// This file is auto-generated, don't edit it
/**
 */
import Util, * as $Util from '@alicloud/tea-util';
import GatewayClient from '@alicloud/gateway-pop';
import OpenApi, * as $OpenApi from '@alicloud/openapi-client';
import OpenApiUtil from '@alicloud/openapi-util';
import EndpointUtil from '@alicloud/endpoint-util';
import * as $tea from '@alicloud/tea-typescript';

export class CallChainInfo extends $tea.Model {
  additionalInfo?: string;
  appName?: string;
  appType?: string;
  children?: CallChainInfo[];
  haveSpan?: boolean;
  logMap?: { [key: string]: {[key: string]: any} };
  logTime?: number;
  parentSpanId?: string;
  pid?: string;
  regionId?: string;
  resultCode?: string;
  rpc?: string;
  rpcId?: string;
  rpcType?: number;
  serverIp?: string;
  span?: number;
  spanId?: string;
  tagMap?: { [key: string]: string };
  traceId?: string;
  static names(): { [key: string]: string } {
    return {
      additionalInfo: 'AdditionalInfo',
      appName: 'AppName',
      appType: 'AppType',
      children: 'Children',
      haveSpan: 'HaveSpan',
      logMap: 'LogMap',
      logTime: 'LogTime',
      parentSpanId: 'ParentSpanId',
      pid: 'Pid',
      regionId: 'RegionId',
      resultCode: 'ResultCode',
      rpc: 'Rpc',
      rpcId: 'RpcId',
      rpcType: 'RpcType',
      serverIp: 'ServerIp',
      span: 'Span',
      spanId: 'SpanId',
      tagMap: 'TagMap',
      traceId: 'TraceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      additionalInfo: 'string',
      appName: 'string',
      appType: 'string',
      children: { 'type': 'array', 'itemType': CallChainInfo },
      haveSpan: 'boolean',
      logMap: { 'type': 'map', 'keyType': 'string', 'valueType': '{[key: string]: any}' },
      logTime: 'number',
      parentSpanId: 'string',
      pid: 'string',
      regionId: 'string',
      resultCode: 'string',
      rpc: 'string',
      rpcId: 'string',
      rpcType: 'number',
      serverIp: 'string',
      span: 'number',
      spanId: 'string',
      tagMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      traceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrafanaWorkspace extends $tea.Model {
  commercial?: boolean;
  deployType?: string;
  description?: string;
  /**
   * @example
   * 1652803200000
   */
  endTime?: number;
  /**
   * @example
   * 创建时间
   */
  gmtCreate?: number;
  grafanaVersion?: string;
  grafanaWorkspaceDomain?: string;
  /**
   * @example
   * on
   */
  grafanaWorkspaceDomainStatus?: string;
  /**
   * @example
   * experts_edition/advanced_edition/standard
   */
  grafanaWorkspaceEdition?: string;
  /**
   * @example
   * g-thisisademo666
   */
  grafanaWorkspaceId?: string;
  /**
   * @example
   * 127.0.0.1:3000
   */
  grafanaWorkspaceIp?: string;
  grafanaWorkspaceName?: string;
  /**
   * @example
   * 10
   */
  maxAccount?: string;
  ntmId?: string;
  personalDomain?: string;
  personalDomainPrefix?: string;
  privateDomain?: string;
  privateIp?: string;
  /**
   * @example
   * http/https
   */
  protocol?: string;
  /**
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  resourceGroupId?: string;
  shareSynced?: boolean;
  /**
   * @example
   * 1.1.1.1
   */
  snatIp?: string;
  /**
   * @example
   * Starting/Running/Stop/DeleteSucceed
   */
  status?: string;
  tags?: GrafanaWorkspaceTags[];
  upgradeVersion?: string[];
  /**
   * @example
   * 66666666
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      commercial: 'commercial',
      deployType: 'deployType',
      description: 'description',
      endTime: 'endTime',
      gmtCreate: 'gmtCreate',
      grafanaVersion: 'grafanaVersion',
      grafanaWorkspaceDomain: 'grafanaWorkspaceDomain',
      grafanaWorkspaceDomainStatus: 'grafanaWorkspaceDomainStatus',
      grafanaWorkspaceEdition: 'grafanaWorkspaceEdition',
      grafanaWorkspaceId: 'grafanaWorkspaceId',
      grafanaWorkspaceIp: 'grafanaWorkspaceIp',
      grafanaWorkspaceName: 'grafanaWorkspaceName',
      maxAccount: 'maxAccount',
      ntmId: 'ntmId',
      personalDomain: 'personalDomain',
      personalDomainPrefix: 'personalDomainPrefix',
      privateDomain: 'privateDomain',
      privateIp: 'privateIp',
      protocol: 'protocol',
      regionId: 'regionId',
      resourceGroupId: 'resourceGroupId',
      shareSynced: 'shareSynced',
      snatIp: 'snatIp',
      status: 'status',
      tags: 'tags',
      upgradeVersion: 'upgradeVersion',
      userId: 'userId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commercial: 'boolean',
      deployType: 'string',
      description: 'string',
      endTime: 'number',
      gmtCreate: 'number',
      grafanaVersion: 'string',
      grafanaWorkspaceDomain: 'string',
      grafanaWorkspaceDomainStatus: 'string',
      grafanaWorkspaceEdition: 'string',
      grafanaWorkspaceId: 'string',
      grafanaWorkspaceIp: 'string',
      grafanaWorkspaceName: 'string',
      maxAccount: 'string',
      ntmId: 'string',
      personalDomain: 'string',
      personalDomainPrefix: 'string',
      privateDomain: 'string',
      privateIp: 'string',
      protocol: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      shareSynced: 'boolean',
      snatIp: 'string',
      status: 'string',
      tags: { 'type': 'array', 'itemType': GrafanaWorkspaceTags },
      upgradeVersion: { 'type': 'array', 'itemType': 'string' },
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrafanaWorkspaceAccount extends $tea.Model {
  /**
   * @example
   * 1
   */
  accountId?: number;
  accountNotes?: string;
  /**
   * @example
   * 131243781293
   */
  aliyunUid?: string;
  /**
   * @example
   * test
   */
  aliyunUserName?: string;
  /**
   * @example
   * 创建时间
   */
  gmtCreate?: number;
  orgs?: GrafanaWorkspaceUserOrg[];
  /**
   * @example
   * aliyun
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      accountId: 'accountId',
      accountNotes: 'accountNotes',
      aliyunUid: 'aliyunUid',
      aliyunUserName: 'aliyunUserName',
      gmtCreate: 'gmtCreate',
      orgs: 'orgs',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountId: 'number',
      accountNotes: 'string',
      aliyunUid: 'string',
      aliyunUserName: 'string',
      gmtCreate: 'number',
      orgs: { 'type': 'array', 'itemType': GrafanaWorkspaceUserOrg },
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrafanaWorkspaceAlertNotification extends $tea.Model {
  /**
   * @example
   * 1
   */
  id?: number;
  /**
   * @example
   * true
   */
  isArms?: boolean;
  /**
   * @example
   * true
   */
  isDefault?: boolean;
  /**
   * @example
   * test
   */
  name?: string;
  /**
   * @example
   * true
   */
  sendReminder?: boolean;
  /**
   * @example
   * {}
   */
  settings?: string;
  /**
   * @example
   * Email
   */
  type?: string;
  /**
   * @example
   * Xfdf******
   */
  uid?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      isArms: 'isArms',
      isDefault: 'isDefault',
      name: 'name',
      sendReminder: 'sendReminder',
      settings: 'settings',
      type: 'type',
      uid: 'uid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      isArms: 'boolean',
      isDefault: 'boolean',
      name: 'string',
      sendReminder: 'boolean',
      settings: 'string',
      type: 'string',
      uid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrafanaWorkspaceArmsAlertConfig extends $tea.Model {
  /**
   * @example
   * true
   */
  armsAlertsEnable?: string;
  armsAlertsWebhookUrl?: string;
  static names(): { [key: string]: string } {
    return {
      armsAlertsEnable: 'armsAlertsEnable',
      armsAlertsWebhookUrl: 'armsAlertsWebhookUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      armsAlertsEnable: 'string',
      armsAlertsWebhookUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrafanaWorkspaceCustomDomain extends $tea.Model {
  /**
   * @example
   * protocol为http时无需填写;
   */
  cert?: string;
  /**
   * @example
   * 1688627798017
   */
  date?: number;
  /**
   * @example
   * mydomain.com
   */
  domain?: string;
  /**
   * @example
   * grafana-cn-***********
   */
  grafanaWorkspaceId?: string;
  /**
   * @example
   * 1
   */
  id?: number;
  /**
   * @example
   * protocol为http时无需填写;
   */
  key?: string;
  /**
   * @example
   * true
   */
  privateZone?: string;
  /**
   * @example
   * https
   */
  protocol?: string;
  /**
   * @example
   * CreateSucceed
   */
  status?: string;
  /**
   * @example
   * /
   */
  uri?: string;
  static names(): { [key: string]: string } {
    return {
      cert: 'cert',
      date: 'date',
      domain: 'domain',
      grafanaWorkspaceId: 'grafanaWorkspaceId',
      id: 'id',
      key: 'key',
      privateZone: 'privateZone',
      protocol: 'protocol',
      status: 'status',
      uri: 'uri',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cert: 'string',
      date: 'number',
      domain: 'string',
      grafanaWorkspaceId: 'string',
      id: 'number',
      key: 'string',
      privateZone: 'string',
      protocol: 'string',
      status: 'string',
      uri: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrafanaWorkspaceDashboardReport extends $tea.Model {
  /**
   * @example
   * 1680861352600
   */
  gmtCreate?: number;
  /**
   * @example
   * grafana-cn-**********
   */
  grafanaWorkspaceId?: string;
  /**
   * @example
   * 1
   */
  id?: number;
  /**
   * @example
   * 1680861352600
   */
  lastSendTime?: number;
  msg?: string;
  name?: string;
  /**
   * @example
   * ******@aliyun.com
   */
  reportChannelTarget?: string;
  /**
   * @example
   * Email
   */
  reportChannelType?: string;
  /**
   * @example
   * Grid,Simple
   */
  reportStyle?: string;
  /**
   * @example
   * Image
   */
  reportType?: string;
  status?: string;
  /**
   * @example
   * 1
   */
  triggerDay?: string;
  /**
   * @example
   * 12:25
   */
  triggerTime?: string;
  /**
   * @example
   * ByWeek
   */
  triggerType?: string;
  /**
   * @example
   * Dashboard URL
   */
  url?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'gmtCreate',
      grafanaWorkspaceId: 'grafanaWorkspaceId',
      id: 'id',
      lastSendTime: 'lastSendTime',
      msg: 'msg',
      name: 'name',
      reportChannelTarget: 'reportChannelTarget',
      reportChannelType: 'reportChannelType',
      reportStyle: 'reportStyle',
      reportType: 'reportType',
      status: 'status',
      triggerDay: 'triggerDay',
      triggerTime: 'triggerTime',
      triggerType: 'triggerType',
      url: 'url',
      userId: 'userId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      grafanaWorkspaceId: 'string',
      id: 'number',
      lastSendTime: 'number',
      msg: 'string',
      name: 'string',
      reportChannelTarget: 'string',
      reportChannelType: 'string',
      reportStyle: 'string',
      reportType: 'string',
      status: 'string',
      triggerDay: 'string',
      triggerTime: 'string',
      triggerType: 'string',
      url: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrafanaWorkspaceDashboardSync extends $tea.Model {
  /**
   * @example
   * testTitle
   */
  dashboardTitle?: string;
  /**
   * @example
   * https://g.console.aliyun.com/d/1098370038733503-14960236-422-3/ack-pro-apiserver
   */
  dashboardURL?: string;
  /**
   * @example
   * xxxdvxsea
   */
  dashboardUid?: string;
  /**
   * @example
   * 123456
   */
  folderId?: string;
  /**
   * @example
   * test
   */
  folderTitle?: string;
  /**
   * @example
   * https://g.console.aliyun.com/d/1098370038733503-14960236-422-3/ack-pro-apiserver
   */
  folderURL?: string;
  /**
   * @example
   * vxeupqn
   */
  folderUid?: string;
  /**
   * @example
   * 1
   */
  orgId?: string;
  /**
   * @example
   * user123
   */
  orgName?: string;
  /**
   * @example
   * normal
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      dashboardTitle: 'dashboardTitle',
      dashboardURL: 'dashboardURL',
      dashboardUid: 'dashboardUid',
      folderId: 'folderId',
      folderTitle: 'folderTitle',
      folderURL: 'folderURL',
      folderUid: 'folderUid',
      orgId: 'orgId',
      orgName: 'orgName',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dashboardTitle: 'string',
      dashboardURL: 'string',
      dashboardUid: 'string',
      folderId: 'string',
      folderTitle: 'string',
      folderURL: 'string',
      folderUid: 'string',
      orgId: 'string',
      orgName: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrafanaWorkspaceDataBackup extends $tea.Model {
  /**
   * @example
   * 1680861352600
   */
  gmtCreate?: number;
  /**
   * @example
   * 1680861352600
   */
  gmtModified?: number;
  /**
   * @example
   * grafana-cn-**********
   */
  grafanaWorkspaceId?: string;
  /**
   * @example
   * 1
   */
  id?: number;
  msg?: string;
  processName?: string;
  processStatus?: string;
  /**
   * @example
   * User
   */
  subType?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      grafanaWorkspaceId: 'grafanaWorkspaceId',
      id: 'id',
      msg: 'msg',
      processName: 'processName',
      processStatus: 'processStatus',
      subType: 'subType',
      userId: 'userId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      gmtModified: 'number',
      grafanaWorkspaceId: 'string',
      id: 'number',
      msg: 'string',
      processName: 'string',
      processStatus: 'string',
      subType: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrafanaWorkspaceIniBackup extends $tea.Model {
  ext?: string;
  /**
   * @example
   * 1680861352600
   */
  gmtCreate?: number;
  /**
   * @example
   * 1680861352600
   */
  gmtModified?: number;
  /**
   * @example
   * grafana-cn-**********
   */
  grafanaWorkspaceId?: string;
  /**
   * @example
   * 1
   */
  id?: number;
  msg?: string;
  processName?: string;
  processStatus?: string;
  /**
   * @example
   * User
   */
  subType?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      ext: 'ext',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      grafanaWorkspaceId: 'grafanaWorkspaceId',
      id: 'id',
      msg: 'msg',
      processName: 'processName',
      processStatus: 'processStatus',
      subType: 'subType',
      userId: 'userId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ext: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      grafanaWorkspaceId: 'string',
      id: 'number',
      msg: 'string',
      processName: 'string',
      processStatus: 'string',
      subType: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrafanaWorkspaceIniProperty extends $tea.Model {
  defaultValue?: string;
  description?: string;
  example?: string;
  key?: string;
  secret?: boolean;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      defaultValue: 'defaultValue',
      description: 'description',
      example: 'example',
      key: 'key',
      secret: 'secret',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultValue: 'string',
      description: 'string',
      example: 'string',
      key: 'string',
      secret: 'boolean',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrafanaWorkspaceIniSection extends $tea.Model {
  propertys?: GrafanaWorkspaceIniProperty[];
  section?: string;
  static names(): { [key: string]: string } {
    return {
      propertys: 'propertys',
      section: 'section',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertys: { 'type': 'array', 'itemType': GrafanaWorkspaceIniProperty },
      section: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrafanaWorkspaceIntegration extends $tea.Model {
  datasourceAmount?: number;
  integrationId?: string;
  integrationName?: string;
  previews?: GrafanaWorkspaceIntegrationPreview[];
  status?: string;
  supportRegions?: string[];
  static names(): { [key: string]: string } {
    return {
      datasourceAmount: 'datasourceAmount',
      integrationId: 'integrationId',
      integrationName: 'integrationName',
      previews: 'previews',
      status: 'status',
      supportRegions: 'supportRegions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      datasourceAmount: 'number',
      integrationId: 'string',
      integrationName: 'string',
      previews: { 'type': 'array', 'itemType': GrafanaWorkspaceIntegrationPreview },
      status: 'string',
      supportRegions: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrafanaWorkspaceIntegrationDataSource extends $tea.Model {
  clusterType?: string;
  datasourceId?: string;
  datasourceName?: string;
  datasourceUrl?: string;
  description?: string;
  exploreUrl?: string;
  extra?: { [key: string]: string };
  folderUrl?: string;
  regionId?: string;
  status?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      clusterType: 'clusterType',
      datasourceId: 'datasourceId',
      datasourceName: 'datasourceName',
      datasourceUrl: 'datasourceUrl',
      description: 'description',
      exploreUrl: 'exploreUrl',
      extra: 'extra',
      folderUrl: 'folderUrl',
      regionId: 'regionId',
      status: 'status',
      type: 'type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterType: 'string',
      datasourceId: 'string',
      datasourceName: 'string',
      datasourceUrl: 'string',
      description: 'string',
      exploreUrl: 'string',
      extra: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      folderUrl: 'string',
      regionId: 'string',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrafanaWorkspaceIntegrationDetail extends $tea.Model {
  dataSources?: GrafanaWorkspaceIntegrationDataSource[];
  integrationId?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      dataSources: 'dataSources',
      integrationId: 'integrationId',
      status: 'status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSources: { 'type': 'array', 'itemType': GrafanaWorkspaceIntegrationDataSource },
      integrationId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrafanaWorkspaceIntegrationPreview extends $tea.Model {
  id?: string;
  image?: string;
  name?: string;
  thumbnail?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      image: 'image',
      name: 'name',
      thumbnail: 'thumbnail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      image: 'string',
      name: 'string',
      thumbnail: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrafanaWorkspaceMoveProcess extends $tea.Model {
  /**
   * @example
   * 1680861352600
   */
  gmtCreate?: number;
  /**
   * @example
   * 1680861352600
   */
  gmtModified?: number;
  /**
   * @example
   * grafana-cn-**********
   */
  grafanaWorkspaceId?: string;
  /**
   * @example
   * 1
   */
  id?: number;
  msg?: string;
  processName?: string;
  processStatus?: string;
  /**
   * @example
   * User
   */
  subType?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      grafanaWorkspaceId: 'grafanaWorkspaceId',
      id: 'id',
      msg: 'msg',
      processName: 'processName',
      processStatus: 'processStatus',
      subType: 'subType',
      userId: 'userId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtCreate: 'number',
      gmtModified: 'number',
      grafanaWorkspaceId: 'string',
      id: 'number',
      msg: 'string',
      processName: 'string',
      processStatus: 'string',
      subType: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrafanaWorkspaceNews extends $tea.Model {
  date?: number;
  description?: string;
  image?: string;
  link?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      date: 'date',
      description: 'description',
      image: 'image',
      link: 'link',
      title: 'title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      date: 'number',
      description: 'string',
      image: 'string',
      link: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrafanaWorkspaceOperateLog extends $tea.Model {
  date?: number;
  detail?: string;
  grafanaWorkspaceId?: string;
  id?: number;
  operatorId?: string;
  static names(): { [key: string]: string } {
    return {
      date: 'date',
      detail: 'detail',
      grafanaWorkspaceId: 'grafanaWorkspaceId',
      id: 'id',
      operatorId: 'operatorId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      date: 'number',
      detail: 'string',
      grafanaWorkspaceId: 'string',
      id: 'number',
      operatorId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrafanaWorkspaceOrg extends $tea.Model {
  /**
   * @example
   * 1
   */
  id?: number;
  /**
   * @example
   * main org
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrafanaWorkspaceTrans extends $tea.Model {
  apiUrl?: string;
  authType?: string;
  gmtCreate?: number;
  gmtModified?: number;
  grafanaWorkspaceId?: string;
  id?: number;
  msg?: string;
  processStatus?: string;
  transDetails?: GrafanaWorkspaceTransDetail[];
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      apiUrl: 'apiUrl',
      authType: 'authType',
      gmtCreate: 'gmtCreate',
      gmtModified: 'gmtModified',
      grafanaWorkspaceId: 'grafanaWorkspaceId',
      id: 'id',
      msg: 'msg',
      processStatus: 'processStatus',
      transDetails: 'transDetails',
      userId: 'userId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiUrl: 'string',
      authType: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      grafanaWorkspaceId: 'string',
      id: 'number',
      msg: 'string',
      processStatus: 'string',
      transDetails: { 'type': 'array', 'itemType': GrafanaWorkspaceTransDetail },
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrafanaWorkspaceTransDetail extends $tea.Model {
  dashboardAmount?: number;
  dataSourceAmount?: number;
  original?: number;
  originalName?: string;
  target?: number;
  targetName?: string;
  static names(): { [key: string]: string } {
    return {
      dashboardAmount: 'dashboardAmount',
      dataSourceAmount: 'dataSourceAmount',
      original: 'original',
      originalName: 'originalName',
      target: 'target',
      targetName: 'targetName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dashboardAmount: 'number',
      dataSourceAmount: 'number',
      original: 'number',
      originalName: 'string',
      target: 'number',
      targetName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrafanaWorkspaceUserCert extends $tea.Model {
  /**
   * @example
   * 8096753
   */
  id?: string;
  /**
   * @example
   * cert-7700050 [grafana.tongtong-max.cn]
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrafanaWorkspaceUserOrg extends $tea.Model {
  /**
   * @example
   * 1
   */
  orgId?: number;
  /**
   * @example
   * main org
   */
  orgName?: string;
  /**
   * @example
   * admin
   */
  role?: string;
  static names(): { [key: string]: string } {
    return {
      orgId: 'orgId',
      orgName: 'orgName',
      role: 'role',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orgId: 'number',
      orgName: 'string',
      role: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrafanaWorkspaceVpcConfig extends $tea.Model {
  /**
   * @example
   * fc、ansm
   */
  fcConfig?: string;
  /**
   * @example
   * 1
   */
  id?: number;
  installMsg?: string;
  /**
   * @example
   * CreateSucceed
   */
  installStatus?: string;
  /**
   * @example
   * 北京VPC-A通道
   */
  name?: string;
  /**
   * @example
   * cn-beijing
   */
  regionId?: string;
  /**
   * @example
   * sg-6we94uvybteyc******
   */
  securityGroupId?: string;
  /**
   * @example
   * 10983***********
   */
  userId?: string;
  /**
   * @example
   * vsw-6we3**********
   */
  vSwitchId?: string;
  /**
   * @example
   * vpc-6wehr2x**********
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      fcConfig: 'fcConfig',
      id: 'id',
      installMsg: 'installMsg',
      installStatus: 'installStatus',
      name: 'name',
      regionId: 'regionId',
      securityGroupId: 'securityGroupId',
      userId: 'userId',
      vSwitchId: 'vSwitchId',
      vpcId: 'vpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fcConfig: 'string',
      id: 'number',
      installMsg: 'string',
      installStatus: 'string',
      name: 'string',
      regionId: 'string',
      securityGroupId: 'string',
      userId: 'string',
      vSwitchId: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrafanaWorkspaceVpcRegion extends $tea.Model {
  /**
   * @example
   * cn-beijing
   */
  regionId?: string;
  /**
   * @example
   * 华北2（北京）
   */
  regionName?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'regionId',
      regionName: 'regionName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      regionName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrafanaWorkspaceVpcRegionDetail extends $tea.Model {
  /**
   * @example
   * fc、ansm
   */
  fcConfig?: string;
  /**
   * @example
   * 配置ID
   */
  id?: number;
  /**
   * @example
   * Uninitialized
   */
  installStatus?: string;
  /**
   * @example
   * vpc-abc*****
   */
  name?: string;
  /**
   * @example
   * cn-beijing
   */
  regionId?: string;
  securityGroupId?: string;
  securityGroupIds?: string[];
  /**
   * @example
   * 10988**********
   */
  userId?: string;
  vSwitchId?: string;
  vSwitchIds?: string[];
  /**
   * @example
   * vpc-2ze4siu98**********
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      fcConfig: 'fcConfig',
      id: 'id',
      installStatus: 'installStatus',
      name: 'name',
      regionId: 'regionId',
      securityGroupId: 'securityGroupId',
      securityGroupIds: 'securityGroupIds',
      userId: 'userId',
      vSwitchId: 'vSwitchId',
      vSwitchIds: 'vSwitchIds',
      vpcId: 'vpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fcConfig: 'string',
      id: 'number',
      installStatus: 'string',
      name: 'string',
      regionId: 'string',
      securityGroupId: 'string',
      securityGroupIds: { 'type': 'array', 'itemType': 'string' },
      userId: 'string',
      vSwitchId: 'string',
      vSwitchIds: { 'type': 'array', 'itemType': 'string' },
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDataResponse extends $tea.Model {
  results?: string;
  static names(): { [key: string]: string } {
    return {
      results: 'results',
    };
  }

  static types(): { [key: string]: any } {
    return {
      results: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DataBonreeSDKConfigModuleConfigDefaultConfigValue extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the configuration is enabled.
   * 
   * @example
   * true
   */
  enable?: boolean;
  static names(): { [key: string]: string } {
    return {
      enable: 'enable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DataBonreeSDKConfigModuleConfigVersionConfigsValue extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the custom configuration is used.
   * 
   * @example
   * true
   */
  useCustom?: boolean;
  /**
   * @remarks
   * The custom configuration.
   */
  customConfig?: { [key: string]: DataBonreeSDKConfigModuleConfigVersionConfigsValueCustomConfigValue };
  /**
   * @remarks
   * The description of the version configuration.
   */
  description?: string;
  /**
   * @remarks
   * The time when the version configuration was updated.
   * 
   * @example
   * 1721112372055
   */
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      useCustom: 'useCustom',
      customConfig: 'customConfig',
      description: 'description',
      updateTime: 'updateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      useCustom: 'boolean',
      customConfig: { 'type': 'map', 'keyType': 'string', 'valueType': DataBonreeSDKConfigModuleConfigVersionConfigsValueCustomConfigValue },
      description: 'string',
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DataBonreeSDKConfigModuleConfigVersionConfigsValueCustomConfigValue extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the configuration is enabled.
   * 
   * @example
   * true
   */
  enable?: boolean;
  static names(): { [key: string]: string } {
    return {
      enable: 'enable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAliClusterIdsToPrometheusGlobalViewRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of clusters. Separate multiple IDs with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * cd1d55bef19904324a20ed0ebb86caa5c,c5b48729918ab4745a24482ac29d0973a, c00a94896641449098bf24931e4166003, cd174485c09384060ba542bc1be1185a4
   */
  clusterIds?: string;
  /**
   * @remarks
   * The ID of the global aggregation instance.
   * 
   * This parameter is required.
   * 
   * @example
   * global-v2-cn-1478326682034601-vss8pd0i
   */
  globalViewClusterId?: string;
  /**
   * @remarks
   * The name of the global aggregation instance.
   * 
   * This parameter is required.
   * 
   * @example
   * zyGlobalView
   */
  groupName?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterIds: 'ClusterIds',
      globalViewClusterId: 'GlobalViewClusterId',
      groupName: 'GroupName',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterIds: 'string',
      globalViewClusterId: 'string',
      groupName: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAliClusterIdsToPrometheusGlobalViewResponseBody extends $tea.Model {
  /**
   * @remarks
   * Status code. 200 is success, other status codes are exceptions.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The information about the array object.
   */
  data?: AddAliClusterIdsToPrometheusGlobalViewResponseBodyData;
  /**
   * @remarks
   * Returns a hint message for the result.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * F7781D4A-2818-41E7-B7BB-79D809E9****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: AddAliClusterIdsToPrometheusGlobalViewResponseBodyData,
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAliClusterIdsToPrometheusGlobalViewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddAliClusterIdsToPrometheusGlobalViewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddAliClusterIdsToPrometheusGlobalViewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGrafanaRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the Container Service for Kubernetes (ACK) cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The abbreviation of the software that is supported by Application Real-Time Monitoring Service (ARMS). Valid values (case-insensitive): `ASM`, `IoT`, and `Flink`.
   * 
   * This parameter is required.
   * 
   * @example
   * asm
   */
  integration?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      integration: 'Integration',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      integration: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGrafanaResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the call was successful.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 1A9C645C-C83F-4C9D-8CCB-29BEC9E1****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddGrafanaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddGrafanaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddGrafanaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddIntegrationRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the Container Service for Kubernetes (ACK) cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The abbreviation of the software that is supported by Application Real-Time Monitoring Service (ARMS). Valid values (case-insensitive): `ASM`, `IoT`, and `Flink`.
   * 
   * This parameter is required.
   * 
   * @example
   * asm
   */
  integration?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      integration: 'Integration',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      integration: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddIntegrationResponseBody extends $tea.Model {
  /**
   * @remarks
   * Status code. 200 means success, other status codes are exceptions.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Indicates whether the call was successful.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The prompt information of the returned result.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 1A9C645C-C83F-4C9D-8CCB-29BEC9E1****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddIntegrationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddIntegrationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddIntegrationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPrometheusGlobalViewRequest extends $tea.Model {
  /**
   * @remarks
   * The queried global aggregation instances. The value is a JSON string.
   * 
   * This parameter is required.
   * 
   * @example
   * [         {             "sourceName": "Data source name- ArmsPrometheus No.1",             "sourceType":"AlibabaPrometheus",             "userId":"UserID",             "clusterId":"ClusterId",         },         {             "sourceName": "Data source name - MetrcStore No.2",             "sourceType":"MetricStore",             "dataSource":"MetricStore remote read address",             "extras":{                 "username":"BasicAuthUsername",                 "password":"BasicAuthPassword"             }         },         {             "sourceName": "Custom ",             "sourceType":"CustomPrometheus",             "dataSource":"Build your own Prometheus data source remoteread address",             "extras":{                 "username":"BasicAuthUsername",                 "password":"BasicAuthPassword"             }         },         {           	"sourceName": "Other one ",             "sourceType":"Others",             "dataSource":"Other data sources such as Tencent remoteread address",             "headers":{                 "AnyHeaderToFill":"Headers to be populated"             },             "extras":{                 "username":"BasicAuthUsername",                 "password":"BasicAuthPassword"             }         }   // ....... more addre ]
   */
  clusters?: string;
  /**
   * @remarks
   * The name of the aggregation instance.
   * 
   * This parameter is required.
   * 
   * @example
   * zyGlobalView
   */
  groupName?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The resource group ID.
   * 
   * @example
   * rg-aek2eq4pecazwfy
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The list of tags.
   */
  tag?: AddPrometheusGlobalViewRequestTag[];
  static names(): { [key: string]: string } {
    return {
      clusters: 'Clusters',
      groupName: 'GroupName',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusters: 'string',
      groupName: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      tag: { 'type': 'array', 'itemType': AddPrometheusGlobalViewRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPrometheusGlobalViewResponseBody extends $tea.Model {
  /**
   * @remarks
   * 状态码。说明 200表示成功。
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The information about the array object.
   */
  data?: AddPrometheusGlobalViewResponseBodyData;
  /**
   * @remarks
   * 返回结果的提示信息。
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * 34ED024E-9E31-434A-9E4E-D9D15C3****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: AddPrometheusGlobalViewResponseBodyData,
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPrometheusGlobalViewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddPrometheusGlobalViewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddPrometheusGlobalViewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPrometheusGlobalViewByAliClusterIdsRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of clusters. Separate multiple IDs with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * cd1d55bef19904324a20ed0ebb86caa5c,c5b48729918ab4745a24482ac29d0973a, c00a94896641449098bf24931e4166003, cd174485c09384060ba542bc1be1185a4
   */
  clusterIds?: string;
  /**
   * @remarks
   * The name of the global aggregation instance.
   * 
   * This parameter is required.
   * 
   * @example
   * zyGlobalView
   */
  groupName?: string;
  /**
   * @remarks
   * The identifier to identify the service if custom dashboards are created for the specified clusters.
   * 
   * @example
   * adcp
   */
  productCode?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterIds: 'ClusterIds',
      groupName: 'GroupName',
      productCode: 'ProductCode',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterIds: 'string',
      groupName: 'string',
      productCode: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPrometheusGlobalViewByAliClusterIdsResponseBody extends $tea.Model {
  /**
   * @remarks
   * Status code. 200 is success, other status codes are exceptions.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The struct returned.
   */
  data?: AddPrometheusGlobalViewByAliClusterIdsResponseBodyData;
  /**
   * @remarks
   * Returns a hint message for the result.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * 3A0EA2AF-C9B3-555C-B9D5-5DD8F5EF98A9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: AddPrometheusGlobalViewByAliClusterIdsResponseBodyData,
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPrometheusGlobalViewByAliClusterIdsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddPrometheusGlobalViewByAliClusterIdsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddPrometheusGlobalViewByAliClusterIdsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPrometheusInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the Prometheus instance for Remote Write.
   * 
   * This parameter is required.
   * 
   * @example
   * notificationpolicy_test
   */
  name?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The type of the Prometheus instance. Only Prometheus instances for Remote Write is supported. Set the value to RW.
   * 
   * This parameter is required.
   * 
   * @example
   * RW
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      regionId: 'RegionId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      regionId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPrometheusInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The struct returned. { "RequestId": the request ID, "Data": "{ "clusterType": the cluster type, "remoteWriteUrl": the public URL for remote write, "internetGrafanaUrl": the internal URL for Grafana, "authToken": indicates whether authentication is enabled, "internetPushGatewayUrl": the internal URL for Pushgateway, "clusterId": the cluster ID, "internetRemoteReadUrl": the internal URL for remote read, "remoteReadUrl": the public URL for remote read, "grafanaUrl": the public URL for Grafana, "pushGatewayUrl": the public URL for Pushgateway, "internetRemoteWriteUrl": the internal URL for remote write}" }
   * 
   * @example
   * {
   *   "RequestId": "1293091C-54AD-50FE-B787-E314B94B35AB",
   *   "Data": "{
   *   "clusterType":"remote-write-prometheus",
   *   "remoteWriteUrl":"http://cn-hu/api/v3/write",
   *   "internetGrafanaUrl":"https://cn-hanga/cn-hangzhou",
   *   "authToken":false,
   *   "internetPushGatewayUrl":"https://cangzhou/api/v2",
   *   "clusterId":"vrju1lj3sa|123456",
   *   "internetRemoteReadUrl":"https://cn-hangzh67cn-hangzhou/api/v1/read",
   *   "remoteReadUrl":"http://cn-hanou/api/v1/read",
   *   "grafanaUrl":"http://cn-angzhou",
   *   "pushGatewayUrl":"htt1lj3sa/cn-hangzhou/api/v2",
   *   "internetRemoteWriteUrl":"httpsngzhou/api/v3/write"}"
   * }
   */
  data?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9319A57D-2D9E-472A-B69B-CF3CD16D****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPrometheusInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddPrometheusInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddPrometheusInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPrometheusIntegrationRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the Prometheus instance. Only a Prometheus instance for Container Service or a Prometheus instance for ECS is supported.
   * 
   * This parameter is required.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The type of the integration.
   * 
   * This parameter is required.
   * 
   * @example
   * kafka, mysql, redis, snmp, emr, nubela, and tidb
   */
  integrationType?: string;
  /**
   * @remarks
   * The configurations of the exporter. The value is a JSON string.
   * 
   * This parameter is required.
   * 
   * @example
   * {"port":"5554","name":"kafka-test12","kafka_instance":"kafka-test","__label_value":"kafka-test","scrape_interval":33,"metrics_path":"/metrics","__label_key":"kafka-test"}
   */
  param?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      integrationType: 'IntegrationType',
      param: 'Param',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      integrationType: 'string',
      param: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPrometheusIntegrationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code or error code.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The struct returned.
   */
  data?: AddPrometheusIntegrationResponseBodyData;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 3703B98C-335E-5BA7-972E-F90E9E768A85
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: AddPrometheusIntegrationResponseBodyData,
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPrometheusIntegrationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddPrometheusIntegrationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddPrometheusIntegrationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddRecordingRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The custom recording rule. The value is in the YAML format.
   * 
   * This parameter is required.
   * 
   * @example
   * groups: - name: "recording_demo"   rules:   - expr: "sum(jvm_memory_max_bytes)"     record: "rate_coredns_demo"
   */
  ruleYaml?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
      ruleYaml: 'RuleYaml',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
      ruleYaml: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddRecordingRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The status of the response.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9FEA6D00-317F-45E3-9004-7FB8B0B7****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddRecordingRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddRecordingRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddRecordingRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTagToFlinkClusterRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the Prometheus instance.
   * 
   * This parameter is required.
   * 
   * @example
   * c5defa51f******c92bd2ef5fb093269
   */
  clusterId?: string;
  /**
   * @remarks
   * The ID of the Flink workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * ab18f***93744d
   */
  flinkWorkSpaceId?: string;
  /**
   * @remarks
   * The name of the Flink workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * flink-demo
   */
  flinkWorkSpaceName?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account to which the Flink workspace belongs.
   * 
   * This parameter is required.
   * 
   * @example
   * 198608******7619
   */
  targetUserId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      flinkWorkSpaceId: 'FlinkWorkSpaceId',
      flinkWorkSpaceName: 'FlinkWorkSpaceName',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      targetUserId: 'TargetUserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      flinkWorkSpaceId: 'string',
      flinkWorkSpaceName: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      targetUserId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTagToFlinkClusterResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Indicates whether the business logic was executed. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * false
   */
  data?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2FC13182-B9AF-4E6B-BE51-72669B7C****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTagToFlinkClusterResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddTagToFlinkClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddTagToFlinkClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AppendInstancesToPrometheusGlobalViewRequest extends $tea.Model {
  /**
   * @remarks
   * The list of global aggregation instances. The value is a JSON string.
   * 
   * This parameter is required.
   * 
   * @example
   * [ { "sourceName": "Data source name- ArmsPrometheus No.1", "sourceType":"AlibabaPrometheus", "userId":"UserID", "clusterId":"ClusterId", }, { "sourceName": "Data source name - MetrcStore No.2", "sourceType":"MetricStore", "dataSource":"Remote read endpoint of the MetricStore", "extras":{ "username":"BasicAuthUsername", "password":"BasicAuthPassword" } }, { "sourceName": "Custom ", "sourceType":"CustomPrometheus", "dataSource":"Remote read endpoint of the self-managed Prometheus data source", "extras":{ "username":"BasicAuthUsername", "password":"BasicAuthPassword" } }, { "sourceName": "Other one ", "sourceType":"Others", "dataSource":"Endpoint of another data source such as Tencent remote read", "headers":{ "AnyHeaderToFill":"Headers to be filled" }, "extras":{ "username":"BasicAuthUsername", "password":"BasicAuthPassword" } } // ....... more addre ]
   */
  clusters?: string;
  /**
   * @remarks
   * The ID of the global aggregation instance.
   * 
   * This parameter is required.
   * 
   * @example
   * global-v2-cn-1670100631025794-6gjc0qgb
   */
  globalViewClusterId?: string;
  /**
   * @remarks
   * The name of the global aggregation instance.
   * 
   * This parameter is required.
   * 
   * @example
   * zyGlobalView
   */
  groupName?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusters: 'Clusters',
      globalViewClusterId: 'GlobalViewClusterId',
      groupName: 'GroupName',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusters: 'string',
      globalViewClusterId: 'string',
      groupName: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AppendInstancesToPrometheusGlobalViewResponseBody extends $tea.Model {
  /**
   * @remarks
   * Status code. 200 means success, other status codes are exceptions.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The information about the array object.
   */
  data?: AppendInstancesToPrometheusGlobalViewResponseBodyData;
  /**
   * @remarks
   * Additional message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * 27E653FA-5958-45BE-8AA9-14D884DC****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: AppendInstancesToPrometheusGlobalViewResponseBodyData,
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AppendInstancesToPrometheusGlobalViewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AppendInstancesToPrometheusGlobalViewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AppendInstancesToPrometheusGlobalViewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyScenarioRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the application.
   * 
   * This parameter is required.
   * 
   * @example
   * b590lhguqs@28f515462f******
   */
  appId?: string;
  /**
   * @remarks
   * The configuration of the business monitoring job. The value is a JSON string. For more information about this parameter, see the following additional information about the **Config** parameter.
   * 
   * This parameter is required.
   * 
   * @example
   * {"rpcType":"0","nameMatchType":"EQUALS","service":"/api/pop/test","operator":"and","filterItems":[{"type":"HttpHeaders","key":"uid","opt":"==","value":"123456789"}],"group":{"type":"HttpRequestParameters","key":"name"}}
   */
  config?: { [key: string]: any };
  /**
   * @remarks
   * The name of the business monitoring job.
   * 
   * This parameter is required.
   * 
   * @example
   * ScenarioName
   */
  name?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-zhangjaikou
   */
  regionId?: string;
  /**
   * @remarks
   * The scenario where you want to use the business monitoring job. Valid values:
   * 
   * *   `USER-DEFINED`: user-defined. This is the default value.
   * *   `EDAS-ROLLOUT`: application release in Enterprise Distributed Application Service (EDAS)
   * *   `OAM-ROLLOUT`: application release based on Open Application Model (OAM)
   * *   `MSC-CANARY`: canary release based on Microservice Engine (MSE)
   * 
   * @example
   * USER-DEFINED
   */
  scenario?: string;
  /**
   * @remarks
   * The code of the business monitoring job. This parameter is not required when you create a business monitoring job. However, this parameter is required when you update a business monitoring job.
   * 
   * @example
   * a9f8****
   */
  sign?: string;
  /**
   * @remarks
   * Specifies whether to record business parameters to the trace marked with the coloring sign.
   * 
   * *   `true`
   * *   `false`: This is the default value.
   * 
   * @example
   * false
   */
  snDump?: boolean;
  /**
   * @remarks
   * Specifies whether traffic in the trace marked with the coloring sign is all collected.
   * 
   * *   `true`
   * *   `false`: This is the default value.
   * 
   * @example
   * false
   */
  snForce?: boolean;
  /**
   * @remarks
   * Specifies whether to count traffic based on the coloring sign.
   * 
   * *   `true`
   * *   `false`: This is the default value.
   * 
   * @example
   * false
   */
  snStat?: boolean;
  /**
   * @remarks
   * Specifies whether the coloring sign is transparently passed down to downstream application nodes in the trace.
   * 
   * *   `true`
   * *   `false`: This is the default value.
   * 
   * @example
   * false
   */
  snTransfer?: boolean;
  /**
   * @remarks
   * Specifies whether the operation is an update operation.
   * 
   * *   `true`: update
   * *   `false`: insert
   * 
   * This parameter is required.
   * 
   * @example
   * false
   */
  updateOption?: boolean;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      config: 'Config',
      name: 'Name',
      regionId: 'RegionId',
      scenario: 'Scenario',
      sign: 'Sign',
      snDump: 'SnDump',
      snForce: 'SnForce',
      snStat: 'SnStat',
      snTransfer: 'SnTransfer',
      updateOption: 'UpdateOption',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      config: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      name: 'string',
      regionId: 'string',
      scenario: 'string',
      sign: 'string',
      snDump: 'boolean',
      snForce: 'boolean',
      snStat: 'boolean',
      snTransfer: 'boolean',
      updateOption: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyScenarioShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the application.
   * 
   * This parameter is required.
   * 
   * @example
   * b590lhguqs@28f515462f******
   */
  appId?: string;
  /**
   * @remarks
   * The configuration of the business monitoring job. The value is a JSON string. For more information about this parameter, see the following additional information about the **Config** parameter.
   * 
   * This parameter is required.
   * 
   * @example
   * {"rpcType":"0","nameMatchType":"EQUALS","service":"/api/pop/test","operator":"and","filterItems":[{"type":"HttpHeaders","key":"uid","opt":"==","value":"123456789"}],"group":{"type":"HttpRequestParameters","key":"name"}}
   */
  configShrink?: string;
  /**
   * @remarks
   * The name of the business monitoring job.
   * 
   * This parameter is required.
   * 
   * @example
   * ScenarioName
   */
  name?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-zhangjaikou
   */
  regionId?: string;
  /**
   * @remarks
   * The scenario where you want to use the business monitoring job. Valid values:
   * 
   * *   `USER-DEFINED`: user-defined. This is the default value.
   * *   `EDAS-ROLLOUT`: application release in Enterprise Distributed Application Service (EDAS)
   * *   `OAM-ROLLOUT`: application release based on Open Application Model (OAM)
   * *   `MSC-CANARY`: canary release based on Microservice Engine (MSE)
   * 
   * @example
   * USER-DEFINED
   */
  scenario?: string;
  /**
   * @remarks
   * The code of the business monitoring job. This parameter is not required when you create a business monitoring job. However, this parameter is required when you update a business monitoring job.
   * 
   * @example
   * a9f8****
   */
  sign?: string;
  /**
   * @remarks
   * Specifies whether to record business parameters to the trace marked with the coloring sign.
   * 
   * *   `true`
   * *   `false`: This is the default value.
   * 
   * @example
   * false
   */
  snDump?: boolean;
  /**
   * @remarks
   * Specifies whether traffic in the trace marked with the coloring sign is all collected.
   * 
   * *   `true`
   * *   `false`: This is the default value.
   * 
   * @example
   * false
   */
  snForce?: boolean;
  /**
   * @remarks
   * Specifies whether to count traffic based on the coloring sign.
   * 
   * *   `true`
   * *   `false`: This is the default value.
   * 
   * @example
   * false
   */
  snStat?: boolean;
  /**
   * @remarks
   * Specifies whether the coloring sign is transparently passed down to downstream application nodes in the trace.
   * 
   * *   `true`
   * *   `false`: This is the default value.
   * 
   * @example
   * false
   */
  snTransfer?: boolean;
  /**
   * @remarks
   * Specifies whether the operation is an update operation.
   * 
   * *   `true`: update
   * *   `false`: insert
   * 
   * This parameter is required.
   * 
   * @example
   * false
   */
  updateOption?: boolean;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      configShrink: 'Config',
      name: 'Name',
      regionId: 'RegionId',
      scenario: 'Scenario',
      sign: 'Sign',
      snDump: 'SnDump',
      snForce: 'SnForce',
      snStat: 'SnStat',
      snTransfer: 'SnTransfer',
      updateOption: 'UpdateOption',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      configShrink: 'string',
      name: 'string',
      regionId: 'string',
      scenario: 'string',
      sign: 'string',
      snDump: 'boolean',
      snForce: 'boolean',
      snStat: 'boolean',
      snTransfer: 'boolean',
      updateOption: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyScenarioResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EA24D522-AD35-47B8-8CB2-ADBC38******
   */
  requestId?: string;
  /**
   * @remarks
   * The code of the business monitoring job, which is the coloring sign.
   * 
   * @example
   * 2b97****
   */
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyScenarioResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ApplyScenarioResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ApplyScenarioResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindPrometheusGrafanaInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the Prometheus instance.
   * 
   * This parameter is required.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The ID of the Grafana workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * grafana-bp1*****
   */
  grafanaInstanceId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group to which the Prometheus instance belongs.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      grafanaInstanceId: 'GrafanaInstanceId',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      grafanaInstanceId: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindPrometheusGrafanaInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 27E653FA-5958-45BE-8AA9-14D884DC****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'boolean',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindPrometheusGrafanaInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BindPrometheusGrafanaInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BindPrometheusGrafanaInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BlockAlarmNotificationRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert.
   * 
   * For more information about how to obtain the ID of an alert, see [ListAlertEvents](https://help.aliyun.com/document_detail/2612346.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 133
   */
  alarmId?: number;
  /**
   * @remarks
   * The ID of the alert handler.
   * 
   * @example
   * 2044049
   */
  handlerId?: number;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The number of seconds that elapse before alert notifications are blocked. Unit: seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 180
   */
  timeout?: number;
  static names(): { [key: string]: string } {
    return {
      alarmId: 'AlarmId',
      handlerId: 'HandlerId',
      regionId: 'RegionId',
      timeout: 'Timeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmId: 'number',
      handlerId: 'number',
      regionId: 'string',
      timeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BlockAlarmNotificationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 626037F5-FDEB-45B0-804C-B3C92797****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  result?: boolean;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      requestId: 'string',
      result: 'boolean',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BlockAlarmNotificationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BlockAlarmNotificationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BlockAlarmNotificationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeAlarmSeverityRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert.
   * 
   * For more information about how to obtain the ID of an alert, see [ListAlertEvents](https://help.aliyun.com/document_detail/2612346.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 155
   */
  alarmId?: number;
  /**
   * @remarks
   * The ID of the handler.
   * 
   * @example
   * 2046076
   */
  handlerId?: number;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The severity level of the alert. Valid values: P1, P2, P3, and P4. P4 indicates the lowest severity, whereas P1 indicates the highest severity.
   * 
   * This parameter is required.
   * 
   * @example
   * P1
   */
  severity?: string;
  static names(): { [key: string]: string } {
    return {
      alarmId: 'AlarmId',
      handlerId: 'HandlerId',
      regionId: 'RegionId',
      severity: 'Severity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmId: 'number',
      handlerId: 'number',
      regionId: 'string',
      severity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeAlarmSeverityResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F7781D4A-2818-41E7-B7BB-79D809E9****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the severity level was modified.
   * 
   * - `true`: The severity level was modified.
   * - `false`: The severity level failed to be modified.
   * 
   * @example
   * true
   */
  result?: boolean;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * - true
   * - false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      requestId: 'string',
      result: 'boolean',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeAlarmSeverityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ChangeAlarmSeverityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ChangeAlarmSeverityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeResourceGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the new resource group. You can view the available resource groups in the Resource Management console.
   * 
   * This parameter is required.
   * 
   * @example
   * rg-aek2vezare****
   */
  newResourceGroupId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The resource ID.
   * 
   * This parameter is required.
   * 
   * @example
   * ggxw4lnjuz@cfd34a78f******
   */
  resourceId?: string;
  /**
   * @remarks
   * The resource type.
   * 
   * @example
   * APPLICATION
   */
  resourceType?: string;
  static names(): { [key: string]: string } {
    return {
      newResourceGroupId: 'NewResourceGroupId',
      regionId: 'RegionId',
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      newResourceGroupId: 'string',
      regionId: 'string',
      resourceId: 'string',
      resourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeResourceGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code or error code.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned struct.
   */
  data?: ChangeResourceGroupResponseBodyData;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 46355DD8-FC56-40C5-BFC6-269DE4F9****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ChangeResourceGroupResponseBodyData,
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeResourceGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ChangeResourceGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ChangeResourceGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckCommercialStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The region ID. Default value: cn-hangzhou.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ARMS sub-service. Valid values:
   * 
   * *   apm: Application Monitoring
   * *   rum: RUM
   * *   prometheus: Managed Service for Prometheus
   * *   xtrace: Managed Service for OpenTelemetry
   * 
   * This parameter is required.
   * 
   * @example
   * apm
   */
  service?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      service: 'Service',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      service: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckCommercialStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned struct.
   * 
   * @example
   * True
   */
  data?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 1A474FF8-7861-4D00-81B5-5BC3DA4E****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckCommercialStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CheckCommercialStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CheckCommercialStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckServiceStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-beijing
   */
  regionId?: string;
  /**
   * @remarks
   * The service code of an Alibaba Cloud service. The service code of Managed Service for Prometheus is prometheus.
   * 
   * This parameter is required.
   * 
   * @example
   * prometheus
   */
  svcCode?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      svcCode: 'SvcCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      svcCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckServiceStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true.
   * *   false.
   * 
   * @example
   * true
   */
  data?: string;
  /**
   * @remarks
   * The request ID. You can use the ID to find logs and troubleshoot issues.
   * 
   * @example
   * 5710C923-AD09-4293-9E11-DCBE3D15F8D4
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckServiceStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CheckServiceStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CheckServiceStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClaimAlarmRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert.
   * 
   * For more information about how to obtain the ID of an alert, see [ListAlertEvents](https://help.aliyun.com/document_detail/2612346.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 30
   */
  alarmId?: number;
  /**
   * @remarks
   * The ID of the handler.
   * 
   * @example
   * 2046076
   */
  handlerId?: number;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      alarmId: 'AlarmId',
      handlerId: 'HandlerId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmId: 'number',
      handlerId: 'number',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClaimAlarmResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6A9AEA84-7186-4D8D-B498-4585C6A2****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  result?: boolean;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * `true`
   * 
   * `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      requestId: 'string',
      result: 'boolean',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClaimAlarmResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ClaimAlarmResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ClaimAlarmResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseAlarmRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert.
   * 
   * For more information about how to obtain the ID of an alert, see [ListAlertEvents](https://help.aliyun.com/document_detail/2612346.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 163
   */
  alarmId?: number;
  /**
   * @remarks
   * The ID of the alert handler.
   * 
   * @example
   * 2048065
   */
  handlerId?: number;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The alert solution.
   * 
   * @example
   * Restart Repair
   */
  solution?: string;
  static names(): { [key: string]: string } {
    return {
      alarmId: 'AlarmId',
      handlerId: 'HandlerId',
      regionId: 'RegionId',
      solution: 'Solution',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmId: 'number',
      handlerId: 'number',
      regionId: 'string',
      solution: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseAlarmResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 46355DD8-FC56-40C5-BFC6-269DE4F9****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  result?: boolean;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * True
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      requestId: 'string',
      result: 'boolean',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseAlarmResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CloseAlarmResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CloseAlarmResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigAppRequest extends $tea.Model {
  /**
   * @remarks
   * The process identifier (PID) of the application. Separate multiple PIDs with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * iioe7jcnuk@582846f37******,atc889zkcf@d8deedfa9bf******
   */
  appIds?: string;
  /**
   * @remarks
   * Specifies whether to turn on or off the main switch of the ARMS agent. The monitoring stops after the switch is turned off. If you do not specify this parameter, the main switch status of the ARMS agent is queried.
   * 
   * *   `true`: turns on the switch
   * *   `false`: turns off the switch
   * 
   * @example
   * true
   */
  enable?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The type of the application. Set the value to **TRACE**.
   * 
   * @example
   * TRACE
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      appIds: 'AppIds',
      enable: 'Enable',
      regionId: 'RegionId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appIds: 'string',
      enable: 'string',
      regionId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigAppResponseBody extends $tea.Model {
  /**
   * @remarks
   * The result of turning on or off the main switch of the agent or the main switch status of the agent. Indicates whether the request was successful. Valid values:
   * 
   * *   success
   * *   failed
   * 
   * The main switch status of the agent. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * abc@def success\\nghi@jkl success\\n
   */
  data?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 16AF921B-8187-489F-9913-43C808B4****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigAppResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ConfigAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ConfigAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAlertContactRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the alert contact.
   * 
   * @example
   * JohnDoe
   */
  contactName?: string;
  /**
   * @remarks
   * The webhook URL of the DingTalk chatbot. For more information about how to obtain the URL, see [Configure a DingTalk chatbot to send alert notifications](https://www.alibabacloud.com/help/zh/doc-detail/106247.htm). You must specify at least one of the following parameters: PhoneNum, Email, and DingRobotWebhookUrl.
   * 
   * >  Enter `alert` in the custom keyword field of DingTalk chatbot security settings.
   * 
   * @example
   * https://oapi.dingtalk.com/robot/send?access_token=91f2f6****
   */
  dingRobotWebhookUrl?: string;
  /**
   * @remarks
   * The email address of the alert contact. You must specify at least one of the following parameters: PhoneNum, Email, and DingRobotWebhookUrl.
   * 
   * @example
   * someone@example.com
   */
  email?: string;
  /**
   * @remarks
   * The mobile number of the alert contact. You must specify at least one of the following parameters: PhoneNum, Email, and DingRobotWebhookUrl.
   * 
   * @example
   * 1381111****
   */
  phoneNum?: string;
  /**
   * @remarks
   * The ID of the region. Set the value to `cn-hangzhou`.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group. You can obtain the resource group ID in the **Resource Management** console.
   * 
   * @example
   * rg-aek2eq4peca****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * Specifies whether the alert contact receives system notifications. Valid values:
   * 
   * *   `true`: The alert contact receives system notifications.
   * *   `false`: The alert contact does not receive system notifications.
   * 
   * @example
   * true
   */
  systemNoc?: boolean;
  static names(): { [key: string]: string } {
    return {
      contactName: 'ContactName',
      dingRobotWebhookUrl: 'DingRobotWebhookUrl',
      email: 'Email',
      phoneNum: 'PhoneNum',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      systemNoc: 'SystemNoc',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactName: 'string',
      dingRobotWebhookUrl: 'string',
      email: 'string',
      phoneNum: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      systemNoc: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAlertContactResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert contact.
   * 
   * @example
   * 102**
   */
  contactId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E9C9DA3D-10FE-472E-9EEF-2D0A3E41****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      contactId: 'ContactId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAlertContactResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateAlertContactResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateAlertContactResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAlertContactGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the alert contact group.
   * 
   * This parameter is required.
   * 
   * @example
   * TestGroup
   */
  contactGroupName?: string;
  /**
   * @remarks
   * The IDs of contacts in the contact group. Separate multiple contact IDs with spaces. You can call the SearchAlertContact operation to query the contact IDs. For more information, see [SearchAlertContact](https://help.aliyun.com/document_detail/130703.html).
   * 
   * @example
   * 12* 23* 34*
   */
  contactIds?: string;
  /**
   * @remarks
   * The region ID. Default value: `cn-hangzhou`.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      contactGroupName: 'ContactGroupName',
      contactIds: 'ContactIds',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroupName: 'string',
      contactIds: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAlertContactGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert contact group.
   * 
   * @example
   * 446*
   */
  contactGroupId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 70675725-8F11-4817-8106-CFE0AD71****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      contactGroupId: 'ContactGroupId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroupId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAlertContactGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateAlertContactGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateAlertContactGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDispatchRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The dispatch rule configuration. The value is a JSON string. For more information about this parameter, see the following **additional information about the DispatchRule parameter**.
   * 
   * This parameter is required.
   * 
   * @example
   * {   "system": false,   "ruleid": 10282,   "name": "Prometheus Alert",   "labelMatchExpressionGrid": {     "labelMatchExpressionGroups": [       {         "labelMatchExpressions": [           {             "key": "_aliyun_arms_involvedObject_kind",             "value": "app",             "operator": "eq"           }         ]       }     ]   },   "dispatchType": "CREATE_ALERT/DISCARD_ALERT",   "isRecover": true,   "groupRules": [     {       "groupId": 1,       "groupingFields": [         "alertname"       ],       "groupWait": 10,       "groupInterval": 15,       "repeatInterval": 20     }   ],   "notifyRules": [     {       "notifyObjects": [         {           "notifyType": "ARMS_CONTACT",           "name": "JohnDoe",           "notifyObjectId": 1         },         {           "notifyType": "ARMS_CONTACT_GROUP",           "name": "JohnDoe_group",           "notifyObjectId": 2         }       ],       "notifyChannels":["dingTalk","wechat","webhook","email"]     },   ], }
   */
  dispatchRule?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      dispatchRule: 'DispatchRule',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dispatchRule: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDispatchRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the dispatch policy.
   * 
   * @example
   * 10413
   */
  dispatchRuleId?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * A5EC8221-08F2-4C95-9AF1-49FD998C****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      dispatchRuleId: 'DispatchRuleId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dispatchRuleId: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDispatchRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDispatchRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDispatchRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEnvCustomJobRequest extends $tea.Model {
  /**
   * @remarks
   * The language. Valid values: zh and en. Default value: zh.
   * 
   * @example
   * zh
   */
  aliyunLang?: string;
  /**
   * @remarks
   * The YAML configuration string of the custom job.
   * 
   * This parameter is required.
   * 
   * @example
   * Refer to supplementary instructions.
   */
  configYaml?: string;
  /**
   * @remarks
   * The name of the custom job.
   * 
   * This parameter is required.
   * 
   * @example
   * customJob1
   */
  customJobName?: string;
  /**
   * @remarks
   * The ID of the environment instance.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxxxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunLang: 'AliyunLang',
      configYaml: 'ConfigYaml',
      customJobName: 'CustomJobName',
      environmentId: 'EnvironmentId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunLang: 'string',
      configYaml: 'string',
      customJobName: 'string',
      environmentId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEnvCustomJobResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The name of the custom job that was created, or the exception information.
   * 
   * @example
   * cutomJob1
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 4C518054-852F-4023-ABC1-4AF95FF7****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEnvCustomJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateEnvCustomJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateEnvCustomJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEnvPodMonitorRequest extends $tea.Model {
  /**
   * @remarks
   * The language. Valid values: zh and en. Default value: zh.
   * 
   * @example
   * zh
   */
  aliyunLang?: string;
  /**
   * @remarks
   * The YAML configuration string of the PodMonitor.
   * 
   * This parameter is required.
   * 
   * @example
   * Refer to supplementary instructions.
   */
  configYaml?: string;
  /**
   * @remarks
   * Specifies whether to perform only a dry run, without performing the actual request.
   * 
   * @example
   * true
   */
  dryRun?: boolean;
  /**
   * @remarks
   * The ID of the environment instance.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxxxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunLang: 'AliyunLang',
      configYaml: 'ConfigYaml',
      dryRun: 'DryRun',
      environmentId: 'EnvironmentId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunLang: 'string',
      configYaml: 'string',
      dryRun: 'boolean',
      environmentId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEnvPodMonitorResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned result, which indicates whether the operation was successful.
   */
  data?: CreateEnvPodMonitorResponseBodyData;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 78901766-3806-4E96-8E47-CFEF59E4****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: CreateEnvPodMonitorResponseBodyData,
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEnvPodMonitorResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateEnvPodMonitorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateEnvPodMonitorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEnvServiceMonitorRequest extends $tea.Model {
  /**
   * @remarks
   * The language. Valid values:
   * 
   * *   zh (default): Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  aliyunLang?: string;
  /**
   * @remarks
   * The YAML configuration file of the ServiceMonitor.
   * 
   * This parameter is required.
   * 
   * @example
   * Refer to supplementary instructions.
   */
  configYaml?: string;
  /**
   * @remarks
   * Specifies whether to perform only a dry run, without performing the actual request. The system checks whether the format is valid and whether targets are matched.
   * 
   * @example
   * true
   */
  dryRun?: boolean;
  /**
   * @remarks
   * The ID of the environment instance.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxxxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunLang: 'AliyunLang',
      configYaml: 'ConfigYaml',
      dryRun: 'DryRun',
      environmentId: 'EnvironmentId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunLang: 'string',
      configYaml: 'string',
      dryRun: 'boolean',
      environmentId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEnvServiceMonitorResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned struct.
   */
  data?: CreateEnvServiceMonitorResponseBodyData;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 78901766-3806-4E96-8E47-CFEF59E4****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: CreateEnvServiceMonitorResponseBodyData,
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEnvServiceMonitorResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateEnvServiceMonitorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateEnvServiceMonitorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEnvironmentRequest extends $tea.Model {
  /**
   * @remarks
   * The language. Default value: zh.
   * 
   * Valid values:
   * *   en: English
   * *   zh: Chinese
   * 
   * @example
   * zh
   */
  aliyunLang?: string;
  /**
   * @remarks
   * The ID of the resource bound to the environment, such as the container ID or VPC ID. For a Cloud environment, specify the region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c6e9dec475dca4a50a188411d8cbxxx
   */
  bindResourceId?: string;
  /**
   * @remarks
   * The name of the environment.
   * 
   * This parameter is required.
   * 
   * @example
   * env1
   */
  environmentName?: string;
  /**
   * @remarks
   * The subtype of the environment. Valid values:
   * 
   * *   CS: Container Service for Kubernetes (ACK) or Distributed Cloud Container Platform for Kubernetes (ACK One)
   * *   ECS: ECS
   * *   Cloud: cloud service
   * 
   * This parameter is required.
   * 
   * @example
   * ECS, ACK, etc.
   */
  environmentSubType?: string;
  /**
   * @remarks
   * The type of the environment. Valid values:
   * 
   * *   CS: Container Service
   * *   ECS: Elastic Compute Service
   * *   Cloud: cloud service
   * 
   * This parameter is required.
   * 
   * @example
   * CS
   */
  environmentType?: string;
  /**
   * @remarks
   * The payable resource plan.
   * 
   * *   If the EnvironmentType parameter is set to CS, set the value to CS_Basic or CS_Pro. Default value: CS_Basic.
   * *   Otherwise, leave the parameter empty.
   * 
   * @example
   * CS_Basic
   */
  feePackage?: string;
  /**
   * @remarks
   * The ID of the Grafana workspace associated with the environment. If this parameter is left empty, the default shared Grafana workspace is used.
   * 
   * @example
   * grafana-rnglkcdrntlhk0****
   * 
   * **if can be null:**
   * true
   */
  grafanaWorkspaceId?: string;
  /**
   * @remarks
   * Specifies whether to initialize the environment.
   * 
   * @example
   * false
   */
  initEnvironment?: boolean;
  /**
   * @remarks
   * Specifies whether agents or exporters are managed. Valid values:
   * 
   * *   none: No. By default, no managed agents or exporters are provided for ACK clusters.
   * *   agent: Agents are managed. By default, managed agents are provided for ASK clusters, ACS clusters, and ACK One clusters.
   * *   agent-exporter: Agents and exporters are managed. By default, managed agents and exporters are provided for cloud services.
   * 
   * @example
   * none
   */
  managedType?: string;
  /**
   * @remarks
   * The ID of the Prometheus instance. If no Prometheus instance is created, call the InitEnvironment operation.
   * 
   * @example
   * c6e9dec475dca4a50a188411d8cbxxx
   */
  prometheusInstanceId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfmxyexli2****
   * 
   * **if can be null:**
   * true
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The tags of the instance. You can specify this parameter to manage tags for the instance.
   */
  tags?: CreateEnvironmentRequestTags[];
  static names(): { [key: string]: string } {
    return {
      aliyunLang: 'AliyunLang',
      bindResourceId: 'BindResourceId',
      environmentName: 'EnvironmentName',
      environmentSubType: 'EnvironmentSubType',
      environmentType: 'EnvironmentType',
      feePackage: 'FeePackage',
      grafanaWorkspaceId: 'GrafanaWorkspaceId',
      initEnvironment: 'InitEnvironment',
      managedType: 'ManagedType',
      prometheusInstanceId: 'PrometheusInstanceId',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunLang: 'string',
      bindResourceId: 'string',
      environmentName: 'string',
      environmentSubType: 'string',
      environmentType: 'string',
      feePackage: 'string',
      grafanaWorkspaceId: 'string',
      initEnvironment: 'boolean',
      managedType: 'string',
      prometheusInstanceId: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      tags: { 'type': 'array', 'itemType': CreateEnvironmentRequestTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEnvironmentResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The ID of the created environment.
   * 
   * @example
   * env-xxxxx
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 16AF921B-8187-489F-9913-43C808B4****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEnvironmentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateEnvironmentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateEnvironmentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGrafanaWorkspaceRequest extends $tea.Model {
  /**
   * @remarks
   * The language. Default value: zh. Valid values:
   * 
   * *   zh
   * *   en
   * 
   * @example
   * zh
   */
  aliyunLang?: string;
  /**
   * @remarks
   * The description of the workspace
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 10.0.x
   */
  grafanaVersion?: string;
  /**
   * @remarks
   * The edition.
   * 
   * **Valid values:**
   * 
   * *   standard: `Beta Edition or Standard Edition`
   * *   personal_edition: Developer Edition
   * *   experts_edition: Pro Edition
   * *   advanced_edition: Advanced Edition
   * 
   * This parameter is required.
   * 
   * @example
   * experts_edition
   */
  grafanaWorkspaceEdition?: string;
  /**
   * @remarks
   * The name of the Grafana workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * testgrafana
   */
  grafanaWorkspaceName?: string;
  /**
   * @remarks
   * The password of the workspace. The password must be 8 to 30 characters in length. It must include at least three of the following characters types: uppercase letter, lowercase letter, digit, and special character. Special characters include () \\" ~ ! @ # $ % ^ & \\* - _ + =.
   * 
   * @example
   * Test123456!
   */
  password?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The resource group ID.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The list of tags.
   */
  tags?: CreateGrafanaWorkspaceRequestTags[];
  static names(): { [key: string]: string } {
    return {
      aliyunLang: 'AliyunLang',
      description: 'Description',
      grafanaVersion: 'GrafanaVersion',
      grafanaWorkspaceEdition: 'GrafanaWorkspaceEdition',
      grafanaWorkspaceName: 'GrafanaWorkspaceName',
      password: 'Password',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunLang: 'string',
      description: 'string',
      grafanaVersion: 'string',
      grafanaWorkspaceEdition: 'string',
      grafanaWorkspaceName: 'string',
      password: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      tags: { 'type': 'array', 'itemType': CreateGrafanaWorkspaceRequestTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGrafanaWorkspaceShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language. Default value: zh. Valid values:
   * 
   * *   zh
   * *   en
   * 
   * @example
   * zh
   */
  aliyunLang?: string;
  /**
   * @remarks
   * The description of the workspace
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 10.0.x
   */
  grafanaVersion?: string;
  /**
   * @remarks
   * The edition.
   * 
   * **Valid values:**
   * 
   * *   standard: `Beta Edition or Standard Edition`
   * *   personal_edition: Developer Edition
   * *   experts_edition: Pro Edition
   * *   advanced_edition: Advanced Edition
   * 
   * This parameter is required.
   * 
   * @example
   * experts_edition
   */
  grafanaWorkspaceEdition?: string;
  /**
   * @remarks
   * The name of the Grafana workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * testgrafana
   */
  grafanaWorkspaceName?: string;
  /**
   * @remarks
   * The password of the workspace. The password must be 8 to 30 characters in length. It must include at least three of the following characters types: uppercase letter, lowercase letter, digit, and special character. Special characters include () \\" ~ ! @ # $ % ^ & \\* - _ + =.
   * 
   * @example
   * Test123456!
   */
  password?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The resource group ID.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The list of tags.
   */
  tagsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunLang: 'AliyunLang',
      description: 'Description',
      grafanaVersion: 'GrafanaVersion',
      grafanaWorkspaceEdition: 'GrafanaWorkspaceEdition',
      grafanaWorkspaceName: 'GrafanaWorkspaceName',
      password: 'Password',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      tagsShrink: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunLang: 'string',
      description: 'string',
      grafanaVersion: 'string',
      grafanaWorkspaceEdition: 'string',
      grafanaWorkspaceName: 'string',
      password: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      tagsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGrafanaWorkspaceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The information about the Grafana workspace.
   */
  data?: GrafanaWorkspace;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * D80ADAAC-8C32-5479-BD14-C28CF832****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The ID of the trace.
   * 
   * @example
   * eac0a8048716731735000007137d000b
   */
  traceId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      traceId: 'TraceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: GrafanaWorkspace,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
      traceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGrafanaWorkspaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateGrafanaWorkspaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateGrafanaWorkspaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateIntegrationRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to automatically clear alert events. Default value: true. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  autoRecover?: boolean;
  /**
   * @remarks
   * The description of the alert integration.
   * 
   * @example
   * Test
   */
  description?: string;
  /**
   * @remarks
   * The name of the alert integration.
   * 
   * This parameter is required.
   * 
   * @example
   * CloudMonitor integration
   */
  integrationName?: string;
  /**
   * @remarks
   * The service of the alert integration. Valid values:
   * 
   * *   CLOUD_MONITOR: CloudMonitor
   * *   LOG_SERVICE: Log Service
   * 
   * This parameter is required.
   * 
   * @example
   * CLOUD_MONITOR
   */
  integrationProductType?: string;
  /**
   * @remarks
   * The period of time within which alert events are automatically cleared. Unit: seconds. Default value: 300.
   * 
   * @example
   * 300
   */
  recoverTime?: number;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      autoRecover: 'AutoRecover',
      description: 'Description',
      integrationName: 'IntegrationName',
      integrationProductType: 'IntegrationProductType',
      recoverTime: 'RecoverTime',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRecover: 'boolean',
      description: 'string',
      integrationName: 'string',
      integrationProductType: 'string',
      recoverTime: 'number',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateIntegrationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned information about the alert integration.
   */
  integration?: CreateIntegrationResponseBodyIntegration;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 34ED024E-9E31-434A-9E4E-D9D15C3****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      integration: 'Integration',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      integration: CreateIntegrationResponseBodyIntegration,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateIntegrationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateIntegrationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateIntegrationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateAlertRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The alert check type of the Prometheus alert rule. Valid values:
   * 
   * *   STATIC: a static threshold value. If you set the parameter to STATIC, you must specify the **MetricsKey** parameter. For more information, see the **Correspondence between AlertGroup and MetricsKey for Prometheus Service** table.
   * *   CUSTOM: a custom PromQL statement. If you set the parameter to CUSTOM, you must specify the **PromQL**, **Duration**, and **Message** parameters to create a Prometheus alert rule.
   * 
   * @example
   * STATIC
   */
  alertCheckType?: string;
  /**
   * @remarks
   * The alert contact group ID of the Prometheus alert rule. Valid values:
   * 
   * *   \\-1: custom PromQL
   * *   1: Kubernetes load
   * *   15: Kubernetes node
   * 
   * @example
   * -1
   */
  alertGroup?: number;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * *   If you do not specify this parameter, a new alert rule is created.
   * *   If you specify this parameter, the specified alert rule is modified.
   * 
   * @example
   * 546xxx
   */
  alertId?: number;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * This parameter is required.
   * 
   * @example
   * Alert Rule Demo
   */
  alertName?: string;
  /**
   * @remarks
   * The configuration of the alert sending channel. This parameter is used to be compatible with the old version of the rule.
   * 
   * @example
   * -
   */
  alertPiplines?: string;
  /**
   * @remarks
   * The content of the Application Monitoring or Browser Monitoring alert rule. The following code provides an example of the **AlertRuleContent** parameter. For more information about the meaning of each field, see the supplementary description.
   * 
   * ```json
   * { 
   *     "Condition": "OR",
   *      "AlertRuleItems": [
   *              { "Operator": "CURRENT_LTE",
   *                  "MetricKey": "appstat.jvm.threadcount",
   *                  "Value": 1000,
   *                  "Aggregate": "AVG",
   *                   "N": 10,
   *                   "Tolerability": 169
   *             } 
   *        ]  
   *   }
   * ```
   * 
   * >  The filter conditions specified by the **AlertRuleItems.MetricKey** field depends on the value of the **MetricsType** parameter. For more information about the types of metrics supported by Application Monitoring and Browser Monitoring and the alert rule fields corresponding to each metric, see the supplementary description.
   * 
   * @example
   * { "Condition": "OR", "AlertRuleItems": [ { "Operator": "CURRENT_LTE",  "MetricKey": "appstat.jvm.threadcount",  "Value": 1000,  "Aggregate": "AVG",   "N": 1  }  ]  }
   */
  alertRuleContent?: string;
  /**
   * @remarks
   * The status of the alert rule. Valid values:
   * 
   * *   RUNNING (default)
   * *   STOPPED
   * 
   * @example
   * RUNNING
   */
  alertStatus?: string;
  /**
   * @remarks
   * The type of the alert rule. Valid values:
   * 
   * *   APPLICATION_MONITORING_ALERT_RULE: alert rule for Application Monitoring
   * *   BROWSER_MONITORING_ALERT_RULE: alert rule for Browser Monitoring
   * *   PROMETHEUS_MONITORING_ALERT_RULE: alert rule for Managed Service for Prometheus
   * *   XTRACE_MONITORING_ALERT_RULE: alert rule for Managed Service for OpenTelemetry
   * *   EBPF_MONITORING_ALERT_RULE: alert rule for Application Monitoring eBPF Edition
   * *   RUM_MONITORING_ALERT_RULE: alert rule for Real User Monitoring
   * 
   * This parameter is required.
   * 
   * @example
   * APPLICATION_MONITORING_ALERT_RULE
   */
  alertType?: string;
  /**
   * @remarks
   * The annotations of the Prometheus alert rule.
   * 
   * @example
   * [ { "Value": "PolarDB slow queries", "Name": "_aliyun_display_name" }
   */
  annotations?: string;
  /**
   * @remarks
   * Specifies whether to apply the alert rule to new applications that are created in Application Monitoring or Browser Monitoring. Valid values:
   * 
   * *   `true`: enables the health check feature.
   * *   `false`: disables the automatic backup feature.
   * 
   * @example
   * false
   */
  autoAddNewApplication?: boolean;
  /**
   * @remarks
   * The configurations that are automatically appended to monitor the application based on the specified alert rule.
   * 
   * *   autoAddMatchType:
   * 
   *     the matching mode. Valid values: REGULAR and NOT_REGULAR.
   * 
   * *   autoAddMatchExp: the regular expression
   * 
   * @example
   * {\\"autoAddMatchType\\":\\"REGULAR\\",\\"autoAddMatchExp\\":\\".*cbw.*\\"}
   */
  autoAddTargetConfig?: string;
  /**
   * @remarks
   * The ID of the monitored cluster.
   * 
   * @example
   * ceba9b9ea5b924dd0b6726d2de6******
   */
  clusterId?: string;
  /**
   * @remarks
   * Data Configuration. The dataRevision field specifies the data repair method when there is no data for the metric.
   * 
   * - Fill with zero: 0
   * - Fill with one: 1
   * - Fill with null: 2 (default, does not trigger an alarm)
   * 
   * @example
   * {
   *     "dataRevision": 2
   * }
   */
  dataConfig?: string;
  /**
   * @remarks
   * The duration of the Prometheus alert rule, in minutes, in the range of [0,1440].
   * 
   * @example
   * 1
   */
  duration?: number;
  /**
   * @remarks
   * The filter conditions of the Application Monitoring or Browser Monitoring alert rule. Format:
   * 
   *     "DimFilters": [ 
   *     { 
   *      "FilterOpt": "ALL",
   *     "FilterValues": [],         //The value of the filter condition.
   *     "FilterKey": "rootIp"     //The key of the filter condition.
   *     }
   *     ]
   * 
   * Valid values of **FilterOpt**:
   * 
   * *   STATIC: matches the value of the specified dimension.
   * *   ALL: traverses all dimension values. Dynamic thresholds do not support traversal.
   * *   DISABLE: aggregates the values of all dimensions.
   * 
   * @example
   * {"DimFilters": [             {               "FilterOpt": "ALL",               "FilterValues": [],               "FilterKey": "rootIp"             }           ]         }
   */
  filters?: string;
  /**
   * @remarks
   * The tags of the Prometheus alert rule.
   * 
   * @example
   * [  { "Value": "cms_polardb",             "Name": "_aliyun_cloud_product"           }         ]
   */
  labels?: string;
  /**
   * @remarks
   * The severity level of the Prometheus alert rule.
   * 
   * *   P1: Alert notifications are sent for major issues that affect the availability of core business, have a huge impact, and may lead to serious consequences.
   * *   P2: Alert notifications are sent for service errors that affect the system availability with relatively limited impact.
   * *   P3: Alert notifications are sent for issues that may cause service errors or negative effects, or alert notifications for services that are relatively less important.
   * *   P4: Alert notifications are sent for low-priority issues that do not affect your business.
   * *   Default: Alert notifications are sent regardless of alert levels.
   * 
   * @example
   * P2
   */
  level?: string;
  /**
   * @remarks
   * Application Tags. Used for application monitoring alert rules, to filter applications associated with alert rules.
   */
  markTags?: CreateOrUpdateAlertRuleRequestMarkTags[];
  /**
   * @remarks
   * The alert message of the Prometheus alert rule.
   * 
   * @example
   * Namespace: {{$labels.namespace}} / Pod: {{$labels.pod_name}} / Container: {{$labels.container}} Memory usage exceeds 80%. Current value: {{ printf \\\\\\\\\\"%.2f\\\\\\\\\\" $value }}%
   */
  message?: string;
  /**
   * @remarks
   * The alert metrics. If you set the **AlertCheckType** parameter to **STATIC** when you create a Prometheus alert rule, you must specify the **MetricsKey** parameter.
   * 
   * > Alert metrics vary depending on the value of the **AlertGroup** parameter. For more information about the correspondence between **AlertGroup** and **MetricsKey**, see the supplementary description.
   * 
   * @example
   * pop.status.error
   */
  metricsKey?: string;
  /**
   * @remarks
   * The metric type of the Application Monitoring or Browser Monitoring alert rule. For more information, see the following table.
   * 
   * @example
   * jvm
   */
  metricsType?: string;
  /**
   * @remarks
   * The effective time and notification time. This parameter is used to be compatible with the old version of the rule.
   * 
   * @example
   * -
   */
  notice?: string;
  /**
   * @remarks
   * The notification mode. You can specify the normal mode or simple mode.
   * 
   * *   DIRECTED_MODE
   * *   NORMAL_MODE
   * 
   * @example
   * NORMAL_MODE
   */
  notifyMode?: string;
  /**
   * @remarks
   * The notification policy.
   * 
   * *   If you set this parameter to null, no notification policy is specified. After you create an alert rule, you can create a notification policy and specify match rules and match conditions. For example, you can specify the name of the alert rule as the match condition. When the alert rule is triggered, an alert event is generated and an alert notification is sent to the contacts or contact groups that are specified in the notification policy.
   * *   To specify a notification policy, set this parameter to the ID of the notification policy. Application Real-Time Monitoring Service (ARMS) automatically adds a match rule to the notification policy and specifies the ID of the alert rule as the match condition. The name of the alert rule is also displayed. This way, the alert events that are generated based on the alert rule can be matched by the specified notification policy.
   * 
   * @example
   * 569xxx
   */
  notifyStrategy?: string;
  /**
   * @remarks
   * The process ID (PID) that is associated with the Application Monitoring or Browser Monitoring alert rule.
   * 
   * @example
   * ["b590lhguqs@40d8deedfa9******"]
   */
  pids?: string;
  /**
   * @remarks
   * The product code. If you specify this parameter when you create a Prometheus alert rule, the backend checks whether the product exists.
   * 
   * @example
   * clickhouse
   */
  product?: string;
  /**
   * @remarks
   * The PromQL statement of the Prometheus alert rule.
   * 
   * @example
   * node_memory_MemAvailable_bytes{} / node_memory_MemTotal_bytes{} * 100
   */
  promQL?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The list of tags.
   */
  tags?: CreateOrUpdateAlertRuleRequestTags[];
  static names(): { [key: string]: string } {
    return {
      alertCheckType: 'AlertCheckType',
      alertGroup: 'AlertGroup',
      alertId: 'AlertId',
      alertName: 'AlertName',
      alertPiplines: 'AlertPiplines',
      alertRuleContent: 'AlertRuleContent',
      alertStatus: 'AlertStatus',
      alertType: 'AlertType',
      annotations: 'Annotations',
      autoAddNewApplication: 'AutoAddNewApplication',
      autoAddTargetConfig: 'AutoAddTargetConfig',
      clusterId: 'ClusterId',
      dataConfig: 'DataConfig',
      duration: 'Duration',
      filters: 'Filters',
      labels: 'Labels',
      level: 'Level',
      markTags: 'MarkTags',
      message: 'Message',
      metricsKey: 'MetricsKey',
      metricsType: 'MetricsType',
      notice: 'Notice',
      notifyMode: 'NotifyMode',
      notifyStrategy: 'NotifyStrategy',
      pids: 'Pids',
      product: 'Product',
      promQL: 'PromQL',
      regionId: 'RegionId',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertCheckType: 'string',
      alertGroup: 'number',
      alertId: 'number',
      alertName: 'string',
      alertPiplines: 'string',
      alertRuleContent: 'string',
      alertStatus: 'string',
      alertType: 'string',
      annotations: 'string',
      autoAddNewApplication: 'boolean',
      autoAddTargetConfig: 'string',
      clusterId: 'string',
      dataConfig: 'string',
      duration: 'number',
      filters: 'string',
      labels: 'string',
      level: 'string',
      markTags: { 'type': 'array', 'itemType': CreateOrUpdateAlertRuleRequestMarkTags },
      message: 'string',
      metricsKey: 'string',
      metricsType: 'string',
      notice: 'string',
      notifyMode: 'string',
      notifyStrategy: 'string',
      pids: 'string',
      product: 'string',
      promQL: 'string',
      regionId: 'string',
      tags: { 'type': 'array', 'itemType': CreateOrUpdateAlertRuleRequestTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateAlertRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the alert rule.
   */
  alertRule?: CreateOrUpdateAlertRuleResponseBodyAlertRule;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 337B8F7E-0A64-5768-9225-E9B3CF******
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      alertRule: 'AlertRule',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertRule: CreateOrUpdateAlertRuleResponseBodyAlertRule,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateAlertRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateOrUpdateAlertRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOrUpdateAlertRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateContactRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert contact.
   * 
   * *   If you do not specify this parameter, a new alert contact is created.
   * *   If you specify this parameter, the specified alert contact is modified.
   * 
   * @example
   * 123
   */
  contactId?: number;
  /**
   * @remarks
   * The name of the alert contact.
   * 
   * This parameter is required.
   * 
   * @example
   * JohnDoe
   */
  contactName?: string;
  /**
   * @remarks
   * The ID of the alert contact that is shown to the enterprise when the contact is mentioned with the at sign (@) by a third-party instant messaging (IM) tool.
   * 
   * @example
   * A123221
   */
  corpUserId?: string;
  /**
   * @remarks
   * The webhook URL of the DingTalk chatbot.
   * 
   * @example
   * https://oapi.dingtalk.com/robot/send?access_token=69d4e0******
   */
  dingRobotUrl?: string;
  /**
   * @remarks
   * The email address of the alert contact.
   * 
   * > You must specify at least one of the **Phone** and **Email** parameters. Each mobile number or email address can be used for only one alert contact.
   * 
   * @example
   * someone@example.com
   */
  email?: string;
  /**
   * @remarks
   * Specifies whether the email address is verified.
   * 
   * @example
   * true
   */
  isEmailVerify?: boolean;
  /**
   * @remarks
   * The mobile number of the alert contact.
   * 
   * > You must specify at least one of the **Phone** and **Email** parameters. Each mobile number or email address can be used for only one alert contact.
   * 
   * @example
   * 1381111****
   */
  phone?: string;
  /**
   * @remarks
   * The operation that you want to perform if phone calls fail to be answered. Valid values:
   * 
   * *   0: No operation is performed.
   * *   1: A phone call is made again.
   * *   2: A text message is sent.
   * *   3 (default value): The global default value is used.
   * 
   * @example
   * 3
   */
  reissueSendNotice?: number;
  /**
   * @remarks
   * The resource group ID.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      contactId: 'ContactId',
      contactName: 'ContactName',
      corpUserId: 'CorpUserId',
      dingRobotUrl: 'DingRobotUrl',
      email: 'Email',
      isEmailVerify: 'IsEmailVerify',
      phone: 'Phone',
      reissueSendNotice: 'ReissueSendNotice',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactId: 'number',
      contactName: 'string',
      corpUserId: 'string',
      dingRobotUrl: 'string',
      email: 'string',
      isEmailVerify: 'boolean',
      phone: 'string',
      reissueSendNotice: 'number',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateContactResponseBody extends $tea.Model {
  /**
   * @remarks
   * The object of the alert contact.
   */
  alertContact?: CreateOrUpdateContactResponseBodyAlertContact;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * E9C9DA3D-10FE-472E-9EEF-2D0A3E41****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      alertContact: 'AlertContact',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertContact: CreateOrUpdateContactResponseBodyAlertContact,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateContactResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateOrUpdateContactResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOrUpdateContactResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateContactGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert contact group.
   * 
   * *   If you do not specify this parameter, an alert contact group is created.
   * *   If you specify this parameter, the specified alert contact group is modified.
   * 
   * @example
   * 123
   */
  contactGroupId?: number;
  /**
   * @remarks
   * The name of the alert contact group.
   * 
   * This parameter is required.
   * 
   * @example
   * TestGroup
   */
  contactGroupName?: string;
  /**
   * @remarks
   * The ID of the contact that you want to add to the contact group. Separate multiple IDs with commas (,).
   * 
   * @example
   * [1,2,3]
   */
  contactIds?: string;
  static names(): { [key: string]: string } {
    return {
      contactGroupId: 'ContactGroupId',
      contactGroupName: 'ContactGroupName',
      contactIds: 'ContactIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroupId: 'number',
      contactGroupName: 'string',
      contactIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateContactGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the alert contact group.
   */
  alertContactGroup?: CreateOrUpdateContactGroupResponseBodyAlertContactGroup;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9319A57D-2D9E-472A-B69B-CF3CD16D****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      alertContactGroup: 'AlertContactGroup',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertContactGroup: CreateOrUpdateContactGroupResponseBodyAlertContactGroup,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateContactGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateOrUpdateContactGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOrUpdateContactGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateEventBridgeIntegrationRequest extends $tea.Model {
  /**
   * @remarks
   * The AccessKey ID that is used to connect to EventBridge.
   * 
   * @example
   * abc******************
   */
  accessKey?: string;
  /**
   * @remarks
   * The AccessKey secret that is used to connect to EventBridge.
   * 
   * @example
   * abc******************
   */
  accessSecret?: string;
  /**
   * @remarks
   * The description of the EventBridge integration.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The public endpoint of EventBridge.
   * 
   * @example
   * http://xxxxx
   */
  endpoint?: string;
  /**
   * @remarks
   * The name of the event bus.
   * 
   * @example
   * EventBus_Test
   */
  eventBusName?: string;
  /**
   * @remarks
   * The region ID of the event bus.
   * 
   * @example
   * cn-hangzhou
   */
  eventBusRegionId?: string;
  /**
   * @remarks
   * The ID of the EventBridge integration.
   * 
   * *   If you do not specify this parameter, an EventBridge integration is created.
   * *   If you specify this parameter, the specified EventBridge integration is modified.
   * 
   * @example
   * 123
   */
  id?: number;
  /**
   * @remarks
   * The name of the EventBridge integration.
   * 
   * This parameter is required.
   * 
   * @example
   * EventBridge_Test
   */
  name?: string;
  /**
   * @remarks
   * The event source.
   * 
   * @example
   * arms
   */
  source?: string;
  static names(): { [key: string]: string } {
    return {
      accessKey: 'AccessKey',
      accessSecret: 'AccessSecret',
      description: 'Description',
      endpoint: 'Endpoint',
      eventBusName: 'EventBusName',
      eventBusRegionId: 'EventBusRegionId',
      id: 'Id',
      name: 'Name',
      source: 'Source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKey: 'string',
      accessSecret: 'string',
      description: 'string',
      endpoint: 'string',
      eventBusName: 'string',
      eventBusRegionId: 'string',
      id: 'number',
      name: 'string',
      source: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateEventBridgeIntegrationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the EventBridge integration.
   */
  eventBridgeIntegration?: CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2B289756-E791-5842-BCBD-AD414C******
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      eventBridgeIntegration: 'EventBridgeIntegration',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventBridgeIntegration: CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateEventBridgeIntegrationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateOrUpdateEventBridgeIntegrationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOrUpdateEventBridgeIntegrationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateIMRobotRequest extends $tea.Model {
  /**
   * @remarks
   * The configurations of the alert card template. For more information about the parameters in the template, see the following section.
   * 
   * @example
   * {     "button": [         "claim",         "close",         "follow",         "send_itsm",         "block",         "unResolvedIncident"     ],     "field": [         {             "fieldName": "alarmName",             "visible": true         },         {             "fieldName": "notificationPolicy",             "visible": true         },         {             "fieldName": "alarmContent",             "visible": true         },         {             "fieldName": "alarmTime",             "visible": true         },         {             "fieldName": "seriesChart",             "visible": true         },         {             "fieldName": "includeEvent",             "visible": true         },         {             "fieldName": "assigned",             "visible": true         },         {             "fieldName": "similarAlarm",             "visible": true         },         {             "fieldName": "operator",             "visible": true         }     ] }
   */
  cardTemplate?: string;
  /**
   * @remarks
   * Specifies whether to send daily statistics. Valid values:
   * 
   * *   `false` (default): Daily statistics are not sent.
   * *   `true`: Daily statistics are sent. If you set the value to `true`, the **DailyNocTime** parameter is required.
   * 
   * @example
   * true
   */
  dailyNoc?: boolean;
  /**
   * @remarks
   * The points in time at which the daily statistics are sent. Separate multiple points in time with commas (,). The points in time are in the HH:SS format. The information that ARMS sends at the specified points in time includes the total number of alerts generated on the current day, the number of cleared alerts, and the number of alerts to be cleared.
   * 
   * @example
   * 09:30,17:00
   */
  dailyNocTime?: string;
  /**
   * @remarks
   * The signature key of DingTalk. If you specify a signature key, DingTalk authentication is performed by using the signature key. If you do not specify a signature key, a whitelist is used for authentication by default. The keyword of the whitelist is **Alert**.
   * 
   * @example
   * ******
   */
  dingSignKey?: string;
  /**
   * @remarks
   * Specifies whether to enable the Outgoing feature.
   * 
   * @example
   * true
   */
  enableOutgoing?: boolean;
  /**
   * @remarks
   * The webhook URL of the IM chatbot.
   * 
   * This parameter is required.
   * 
   * @example
   * https://oapi.dingtalk.com/robot/send?access_token=e1a049121******
   */
  robotAddress?: string;
  /**
   * @remarks
   * The ID of the IM chatbot.
   * > If you do not specify the parameter, a new IM chatbot is created.
   * 
   * @example
   * 123
   */
  robotId?: number;
  /**
   * @remarks
   * The name of the IM chatbot.
   * 
   * This parameter is required.
   * 
   * @example
   * Chatbot name
   */
  robotName?: string;
  /**
   * @remarks
   * The token required to enable the Outgoing feature.
   * 
   * @example
   * 1656558719183be1245ab44********
   */
  token?: string;
  /**
   * @remarks
   * The type of the IM chatbot. Valid values:
   * 
   * *   `dingding`: DingTalk chatbot
   * *   `wechat`: WeCom chatbot
   * *   `feishu`: Lark chatbot
   * 
   * This parameter is required.
   * 
   * @example
   * dingding
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      cardTemplate: 'CardTemplate',
      dailyNoc: 'DailyNoc',
      dailyNocTime: 'DailyNocTime',
      dingSignKey: 'DingSignKey',
      enableOutgoing: 'EnableOutgoing',
      robotAddress: 'RobotAddress',
      robotId: 'RobotId',
      robotName: 'RobotName',
      token: 'Token',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cardTemplate: 'string',
      dailyNoc: 'boolean',
      dailyNocTime: 'string',
      dingSignKey: 'string',
      enableOutgoing: 'boolean',
      robotAddress: 'string',
      robotId: 'number',
      robotName: 'string',
      token: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateIMRobotResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the IM chatbot.
   */
  alertRobot?: CreateOrUpdateIMRobotResponseBodyAlertRobot;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 16AF921B-8187-489F-9913-43C808B4****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      alertRobot: 'AlertRobot',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertRobot: CreateOrUpdateIMRobotResponseBodyAlertRobot,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateIMRobotResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateOrUpdateIMRobotResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOrUpdateIMRobotResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateNotificationPolicyRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to enable simple mode.
   * 
   * @example
   * false
   */
  directedMode?: boolean;
  /**
   * @remarks
   * The ID of the escalation policy.
   * 
   * @example
   * 123
   */
  escalationPolicyId?: number;
  /**
   * @remarks
   * An array of alert event group objects.
   * 
   * *   If you do not specify the groupingFields field, all alerts will be sent to contacts based on `alertname`.
   * *   If you specify the groupingFields field, alerts with the same field will be sent to contacts in one notification.
   * 
   * Sample statement:
   * 
   *     { 
   *     "groupWait":5,    // The waiting time for grouping. 
   *     "groupInterval":30,     // The time interval of grouping. 
   *     "groupingFields":["alertname"]       // The field that is used to group alert events. 
   *     }
   * 
   * @example
   * { 	"groupWait":5, 	"groupInterval":30, 	"groupingFields":["alertname"] }
   */
  groupRule?: string;
  /**
   * @remarks
   * The ID of the notification policy.
   * 
   * *   If you do not specify this parameter, a new notification policy is created.
   * *   If you specify this parameter, the specified notification policy is modified.
   * 
   * @example
   * 1234
   */
  id?: number;
  /**
   * @remarks
   * The integration ID of the ticket system to which alerts are pushed.
   * 
   * @example
   * 34
   */
  integrationId?: number;
  /**
   * @remarks
   * The matching rules. Format:
   * 
   *     [
   *      {
   *      "matchingConditions": [
   *      { 
   *      "value": "test",    // The value of the matching condition. 
   *      "key": "alertname",     // The key of the matching condition. 
   *      "operator": "eq"   // The logical operator of the matching condition, including eq (equal to), neq (not equal to), in (contains), nin (does not contain), re (regular expression match), and nre (regular expression mismatch).   
   *      }
   *      ]
   *      } 
   *      ]
   * 
   * @example
   * [ 		 { 		 "matchingConditions": [          { 		 "value": "test", 		 "key": "alertname", 		 "operator": "eq"         }       ]     }   ]
   */
  matchingRules?: string;
  /**
   * @remarks
   * The name of the notification policy.
   * 
   * This parameter is required.
   * 
   * @example
   * notificationpolicy_test
   */
  name?: string;
  /**
   * @remarks
   * An array of notification rule objects. Format:
   * 
   *     { 
   *      "notifyStartTime":"00:00",      // The start time of the notification window. 
   *      "notifyEndTime":"23:59",       // The end time of the notification window. 
   *      "notifyChannels":["dingTalk", "email", "sms", "tts", "webhook"],       // The notification methods. Valid values: dingTalk, email, sms, tts, and webhook. 
   *      "notifyObjects":[{       // An array of notification objects. 
   *      "notifyObjectType":"CONTACT",       // The type of the notification object. Valid values: CONTACT (contact), CONTACT_GROUP (contact group), ARMS_CONTACT (ARMS contact), ARMS_CONTACT_GROUP (ARMS contact group), DING_ROBOT_GROUP (DingTalk, Lark, WeCom, or IM robot), and CONTACT_SCHEDULE (user on duty defined by a schedule). 
   *      "notifyObjectId":123,       // The ID of the notification object. 
   *      "notifyObjectName":"test"       // The name of the notification object. 
   *      }]
   * 
   * This parameter is required.
   * 
   * @example
   * {     "notifyStartTime":"00:00",     "notifyEndTime":"23:59",     "notifyChannels":[         "dingTalk",         "email",         "sms",         "tts",         "webhook"     ],     "notifyObjects":[         {             "notifyObjectType":"CONTACT",             "notifyObjectId":123,             "notifyObjectName":"test"         }     ] }
   */
  notifyRule?: string;
  /**
   * @remarks
   * The notification template. The default notification template is provided below the table.
   * 
   * @example
   * "robotContent":"{{if .commonLabels.clustername }} > Cluster name: {{ .commonLabels.clustername }} {{ end }}{{if eq "app" .commonLabels._aliyun_arms_involvedObject_kind }} > Application name: {{ .commonLabels._aliyun_arms_involvedObject_name }} {{ end }}{{ for .alerts }} > {{.annotations.message}} {{if .generatorURL }} [Link]\\({{.generatorURL}}) {{ end }} {{if eq "true" .labels._aliyun_arms_is_denoise_filtered }} (Suspected noise) {{end}} {{end}}"
   */
  notifyTemplate?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * Specifies whether to resend a notification for a long-lasting unresolved alert. Default value: true. Valid values:
   * 
   * *   `true`: If you set this parameter to `true`, you must set **RepeatInterval**.
   * *   `false`: If you set this parameter to `false`, you must set **EscalationPolicyId**.
   * 
   * @example
   * true
   */
  repeat?: boolean;
  /**
   * @remarks
   * The time interval at which a notification is resent for a long-lasting unresolved alert. Unit: seconds.
   * 
   * @example
   * 600
   */
  repeatInterval?: number;
  /**
   * @remarks
   * Specifies whether the status of an alert automatically changes to Resolved when all events related to the alert change to the Restored state. ARMS notifies contacts when the alert status changes to Resolved.
   * 
   * *   `true`: The system sends a notification.
   * *   `false`: The system does not send a notification.
   * 
   * @example
   * true
   */
  sendRecoverMessage?: boolean;
  /**
   * @remarks
   * Specifies whether to enable the notification policy. Valid values: enable and disable.
   * 
   * @example
   * enable
   */
  state?: string;
  static names(): { [key: string]: string } {
    return {
      directedMode: 'DirectedMode',
      escalationPolicyId: 'EscalationPolicyId',
      groupRule: 'GroupRule',
      id: 'Id',
      integrationId: 'IntegrationId',
      matchingRules: 'MatchingRules',
      name: 'Name',
      notifyRule: 'NotifyRule',
      notifyTemplate: 'NotifyTemplate',
      regionId: 'RegionId',
      repeat: 'Repeat',
      repeatInterval: 'RepeatInterval',
      sendRecoverMessage: 'SendRecoverMessage',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      directedMode: 'boolean',
      escalationPolicyId: 'number',
      groupRule: 'string',
      id: 'number',
      integrationId: 'number',
      matchingRules: 'string',
      name: 'string',
      notifyRule: 'string',
      notifyTemplate: 'string',
      regionId: 'string',
      repeat: 'boolean',
      repeatInterval: 'number',
      sendRecoverMessage: 'boolean',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateNotificationPolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * An array of notification policy objects.
   */
  notificationPolicy?: CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * A5EC8221-08F2-4C95-9AF1-49FD998C****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      notificationPolicy: 'NotificationPolicy',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      notificationPolicy: CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateNotificationPolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateOrUpdateNotificationPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOrUpdateNotificationPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateSilencePolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The effective duration of the silence policy. Valid values: PERMANENT, CUSTOM_TIME, and CYCLE_EFFECT.
   * 
   * @example
   * PERMANENT
   */
  effectiveTimeType?: string;
  /**
   * @remarks
   * The ID of the silence policy.
   * 
   * *   If you do not configure this parameter, a new silence policy is created.
   * *   If you configure this parameter, the specified silence policy is modified.
   * 
   * @example
   * 1234
   */
  id?: number;
  /**
   * @remarks
   * The matching rules. The following code shows the format of matching rules:
   * 
   *     [
   *          {
   *     	 "matchingConditions": [
   *     	 {
   *     	 "value": "test", // The value of the matching condition. 
   *     	 "key": "altertname", // The key of the matching condition. 
   *     	 "operator": "eq" // The logical operator of the matching condition, including eq (equal to), neq (not equal to), in (contains), nin (does not contain), re (regular expression match), and nre (regular expression mismatch).   
   *     	 }
   *     	 ]
   *          }
   *     	 ]
   * 
   * @example
   * [ 	 { 	 "matchingConditions": [ 	 { 	 "value": "test", 	 "key": "altertname", 	 "operator": "eq" 	 } 	 ]      } 	 ]
   */
  matchingRules?: string;
  /**
   * @remarks
   * The name of the silence policy.
   * 
   * This parameter is required.
   * 
   * @example
   * silencepolicy_test
   */
  name?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * Specifies whether to enable the silence policy. Valid values: enable and disable.
   * 
   * @example
   * enable
   */
  state?: string;
  /**
   * @remarks
   * The recurring period. This parameter is required when EffectiveTimeType is set to CYCLE_EFFECT. DAY: The silence policy is effective by day. WEEK: The silence policy is effective by week.
   * 
   * @example
   * DAY
   */
  timePeriod?: string;
  /**
   * @remarks
   * The time period during which the silence policy is effective. If you set EffectiveTimeType to CUSTOM_TIME, specify a custom time period in the following format: [{"startTime":"2024-08-04 22:13","endTime":"2024-08-04 22:21"}] If you set EffectiveTimeType to CYCLE_EFFECT and TimePeriod to DAY, specify a custom time period in the following format: [{"startTime":"22:13","endTime":"22:21"}]. The start time cannot be later than the end time. If you set EffectiveTimeType to CYCLE_EFFECT and TimePeriod to WEEK, specify a custom time period in the following format: [{"startWeek":"1", "endWeek":"2" "startTime":"22:13","endTime":"22:21"}]. Valid values of startWeek and endWeek: 1 to 7. The start time cannot be later than the end time.
   * 
   * @example
   * [{"startTime":"2024-08-04 22:13","endTime":"2024-08-04 22:21"}]
   */
  timeSlots?: string;
  static names(): { [key: string]: string } {
    return {
      effectiveTimeType: 'EffectiveTimeType',
      id: 'Id',
      matchingRules: 'MatchingRules',
      name: 'Name',
      regionId: 'RegionId',
      state: 'State',
      timePeriod: 'TimePeriod',
      timeSlots: 'TimeSlots',
    };
  }

  static types(): { [key: string]: any } {
    return {
      effectiveTimeType: 'string',
      id: 'number',
      matchingRules: 'string',
      name: 'string',
      regionId: 'string',
      state: 'string',
      timePeriod: 'string',
      timeSlots: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateSilencePolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * A5EC8221-08F2-4C95-9AF1-49FD998C****
   */
  requestId?: string;
  /**
   * @remarks
   * A list of silence policies.
   */
  silencePolicy?: CreateOrUpdateSilencePolicyResponseBodySilencePolicy;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      silencePolicy: 'SilencePolicy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      silencePolicy: CreateOrUpdateSilencePolicyResponseBodySilencePolicy,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateSilencePolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateOrUpdateSilencePolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOrUpdateSilencePolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateWebhookContactRequest extends $tea.Model {
  /**
   * @remarks
   * The HTTP request headers.
   * 
   * @example
   * [{"Content-Type":"application/json;charset=utf-8"}]
   */
  bizHeaders?: string;
  /**
   * @remarks
   * The parameters in the HTTP request.
   * 
   * @example
   * [{"content":"mike"}]
   */
  bizParams?: string;
  /**
   * @remarks
   * The notification template that is sent when an alert is triggered. This parameter is required if the **Method** parameter is set to **Post**. You can use the `$content` placeholder to specify the notification content. The content cannot exceed 500 characters in length. For more information, see [Variable description of a notification template](https://help.aliyun.com/document_detail/251834.html).\\\\
   * 
   * @example
   * { "Alert name":"{{ .commonLabels.alertname }}{{if .commonLabels.clustername }}", "Cluster name":"{{ .commonLabels.clustername }} {{ end }}{{if eq "app" .commonLabels._aliyun_arms_involvedObject_kind }}", "Application name":"{{ .commonLabels._aliyun_arms_involvedObject_name }} {{ end }}", "Notification policy":"{{ .dispatchRuleName }}", "Alert time":"{{ .startTime }}", "Alert content":"{{ for .alerts }} {{ .annotations.message }} {{ end }}" }
   */
  body?: string;
  /**
   * @remarks
   * The HTTP request method.
   * 
   * *   Post
   * *   Get
   * 
   * This parameter is required.
   * 
   * @example
   * Post
   */
  method?: string;
  /**
   * @remarks
   * The notification template that is sent when an alert is resolved. This parameter is required if the **Method** parameter is set to **Post**. You can use the `$content` placeholder to specify the notification content. The content cannot exceed 500 characters in length. For more information, see [Variable description of a notification template](https://help.aliyun.com/document_detail/251834.html).
   * 
   * @example
   * { "Alert name":"{{ .commonLabels.alertname }}{{if .commonLabels.clustername }}", "Cluster name":"{{ .commonLabels.clustername }} {{ end }}{{if eq "app" .commonLabels._aliyun_arms_involvedObject_kind }}", "Application name":"{{ .commonLabels._aliyun_arms_involvedObject_name }} {{ end }}", "Notification policy":"{{ .dispatchRuleName }}", "Recovery time":"{{ .endTime }}", "Alert content":"{{ for .alerts }} {{ .annotations.message }} {{ end }}" }
   */
  recoverBody?: string;
  /**
   * @remarks
   * The URL of the HTTP request **method**.
   * 
   * This parameter is required.
   * 
   * @example
   * https://oapi.dingtalk.com/robot/send?access_token=e1a049121******
   */
  url?: string;
  /**
   * @remarks
   * The ID of the webhook alert contact.
   * 
   * *   If you do not specify this parameter, a new webhook alert contact is created.
   * * If you specify this parameter, the specified webhook alert contact is modified.
   * 
   * @example
   * 123
   */
  webhookId?: number;
  /**
   * @remarks
   * The name of the webhook alert contact.
   * 
   * This parameter is required.
   * 
   * @example
   * Webhook alert
   */
  webhookName?: string;
  static names(): { [key: string]: string } {
    return {
      bizHeaders: 'BizHeaders',
      bizParams: 'BizParams',
      body: 'Body',
      method: 'Method',
      recoverBody: 'RecoverBody',
      url: 'Url',
      webhookId: 'WebhookId',
      webhookName: 'WebhookName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizHeaders: 'string',
      bizParams: 'string',
      body: 'string',
      method: 'string',
      recoverBody: 'string',
      url: 'string',
      webhookId: 'number',
      webhookName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateWebhookContactResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 16AF921B-8187-489F-9913-43C808B4****
   */
  requestId?: string;
  /**
   * @remarks
   * The returned webhook alert contact.
   */
  webhookContact?: CreateOrUpdateWebhookContactResponseBodyWebhookContact;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      webhookContact: 'WebhookContact',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      webhookContact: CreateOrUpdateWebhookContactResponseBodyWebhookContact,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateWebhookContactResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateOrUpdateWebhookContactResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOrUpdateWebhookContactResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePrometheusAlertRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * This parameter is required.
   * 
   * @example
   * Prometheus_Alert
   */
  alertName?: string;
  /**
   * @remarks
   * The annotations that are described in a JSON string. You must specify the name and value of each annotation.
   * 
   * @example
   * [{"Value": "xxx","Name": "description"}]
   */
  annotations?: string;
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * c0bad479465464e1d8c1e641b0afb****
   */
  clusterId?: string;
  /**
   * @remarks
   * The ID of the notification policy. This parameter is required if the NotifyType parameter is set to `DISPATCH_RULE`.
   * 
   * @example
   * 10282
   */
  dispatchRuleId?: number;
  /**
   * @remarks
   * The duration. The value ranges from 1 to 1440 minutes.
   * 
   * This parameter is required.
   * 
   * @example
   * 10m
   */
  duration?: string;
  /**
   * @remarks
   * The expression of the alert rule. The expression must follow the PromQL syntax.
   * 
   * This parameter is required.
   * 
   * @example
   * 100 * (sum(rate(container_cpu_usage_seconds_total[1m])) by (pod_name) / sum(label_replace(kube_pod_container_resource_limits_cpu_cores, \\"pod_name\\", \\"$1\\", \\"pod\\", \\"(.*)\\")) by (pod_name))>75
   */
  expression?: string;
  /**
   * @remarks
   * The tags that are described in a JSON string. You must specify the name and value of each tag.
   * 
   * @example
   * [{"Value": "critical","Name": "severity"}]
   */
  labels?: string;
  /**
   * @remarks
   * The content of the alert notification. Tags can be referenced in the {{$labels.xxx}} format.
   * 
   * This parameter is required.
   * 
   * @example
   * The CPU utilization of ${{$labels.pod_name}} has exceeded 80%. Current value: {{$value}}%
   */
  message?: string;
  /**
   * @remarks
   * The method that is used to send alert notifications. Valid values:
   * 
   * - `ALERT_MANAGER`: Alert notifications are sent by Operation Center. This is the default value.
   * - `DISPATCH_RULE`: Alert notifications are sent based on the specified notification policy.
   * 
   * @example
   * ALERT_MANAGER
   */
  notifyType?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The tags.
   */
  tags?: CreatePrometheusAlertRuleRequestTags[];
  /**
   * @remarks
   * The type of the alert rule. Valid values:
   * 
   * - 99: custom alert
   * - 101: Prometheus Service alert
   * 
   * @example
   * 101
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      alertName: 'AlertName',
      annotations: 'Annotations',
      clusterId: 'ClusterId',
      dispatchRuleId: 'DispatchRuleId',
      duration: 'Duration',
      expression: 'Expression',
      labels: 'Labels',
      message: 'Message',
      notifyType: 'NotifyType',
      regionId: 'RegionId',
      tags: 'Tags',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertName: 'string',
      annotations: 'string',
      clusterId: 'string',
      dispatchRuleId: 'number',
      duration: 'string',
      expression: 'string',
      labels: 'string',
      message: 'string',
      notifyType: 'string',
      regionId: 'string',
      tags: { 'type': 'array', 'itemType': CreatePrometheusAlertRuleRequestTags },
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePrometheusAlertRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The returned struct.
   */
  prometheusAlertRule?: CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9FEA6D00-317F-45E3-9004-7FB8B0B7****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      prometheusAlertRule: 'PrometheusAlertRule',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      prometheusAlertRule: CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePrometheusAlertRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreatePrometheusAlertRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreatePrometheusAlertRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePrometheusInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * Does it require all child instances to be verified successfully before creating a GlobalView instance. The default is false, which means partial success is possible.
   * 
   * @example
   * true
   */
  allSubClustersSuccess?: boolean;
  /**
   * @remarks
   * The number of days for which data is automatically archived after the storage expires. Valid values: 60, 90, 180, and 365. 0 indicates that the data is not archived.
   * 
   * @example
   * 90
   */
  archiveDuration?: number;
  /**
   * @remarks
   * The ID of the ACK cluster. This parameter is required if you set the ClusterType parameter to aliyun-cs.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The name of the created cluster. This parameter is required if you set the ClusterType parameter to remote-write or ecs.
   * 
   * @example
   * clusterNameOfTest
   */
  clusterName?: string;
  /**
   * @remarks
   * The type of the Prometheus instance. Valid values:
   * 
   * *   remote-write: Prometheus instance for Remote Write
   * *   ecs (unavailable): Prometheus instance for ECS
   * *   global-view: Prometheus instance for GlobalView
   * *   aliyun-cs: Prometheus instance for Container Service
   * *   cloud-product (unavailable): Prometheus instance for Alibaba Cloud services
   * *   cloud-monitor (unavailable): Prometheus instance for Hybrid Cloud Monitoring
   * *   flink (unavailable): Prometheus instance for Flink
   * 
   * This parameter is required.
   * 
   * @example
   * remote-write
   */
  clusterType?: string;
  /**
   * @remarks
   * The data storage duration. Unit: days.
   * 
   * @example
   * 90
   */
  duration?: number;
  /**
   * @remarks
   * The ID of the Grafana dedicated instance. This parameter is available if you set the ClusterType parameter to ecs.
   * 
   * @example
   * grafana-bp1*****
   */
  grafanaInstanceId?: string;
  /**
   * @remarks
   * The ID of the region. If you use a Prometheus instance to monitor an Alibaba Cloud service in China, this parameter must be set to cn-shanghai.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-shanghai
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the custom resource group. You can configure this parameter to bind the instance to the resource group.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The ID of the security group. This parameter is required if you set the ClusterType parameter to ecs.
   * 
   * @example
   * sg-bp1********
   */
  securityGroupId?: string;
  /**
   * @remarks
   * JSON string for child instances of the globalView instance.
   * 
   * @example
   * When the clusterType is global view, this parameter needs to be passed: a list of information about the clusters that need to be aggregated.
   * Example:
   * [
   *   {
   *     "Headers":{
   * 
   *     },
   *     "RegionId": "cn hangzhou",
   *     "SourceType": "Alibaba Prometheus",
   *     "Extras":{
   * 
   *     },
   *     "ClusterId": "c39a1048921e04f ****************",
   *     "SourceName": "test1",
   *     "DataSource": "",
   *     "UserId": "1672753 ******************"
   *   },
   *   {
   *     "Headers":{
   * 
   *     },
   *     "RegionId": "cn beijing",
   *     "SourceType": "Alibaba Prometheus",
   *     "Extras":{
   * 
   *     },
   *     "ClusterId": "c6b6485496d5b40 ****************",
   *     "SourceName": "test2",
   *     "DataSource": "",
   *     "UserId": "1672753 ******************"
   *   },
   *   {
   *     "Headers":{
   * 
   *     },
   *     "RegionId": "cn zhangjiakou",
   *     "SourceType": "Alibaba Prometheus",
   *     "Extras":{
   * 
   *     },
   *     "ClusterId": "c261a4f3200c446 ****************",
   *     "SourceName": "test3",
   *     "DataSource": "",
   *     "UserId": "1672753 ******************"
   *   }
   * ]
   */
  subClustersJson?: string;
  /**
   * @remarks
   * The tags of the instance. You can configure this parameter to manage tags for the instance.
   * 
   * @example
   * [
   *     {
   *         "labelName":"labelValue"
   *     },
   *     {
   *         "testName":"clusterA"
   *     }
   * ]
   */
  tags?: CreatePrometheusInstanceRequestTags[];
  /**
   * @remarks
   * The ID of the vSwitch. This parameter is required if you set the ClusterType parameter to ecs.
   * 
   * @example
   * vsw-bp1*********
   */
  vSwitchId?: string;
  /**
   * @remarks
   * The ID of virtual private cloud (VPC). This parameter is required if you set the ClusterType parameter to ecs.
   * 
   * @example
   * vpc-rpn**********
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      allSubClustersSuccess: 'AllSubClustersSuccess',
      archiveDuration: 'ArchiveDuration',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      clusterType: 'ClusterType',
      duration: 'Duration',
      grafanaInstanceId: 'GrafanaInstanceId',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      securityGroupId: 'SecurityGroupId',
      subClustersJson: 'SubClustersJson',
      tags: 'Tags',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allSubClustersSuccess: 'boolean',
      archiveDuration: 'number',
      clusterId: 'string',
      clusterName: 'string',
      clusterType: 'string',
      duration: 'number',
      grafanaInstanceId: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      securityGroupId: 'string',
      subClustersJson: 'string',
      tags: { 'type': 'array', 'itemType': CreatePrometheusInstanceRequestTags },
      vSwitchId: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePrometheusInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The ID of the created Prometheus instance.
   * 
   * @example
   * qduukd****
   */
  data?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 70675725-8F11-4817-8106-CFE0AD71****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePrometheusInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreatePrometheusInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreatePrometheusInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePrometheusMonitoringRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the Prometheus instance.
   * 
   * This parameter is required.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The monitoring configuration. Specify a YAML string.
   * 
   * This parameter is required.
   * 
   * @example
   * Please refer to the supplementary explanation of the request parameters.
   */
  configYaml?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The status of the monitoring configuration. Valid values: run and stop. Default value: run. This parameter is not available if the Type parameter is set to Probe.
   * 
   * @example
   * run
   */
  status?: string;
  /**
   * @remarks
   * The type of the monitoring configuration. 
   * Valid values for a Prometheus instance for Container Service: serviceMonitor, podMonitor, customJob, and probe. 
   * Valid values for a Prometheus instance for ECS: customJob and probe.
   * 
   * This parameter is required.
   * 
   * @example
   * serviceMonitor
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      configYaml: 'ConfigYaml',
      regionId: 'RegionId',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      configYaml: 'string',
      regionId: 'string',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePrometheusMonitoringResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The name of the monitoring configuration that was added, or the exception information.
   * 
   * @example
   * name1
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 21E85B16-75A6-429A-9F65-8AAC9A54****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePrometheusMonitoringResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreatePrometheusMonitoringResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreatePrometheusMonitoringResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRetcodeAppRequest extends $tea.Model {
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group. You can obtain the resource group ID in the **Resource Management** console.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * This parameter is required.
   * 
   * @example
   * SdkTest
   */
  retcodeAppName?: string;
  /**
   * @remarks
   * The type of the application. Valid values:
   * 
   * *   `web`: web application
   * *   `weex`: Weex mobile app
   * *   `mini_dd`: DingTalk mini program
   * *   `mini_alipay`: Alipay mini program
   * *   `mini_wx`: WeChat mini program
   * *   `mini_common`: mini program on other platforms
   * 
   * This parameter is required.
   * 
   * @example
   * mini_dd
   */
  retcodeAppType?: string;
  /**
   * @remarks
   * The tags that you want to add to the task.
   */
  tags?: CreateRetcodeAppRequestTags[];
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      retcodeAppName: 'RetcodeAppName',
      retcodeAppType: 'RetcodeAppType',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      resourceGroupId: 'string',
      retcodeAppName: 'string',
      retcodeAppType: 'string',
      tags: { 'type': 'array', 'itemType': CreateRetcodeAppRequestTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRetcodeAppResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The response parameters.
   * 
   * @example
   * bdidt76ehx@d5cf1cd3f7df411
   */
  data?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * A5EC8221-08F2-4C95-9AF1-49FD998C647A
   */
  requestId?: string;
  /**
   * @remarks
   * The information of the Browser Monitoring task.
   */
  retcodeAppDataBean?: CreateRetcodeAppResponseBodyRetcodeAppDataBean;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * - true: The call was successful.
   * - false: The call failed.
   * 
   * @example
   * True
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      retcodeAppDataBean: 'RetcodeAppDataBean',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
      retcodeAppDataBean: CreateRetcodeAppResponseBodyRetcodeAppDataBean,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRetcodeAppResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateRetcodeAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateRetcodeAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRumAppRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the application group.
   * 
   * @example
   * default
   */
  appGroup?: string;
  /**
   * @remarks
   * The application name.
   * 
   * This parameter is required.
   * 
   * @example
   * test-app
   */
  appName?: string;
  /**
   * @remarks
   * The description of the application.
   * 
   * @example
   * Monitoring description
   */
  description?: string;
  /**
   * @remarks
   * The nickname of the application.
   * 
   * @example
   * test-app
   */
  nickName?: string;
  /**
   * @remarks
   * The name of the Android application package. This parameter is required if you create an Android application.
   * 
   * @example
   * com.xxxx.xxxxxx
   */
  packageName?: string;
  realRegionId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The application type. Valid values: web, miniapp, ios, and android.
   * 
   * This parameter is required.
   * 
   * @example
   * web
   */
  siteType?: string;
  /**
   * @remarks
   * The source. This is a reserved parameter.
   * 
   * @example
   * arms
   */
  source?: string;
  /**
   * @remarks
   * The list of tags. You can specify a maximum of 20 tags.
   */
  tag?: CreateRumAppRequestTag[];
  static names(): { [key: string]: string } {
    return {
      appGroup: 'AppGroup',
      appName: 'AppName',
      description: 'Description',
      nickName: 'NickName',
      packageName: 'PackageName',
      realRegionId: 'RealRegionId',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      siteType: 'SiteType',
      source: 'Source',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appGroup: 'string',
      appName: 'string',
      description: 'string',
      nickName: 'string',
      packageName: 'string',
      realRegionId: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      siteType: 'string',
      source: 'string',
      tag: { 'type': 'array', 'itemType': CreateRumAppRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRumAppShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the application group.
   * 
   * @example
   * default
   */
  appGroup?: string;
  /**
   * @remarks
   * The application name.
   * 
   * This parameter is required.
   * 
   * @example
   * test-app
   */
  appName?: string;
  /**
   * @remarks
   * The description of the application.
   * 
   * @example
   * Monitoring description
   */
  description?: string;
  /**
   * @remarks
   * The nickname of the application.
   * 
   * @example
   * test-app
   */
  nickName?: string;
  /**
   * @remarks
   * The name of the Android application package. This parameter is required if you create an Android application.
   * 
   * @example
   * com.xxxx.xxxxxx
   */
  packageName?: string;
  realRegionId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The application type. Valid values: web, miniapp, ios, and android.
   * 
   * This parameter is required.
   * 
   * @example
   * web
   */
  siteType?: string;
  /**
   * @remarks
   * The source. This is a reserved parameter.
   * 
   * @example
   * arms
   */
  source?: string;
  /**
   * @remarks
   * The list of tags. You can specify a maximum of 20 tags.
   */
  tagShrink?: string;
  static names(): { [key: string]: string } {
    return {
      appGroup: 'AppGroup',
      appName: 'AppName',
      description: 'Description',
      nickName: 'NickName',
      packageName: 'PackageName',
      realRegionId: 'RealRegionId',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      siteType: 'SiteType',
      source: 'Source',
      tagShrink: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appGroup: 'string',
      appName: 'string',
      description: 'string',
      nickName: 'string',
      packageName: 'string',
      realRegionId: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      siteType: 'string',
      source: 'string',
      tagShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRumAppResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. 2XX indicates that the request was successful. 3XX indicates that the request was redirected. 4XX indicates that a request error occurred. 5XX indicates that a server error occurred.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The application ID and domain names. This parameter is returned if the application is created. Multiple domain names are separated with commas (,).
   * 
   * @example
   * ggxxxnjuz@xxxx,xxxxxx-default-cn.rum.aliyuncs.com
   */
  data?: CreateRumAppResponseBodyData;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1A474FF8-7861-4D00-81B5-5BC3DA4E****
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      resourceGroupId: 'ResourceGroupId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: CreateRumAppResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      resourceGroupId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRumAppResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateRumAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateRumAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRumUploadFileUrlRequest extends $tea.Model {
  /**
   * @remarks
   * The application name.
   * 
   * @example
   * test-app
   */
  appName?: string;
  /**
   * @remarks
   * The type of the file. You can set this parameter to "application/zip", "text/plain", or an empty string.
   * 
   * @example
   * text/plain
   */
  contentType?: string;
  /**
   * @remarks
   * The file name.
   * 
   * This parameter is required.
   * 
   * @example
   * test.js.map
   */
  fileName?: string;
  /**
   * @remarks
   * The process ID (PID) of the application.
   * 
   * This parameter is required.
   * 
   * @example
   * iioe7jcnuk@582846f37******
   */
  pid?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The file type. Valid values: source-map: SourceMap files. mapping: symbol table files for Android. dsym: dSYM files for iOS.
   * 
   * @example
   * source-map
   */
  sourcemapType?: string;
  /**
   * @remarks
   * The file ID.
   * 
   * @example
   * 125bdb39-a415-4503-bd96-e293925fc64c
   */
  uuid?: string;
  /**
   * @remarks
   * The version number of the file.
   * 
   * @example
   * 1.0.0
   */
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      contentType: 'ContentType',
      fileName: 'FileName',
      pid: 'Pid',
      regionId: 'RegionId',
      sourcemapType: 'SourcemapType',
      uuid: 'Uuid',
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      contentType: 'string',
      fileName: 'string',
      pid: 'string',
      regionId: 'string',
      sourcemapType: 'string',
      uuid: 'string',
      versionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRumUploadFileUrlResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The file upload URL.
   * 
   * @example
   * http://arms-rum-v2.oss-cn-hangzhou.aliyuncs.com/113197164xxxxx28/b590lhguqs%40f93xxxxxbf31d3/1.0.0-robots.txt?Expires=1713847079&OSSAccessKeyId=STS.NT6XvoxkyqA&Signature=6ptYX4OTjLMrsleTlA2t97
   */
  data?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * A5EC8221-08F2-4C95-9AF1-49FD998C****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRumUploadFileUrlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateRumUploadFileUrlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateRumUploadFileUrlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSyntheticTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The common parameters.
   */
  commonParam?: CreateSyntheticTaskRequestCommonParam;
  /**
   * @remarks
   * The file download task.
   */
  download?: CreateSyntheticTaskRequestDownload;
  /**
   * @remarks
   * The frequency.
   */
  extendInterval?: CreateSyntheticTaskRequestExtendInterval;
  /**
   * @remarks
   * The interval at which synthetic monitoring is performed. Unit: minutes. Valid values:
   * 
   * *   1
   * *   5
   * *   10
   * *   15
   * *   20
   * *   30
   * *   60
   * *   120
   * *   180
   * *   240
   * *   360
   * *   480
   * *   720
   * *   1440
   * 
   * This parameter is required.
   * 
   * @example
   * 5
   */
  intervalTime?: string;
  /**
   * @remarks
   * The interval type.
   * 
   * *   0: daily
   * *   1: custom frequency
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  intervalType?: string;
  /**
   * @remarks
   * The IP address type:
   * 
   * *   0: an automatic IP address
   * *   1: IPv4
   * *   2: IPv6
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  ipType?: number;
  /**
   * @remarks
   * The list of monitoring points.
   * 
   * This parameter is required.
   */
  monitorList?: CreateSyntheticTaskRequestMonitorList[];
  /**
   * @remarks
   * The monitoring items that are associated with the browse tasks.
   */
  navigation?: CreateSyntheticTaskRequestNavigation;
  /**
   * @remarks
   * The network synthetic monitoring task.
   */
  net?: CreateSyntheticTaskRequestNet;
  /**
   * @remarks
   * The API performance synthetic monitoring task.
   */
  protocol?: CreateSyntheticTaskRequestProtocol;
  /**
   * @remarks
   * The ID of the region in which the application is located.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The name of the task. To update a synthetic monitoring task, enter the task name and set the **UpdateTask** parameter to **true**.
   * 
   * This parameter is required.
   * 
   * @example
   * Network synthetic monitoring task
   */
  taskName?: string;
  /**
   * @remarks
   * The type of the monitoring task. Valid values:
   * 
   * 1.  3: web page performance - IE
   * 2.  34: web Page Performance - Chrome
   * 3.  0: network quality
   * 4.  40: file download
   * 5.  7:API performance
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  taskType?: number;
  /**
   * @remarks
   * Specifies whether to update existing synthetic monitoring tasks.
   * 
   * *   true: updates existing synthetic monitoring tasks.
   * *   false: creates new synthetic monitoring tasks.
   * 
   * @example
   * false
   */
  updateTask?: boolean;
  /**
   * @remarks
   * The URL for synthetic monitoring.
   * 
   * This parameter is required.
   * 
   * @example
   * https://www.example.com
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      commonParam: 'CommonParam',
      download: 'Download',
      extendInterval: 'ExtendInterval',
      intervalTime: 'IntervalTime',
      intervalType: 'IntervalType',
      ipType: 'IpType',
      monitorList: 'MonitorList',
      navigation: 'Navigation',
      net: 'Net',
      protocol: 'Protocol',
      regionId: 'RegionId',
      taskName: 'TaskName',
      taskType: 'TaskType',
      updateTask: 'UpdateTask',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonParam: CreateSyntheticTaskRequestCommonParam,
      download: CreateSyntheticTaskRequestDownload,
      extendInterval: CreateSyntheticTaskRequestExtendInterval,
      intervalTime: 'string',
      intervalType: 'string',
      ipType: 'number',
      monitorList: { 'type': 'array', 'itemType': CreateSyntheticTaskRequestMonitorList },
      navigation: CreateSyntheticTaskRequestNavigation,
      net: CreateSyntheticTaskRequestNet,
      protocol: CreateSyntheticTaskRequestProtocol,
      regionId: 'string',
      taskName: 'string',
      taskType: 'number',
      updateTask: 'boolean',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSyntheticTaskShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The common parameters.
   */
  commonParamShrink?: string;
  /**
   * @remarks
   * The file download task.
   */
  downloadShrink?: string;
  /**
   * @remarks
   * The frequency.
   */
  extendIntervalShrink?: string;
  /**
   * @remarks
   * The interval at which synthetic monitoring is performed. Unit: minutes. Valid values:
   * 
   * *   1
   * *   5
   * *   10
   * *   15
   * *   20
   * *   30
   * *   60
   * *   120
   * *   180
   * *   240
   * *   360
   * *   480
   * *   720
   * *   1440
   * 
   * This parameter is required.
   * 
   * @example
   * 5
   */
  intervalTime?: string;
  /**
   * @remarks
   * The interval type.
   * 
   * *   0: daily
   * *   1: custom frequency
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  intervalType?: string;
  /**
   * @remarks
   * The IP address type:
   * 
   * *   0: an automatic IP address
   * *   1: IPv4
   * *   2: IPv6
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  ipType?: number;
  /**
   * @remarks
   * The list of monitoring points.
   * 
   * This parameter is required.
   */
  monitorListShrink?: string;
  /**
   * @remarks
   * The monitoring items that are associated with the browse tasks.
   */
  navigationShrink?: string;
  /**
   * @remarks
   * The network synthetic monitoring task.
   */
  netShrink?: string;
  /**
   * @remarks
   * The API performance synthetic monitoring task.
   */
  protocolShrink?: string;
  /**
   * @remarks
   * The ID of the region in which the application is located.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The name of the task. To update a synthetic monitoring task, enter the task name and set the **UpdateTask** parameter to **true**.
   * 
   * This parameter is required.
   * 
   * @example
   * Network synthetic monitoring task
   */
  taskName?: string;
  /**
   * @remarks
   * The type of the monitoring task. Valid values:
   * 
   * 1.  3: web page performance - IE
   * 2.  34: web Page Performance - Chrome
   * 3.  0: network quality
   * 4.  40: file download
   * 5.  7:API performance
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  taskType?: number;
  /**
   * @remarks
   * Specifies whether to update existing synthetic monitoring tasks.
   * 
   * *   true: updates existing synthetic monitoring tasks.
   * *   false: creates new synthetic monitoring tasks.
   * 
   * @example
   * false
   */
  updateTask?: boolean;
  /**
   * @remarks
   * The URL for synthetic monitoring.
   * 
   * This parameter is required.
   * 
   * @example
   * https://www.example.com
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      commonParamShrink: 'CommonParam',
      downloadShrink: 'Download',
      extendIntervalShrink: 'ExtendInterval',
      intervalTime: 'IntervalTime',
      intervalType: 'IntervalType',
      ipType: 'IpType',
      monitorListShrink: 'MonitorList',
      navigationShrink: 'Navigation',
      netShrink: 'Net',
      protocolShrink: 'Protocol',
      regionId: 'RegionId',
      taskName: 'TaskName',
      taskType: 'TaskType',
      updateTask: 'UpdateTask',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonParamShrink: 'string',
      downloadShrink: 'string',
      extendIntervalShrink: 'string',
      intervalTime: 'string',
      intervalType: 'string',
      ipType: 'number',
      monitorListShrink: 'string',
      navigationShrink: 'string',
      netShrink: 'string',
      protocolShrink: 'string',
      regionId: 'string',
      taskName: 'string',
      taskType: 'number',
      updateTask: 'boolean',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSyntheticTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * *   1001: The request was successful.
   * *   1002: The request failed.
   * *   1003: Parameter errors occurred.
   * *   1004: Authentication failed.
   * *   1006: The task does not exist.
   * *   1099: Internal errors occurred.
   * 
   * @example
   * 1001
   */
  code?: string;
  /**
   * @remarks
   * The information about the synthetic monitoring task.
   */
  data?: CreateSyntheticTaskResponseBodyData;
  /**
   * @remarks
   * The message that is returned when the task failed to be created.
   * 
   * @example
   * null
   */
  msg?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * A5EC8221-08F2-4C95-9AF1-49FD998C****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      msg: 'Msg',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: CreateSyntheticTaskResponseBodyData,
      msg: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSyntheticTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateSyntheticTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSyntheticTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTimingSyntheticTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The list of assertions.
   */
  availableAssertions?: CreateTimingSyntheticTaskRequestAvailableAssertions[];
  /**
   * @remarks
   * The general settings.
   */
  commonSetting?: CreateTimingSyntheticTaskRequestCommonSetting;
  /**
   * @remarks
   * The general settings.
   */
  customPeriod?: CreateTimingSyntheticTaskRequestCustomPeriod;
  /**
   * @remarks
   * The detection frequency. Valid values: 1m, 5m, 10m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, and 24h.
   * 
   * This parameter is required.
   * 
   * @example
   * 5m
   */
  frequency?: string;
  /**
   * @remarks
   * The detection point type. Valid values:
   * 
   * - 1: PC
   * - 2: mobile device
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  monitorCategory?: number;
  /**
   * @remarks
   * The monitoring configurations.
   * 
   * This parameter is required.
   */
  monitorConf?: CreateTimingSyntheticTaskRequestMonitorConf;
  /**
   * @remarks
   * The list of detection points.
   * 
   * This parameter is required.
   */
  monitors?: CreateTimingSyntheticTaskRequestMonitors[];
  /**
   * @remarks
   * The name of the task.
   * 
   * This parameter is required.
   * 
   * @example
   * demo-test
   */
  name?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The parameter is optional.
   * 
   * @example
   * xxxx
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The tag list.
   */
  tags?: CreateTimingSyntheticTaskRequestTags[];
  /**
   * @remarks
   * The type of the task. Valid values:
   * 
   * 1: ICMP. 2: TCP. 3: DNS. 4: HTTP. 5: website speed measurement. 6: file download.
   * 
   * This parameter is required.
   * 
   * @example
   * 4
   */
  taskType?: number;
  static names(): { [key: string]: string } {
    return {
      availableAssertions: 'AvailableAssertions',
      commonSetting: 'CommonSetting',
      customPeriod: 'CustomPeriod',
      frequency: 'Frequency',
      monitorCategory: 'MonitorCategory',
      monitorConf: 'MonitorConf',
      monitors: 'Monitors',
      name: 'Name',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      tags: 'Tags',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableAssertions: { 'type': 'array', 'itemType': CreateTimingSyntheticTaskRequestAvailableAssertions },
      commonSetting: CreateTimingSyntheticTaskRequestCommonSetting,
      customPeriod: CreateTimingSyntheticTaskRequestCustomPeriod,
      frequency: 'string',
      monitorCategory: 'number',
      monitorConf: CreateTimingSyntheticTaskRequestMonitorConf,
      monitors: { 'type': 'array', 'itemType': CreateTimingSyntheticTaskRequestMonitors },
      name: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      tags: { 'type': 'array', 'itemType': CreateTimingSyntheticTaskRequestTags },
      taskType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTimingSyntheticTaskShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The list of assertions.
   */
  availableAssertionsShrink?: string;
  /**
   * @remarks
   * The general settings.
   */
  commonSettingShrink?: string;
  /**
   * @remarks
   * The general settings.
   */
  customPeriodShrink?: string;
  /**
   * @remarks
   * The detection frequency. Valid values: 1m, 5m, 10m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, and 24h.
   * 
   * This parameter is required.
   * 
   * @example
   * 5m
   */
  frequency?: string;
  /**
   * @remarks
   * The detection point type. Valid values:
   * 
   * - 1: PC
   * - 2: mobile device
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  monitorCategory?: number;
  /**
   * @remarks
   * The monitoring configurations.
   * 
   * This parameter is required.
   */
  monitorConfShrink?: string;
  /**
   * @remarks
   * The list of detection points.
   * 
   * This parameter is required.
   */
  monitorsShrink?: string;
  /**
   * @remarks
   * The name of the task.
   * 
   * This parameter is required.
   * 
   * @example
   * demo-test
   */
  name?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The parameter is optional.
   * 
   * @example
   * xxxx
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The tag list.
   */
  tagsShrink?: string;
  /**
   * @remarks
   * The type of the task. Valid values:
   * 
   * 1: ICMP. 2: TCP. 3: DNS. 4: HTTP. 5: website speed measurement. 6: file download.
   * 
   * This parameter is required.
   * 
   * @example
   * 4
   */
  taskType?: number;
  static names(): { [key: string]: string } {
    return {
      availableAssertionsShrink: 'AvailableAssertions',
      commonSettingShrink: 'CommonSetting',
      customPeriodShrink: 'CustomPeriod',
      frequency: 'Frequency',
      monitorCategory: 'MonitorCategory',
      monitorConfShrink: 'MonitorConf',
      monitorsShrink: 'Monitors',
      name: 'Name',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      tagsShrink: 'Tags',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableAssertionsShrink: 'string',
      commonSettingShrink: 'string',
      customPeriodShrink: 'string',
      frequency: 'string',
      monitorCategory: 'number',
      monitorConfShrink: 'string',
      monitorsShrink: 'string',
      name: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      tagsShrink: 'string',
      taskType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTimingSyntheticTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code returned. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The struct returned.
   */
  data?: CreateTimingSyntheticTaskResponseBodyData;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 53B5874D-EBC1-5567-B787-E4B7267F5CEB
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values: true and false.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: CreateTimingSyntheticTaskResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTimingSyntheticTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTimingSyntheticTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTimingSyntheticTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWebhookRequest extends $tea.Model {
  /**
   * @remarks
   * The notification template that is sent when an alert is triggered. This parameter is required if the **Method** parameter is set to **Post**. You can use the $content placeholder to specify the notification content. The content cannot exceed 500 characters in length.
   * 
   * This parameter is required.
   * 
   * @example
   * { "Alert Name": "{{ .commonLabels.alertname }}{{if .commonLabels.clustername }}", "Cluster Name": "{{ .commonLabels.clustername }} {{ end }}{{if eq " app" .commonLabels._aliyun_arms_involvedObject_kind }}", "Application Name": "{{ .commonLabels._aliyun_arms_involvedObject_name }} {{ end }}", "Notification Policy": "{{ .dispatchRuleName }}", "Alarm Time": "{{ .startTime }}", "Alert Content": "{{ for .alerts }} {{ .annotations.message }} {{ end }}" }
   */
  body?: string;
  /**
   * @remarks
   * The name of the contact.
   * 
   * This parameter is required.
   * 
   * @example
   * WebhookAlert
   */
  contactName?: string;
  /**
   * @remarks
   * The HTTP request header.
   * 
   * @example
   * [{"Content-Type":"application/json"}]
   */
  httpHeaders?: string;
  /**
   * @remarks
   * The parameters in the HTTP request.
   * 
   * @example
   * [{"name":"mike"}]
   */
  httpParams?: string;
  /**
   * @remarks
   * The HTTP request method.
   * 
   * *   `Get`
   * *   `Post`
   * 
   * This parameter is required.
   * 
   * @example
   * Post
   */
  method?: string;
  /**
   * @remarks
   * The notification template that is sent when an alert is resolved. This parameter is required if the **Method** parameter is set to **Post**. You can use the $content placeholder to specify the notification content. The content cannot exceed 500 characters in length.
   * 
   * @example
   * { "Alert Name": "{{ .commonLabels.alertname }}{{if .commonLabels.clustername }}", "Cluster Name": "{{ .commonLabels.clustername }} {{ end }}{{if eq " app" .commonLabels._aliyun_arms_involvedObject_kind }}", "Application Name": "{{ .commonLabels._aliyun_arms_involvedObject_name }} {{ end }}", "Notification Policy": "{{ .dispatchRuleName }}", "Alarm Time": "{{ .startTime }}", "Alert Content": "{{ for .alerts }} {{ .annotations.message }} {{ end }}" }
   */
  recoverBody?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The URL of the request **method**.
   * 
   * This parameter is required.
   * 
   * @example
   * https://oapi.dingtalk.com/robot/send?access_token=e1a049121ddbfce1ca963d115ef88cc7219583c4fb79fe6e398fbfb688******
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      body: 'Body',
      contactName: 'ContactName',
      httpHeaders: 'HttpHeaders',
      httpParams: 'HttpParams',
      method: 'Method',
      recoverBody: 'RecoverBody',
      regionId: 'RegionId',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      body: 'string',
      contactName: 'string',
      httpHeaders: 'string',
      httpParams: 'string',
      method: 'string',
      recoverBody: 'string',
      regionId: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWebhookResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the contact for webhook alerts.
   * 
   * @example
   * 48716
   */
  contactId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 16AF921B-8187-489F-9913-43C808B4****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      contactId: 'ContactId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWebhookResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateWebhookResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateWebhookResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DelAuthTokenRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DelAuthTokenResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the call was successful.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * A5EC8221-08F2-4C95-9AF1-49FD998C647A
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DelAuthTokenResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DelAuthTokenResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DelAuthTokenResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAddonReleaseRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the add-on. If you assign a value to AddonName, the ReleaseName parameter is ignored and all AddonReleases that belong to the same add-on are deleted.
   * 
   * @example
   * mysql
   */
  addonName?: string;
  /**
   * @remarks
   * Environment ID.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxx
   */
  environmentId?: string;
  /**
   * @remarks
   * Whether to be forcibly deleted. The default value is false.
   * 
   * @example
   * false
   */
  force?: boolean;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * Name of Release.
   * 
   * This parameter is required.
   * 
   * @example
   * agent-822567d4-2449
   */
  releaseName?: string;
  static names(): { [key: string]: string } {
    return {
      addonName: 'AddonName',
      environmentId: 'EnvironmentId',
      force: 'Force',
      regionId: 'RegionId',
      releaseName: 'ReleaseName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addonName: 'string',
      environmentId: 'string',
      force: 'boolean',
      regionId: 'string',
      releaseName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAddonReleaseResponseBody extends $tea.Model {
  /**
   * @remarks
   * Status code: 200 indicates success.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Return a message.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * F7781D4A-2818-41E7-B7BB-79D809E9****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the alert rule was deleted. Valid values:
   * 
   * *   `true`: The alert rule was deleted.
   * *   `false`: The alert rule failed to be deleted.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAddonReleaseResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteAddonReleaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteAddonReleaseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAlertContactRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert contact.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  contactId?: number;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      contactId: 'ContactId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactId: 'number',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAlertContactResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the call was successful.
   * 
   * *   `true`: The call was successful.
   * *   `false`: The call failed.
   * 
   * @example
   * true
   */
  isSuccess?: boolean;
  /**
   * @remarks
   * The ID of the request. You can query logs and troubleshoot issues based on the ID.
   * 
   * @example
   * 78901766-3806-4E96-8E47-CFEF59E4****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      isSuccess: 'IsSuccess',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isSuccess: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAlertContactResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteAlertContactResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteAlertContactResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAlertContactGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert contact group.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  contactGroupId?: number;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      contactGroupId: 'ContactGroupId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroupId: 'number',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAlertContactGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the call was successful.
   * 
   * *   `true`: The call was successful.
   * *   `false`: The call failed.
   * 
   * @example
   * true
   */
  isSuccess?: boolean;
  /**
   * @remarks
   * The ID of the request, which is used to locate and troubleshoot issues.
   * 
   * @example
   * C21AB7CF-B7AF-410F-BD61-82D1567F****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      isSuccess: 'IsSuccess',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isSuccess: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAlertContactGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteAlertContactGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteAlertContactGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAlertRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The alert rule ID.
   * 
   * For more information about how to obtain the ID of an alert rule, see [GetAlertRules](https://help.aliyun.com/document_detail/2612348.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  alertId?: number;
  static names(): { [key: string]: string } {
    return {
      alertId: 'AlertId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAlertRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the call was successful.
   * 
   * *   `true`: The call was successful.
   * *   `false`: The call failed.
   * 
   * @example
   * true
   */
  isSuccess?: boolean;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * C21AB7CF-B7AF-410F-BD61-82D1567F****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      isSuccess: 'IsSuccess',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isSuccess: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAlertRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteAlertRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteAlertRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAlertRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of the alert rules that you want to delete. The value is a JSON array, for example, `[123, 234]`. You can call the SearchAlertRules operation and view the `Id` parameter in the response to obtain the alert rule ID. For more information, see [SearchAlertRules](https://help.aliyun.com/document_detail/175825.html).
   * 
   * This parameter is required.
   * 
   * @example
   * [123, 234]
   */
  alertIds?: string;
  /**
   * @remarks
   * The region ID. Default value: `cn-hangzhou`.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      alertIds: 'AlertIds',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertIds: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAlertRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the alert rule was deleted.
   * 
   * *   `true`: The alert rule was deleted.
   * *   `false`: The alert rule failed to be deleted.
   * 
   * @example
   * true
   */
  isSuccess?: boolean;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C21AB7CF-B7AF-410F-BD61-82D1567F****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      isSuccess: 'IsSuccess',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isSuccess: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAlertRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteAlertRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteAlertRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAppListRequest extends $tea.Model {
  /**
   * @remarks
   * The PIDs of the applications monitored by ARMS Application Monitoring.
   */
  pids?: string[];
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      pids: 'Pids',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pids: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAppListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. 2XX indicates that the request was successful. 3XX indicates that the request was redirected. 4XX indicates that a request error occurred. 5XX indicates that a server error occurred.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * "{\\"code\\":200,\\"data\\":\\"{\\\\\\"code\\\\\\":200,\\\\\\"data\\\\\\":true,\\\\\\"errorCode\\\\ \\":\\\\\\"Deletion of application successful\\\\\\",\\\\\\"Message\\\\\\":\\\\\\"Deletion of application successful\\\\\\",\\\\\\"Successful\\\\\\":true,\\ \\\\"traceId\\\\\\":\\\\\\"0bc1667516940677164677396d0088\\\\\\"}\\",\\"errorCode\\":\\"Batch deletion of applications successful\\",\\"message\\":\\"Batch deletion of applications successful\\ ",\\"Success\\":true,\\"traceId\\":\\"210f470416940677161213505e0e7a\\"}"
   */
  data?: string;
  /**
   * @remarks
   * The error message returned when the request parameters are invalid.
   * 
   * @example
   * "Deletion of application successful"
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 4B446DF2-3DDD-4B5B-8E3F-D5225120****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the specified applications are deleted. Valid values:
   * 
   * *   `true`: The applications are deleted.
   * *   `false`: The applications failed to be deleted.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAppListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteAppListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteAppListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCmsExporterRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCmsExporterResponseBody extends $tea.Model {
  /**
   * @example
   * success
   */
  data?: string;
  /**
   * @example
   * 27E653FA-5958-45BE-8AA9-14D884DC****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCmsExporterResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteCmsExporterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteCmsExporterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteContactRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert contact.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  contactId?: number;
  static names(): { [key: string]: string } {
    return {
      contactId: 'ContactId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteContactResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the alert contact is deleted. Valid values:
   * 
   * *   `true`: The alert contact is deleted.
   * *   `false`: The alert contact is not deleted.
   * 
   * @example
   * true
   */
  isSuccess?: boolean;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C21AB7CF-B7AF-410F-BD61-82D1567F****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      isSuccess: 'IsSuccess',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isSuccess: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteContactResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteContactResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteContactResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteContactGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert contact group.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  contactGroupId?: number;
  static names(): { [key: string]: string } {
    return {
      contactGroupId: 'ContactGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroupId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteContactGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the alert contact group was deleted. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  isSuccess?: boolean;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * C21AB7CF-B7AF-410F-BD61-82D1567F****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      isSuccess: 'IsSuccess',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isSuccess: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteContactGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteContactGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteContactGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDispatchRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the dispatch policy.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  id?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDispatchRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 16AF921B-8187-489F-9913-43C808B4****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values: true and false.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDispatchRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDispatchRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDispatchRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEnvCustomJobRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the custom job.
   * 
   * This parameter is required.
   * 
   * @example
   * job1
   */
  customJobName?: string;
  /**
   * @remarks
   * The ID of the environment instance.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      customJobName: 'CustomJobName',
      environmentId: 'EnvironmentId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customJobName: 'string',
      environmentId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEnvCustomJobResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The result of the operation.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2FC13182-B9AF-4E6B-BE51-72669B7C****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEnvCustomJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteEnvCustomJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteEnvCustomJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEnvPodMonitorRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the environment instance.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxxxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The namespace where the PodMonitor is located.
   * 
   * This parameter is required.
   * 
   * @example
   * arms-prom
   */
  namespace?: string;
  /**
   * @remarks
   * The name of the PodMonitor.
   * 
   * This parameter is required.
   * 
   * @example
   * arms-admin-pm1
   */
  podMonitorName?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      environmentId: 'EnvironmentId',
      namespace: 'Namespace',
      podMonitorName: 'PodMonitorName',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      environmentId: 'string',
      namespace: 'string',
      podMonitorName: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEnvPodMonitorResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The result of the operation.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 626037F5-FDEB-45B0-804C-B3C92797****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEnvPodMonitorResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteEnvPodMonitorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteEnvPodMonitorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEnvServiceMonitorRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the environment instance.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxxxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The namespace where the ServiceMonitor is located.
   * 
   * This parameter is required.
   * 
   * @example
   * arms-prom
   */
  namespace?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The name of the ServiceMonitor.
   * 
   * This parameter is required.
   * 
   * @example
   * arms-admin1
   */
  serviceMonitorName?: string;
  static names(): { [key: string]: string } {
    return {
      environmentId: 'EnvironmentId',
      namespace: 'Namespace',
      regionId: 'RegionId',
      serviceMonitorName: 'ServiceMonitorName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      environmentId: 'string',
      namespace: 'string',
      regionId: 'string',
      serviceMonitorName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEnvServiceMonitorResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The result of the operation.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 78901766-3806-4E96-8E47-CFEF59E4****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEnvServiceMonitorResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteEnvServiceMonitorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteEnvServiceMonitorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEnvironmentRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to delete the related Prometheus instance.
   * 
   * @example
   * true
   * 
   * **if can be null:**
   * true
   */
  deletePromInstance?: boolean;
  /**
   * @remarks
   * The ID of the environment instance.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxxxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      deletePromInstance: 'DeletePromInstance',
      environmentId: 'EnvironmentId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deletePromInstance: 'boolean',
      environmentId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEnvironmentResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The result of the operation.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 34ED024E-9E31-434A-9E4E-D9D15C3****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEnvironmentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteEnvironmentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteEnvironmentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEnvironmentFeatureRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the environment.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The feature name. Valid values: app-agent-pilot, metric-agent, ebpf-agent, and service-check.
   * 
   * This parameter is required.
   * 
   * @example
   * metric-agent
   */
  featureName?: string;
  /**
   * @remarks
   * The region ID. Valid values: cn-beijing and cn-hangzhou.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      environmentId: 'EnvironmentId',
      featureName: 'FeatureName',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      environmentId: 'string',
      featureName: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEnvironmentFeatureResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2A0CEDF1-06FE-44AC-8E21-21A5BE65****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values: true and false.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEnvironmentFeatureResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteEnvironmentFeatureResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteEnvironmentFeatureResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEventBridgeIntegrationRequest extends $tea.Model {
  /**
   * @remarks
   * Required. The ID of the EventBridge notification integration. You can call the **ListEventBridgeIntegrations** operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEventBridgeIntegrationResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the EventBridge integration is deleted.
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  isSuccess?: boolean;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2B289756-E791-5842-BCBD-AD414C******
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      isSuccess: 'IsSuccess',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isSuccess: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEventBridgeIntegrationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteEventBridgeIntegrationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteEventBridgeIntegrationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGrafanaResourceRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The name of the cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * clusterNameOfTest
   */
  clusterName?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      clusterName: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGrafanaResourceResponseBody extends $tea.Model {
  /**
   * @remarks
   * Status code. 200 is success, other status codes are exceptions.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * delete success.
   */
  data?: string;
  /**
   * @remarks
   * Returns a hint message for the result.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * 771DC66C-C5E0-59BC-A983-DD18FEE9EFFA
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGrafanaResourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteGrafanaResourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteGrafanaResourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGrafanaWorkspaceRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * grafana-rnglkcdrntlhk0****
   */
  grafanaWorkspaceId?: string;
  /**
   * @remarks
   * The region ID. Default value: cn-hangzhou.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      grafanaWorkspaceId: 'GrafanaWorkspaceId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      grafanaWorkspaceId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGrafanaWorkspaceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Indicates whether the workspace was deleted. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 27E653FA-5958-45BE-8AA9-14D884DC****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The ID of the trace. The ID is used to query the details of a request.
   * 
   * @example
   * eac0a8048716731735000007137d000b
   */
  traceId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      traceId: 'TraceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'boolean',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
      traceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGrafanaWorkspaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteGrafanaWorkspaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteGrafanaWorkspaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteIMRobotRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the IM chatbot.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  robotId?: number;
  static names(): { [key: string]: string } {
    return {
      robotId: 'RobotId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      robotId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteIMRobotResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the call was successful.
   * 
   * *   `true`: The call was successful.
   * *   `false`: The call failed.
   * 
   * @example
   * true
   */
  isSuccess?: boolean;
  /**
   * @remarks
   * The request ID. You can use the ID to find logs and troubleshoot issues.
   * 
   * @example
   * C21AB7CF-B7AF-410F-BD61-82D1567F****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      isSuccess: 'IsSuccess',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isSuccess: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteIMRobotResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteIMRobotResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteIMRobotResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteIntegrationRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ACK cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The abbreviation of the software that is supported by Application Real-Time Monitoring Service (ARMS). Valid values (case-insensitive): `ASM`, `IoT`, and `Flink`.
   * 
   * This parameter is required.
   * 
   * @example
   * asm
   */
  integration?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      integration: 'Integration',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      integration: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteIntegrationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Indicates whether the call was successful.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1A9C645C-C83F-4C9D-8CCB-29BEC9E1****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteIntegrationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteIntegrationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteIntegrationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteIntegrationsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert integration.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  integrationId?: number;
  static names(): { [key: string]: string } {
    return {
      integrationId: 'IntegrationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      integrationId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteIntegrationsResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the alert integration is deleted. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  isSuccess?: boolean;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 34ED024E-9E31-434A-9E4E-D9D15C3****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      isSuccess: 'IsSuccess',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isSuccess: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteIntegrationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteIntegrationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteIntegrationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNotificationPolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the notification policy.
   * 
   * For more information about how to obtain the ID of a notification policy, see [ListNotificationPolicies](https://help.aliyun.com/document_detail/2612375.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNotificationPolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * true
   */
  isSuccess?: boolean;
  /**
   * @remarks
   * The ID of the notification policy.
   * 
   * @example
   * A5EC8221-08F2-4C95-9AF1-49FD998C****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      isSuccess: 'IsSuccess',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isSuccess: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNotificationPolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteNotificationPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteNotificationPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePrometheusAlertRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert rule. You can call the ListPrometheusAlertRules operation to query the ID of the alert rule.
   * 
   * This parameter is required.
   * 
   * @example
   * 3888704
   */
  alertId?: number;
  /**
   * @remarks
   * The cluster ID of the Prometheus monitoring alarm rule.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  static names(): { [key: string]: string } {
    return {
      alertId: 'AlertId',
      clusterId: 'ClusterId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertId: 'number',
      clusterId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePrometheusAlertRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * Status code. 200 means success, other status codes are exceptions.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * More Information.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9FEA6D00-317F-45E3-9004-7FB8B0B7****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the alert rule was deleted. Valid values:
   * 
   * *   `true`: The alert rule was deleted.
   * *   `false`: The alert rule failed to be deleted.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePrometheusAlertRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeletePrometheusAlertRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeletePrometheusAlertRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePrometheusGlobalViewRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the global aggregation instance.
   * 
   * This parameter is required.
   * 
   * @example
   * global-v2-cn-1670100631025794-amaykca4
   */
  globalViewClusterId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      globalViewClusterId: 'GlobalViewClusterId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      globalViewClusterId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePrometheusGlobalViewResponseBody extends $tea.Model {
  /**
   * @remarks
   * Status code. 200 is success, other status codes are exceptions.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The response parameters in the JSON format.
   * 
   * @example
   * {"Success":true,"Msg":"OK"}
   */
  data?: string;
  /**
   * @remarks
   * Additional Message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * 337B8F7E-0A64-5768-9225-E9B3CF******
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePrometheusGlobalViewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeletePrometheusGlobalViewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeletePrometheusGlobalViewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePrometheusIntegrationRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the Prometheus instance. Only a Prometheus instance for Container Service or a Prometheus instance for ECS is supported.
   * 
   * This parameter is required.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The ID of the exporter.
   * 
   * @example
   * 2875
   */
  instanceId?: number;
  /**
   * @remarks
   * The type of the integration.
   * 
   * This parameter is required.
   * 
   * @example
   * kafka and mysql.
   */
  integrationType?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      instanceId: 'InstanceId',
      integrationType: 'IntegrationType',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      instanceId: 'number',
      integrationType: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePrometheusIntegrationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * success or an error message.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 19F54318-CC92-5567-BF66-CB029EC44C84
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePrometheusIntegrationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeletePrometheusIntegrationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeletePrometheusIntegrationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePrometheusMonitoringRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the Prometheus instance.
   * 
   * This parameter is required.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The name of the monitoring configuration.
   * 
   * This parameter is required.
   * 
   * @example
   * customJob1
   */
  monitoringName?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The type of the monitoring configuration. 
   * Valid values for a Prometheus instance for Container Service: serviceMonitor, podMonitor, customJob, and probe. 
   * Valid values for a Prometheus instance for ECS: customJob and probe.
   * 
   * This parameter is required.
   * 
   * @example
   * probe
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      monitoringName: 'MonitoringName',
      regionId: 'RegionId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      monitoringName: 'string',
      regionId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePrometheusMonitoringResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The result of the operation.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 4D6C358A-A58B-4F4B-94CE-F5AAF023****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePrometheusMonitoringResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeletePrometheusMonitoringResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeletePrometheusMonitoringResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRetcodeAppRequest extends $tea.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * 1231
   */
  appId?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * test-app
   */
  appName?: string;
  /**
   * @remarks
   * The process identifier (PID) of the application.
   * 
   * This parameter is required.
   * 
   * @example
   * aokcdqn3ly@741623b4e91****
   */
  pid?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      pid: 'Pid',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      appName: 'string',
      pid: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRetcodeAppResponseBody extends $tea.Model {
  /**
   * @remarks
   * Status code. 200 means success, other status codes are exceptions.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Indicates whether the Browser Monitoring task was deleted. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  data?: string;
  /**
   * @remarks
   * Additional information. The value description is as follows:
   * - If the request is normal, return success.
   * - If the request is abnormal, return specific abnormal information.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 01FF8DD9-A09C-47A1-895A-B6E321BE77B6
   */
  requestId?: string;
  /**
   * @remarks
   * Whether the operation was successful:
   * - `true`: The operation was successful
   * - `false`: The operation failed
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRetcodeAppResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRetcodeAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRetcodeAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRumAppRequest extends $tea.Model {
  /**
   * @remarks
   * The group where the application resides.
   * 
   * @example
   * default
   */
  appGroup?: string;
  /**
   * @remarks
   * The ID of the application.
   * 
   * This parameter is required.
   * 
   * @example
   * b590lhguqs@28f515462******
   */
  appId?: string;
  realRegionId?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      appGroup: 'AppGroup',
      appId: 'AppId',
      realRegionId: 'RealRegionId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appGroup: 'string',
      appId: 'string',
      realRegionId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRumAppResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 4C518054-852F-4023-ABC1-4AF95FF7****
   */
  requestId?: string;
  /**
   * @remarks
   * The resource group ID.
   * 
   * @example
   * rg-aek2eq4peca****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The message that appears when the application is deleted.
   * 
   * @example
   * Success to delete app.
   */
  result?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values: true and false.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      resourceGroupId: 'ResourceGroupId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      resourceGroupId: 'string',
      result: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRumAppResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRumAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRumAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRumUploadFileRequest extends $tea.Model {
  /**
   * @remarks
   * Information of files to be deleted in JSON array format. If a single file needs to be deleted, this field should be left empty. If multiple files need to be deleted, just fill in this field.
   * 
   * @example
   * [{
   *     "fileName" : "test.js.map",
   *     "version" : "1.0.0"
   *   },
   *   {
   *     "fileName" : "test.dSYM",
   *     "version" : "1.20.1",
   *     "uuid" : "xxxx-xxxx-xxxx-xxxx"
   *   }]
   */
  batchItems?: string;
  /**
   * @remarks
   * The file name, with the extension.
   * 
   * @example
   * test.js.map
   */
  fileName?: string;
  /**
   * @remarks
   * The application ID.
   * 
   * This parameter is required.
   * 
   * @example
   * atc889zkcf@d8deedfa9bf****
   */
  pid?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The file ID.
   * 
   * @example
   * MS4wLjAtbWFpbi4wZjM0NzRlOSxxxxxx
   */
  uuid?: string;
  /**
   * @remarks
   * The version number of the file.
   * 
   * @example
   * 1.0.0
   */
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      batchItems: 'BatchItems',
      fileName: 'FileName',
      pid: 'Pid',
      regionId: 'RegionId',
      uuid: 'Uuid',
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchItems: 'string',
      fileName: 'string',
      pid: 'string',
      regionId: 'string',
      uuid: 'string',
      versionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRumUploadFileResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Indicates whether the file is deleted. If the file is deleted, "success" is returned.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * Internal error, please contact the administrator.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 40B10E04-81E8-4643-970D-F1B38F2E****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRumUploadFileResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRumUploadFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRumUploadFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScenarioRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-zhangjaikou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the business monitoring job. You can obtain the ID by calling the ListScenario operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 132
   */
  scenarioId?: number;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      scenarioId: 'ScenarioId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      scenarioId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScenarioResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EA24D522-AD35-47B8-8CB2-ADBC382B****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * *   `true`: successful
   * *   `false`: failed
   * 
   * @example
   * true
   */
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScenarioResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteScenarioResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteScenarioResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSilencePolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the silence policy.
   * 
   * For more information about how to obtain the ID of a silence policy, see [ListSilencePolicies](https://help.aliyun.com/document_detail/2612383.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSilencePolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the silence policy was deleted successfully. Valid values:
   * 
   * *   `true`: The silence policy was deleted successfully.
   * *   `false`: The silence policy failed to be deleted.
   * 
   * @example
   * true
   */
  isSuccess?: boolean;
  /**
   * @remarks
   * The operation that you want to perform. Set the value to **DeleteSilencePolicy**.
   * 
   * @example
   * A5EC8221-08F2-4C95-9AF1-49FD998C****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      isSuccess: 'IsSuccess',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isSuccess: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSilencePolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteSilencePolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSilencePolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSourceMapRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of the SourceMap files.
   * 
   * This parameter is required.
   */
  fidList?: string[];
  /**
   * @remarks
   * The process identifier (PID) of the application.
   * 
   * This parameter is required.
   * 
   * @example
   * atc889zkcf@d8deedfa9bf****
   */
  pid?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      fidList: 'FidList',
      pid: 'Pid',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fidList: { 'type': 'array', 'itemType': 'string' },
      pid: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSourceMapShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of the SourceMap files.
   * 
   * This parameter is required.
   */
  fidListShrink?: string;
  /**
   * @remarks
   * The process identifier (PID) of the application.
   * 
   * This parameter is required.
   * 
   * @example
   * atc889zkcf@d8deedfa9bf****
   */
  pid?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      fidListShrink: 'FidList',
      pid: 'Pid',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fidListShrink: 'string',
      pid: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSourceMapResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the SourceMap files are deleted. Valid values:
   * 
   * *   success: The SourceMap files are deleted.
   * *   false: The SourceMap files fail to be deleted.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 1A9C645C-C83F-4C9D-8CCB-29BEC9E1****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSourceMapResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteSourceMapResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSourceMapResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSyntheticTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The region ID. Default value: cn-hangzhou.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The task IDs.
   * 
   * This parameter is required.
   */
  taskIds?: string[];
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      taskIds: 'TaskIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      taskIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSyntheticTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1A9C645C-C83F-4C9D-8CCB-29BEC9E1****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the specified tasks are deleted.
   * 
   * *   `true`: The tasks are deleted.
   * *   `false`: The tasks fail to be deleted.
   * 
   * @example
   * true
   */
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSyntheticTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteSyntheticTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSyntheticTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTimingSyntheticTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The resource group ID.
   * 
   * @example
   * rg-aek2eq4peca****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The ID of the synthetic monitoring task.
   * 
   * @example
   * 5308a2691f59422c8c3b7aeccec9cd3b
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      resourceGroupId: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTimingSyntheticTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Indicates whether the synthetic monitoring task was deleted. true: The synthetic monitoring task was deleted. false: The synthetic monitoring task failed to be deleted.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * A5EC8221-08F2-4C95-9AF1-49FD998C****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'boolean',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTimingSyntheticTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTimingSyntheticTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTimingSyntheticTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTraceAppRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the application that you want to delete. You can call the SearchTraceAppByName operation to query the application ID. For more information, see [SearchTraceAppByName](https://help.aliyun.com/document_detail/130676.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 5406**
   */
  appId?: string;
  /**
   * @remarks
   * The reason(s) to delete application.
   */
  deleteReason?: DeleteTraceAppRequestDeleteReason;
  /**
   * @remarks
   * The PID of the application. For more information about how to query the PID, see [QueryMetricByPage](https://www.alibabacloud.com/help/zh/doc-detail/186100.htm?spm=a2cdw.13409063.0.0.7a72281f0bkTfx#title-imy-7gj-qhr).
   * 
   * This parameter is required.
   * 
   * @example
   * 9w0sc5gxxz@edcsd447c2f****
   */
  pid?: string;
  /**
   * @remarks
   * The ID of the region in which the application is located.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The type of the application that you want to delete. You can call the SearchTraceAppByName operation to query the application type. For more information, see [SearchTraceAppByName](https://help.aliyun.com/document_detail/130676.html). Valid values:
   * 
   * *   `TRACE`: Application Monitoring
   * *   `RETCODE`: frontend monitoring
   * 
   * This parameter is required.
   * 
   * @example
   * TRACE
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      deleteReason: 'DeleteReason',
      pid: 'Pid',
      regionId: 'RegionId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      deleteReason: DeleteTraceAppRequestDeleteReason,
      pid: 'string',
      regionId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTraceAppShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the application that you want to delete. You can call the SearchTraceAppByName operation to query the application ID. For more information, see [SearchTraceAppByName](https://help.aliyun.com/document_detail/130676.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 5406**
   */
  appId?: string;
  /**
   * @remarks
   * The reason(s) to delete application.
   */
  deleteReasonShrink?: string;
  /**
   * @remarks
   * The PID of the application. For more information about how to query the PID, see [QueryMetricByPage](https://www.alibabacloud.com/help/zh/doc-detail/186100.htm?spm=a2cdw.13409063.0.0.7a72281f0bkTfx#title-imy-7gj-qhr).
   * 
   * This parameter is required.
   * 
   * @example
   * 9w0sc5gxxz@edcsd447c2f****
   */
  pid?: string;
  /**
   * @remarks
   * The ID of the region in which the application is located.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The type of the application that you want to delete. You can call the SearchTraceAppByName operation to query the application type. For more information, see [SearchTraceAppByName](https://help.aliyun.com/document_detail/130676.html). Valid values:
   * 
   * *   `TRACE`: Application Monitoring
   * *   `RETCODE`: frontend monitoring
   * 
   * This parameter is required.
   * 
   * @example
   * TRACE
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      deleteReasonShrink: 'DeleteReason',
      pid: 'Pid',
      regionId: 'RegionId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      deleteReasonShrink: 'string',
      pid: 'string',
      regionId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTraceAppResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The response in JSON format, including the HTTP status code, error code, response message, and trace ID.
   * 
   * @example
   * "{\\\\"code\\\\":200,\\\\"data\\\\":\\\\"{\\\\\\\\\\"code\\\\\\\\\\":200,\\\\\\\\\\"data\\\\\\\\\\":true,\\\\\\\\\\"errorCode\\\\\\\\\\":\\\\\\\\\\"The application is deleted\\\\\\\\\\",\\\\\\\\\\"message\\\\\\\\\\":\\\\\\\\\\"The application is deleted\\\\\\\\\\",\\\\\\\\\\"success\\\\\\\\\\":true,\\\\\\\\\\"traceId\\\\\\\\\\":\\\\\\\\\\"0bc0594d15954826692915817e\\*\\*\\*\\*\\\\\\\\\\"}\\\\",\\\\"errorCode\\\\":\\\\"The application is deleted\\\\",\\\\"message\\\\":\\\\"The application is deleted\\\\",\\\\"success\\\\":true,\\\\"traceId\\\\":\\\\"0ab2646915954826692568137d\\*\\*\\*\\*\\\\"}
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * Internal error. Please try again. Contact the DingTalk service account if the issue                              persists after multiple retries.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 46355DD8-FC56-40C5-BFC6-269DE4F9****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * true: The request was successful.
   * 
   * false: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTraceAppResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTraceAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTraceAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWebhookContactRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the webhook alert contact.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  webhookId?: number;
  static names(): { [key: string]: string } {
    return {
      webhookId: 'WebhookId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      webhookId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWebhookContactResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the webhook alert contact was deleted.
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  isSuccess?: boolean;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * C21AB7CF-B7AF-410F-BD61-82D1567F****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      isSuccess: 'IsSuccess',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isSuccess: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWebhookContactResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteWebhookContactResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteWebhookContactResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAddonReleaseRequest extends $tea.Model {
  /**
   * @remarks
   * The environment ID.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The name of the add-on release.
   * 
   * This parameter is required.
   * 
   * @example
   * agent-822567d4-2449
   */
  releaseName?: string;
  static names(): { [key: string]: string } {
    return {
      environmentId: 'EnvironmentId',
      regionId: 'RegionId',
      releaseName: 'ReleaseName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      environmentId: 'string',
      regionId: 'string',
      releaseName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAddonReleaseResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The release information.
   */
  data?: DescribeAddonReleaseResponseBodyData;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 78901766-3806-4E96-8E47-CFEF59E4****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values: true and false.
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: DescribeAddonReleaseResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAddonReleaseResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAddonReleaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAddonReleaseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactGroupsRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the alert contact group.
   * 
   * @example
   * TestGroup
   */
  contactGroupName?: string;
  /**
   * @remarks
   * The ID of the alert contact group.
   * 
   * @example
   * 12345
   */
  groupIds?: string;
  /**
   * @remarks
   * Specifies whether to return all the alert contacts in the queried alert contact group. Valid values:
   * 
   * *   `false`
   * *   `true`
   * 
   * @example
   * true
   */
  isDetail?: boolean;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The number of alert contact groups displayed on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 20
   */
  size?: number;
  static names(): { [key: string]: string } {
    return {
      contactGroupName: 'ContactGroupName',
      groupIds: 'GroupIds',
      isDetail: 'IsDetail',
      page: 'Page',
      regionId: 'RegionId',
      size: 'Size',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroupName: 'string',
      groupIds: 'string',
      isDetail: 'boolean',
      page: 'number',
      regionId: 'string',
      size: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactGroupsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The objects that were returned.
   */
  pageBean?: DescribeContactGroupsResponseBodyPageBean;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4D6C358A-A58B-4F4B-94CE-F5AAF023****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageBean: 'PageBean',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageBean: DescribeContactGroupsResponseBodyPageBean,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeContactGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeContactGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert contact that you want to query. Separate multiple contact IDs with spaces.
   * 
   * @example
   * 123,321
   */
  contactIds?: string;
  /**
   * @remarks
   * The name of the alert contact.
   * 
   * @example
   * John Doe
   */
  contactName?: string;
  /**
   * @remarks
   * The email address of the alert contact.
   * 
   * @example
   * someone@example.com
   */
  email?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The mobile number of the alert contact.
   * 
   * @example
   * 1381111*****
   */
  phone?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The number of alert contacts to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 20
   */
  size?: number;
  /**
   * @remarks
   * Specifies whether to return redundant information.
   * 
   * @example
   * true
   */
  verbose?: string;
  static names(): { [key: string]: string } {
    return {
      contactIds: 'ContactIds',
      contactName: 'ContactName',
      email: 'Email',
      page: 'Page',
      phone: 'Phone',
      regionId: 'RegionId',
      size: 'Size',
      verbose: 'Verbose',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactIds: 'string',
      contactName: 'string',
      email: 'string',
      page: 'number',
      phone: 'string',
      regionId: 'string',
      size: 'number',
      verbose: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The objects that were returned.
   */
  pageBean?: DescribeContactsResponseBodyPageBean;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 21E85B16-75A6-429A-9F65-8AAC9A54****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageBean: 'PageBean',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageBean: DescribeContactsResponseBodyPageBean,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeContactsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeContactsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDispatchRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the dispatch policy.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  id?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDispatchRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The struct returned.
   */
  dispatchRule?: DescribeDispatchRuleResponseBodyDispatchRule;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 34ED024E-9E31-434A-9E4E-D9D15C3****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      dispatchRule: 'DispatchRule',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dispatchRule: DescribeDispatchRuleResponseBodyDispatchRule,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDispatchRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDispatchRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDispatchRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEnvCustomJobRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the custom job.
   * 
   * This parameter is required.
   * 
   * @example
   * customJob1
   */
  customJobName?: string;
  /**
   * @remarks
   * Specifies whether to return an encrypted YAML string.
   * 
   * @example
   * true
   */
  encryptYaml?: boolean;
  /**
   * @remarks
   * The ID of the environment instance.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxxxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      customJobName: 'CustomJobName',
      encryptYaml: 'EncryptYaml',
      environmentId: 'EnvironmentId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customJobName: 'string',
      encryptYaml: 'boolean',
      environmentId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEnvCustomJobResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned struct.
   */
  data?: DescribeEnvCustomJobResponseBodyData;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6A9AEA84-7186-4D8D-B498-4585C6A2****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: DescribeEnvCustomJobResponseBodyData,
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEnvCustomJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeEnvCustomJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeEnvCustomJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEnvPodMonitorRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the environment instance.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The namespace where the PodMonitor resides.
   * 
   * This parameter is required.
   * 
   * @example
   * arms-prom
   */
  namespace?: string;
  /**
   * @remarks
   * The name of the PodMonitor.
   * 
   * This parameter is required.
   * 
   * @example
   * arms-admin-pm1
   */
  podMonitorName?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      environmentId: 'EnvironmentId',
      namespace: 'Namespace',
      podMonitorName: 'PodMonitorName',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      environmentId: 'string',
      namespace: 'string',
      podMonitorName: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEnvPodMonitorResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned struct.
   */
  data?: DescribeEnvPodMonitorResponseBodyData;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1A9C645C-C83F-4C9D-8CCB-29BEC9E1****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: DescribeEnvPodMonitorResponseBodyData,
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEnvPodMonitorResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeEnvPodMonitorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeEnvPodMonitorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEnvServiceMonitorRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the environment instance.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The namespace where the ServiceMonitor resides.
   * 
   * This parameter is required.
   * 
   * @example
   * arms-prom
   */
  namespace?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The name of the ServiceMonitor.
   * 
   * This parameter is required.
   * 
   * @example
   * arms-admin1
   */
  serviceMonitorName?: string;
  static names(): { [key: string]: string } {
    return {
      environmentId: 'EnvironmentId',
      namespace: 'Namespace',
      regionId: 'RegionId',
      serviceMonitorName: 'ServiceMonitorName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      environmentId: 'string',
      namespace: 'string',
      regionId: 'string',
      serviceMonitorName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEnvServiceMonitorResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned struct.
   */
  data?: DescribeEnvServiceMonitorResponseBodyData;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 40B10E04-81E8-4643-970D-F1B38F2E****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: DescribeEnvServiceMonitorResponseBodyData,
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEnvServiceMonitorResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeEnvServiceMonitorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeEnvServiceMonitorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEnvironmentRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the environment instance.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      environmentId: 'EnvironmentId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      environmentId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEnvironmentResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned struct.
   */
  data?: DescribeEnvironmentResponseBodyData;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * C21AB7CF-B7AF-410F-BD61-82D1567F****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: DescribeEnvironmentResponseBodyData,
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEnvironmentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeEnvironmentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeEnvironmentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEnvironmentFeatureRequest extends $tea.Model {
  /**
   * @remarks
   * The language. Valid values: en and zh.
   * 
   * @example
   * en
   */
  aliyunLang?: string;
  /**
   * @remarks
   * The environment ID.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The name of the feature.
   * 
   * Valid values:
   * 
   * *   app-agent-pilot: App Pilot agent
   * *   arms-cmonitor: ARMS CMonitor agent
   * *   metric-agent: Prometheus agent
   * 
   * This parameter is required.
   * 
   * @example
   * metric-agent
   */
  featureName?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunLang: 'AliyunLang',
      environmentId: 'EnvironmentId',
      featureName: 'FeatureName',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunLang: 'string',
      environmentId: 'string',
      featureName: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEnvironmentFeatureResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned struct.
   */
  data?: DescribeEnvironmentFeatureResponseBodyData;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 01FF8DD9-A09C-47A1-895A-B6E321BE77B6
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values: true and false.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: DescribeEnvironmentFeatureResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEnvironmentFeatureResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeEnvironmentFeatureResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeEnvironmentFeatureResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIMRobotsRequest extends $tea.Model {
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The chatbot IDs.
   * 
   * @example
   * 123
   */
  robotIds?: string;
  /**
   * @remarks
   * The name of the IM chatbot.
   * 
   * @example
   * Chatbot name
   */
  robotName?: string;
  /**
   * @remarks
   * The number of IM chatbots to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 20
   */
  size?: number;
  static names(): { [key: string]: string } {
    return {
      page: 'Page',
      robotIds: 'RobotIds',
      robotName: 'RobotName',
      size: 'Size',
    };
  }

  static types(): { [key: string]: any } {
    return {
      page: 'number',
      robotIds: 'string',
      robotName: 'string',
      size: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIMRobotsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned objects.
   */
  pageBean?: DescribeIMRobotsResponseBodyPageBean;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 4D6C358A-A58B-4F4B-94CE-F5AAF023****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageBean: 'PageBean',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageBean: DescribeIMRobotsResponseBodyPageBean,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIMRobotsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeIMRobotsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeIMRobotsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePrometheusAlertRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert rule. You can call the ListPrometheusAlertRules operation to query the ID of the alert rule.
   * 
   * This parameter is required.
   * 
   * @example
   * 3888704
   */
  alertId?: number;
  /**
   * @remarks
   * The ID of the Prometheus instance.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  static names(): { [key: string]: string } {
    return {
      alertId: 'AlertId',
      clusterId: 'ClusterId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertId: 'number',
      clusterId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePrometheusAlertRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The returned struct.
   */
  prometheusAlertRule?: DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9FEA6D00-317F-45E3-9004-7FB8B0B7****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * True
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      prometheusAlertRule: 'PrometheusAlertRule',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      prometheusAlertRule: DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePrometheusAlertRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePrometheusAlertRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePrometheusAlertRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTraceLicenseKeyRequest extends $tea.Model {
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTraceLicenseKeyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The license key for the application.
   * 
   * @example
   * b590lhguqs@3a75d95f218****
   */
  licenseKey?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 29053944-6FE5-4240-8927-10095ECE****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      licenseKey: 'LicenseKey',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      licenseKey: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTraceLicenseKeyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTraceLicenseKeyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTraceLicenseKeyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebhookContactsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert contact.
   * 
   * @example
   * 123
   */
  contactIds?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of alert contacts displayed on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 20
   */
  size?: number;
  /**
   * @remarks
   * The name of the webhook alert contact.
   * 
   * @example
   * Webhook name
   */
  webhookName?: string;
  static names(): { [key: string]: string } {
    return {
      contactIds: 'ContactIds',
      page: 'Page',
      size: 'Size',
      webhookName: 'WebhookName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactIds: 'string',
      page: 'number',
      size: 'number',
      webhookName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebhookContactsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned objects.
   */
  pageBean?: DescribeWebhookContactsResponseBodyPageBean;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 4D6C358A-A58B-4F4B-94CE-F5AAF023****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageBean: 'PageBean',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageBean: DescribeWebhookContactsResponseBodyPageBean,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebhookContactsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeWebhookContactsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWebhookContactsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DoInsightsActionRequest extends $tea.Model {
  /**
   * @remarks
   * The query parameters. Different module types correspond to different query parameters.
   * 
   * *   QueryTopo
   * 
   * <!---->
   * 
   *     {
   *         "regionId": string,  # The region ID.
   *         "startTime": string, # The beginning of the time range to query, in the yyyy-MM-dd HH:mm:ss format.
   *         "endTime": string, # The end of the time range to query, in the yyyy-MM-dd HH:mm:ss format.
   *         "edgeFilter": { # The edge filter condition.
   *             "includeTypes": [EdgeType], # The edge types to be included.
   *             "excludeTypes": [EdgeType], # The edge types to be excluded.
   *             "fromNodeFilter": { # The source node filter condition.
   *                 "includeEntityTypes": [EntityType] # The entity types to be included.
   *                 "excludeEntityTypes": [EntityType] # The entity types to be excluded.
   *             },
   *             "toNodeFilter": {  # The destination node filter condition.
   *                 "includeEntityTypes": [EntityType] # The entity types to be included.
   *                 "excludeEntityTypes": [EntityType] # The entity types to be excluded.
   *             }
   *         },
   *         "includeIsolatedNodes": bool, # Specifies whether to include isolated nodes.
   *         "isolatedNodeFilter": { # The isolated node filter condition.
   *             "includeEntityTypes": [EntityType] # The entity types to be included.
   *             "excludeEntityTypes": [EntityType] # The entity types to be excluded.
   *          },
   *         "queryMetrics": boolean, # Specifies whether to query related red metrics during the metric query.
   *         "timeoutSecs": int, # The timeout duration for querying metrics.
   *     	"redOption": { # A metric query option.
   *     		"skipRt": boolean,  # Specifies whether to skip querying the response time.
   *     		"skipCount": boolean, # Specifies whether to skip querying the number of requests.
   *     		"skipError": boolean # Specifies whether to skip querying the number of errors.
   *     	}
   *     }
   * 
   * *   QueryTopoRed
   * 
   * <!---->
   * 
   *     {
   *         "regionId": string,  # The region ID.
   *         "startTime": string, # The beginning of the time range to query, in the yyyy-MM-dd HH:mm:ss format.
   *         "endTime": string,   # The end of the time range to query, in the yyyy-MM-dd HH:mm:ss format.
   *         "edgeIds": [string]  # The IDs of the edges to query.
   *         "nodeIds": [string]  # The IDs of the nodes to query.
   *         "redOption": { # A metric query option.
   *             "skipRt": boolean,  # Specifies whether to skip querying the response time.
   *             "skipCount": boolean, # Specifies whether to skip querying the number of requests.
   *             "skipError": boolean # Specifies whether to skip querying the number of errors.
   *         }
   *     }
   * 
   * This parameter is required.
   * 
   * @example
   * - QueryTopo
   * 
   * 
   * 	{
   * 		"regionId": "cn-hangzhou",
   * 		"startTime": "2024-07-23 19:16:00",  
   * 		"endTime": "2024-07-23 20:16:00", # Limit the topology query range to 2024-07-23 19:16:00 to 2024-07-23 20:16:00
   * 		"edgeFilter": {
   * 			"includeTypes": [
   * 				"CALLS" # The resulting topology only contains edges of call relationships.
   * 			],
   * 			"fromNodeFilter": {
   * 				"includeEntityTypes": [ # The source node type of the call edge must be application type
   * 					"APPLICATION" 
   * 				]
   * 			},
   * 			"toNodeFilter": {
   * 				"includeEntityTypes": [ # The target node of the call edge must be an application type or an external service type.
   * 					"APPLICATION",
   * 					"EXTERNAL_SERVICE"
   * 				]
   * 			}
   * 		},
   * 		"includeIsolatedNodes": false, # The resulting topology does not contain isolated nodes
   * 		"queryMetrics": true, # Synchronously query the RED indicator
   * 		"timeoutSecs": 20, #It takes up to 20 seconds to query indicator data
   * 		"redOption": { # The query indicators include time consumption, request volume, and query skip errors.
   * 			"skipRt": false,
   * 			"skipCount": false,
   * 			"skipError": true
   * 		}
   * 	}
   * 
   * 
   * 
   * - QueryTopoRed
   * 
   * 
   * 	{
   * 		"regionId": "cn-hangzhou",
   * 		"startTime": "2024-07-23 10:00:00",
   * 		"endTime": "2024-07-23 14:00:00",
   * 		"edgeIds": [
   * 			"097843bd50b06fbe2c6c1d8b761a7e8b"
   * 		],
   * 		"nodeIds": [
   * 			"23d973261c6923da1b5b7a571ec1aa8b"
   * 		],
   * 		"redOption": { # The query indicators include time consumption, request volume, and query skip errors.
   * 			"skipCount": false,
   * 			"skipError": true,
   * 			"skipRt": false
   * 		}
   * 	}
   */
  data?: string;
  /**
   * @remarks
   * The module type. Valid values:
   * 
   * *   QueryTopo: queries the topology.
   * *   QueryTopoRed: queries the red topology metrics, such as the number of requests, response time, and number of errors.
   * 
   * Notice: The preceding features are still in canary release and are disabled by default. If you need to enable these features, submit a ticket in the Application Real-Time Monitoring Service (ARMS) console.
   * 
   * *
   * *
   * 
   * This parameter is required.
   * 
   * @example
   * QueryTopo
   */
  module?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      module: 'Module',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      module: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DoInsightsActionResponseBody extends $tea.Model {
  /**
   * @remarks
   * Status code. 200 means success, other status codes are exceptions.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The response parameters vary with the value of module.
   * 
   * *   QueryTopo
   * 
   *         {
   *          "nodes": [Node] # The collection of nodes. For more information, see the "Node" section of this topic.
   *          "edges": [Edge] # The collection of edges. For more information, see the "Edge" section of this topic.
   *         }
   * 
   * *   QueryTopoRed
   * 
   *         {
   *           "nodeRed": {
   *           	"nodeId": {
   *           		"count": double, # The total number of requests in the specified time range.
   *           		"error": double, # The total number of errors in the specified time range.
   *           		"rt": double, # The average response time in the specified time range. Unit: milliseconds.
   *           	}
   *           },
   *           "edgeRed": {
   *           	"edgeId": {
   *           	    "count": double, # The total number of requests in the specified time range.
   *           		"error": double, # The total number of errors in the specified time range.
   *           		"rt": double, # The average response time in the specified time range. Unit: milliseconds.
   *           	}
   *           }
   * 
   * }
   * 
   * ```
   * ```
   * 
   * @example
   * - QueryTopo
   * 
   * 
   * 	{
   * 		"nodes": [
   * 			{
   * 				"nodeId": "3bfe1a747389273388182760406c079d",
   * 				"entity": {
   * 					"regionId": "cn-hangzhou",
   * 					"appType": "TRACE",
   * 					"appId": "xxxxxxxxxxxxxxxx",
   * 					"name": "prometheus-pop-cn-hangzhou",
   * 					"entityId": "3bfe1a747389273388182760406c079d",
   * 					"firstSeenTms": 1721733226981,
   * 					"lastSeenTms": 1721789171614,
   * 					"type": "APPLICATION"
   * 				},
   * 				"attrs": {
   * 					"RED": {
   * 						"count": 643848.0,
   * 						"error": 0.0,
   * 						"rt": 172.31701892372112
   * 					}
   * 				}
   * 			}
   * 		],
   * 		"edges": [
   * 			{
   * 				"from": "98b4184b22e588cf86e9a29aa4179606",
   * 				"to": "98b4184b22e588cf86e9a29aa4179606",
   * 				"type": "CALLS",
   * 				"attrs": {
   * 					"RED": {
   * 						"count": 4.0,
   * 						"error": 0.0,
   * 						"rt": 37.0
   * 					}
   * 				},
   * 				"edgeId": "5d611597e4b0013d0947615c9eca4de6",
   * 				"firstSeenTms": 1721783795125,
   * 				"lastSeenTms": 1721787371614
   * 			}
   * 		]
   * 	}
   * 
   * 
   * - QueryTopoRed
   * 
   * 	{
   * 		"nodeRed": {
   * 			"361d9f32e58cef316bf2355f3ff05575": {
   * 				"count": 3258110.0,
   * 				"error": 74.0,
   * 				"rt": 167.39844355494878
   * 			}
   * 		},
   * 		"edgeRed": {}
   * 	}
   */
  data?: string;
  /**
   * @remarks
   * Information returned when the call fails.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 626037F5-FDEB-45B0-804C-B3C92797A64E
   */
  requestId?: string;
  /**
   * @remarks
   * Whether the query is successful:
   * 
   * - true
   * - false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DoInsightsActionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DoInsightsActionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DoInsightsActionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableMetricRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * ccfa5e34a5c1f4ce6b916a40a12151d88
   */
  clusterId?: string;
  /**
   * @remarks
   * The metric name.
   * 
   * @example
   * kube_pod_container_status_ready
   */
  dropMetric?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dropMetric: 'DropMetric',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dropMetric: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableMetricResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned struct.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 0231DA4B-3D11-5433-9376-3B5B46C7228D
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableMetricResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EnableMetricResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EnableMetricResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAgentDownloadUrlRequest extends $tea.Model {
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAgentDownloadUrlResponseBody extends $tea.Model {
  /**
   * @remarks
   * The download URL of the ARMS agent.
   * 
   * @example
   * http://arms-apm-hangzhou.oss-cn-hangzhou-internal.aliyuncs.com/2.7.1.1/
   */
  armsAgentDownloadUrl?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 14043452-D486-4EA1-80C9-BA73FB81****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      armsAgentDownloadUrl: 'ArmsAgentDownloadUrl',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      armsAgentDownloadUrl: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAgentDownloadUrlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetAgentDownloadUrlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetAgentDownloadUrlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAgentDownloadUrlV2Request extends $tea.Model {
  /**
   * @remarks
   * The agent type.\\
   * **Valid values:**
   * 
   * *   **JavaAgent**
   * *   **Instgo**
   * 
   * This parameter is required.
   * 
   * @example
   * JavaAgent
   */
  agentType?: string;
  /**
   * @remarks
   * The architecture type of the environment where the agent is installed.\\
   * This parameter is required and valid only when **AgentType** is set to **Instgo**.\\
   * **Valid values:**
   * 
   * *   **amd64**
   * *   **arm64**
   * 
   * @example
   * amd64
   */
  archType?: string;
  /**
   * @remarks
   * The operating system of the environment where the agent is installed.\\
   * This parameter is required and valid only when **AgentType** is set to **Instgo**.\\
   * **Valid values:**
   * 
   * *   **linux**
   * *   **darwin**
   * *   **windows**
   * 
   * @example
   * linux
   */
  osType?: string;
  static names(): { [key: string]: string } {
    return {
      agentType: 'AgentType',
      archType: 'ArchType',
      osType: 'OsType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      agentType: 'string',
      archType: 'string',
      osType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAgentDownloadUrlV2ResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.\\
   * **Valid values:**
   * 
   * *   2xx: The request was successful.
   * *   3xx: The request was redirected.
   * *   4xx: The request was invalid.
   * *   5xx: A server error occurred.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The version number and download URL of the agent.
   */
  data?: GetAgentDownloadUrlV2ResponseBodyData;
  /**
   * @remarks
   * The returned message.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 78901766-3806-4E96-8E47-CFEF59E4****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.\\
   * **Valid values:**
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: GetAgentDownloadUrlV2ResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAgentDownloadUrlV2Response extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetAgentDownloadUrlV2ResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetAgentDownloadUrlV2ResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAlertRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The unique IDs of alert rules.
   * 
   * *   If you do not specify this parameter, the API operation does not filter alert rules based on their IDs.
   * *   If you specify this parameter, the API operation returns only the information of the specified alert rules. Other filter conditions also take effect.
   * 
   * > When you call the GetAlertRules operation, you can specify other request parameters to obtain the AlertIds parameter from the response. Then, you can specify the AlertIds parameter to query the specified alert rules.
   * 
   * @example
   * ["12345"]
   */
  alertIds?: string;
  /**
   * @remarks
   * The names of alert rules. When you create alert rules of the new version, you cannot specify duplicate names. However, existing alert rules may have duplicate names. Therefore, the **AlertName** parameter does not uniquely identify an alert rule.
   * 
   * *   If you do not specify this parameter, the API operation does not filter alert rules based on their names.
   * *   If you specify this parameter, the API operation returns only the information of the specified alert rules. Other filter conditions also take effect.
   * 
   * @example
   * ["test"]
   */
  alertNames?: string;
  /**
   * @remarks
   * The status of the alert rule. Valid values:
   * 
   * *   RUNNING
   * *   STOPPED
   * *   PAUSED
   * 
   * >  The PAUSED state indicates that the alert rule is abnormal and has been suspended. This may be because the specified threshold value is excessively large, or the associated cluster has been deleted.
   * 
   * @example
   * RUNNING
   */
  alertStatus?: string;
  /**
   * @remarks
   * The type of the alert rule. This parameter is required for the new version of Alert Management.
   * 
   * *   APPLICATION_MONITORING_ALERT_RULE: alert rule for Application Monitoring
   * *   BROWSER_MONITORING_ALERT_RULE: alert rule for Browser Monitoring
   * *   PROMETHEUS_MONITORING_ALERT_RULE: alert rule for Managed Service for Prometheus
   * 
   * @example
   * APPLICATION_MONITORING_ALERT_RULE
   */
  alertType?: string;
  /**
   * @remarks
   * The ID of the monitored cluster.
   * 
   * @example
   * ceba9b9ea5b924dd0b6726d2de6******
   */
  clusterId?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * You do not need to configure this parameter.
   * 
   * @example
   * null
   */
  productCode?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The number of alert rules to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 20
   */
  size?: number;
  /**
   * @remarks
   * The list of tags.
   */
  tags?: GetAlertRulesRequestTags[];
  static names(): { [key: string]: string } {
    return {
      alertIds: 'AlertIds',
      alertNames: 'AlertNames',
      alertStatus: 'AlertStatus',
      alertType: 'AlertType',
      clusterId: 'ClusterId',
      page: 'Page',
      productCode: 'ProductCode',
      regionId: 'RegionId',
      size: 'Size',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertIds: 'string',
      alertNames: 'string',
      alertStatus: 'string',
      alertType: 'string',
      clusterId: 'string',
      page: 'number',
      productCode: 'string',
      regionId: 'string',
      size: 'number',
      tags: { 'type': 'array', 'itemType': GetAlertRulesRequestTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAlertRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned pages.
   */
  pageBean?: GetAlertRulesResponseBodyPageBean;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 337B8F7E-0A64-5768-9225-E9B3CF******
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageBean: 'PageBean',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageBean: GetAlertRulesResponseBodyPageBean,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAlertRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetAlertRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetAlertRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAppApiByPageRequest extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  currentPage?: number;
  /**
   * @remarks
   * The end of the time range to query. Unit: milliseconds.
   * 
   * @example
   * 1600066800000
   */
  endTime?: number;
  /**
   * @remarks
   * The time interval between the data shards to be queried. Unit: milliseconds. Minimum value: 60000. Maximum value: 2147483647.
   * 
   * @example
   * 60000
   */
  intervalMills?: number;
  /**
   * @remarks
   * The process identifier (PID) of the application. For information about how to obtain a PID, see [Obtain the PID of an application](https://www.alibabacloud.com/help/zh/doc-detail/186100.htm?spm=a2cdw.13409063.0.0.7a72281f0bkTfx#title-imy-7gj-qhr).
   * 
   * This parameter is required.
   * 
   * @example
   * a2n80plglh@745eddxxx
   */
  PId?: string;
  /**
   * @remarks
   * The number of entries to return on each page. This parameter is no longer supported. The number of entries to return on each page. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Unit: milliseconds.
   * 
   * @example
   * 1600063200000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      endTime: 'EndTime',
      intervalMills: 'IntervalMills',
      PId: 'PId',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      endTime: 'number',
      intervalMills: 'number',
      PId: 'string',
      pageSize: 'number',
      regionId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAppApiByPageResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code returned for the request. Valid values:
   * 
   * *   2XX: The request was successful.
   * *   3XX: A redirection message was returned.
   * *   4XX: The request was invalid.
   * *   5XX: A server error occurred.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The struct returned.
   */
  data?: GetAppApiByPageResponseBodyData;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * B6A00968-82A8-4F14-9D1B-B53827DB****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   `true`: The call was successful.
   * *   `false`: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: GetAppApiByPageResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAppApiByPageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetAppApiByPageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetAppApiByPageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAppJVMConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. Unit: milliseconds.
   * 
   * @example
   * 1480607940000
   */
  endTime?: number;
  /**
   * @remarks
   * The IDof the application.
   *  
   * Log on to the **ARMS console**. In the left-side navigation pane, choose **Application Monitoring** > **Applications**. On the **Applications** page, click the name of an application. The URL in the address bar contains the process ID (PID) of the application. The PID is indicated in the pid=xxx format. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is eb4zdose6v%409781be0f44d\\*\\*\\*\\*, you must replace %40 with an at sign (@) to obtain eb4zdose6v@9781be0f44d\\*\\*\\*\\*.
   * 
   * @example
   * atc889zkcf@d8deedfa9bf****
   */
  pid?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The start of the time range to query. Unit: milliseconds.
   * 
   * @example
   * 1480521600000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      pid: 'Pid',
      regionId: 'RegionId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      pid: 'string',
      regionId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAppJVMConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code. Valid values: 2XX: The request is successful. 3XX: A redirection message is returned. 4XX: The request is invalid. 5XX: A server error occurs.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The list of JVM information.
   */
  jvmInfoList?: GetAppJVMConfigResponseBodyJvmInfoList[];
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1A9C645C-C83F-4C9D-8CCB-29BEC9E1****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values: true and false.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      jvmInfoList: 'JvmInfoList',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      jvmInfoList: { 'type': 'array', 'itemType': GetAppJVMConfigResponseBodyJvmInfoList },
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAppJVMConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetAppJVMConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetAppJVMConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthTokenRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ACK cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthTokenResponseBody extends $tea.Model {
  /**
   * @remarks
   * Status code. 200 means success, other status codes are exceptions.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned authentication token.
   * 
   * @example
   * eyJhbGciOiJIUzI1NiJ9******
   */
  data?: string;
  /**
   * @remarks
   * Additional Information.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 1A9C645C-C83F-4C9D-8CCB-29BEC9E1****
   */
  requestId?: string;
  /**
   * @remarks
   * Whether the query was successful:
   * - true: Success
   * - false: Failure
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthTokenResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetAuthTokenResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetAuthTokenResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCloudClusterAllUrlRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the CloudMonitor instance.
   * 
   * @example
   * ca9676014babd4
   */
  clusterId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-beijing
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCloudClusterAllUrlResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * An array object.
   */
  data?: GetCloudClusterAllUrlResponseBodyData[];
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 99A663CB-8D7B-4B0D-A006-03C8EE38E7BB
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values: true and false.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': GetCloudClusterAllUrlResponseBodyData },
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCloudClusterAllUrlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetCloudClusterAllUrlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCloudClusterAllUrlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClusterAllUrlRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The region ID. Default value: cn-hangzhou.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClusterAllUrlResponseBody extends $tea.Model {
  /**
   * @remarks
   * Status code. 200 means success, other status codes are exceptions.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The response parameters in the JSON format.
   * 
   * @example
   * {
   *   "RequestId": "41877338-646B-5DD6-BFBE-F89F1E7245AD",
   *   "Data": "{\\"clusterType\\":\\"ManagedKubernetes\\",\\"remoteWriteUrl\\":\\"http:/" }
   */
  data?: string;
  /**
   * @remarks
   * The prompt information of the returned result.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 40B10E04-81E8-4643-970D-F1B38F2E****
   */
  requestId?: string;
  /**
   * @remarks
   * Whether the query is successful:
   * - true: success
   * - false: failure
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClusterAllUrlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetClusterAllUrlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetClusterAllUrlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCommercialStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The product code.
   * 
   * *   arms_app_post
   * *   arms_web_post
   * *   arms_promethues_public_cn
   * *   prometheus_pay_public_cn
   * *   xtrace
   * *   arms_serverless_public_cn
   * *   arms_rumserverless_public_cn
   * *   prometheus_serverless_public_cn
   * *   xtrace_serverless_public_cn
   * 
   * This parameter is required.
   * 
   * @example
   * arms_app_post
   */
  commodityCode?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      commodityCode: 'CommodityCode',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commodityCode: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCommercialStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 49C82193-E991-5F6A-AF3E-1664D8D05CA3
   */
  requestId?: string;
  /**
   * @remarks
   * The commercialization status of the service.
   */
  userAndCommodityStatus?: GetCommercialStatusResponseBodyUserAndCommodityStatus;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      userAndCommodityStatus: 'UserAndCommodityStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      userAndCommodityStatus: GetCommercialStatusResponseBodyUserAndCommodityStatus,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCommercialStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetCommercialStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCommercialStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetExploreUrlRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c9cc4c5e220f8461f9d71b6ec6e******
   */
  clusterId?: string;
  /**
   * @remarks
   * The query statement that corresponds to the data source.
   * 
   * @example
   * {app="buy2"}
   */
  expression?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The type of the Grafana data source.
   * 
   * This parameter is required.
   * 
   * @example
   * prometheus
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      expression: 'Expression',
      regionId: 'RegionId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      expression: 'string',
      regionId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetExploreUrlResponseBody extends $tea.Model {
  /**
   * @remarks
   * Status code. 200 means success, other status codes are exceptions.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Response parameters
   * 
   * @example
   * -
   */
  data?: string;
  /**
   * @remarks
   * The prompt information of the returned result.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 34ED024E-9E31-434A-9E4E-D9D15C3****
   */
  requestId?: string;
  /**
   * @remarks
   * Whether the operation was successful:
   * - true: the operation was successful
   * - false: the operation failed
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetExploreUrlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetExploreUrlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetExploreUrlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGrafanaWorkspaceRequest extends $tea.Model {
  /**
   * @remarks
   * The language. Valid values: zh and en. Default value: zh.
   * 
   * @example
   * zh
   */
  aliyunLang?: string;
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * grafana-cn-4xl3g******
   */
  grafanaWorkspaceId?: string;
  /**
   * @remarks
   * The region ID. Default value: cn-hangzhou.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunLang: 'AliyunLang',
      grafanaWorkspaceId: 'GrafanaWorkspaceId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunLang: 'string',
      grafanaWorkspaceId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGrafanaWorkspaceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code returned for the request. Valid values:
   * 
   * *   `2XX`: The request is successful.
   * *   `3XX`: A redirection message is returned.
   * *   `4XX`: The request is invalid.
   * *   `5XX`: A server error occurs.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The information about the Grafana workspace.
   */
  data?: GrafanaWorkspace;
  /**
   * @remarks
   * The error message returned when the request parameters are invalid.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 2C3F217B-9AAE-5D51-974D-48********
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The ID of the trace. The ID is used to query the details of a request.
   * 
   * @example
   * eac0a8048716731735000007137d000b
   */
  traceId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      traceId: 'TraceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: GrafanaWorkspace,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
      traceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetGrafanaWorkspaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetGrafanaWorkspaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetGrafanaWorkspaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetIntegrationStateRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the Container Service for Kubernetes (ACK) cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The abbreviation of the software that is supported by ARMS. Valid values (case-insensitive): `ASM`, `IoT`, and `Flink`.
   * 
   * This parameter is required.
   * 
   * @example
   * asm
   */
  integration?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      integration: 'Integration',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      integration: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetIntegrationStateResponseBody extends $tea.Model {
  /**
   * @remarks
   * Status code. 200 means success, other status codes are exceptions.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The prompt information of the returned result.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 1A9C645C-C83F-4C9D-8CCB-29BEC9E1****
   */
  requestId?: string;
  /**
   * @remarks
   * The integration state of Prometheus dashboards and collection rules. Valid values:
   * 
   * *   `true`: The Prometheus dashboards and collection rules that monitor the software are integrated.
   * *   `false`: The Prometheus dashboards and collection rules that monitor the software are not integrated.
   * 
   * @example
   * true
   */
  state?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      requestId: 'string',
      state: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetIntegrationStateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetIntegrationStateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetIntegrationStateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetManagedPrometheusStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID. This parameter is required if the ClusterType parameter is set to ask.
   * 
   * This parameter is required.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The type of the cluster. Valid values: ask and ecs.
   * 
   * This parameter is required.
   * 
   * @example
   * ask
   */
  clusterType?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The resource group id of the Prometheus instance.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The ID of the virtual private cloud (VPC). This parameter is required if the ClusterType parameter is set to ecs.
   * 
   * @example
   * vpc-***
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      clusterType: 'ClusterType',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      clusterType: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetManagedPrometheusStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The installation status of the Prometheus agent.
   * 
   * *   Installing: The Prometheus agent is installed and no registration information is available.
   * *   Succeed: The Prometheus agent is installed and registered.
   * *   Failure: The Prometheus agent failed to be installed or registered.
   * *   Unknown: The installation status of the Prometheus agent is unknown.
   * 
   * @example
   * Installing
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * Successful
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F7781D4A-2818-41E7-B7BB-79D809E9****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetManagedPrometheusStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetManagedPrometheusStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetManagedPrometheusStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMultipleTraceRequest extends $tea.Model {
  /**
   * @remarks
   * The time when the trace ends. The value is a timestamp. Unit: milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1663999380000
   */
  endTime?: number;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The start time of the trace. The value is a timestamp. Unit: milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1657692507000
   */
  startTime?: number;
  /**
   * @remarks
   * The trace IDs.
   * 
   * This parameter is required.
   * 
   * @example
   * ac1400a115951745017447033d****
   */
  traceIDs?: string[];
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      regionId: 'RegionId',
      startTime: 'StartTime',
      traceIDs: 'TraceIDs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      regionId: 'string',
      startTime: 'number',
      traceIDs: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMultipleTraceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of traces.
   */
  multiCallChainInfos?: GetMultipleTraceResponseBodyMultiCallChainInfos[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2983BEF7-4A0D-47A2-94A2-8E9C5E63****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      multiCallChainInfos: 'MultiCallChainInfos',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      multiCallChainInfos: { 'type': 'array', 'itemType': GetMultipleTraceResponseBodyMultiCallChainInfos },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMultipleTraceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMultipleTraceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMultipleTraceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOnCallSchedulesDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The date on which the shift ends. Format: `yyyy-MM-dd`.
   * 
   * @example
   * 2022-10-30
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the scheduling policy.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  id?: number;
  /**
   * @remarks
   * The date from which the shift starts. Format: `yyyy-MM-dd`.
   * 
   * @example
   * 2022-10-01
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      id: 'Id',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      id: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOnCallSchedulesDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the scheduling policy.
   */
  data?: GetOnCallSchedulesDetailResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 21E85B16-75A6-429A-9F65-8AAC9A54****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetOnCallSchedulesDetailResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOnCallSchedulesDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetOnCallSchedulesDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOnCallSchedulesDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPrometheusApiTokenRequest extends $tea.Model {
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPrometheusApiTokenResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1A9C645C-C83F-4C9D-8CCB-29BEC9E1****
   */
  requestId?: string;
  /**
   * @remarks
   * The token required for integrating Prometheus Service.
   * 
   * @example
   * 6dcbb77ef4ba6ef5466b5debf9e2****
   */
  token?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      token: 'Token',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      token: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPrometheusApiTokenResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPrometheusApiTokenResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPrometheusApiTokenResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPrometheusGlobalViewRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the global aggregation instance.
   * 
   * This parameter is required.
   * 
   * @example
   * global-v2-cn-1478326682034601-vss8pd0i
   */
  globalViewClusterId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      globalViewClusterId: 'GlobalViewClusterId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      globalViewClusterId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPrometheusGlobalViewResponseBody extends $tea.Model {
  /**
   * @remarks
   * Status code. 200 is success, other status codes are exceptions.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The struct returned.
   * 
   * @example
   * { "clusterId":"The ID of the global aggregation instance.", "groupName":"The name of the global aggregation instance.", "dataSources":[ { "sourceName":"The name of the data source.- ArmsPrometheus No.1", "sourceType":"AlibabaPrometheus", "userId":"UserID", "clusterId":"ClusterId" }, // more datasources ] }
   */
  data?: string;
  /**
   * @remarks
   * Returns a hint message for the result.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 743AD493-D006-53BD-AAEC-DDCE7FB68EA7
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPrometheusGlobalViewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPrometheusGlobalViewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPrometheusGlobalViewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPrometheusInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the Prometheus instance.
   * 
   * This parameter is required.
   * 
   * @example
   * c77f6f2397ea74672872acf5e31374a27
   */
  clusterId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPrometheusInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned message.
   */
  data?: GetPrometheusInstanceResponseBodyData;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 52C422FD-6B43-524D-B8A1-A4693294318C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: GetPrometheusInstanceResponseBodyData,
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPrometheusInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPrometheusInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPrometheusInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPrometheusIntegrationRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the Prometheus instance. Valid values: aliyun-cs and ecs.
   * 
   * This parameter is required.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The ID of the exporter.
   * 
   * This parameter is required.
   * 
   * @example
   * 2893
   */
  instanceId?: number;
  /**
   * @remarks
   * The integration type. Valid values: kafka, mysql, redis, snmp, emr, nubela, and tidb.
   * 
   * This parameter is required.
   * 
   * @example
   * kafka, mysql, redis, snmp, emr, nubela, and tidb
   */
  integrationType?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      instanceId: 'InstanceId',
      integrationType: 'IntegrationType',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      instanceId: 'number',
      integrationType: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPrometheusIntegrationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned struct.
   */
  data?: GetPrometheusIntegrationResponseBodyData;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9BEF2832-9D95-5E3E-9B10-74887CA17B94
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: GetPrometheusIntegrationResponseBodyData,
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPrometheusIntegrationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPrometheusIntegrationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPrometheusIntegrationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPrometheusMonitoringRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the Prometheus instance.
   * 
   * This parameter is required.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The name of the monitoring configuration.
   * 
   * This parameter is required.
   * 
   * @example
   * customJob1
   */
  monitoringName?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The type of the monitoring configuration. 
   * Valid values for a Prometheus instance for Container Service: serviceMonitor, podMonitor, customJob, and probe. 
   * Valid values for a Prometheus instance for ECS: customJob and probe.
   * 
   * This parameter is required.
   * 
   * @example
   * customJob
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      monitoringName: 'MonitoringName',
      regionId: 'RegionId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      monitoringName: 'string',
      regionId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPrometheusMonitoringResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned struct.
   */
  data?: GetPrometheusMonitoringResponseBodyData;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 78901766-3806-4E96-8E47-CFEF59E4****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: GetPrometheusMonitoringResponseBodyData,
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPrometheusMonitoringResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPrometheusMonitoringResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPrometheusMonitoringResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRecordingRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRecordingRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * Status code. 200 is success, other status codes are exceptions.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The recording rule.
   * 
   * @example
   * --- groups: - name: "recording_demo"   rules:   - expr: "sum(jvm_memory_max_bytes)"     record: "rate_coredns_demo"
   */
  data?: string;
  /**
   * @remarks
   * Returns a hint message for the result.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9FEA6D00-317F-45E3-9004-7FB8B0B7****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRecordingRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRecordingRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRecordingRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRetcodeAppByPidRequest extends $tea.Model {
  /**
   * @remarks
   * The PID of the application. To obtain the PID of the application, perform the following steps: Log on to the Application Real-Time Monitoring Service (ARMS) console. In the left-side navigation pane, choose **Browser Monitoring** > **Browser Monitoring**. On the Browser Monitoring page, click the name of the application. The URL in the address bar contains the PID of the application. The PID is in the pid=xxx format. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is xxx%4074xxx, you must replace %40 with the at sign (@) to obtain xxx@74xxx.
   * 
   * This parameter is required.
   * 
   * @example
   * b590lhguqs@9781be0f44dXXXX
   */
  pid?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The list of tags.
   */
  tags?: GetRetcodeAppByPidRequestTags[];
  static names(): { [key: string]: string } {
    return {
      pid: 'Pid',
      regionId: 'RegionId',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pid: 'string',
      regionId: 'string',
      tags: { 'type': 'array', 'itemType': GetRetcodeAppByPidRequestTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRetcodeAppByPidResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 2983BEF7-4A0D-47A2-94A2-8E9C5E63****
   */
  requestId?: string;
  /**
   * @remarks
   * The returned application data.
   */
  retcodeApp?: GetRetcodeAppByPidResponseBodyRetcodeApp;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      retcodeApp: 'RetcodeApp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      retcodeApp: GetRetcodeAppByPidResponseBodyRetcodeApp,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRetcodeAppByPidResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRetcodeAppByPidResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRetcodeAppByPidResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRetcodeDataByQueryRequest extends $tea.Model {
  /**
   * @remarks
   * The beginning of the time range to query. This value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 1668687302
   */
  from?: number;
  /**
   * @remarks
   * The ID of the application.
   * 
   * Log on to the **ARMS console**. In the left-side navigation pane, choose **Browser Monitoring** > **Browser Monitoring**. On the Browser Monitoring page, click the name of an application. The URL in the address bar contains the process ID (PID) of the application. The PID is indicated in the pid=xxx format. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is eb4zdose6v%409781be0f44d\\*\\*\\*\\*, you must replace %40 with an at sign (@) to obtain eb4zdose6v@9781be0f44d\\*\\*\\*\\*.
   * 
   * This parameter is required.
   * 
   * @example
   * atc889zkcf@d8deedfa9bf****
   */
  pid?: string;
  /**
   * @remarks
   * The query statement that conforms to the query syntax of a Log Service Logstore.
   * 
   * This parameter is required.
   * 
   * @example
   * t : pv|select sum(times) as pv , approx_distinct(uid) as uv , (date-date%3600000) as date  group by date
   */
  query?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The end of the time range to query. This value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 1668688000
   */
  to?: number;
  static names(): { [key: string]: string } {
    return {
      from: 'From',
      pid: 'Pid',
      query: 'Query',
      regionId: 'RegionId',
      to: 'To',
    };
  }

  static types(): { [key: string]: any } {
    return {
      from: 'number',
      pid: 'string',
      query: 'string',
      regionId: 'string',
      to: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRetcodeDataByQueryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code returned for the request. Valid values:
   * 
   * *   2XX: The request was successful.
   * *   3XX: A redirection message was returned.
   * *   4XX: The request was invalid.
   * *   5XX: A server error occurred.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The Browser Monitoring data returned.
   * 
   * @example
   * {"total":0,"auth":false,"pageSize":20,"completed":true,"page":1,"items":[]}
   */
  data?: string;
  /**
   * @remarks
   * The error message returned if the call fails.
   * 
   * @example
   * Internal error. Please try again. Contact the DingTalk service account if the issue                              persists after multiple retries.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2A0CEDF1-06FE-44AC-8E21-21A5BE65****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRetcodeDataByQueryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRetcodeDataByQueryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRetcodeDataByQueryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRetcodeLogstoreRequest extends $tea.Model {
  /**
   * @remarks
   * The process identifier (PID) of the application. To obtain the PID of the application, perform the following steps: Log on to the Application Real-Time Monitoring Service (ARMS) console. In the left-side navigation pane, choose **Browser Monitoring** > **Browser Monitoring**. On the Browser Monitoring page, click the name of the application. The URL in the address bar contains the PID of the application. The PID is in the pid=xxx format. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is xxx%4074xxx, you must replace %40 with the at sign (@) to obtain xxx@74xxx.
   * 
   * This parameter is required.
   * 
   * @example
   * atc889zkcf@d8deedfa9bf****
   */
  pid?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      pid: 'Pid',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pid: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRetcodeLogstoreResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned struct.
   */
  data?: GetRetcodeLogstoreResponseBodyData;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 1A9C645C-C83F-4C9D-8CCB-29BEC9E1****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetRetcodeLogstoreResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRetcodeLogstoreResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRetcodeLogstoreResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRetcodeLogstoreResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRetcodeShareUrlRequest extends $tea.Model {
  /**
   * @remarks
   * The process identifier (PID) of the application. 
   * 
   * Log on to the **ARMS console**. In the left-side navigation pane, choose **Browser Monitoring** > **Browser Monitoring**. On the Browser Monitoring page, click the name of an application. The URL in the address bar contains the process ID (PID) of the application. The PID is indicated in the `pid=xxx` format. The PID is usually percent encoded as `xxx%40xxx`. You must modify this value to remove the percent encoding. For example, if the PID in the URL is `eb4zdose6v%409781be0f44d****`, you must replace `%40` with @ to obtain `eb4zdose6v@9781be0f44d****`.
   * 
   * This parameter is required.
   * 
   * @example
   * iioe7jcnuk@582846f37******
   */
  pid?: string;
  static names(): { [key: string]: string } {
    return {
      pid: 'Pid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRetcodeShareUrlResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 01FF8DD9-A09C-47A1-895A-B6E321******
   */
  requestId?: string;
  /**
   * @remarks
   * The logon-free URL of the application.
   * 
   * @example
   * http://arms-daily.console.aliyun.com:8080/shareapi/retcode.json?login_arms_t3h_token=XXXxxx&action=RetcodeAction&eventSubmitDoGetData=1
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRetcodeShareUrlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRetcodeShareUrlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRetcodeShareUrlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumAppInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The group to which the application belongs.
   * 
   * @example
   * default
   */
  appGroup?: string;
  /**
   * @remarks
   * The process ID (PID) of the application.
   * 
   * This parameter is required.
   * 
   * @example
   * atc889zkcf@d8deedfa9bf****
   */
  pid?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      appGroup: 'AppGroup',
      pid: 'Pid',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appGroup: 'string',
      pid: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumAppInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The details of the application.
   */
  data?: GetRumAppInfoResponseBodyData;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * StartTime is mandatory for this action.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * A5EC8221-08F2-4C95-9AF1-49FD998C****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: GetRumAppInfoResponseBodyData,
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumAppInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRumAppInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRumAppInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumAppsRequest extends $tea.Model {
  /**
   * @remarks
   * The group to which the application belongs.
   * 
   * @example
   * default
   */
  appGroup?: string;
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * b590lhguqs@28f515462******
   */
  appId?: string;
  /**
   * @remarks
   * The name of the application. You can specify only one application name in each request.
   * 
   * @example
   * test-app
   */
  appName?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The tags.
   */
  tags?: GetRumAppsRequestTags[];
  static names(): { [key: string]: string } {
    return {
      appGroup: 'AppGroup',
      appId: 'AppId',
      appName: 'AppName',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appGroup: 'string',
      appId: 'string',
      appName: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      tags: { 'type': 'array', 'itemType': GetRumAppsRequestTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumAppsShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The group to which the application belongs.
   * 
   * @example
   * default
   */
  appGroup?: string;
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * b590lhguqs@28f515462******
   */
  appId?: string;
  /**
   * @remarks
   * The name of the application. You can specify only one application name in each request.
   * 
   * @example
   * test-app
   */
  appName?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The tags.
   */
  tagsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      appGroup: 'AppGroup',
      appId: 'AppId',
      appName: 'AppName',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      tagsShrink: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appGroup: 'string',
      appId: 'string',
      appName: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      tagsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumAppsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The queried applications.
   */
  appList?: GetRumAppsResponseBodyAppList[];
  /**
   * @remarks
   * The response code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * Internal error, please contact customer service.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 70675725-8F11-4817-8106-CFE0AD71****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      appList: 'AppList',
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appList: { 'type': 'array', 'itemType': GetRumAppsResponseBodyAppList },
      code: 'number',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumAppsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRumAppsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRumAppsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumDataForPageRequest extends $tea.Model {
  /**
   * @remarks
   * The group to which the application belongs.
   * 
   * @example
   * default
   */
  appGroup?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  currentPage?: number;
  /**
   * @remarks
   * The beginning of the time range to query. The time is accurate to seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1713774233
   */
  endTime?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * iixxxjcnuk@582846f37******
   */
  pid?: string;
  /**
   * @remarks
   * A query statement that complies with the query syntax of Simple Log Service Logstore. For more information, see the parameters corresponding to this operation on the console page.
   * 
   * This parameter is required.
   * 
   * @example
   * * and app.id: xxxx@586810fbxxxx19f
   */
  query?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. The time is accurate to seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1713687833
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      appGroup: 'AppGroup',
      currentPage: 'CurrentPage',
      endTime: 'EndTime',
      pageSize: 'PageSize',
      pid: 'Pid',
      query: 'Query',
      regionId: 'RegionId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appGroup: 'string',
      currentPage: 'number',
      endTime: 'number',
      pageSize: 'number',
      pid: 'string',
      query: 'string',
      regionId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumDataForPageResponseBody extends $tea.Model {
  /**
   * @remarks
   * The responses code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The result of the operation.
   */
  data?: GetRumDataForPageResponseBodyData;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * StartTime is mandatory for this action.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 78901766-3806-4E96-8E47-CFEF59E4****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetRumDataForPageResponseBodyData,
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumDataForPageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRumDataForPageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRumDataForPageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumExceptionStackRequest extends $tea.Model {
  /**
   * @remarks
   * The binary images, which represent all executable files loaded into the process address space when a crash occurs.
   * 
   * @example
   * iOSDemo:arm64%3B1489F4D3-6DE2-300C-90E9-E1B869675351%3B0x0000000104064000\\nAlibabaCloudRUM:arm64%3BAB7B3A8E-6CEE-325D-BCBB-8DA50E61804F%3B0x0000000106660000\\nlibdispatch.dylib:arm
   */
  exceptionBinaryImages?: string;
  /**
   * @remarks
   * The exception stack information. Set the value to a JSON string. call_stack.info represents the stack information, call_stack.thread.name represents the thread name, and call_stack.thread.id represents the thread ID. This parameter is exactly the same as the exception.stack parameter in the logstore-rum Logstore of Simple Log Service.
   * 
   * @example
   * [
   * {
   *     "call_stack.info": "libsystem_kernel.dylib  0x00000001f1ce9178 0x00000001f1ce8000 + 4472\\r\\nlibsystem_kernel.dylib  0x00000001f1ce8f10 0x00000001f1ce8000 + 3856\\r\\nlibsystem_kernel.dylib  0x00000001f1ced718 0x00000001f1ce8000 + 22296\\r\\nAlibabaCloudRUM  0x0000000106711af4 0x0000000106660000 + 727796\\r\\nlibsystem_pthread.dylib  0x00000002146744d4 0x0000000214672000 + 9428",
   *     "call_stack.thread.name": "#3 BRSCrash Exception Handler (Secondary)",
   *     "call_stack.thread.id": "16643"
   *   }
   * ]
   */
  exceptionStack?: string;
  /**
   * @remarks
   * The ID of the exception thread.
   * 
   * @example
   * 16643
   */
  exceptionThreadId?: string;
  /**
   * @remarks
   * The application ID.
   * 
   * This parameter is required.
   * 
   * @example
   * atxxxxzkcf@d8deedfa9bf****
   */
  pid?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The file type. Valid values:
   * 
   * - source-map: SourceMap files
   * - mapping: symbol table files for Android
   * - dsym: dSYM files for iOS
   * 
   * @example
   * source-map
   */
  sourcemapType?: string;
  static names(): { [key: string]: string } {
    return {
      exceptionBinaryImages: 'ExceptionBinaryImages',
      exceptionStack: 'ExceptionStack',
      exceptionThreadId: 'ExceptionThreadId',
      pid: 'Pid',
      regionId: 'RegionId',
      sourcemapType: 'SourcemapType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      exceptionBinaryImages: 'string',
      exceptionStack: 'string',
      exceptionThreadId: 'string',
      pid: 'string',
      regionId: 'string',
      sourcemapType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumExceptionStackResponseBody extends $tea.Model {
  /**
   * @remarks
   * The responses code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The response parameters.
   */
  data?: GetRumExceptionStackResponseBodyData;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * Internal error. Please try again. Contact the DingTalk service account if the issue                              persists after multiple retries.
   */
  message?: string;
  /**
   * @remarks
   * Id of the request.
   * 
   * @example
   * B6A00968-82A8-4F14-9D1B-B53827DB****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetRumExceptionStackResponseBodyData,
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumExceptionStackResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRumExceptionStackResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRumExceptionStackResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumOcuStatisticDataRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. Unit: milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1687849260000
   */
  endTime?: number;
  /**
   * @remarks
   * The filter condition. Three types of filter conditions are provided:
   * 
   * *   Application name: pid (Note that the application name is displayed, but the application ID is actually specified)
   * *   Application type: siteType
   * *   Data type: dataType
   */
  filter?: GetRumOcuStatisticDataRequestFilter[];
  /**
   * @remarks
   * The grouping fields. Valid values:
   * 
   * *   siteType: The total number of OCUs is grouped by application type.
   * *   dataType: The total number of OCUs is grouped by data type.
   * *   pid: The total number of OCUs is grouped by application ID.
   * *   appName: The total number of OCUs is grouped by application name.
   * *   startTime: The total number of OCUs is grouped by start time.
   */
  group?: string[];
  /**
   * @remarks
   * The page number.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * This parameter is required.
   * 
   * @example
   * 100
   */
  pageSize?: number;
  /**
   * @remarks
   * The type of the query. To query non-time series data, set the value to INSTANT. To query time series data, set the value to TIME_SERIES.
   * 
   * @example
   * TIME_SERIES
   */
  queryType?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Unit: milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1600063200000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      filter: 'Filter',
      group: 'Group',
      page: 'Page',
      pageSize: 'PageSize',
      queryType: 'QueryType',
      regionId: 'RegionId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      filter: { 'type': 'array', 'itemType': GetRumOcuStatisticDataRequestFilter },
      group: { 'type': 'array', 'itemType': 'string' },
      page: 'number',
      pageSize: 'number',
      queryType: 'string',
      regionId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumOcuStatisticDataShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. Unit: milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1687849260000
   */
  endTime?: number;
  /**
   * @remarks
   * The filter condition. Three types of filter conditions are provided:
   * 
   * *   Application name: pid (Note that the application name is displayed, but the application ID is actually specified)
   * *   Application type: siteType
   * *   Data type: dataType
   */
  filterShrink?: string;
  /**
   * @remarks
   * The grouping fields. Valid values:
   * 
   * *   siteType: The total number of OCUs is grouped by application type.
   * *   dataType: The total number of OCUs is grouped by data type.
   * *   pid: The total number of OCUs is grouped by application ID.
   * *   appName: The total number of OCUs is grouped by application name.
   * *   startTime: The total number of OCUs is grouped by start time.
   */
  groupShrink?: string;
  /**
   * @remarks
   * The page number.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * This parameter is required.
   * 
   * @example
   * 100
   */
  pageSize?: number;
  /**
   * @remarks
   * The type of the query. To query non-time series data, set the value to INSTANT. To query time series data, set the value to TIME_SERIES.
   * 
   * @example
   * TIME_SERIES
   */
  queryType?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Unit: milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1600063200000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      filterShrink: 'Filter',
      groupShrink: 'Group',
      page: 'Page',
      pageSize: 'PageSize',
      queryType: 'QueryType',
      regionId: 'RegionId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      filterShrink: 'string',
      groupShrink: 'string',
      page: 'number',
      pageSize: 'number',
      queryType: 'string',
      regionId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumOcuStatisticDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned struct.
   */
  data?: GetRumOcuStatisticDataResponseBodyData;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * null
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 626037F5-FDEB-45B0-804C-B3C92797****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: GetRumOcuStatisticDataResponseBodyData,
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumOcuStatisticDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRumOcuStatisticDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRumOcuStatisticDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumUploadFilesRequest extends $tea.Model {
  /**
   * @remarks
   * The file type. Valid values: source-map: SourceMap files. mapping: symbol table files for Android. dsym: dSYM files for iOS.
   * 
   * @example
   * source-map
   */
  appType?: string;
  /**
   * @remarks
   * The process ID (PID) of the application.
   * 
   * This parameter is required.
   * 
   * @example
   * aoxxxxxly@741623b4e91****
   */
  pid?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The version number of the files. If you do not specify this parameter, all versions of the files are returned by default.
   * 
   * @example
   * 1.0.0
   */
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      pid: 'Pid',
      regionId: 'RegionId',
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      pid: 'string',
      regionId: 'string',
      versionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumUploadFilesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The queried files.
   */
  data?: GetRumUploadFilesResponseBodyData[];
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2983BEF7-4A0D-47A2-94A2-8E9C5E63****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': GetRumUploadFilesResponseBodyData },
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumUploadFilesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRumUploadFilesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRumUploadFilesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSourceMapInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The order in which the files are sorted. Valid values:
   * 
   * *   true: ascending order
   * *   false: descending order
   * 
   * @example
   * true
   */
  ascendingSequence?: boolean;
  /**
   * @remarks
   * The version of the SourceMap file.
   * 
   * @example
   * 0.0.0
   */
  edition?: string;
  /**
   * @remarks
   * The ID of the SourceMap file.
   * 
   * This parameter is required.
   */
  ID?: string;
  /**
   * @remarks
   * The keyword in the file name. The files are searched by keyword.
   * 
   * @example
   * test
   */
  keyword?: string;
  /**
   * @remarks
   * The criterion by which the files are sorted. Valid values:
   * 
   * *   version: The files are sorted by version.
   * *   uploadTime: The files are sorted by upload time.
   * 
   * @example
   * version
   */
  orderField?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      ascendingSequence: 'AscendingSequence',
      edition: 'Edition',
      ID: 'ID',
      keyword: 'Keyword',
      orderField: 'OrderField',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ascendingSequence: 'boolean',
      edition: 'string',
      ID: 'string',
      keyword: 'string',
      orderField: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSourceMapInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C21AB7CF-B7AF-410F-BD61-82D1567F****
   */
  requestId?: string;
  /**
   * @remarks
   * The details of the SourceMap file.
   */
  sourceMapList?: GetSourceMapInfoResponseBodySourceMapList[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      sourceMapList: 'SourceMapList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      sourceMapList: { 'type': 'array', 'itemType': GetSourceMapInfoResponseBodySourceMapList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSourceMapInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSourceMapInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSourceMapInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStackRequest extends $tea.Model {
  /**
   * @remarks
   * The end time of the call method.
   * 
   * @example
   * 1653641800
   */
  endTime?: number;
  /**
   * @remarks
   * The process identifier (PID) of the application. For more information about how to obtain the PID, see [Obtain the PID of an application](https://www.alibabacloud.com/help/zh/doc-detail/186100.htm?spm=a2cdw.13409063.0.0.7a72281f0bkTfx#title-imy-7gj-qhr).
   * 
   * @example
   * eb4zdose6v@36bab313a******
   */
  pid?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the remote procedure call (RPC) mode. You can obtain the ID by calling the **GetTrace** operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 0.1
   */
  rpcID?: string;
  /**
   * @remarks
   * The start time of the call method.
   * 
   * @example
   * 1653555396
   */
  startTime?: number;
  /**
   * @remarks
   * The trace ID. You can log on to the Application Real-Time Monitoring Service (ARMS) console and obtain the trace ID on the **Trace Query** page.
   * 
   * This parameter is required.
   * 
   * @example
   * 0a5800611641470044457853******
   */
  traceID?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      pid: 'Pid',
      regionId: 'RegionId',
      rpcID: 'RpcID',
      startTime: 'StartTime',
      traceID: 'TraceID',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      pid: 'string',
      regionId: 'string',
      rpcID: 'string',
      startTime: 'number',
      traceID: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStackResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * B34C3A43-A901-5F94-9DAD-758CE4******
   */
  requestId?: string;
  /**
   * @remarks
   * The information of the method stack.
   */
  stackInfo?: GetStackResponseBodyStackInfo[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      stackInfo: 'StackInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      stackInfo: { 'type': 'array', 'itemType': GetStackResponseBodyStackInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStackResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetStackResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetStackResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticMonitorsRequest extends $tea.Model {
  /**
   * @remarks
   * The query conditions.
   * 
   * This parameter is required.
   */
  filter?: GetSyntheticMonitorsRequestFilter;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      filter: 'Filter',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      filter: GetSyntheticMonitorsRequestFilter,
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticMonitorsShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The query conditions.
   * 
   * This parameter is required.
   */
  filterShrink?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      filterShrink: 'Filter',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      filterShrink: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticMonitorsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The list of monitoring points.
   */
  data?: GetSyntheticMonitorsResponseBodyData[];
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2FD473FF-5398-5A85-9BF6-7AB45561522F
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': GetSyntheticMonitorsResponseBodyData },
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticMonitorsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSyntheticMonitorsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSyntheticMonitorsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticTaskDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The region ID. Default value: cn-hangzhou.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the synthetic monitoring task.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticTaskDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 4D6C358A-A58B-4F4B-94CE-F5AAF023****
   */
  requestId?: string;
  /**
   * @remarks
   * The details of the task.
   */
  taskDetail?: GetSyntheticTaskDetailResponseBodyTaskDetail;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      taskDetail: 'TaskDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      taskDetail: GetSyntheticTaskDetailResponseBodyTaskDetail,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticTaskDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSyntheticTaskDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSyntheticTaskDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticTaskListRequest extends $tea.Model {
  /**
   * @remarks
   * The order by which the queried tasks are sorted. Valid values:
   * 
   * *   **asc**: ascending
   * *   **desc**: descending
   * 
   * @example
   * asc
   */
  direction?: string;
  /**
   * @remarks
   * The condition by which the queried tasks are sorted.
   * 
   * @example
   * CreateTime
   */
  order?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNum?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The region ID. Default value: **cn-hangzhou**.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The task name.
   * 
   * @example
   * net-test
   */
  taskName?: string;
  /**
   * @remarks
   * The status of the task. Valid values:
   * 
   * *   **0**: The task is stopped.
   * *   **1**: The task is started.
   * *   **9**: The task is ended.
   * 
   * @example
   * 1
   */
  taskStatus?: string;
  /**
   * @remarks
   * The type of the task. Valid values:
   * 
   * 1.  3: web page performance - IE
   * 2.  34: web page performance - Chrome
   * 3.  0: network quality
   * 4.  40: file download
   * 5.  7: API performance
   * 
   * @example
   * 0
   */
  taskType?: string;
  /**
   * @remarks
   * The URL for synthetic monitoring.
   * 
   * @example
   * https://www.example.com
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      direction: 'Direction',
      order: 'Order',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      taskName: 'TaskName',
      taskStatus: 'TaskStatus',
      taskType: 'TaskType',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      direction: 'string',
      order: 'string',
      pageNum: 'number',
      pageSize: 'number',
      regionId: 'string',
      taskName: 'string',
      taskStatus: 'string',
      taskType: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticTaskListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The query results.
   */
  pageInfo?: GetSyntheticTaskListResponseBodyPageInfo;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * A5EC8221-08F2-4C95-9AF1-49FD998C****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: GetSyntheticTaskListResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticTaskListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSyntheticTaskListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSyntheticTaskListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticTaskMonitorsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the region in which the application is located.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticTaskMonitorsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned.
   * 
   * *   1001: The request was successful.
   * *   1002: The request failed.
   * *   1003: Parameter errors occurred.
   * *   1004: Authentication failed.
   * *   1006: The task does not exist.
   * *   1099: Internal errors occurred.
   * 
   * @example
   * 1001
   */
  code?: string;
  /**
   * @remarks
   * The details of the monitoring point.
   */
  data?: GetSyntheticTaskMonitorsResponseBodyData[];
  /**
   * @remarks
   * The message that is returned when the request failed.
   * 
   * @example
   * null
   */
  msg?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 21E85B16-75A6-429A-9F65-8AAC9A54****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      msg: 'Msg',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: { 'type': 'array', 'itemType': GetSyntheticTaskMonitorsResponseBodyData },
      msg: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticTaskMonitorsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSyntheticTaskMonitorsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSyntheticTaskMonitorsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTimingSyntheticTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the synthetic monitoring task.
   * 
   * @example
   * 856566a9cb2a4cafa05aa95ed0ec8f21
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTimingSyntheticTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code returned. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned struct.
   */
  data?: GetTimingSyntheticTaskResponseBodyData;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * E13430A6-57A9-56E9-9D8D-28FE8DEBCA40
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: GetTimingSyntheticTaskResponseBodyData,
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTimingSyntheticTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTimingSyntheticTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTimingSyntheticTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTraceRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. Unit: milliseconds.
   * 
   * > If the ID of the trace is 30 characters in length, this parameter is optional. Otherwise, this parameter is required.
   * 
   * @example
   * 1623827603000
   */
  endTime?: number;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Unit: milliseconds.
   * 
   * > If the ID of the trace is 30 characters in length, this parameter is optional. Otherwise, this parameter is required.
   * 
   * @example
   * 1623827602000
   */
  startTime?: number;
  /**
   * @remarks
   * The trace ID. You can log on to the ARMS console and obtain the trace ID on the **Trace Query** page or **Interface Snapshot** tab.
   * 
   * This parameter is required.
   * 
   * @example
   * ac14001a15954493811405707d****
   */
  traceID?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      regionId: 'RegionId',
      startTime: 'StartTime',
      traceID: 'TraceID',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      regionId: 'string',
      startTime: 'number',
      traceID: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTraceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6A9AEA84-7186-4D8D-B498-4585C6A2****
   */
  requestId?: string;
  /**
   * @remarks
   * The details of the trace.
   */
  spans?: GetTraceResponseBodySpans[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      spans: 'Spans',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      spans: { 'type': 'array', 'itemType': GetTraceResponseBodySpans },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTraceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTraceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTraceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTraceAppRequest extends $tea.Model {
  /**
   * @remarks
   * The process identifier (PID) of the application. For more information about how to obtain the PID, see [Obtain the PID of an application](https://www.alibabacloud.com/help/zh/doc-detail/186100.htm?spm=a2cdw.13409063.0.0.7a72281f0bkTfx#title-imy-7gj-qhr).
   * 
   * This parameter is required.
   * 
   * @example
   * b590lhguqs@d8deedfa9bf****
   */
  pid?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * 标签。
   */
  tags?: GetTraceAppRequestTags[];
  static names(): { [key: string]: string } {
    return {
      pid: 'Pid',
      regionId: 'RegionId',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pid: 'string',
      regionId: 'string',
      tags: { 'type': 'array', 'itemType': GetTraceAppRequestTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTraceAppResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * D80ADAAC-8C32-5479-BD14-C28CF832****
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the array object.
   */
  traceApp?: GetTraceAppResponseBodyTraceApp;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      traceApp: 'TraceApp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      traceApp: GetTraceAppResponseBodyTraceApp,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTraceAppResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTraceAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTraceAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTraceAppConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The process ID (PID) of the application.
   * 
   * You can use one of the following methods to obtain the PID:
   * 
   * *   API: Call the [ListTraceApps](https://help.aliyun.com/document_detail/2588008.html) operation
   * *   Console: Log on to the Application Real-Time Monitoring Service (ARMS) console. In the left-side navigation pane, choose **Application Monitoring** > **Application List**. On the Application List page, click the name of your application. The URL in the address bar contains the PID of the application. The PID is indicated in the pid=xxx format. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is xxx%4074xxx, you must replace %40 with an at sign (@) to obtain xxx@74xxx.
   * 
   * > 
   * 
   * *   To obtain the PID in the console, your application must be monitored by Application Monitoring rather than Managed Service for OpenTelemetry.
   * 
   * *   The GetTraceAppConfig operation can query only the custom settings of applications that are monitored by Application Monitoring.
   * 
   * This parameter is required.
   * 
   * @example
   * a2n80plglh@745eddxxx
   */
  pid?: string;
  static names(): { [key: string]: string } {
    return {
      pid: 'Pid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTraceAppConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * Valid values:
   * 
   * *   2xx: The request was successful.
   * *   3xx: The request was redirected.
   * *   4xx: A request error occurred.
   * *   5xx: A server error occurred.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The custom settings of the application, which is a JSON string. For more information, see **Additional description of response parameters**.
   * 
   * @example
   * {"profiler":{"enable":true}}
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 78901766-3806-4E96-8E47-CFEF59E4****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTraceAppConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTraceAppConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTraceAppConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportAppAlertRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of the alert contact groups. The value must be a JSON array.
   * 
   * @example
   * [123, 234]
   */
  contactGroupIds?: string;
  /**
   * @remarks
   * Specifies whether to enable the alert rule after it is created. Default value: `false`.
   * 
   * *   `true`: enables the alert rule.
   * *   `false`: disables the alert rule.
   * 
   * @example
   * true
   */
  isAutoStart?: boolean;
  /**
   * @remarks
   * The process identifiers (PIDs) of the applications associated with the alert rule. The value must be a JSON array. For more information about how to obtain the PID, see [Obtain the PID of an application](~~186100#section-bkl-3j6-ezg~~).
   * 
   * This parameter is required.
   * 
   * @example
   * ["atc889zkcf@d8deedfa9bfxxxx", "acd129bfcf@d5daebfa6cdxxxx"]
   */
  pids?: string;
  /**
   * @remarks
   * The ID of the region where the associated applications reside.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The list of tags.
   */
  tags?: ImportAppAlertRulesRequestTags[];
  /**
   * @remarks
   * The configurations of the alert template based on which you want to create an alert rule. The value must be a JSON string. You must set at least one of the **TemplateAlertId** and **TemplageAlertConfig** parameters. If you set both parameters, the **TemplateAlertId** parameter prevails. For more information about the TemplageAlertConfig parameter, see the following **additional information about the TemplageAlertConfig parameter**.
   * 
   * @example
   * [ { "contactGroupIds": "381", "alertType": 5, "alarmContext": { "subTitle": "", "content": "Alarm name: $alarm name\\nFilter condition: $filter\\nAlarm time : $Alarm time\\nAlarm content: $Alarm content\\nNote: Before the recovery email is received, the alarm is in continuous alarm, and you will be reminded again after 24 hours!" }, "alertLevel": "WARN", " metricParam": { "appId": "70901", "pid": "atc889zkcf@d8deedfa9bf****", "type": "TXN", "dimensions": [ { "type": "STATIC", "value ": "\\\\/hello_test_api_address\\\\/test1", "key": "rpc" } ] }, "alertWay": [ "SMS", "MAIL", "DING_ROBOT" ], "alertRule": { "rules" : [ { "measure": "appstat.txn.rt", "alias": "Entry call response time_ms", "aggregates": "AVG", "nValue": 1, "value": 1, "operator ": "CURRENT_GTE" } ], "operator": "|" }, "title": "Alarm template alarm name", "config": "{\\"continuous\\":false,\\"dataRevision\\":2, \\"ownerId\\":\\"123412341234\\"}", "notice": { "noticeStartTime": 1480521600000, "startTime": 1480521600000, "endTime": 1480607940000, "noticeEndTime": 1480607940000 }, "stat us": "NON " } ]
   */
  templageAlertConfig?: string;
  /**
   * @remarks
   * The ID of the alert template. You must set at least one of the **TemplateAlertId** and **TemplageAlertConfig** parameters. If you set both parameters, the **TemplateAlertId** parameter prevails.
   * 
   * @example
   * 324324234
   */
  templateAlertId?: string;
  static names(): { [key: string]: string } {
    return {
      contactGroupIds: 'ContactGroupIds',
      isAutoStart: 'IsAutoStart',
      pids: 'Pids',
      regionId: 'RegionId',
      tags: 'Tags',
      templageAlertConfig: 'TemplageAlertConfig',
      templateAlertId: 'TemplateAlertId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroupIds: 'string',
      isAutoStart: 'boolean',
      pids: 'string',
      regionId: 'string',
      tags: { 'type': 'array', 'itemType': ImportAppAlertRulesRequestTags },
      templageAlertConfig: 'string',
      templateAlertId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportAppAlertRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * @example
   * [12174**]
   */
  data?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * A5EC8221-08F2-4C95-9AF1-49FD998C****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportAppAlertRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ImportAppAlertRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ImportAppAlertRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InitEnvironmentRequest extends $tea.Model {
  /**
   * @remarks
   * The language. Valid values: zh and en. Default value: zh.
   * 
   * @example
   * zh
   */
  aliyunLang?: string;
  /**
   * @remarks
   * Specifies whether to create a token to improve data security.
   * 
   * @example
   * false
   */
  createAuthToken?: boolean;
  /**
   * @remarks
   * The ID of the environment instance.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxx
   */
  environmentId?: string;
  /**
   * @remarks
   * Whether agents or exporters are managed. Valid values:
   * 
   * *   none: No. By default, no managed agents or exporters are provided for ACK clusters.
   * *   agent: Agents are managed. By default, managed agents are provided for ASK clusters, ACS clusters, and ACK One clusters.
   * *   agent-exproter: Agents and exporters are managed. By default, managed agents and exporters are provided for cloud services.
   * 
   * @example
   * agent
   */
  managedType?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunLang: 'AliyunLang',
      createAuthToken: 'CreateAuthToken',
      environmentId: 'EnvironmentId',
      managedType: 'ManagedType',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunLang: 'string',
      createAuthToken: 'boolean',
      environmentId: 'string',
      managedType: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InitEnvironmentResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The result of the operation.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 4D6C358A-A58B-4F4B-94CE-F5AAF023****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InitEnvironmentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: InitEnvironmentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: InitEnvironmentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallAddonRequest extends $tea.Model {
  /**
   * @remarks
   * The version of the add-on.
   * 
   * This parameter is required.
   * 
   * @example
   * 0.0.1
   */
  addonVersion?: string;
  /**
   * @remarks
   * The language. Valid values: zh and en. Default value: zh.
   * 
   * @example
   * zh
   */
  aliyunLang?: string;
  /**
   * @remarks
   * Specifies whether to perform only a dry run, without performing the actual request. Default value: false.
   * 
   * @example
   * false
   */
  dryRun?: boolean;
  /**
   * @remarks
   * The environment ID.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The name of the add-on.
   * 
   * This parameter is required.
   * 
   * @example
   * mysql
   */
  name?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The name of the add-on after it is installed. If you do not specify this parameter, a default rule name is generated.
   * 
   * @example
   * mysql-xxxxx
   */
  releaseName?: string;
  /**
   * @remarks
   * The metadata.
   * 
   * @example
   * {"host":"mysql-service.default","port":3306,"username":"root","password":"roots"}
   */
  values?: string;
  static names(): { [key: string]: string } {
    return {
      addonVersion: 'AddonVersion',
      aliyunLang: 'AliyunLang',
      dryRun: 'DryRun',
      environmentId: 'EnvironmentId',
      name: 'Name',
      regionId: 'RegionId',
      releaseName: 'ReleaseName',
      values: 'Values',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addonVersion: 'string',
      aliyunLang: 'string',
      dryRun: 'boolean',
      environmentId: 'string',
      name: 'string',
      regionId: 'string',
      releaseName: 'string',
      values: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallAddonResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned data.
   */
  data?: InstallAddonResponseBodyData;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C21AB7CF-B7AF-410F-BD61-82D1567F****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values: true and false.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: InstallAddonResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallAddonResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: InstallAddonResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: InstallAddonResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallCmsExporterRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The cloud services that you want to monitor. The CmsArgs parameter is the startup parameter of the cms-exporter collector. Separate multiple cloud services with number signs (`#`).
   * 
   * @example
   * hologres#cen
   */
  cmsArgs?: string;
  /**
   * @remarks
   * The recently monitored cloud services. Separate multiple cloud services with number signs (`#`).
   * 
   * @example
   * hologres#cen
   */
  directArgs?: string;
  /**
   * @remarks
   * Specifies whether to collect the aliyun tags attached to each cloud service. Default value: false.
   * 
   * @example
   * false
   */
  enableTag?: boolean;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-beijing
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      cmsArgs: 'CmsArgs',
      directArgs: 'DirectArgs',
      enableTag: 'EnableTag',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      cmsArgs: 'string',
      directArgs: 'string',
      enableTag: 'boolean',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallCmsExporterResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the call was successful.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * E7A04B0D-E2CA-59BB-8A9D-D5D349C22BF1
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallCmsExporterResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: InstallCmsExporterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: InstallCmsExporterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallEnvironmentFeatureRequest extends $tea.Model {
  /**
   * @remarks
   * The language. Valid values: zh and en. Default value: zh.
   * 
   * @example
   * zh
   */
  aliyunLang?: string;
  /**
   * @remarks
   * The metadata of the feature.
   * 
   * @example
   * {\\"continuous\\":true,\\"dataRevision\\":2}
   */
  config?: string;
  /**
   * @remarks
   * The environment ID.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The name of the feature.
   * 
   * Valid values:
   * 
   * *   app-agent-pilot
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   metric-agent
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * This parameter is required.
   * 
   * @example
   * metric-agent
   */
  featureName?: string;
  /**
   * @remarks
   * The version of the feature.
   * 
   * This parameter is required.
   * 
   * @example
   * 1.1.17
   */
  featureVersion?: string;
  /**
   * @remarks
   * The region ID of the feature.
   * 
   * @example
   * cn-shenzhen
   */
  region?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunLang: 'AliyunLang',
      config: 'Config',
      environmentId: 'EnvironmentId',
      featureName: 'FeatureName',
      featureVersion: 'FeatureVersion',
      region: 'Region',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunLang: 'string',
      config: 'string',
      environmentId: 'string',
      featureName: 'string',
      featureVersion: 'string',
      region: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallEnvironmentFeatureResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The release ID.
   * 
   * @example
   * 83FCC44C-A056-18AF-A902-7043E723F0D9
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4C518054-852F-4023-ABC1-4AF95FF7****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallEnvironmentFeatureResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: InstallEnvironmentFeatureResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: InstallEnvironmentFeatureResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallManagedPrometheusRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ASK cluster.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The name of the cluster. This parameter is required if the ClusterType parameter is set to ecs.
   * 
   * @example
   * prd-ecs
   */
  clusterName?: string;
  /**
   * @remarks
   * The cluster type.
   * 
   * Valid values:
   * 
   * *   ecs: ECS
   * *   one: ACK One
   * *   ask: ASK
   * *   pro: Container Monitoring Pro
   * 
   * This parameter is required.
   * 
   * @example
   * ask
   */
  clusterType?: string;
  /**
   * @remarks
   * The ID of the managed Grafana workspace that is associated with the cluster. If you set this parameter to free or leave this parameter empty, the cluster is associated with a shared Grafana workspace.
   * 
   * @example
   * grafana-bp1*****
   */
  grafanaInstanceId?: string;
  /**
   * @remarks
   * This parameter is not supported.
   * 
   * @example
   * -
   * 
   * **if can be null:**
   * true
   */
  kubeConfig?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The ID of the security group to which the cluster belongs.
   * 
   * This parameter is required.
   * 
   * @example
   * sg-bp1********
   */
  securityGroupId?: string;
  /**
   * @remarks
   * The ID of the vSwitch that is used by the cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * vsw-bp1*********
   */
  vSwitchId?: string;
  /**
   * @remarks
   * The virtual private cloud (VPC) where the cluster resides.
   * 
   * This parameter is required.
   * 
   * @example
   * vpc-xxxxxx
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      clusterType: 'ClusterType',
      grafanaInstanceId: 'GrafanaInstanceId',
      kubeConfig: 'KubeConfig',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      securityGroupId: 'SecurityGroupId',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      clusterName: 'string',
      clusterType: 'string',
      grafanaInstanceId: 'string',
      kubeConfig: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      securityGroupId: 'string',
      vSwitchId: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallManagedPrometheusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The response content. In most cases, the installation status of the Prometheus agent is returned.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The error message returned if the Prometheus agent failed to be installed.
   * 
   * @example
   * vpcId is blank
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * String	2A0CEDF1-06FE-44AC-8E21-21A5BE65****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the Prometheus agent was installed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallManagedPrometheusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: InstallManagedPrometheusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: InstallManagedPrometheusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListActivatedAlertsRequest extends $tea.Model {
  /**
   * @remarks
   * The number of the page to return. Default value: `1`.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  currentPage?: number;
  /**
   * @remarks
   * The filter condition in the `{"key":"value"}`format. You must specify the `key` and `value` of the filter condition.
   * 
   * @example
   * {"alertname":"Container CPU usage is greater than 80%"}
   */
  filter?: string;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: `10`.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      filter: 'Filter',
      pageSize: 'PageSize',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      filter: 'string',
      pageSize: 'number',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListActivatedAlertsResponseBody extends $tea.Model {
  message?: string;
  /**
   * @remarks
   * The struct returned.
   */
  page?: ListActivatedAlertsResponseBodyPage;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * BDB74B8F-4123-482A-ABB7-7F440349****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      page: 'Page',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      page: ListActivatedAlertsResponseBodyPage,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListActivatedAlertsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListActivatedAlertsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListActivatedAlertsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAddonReleasesRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the add-on.
   * 
   * @example
   * mysql
   */
  addonName?: string;
  /**
   * @remarks
   * The environment ID.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      addonName: 'AddonName',
      environmentId: 'EnvironmentId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addonName: 'string',
      environmentId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAddonReleasesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The result of the operation.
   */
  data?: ListAddonReleasesResponseBodyData;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * E9C9DA3D-10FE-472E-9EEF-2D0A3E41****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values: true and false.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: ListAddonReleasesResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAddonReleasesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListAddonReleasesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAddonReleasesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAddonsRequest extends $tea.Model {
  /**
   * @remarks
   * Language,the default language is Chinese.
   * 
   * @example
   * zh
   */
  aliyunLang?: string;
  /**
   * @remarks
   * Category filter.
   * 
   * @example
   * database
   */
  category?: string;
  /**
   * @remarks
   * Whether to enable regular matching.
   * 
   * @example
   * false
   */
  regexp?: boolean;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * A query field can be queried by name or description.
   * 
   * @example
   * mysql
   */
  search?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunLang: 'AliyunLang',
      category: 'Category',
      regexp: 'Regexp',
      regionId: 'RegionId',
      search: 'Search',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunLang: 'string',
      category: 'string',
      regexp: 'boolean',
      regionId: 'string',
      search: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAddonsResponseBody extends $tea.Model {
  /**
   * @remarks
   * Status code: 200 indicates success.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The queried add-ons.
   */
  data?: ListAddonsResponseBodyData[];
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 78901766-3806-4E96-8E47-CFEF59E4****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the alert rule was deleted. Valid values:
   * 
   * *   `true`: The alert rule was deleted.
   * *   `false`: The alert rule failed to be deleted.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': ListAddonsResponseBodyData },
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAddonsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListAddonsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAddonsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAlertEventsRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the alert.
   * 
   * @example
   * Test-triggered alert
   */
  alertName?: string;
  /**
   * @remarks
   * The end time of the alert events that you want to query. Specify the time in the YYYY-MM-DD HH:mm:ss format.
   * 
   * @example
   * 2021-12-22 23:59:59
   */
  endTime?: string;
  /**
   * @remarks
   * The list of matching conditions.
   * 
   * @example
   * [         {           "value": "ARMS_NOTIFICATION",           "key": "clustername",           "operator": "eq"         }       ]     },{       "matchingConditions": [         {           "value": "test",           "key": "alertname",           "operator": "eq"         }       ]
   */
  matchingConditions?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * Specifies whether to show the associated notification policy.
   * 
   * @example
   * false
   */
  showNotificationPolicies?: boolean;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 20
   */
  size?: number;
  /**
   * @remarks
   * The start time of the alert events that you want to query. Specify the time in the YYYY-MM-DD HH:mm:ss format.
   * 
   * @example
   * 2021-12-19 00:00:00
   */
  startTime?: string;
  /**
   * @remarks
   * The status of the alert events. Valid values:
   * 
   * *   Active
   * *   Silenced
   * *   Resolved
   * 
   * @example
   * Active
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      alertName: 'AlertName',
      endTime: 'EndTime',
      matchingConditions: 'MatchingConditions',
      page: 'Page',
      showNotificationPolicies: 'ShowNotificationPolicies',
      size: 'Size',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertName: 'string',
      endTime: 'string',
      matchingConditions: 'string',
      page: 'number',
      showNotificationPolicies: 'boolean',
      size: 'number',
      startTime: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAlertEventsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned struct.
   */
  pageBean?: ListAlertEventsResponseBodyPageBean;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 2FC13182-B9AF-4E6B-BE51-72669B7C****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageBean: 'PageBean',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageBean: ListAlertEventsResponseBodyPageBean,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAlertEventsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListAlertEventsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAlertEventsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAlertsRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * @example
   * Test alert
   */
  alertName?: string;
  /**
   * @remarks
   * The ID of the notification policy.
   * 
   * @example
   * 12345
   */
  dispatchRuleId?: number;
  /**
   * @remarks
   * The end time of the alert sending history that you want to query. Specify the time in the `YYYY-MM-DD HH:mm:ss` format.
   * 
   * @example
   * 2021-12-22 23:59:59
   */
  endTime?: string;
  /**
   * @remarks
   * The integration type.
   * 
   * *   ARMS
   * *   CLOUD_MONITOR
   * *   MSE
   * *   ARMS_CLOUD_DIALTEST
   * *   PROMETHEUS
   * *   LOG_SERVICE
   * *   CUSTOM
   * *   ARMS_PROMETHEUS
   * *   ARMS_APP_MON
   * *   ARMS_FRONT_MON
   * *   ARMS_CUSTOM
   * *   XTRACE
   * *   GRAFANA
   * *   ZABBIX
   * *   SKYWALKING
   * *   EVENT_BRIDGE
   * *   NAGIOS
   * *   OPENFALCON
   * *   ARMS_INSIGHTS
   * 
   * @example
   * ARMS_APP_MON
   */
  integrationType?: string;
  owner?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The severity level of the alert. Valid values: P6, P5, P4, P3, P2, and P1. The preceding values are listed in ascending order of severity.
   * 
   * @example
   * P6
   */
  severity?: string;
  /**
   * @remarks
   * Specifies whether to query the activities that correspond to alerts. Valid values:
   * 
   * *   `false` (default value): The activities are not queried.
   * *   `true`: The activities in the last three days are queried.
   * 
   * @example
   * true
   */
  showActivities?: boolean;
  /**
   * @remarks
   * Specifies whether to query the events that correspond to alerts. Valid values:
   * 
   * *   `false` (default value): The events are not queried.
   * *   `true`: The events are queried.
   * 
   * @example
   * true
   */
  showEvents?: boolean;
  /**
   * @remarks
   * The number of alerts to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 20
   */
  size?: number;
  /**
   * @remarks
   * The start time of the alert sending history that you want to query. Specify the time in the `YYYY-MM-DD HH:mm:ss` format.
   * 
   * @example
   * 2021-12-10 00:00:00
   */
  startTime?: string;
  /**
   * @remarks
   * The status of the alert. Valid values:
   * 
   * *   0: The alert is pending.
   * *   1: The alert is being handled.
   * *   2: The alert is handled.
   * 
   * @example
   * 2
   */
  state?: number;
  static names(): { [key: string]: string } {
    return {
      alertName: 'AlertName',
      dispatchRuleId: 'DispatchRuleId',
      endTime: 'EndTime',
      integrationType: 'IntegrationType',
      owner: 'Owner',
      page: 'Page',
      regionId: 'RegionId',
      severity: 'Severity',
      showActivities: 'ShowActivities',
      showEvents: 'ShowEvents',
      size: 'Size',
      startTime: 'StartTime',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertName: 'string',
      dispatchRuleId: 'number',
      endTime: 'string',
      integrationType: 'string',
      owner: 'string',
      page: 'number',
      regionId: 'string',
      severity: 'string',
      showActivities: 'boolean',
      showEvents: 'boolean',
      size: 'number',
      startTime: 'string',
      state: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAlertsResponseBody extends $tea.Model {
  message?: string;
  /**
   * @remarks
   * The information about the array object.
   */
  pageBean?: ListAlertsResponseBodyPageBean;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2FC13182-B9AF-4E6B-BE51-72669B7C****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      pageBean: 'PageBean',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      pageBean: ListAlertsResponseBodyPageBean,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAlertsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListAlertsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAlertsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterFromGrafanaRequest extends $tea.Model {
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterFromGrafanaResponseBody extends $tea.Model {
  /**
   * @remarks
   * The cluster information.
   */
  promClusterList?: ListClusterFromGrafanaResponseBodyPromClusterList[];
  /**
   * @remarks
   * The request ID. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * 6849D41E-EED4-5C00-89F9-6047BBD9DCB4
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      promClusterList: 'PromClusterList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      promClusterList: { 'type': 'array', 'itemType': ListClusterFromGrafanaResponseBodyPromClusterList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterFromGrafanaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListClusterFromGrafanaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListClusterFromGrafanaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCmsInstancesRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * n9p9o9o3se
   */
  clusterId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @example
   * direct
   */
  typeFilter?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
      typeFilter: 'TypeFilter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
      typeFilter: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCmsInstancesResponseBody extends $tea.Model {
  data?: ListCmsInstancesResponseBodyData;
  /**
   * @example
   * E7A04B0D-E2CA-59BB-8A9D-D5D349C22BF1
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListCmsInstancesResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCmsInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListCmsInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCmsInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDashboardsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ACK cluster.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * Valid values: ACK, ASK, cloud-product-prometheus, and Node. You can query the dashboards of a virtual cluster by specifying the cluster type. For InfluxDB, set this parameter to `cloud-product-prometheus`.
   * 
   * @example
   * Node
   */
  clusterType?: string;
  /**
   * @remarks
   * The unique names of the dashboards. You can query dashboards by specifying their names. The **dashboard title** can be changed whereas the **dashboard name** cannot. You can specify multiple names and separate them with commas (,), for example, `k8s-event,k8s-overview`. A dashboard may have multiple versions. If you want to specify a version, you can add version information after the name, for example, `k8s-event:v1,k8s-overview:latest`.
   * 
   * @example
   * k8s-node-overview
   */
  dashboardName?: string;
  /**
   * @remarks
   * The language of the returned Grafana dashboard. Valid values: en and zh. Default value: en.
   * 
   * @example
   * en
   */
  language?: string;
  /**
   * @remarks
   * The cloud service code. This parameter is required if you set the ClusterType parameter to `cloud-product-prometheus`. The following cloud services are available: Serverless App Engine, Microservices Engine, Message Queue for Apache RocketMQ, Lindorm, Message Queue for Apache Kafka, ApsaraDB for ClickHouse, Data Lake Analytics, Message Queue for RabbitMQ, ApsaraDB for MongoDB, Time Series Database (TSDB) for InfluxDB, MSE Cloud-native Gateway, Grafana Service, SchedulerX, Global Transaction Service, Enterprise Distributed Application Service, Machine Learning Platform for AI - Elastic Algorithm Service (EAS), Application High Availability Service, and Performance Testing.
   * 
   * @example
   * xxxx
   */
  product?: string;
  /**
   * @remarks
   * Specifies whether to create or query a virtual cluster. This parameter provides backward compatibility.
   * 
   * @example
   * false
   */
  recreateSwitch?: boolean;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The dashboard title. The dashboard title can be changed. We recommend that you specify the **DashboardName** parameter.
   * 
   * @example
   * ApiServer
   */
  title?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      clusterType: 'ClusterType',
      dashboardName: 'DashboardName',
      language: 'Language',
      product: 'Product',
      recreateSwitch: 'RecreateSwitch',
      regionId: 'RegionId',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      clusterType: 'string',
      dashboardName: 'string',
      language: 'string',
      product: 'string',
      recreateSwitch: 'boolean',
      regionId: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDashboardsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the Grafana dashboard.
   */
  dashboardVos?: ListDashboardsResponseBodyDashboardVos[];
  /**
   * @remarks
   * The ID of the environment instance.
   * 
   * @example
   * env-ebd54733482581fc8c4237******
   */
  environmentId?: string;
  /**
   * @remarks
   * Indicates whether Managed Service for Grafana is activated.
   * 
   * @example
   * true
   */
  grafanaServiceOpened?: string;
  /**
   * @remarks
   * Whether or not to turn on Prometheus service.
   * 
   * @example
   * true
   */
  prometheusServiceOpened?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2A0CEDF1-06FE-44AC-8E21-21A5BE65****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      dashboardVos: 'DashboardVos',
      environmentId: 'EnvironmentId',
      grafanaServiceOpened: 'GrafanaServiceOpened',
      prometheusServiceOpened: 'PrometheusServiceOpened',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dashboardVos: { 'type': 'array', 'itemType': ListDashboardsResponseBodyDashboardVos },
      environmentId: 'string',
      grafanaServiceOpened: 'string',
      prometheusServiceOpened: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDashboardsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDashboardsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDashboardsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDashboardsByNameRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the cluster. If the ClusterType parameter is not set to `cloud-product-prometheus` or `cms-enterprise-prometheus`, you must specify the ClusterId parameter.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The cluster type. Valid values:
   * 
   * *   vpc-prometheus
   * *   cloud-product-prometheus
   * *   cms-enterprise-prometheus
   * *   ExternalKubernetes
   * *   Ask
   * *   Kubernetes
   * *   ManagedKubernetes
   * *   remote-write-prometheus
   * *   GlobalViewV2
   * 
   * @example
   * cloud-product-prometheus
   */
  clusterType?: string;
  /**
   * @remarks
   * The name of the dashboard.
   * 
   * @example
   * edas-ingress-url
   */
  dashBoardName?: string;
  /**
   * @remarks
   * The version of the dashboard.
   * 
   * @example
   * latest
   */
  dashBoardVersion?: string;
  /**
   * @remarks
   * The type of the data source. Valid values:
   * 
   * *   loki
   * *   prometheus
   * 
   * @example
   * loki
   */
  dataSourceType?: string;
  /**
   * @remarks
   * The name of the dashboard group.
   * 
   * @example
   * EDAS
   */
  groupName?: string;
  /**
   * @remarks
   * Specifies whether to display the Grafana dashboard only in the Application Real-Time Monitoring Service (ARMS) console.
   * 
   * @example
   * true
   */
  onlyQuery?: boolean;
  /**
   * @remarks
   * The abbreviation of the Alibaba Cloud service name.
   * 
   * @example
   * edas
   */
  productCode?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      clusterType: 'ClusterType',
      dashBoardName: 'DashBoardName',
      dashBoardVersion: 'DashBoardVersion',
      dataSourceType: 'DataSourceType',
      groupName: 'GroupName',
      onlyQuery: 'OnlyQuery',
      productCode: 'ProductCode',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      clusterType: 'string',
      dashBoardName: 'string',
      dashBoardVersion: 'string',
      dataSourceType: 'string',
      groupName: 'string',
      onlyQuery: 'boolean',
      productCode: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDashboardsByNameResponseBody extends $tea.Model {
  /**
   * @remarks
   * Status Code. Description 200 indicates success.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned struct.
   * 
   * @example
   * [{"name":"Edas Ingress Url Analysis","type":"edas-ingress-url-analysis","url":"https://g.console.aliyun.com/d/1036052989950239-11040375-66-3/edas-ingress-url-analysis?var-clusterId=29ksa&var-regionId=cn-hangzhou"}]
   */
  data?: string;
  /**
   * @remarks
   * Returns a hint message for the result.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request, You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * 2983BEF7-4A0D-47A2-94A2-8E9C5E63****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDashboardsByNameResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDashboardsByNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDashboardsByNameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDispatchRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the notification policy. Fuzzy match is supported.
   * 
   * @example
   * Prod
   */
  name?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * *   The type of notification policies to be queried. Valid values: `false` (default): notification policies created in Application Real-Time Monitoring Service (ARMS).
   * *   `true`: notification policies created in an external system.
   * 
   * >  You cannot use the ARMS console to modify the dispatch rules of a notification policy that is created in an external system.
   * 
   * @example
   * true
   */
  system?: boolean;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      regionId: 'RegionId',
      system: 'System',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      regionId: 'string',
      system: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDispatchRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned struct.
   */
  dispatchRules?: ListDispatchRuleResponseBodyDispatchRules[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 34ED024E-9E31-434A-9E4E-D9D15C3****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      dispatchRules: 'DispatchRules',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dispatchRules: { 'type': 'array', 'itemType': ListDispatchRuleResponseBodyDispatchRules },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDispatchRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDispatchRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDispatchRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvCustomJobsRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to return the encrypted YAML string.
   * 
   * @example
   * true
   */
  encryptYaml?: boolean;
  /**
   * @remarks
   * The ID of the environment instance.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      encryptYaml: 'EncryptYaml',
      environmentId: 'EnvironmentId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      encryptYaml: 'boolean',
      environmentId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvCustomJobsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned struct.
   */
  data?: ListEnvCustomJobsResponseBodyData[];
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2A0CEDF1-06FE-44AC-8E21-21A5BE65****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': ListEnvCustomJobsResponseBodyData },
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvCustomJobsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEnvCustomJobsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEnvCustomJobsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvPodMonitorsRequest extends $tea.Model {
  /**
   * @remarks
   * The environment ID.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      environmentId: 'EnvironmentId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      environmentId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvPodMonitorsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The result of the operation.
   */
  data?: ListEnvPodMonitorsResponseBodyData[];
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 4C518054-852F-4023-ABC1-4AF95FF7****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': ListEnvPodMonitorsResponseBodyData },
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvPodMonitorsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEnvPodMonitorsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEnvPodMonitorsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvServiceMonitorsRequest extends $tea.Model {
  /**
   * @remarks
   * The environment ID.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      environmentId: 'EnvironmentId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      environmentId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvServiceMonitorsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned struct.
   */
  data?: ListEnvServiceMonitorsResponseBodyData[];
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1A474FF8-7861-4D00-81B5-5BC3DA4E****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': ListEnvServiceMonitorsResponseBodyData },
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvServiceMonitorsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEnvServiceMonitorsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEnvServiceMonitorsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvironmentDashboardsRequest extends $tea.Model {
  /**
   * @remarks
   * Name of Addon,One of AddonName and Scene must be filled in.
   * 
   * @example
   * trace-java
   */
  addonName?: string;
  /**
   * @remarks
   * The ID of the environment instance.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The region ID of the instance.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The scenario of Addon. Either AddonName or Scene is required.
   * 
   * @example
   * database
   */
  scene?: string;
  static names(): { [key: string]: string } {
    return {
      addonName: 'AddonName',
      environmentId: 'EnvironmentId',
      regionId: 'RegionId',
      scene: 'Scene',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addonName: 'string',
      environmentId: 'string',
      regionId: 'string',
      scene: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvironmentDashboardsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The result of the operation.
   */
  data?: ListEnvironmentDashboardsResponseBodyData;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * A5EC8221-08F2-4C95-9AF1-49FD998C647A
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: ListEnvironmentDashboardsResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvironmentDashboardsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEnvironmentDashboardsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEnvironmentDashboardsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvironmentFeaturesRequest extends $tea.Model {
  /**
   * @remarks
   * The language. Default value: zh.
   * 
   * Valid values:
   * 
   * *   en: English.
   * *   zh: Chinese.
   * 
   * @example
   * en
   */
  aliyunLang?: string;
  /**
   * @remarks
   * The environment ID.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunLang: 'AliyunLang',
      environmentId: 'EnvironmentId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunLang: 'string',
      environmentId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvironmentFeaturesResponseBody extends $tea.Model {
  /**
   * @remarks
   * Status Code. Description 200 indicates success.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned struct.
   */
  data?: ListEnvironmentFeaturesResponseBodyData[];
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 40B10E04-81E8-4643-970D-F1B38F2E****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the alert rule was deleted. Valid values:
   * 
   * *   `true`: The alert rule was deleted.
   * *   `false`: The alert rule failed to be deleted.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': ListEnvironmentFeaturesResponseBodyData },
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvironmentFeaturesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEnvironmentFeaturesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEnvironmentFeaturesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvironmentsRequest extends $tea.Model {
  /**
   * @remarks
   * The add-on name. You must specify at least one of the AddonName and EnvironmentType parameters.
   * 
   * @example
   * trace-java
   */
  addonName?: string;
  /**
   * @remarks
   * The ID of the resource.
   * 
   * @example
   * cff30f0d67d7542dfb05bd114b4b1d7af
   */
  bindResourceId?: string;
  /**
   * @remarks
   * The environment type. You must specify at least one of the AddonName and EnvironmentType parameters.
   * 
   * Valid values:
   * 
   * *   CS
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     Container Service for Kubernetes (ACK)
   * 
   *     <!-- -->
   * 
   * *   ECS
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     Elastic Compute Service (ECS)
   * 
   *     <!-- -->
   * 
   * *   Cloud
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     cloud service
   * 
   *     <!-- -->
   * 
   * @example
   * CS
   */
  environmentType?: string;
  /**
   * @remarks
   * The payable resource plan.
   * 
   * *   If the EnvironmentType parameter is set to CS, set the value to CS_Basic or CS_Pro. Default value: CS_Basic.
   * *   Otherwise, leave the parameter empty.
   * 
   * Valid values:
   * 
   * *   CS_Pro: Container Monitoring Pro
   * *   CS_Basic: Container Monitoring Basic
   * 
   * @example
   * CS_Pro
   */
  feePackage?: string;
  /**
   * @remarks
   * The region IDs.
   */
  filterRegionIds?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-aekzfurdatohtka
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The tags.
   */
  tag?: ListEnvironmentsRequestTag[];
  static names(): { [key: string]: string } {
    return {
      addonName: 'AddonName',
      bindResourceId: 'BindResourceId',
      environmentType: 'EnvironmentType',
      feePackage: 'FeePackage',
      filterRegionIds: 'FilterRegionIds',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addonName: 'string',
      bindResourceId: 'string',
      environmentType: 'string',
      feePackage: 'string',
      filterRegionIds: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      tag: { 'type': 'array', 'itemType': ListEnvironmentsRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvironmentsShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The add-on name. You must specify at least one of the AddonName and EnvironmentType parameters.
   * 
   * @example
   * trace-java
   */
  addonName?: string;
  /**
   * @remarks
   * The ID of the resource.
   * 
   * @example
   * cff30f0d67d7542dfb05bd114b4b1d7af
   */
  bindResourceId?: string;
  /**
   * @remarks
   * The environment type. You must specify at least one of the AddonName and EnvironmentType parameters.
   * 
   * Valid values:
   * 
   * *   CS
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     Container Service for Kubernetes (ACK)
   * 
   *     <!-- -->
   * 
   * *   ECS
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     Elastic Compute Service (ECS)
   * 
   *     <!-- -->
   * 
   * *   Cloud
   * 
   *     <!-- -->
   * 
   *     :
   * 
   *     <!-- -->
   * 
   *     cloud service
   * 
   *     <!-- -->
   * 
   * @example
   * CS
   */
  environmentType?: string;
  /**
   * @remarks
   * The payable resource plan.
   * 
   * *   If the EnvironmentType parameter is set to CS, set the value to CS_Basic or CS_Pro. Default value: CS_Basic.
   * *   Otherwise, leave the parameter empty.
   * 
   * Valid values:
   * 
   * *   CS_Pro: Container Monitoring Pro
   * *   CS_Basic: Container Monitoring Basic
   * 
   * @example
   * CS_Pro
   */
  feePackage?: string;
  /**
   * @remarks
   * The region IDs.
   */
  filterRegionIds?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-aekzfurdatohtka
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The tags.
   */
  tagShrink?: string;
  static names(): { [key: string]: string } {
    return {
      addonName: 'AddonName',
      bindResourceId: 'BindResourceId',
      environmentType: 'EnvironmentType',
      feePackage: 'FeePackage',
      filterRegionIds: 'FilterRegionIds',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      tagShrink: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addonName: 'string',
      bindResourceId: 'string',
      environmentType: 'string',
      feePackage: 'string',
      filterRegionIds: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      tagShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvironmentsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned struct.
   */
  data?: ListEnvironmentsResponseBodyData;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1A9C645C-C83F-4C9D-8CCB-29BEC9E1****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values: true and false.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: ListEnvironmentsResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvironmentsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEnvironmentsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEnvironmentsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEscalationPoliciesRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the escalation policy.
   * 
   * @example
   * prod escalation policy
   */
  name?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 20
   */
  size?: number;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      page: 'Page',
      size: 'Size',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      page: 'number',
      size: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEscalationPoliciesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned objects.
   */
  pageBean?: ListEscalationPoliciesResponseBodyPageBean;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 78901766-3806-4E96-8E47-CFEF59E4****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageBean: 'PageBean',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageBean: ListEscalationPoliciesResponseBodyPageBean,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEscalationPoliciesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEscalationPoliciesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEscalationPoliciesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventBridgeIntegrationsRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the EventBridge integration.
   * 
   * @example
   * EventBridge_Test
   */
  name?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 15
   */
  size?: number;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      page: 'Page',
      size: 'Size',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      page: 'number',
      size: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventBridgeIntegrationsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about EventBridge integrations that is returned on each page.
   */
  pageBean?: ListEventBridgeIntegrationsResponseBodyPageBean;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 2B289756-E791-5842-BCBD-AD414C******
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageBean: 'PageBean',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageBean: ListEventBridgeIntegrationsResponseBodyPageBean,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventBridgeIntegrationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEventBridgeIntegrationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEventBridgeIntegrationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGrafanaWorkspaceRequest extends $tea.Model {
  /**
   * @remarks
   * The language. Valid values: zh and en. Default value: zh.
   * 
   * @example
   * zh
   */
  aliyunLang?: string;
  /**
   * @remarks
   * The region ID. Default value: cn-hangzhou.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group to which the Prometheus instance belongs.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The tags.
   */
  tags?: ListGrafanaWorkspaceRequestTags[];
  static names(): { [key: string]: string } {
    return {
      aliyunLang: 'AliyunLang',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunLang: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      tags: { 'type': 'array', 'itemType': ListGrafanaWorkspaceRequestTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGrafanaWorkspaceShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The language. Valid values: zh and en. Default value: zh.
   * 
   * @example
   * zh
   */
  aliyunLang?: string;
  /**
   * @remarks
   * The region ID. Default value: cn-hangzhou.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group to which the Prometheus instance belongs.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The tags.
   */
  tagsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunLang: 'AliyunLang',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      tagsShrink: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunLang: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      tagsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGrafanaWorkspaceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned result.
   */
  data?: GrafanaWorkspace[];
  /**
   * @remarks
   * The error message returned if the request parameters are invalid.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0080BE65-167F-5CB6-A691-14E2EFD474BC
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values: true and false.
   * 
   * @example
   * True
   */
  success?: boolean;
  /**
   * @remarks
   * The trace ID that is used to query the details of the request.
   * 
   * @example
   * eac0a8048716731735000007137d000b
   */
  traceId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      traceId: 'TraceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': GrafanaWorkspace },
      message: 'string',
      requestId: 'string',
      success: 'boolean',
      traceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGrafanaWorkspaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListGrafanaWorkspaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListGrafanaWorkspaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInsightsEventsRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. The value is a timestamp.
   * 
   * This parameter is required.
   * 
   * @example
   * 1480607940000
   */
  endTime?: string;
  /**
   * @remarks
   * The types of the events that you want to query. Separate multiple event types with commas (,). If you do not specify this parameter, all events are queried.
   * 
   * *   errorIncrease: API error-rate spike events. Examples: HTTP API error-rate spike events and Dubbo API error-rate spike events.
   * *   topErrorIncrease: the top five API error-rate spike events with the highest traffic.
   * *   topRtIncrease: API response-time spike events. Examples: HTTP API response-time spike events and Dubbo API response-time spike events.
   * *   rtIncrease: the top five API response-time spike events with the highest traffic.
   * 
   * @example
   * errorIncrease,topErrorIncrease,topExceptionIncrease,topRtIncrease,rtIncrease
   */
  insightsTypes?: string;
  /**
   * @remarks
   * The ID of the application.
   * 
   * @example
   * aokcdqn3ly@a195c6d6421****
   */
  pid?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The start of the time range to query. The value is a timestamp.
   * 
   * This parameter is required.
   * 
   * @example
   * 1595174400000
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      insightsTypes: 'InsightsTypes',
      pid: 'Pid',
      regionId: 'RegionId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      insightsTypes: 'string',
      pid: 'string',
      regionId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInsightsEventsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the event.
   */
  insightsEvents?: ListInsightsEventsResponseBodyInsightsEvents[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6F1174DC-6085-5353-AAE7-D4ADCD******
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      insightsEvents: 'InsightsEvents',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      insightsEvents: { 'type': 'array', 'itemType': ListInsightsEventsResponseBodyInsightsEvents },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInsightsEventsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListInsightsEventsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListInsightsEventsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListIntegrationRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the alert integration.
   * 
   * @example
   * CloudMonitor integration
   */
  integrationName?: string;
  /**
   * @remarks
   * The type of the alert integration. Valid values:
   * 
   * *   CLOUD_MONITOR: CloudMonitor
   * *   LOG_SERVICE: Log Service
   * 
   * This parameter is required.
   * 
   * @example
   * CLOUD_MONITOR
   */
  integrationProductType?: string;
  /**
   * @remarks
   * Specifies whether to display the details of each alert integration:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  isDetail?: boolean;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of alert integrations to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  size?: number;
  static names(): { [key: string]: string } {
    return {
      integrationName: 'IntegrationName',
      integrationProductType: 'IntegrationProductType',
      isDetail: 'IsDetail',
      page: 'Page',
      size: 'Size',
    };
  }

  static types(): { [key: string]: any } {
    return {
      integrationName: 'string',
      integrationProductType: 'string',
      isDetail: 'boolean',
      page: 'number',
      size: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListIntegrationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The pagination information.
   */
  pageInfo?: ListIntegrationResponseBodyPageInfo;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 34ED024E-9E31-434A-9E4E-D9D15C3****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: ListIntegrationResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListIntegrationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListIntegrationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListIntegrationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNotificationPoliciesRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to enable simple mode.
   * 
   * @example
   * true
   */
  directedMode?: boolean;
  /**
   * @remarks
   * The ID of the notification policy.
   * 
   * @example
   * 12345
   */
  ids?: string;
  /**
   * @remarks
   * Specifies whether to query the details about notification policies. Valid values:
   * 
   * *   `true`: Details about notification policies are queried.
   * *   `false`: Details about notification policies are not queried.
   * 
   * @example
   * false
   */
  isDetail?: boolean;
  /**
   * @remarks
   * The name of the notification policy.
   * 
   * @example
   * notificationpolicy_test
   */
  name?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The ID of the region. Default value: **cn-hangzhou**.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 20
   */
  size?: number;
  static names(): { [key: string]: string } {
    return {
      directedMode: 'DirectedMode',
      ids: 'Ids',
      isDetail: 'IsDetail',
      name: 'Name',
      page: 'Page',
      regionId: 'RegionId',
      size: 'Size',
    };
  }

  static types(): { [key: string]: any } {
    return {
      directedMode: 'boolean',
      ids: 'string',
      isDetail: 'boolean',
      name: 'string',
      page: 'number',
      regionId: 'string',
      size: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNotificationPoliciesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned pages.
   */
  pageBean?: ListNotificationPoliciesResponseBodyPageBean;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 78901766-3806-4E96-8E47-CFEF59E4****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageBean: 'PageBean',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageBean: ListNotificationPoliciesResponseBodyPageBean,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNotificationPoliciesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListNotificationPoliciesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListNotificationPoliciesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOnCallSchedulesRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the scheduling policy.
   * 
   * @example
   * OnCallSchedule_test
   */
  name?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 20
   */
  size?: number;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      page: 'Page',
      size: 'Size',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      page: 'number',
      size: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOnCallSchedulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The objects that were returned.
   */
  pageBean?: ListOnCallSchedulesResponseBodyPageBean;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 78901766-3806-4E96-8E47-CFEF59E4****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageBean: 'PageBean',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageBean: ListOnCallSchedulesResponseBodyPageBean,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOnCallSchedulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListOnCallSchedulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListOnCallSchedulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusAlertRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * c0bad479465464e1d8c1e641b0afb****
   */
  clusterId?: string;
  /**
   * @remarks
   * The tag match conditions that are described in a JSON string. For more information about this parameter, see the **Additional description of the MatchExpressions parameter** section.
   * 
   * @example
   * [{"key":"severity","value":"critical","operator":"re"}]
   */
  matchExpressions?: string;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * @example
   * Prometheus_Alert
   */
  name?: string;
  /**
   * @remarks
   * The region ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * Specifies whether the alert rule is enabled. Valid values:
   * 
   * - 1: enables the alert rule.
   * - 0: disables the alert rule.
   * 
   * @example
   * 1
   */
  status?: number;
  /**
   * @remarks
   * The tags.
   */
  tags?: ListPrometheusAlertRulesRequestTags[];
  /**
   * @remarks
   * The type of the alert rule.
   * 
   * @example
   * Custom
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      matchExpressions: 'MatchExpressions',
      name: 'Name',
      regionId: 'RegionId',
      status: 'Status',
      tags: 'Tags',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      matchExpressions: 'string',
      name: 'string',
      regionId: 'string',
      status: 'number',
      tags: { 'type': 'array', 'itemType': ListPrometheusAlertRulesRequestTags },
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusAlertRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The returned struct.
   */
  prometheusAlertRules?: ListPrometheusAlertRulesResponseBodyPrometheusAlertRules[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9FEA6D00-317F-45E3-9004-7FB8B0B7****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * True
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      prometheusAlertRules: 'PrometheusAlertRules',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      prometheusAlertRules: { 'type': 'array', 'itemType': ListPrometheusAlertRulesResponseBodyPrometheusAlertRules },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusAlertRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListPrometheusAlertRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPrometheusAlertRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusAlertTemplatesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * @example
   * c0bad479465464e1d8c1e641b0afb****
   */
  clusterId?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusAlertTemplatesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned struct.
   */
  prometheusAlertTemplates?: ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9FEA6D00-317F-45E3-9004-7FB8B0B7****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      prometheusAlertTemplates: 'PrometheusAlertTemplates',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      prometheusAlertTemplates: { 'type': 'array', 'itemType': ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusAlertTemplatesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListPrometheusAlertTemplatesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPrometheusAlertTemplatesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusGlobalViewRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusGlobalViewResponseBody extends $tea.Model {
  /**
   * @remarks
   * Status code. Description 200 means success.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The list of global aggregation instances. The value of this parameter is a string in the JSON format.
   * 
   * @example
   * [ {groupName: "the name of the global aggregation instance", clusterId: "global-v2-clusterid", endpoint: "cn-hangzhou"}, // ..... more items ]
   */
  data?: string;
  /**
   * @remarks
   * More information.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * DBDCE95A-A0DD-5FC5-97CC-EEFC3D814385
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusGlobalViewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListPrometheusGlobalViewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPrometheusGlobalViewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusInstanceByTagAndResourceGroupIdRequest extends $tea.Model {
  /**
   * @remarks
   * The region ID of the Prometheus instance.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The tags.
   */
  tag?: ListPrometheusInstanceByTagAndResourceGroupIdRequestTag[];
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      resourceGroupId: 'string',
      tag: { 'type': 'array', 'itemType': ListPrometheusInstanceByTagAndResourceGroupIdRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusInstanceByTagAndResourceGroupIdResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The returned struct.
   */
  data?: ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyData;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 4789C3E9-A85A-524B-B97B-9D2B14BA06BC
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyData,
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusInstanceByTagAndResourceGroupIdResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListPrometheusInstanceByTagAndResourceGroupIdResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPrometheusInstanceByTagAndResourceGroupIdResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusInstancesRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster type. If you do not specify this parameter, all cluster types are queried. Valid values:
   * 
   * *   cloud-product-prometheus: Prometheus instance for cloud services
   * *   ManagedKubernetes: ACK managed cluster
   * *   satellite: Prometheus instance for ARMS OpenTelemetry
   * *   Ask: ACK Serverless cluster
   * *   remote-write-prometheus: general-purpose Prometheus instance
   * *   cloud-monitor-cmee: Hybrid Cloud Monitoring
   * *   ExternalKubernetes: external Kubernetes cluster registered in ACK
   * *   vpc-prometheus: Prometheus instance for ECS
   * *   cloud-monitor-direct: cloud service self-monitoring
   * *   Edge Kubernetes: ACK Edge cluster
   * 
   * @example
   * cloud-product-prometheus
   */
  clusterType?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * Specifies whether to obtain global aggregation instances. Valid values:
   * 
   * *   true
   * *   false
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  showGlobalView?: boolean;
  static names(): { [key: string]: string } {
    return {
      clusterType: 'ClusterType',
      regionId: 'RegionId',
      showGlobalView: 'ShowGlobalView',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterType: 'string',
      regionId: 'string',
      showGlobalView: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusInstancesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The Prometheus instances in the region in the JSON format.
   * 
   * @example
   * [{"agentStatus":"0","clusterId":"global-v2-cn-1672753017899-dmjnwtzz","clusterName":"test-GlobalView","clusterType":"GlobalViewV2","commercialConfig":{},"createTime":1656579981000,"id":13785300,"isAdvancedClusterInstalled":false,"isClusterRunning":true,"isControllerInstalled":true,"isIntegrationCenter":false,"regionId":"cn-hongkong","updateTime":1657616273000,"userId":"1672753017899"},{"agentStatus":"0","clusterId":"51a123a61a8f31f0","clusterName":"cloud-product-prometheus_cn-qingdao","clusterType":"cloud-product-prometheus","commercialConfig":{},"controllerId":"51a123a61a8f31f0","createTime":1653532488000,"id":13746658,"isAdvancedClusterInstalled":false,"isClusterRunning":true,"isControllerInstalled":true,"isIntegrationCenter":false,"regionId":"cn-qingdao","updateTime":1653532518000,"userId":"1672753017899"}]
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * E9C9DA3D-10FE-472E-9EEF-2D0A3E41****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListPrometheusInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPrometheusInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusIntegrationRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the Prometheus instance. Only aliyun-cs and ecs instances are supported.
   * 
   * This parameter is required.
   * 
   * @example
   * c77f6f2397ea74672872acf5e31374a27
   */
  clusterId?: string;
  /**
   * @remarks
   * The integration type. Valid values: kafka, mysql, redis, snmp, emr, nubela, and tidb.
   * 
   * This parameter is required.
   * 
   * @example
   * kafka, mysql, redis, snmp, emr, nubela, and tidb
   */
  integrationType?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      integrationType: 'IntegrationType',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      integrationType: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusIntegrationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The queried exporters.
   */
  data?: ListPrometheusIntegrationResponseBodyData[];
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1F1D8840-5330-5804-A8DB-C3C5C5CED6BB
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': ListPrometheusIntegrationResponseBodyData },
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusIntegrationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListPrometheusIntegrationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPrometheusIntegrationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusMonitoringRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the Prometheus instance.
   * 
   * This parameter is required.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The region ID. Default value: `cn-hangzhou`.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The type of the monitoring configuration. Valid values for a Prometheus instance for Container Service: ServiceMonitor, PodMonitor, CustomJob, and Probe. Valid values for a Prometheus instance for ECS: CustomJob and Probe.
   * 
   * @example
   * serviceMonitor
   * 
   * **if can be null:**
   * true
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusMonitoringResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned struct.
   */
  data?: ListPrometheusMonitoringResponseBodyData[];
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * D80ADAAC-8C32-5479-BD14-C28CF832****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'array', 'itemType': ListPrometheusMonitoringResponseBodyData },
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusMonitoringResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListPrometheusMonitoringResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPrometheusMonitoringResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRetcodeAppsRequest extends $tea.Model {
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group. You can obtain the resource group ID in the **Resource Management** console.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The tags that you want to add to the task.
   */
  tags?: ListRetcodeAppsRequestTags[];
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      resourceGroupId: 'string',
      tags: { 'type': 'array', 'itemType': ListRetcodeAppsRequestTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRetcodeAppsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 99A663CB-8D7B-4B0D-A006-03C8EE38E7BB
   */
  requestId?: string;
  /**
   * @remarks
   * The list of applications monitored by Browser Monitoring.
   */
  retcodeApps?: ListRetcodeAppsResponseBodyRetcodeApps[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      retcodeApps: 'RetcodeApps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      retcodeApps: { 'type': 'array', 'itemType': ListRetcodeAppsResponseBodyRetcodeApps },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRetcodeAppsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRetcodeAppsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRetcodeAppsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScenarioRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the application.
   * 
   * This parameter is required.
   * 
   * @example
   * b590lhguqs@28f515462******
   */
  appId?: string;
  /**
   * @remarks
   * The name of the business monitoring job.
   * 
   * This parameter is required.
   * 
   * @example
   * pro-content
   */
  name?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-zhangjaikou
   */
  regionId?: string;
  /**
   * @remarks
   * The scenario where the business monitoring job is used. Valid values:
   * 
   * *   `USER-DEFINED`: user-defined. This is the default value.
   * *   `EDAS-ROLLOUT`: application release in Enterprise Distributed Application Service (EDAS)
   * *   `OAM-ROLLOUT`: application release based on Open Application Model (OAM)
   * *   `MSC-CANARY`: canary release based on Microservice Engine (MSE)
   * 
   * @example
   * USER-DEFINED
   */
  scenario?: string;
  /**
   * @remarks
   * The code of the business monitoring job. Set this parameter when you know the code of the business monitoring job you want to query.
   * 
   * @example
   * a9f8****
   */
  sign?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      name: 'Name',
      regionId: 'RegionId',
      scenario: 'Scenario',
      sign: 'Sign',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      name: 'string',
      regionId: 'string',
      scenario: 'string',
      sign: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScenarioResponseBody extends $tea.Model {
  /**
   * @remarks
   * The detailed information of the business monitoring job.
   */
  armsScenarios?: ListScenarioResponseBodyArmsScenarios[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 98027D1F-3AEB-492C-A4AA-E9217992****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      armsScenarios: 'ArmsScenarios',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      armsScenarios: { 'type': 'array', 'itemType': ListScenarioResponseBodyArmsScenarios },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScenarioResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListScenarioResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListScenarioResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSilencePoliciesRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to query the details of a silence policy. Valid values:
   * 
   * *   `true`: Details of the silence policy are queried.
   * *   `false`: Details about notification policies are not queried.
   * 
   * @example
   * true
   */
  isDetail?: boolean;
  /**
   * @remarks
   * The name of the silence policy.
   * 
   * @example
   * silencepolicy_test
   */
  name?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 20
   */
  size?: number;
  static names(): { [key: string]: string } {
    return {
      isDetail: 'IsDetail',
      name: 'Name',
      page: 'Page',
      regionId: 'RegionId',
      size: 'Size',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isDetail: 'boolean',
      name: 'string',
      page: 'number',
      regionId: 'string',
      size: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSilencePoliciesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned pages.
   */
  pageBean?: ListSilencePoliciesResponseBodyPageBean;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 78901766-3806-4E96-8E47-CFEF59E4****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageBean: 'PageBean',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageBean: ListSilencePoliciesResponseBodyPageBean,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSilencePoliciesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSilencePoliciesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSilencePoliciesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSyntheticDetailRequest extends $tea.Model {
  /**
   * @remarks
   * An array of filter conditions. This parameter is required.
   * 
   * *   To query the list of synthetic test results, set this parameter in the following format: [{"Key":"taskType","OpType":"in","Value":[Task type]}].
   * *   To query the result details of a synthetic monitoring task, set this parameter in the following format: [{"Key":"dataId","OpType":"eq","Value":"dataId"}]. dataId is returned when you query the list of synthetic test results.
   */
  advancedFilters?: ListSyntheticDetailRequestAdvancedFilters[];
  /**
   * @remarks
   * The type of the results. Set the value to SYNTHETIC.
   * 
   * @example
   * SYNTHETIC
   */
  category?: string;
  /**
   * @remarks
   * The type of the list that contains the results. This parameter is required. Valid values:
   * 
   * *   ICMP_LIST
   * *   TCP_LIST
   * *   DNS_LIST
   * *   HTTP_LIST
   * *   WEBSITE_LIST
   * *   DOWNLOAD_LIST
   * *   ALL
   * 
   * @example
   * ICMP_LIST
   */
  detail?: string;
  /**
   * @remarks
   * The timestamp of the end time of the query. Unit: milliseconds.
   * 
   * @example
   * 1684480557772
   */
  endTime?: number;
  /**
   * @remarks
   * A reserved field.
   */
  exactFilters?: ListSyntheticDetailRequestExactFilters[];
  /**
   * @remarks
   * The filter condition. This parameter is required.
   * 
   * *   To query the result of a synthetic monitoring task, set this parameter in the following format: {"taskId":"${taskId}"}.
   * *   To query the result details of a synthetic monitoring task, set this parameter in the following format: {"taskId":"${taskId}","dataId":"${dataId}"}.
   */
  filters?: { [key: string]: string };
  /**
   * @remarks
   * The order in which results are sorted. Valid values:
   * 
   * - `ASC`: ascending order
   * - `DESC`: descending order
   * 
   * @example
   * DESC
   */
  order?: string;
  /**
   * @remarks
   * The field based on which results are sorted. Set the value to timestamp.
   * 
   * @example
   * timestamp
   */
  orderBy?: string;
  /**
   * @remarks
   * The page number. Pages start from page 1.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the region. Set the value to cn-hangzhou.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The timestamp of the start time of the query. Unit: milliseconds.
   * 
   * @example
   * 1684110343127
   */
  startTime?: number;
  /**
   * @remarks
   * The type of the synthetic test. Valid values: 1 and 2. 1 represents an immediate test, and 2 represents a scheduled test.
   * 
   * @example
   * 1
   */
  syntheticType?: number;
  static names(): { [key: string]: string } {
    return {
      advancedFilters: 'AdvancedFilters',
      category: 'Category',
      detail: 'Detail',
      endTime: 'EndTime',
      exactFilters: 'ExactFilters',
      filters: 'Filters',
      order: 'Order',
      orderBy: 'OrderBy',
      page: 'Page',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      startTime: 'StartTime',
      syntheticType: 'SyntheticType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advancedFilters: { 'type': 'array', 'itemType': ListSyntheticDetailRequestAdvancedFilters },
      category: 'string',
      detail: 'string',
      endTime: 'number',
      exactFilters: { 'type': 'array', 'itemType': ListSyntheticDetailRequestExactFilters },
      filters: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      order: 'string',
      orderBy: 'string',
      page: 'number',
      pageSize: 'number',
      regionId: 'string',
      startTime: 'number',
      syntheticType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSyntheticDetailShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * An array of filter conditions. This parameter is required.
   * 
   * *   To query the list of synthetic test results, set this parameter in the following format: [{"Key":"taskType","OpType":"in","Value":[Task type]}].
   * *   To query the result details of a synthetic monitoring task, set this parameter in the following format: [{"Key":"dataId","OpType":"eq","Value":"dataId"}]. dataId is returned when you query the list of synthetic test results.
   */
  advancedFiltersShrink?: string;
  /**
   * @remarks
   * The type of the results. Set the value to SYNTHETIC.
   * 
   * @example
   * SYNTHETIC
   */
  category?: string;
  /**
   * @remarks
   * The type of the list that contains the results. This parameter is required. Valid values:
   * 
   * *   ICMP_LIST
   * *   TCP_LIST
   * *   DNS_LIST
   * *   HTTP_LIST
   * *   WEBSITE_LIST
   * *   DOWNLOAD_LIST
   * *   ALL
   * 
   * @example
   * ICMP_LIST
   */
  detail?: string;
  /**
   * @remarks
   * The timestamp of the end time of the query. Unit: milliseconds.
   * 
   * @example
   * 1684480557772
   */
  endTime?: number;
  /**
   * @remarks
   * A reserved field.
   */
  exactFiltersShrink?: string;
  /**
   * @remarks
   * The filter condition. This parameter is required.
   * 
   * *   To query the result of a synthetic monitoring task, set this parameter in the following format: {"taskId":"${taskId}"}.
   * *   To query the result details of a synthetic monitoring task, set this parameter in the following format: {"taskId":"${taskId}","dataId":"${dataId}"}.
   */
  filtersShrink?: string;
  /**
   * @remarks
   * The order in which results are sorted. Valid values:
   * 
   * - `ASC`: ascending order
   * - `DESC`: descending order
   * 
   * @example
   * DESC
   */
  order?: string;
  /**
   * @remarks
   * The field based on which results are sorted. Set the value to timestamp.
   * 
   * @example
   * timestamp
   */
  orderBy?: string;
  /**
   * @remarks
   * The page number. Pages start from page 1.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the region. Set the value to cn-hangzhou.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The timestamp of the start time of the query. Unit: milliseconds.
   * 
   * @example
   * 1684110343127
   */
  startTime?: number;
  /**
   * @remarks
   * The type of the synthetic test. Valid values: 1 and 2. 1 represents an immediate test, and 2 represents a scheduled test.
   * 
   * @example
   * 1
   */
  syntheticType?: number;
  static names(): { [key: string]: string } {
    return {
      advancedFiltersShrink: 'AdvancedFilters',
      category: 'Category',
      detail: 'Detail',
      endTime: 'EndTime',
      exactFiltersShrink: 'ExactFilters',
      filtersShrink: 'Filters',
      order: 'Order',
      orderBy: 'OrderBy',
      page: 'Page',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      startTime: 'StartTime',
      syntheticType: 'SyntheticType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advancedFiltersShrink: 'string',
      category: 'string',
      detail: 'string',
      endTime: 'number',
      exactFiltersShrink: 'string',
      filtersShrink: 'string',
      order: 'string',
      orderBy: 'string',
      page: 'number',
      pageSize: 'number',
      regionId: 'string',
      startTime: 'number',
      syntheticType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSyntheticDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code returned. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned struct.
   */
  data?: ListSyntheticDetailResponseBodyData;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * null
   */
  message?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 70675725-8F11-4817-8106-CFE0AD71****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: ListSyntheticDetailResponseBodyData,
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSyntheticDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSyntheticDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSyntheticDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTimingSyntheticTasksRequest extends $tea.Model {
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The search keyword.
   */
  search?: ListTimingSyntheticTasksRequestSearch;
  /**
   * @remarks
   * The tags.
   */
  tags?: ListTimingSyntheticTasksRequestTags[];
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      search: 'Search',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      resourceGroupId: 'string',
      search: ListTimingSyntheticTasksRequestSearch,
      tags: { 'type': 'array', 'itemType': ListTimingSyntheticTasksRequestTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTimingSyntheticTasksShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The search keyword.
   */
  searchShrink?: string;
  /**
   * @remarks
   * The tags.
   */
  tagsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      searchShrink: 'Search',
      tagsShrink: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      resourceGroupId: 'string',
      searchShrink: 'string',
      tagsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTimingSyntheticTasksResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned struct.
   */
  data?: ListTimingSyntheticTasksResponseBodyData;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 730E90FE-996A-5638-99F3-4F0F9038CC6C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: ListTimingSyntheticTasksResponseBodyData,
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTimingSyntheticTasksResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTimingSyntheticTasksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTimingSyntheticTasksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTraceAppsRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the application that is associated with the alert rule. Valid values:
   * 
   * - TRACE: Application Monitoring
   * - EBPF: Application Monitoring eBPF Edition
   * 
   * @example
   * TRACE
   */
  appType?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-shenzhen
   */
  region?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The resource group ID.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The tags.
   */
  tags?: ListTraceAppsRequestTags[];
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      region: 'Region',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      region: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      tags: { 'type': 'array', 'itemType': ListTraceAppsRequestTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTraceAppsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code returned for the request. Valid values:
   * 
   * *   `2XX`: The request is successful.
   * *   `3XX`: A redirection message is returned.
   * *   `4XX`: The request is invalid.
   * *   `5XX`: A server error occurs.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The error message returned if the request parameters are invalid.
   * 
   * @example
   * Internal error. Please try again. Contact the DingTalk service account if the issue persists after multiple retries.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 40B10E04-81E8-4643-970D-F1B38F2E****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   `true`: The call was successful.
   * *   `false`: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The list of Application Monitoring tasks.
   */
  traceApps?: ListTraceAppsResponseBodyTraceApps[];
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      traceApps: 'TraceApps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
      traceApps: { 'type': 'array', 'itemType': ListTraceAppsResponseBodyTraceApps },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTraceAppsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTraceAppsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTraceAppsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ManageGetRecordingRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The user ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 876345234
   */
  queryUserId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      queryUserId: 'QueryUserId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      queryUserId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ManageGetRecordingRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * 状态码。200为成功，其他状态码为异常。
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * --- groups: - name: "recording_demo"   rules:   - expr: "sum(jvm_memory_max_bytes)"     record: "rate_coredns_demo"
   */
  data?: string;
  /**
   * @remarks
   * 返回信息。
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * 34ED024E-9E31-434A-9E4E-D9D15C3****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ManageGetRecordingRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ManageGetRecordingRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ManageGetRecordingRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ManageRecordingRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * cf09705f5a82f454db0d50420b6b4e904
   */
  clusterId?: string;
  /**
   * @remarks
   * The ID of the user.
   * 
   * This parameter is required.
   * 
   * @example
   * 87348589207
   */
  queryUserId?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The recording rule.
   * 
   * This parameter is required.
   * 
   * @example
   * groups:\\n- interval: 60s\\n  name: auto_analyzer_recording_rule_60s\\n  rules:\\n  - expr: sum(node_cpu_seconds_total)\\n    record: sum:node_cpu_seconds_total:recording_rule_hash_f341458c0f7d\\n
   */
  ruleYaml?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      queryUserId: 'QueryUserId',
      regionId: 'RegionId',
      ruleYaml: 'RuleYaml',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      queryUserId: 'string',
      regionId: 'string',
      ruleYaml: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ManageRecordingRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The result of the operation.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to troubleshoot issues.
   * 
   * @example
   * CD782AEC-A676-529F-8F26-0ED0FF0EF1EA
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ManageRecordingRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ManageRecordingRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ManageRecordingRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenArmsDefaultSLRRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenArmsDefaultSLRResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   `true`: The call was successful.
   * *   `false`: The call failed.
   * 
   * @example
   * true
   */
  data?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 53CACA70-2CF7-490C-BD06-1A2AE4EB****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenArmsDefaultSLRResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: OpenArmsDefaultSLRResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OpenArmsDefaultSLRResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenArmsServiceSecondVersionRequest extends $tea.Model {
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The type of the service. Valid values:
   * 
   * *   `arms`: ARMS
   * *   `arms_app`: Application Monitoring
   * *   `arms_web`: Browser Monitoring
   * *   `prometheus_monitor`: Managed Service for Prometheus
   * *   `synthetic_post`: Synthetic Monitoring
   * 
   * This parameter is required.
   * 
   * @example
   * arms
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenArmsServiceSecondVersionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The service ID returned if the service is activated.
   * 
   * @example
   * 20896874992****
   */
  orderId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9ED50893-F3C4-42DF-ABB2-C200BE******
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenArmsServiceSecondVersionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: OpenArmsServiceSecondVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OpenArmsServiceSecondVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenVClusterRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the cluster. For cloud services, set this parameter to `cloud-product-prometheus`.
   * 
   * This parameter is required.
   * 
   * @example
   * cloud-product-prometheus
   */
  clusterType?: string;
  /**
   * @remarks
   * The length of the cluster ID. Default value: 10.
   * 
   * @example
   * 10
   */
  length?: number;
  /**
   * @remarks
   * The name of the cloud service. This parameter must be specified when ClusterType is set to `cloud-product-prometheus`. Valid values: influxdb, mongodb, and DLA. You cannot specify multiple service names.
   * 
   * @example
   * influxdb
   */
  product?: string;
  /**
   * @remarks
   * Specifies whether to create or query a virtual cluster. This parameter provides backward compatibility.
   * 
   * @example
   * false
   */
  recreateSwitch?: boolean;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterType: 'ClusterType',
      length: 'Length',
      product: 'Product',
      recreateSwitch: 'RecreateSwitch',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterType: 'string',
      length: 'number',
      product: 'string',
      recreateSwitch: 'boolean',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenVClusterResponseBody extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * @example
   * rre59xelcx
   */
  data?: string;
  /**
   * @remarks
   * The request ID. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * 42E58E4D-ACAD-4400-8FAF-F762340AE5B3
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenVClusterResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: OpenVClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OpenVClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenXtraceDefaultSLRRequest extends $tea.Model {
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenXtraceDefaultSLRResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   *  
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  data?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 53CACA70-2CF7-490C-BD06-1A2AE4EB****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenXtraceDefaultSLRResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: OpenXtraceDefaultSLRResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OpenXtraceDefaultSLRResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAppMetadataRequest extends $tea.Model {
  /**
   * @remarks
   * The metadata IDs. Separate multiple IDs with commas (,).
   * 
   * You can obtain the exception ID on the **Exception Analysis** page of your application in the ARMS console.
   * 
   * This parameter is required.
   * 
   * @example
   * 4c9dd447,3c76c565
   */
  metaIds?: string;
  /**
   * @remarks
   * The metadata type. Valid values:
   * 
   * *   sql: obtains an SQL statement based on sqlId.
   * *   exception: obtains the exception stack based on exceptionId.
   * 
   * This parameter is required.
   * 
   * @example
   * sql
   */
  metaType?: string;
  /**
   * @remarks
   * The process identifier (PID) of the application. You can obtain the PID of an application by calling the **ListTraceApps** operation.
   * 
   * This parameter is required.
   * 
   * @example
   * ggxw4lnjuz@54364d85b97dc56
   */
  pid?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      metaIds: 'MetaIds',
      metaType: 'MetaType',
      pid: 'Pid',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      metaIds: 'string',
      metaType: 'string',
      pid: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAppMetadataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code returned for the request. Valid values:
   * 
   * *   2XX: The request is successful.
   * *   3XX: A redirection message is returned.
   * *   4XX: The request is invalid.
   * *   5XX: A server error occurs.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned struct.
   * 
   * @example
   * {\\"408d5533\\": \\"SELECT * FROM user_base_info\\"}
   */
  data?: { [key: string]: any };
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 51877BAC-330C-5845-BDFD-C7859AD33FB7
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   `true`: The call was successful.
   * *   `false`: The call failed.
   * 
   * @example
   * True
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAppMetadataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryAppMetadataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryAppMetadataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAppTopologyRequest extends $tea.Model {
  /**
   * @remarks
   * The application type
   * 
   * @example
   * TRACE
   */
  appType?: string;
  /**
   * @remarks
   * The database domain name.
   * 
   * @example
   * rm-xxx.mysql.rds.aliyuncs.com:3306
   */
  db?: string;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * orders
   */
  dbName?: string;
  /**
   * @remarks
   * The end of the time range to query. Unit: milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1671952708499
   */
  endTime?: number;
  /**
   * @remarks
   * The filter conditions.
   */
  filters?: { [key: string]: string };
  /**
   * @remarks
   * The ID of the application.
   * 
   * Log on to the **ARMS console**. In the left-side navigation pane, choose **Browser Monitoring** > **Browser Monitoring**. On the Browser Monitoring page, click the name of an application. The URL in the address bar contains the process ID (PID) of the application. The PID is indicated in the pid=xxx format. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is eb4zdose6v%409781be0f44d\\*\\*\\*\\*, you must replace %40 with an at sign (@) to obtain eb4zdose6v@9781be0f44d\\*\\*\\*\\*.
   * 
   * @example
   * atc889zkcf@d8deedfa9bf****
   */
  pid?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * RPC interface name.
   * 
   * @example
   * /eventCenter
   */
  rpc?: string;
  /**
   * @remarks
   * The start of the time range to query. Unit: milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1595568910000
   */
  startTime?: number;
  /**
   * @remarks
   * The type kind of topology.
   * 
   * This parameter is required.
   * 
   * @example
   * apm_apps_v2
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      db: 'Db',
      dbName: 'DbName',
      endTime: 'EndTime',
      filters: 'Filters',
      pid: 'Pid',
      regionId: 'RegionId',
      rpc: 'Rpc',
      startTime: 'StartTime',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      db: 'string',
      dbName: 'string',
      endTime: 'number',
      filters: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      pid: 'string',
      regionId: 'string',
      rpc: 'string',
      startTime: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAppTopologyShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The application type
   * 
   * @example
   * TRACE
   */
  appType?: string;
  /**
   * @remarks
   * The database domain name.
   * 
   * @example
   * rm-xxx.mysql.rds.aliyuncs.com:3306
   */
  db?: string;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * orders
   */
  dbName?: string;
  /**
   * @remarks
   * The end of the time range to query. Unit: milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1671952708499
   */
  endTime?: number;
  /**
   * @remarks
   * The filter conditions.
   */
  filtersShrink?: string;
  /**
   * @remarks
   * The ID of the application.
   * 
   * Log on to the **ARMS console**. In the left-side navigation pane, choose **Browser Monitoring** > **Browser Monitoring**. On the Browser Monitoring page, click the name of an application. The URL in the address bar contains the process ID (PID) of the application. The PID is indicated in the pid=xxx format. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is eb4zdose6v%409781be0f44d\\*\\*\\*\\*, you must replace %40 with an at sign (@) to obtain eb4zdose6v@9781be0f44d\\*\\*\\*\\*.
   * 
   * @example
   * atc889zkcf@d8deedfa9bf****
   */
  pid?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * RPC interface name.
   * 
   * @example
   * /eventCenter
   */
  rpc?: string;
  /**
   * @remarks
   * The start of the time range to query. Unit: milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1595568910000
   */
  startTime?: number;
  /**
   * @remarks
   * The type kind of topology.
   * 
   * This parameter is required.
   * 
   * @example
   * apm_apps_v2
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      db: 'Db',
      dbName: 'DbName',
      endTime: 'EndTime',
      filtersShrink: 'Filters',
      pid: 'Pid',
      regionId: 'RegionId',
      rpc: 'Rpc',
      startTime: 'StartTime',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      db: 'string',
      dbName: 'string',
      endTime: 'number',
      filtersShrink: 'string',
      pid: 'string',
      regionId: 'string',
      rpc: 'string',
      startTime: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAppTopologyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned struct.
   * 
   * @example
   * "Data": {
   *     "nodes": [
   *       {
   *         "data": {
   *           "duration": 0.2254335260115607,
   *           "requests": 1211,
   *           "type": "MYSQL",
   *           "errors": 0
   *         },
   *         "id": "ggxw4lnjuz@c0507xxxx##MYSQL",
   *         "label": "mysql-pod:3306(cart_db)"
   *       }
   *     ],
   *     "edges": [
   *       {
   *         "data": {
   *           "duration": 0.03333333333333333,
   *           "requests": 600,
   *           "type": "UNKNOWN",
   *           "errors": 0
   *         },
   *         "id": "1974097372",
   *         "source": "ggxw4lnjuz@456xxxxx",
   *         "target": "ggxw4lnjuz@c0507xxxx"
   *       }
   *     ]
   *   }
   */
  data?: any;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * Internal error. Please try again. Contact the DingTalk service account if the issue                              persists after multiple retries.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 78901766-3806-4E96-8E47-CFEF59E4****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   true: The call was successful.
   * *   false: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'any',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAppTopologyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryAppTopologyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryAppTopologyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCommercialUsageRequest extends $tea.Model {
  /**
   * @remarks
   * The filter conditions.
   */
  advancedFilters?: QueryCommercialUsageRequestAdvancedFilters[];
  /**
   * @remarks
   * The dimensions of the metric that you want to query. Valid values:
   * 
   * *   dataType: data type
   * *   productType: product type
   * *   instanceId: instance ID
   * *   instanceName: instance name
   * *   instanceType: instance type
   */
  dimensions?: string[];
  /**
   * @remarks
   * The end of the time range to query. Unit: milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1699286400000
   */
  endTime?: number;
  /**
   * @remarks
   * The time interval between data slices. Unit: seconds. Minimum value: 3600.
   * 
   * Valid values:
   * 
   * *   3600: hours
   * *   86400: days
   * 
   * @example
   * 3600
   */
  intervalInSec?: number;
  /**
   * @remarks
   * The measures of the metric that you want to query.
   */
  measures?: string[];
  /**
   * @remarks
   * The name of the metric. Valid value: USAGEFEE.STAT.
   * 
   * This parameter is required.
   * 
   * @example
   * USAGEFEE.STAT
   */
  metric?: string;
  /**
   * @remarks
   * The order in which data is sorted. Valid value:
   * 
   * *   `ASC`: ascending order
   * *   `DESC`: descending order
   * 
   * @example
   * ASC
   */
  order?: string;
  /**
   * @remarks
   * The dimension by which data is sorted.
   * 
   * Valid value:
   * 
   * *   dataType
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * @example
   * dataType
   */
  orderBy?: string;
  /**
   * @remarks
   * The data type. Valid values:
   * 
   * *   instantQuery: non-time series
   * *   timeSeriesQuery: time series
   * 
   * This parameter is required.
   * 
   * @example
   * instantQuery
   */
  queryType?: string;
  /**
   * @remarks
   * The start of the time range to query. Unit: milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1699200000000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      advancedFilters: 'AdvancedFilters',
      dimensions: 'Dimensions',
      endTime: 'EndTime',
      intervalInSec: 'IntervalInSec',
      measures: 'Measures',
      metric: 'Metric',
      order: 'Order',
      orderBy: 'OrderBy',
      queryType: 'QueryType',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advancedFilters: { 'type': 'array', 'itemType': QueryCommercialUsageRequestAdvancedFilters },
      dimensions: { 'type': 'array', 'itemType': 'string' },
      endTime: 'number',
      intervalInSec: 'number',
      measures: { 'type': 'array', 'itemType': 'string' },
      metric: 'string',
      order: 'string',
      orderBy: 'string',
      queryType: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCommercialUsageResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response status. Valid values: 2XX: The request is successful. 3XX: A redirection message is returned. 4XX: The request is invalid. 5XX: A server error occurs.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned struct.
   */
  data?: QueryCommercialUsageResponseBodyData;
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 99A663CB-8D7B-4B0D-A006-03C8EE38E7BB
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: QueryCommercialUsageResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCommercialUsageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryCommercialUsageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryCommercialUsageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMetricByPageRequest extends $tea.Model {
  /**
   * @remarks
   * The page number. Default value: `1`.
   * 
   * @example
   * 1
   */
  currentPage?: number;
  /**
   * @remarks
   * Custom filter conditions.
   */
  customFilters?: string[];
  /**
   * @remarks
   * The dimensions of the metric that you want to query.
   * 
   * @example
   * ["detector_browser","detector_device"]
   */
  dimensions?: string[];
  /**
   * @remarks
   * The end of the time range to query. Unit: milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1667546895000
   */
  endTime?: number;
  /**
   * @remarks
   * The filter conditions.
   */
  filters?: QueryMetricByPageRequestFilters[];
  /**
   * @remarks
   * The time interval at which you want to query metric data. Unit: milliseconds. Minimum value: 60000.
   * 
   * @example
   * 100000
   */
  intervalInSec?: number;
  /**
   * @remarks
   * The measures of the metric that you want to query.
   * 
   * @example
   * pv
   */
  measures?: string[];
  /**
   * @remarks
   * The metric that you want to query. You cannot specify a custom metric. For more information, see the "Application monitoring metrics that can be queried" section.
   * 
   * This parameter is required.
   * 
   * @example
   * appstat.host
   */
  metric?: string;
  /**
   * @remarks
   * The order in which measures are sorted. Valid values:
   * 
   * *   `ASC`: ascending order
   * *   `DESC`: descending order
   * 
   * > If you do not specify the parameter, data is not sorted.
   * 
   * @example
   * ASC
   */
  order?: string;
  /**
   * @remarks
   * The dimension from which metrics are sorted. You can set this parameter to a supported dimension.
   * 
   * @example
   * pid
   */
  orderBy?: string;
  /**
   * @remarks
   * This parameter is no longer supported. The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The start of the time range to query. Unit: milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1667287695000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      customFilters: 'CustomFilters',
      dimensions: 'Dimensions',
      endTime: 'EndTime',
      filters: 'Filters',
      intervalInSec: 'IntervalInSec',
      measures: 'Measures',
      metric: 'Metric',
      order: 'Order',
      orderBy: 'OrderBy',
      pageSize: 'PageSize',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      customFilters: { 'type': 'array', 'itemType': 'string' },
      dimensions: { 'type': 'array', 'itemType': 'string' },
      endTime: 'number',
      filters: { 'type': 'array', 'itemType': QueryMetricByPageRequestFilters },
      intervalInSec: 'number',
      measures: { 'type': 'array', 'itemType': 'string' },
      metric: 'string',
      order: 'string',
      orderBy: 'string',
      pageSize: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMetricByPageResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code returned for the request. Valid values:
   * 
   * *   2XX: The request was successful.
   * *   3XX: A redirection message was returned.
   * *   4XX: The request was invalid.
   * *   5XX: A server error occurred.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The information about the array object.
   */
  data?: QueryMetricByPageResponseBodyData;
  /**
   * @remarks
   * The error message returned if the call fails.
   * 
   * @example
   * StartTime is mandatory for this action.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 687F9CB7-4798-57BF-A6EE-E6CC76******
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   `true`: The call was successful.
   * *   `false`: The call failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: QueryMetricByPageResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMetricByPageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryMetricByPageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryMetricByPageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPromInstallStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPromInstallStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned struct.
   */
  data?: QueryPromInstallStatusResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 27E653FA-5958-45BE-8AA9-14D884DC****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: QueryPromInstallStatusResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPromInstallStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryPromInstallStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryPromInstallStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryReleaseMetricRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the change order.
   * 
   * This parameter is required.
   * 
   * @example
   * a341a2f2-ed07-4257-aae9-dfb1be******
   */
  changeOrderId?: string;
  /**
   * @remarks
   * The time when the change order was created.
   * 
   * @example
   * 1634005438000
   */
  createTime?: number;
  /**
   * @remarks
   * The type of the metric that you want to query.
   * 
   * @example
   * SystemContrast
   */
  metricType?: string;
  /**
   * @remarks
   * The ID of the Enterprise Distributed Application Service (EDAS) or Kubernetes application.
   * 
   * This parameter is required.
   * 
   * @example
   * 8b46d03f-5947-449d-90fd-3a96c2******
   */
  pid?: string;
  /**
   * @remarks
   * This parameter is not in use.
   * 
   * @example
   * null
   */
  proxyUserId?: string;
  /**
   * @remarks
   * The end time of the version release.
   * 
   * This parameter is required.
   * 
   * @example
   * 1632798718632
   */
  releaseEndTime?: number;
  /**
   * @remarks
   * The start time of the version release.
   * 
   * This parameter is required.
   * 
   * @example
   * 1632798686692
   */
  releaseStartTime?: number;
  /**
   * @remarks
   * The service that you want to query.
   * 
   * @example
   * clothservice
   */
  service?: string;
  static names(): { [key: string]: string } {
    return {
      changeOrderId: 'ChangeOrderId',
      createTime: 'CreateTime',
      metricType: 'MetricType',
      pid: 'Pid',
      proxyUserId: 'ProxyUserId',
      releaseEndTime: 'ReleaseEndTime',
      releaseStartTime: 'ReleaseStartTime',
      service: 'Service',
    };
  }

  static types(): { [key: string]: any } {
    return {
      changeOrderId: 'string',
      createTime: 'number',
      metricType: 'string',
      pid: 'string',
      proxyUserId: 'string',
      releaseEndTime: 'number',
      releaseStartTime: 'number',
      service: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryReleaseMetricResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned metric data.
   * 
   * @example
   * {"data":{"SystemCpuUser":{"all":[{"date":1632798718000,"val":4.3277,"dim":"SystemCpuUser"},{"date":1632798733000,"val":8.1091,"dim":"SystemCpuUser"}]},"SystemMemUtil":{"all":[{"date":1632798718000,"val":73.4227,"dim":"SystemMemUtil"},{"date":1632798733000,"val":93.0977,"dim":"SystemMemUtil"}]}},"success":true}
   */
  data?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 46355DD8-FC56-40C5-BFC6-269DE4F9****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryReleaseMetricResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryReleaseMetricResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryReleaseMetricResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveAliClusterIdsFromPrometheusGlobalViewRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of clusters. Separate multiple IDs with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * cd1d55bef19904324a20ed0ebb86caa5c,c5b48729918ab4745a24482ac29d0973a, c00a94896641449098bf24931e4166003, cd174485c09384060ba542bc1be1185a4
   */
  clusterIds?: string;
  /**
   * @remarks
   * The ID of the global aggregation instance.
   * 
   * This parameter is required.
   * 
   * @example
   * global-v2-cn-1670100631025794-amaykca4
   */
  globalViewClusterId?: string;
  /**
   * @remarks
   * The name of the global aggregation instance.
   * 
   * This parameter is required.
   * 
   * @example
   * zyGlobalView
   */
  groupName?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterIds: 'ClusterIds',
      globalViewClusterId: 'GlobalViewClusterId',
      groupName: 'GroupName',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterIds: 'string',
      globalViewClusterId: 'string',
      groupName: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned struct.
   */
  data?: RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * F7781D4A-2818-41E7-B7BB-79D809E9****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData,
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveAliClusterIdsFromPrometheusGlobalViewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveSourcesFromPrometheusGlobalViewRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the global aggregation instance.
   * 
   * This parameter is required.
   * 
   * @example
   * global-v2-cn-1478326682034601-vss8pd0i
   */
  globalViewClusterId?: string;
  /**
   * @remarks
   * The name of the global aggregation instance.
   * 
   * This parameter is required.
   * 
   * @example
   * zyGlobalView
   */
  groupName?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The list of custom data sources. You can specify multiple data sources and separate them with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * localPrometheusClusterName,testCumterPrometheusName
   */
  sourceNames?: string;
  static names(): { [key: string]: string } {
    return {
      globalViewClusterId: 'GlobalViewClusterId',
      groupName: 'GroupName',
      regionId: 'RegionId',
      sourceNames: 'SourceNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      globalViewClusterId: 'string',
      groupName: 'string',
      regionId: 'string',
      sourceNames: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveSourcesFromPrometheusGlobalViewResponseBody extends $tea.Model {
  /**
   * @remarks
   * Status code. 200 is success, other status codes are exceptions.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned struct.
   */
  data?: RemoveSourcesFromPrometheusGlobalViewResponseBodyData;
  /**
   * @remarks
   * Returns a hint message for the result.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * 9319A57D-2D9E-472A-B69B-CF3CD16D****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: RemoveSourcesFromPrometheusGlobalViewResponseBodyData,
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveSourcesFromPrometheusGlobalViewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RemoveSourcesFromPrometheusGlobalViewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RemoveSourcesFromPrometheusGlobalViewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RestartEnvironmentFeatureRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the environment.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The feature name. Valid values: app-agent-pilot, metric-agent, ebpf-agent, and service-check.
   * 
   * This parameter is required.
   * 
   * @example
   * metric-agent
   */
  featureName?: string;
  /**
   * @remarks
   * The region ID. Default value: cn-hangzhou.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      environmentId: 'EnvironmentId',
      featureName: 'FeatureName',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      environmentId: 'string',
      featureName: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RestartEnvironmentFeatureResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * success.
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2983BEF7-4A0D-47A2-94A2-8E9C5E63****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values: true false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RestartEnvironmentFeatureResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RestartEnvironmentFeatureResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RestartEnvironmentFeatureResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveTraceAppConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The process ID (PID) of the application.
   * 
   * Log on to the ARMS console. In the left-side navigation pane, choose **Application Monitoring** > **Application List**. On the Application List page, click the name of an application. The URL in the address bar contains the PID of the application. The PID is indicated in the pid=xxx format. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is xxx%4074xxx, you must replace %40 with an at sign (@) to obtain xxx@74xxx.
   * 
   * This parameter is required.
   * 
   * @example
   * a2n80plglh@745eddxxx
   */
  pid?: string;
  /**
   * @remarks
   * The settings of Application Monitoring.
   */
  settings?: SaveTraceAppConfigRequestSettings[];
  static names(): { [key: string]: string } {
    return {
      pid: 'Pid',
      settings: 'Settings',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pid: 'string',
      settings: { 'type': 'array', 'itemType': SaveTraceAppConfigRequestSettings },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveTraceAppConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. 2XX indicates that the request was successful. 3XX indicates that the request was redirected. 4XX indicates that a request error occurred. 5XX indicates that a server error occurred.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Indicates whether the call was successful.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 78901766-3806-4E96-8E47-CFEF59E4****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveTraceAppConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SaveTraceAppConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SaveTraceAppConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchAlertContactRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert contact.
   * 
   * @example
   * [12345]
   */
  contactIds?: string;
  /**
   * @remarks
   * The name of the alert contact.
   * 
   * @example
   * John Doe
   */
  contactName?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  currentPage?: string;
  /**
   * @remarks
   * The email address of the alert contact.
   * 
   * @example
   * someone@example.com
   */
  email?: string;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 20
   */
  pageSize?: string;
  /**
   * @remarks
   * The mobile number of the alert contact.
   * 
   * @example
   * 1381111*****
   */
  phone?: string;
  /**
   * @remarks
   * The ID of the region. Set the value to `cn-hangzhou`.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      contactIds: 'ContactIds',
      contactName: 'ContactName',
      currentPage: 'CurrentPage',
      email: 'Email',
      pageSize: 'PageSize',
      phone: 'Phone',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactIds: 'string',
      contactName: 'string',
      currentPage: 'string',
      email: 'string',
      pageSize: 'string',
      phone: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchAlertContactResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned struct.
   */
  pageBean?: SearchAlertContactResponseBodyPageBean;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 21E85B16-75A6-429A-9F65-8AAC9A54****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageBean: 'PageBean',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageBean: SearchAlertContactResponseBodyPageBean,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchAlertContactResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchAlertContactResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchAlertContactResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchAlertContactGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert contact group. You can query multiple alert contact groups at a time. Separate multiple group IDs with commas (,).
   * 
   * @example
   * 746
   */
  contactGroupIds?: string;
  /**
   * @remarks
   * The name of the alert contact group.
   * 
   * @example
   * TestGroup
   */
  contactGroupName?: string;
  /**
   * @remarks
   * The ID of the alert contact. You can call the SearchAlertContact operation to query the contact IDs. For more information, see [SearchAlertContact](https://help.aliyun.com/document_detail/130703.html).
   * 
   * @example
   * 123
   */
  contactId?: number;
  /**
   * @remarks
   * The name of the alert contact.
   * 
   * @example
   * John Doe
   */
  contactName?: string;
  /**
   * @remarks
   * Specifies whether to return all alert contacts in the queried alert contact group. By default, not all alert contacts are returned.
   * 
   * @example
   * true
   */
  isDetail?: boolean;
  /**
   * @remarks
   * The ID of the region. Default value: `cn-hangzhou`.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      contactGroupIds: 'ContactGroupIds',
      contactGroupName: 'ContactGroupName',
      contactId: 'ContactId',
      contactName: 'ContactName',
      isDetail: 'IsDetail',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroupIds: 'string',
      contactGroupName: 'string',
      contactId: 'number',
      contactName: 'string',
      isDetail: 'boolean',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchAlertContactGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the alert contact groups.
   */
  contactGroups?: SearchAlertContactGroupResponseBodyContactGroups[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4D6C358A-A58B-4F4B-94CE-F5AAF023****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      contactGroups: 'ContactGroups',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroups: { 'type': 'array', 'itemType': SearchAlertContactGroupResponseBodyContactGroups },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchAlertContactGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchAlertContactGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchAlertContactGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchAlertHistoriesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert rule. You can call the SearchAlertRules operation and view the `Id` parameter in the response. For more information, see [SearchAlertRules](https://help.aliyun.com/document_detail/175825.html).
   * 
   * @example
   * 123
   */
  alertId?: number;
  /**
   * @remarks
   * The type of the alert rule. Valid values:
   * 
   * *   `1`: a custom alert rule that is used to monitor drill-down data sets
   * *   `3`: a custom alert rule that is used to monitor tiled data sets
   * *   `4`: an alert rule that is used to monitor web pages, including the default alert rule for browser monitoring
   * *   `5`: an alert rule that is used to monitor applications, including the default alert rule for application monitoring
   * *   `6`: the default alert rule for browser monitoring
   * *   `7`: the default alert rule for application monitoring
   * *   `8`: a Tracing Analysis alert rule
   * *   `101`: a Prometheus alert rule
   * 
   * @example
   * 4
   */
  alertType?: number;
  /**
   * @remarks
   * The number of the page to return. Default value: `1`.
   * 
   * @example
   * 1
   */
  currentPage?: number;
  /**
   * @remarks
   * The end of the time range to query. The value is a UNIX timestamp of the LONG data type. Unit: milliseconds. The default value is the current time.
   * 
   * @example
   * 1579499626000
   */
  endTime?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: `10`.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the region. Default value: `cn-hangzhou`.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. The value is a UNIX timestamp of the LONG data type. Unit: milliseconds. The default value is 10 minutes before the current time.
   * 
   * @example
   * 1595568910000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      alertId: 'AlertId',
      alertType: 'AlertType',
      currentPage: 'CurrentPage',
      endTime: 'EndTime',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertId: 'number',
      alertType: 'number',
      currentPage: 'number',
      endTime: 'number',
      pageSize: 'number',
      regionId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchAlertHistoriesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned struct.
   */
  pageBean?: SearchAlertHistoriesResponseBodyPageBean;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 2FC13182-B9AF-4E6B-BE51-72669B7C****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageBean: 'PageBean',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageBean: SearchAlertHistoriesResponseBodyPageBean,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchAlertHistoriesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchAlertHistoriesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchAlertHistoriesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchAlertRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The id of AlertRule.
   * 
   * @example
   * 12345
   */
  alertRuleId?: string;
  /**
   * @remarks
   * The type of the application that is associated with the alert rule. Valid values:
   * 
   * *   `TRACE`: application
   * *   `RETCODE`: browser
   * 
   * @example
   * TRACE
   */
  appType?: string;
  /**
   * @remarks
   * The page number of the page to return. Default value: `1`.
   * 
   * @example
   * 1
   */
  currentPage?: number;
  /**
   * @remarks
   * The number of entries to return per page. Default value: `10`.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The process identifier (PID) of the application that is associated with the alert rule. For more information about how to obtain the PID, see [Obtain the PID of an application](https://help.aliyun.com/document_detail/186100.html?spm=a2c4g.11186623.6.792.1b50654cqcDPyk#title-imy-7gj-qhr).
   * 
   * @example
   * atc889zkcf@d8deedfa9bf****
   */
  pid?: string;
  /**
   * @remarks
   * The region ID of the alert data. For more information about the mappings between **RegionId** and **SystemRegionId**, see the detailed description below the table.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group. You can obtain the resource group ID in the **Resource Management** console.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The region ID of the alert rule. For more information about the mappings between **RegionId** and **SystemRegionId**, see the detailed description below the table.
   * 
   * @example
   * cn-hangzhou
   */
  systemRegionId?: string;
  /**
   * @remarks
   * The list of tags.
   */
  tags?: SearchAlertRulesRequestTags[];
  /**
   * @remarks
   * The alert rule name.
   * 
   * @example
   * AlertRuleTitle
   */
  title?: string;
  /**
   * @remarks
   * The alert rule type. Valid values:
   * 
   * *   `1`: custom alert rules that are used to monitor drill-down data sets
   * *   `3`: custom alert rules that are used to monitor tiled data sets
   * *   `4`: alert rules that are used to monitor the browser, including the default frontend alert rules
   * *   `5`: alert rules that are used to monitor applications, including the default application alert rules
   * *   `6`: the default browser alert rules
   * *   `7`: the default application alert rules
   * *   `8`: Tracing Analysis alert rules
   * *   `101`: Prometheus alert rules
   * 
   * @example
   * 4
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      alertRuleId: 'AlertRuleId',
      appType: 'AppType',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      pid: 'Pid',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      systemRegionId: 'SystemRegionId',
      tags: 'Tags',
      title: 'Title',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertRuleId: 'string',
      appType: 'string',
      currentPage: 'number',
      pageSize: 'number',
      pid: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      systemRegionId: 'string',
      tags: { 'type': 'array', 'itemType': SearchAlertRulesRequestTags },
      title: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchAlertRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned struct.
   */
  pageBean?: SearchAlertRulesResponseBodyPageBean;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 34ED024E-9E31-434A-9E4E-D9D15C3****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageBean: 'PageBean',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageBean: SearchAlertRulesResponseBodyPageBean,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchAlertRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchAlertRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchAlertRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchEventsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert rule. You can call the SearchAlertRules operation and view the `Id` parameter in the response. For more information, see [SearchAlertRules](https://help.aliyun.com/document_detail/175825.html).
   * 
   * @example
   * 123
   */
  alertId?: number;
  /**
   * @remarks
   * The type of the alert rule. Valid values:
   * 
   * *   `1`: custom alert rules to monitor drill-down data sets
   * *   `3`: custom alert rules to monitor tiled data sets
   * *   `4`: alert rules to monitor the frontend, including the default frontend alert rules
   * *   `5`: alert rules to monitor applications, including the default application alert rules
   * *   `6`: the default frontend alert rules
   * *   `7`: the default application alert rules
   * *   `8`: Tracing Analysis alert rules
   * *   `101`: Prometheus alert rules
   * 
   * @example
   * 4
   */
  alertType?: number;
  /**
   * @remarks
   * The type of the application that is associated with the alert rule. Valid values:
   * 
   * *   `TRACE`: application monitoring
   * *   `RETCODE`: frontend monitoring
   * 
   * @example
   * TRACE
   */
  appType?: string;
  /**
   * @remarks
   * The number of the page to return. Default value: `1`.
   * 
   * @example
   * 1
   */
  currentPage?: number;
  /**
   * @remarks
   * The end of the time range to query. Specify a UNIX timestamp of the LONG data type, in milliseconds. The default value is the current time.
   * 
   * @example
   * 1595568970000
   */
  endTime?: number;
  /**
   * @remarks
   * Specifies whether the alert event is triggered. If you do not set this parameter, all alert events are queried. Valid values:
   * 
   * *   `1`: The event is triggered.
   * *   `0`: The event is not triggered.
   * 
   * @example
   * 1
   */
  isTrigger?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: `10`.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The process identifier (PID) of the application that is associated with the alert rule.
   * 
   * @example
   * atc889zkcf@d8deedfa9bf****
   */
  pid?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify a UNIX timestamp of the LONG data type, in milliseconds. The default value is 10 minutes before the current time.
   * 
   * @example
   * 1595565300000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      alertId: 'AlertId',
      alertType: 'AlertType',
      appType: 'AppType',
      currentPage: 'CurrentPage',
      endTime: 'EndTime',
      isTrigger: 'IsTrigger',
      pageSize: 'PageSize',
      pid: 'Pid',
      regionId: 'RegionId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertId: 'number',
      alertType: 'number',
      appType: 'string',
      currentPage: 'number',
      endTime: 'number',
      isTrigger: 'number',
      pageSize: 'number',
      pid: 'string',
      regionId: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchEventsResponseBody extends $tea.Model {
  /**
   * @remarks
   * Specifies whether the alert event is triggered. If you do not set this parameter, all alert events are queried. Valid values:
   * 
   * *   `1`: The event is triggered.
   * *   `0`: The event is not triggered.
   * 
   * @example
   * 0
   */
  isTrigger?: number;
  /**
   * @remarks
   * The struct returned.
   */
  pageBean?: SearchEventsResponseBodyPageBean;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 32940175-181B-4B93-966E-4BB69176****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      isTrigger: 'IsTrigger',
      pageBean: 'PageBean',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isTrigger: 'number',
      pageBean: SearchEventsResponseBodyPageBean,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchEventsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchEventsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchEventsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchRetcodeAppByPageRequest extends $tea.Model {
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 5
   */
  pageSize?: number;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group. You can obtain the resource group ID in the **Resource Management** console.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The application ID.
   * 
   * Log on to the **ARMS console**. In the left-side navigation pane, choose **Browser Monitoring** > **Browser Monitoring**. On the Browser Monitoring page, click the name of an application. The URL in the browser address bar contains the pid of this application in the format of `pid=xxx`. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is `xxx%4074xxx`, you must replace **%40** with the at sign (@). The actual PID is `xxx@74xxx`.
   * 
   * @example
   * eb4zdose6v@9781be0f44d****
   */
  retcodeAppId?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * App1
   */
  retcodeAppName?: string;
  /**
   * @remarks
   * The tag.
   */
  tags?: SearchRetcodeAppByPageRequestTags[];
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      retcodeAppId: 'RetcodeAppId',
      retcodeAppName: 'RetcodeAppName',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceGroupId: 'string',
      retcodeAppId: 'string',
      retcodeAppName: 'string',
      tags: { 'type': 'array', 'itemType': SearchRetcodeAppByPageRequestTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchRetcodeAppByPageResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned page information.
   */
  pageBean?: SearchRetcodeAppByPageResponseBodyPageBean;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 626037F5-FDEB-45B0-804C-B3C92797A64E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageBean: 'PageBean',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageBean: SearchRetcodeAppByPageResponseBodyPageBean,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchRetcodeAppByPageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchRetcodeAppByPageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchRetcodeAppByPageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTraceAppByNameRequest extends $tea.Model {
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The list of tags.
   */
  tags?: SearchTraceAppByNameRequestTags[];
  /**
   * @remarks
   * The name of the application.
   * 
   * > If you do not specify this parameter, all application monitoring tasks in the specified region are queried.
   * 
   * @example
   * test-app
   */
  traceAppName?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      tags: 'Tags',
      traceAppName: 'TraceAppName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      tags: { 'type': 'array', 'itemType': SearchTraceAppByNameRequestTags },
      traceAppName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTraceAppByNameResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F7781D4A-2818-41E7-B7BB-79D809E9****
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the monitoring task.
   */
  traceApps?: SearchTraceAppByNameResponseBodyTraceApps[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      traceApps: 'TraceApps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      traceApps: { 'type': 'array', 'itemType': SearchTraceAppByNameResponseBodyTraceApps },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTraceAppByNameResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchTraceAppByNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchTraceAppByNameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTraceAppByPageRequest extends $tea.Model {
  /**
   * @remarks
   * The number of the page to return. Default value: `1`.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: `10`.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The resource group ID.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * A list of tags.
   */
  tags?: SearchTraceAppByPageRequestTags[];
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * test-app
   */
  traceAppName?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      tags: 'Tags',
      traceAppName: 'TraceAppName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      regionId: 'string',
      resourceGroupId: 'string',
      tags: { 'type': 'array', 'itemType': SearchTraceAppByPageRequestTags },
      traceAppName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTraceAppByPageResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the array object.
   */
  pageBean?: SearchTraceAppByPageResponseBodyPageBean;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 4B446DF2-3DDD-4B5B-8E3F-D5225120****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageBean: 'PageBean',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageBean: SearchTraceAppByPageResponseBodyPageBean,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTraceAppByPageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchTraceAppByPageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchTraceAppByPageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTracesRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. Unit: milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1595210400000
   */
  endTime?: number;
  /**
   * @remarks
   * The filter conditions.
   */
  exclusionFilters?: SearchTracesRequestExclusionFilters[];
  /**
   * @remarks
   * The minimum amount of time consumed by traces. Unit: milliseconds.
   * 
   * @example
   * 2
   */
  minDuration?: number;
  /**
   * @remarks
   * The name of the traced span.
   * 
   * @example
   * /demo/queryNotExistDB/11
   */
  operationName?: string;
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * b590lhguqs@9781be0f44dXXXX
   */
  pid?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * Specifies whether to sort the query results in chronological order or reverse chronological order. Default value: `false`.
   * 
   * *   `true`: sorts the query results in reverse chronological order.
   * *   `false`: sorts the query results in chronological order.
   * 
   * @example
   * false
   */
  reverse?: boolean;
  /**
   * @remarks
   * The IP address of the host where the application resides.
   * 
   * @example
   * 172.20.XX.XX
   */
  serviceIp?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * arms-k8s-demo-subcomponent
   */
  serviceName?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Unit: milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1595174400000
   */
  startTime?: number;
  /**
   * @remarks
   * The list of tags.
   */
  tag?: SearchTracesRequestTag[];
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      exclusionFilters: 'ExclusionFilters',
      minDuration: 'MinDuration',
      operationName: 'OperationName',
      pid: 'Pid',
      regionId: 'RegionId',
      reverse: 'Reverse',
      serviceIp: 'ServiceIp',
      serviceName: 'ServiceName',
      startTime: 'StartTime',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      exclusionFilters: { 'type': 'array', 'itemType': SearchTracesRequestExclusionFilters },
      minDuration: 'number',
      operationName: 'string',
      pid: 'string',
      regionId: 'string',
      reverse: 'boolean',
      serviceIp: 'string',
      serviceName: 'string',
      startTime: 'number',
      tag: { 'type': 'array', 'itemType': SearchTracesRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTracesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 4C518054-852F-4023-ABC1-4AF95FF7****
   */
  requestId?: string;
  /**
   * @remarks
   * The details of the returned traces.
   */
  traceInfos?: SearchTracesResponseBodyTraceInfos[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      traceInfos: 'TraceInfos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      traceInfos: { 'type': 'array', 'itemType': SearchTracesResponseBodyTraceInfos },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTracesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchTracesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchTracesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTracesByPageRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. Unit: milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1595210400000
   */
  endTime?: number;
  /**
   * @remarks
   * The filter conditions.
   */
  exclusionFilters?: SearchTracesByPageRequestExclusionFilters[];
  /**
   * @remarks
   * Specifies whether to include the traces of abnormal calls.
   * 
   * *   `true`: No
   * *   `false` (default): Yes
   * 
   * @example
   * false
   */
  isError?: boolean;
  /**
   * @remarks
   * The minimum amount of time consumed by traces. Unit: milliseconds.
   * 
   * @example
   * 2
   */
  minDuration?: number;
  /**
   * @remarks
   * The name of the traced span.
   * 
   * @example
   * /demo/queryNotExistDB/11
   */
  operationName?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 100.
   * 
   * @example
   * 5
   */
  pageSize?: number;
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * b590lhguqs@9781be0f44dXXXX
   */
  pid?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * Specifies whether to sort the query results in chronological order or reverse chronological order. Default value: `false`.
   * 
   * *   `true`: sorts the query results in reverse chronological order.
   * *   `false`: sorts the query results in chronological order.
   * 
   * @example
   * false
   */
  reverse?: boolean;
  /**
   * @remarks
   * The IP address of the host where the application resides.
   * 
   * @example
   * 172.20.XX.XX
   */
  serviceIp?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * arms-k8s-demo-subcomponent
   */
  serviceName?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Unit: milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1595174400000
   */
  startTime?: number;
  /**
   * @remarks
   * The list of tags.
   */
  tags?: SearchTracesByPageRequestTags[];
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      exclusionFilters: 'ExclusionFilters',
      isError: 'IsError',
      minDuration: 'MinDuration',
      operationName: 'OperationName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      pid: 'Pid',
      regionId: 'RegionId',
      reverse: 'Reverse',
      serviceIp: 'ServiceIp',
      serviceName: 'ServiceName',
      startTime: 'StartTime',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      exclusionFilters: { 'type': 'array', 'itemType': SearchTracesByPageRequestExclusionFilters },
      isError: 'boolean',
      minDuration: 'number',
      operationName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      pid: 'string',
      regionId: 'string',
      reverse: 'boolean',
      serviceIp: 'string',
      serviceName: 'string',
      startTime: 'number',
      tags: { 'type': 'array', 'itemType': SearchTracesByPageRequestTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTracesByPageResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned struct.
   */
  pageBean?: SearchTracesByPageResponseBodyPageBean;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 4C518054-852F-4023-ABC1-4AF95FF7****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageBean: 'PageBean',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageBean: SearchTracesByPageResponseBodyPageBean,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTracesByPageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchTracesByPageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchTracesByPageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendTTSVerifyLinkRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert contact.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  contactId?: number;
  /**
   * @remarks
   * The mobile number of the alert contact.
   * 
   * This parameter is required.
   * 
   * @example
   * 1381111****
   */
  phone?: string;
  static names(): { [key: string]: string } {
    return {
      contactId: 'ContactId',
      phone: 'Phone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactId: 'number',
      phone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendTTSVerifyLinkResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the text message was sent.
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  isSuccess?: boolean;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 21E85B16-75A6-429A-9F65-8AAC9A54****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      isSuccess: 'IsSuccess',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isSuccess: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SendTTSVerifyLinkResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SendTTSVerifyLinkResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SendTTSVerifyLinkResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetRetcodeShareStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the application that is monitored by Browser Monitoring.
   * 
   * @example
   * test-app
   */
  appName?: string;
  /**
   * @remarks
   * The process identifier (PID) of the application. 
   * 
   * Log on to the **ARMS console**. In the left-side navigation pane, choose **Browser Monitoring** > **Browser Monitoring**. On the Browser Monitoring page, click the name of an application. The URL in the address bar contains the process ID (PID) of the application. The PID is indicated in the `pid=xxx` format. The PID is usually percent encoded as `xxx%40xxx`. You must modify this value to remove the percent encoding. For example, if the PID in the URL is `eb4zdose6v%409781be0f44d****`, you must replace `%40` with @ to obtain `eb4zdose6v@9781be0f44d****`.
   * 
   * @example
   * atc889zkcf@d8deedfa9bf****
   */
  pid?: string;
  /**
   * @remarks
   * Specifies whether to turn on or turn off the logon-free sharing switch. Valid values:
   * 
   * *   `true`: Turn on the switch.
   * *   `false`: Turn off the switch.
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  status?: boolean;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      pid: 'Pid',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      pid: 'string',
      status: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetRetcodeShareStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the call is successful. Valid values:
   * 
   * *   `true`: The call is successful.
   * *   `false`: The call fails.
   * 
   * @example
   * true
   */
  isSuccess?: boolean;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 40B10E04-81E8-4643-970D-F1B38F2E****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      isSuccess: 'IsSuccess',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isSuccess: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetRetcodeShareStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetRetcodeShareStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetRetcodeShareStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartAlertRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert rule. You can call the SearchAlertRules operation and view the `Id` parameter in the response. For more information, see [SearchAlertRules](https://help.aliyun.com/document_detail/175825.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 1610***
   */
  alertId?: string;
  /**
   * @remarks
   * The ID of the region. Set the value to `cn-hangzhou`.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      alertId: 'AlertId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartAlertResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the call was successful.
   * 
   * *   `true`: The call was successful.
   * *   `false`: The call failed.
   * 
   * @example
   * true
   */
  isSuccess?: boolean;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 27E653FA-5958-45BE-8AA9-14D884DC****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      isSuccess: 'IsSuccess',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isSuccess: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartAlertResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StartAlertResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartAlertResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartTimingSyntheticTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The region ID. Default value: cn-hangzhou.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The task IDs.
   */
  taskIds?: string[];
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      taskIds: 'TaskIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      taskIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartTimingSyntheticTaskShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The region ID. Default value: cn-hangzhou.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The task IDs.
   */
  taskIdsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      taskIdsShrink: 'TaskIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      taskIdsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartTimingSyntheticTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values: true and false.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2A0CEDF1-06FE-44AC-8E21-21A5BE65****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'boolean',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartTimingSyntheticTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StartTimingSyntheticTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartTimingSyntheticTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopAlertRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * This parameter is required.
   * 
   * @example
   * 1610***
   */
  alertId?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      alertId: 'AlertId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopAlertResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   `true`: The request is successful.
   * *   `false`: The request fails.
   * 
   * @example
   * true
   */
  isSuccess?: boolean;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 27E653FA-5958-45BE-8AA9-14D884DC****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      isSuccess: 'IsSuccess',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isSuccess: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopAlertResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StopAlertResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopAlertResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopTimingSyntheticTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The task IDs.
   * 
   * This parameter is required.
   */
  taskIds?: string[];
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      taskIds: 'TaskIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      taskIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopTimingSyntheticTaskShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The task IDs.
   * 
   * This parameter is required.
   */
  taskIdsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      taskIdsShrink: 'TaskIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      taskIdsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopTimingSyntheticTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values: true and false.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1A9C645C-C83F-4C9D-8CCB-29BEC9E1****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'boolean',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopTimingSyntheticTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StopTimingSyntheticTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopTimingSyntheticTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SwitchSyntheticTaskStatusRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to start or stop the task. Valid values:
   * 
   * *   **0**: stops the task
   * *   **1**: starts the task
   * 
   * @example
   * 0
   */
  switchStatus?: number;
  /**
   * @remarks
   * The task IDs. You can specify up to 30 task IDs at a time.
   */
  taskIds?: number[];
  static names(): { [key: string]: string } {
    return {
      switchStatus: 'SwitchStatus',
      taskIds: 'TaskIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      switchStatus: 'number',
      taskIds: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SwitchSyntheticTaskStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1A9C645C-C83F-4C9D-8CCB-29BEC9E1****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SwitchSyntheticTaskStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SwitchSyntheticTaskStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SwitchSyntheticTaskStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncRecordingRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the cluster whose aggregation rule you want to synchronize.
   * 
   * This parameter is required.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The ID of the region. The destination region can be the same as the source region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The IDs of clusters to which you want to synchronize the aggregation rule.
   * 
   * This parameter is required.
   * 
   * @example
   * {     "cn":[         "c06ca68cd16f14f52bb07772eda***",         "c33dd70a0ac184c1b879d807ab2***",         "c384cf7e4dcb543e6ac8c7d4dd3***"     ],     "us":[         "ce30f833bc4a04a56a06b070319***"     ],     "jp":[      ],     "ap":[      ],     "gov":[      ],     "finance":[      ] }
   */
  targetClusters?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
      targetClusters: 'TargetClusters',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
      targetClusters: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncRecordingRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * 状态码。200表示成功。
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The struct returned.
   * 
   * @example
   * { "data":[ "c06ca68cd16f14f52bb07772eda\\*\\*\\*", "c33dd70a0ac184c1b879d807ab2\\*\\*\\*", "c384cf7e4dcb543e6ac8c7d4dd3\\*\\*\\*", "ce30f833bc4a04a56a06b070319\\*\\*\\*" ], "message":"IDs of Clusters to which the aggregation rule failed to be synchronized", "success":true }
   */
  data?: string;
  /**
   * @remarks
   * 返回结果的提示信息。
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * 1A9C645C-C83F-4C9D-8CCB-29BEC9E1****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncRecordingRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SyncRecordingRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SyncRecordingRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesRequest extends $tea.Model {
  /**
   * @remarks
   * The resource IDs. You can specify a maximum of 50 resource IDs.
   * 
   * This parameter is required.
   */
  resourceId?: string[];
  /**
   * @remarks
   * The type of the ARMS resources for which you want to modify tags. Valid values:
   * 
   * *   WEB: Browser Monitoring
   * *   APPLICATION: Application Monitoring
   * *   PROMETHEUS: Managed Service for Prometheus
   * *   SYNTHETICTASK: Synthetic Monitoring
   * *   ALERTRULE: Application Monitoring alert rule
   * *   PROMETHEUSALERTRULE: Managed Service for Prometheus alert rule
   * *   XTRACEAPP: Managed Service for OpenTelemetry
   * 
   * This parameter is required.
   * 
   * @example
   * PROMETHEUS
   */
  resourceType?: string;
  /**
   * @remarks
   * The tags to add to the resource. You can specify a maximum of 20 tags.
   * 
   * This parameter is required.
   */
  tag?: TagResourcesRequestTag[];
  static names(): { [key: string]: string } {
    return {
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      tag: { 'type': 'array', 'itemType': TagResourcesRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 05919CF2-B8A1-588D-B3DB-89B3********
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: TagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: TagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UninstallManagedPrometheusRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the Container Service for Kubernetes (ACK) cluster. This parameter is required when the ClusterType parameter is set to ask or one.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The cluster type. Valid values: ask, ecs, and one.
   * 
   * This parameter is required.
   * 
   * @example
   * ask
   */
  clusterType?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group to which the Prometheus instance belongs.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The ID of the virtual private cloud (VPC) where the cluster resides.
   * 
   * @example
   * vpc-rpn**********
   * 
   * **if can be null:**
   * true
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      clusterType: 'ClusterType',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      clusterType: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UninstallManagedPrometheusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The response content. The status of the Prometheus instance is returned.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The error message that is returned if the request fails.
   * 
   * @example
   * vpcId is blank
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2A0CEDF1-06FE-44AC-8E21-21A5BE65****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the Prometheus instance was removed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UninstallManagedPrometheusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UninstallManagedPrometheusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UninstallManagedPrometheusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UninstallPromClusterRequest extends $tea.Model {
  /**
   * @remarks
   * Language environment(If left blank, defaults to zh):
   * - zh
   * - en
   * 
   * @example
   * en
   */
  aliyunLang?: string;
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c0bad479465464e1d8c1e641b0afb****
   */
  clusterId?: string;
  /**
   * @remarks
   * The region ID. Default value: cn-hangzhou.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunLang: 'AliyunLang',
      clusterId: 'ClusterId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunLang: 'string',
      clusterId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UninstallPromClusterResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * The request ID. You can use the ID to find logs and troubleshoot issues.
   * 
   * @example
   * 53980F48-DE82-53A1-9ADE-D2629226DD9A
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UninstallPromClusterResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UninstallPromClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UninstallPromClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to delete all tags. This parameter takes effect only when the TagKey.N parameter is not specified. Valid values:
   * 
   * *   true
   * *   false
   * 
   * Default value: false.
   * 
   * @example
   * False
   */
  all?: boolean;
  /**
   * @remarks
   * The resource IDs. You can specify a maximum of 50 resource IDs.
   * 
   * This parameter is required.
   */
  resourceId?: string[];
  /**
   * @remarks
   * The type of the ARMS resources for which you want to modify tags. Valid values:
   * 
   * *   WEB: Browser Monitoring
   * *   APPLICATION: Application Monitoring
   * *   PROMETHEUS: Managed Service for Prometheus
   * *   SYNTHETICTASK: Synthetic Monitoring
   * *   ALERTRULE: Application Monitoring alert rule
   * *   PROMETHEUSALERTRULE: Managed Service for Prometheus alert rule
   * *   XTRACEAPP: Managed Service for OpenTelemetry
   * 
   * This parameter is required.
   * 
   * @example
   * PROMETHEUS
   */
  resourceType?: string;
  /**
   * @remarks
   * The tag keys. You can specify a maximum of 20 tag keys.
   */
  tagKey?: string[];
  /**
   * @remarks
   * The list of tags.
   */
  tags?: UntagResourcesRequestTags[];
  static names(): { [key: string]: string } {
    return {
      all: 'All',
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tagKey: 'TagKey',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      all: 'boolean',
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      tagKey: { 'type': 'array', 'itemType': 'string' },
      tags: { 'type': 'array', 'itemType': UntagResourcesRequestTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned struct.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * FC183B5E-C9AD-5E9E-937F-*******
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UntagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UntagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAlertContactRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert contact to be updated. You can call the SearchAlertContact operation to query the contact ID. For more information, see [SearchAlertContact](https://help.aliyun.com/document_detail/130703.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  contactId?: number;
  /**
   * @remarks
   * The new name of the alert contact.
   * 
   * @example
   * John Doe
   */
  contactName?: string;
  /**
   * @remarks
   * The new webhook URL of the DingTalk chatbot. For more information, see [Configure a DingTalk chatbot to send alert notifications](https://help.aliyun.com/document_detail/106247.html). You must specify at least one of the following parameters: PhoneNum, Email, and DingRobotWebhookUrl.
   * 
   * >  If you do not specify this parameter, the original parameter value is deleted. If you specify this parameter, the original parameter value is updated.
   * 
   * @example
   * https://oapi.dingtalk.com/robot/send?access_token=91f2f6****
   */
  dingRobotWebhookUrl?: string;
  /**
   * @remarks
   * The new email address of the alert contact. You must specify at least one of the following parameters: PhoneNum, Email, and DingRobotWebhookUrl.
   * 
   * >  If you do not specify this parameter, the original parameter value is deleted. If you specify this parameter, the original parameter value is updated.
   * 
   * @example
   * someone@example.com
   */
  email?: string;
  /**
   * @remarks
   * The new mobile phone number of the alert contact. You must specify at least one of the following parameters: PhoneNum, Email, and DingRobotWebhookUrl.
   * 
   * >  If you do not specify this parameter, the original parameter value is deleted. If you specify this parameter, the original parameter value is updated.
   * 
   * @example
   * 1381111****
   */
  phoneNum?: string;
  /**
   * @remarks
   * The ID of the region. Set the value to `cn-hangzhou`.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * Specifies whether the alert contact receives system notifications. Valid values:
   * 
   * *   `true`: The alert contact receives system notifications.
   * *   `false`: The alert contact does not receive system notifications.
   * 
   * @example
   * true
   */
  systemNoc?: boolean;
  static names(): { [key: string]: string } {
    return {
      contactId: 'ContactId',
      contactName: 'ContactName',
      dingRobotWebhookUrl: 'DingRobotWebhookUrl',
      email: 'Email',
      phoneNum: 'PhoneNum',
      regionId: 'RegionId',
      systemNoc: 'SystemNoc',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactId: 'number',
      contactName: 'string',
      dingRobotWebhookUrl: 'string',
      email: 'string',
      phoneNum: 'string',
      regionId: 'string',
      systemNoc: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAlertContactResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the alert contact was updated. Valid values:
   * 
   * *   true: The alert contact was updated.
   * *   false: The alert contact failed to be updated.
   * 
   * @example
   * true
   */
  isSuccess?: boolean;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 1A474FF8-7861-4D00-81B5-5BC3DA4E****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      isSuccess: 'IsSuccess',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isSuccess: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAlertContactResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateAlertContactResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateAlertContactResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAlertContactGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert contact group.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  contactGroupId?: number;
  /**
   * @remarks
   * The name of the alert contact group.
   * 
   * This parameter is required.
   * 
   * @example
   * TestGroup
   */
  contactGroupName?: string;
  /**
   * @remarks
   * The ID of the alert contact.
   * 
   * @example
   * 123 234 345
   */
  contactIds?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      contactGroupId: 'ContactGroupId',
      contactGroupName: 'ContactGroupName',
      contactIds: 'ContactIds',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroupId: 'number',
      contactGroupName: 'string',
      contactIds: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAlertContactGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the call was successful.
   * 
   * *   `true`: The call was successful.
   * *   `false`: The call failed.
   * 
   * @example
   * true
   */
  isSuccess?: boolean;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9319A57D-2D9E-472A-B69B-CF3CD16D****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      isSuccess: 'IsSuccess',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isSuccess: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAlertContactGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateAlertContactGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateAlertContactGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAlertRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567
   */
  alertId?: number;
  /**
   * @remarks
   * The IDs of the alert contact groups. The value must be a JSON array.
   * 
   * @example
   * [123, 234]
   */
  contactGroupIds?: string;
  /**
   * @remarks
   * Specifies whether to enable the alert rule after it is created. Default value: `false`.
   * 
   * *   `true`: enables the alert rule.
   * *   `false`: disables the alert rule.
   * 
   * @example
   * true
   */
  isAutoStart?: boolean;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The configurations of the alert template based on which you want to create an alert rule. The value must be a JSON string. You must set at least one of the **TemplateAlertId** and **TemplageAlertConfig** parameters. If you set both parameters, the **TemplateAlertId** parameter prevails. For more information about the TemplageAlertConfig parameter, see the following **additional information about the TemplageAlertConfig parameter**.
   * 
   * This parameter is required.
   * 
   * @example
   * [ { "contactGroupIds": "381", "alertType": 5, "alarmContext": { "subTitle": "", "content": "Alarm name: $alarm name\\nFilter condition: $filter\\nAlarm time : $Alarm time\\nAlarm content: $Alarm content\\nNote: Before the recovery email is received, the alarm is in continuous alarm, and you will be reminded again after 24 hours!" }, "alertLevel": "WARN", " metricParam": { "appId": "70901", "pid": "atc889zkcf@d8deedfa9bf****", "type": "TXN", "dimensions": [ { "type": "STATIC", "value ": "\\\\/hello_test_api_address\\\\/test1", "key": "rpc" } ] }, "alertWay": [ "SMS", "MAIL", "DING_ROBOT" ], "alertRule": { "rules" : [ { "measure": "appstat.txn.rt", "alias": "Entry call response time_ms", "aggregates": "AVG", "nValue": 1, "value": 1, "operator ": "CURRENT_GTE" } ], "operator": "|" }, "title": "Alarm template alarm name", "config": "{\\"continuous\\":false,\\"dataRevision\\":2, \\"ownerId\\":\\"123412341234\\"}", "notice": { "noticeStartTime": 1480521600000, "startTime": 1480521600000, "endTime": 1480607940000, "noticeEndTime": 1480607940000 }, "stat us": "NON " } ]
   */
  templageAlertConfig?: string;
  static names(): { [key: string]: string } {
    return {
      alertId: 'AlertId',
      contactGroupIds: 'ContactGroupIds',
      isAutoStart: 'IsAutoStart',
      regionId: 'RegionId',
      templageAlertConfig: 'TemplageAlertConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertId: 'number',
      contactGroupIds: 'string',
      isAutoStart: 'boolean',
      regionId: 'string',
      templageAlertConfig: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAlertRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * @example
   * 1234567
   */
  alertId?: number;
  /**
   * @remarks
   * The struct returned.
   * 
   * @example
   * -
   */
  data?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6A9AEA84-7186-4D8D-B498-4585C6A2****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      alertId: 'AlertId',
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertId: 'number',
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAlertRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateAlertRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateAlertRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDispatchRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The dispatch rule configuration. The value is a JSON string. For more information about this parameter, see the following **additional information about the DispatchRule parameter**.
   * 
   * This parameter is required.
   * 
   * @example
   * {   "id": 123,     "system": false,   "ruleid": 10282,   "name": "Prometheus Alert",   "labelMatchExpressionGrid": {     "labelMatchExpressionGroups": [       {         "labelMatchExpressions": [           {             "key": "_aliyun_arms_involvedObject_kind",             "value": "app",             "operator": "eq"           }         ]       }     ]   },   "dispatchType": "CREATE_ALERT/DISCARD_ALERT",   "isRecover": true,   "groupRules": [     {       "groupId": 1,       "groupingFields": [         "alertname"       ],       "groupWait": 10,       "groupInterval": 15,       "repeatInterval": 20     }   ],   "notifyRules": [     {       "notifyObjects": [         {           "notifyType": "ARMS_CONTACT",           "name": "JohnDoe",           "notifyObjectId": 1         },         {           "notifyType": "ARMS_CONTACT_GROUP",           "name": "JohnDoe_group",           "notifyObjectId": 2         }       ],       "notifyChannels":["dingTalk","wechat","webhook","email"]     },   ], }
   */
  dispatchRule?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      dispatchRule: 'DispatchRule',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dispatchRule: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDispatchRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * A5EC8221-08F2-4C95-9AF1-49FD998C****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDispatchRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateDispatchRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDispatchRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEnvCustomJobRequest extends $tea.Model {
  /**
   * @remarks
   * The language. Valid values: zh and en. Default value: zh.
   * 
   * @example
   * zh
   */
  aliyunLang?: string;
  /**
   * @remarks
   * The YAML configuration string.
   * 
   * @example
   * Refer to supplementary instructions.
   */
  configYaml?: string;
  /**
   * @remarks
   * The name of the custom job.
   * 
   * This parameter is required.
   * 
   * @example
   * customJob1
   */
  customJobName?: string;
  /**
   * @remarks
   * The environment ID.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The status of the custom job. Valid values: run and stop.
   * 
   * @example
   * run
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunLang: 'AliyunLang',
      configYaml: 'ConfigYaml',
      customJobName: 'CustomJobName',
      environmentId: 'EnvironmentId',
      regionId: 'RegionId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunLang: 'string',
      configYaml: 'string',
      customJobName: 'string',
      environmentId: 'string',
      regionId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEnvCustomJobResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code or error code.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The result of the operation.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * C21AB7CF-B7AF-410F-BD61-82D1567F****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEnvCustomJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateEnvCustomJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateEnvCustomJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEnvPodMonitorRequest extends $tea.Model {
  /**
   * @remarks
   * The language. Valid values:
   * 
   * *   zh (default value): Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  aliyunLang?: string;
  /**
   * @remarks
   * The YAML configuration file of the ServiceMonitor.
   * 
   * This parameter is required.
   * 
   * @example
   * Refer to supplementary instructions.
   */
  configYaml?: string;
  /**
   * @remarks
   * Checks whether the format is valid and whether targets are matched.
   * 
   * @example
   * true
   */
  dryRun?: boolean;
  /**
   * @remarks
   * The environment ID.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The namespace where the PodMonitor resides.
   * 
   * This parameter is required.
   * 
   * @example
   * arms-prom
   */
  namespace?: string;
  /**
   * @remarks
   * The name of the PodMonitor.
   * 
   * This parameter is required.
   * 
   * @example
   * arms-admin-pm1
   */
  podMonitorName?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunLang: 'AliyunLang',
      configYaml: 'ConfigYaml',
      dryRun: 'DryRun',
      environmentId: 'EnvironmentId',
      namespace: 'Namespace',
      podMonitorName: 'PodMonitorName',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunLang: 'string',
      configYaml: 'string',
      dryRun: 'boolean',
      environmentId: 'string',
      namespace: 'string',
      podMonitorName: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEnvPodMonitorResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code.
   * 
   * >  The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned struct.
   */
  data?: UpdateEnvPodMonitorResponseBodyData;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * C21AB7CF-B7AF-410F-BD61-82D1567F****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: UpdateEnvPodMonitorResponseBodyData,
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEnvPodMonitorResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateEnvPodMonitorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateEnvPodMonitorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEnvServiceMonitorRequest extends $tea.Model {
  /**
   * @remarks
   * The language. Valid values: zh and en. Default value: zh.
   * 
   * @example
   * zh
   */
  aliyunLang?: string;
  /**
   * @remarks
   * The YAML configuration string.
   * 
   * This parameter is required.
   * 
   * @example
   * Refer to supplementary instructions.
   */
  configYaml?: string;
  /**
   * @remarks
   * Specifies whether to perform only a dry run, without performing the actual request.
   * 
   * @example
   * true
   */
  dryRun?: boolean;
  /**
   * @remarks
   * The environment ID.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The namespace where the ServiceMonitor is located.
   * 
   * This parameter is required.
   * 
   * @example
   * arms-prom
   */
  namespace?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The name of the ServiceMonitor.
   * 
   * This parameter is required.
   * 
   * @example
   * serviceMonitor1
   */
  serviceMonitorName?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunLang: 'AliyunLang',
      configYaml: 'ConfigYaml',
      dryRun: 'DryRun',
      environmentId: 'EnvironmentId',
      namespace: 'Namespace',
      regionId: 'RegionId',
      serviceMonitorName: 'ServiceMonitorName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunLang: 'string',
      configYaml: 'string',
      dryRun: 'boolean',
      environmentId: 'string',
      namespace: 'string',
      regionId: 'string',
      serviceMonitorName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEnvServiceMonitorResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned struct.
   */
  data?: UpdateEnvServiceMonitorResponseBodyData;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1A474FF8-7861-4D00-81B5-5BC3DA4E****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: UpdateEnvServiceMonitorResponseBodyData,
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEnvServiceMonitorResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateEnvServiceMonitorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateEnvServiceMonitorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEnvironmentRequest extends $tea.Model {
  /**
   * @remarks
   * The language. Valid values: zh and en. Default value: zh.
   * 
   * @example
   * zh
   */
  aliyunLang?: string;
  /**
   * @remarks
   * The environment ID.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The name of the environment instance.
   * 
   * @example
   * env1
   */
  environmentName?: string;
  /**
   * @remarks
   * The payable resource plan. Valid values:
   * 
   * *   If the EnvironmentType parameter is set to CS, set the value to CS_Basic or CS_Pro. Default value: CS_Basic.
   * *   Otherwise, leave the parameter empty.
   * 
   * @example
   * CS_Basic
   */
  feePackage?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunLang: 'AliyunLang',
      environmentId: 'EnvironmentId',
      environmentName: 'EnvironmentName',
      feePackage: 'FeePackage',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunLang: 'string',
      environmentId: 'string',
      environmentName: 'string',
      feePackage: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEnvironmentResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The result of the operation.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 70675725-8F11-4817-8106-CFE0AD71****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEnvironmentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateEnvironmentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateEnvironmentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGrafanaWorkspaceRequest extends $tea.Model {
  /**
   * @remarks
   * The language. Valid values: zh and en. Default value: zh.
   * 
   * @example
   * zh
   */
  aliyunLang?: string;
  /**
   * @remarks
   * The description of the workspace.
   */
  description?: string;
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * grafana-cn-4xl3g******
   */
  grafanaWorkspaceId?: string;
  /**
   * @remarks
   * The workspace name.
   * 
   * @example
   * testGrafana
   */
  grafanaWorkspaceName?: string;
  /**
   * @remarks
   * The region ID. Default value: `cn-hangzhou`.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunLang: 'AliyunLang',
      description: 'Description',
      grafanaWorkspaceId: 'GrafanaWorkspaceId',
      grafanaWorkspaceName: 'GrafanaWorkspaceName',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunLang: 'string',
      description: 'string',
      grafanaWorkspaceId: 'string',
      grafanaWorkspaceName: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGrafanaWorkspaceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code returned for the request. Valid values:
   * 
   * *   `2XX`: The request is successful.
   * *   `3XX`: A redirection message is returned.
   * *   `4XX`: The request is invalid.
   * *   `5XX`: A server error occurs.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Indicates whether the update is successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error message returned for the request.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 16AF921B-8187-489F-9913-43C808B4****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The ID of the trace. The ID is used to query the details of a request.
   * 
   * @example
   * eac0a8048716731735000007137d000b
   */
  traceId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      traceId: 'TraceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'boolean',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
      traceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGrafanaWorkspaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGrafanaWorkspaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGrafanaWorkspaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGrafanaWorkspaceVersionRequest extends $tea.Model {
  /**
   * @remarks
   * The language. Valid values: zh and en. Default value: zh.
   * 
   * @example
   * zh
   */
  aliyunLang?: string;
  /**
   * @remarks
   * The Grafana version.
   * 
   * This parameter is required.
   * 
   * @example
   * 10.0.x
   */
  grafanaVersion?: string;
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * grafana-cn-4xl3g******
   */
  grafanaWorkspaceId?: string;
  /**
   * @remarks
   * The region ID. Default value: cn-hangzhou.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunLang: 'AliyunLang',
      grafanaVersion: 'GrafanaVersion',
      grafanaWorkspaceId: 'GrafanaWorkspaceId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunLang: 'string',
      grafanaVersion: 'string',
      grafanaWorkspaceId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGrafanaWorkspaceVersionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code returned for the request. Valid values:
   * 
   * *   `2XX`: The request is successful.
   * *   `3XX`: A redirection message is returned.
   * *   `4XX`: The request is invalid.
   * *   `5XX`: A server error occurs.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Indicates whether the update is successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error message returned for the request.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 2A0CEDF1-06FE-44AC-8E21-21A5BE65****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The ID of the trace. The ID is used to query the details of a request.
   * 
   * @example
   * eac0a8048716731735000007137d000b
   */
  traceId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      traceId: 'TraceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'boolean',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
      traceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGrafanaWorkspaceVersionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGrafanaWorkspaceVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGrafanaWorkspaceVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateIntegrationRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to automatically clear alert events. Valid values:
   * 
   * *   true (default)
   * *   false
   * 
   * @example
   * true
   */
  autoRecover?: boolean;
  /**
   * @remarks
   * The description of the alert integration.
   * 
   * @example
   * Test
   */
  description?: string;
  /**
   * @remarks
   * The fields whose values are deduplicated.
   * 
   * @example
   * LABEL.dimensions::LABEL.ruleId
   */
  duplicateKey?: string;
  /**
   * @remarks
   * The extended mapped fields are mapped to the fields of ARMS alerts. For more information, see the description of the ExtendedFieldRedefineRules parameter.
   * 
   * @example
   * [
   *     {
   *         "redefineType":"EXTRACT",
   *         "matchExpression":null,
   *         "fieldName":"dimensions",
   *         "expression":null,
   *         "mappingRuleList":[
   * 
   *         ],
   *         "name":"dimensions",
   *         "integrationId":1234,
   *         "jsonPath":"$.dimensions",
   *         "id":10013,
   *         "fieldType":"LABEL"
   *     },
   *     {
   *         "redefineType":"EXTRACT",
   *         "matchExpression":null,
   *         "fieldName":"expression",
   *         "expression":null,
   *         "mappingRuleList":[
   * 
   *         ],
   *         "name":"expression",
   *         "integrationId":1234,
   *         "jsonPath":"$.expression",
   *         "id":10014,
   *         "fieldType":"LABEL"
   *     }
   * ]
   */
  extendedFieldRedefineRules?: string;
  /**
   * @remarks
   * The predefined mapped fields are mapped to the fields of ARMS alerts. The predefined mapped fields were generated when the alert integration was created. For more information, see the description of the FieldRedefineRules parameter.
   * 
   * @example
   * [ { "redefineType":"EXTRACT", "matchExpression":null, "fieldName":"alertname", "expression":null, "mappingRuleList":[ ], "name":"Alert name", "integrationId":1234, "jsonPath":"$.alertName", "id":10001, "fieldType":"LABEL" }, { "redefineType":"MAP", "matchExpression":null, "fieldName":"severity", "expression":null, "mappingRuleList":[ { "mappingValue":"critical", "mappingName":"P1", "mappingType":"MAP", "originValue":"CRITICAL" }, { "mappingValue":"error", "mappingName":"P2", "mappingType":"MAP", "originValue":"WARN" }, { "mappingValue":"warning", "mappingName":"P3", "mappingType":"MAP", "originValue":"INFO" } ], "name":"Alert level", "integrationId":1234, "jsonPath":"$.triggerLevel", "id":10002, "fieldType":"LABEL" }, { "redefineType":"EXTRACT", "matchExpression":null, "fieldName":"message", "expression":"{{$labels.namespace}} / {{$labels.dimensions}} Alert content {{ $labels.alertname }}, Current value {{$value}}.", "mappingRuleList":[ ], "name":"Alert description", "integrationId":1234, "jsonPath":null, "id":10003, "fieldType":"ANNOTATION" }, { "redefineType":"EXTRACT", "matchExpression":null, "fieldName":"value", "expression":null, "mappingRuleList":[ ], "name":"Alert sample value", "integrationId":1234, "jsonPath":"$.curValue", "id":10004, "fieldType":"ANNOTATION" }, { "redefineType":"EXTRACT", "matchExpression":null, "fieldName":"source", "expression":null, "mappingRuleList":[ ], "name":"Source", "integrationId":1234, "jsonPath":null, "id":10007, "fieldType":"LABEL" }, { "redefineType":"ADD", "matchExpression":null, "fieldName":"generatorUrl", "expression":"https://cloudmonitor.console.aliyun.com/index.htm#/alarmInfo/name={{$labels.ruleId}}\\&searchValue=\\&searchType=name\\&searchProduct=/history/all/searchKey:{{$labels.ruleId}},startTime:{{sub $startsAt 300000}},endTime:{{$endsAt}}", "mappingRuleList":[ ], "name":"Event URL", "integrationId":1234, "jsonPath":"https://cloudmonitor.console.aliyun.com/index.htm#/alarmInfo/name={{$labels.ruleId}}\\&searchValue=\\&searchType=name\\&searchProduct=/history/all/searchKey:{{$labels.ruleId}},startTime:{{sub $startsAt 300000}},endTime:{{$endsAt}}", "id":10012, "fieldType":"GENERATE_URL" } ]
   */
  fieldRedefineRules?: string;
  /**
   * @remarks
   * The field for clearing alert events. The system queries alert events based on the field of alert clearing events and clears the alert events.
   * 
   * > Only the Log Service alert integration supports the parameter.
   * 
   * @example
   * $.status
   */
  initiativeRecoverField?: string;
  /**
   * @remarks
   * The value of the field for clearing alert events. The system queries alert events based on the field of alert clearing events and clears the alert events.
   * 
   * > Only the Log Service alert integration supports the parameter.
   * 
   * @example
   * ok
   */
  initiativeRecoverValue?: string;
  /**
   * @remarks
   * The ID of the alert integration.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  integrationId?: number;
  /**
   * @remarks
   * The name of the alert integration.
   * 
   * This parameter is required.
   * 
   * @example
   * CloudMonitor integration
   */
  integrationName?: string;
  /**
   * @remarks
   * The service of the alert integration. Valid values:
   * 
   * *   CLOUD_MONITOR: CloudMonitor
   * *   LOG_SERVICE: Log Service
   * 
   * This parameter is required.
   * 
   * @example
   * CLOUD_MONITOR
   */
  integrationProductType?: string;
  /**
   * @remarks
   * The activity of the alert integration
   * 
   * @example
   * ready
   */
  liveness?: string;
  /**
   * @remarks
   * The period of time within which alert events are automatically cleared. Unit: seconds. Default value: 300.
   * 
   * @example
   * 300
   */
  recoverTime?: number;
  /**
   * @remarks
   * The total number of alert events and the number of abnormal alert events in the last hour.
   * 
   * @example
   * [0,0]
   */
  stat?: string;
  /**
   * @remarks
   * Indicates whether the alert integration was enabled. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  state?: boolean;
  static names(): { [key: string]: string } {
    return {
      autoRecover: 'AutoRecover',
      description: 'Description',
      duplicateKey: 'DuplicateKey',
      extendedFieldRedefineRules: 'ExtendedFieldRedefineRules',
      fieldRedefineRules: 'FieldRedefineRules',
      initiativeRecoverField: 'InitiativeRecoverField',
      initiativeRecoverValue: 'InitiativeRecoverValue',
      integrationId: 'IntegrationId',
      integrationName: 'IntegrationName',
      integrationProductType: 'IntegrationProductType',
      liveness: 'Liveness',
      recoverTime: 'RecoverTime',
      stat: 'Stat',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRecover: 'boolean',
      description: 'string',
      duplicateKey: 'string',
      extendedFieldRedefineRules: 'string',
      fieldRedefineRules: 'string',
      initiativeRecoverField: 'string',
      initiativeRecoverValue: 'string',
      integrationId: 'number',
      integrationName: 'string',
      integrationProductType: 'string',
      liveness: 'string',
      recoverTime: 'number',
      stat: 'string',
      state: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateIntegrationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The Information about the alert integration.
   */
  integration?: UpdateIntegrationResponseBodyIntegration;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 34ED024E-9E31-434A-9E4E-D9D15C3****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      integration: 'Integration',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      integration: UpdateIntegrationResponseBodyIntegration,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateIntegrationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateIntegrationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateIntegrationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMetricDropRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the Prometheus instance.
   * 
   * @example
   * c3ca36c8e2693403d85c0d9f8bb1d7b6c
   */
  clusterId?: string;
  /**
   * @remarks
   * The list of discarded metrics. Specify one metric name in each line.
   * 
   * @example
   * apiserver_request_duration_seconds_bucket
   * etcd_request_duration_seconds_bucket
   * apiserver_request_total
   * container_tasks_state
   */
  metricDrop?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      metricDrop: 'MetricDrop',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      metricDrop: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMetricDropResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response status. Valid values: 2XX: The request is successful. 3XX: A redirection message is returned. 4XX: The request is invalid. 5XX: A server error occurs.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CCCA4B88-BD7B-5A38-89AF-C09293BD4187
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMetricDropResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateMetricDropResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateMetricDropResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrometheusAlertRuleRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 3888704
   */
  alertId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * Prometheus_Alert
   */
  alertName?: string;
  /**
   * @example
   * [{"Value": "xxx","Name": "description"}]
   */
  annotations?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * c0bad479465464e1d8c1e641b0afb****
   */
  clusterId?: string;
  /**
   * @example
   * 10282
   */
  dispatchRuleId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1
   */
  duration?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 100 * (sum(rate(container_cpu_usage_seconds_total[1m])) by (pod_name) / sum(label_replace(kube_pod_container_resource_limits_cpu_cores, \\"pod_name\\", \\"$1\\", \\"pod\\", \\"(.*)\\")) by (pod_name))>75
   */
  expression?: string;
  /**
   * @example
   * [{"Value": "critical","Name": "severity"}]
   */
  labels?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  message?: string;
  /**
   * @example
   * ALERT_MANAGER
   */
  notifyType?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The tags.
   */
  tags?: UpdatePrometheusAlertRuleRequestTags[];
  type?: string;
  static names(): { [key: string]: string } {
    return {
      alertId: 'AlertId',
      alertName: 'AlertName',
      annotations: 'Annotations',
      clusterId: 'ClusterId',
      dispatchRuleId: 'DispatchRuleId',
      duration: 'Duration',
      expression: 'Expression',
      labels: 'Labels',
      message: 'Message',
      notifyType: 'NotifyType',
      regionId: 'RegionId',
      tags: 'Tags',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertId: 'number',
      alertName: 'string',
      annotations: 'string',
      clusterId: 'string',
      dispatchRuleId: 'number',
      duration: 'string',
      expression: 'string',
      labels: 'string',
      message: 'string',
      notifyType: 'string',
      regionId: 'string',
      tags: { 'type': 'array', 'itemType': UpdatePrometheusAlertRuleRequestTags },
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrometheusAlertRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  prometheusAlertRule?: UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule;
  /**
   * @example
   * 9FEA6D00-317F-45E3-9004-7FB8B0B7****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * True
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      prometheusAlertRule: 'PrometheusAlertRule',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      prometheusAlertRule: UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrometheusAlertRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdatePrometheusAlertRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdatePrometheusAlertRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrometheusGlobalViewRequest extends $tea.Model {
  /**
   * @remarks
   * To edit a GlobalView aggregated instance, do you require all passed child instances to be verified successfully before creating a GlobalView instance (optional, default to false):
   * - true
   * - false
   * 
   * @example
   * true
   */
  allSubClustersSuccess?: boolean;
  /**
   * @remarks
   * The ID of the Prometheus instance.
   * 
   * This parameter is required.
   * 
   * @example
   * global****
   */
  clusterId?: string;
  /**
   * @remarks
   * The name of the global aggregation instance.
   * 
   * @example
   * zyGlobalView
   */
  groupName?: string;
  /**
   * @remarks
   * The region ID of the global aggregation instance.
   * 
   * @example
   * cn-hangzhou
   */
  mostRegionId?: string;
  /**
   * @remarks
   * The ID of the region in which the Prometheus instance resides.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-shenzhen
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group to which the Prometheus instance belongs.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The data sources of the Prometheus instance for GlobalView.
   * 
   * This parameter is required.
   * 
   * @example
   * [ { "headers":{ }, "regionId":"cn-hangzhou", "sourceType":"AlibabaPrometheus", "extras":{ }, "clusterId":"c39a1048921e04f***********", "sourceName":"arms-luyao-test", "dataSource":"", "userId":"1672753***********" }, { "headers":{ }, "regionId":"cn-beijing", "sourceType":"AlibabaPrometheus", "extras":{ }, "clusterId":"c6b6485496d5b40***********", "sourceName":"agent-321-test", "dataSource":"", "userId":"1672753***********" }, { "headers":{ }, "regionId":"cn-zhangjiakou", "sourceType":"AlibabaPrometheus", "extras":{ }, "clusterId":"c261a4f3200c446***********", "sourceName":"zaifeng-cardinality-01", "dataSource":"", "userId":"1672753***********" } ]
   */
  subClustersJson?: string;
  static names(): { [key: string]: string } {
    return {
      allSubClustersSuccess: 'AllSubClustersSuccess',
      clusterId: 'ClusterId',
      groupName: 'GroupName',
      mostRegionId: 'MostRegionId',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      subClustersJson: 'SubClustersJson',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allSubClustersSuccess: 'boolean',
      clusterId: 'string',
      groupName: 'string',
      mostRegionId: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      subClustersJson: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrometheusGlobalViewResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned struct.
   */
  data?: UpdatePrometheusGlobalViewResponseBodyData;
  /**
   * @remarks
   * The error message that is returned if the request failed.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * E9C9DA3D-10FE-472E-9EEF-2D0A3E41****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: UpdatePrometheusGlobalViewResponseBodyData,
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrometheusGlobalViewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdatePrometheusGlobalViewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdatePrometheusGlobalViewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrometheusInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The number of days for which data is automatically archived after the storage expires. Valid values: 60, 90, 180, and 365. 0 indicates that the data is not archived.
   * 
   * @example
   * 90
   */
  archiveDuration?: number;
  /**
   * @remarks
   * The IP addresses or CIDR blocks for which password-free read is enabled. Separate multiple IP addresses with line breaks.
   * 
   * **if can be null:**
   * true
   */
  authFreeReadPolicy?: string;
  /**
   * @remarks
   * The IP addresses or CIDR blocks for which password-free write is enabled. Separate multiple IP addresses with line breaks.
   * 
   * **if can be null:**
   * true
   */
  authFreeWritePolicy?: string;
  /**
   * @remarks
   * The ID of the Prometheus instance.
   * 
   * This parameter is required.
   * 
   * @example
   * vpc-xxx
   */
  clusterId?: string;
  /**
   * @remarks
   * Specifies whether to enable password-free read.
   * 
   * **if can be null:**
   * true
   */
  enableAuthFreeRead?: boolean;
  /**
   * @remarks
   * Specifies whether to enable password-free write.
   * 
   * **if can be null:**
   * true
   */
  enableAuthFreeWrite?: boolean;
  /**
   * @remarks
   * Specifies whether to enable access token authentication.
   * 
   * **if can be null:**
   * true
   */
  enableAuthToken?: boolean;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The data storage duration. Unit: days.
   * 
   * @example
   * 90
   */
  storageDuration?: number;
  static names(): { [key: string]: string } {
    return {
      archiveDuration: 'ArchiveDuration',
      authFreeReadPolicy: 'AuthFreeReadPolicy',
      authFreeWritePolicy: 'AuthFreeWritePolicy',
      clusterId: 'ClusterId',
      enableAuthFreeRead: 'EnableAuthFreeRead',
      enableAuthFreeWrite: 'EnableAuthFreeWrite',
      enableAuthToken: 'EnableAuthToken',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      storageDuration: 'StorageDuration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      archiveDuration: 'number',
      authFreeReadPolicy: 'string',
      authFreeWritePolicy: 'string',
      clusterId: 'string',
      enableAuthFreeRead: 'boolean',
      enableAuthFreeWrite: 'boolean',
      enableAuthToken: 'boolean',
      regionId: 'string',
      resourceGroupId: 'string',
      storageDuration: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrometheusInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The result of the operation.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6A9AEA84-7186-4D8D-B498-4585C6A2****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrometheusInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdatePrometheusInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdatePrometheusInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrometheusIntegrationRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the Prometheus instance. Only a Prometheus instance for Container Service or a Prometheus instance for ECS is supported.
   * 
   * This parameter is required.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The exporter ID.
   * 
   * @example
   * 2893
   */
  instanceId?: number;
  /**
   * @remarks
   * The type of the integration.
   * 
   * This parameter is required.
   * 
   * @example
   * kafka, mysql, redis, snmp, emr, nubela, and tidb
   */
  integrationType?: string;
  /**
   * @remarks
   * The configurations of the exporter. The value is a JSON string.
   * 
   * This parameter is required.
   * 
   * @example
   * {
   *       "port": "5554",
   *       "name": "kafka-test12",
   *       "kafka_instance": "kafka-test",
   *       "__label_value": "kafka-test",
   *       "scrape_interval": 33,
   *       "metrics_path": "/metrics",
   *       "__label_key": "kafka-test"
   * }
   */
  param?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      instanceId: 'InstanceId',
      integrationType: 'IntegrationType',
      param: 'Param',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      instanceId: 'number',
      integrationType: 'string',
      param: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrometheusIntegrationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code or error code.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The struct returned.
   */
  data?: UpdatePrometheusIntegrationResponseBodyData;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * Successful
   */
  message?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 2DB771C3-D1BB-5363-8A5F-ADB2AF2948DB
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: UpdatePrometheusIntegrationResponseBodyData,
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrometheusIntegrationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdatePrometheusIntegrationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdatePrometheusIntegrationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrometheusMonitoringRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the Prometheus instance.
   * 
   * This parameter is required.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The monitoring configuration. The value is a YAML string.
   * 
   * This parameter is required.
   * 
   * @example
   * apiVersion: monitoring.coreos.com/v1
   * kind: ServiceMonitor
   * metadata:
   *   name: tomcat-demo
   *   namespace: default
   * spec:
   *   endpoints:
   *     - interval: 30s
   *       path: /metrics
   *       port: tomcat-monitor
   *   namespaceSelector:
   *     any: true
   *   selector:
   *     matchLabels:
   *       app: tomcat
   */
  configYaml?: string;
  /**
   * @remarks
   * The name of the monitoring configuration.
   * 
   * This parameter is required.
   * 
   * @example
   * podMonitor1
   */
  monitoringName?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The type of the monitoring configuration. 
   * Valid values for a Prometheus instance for Container Service: serviceMonitor, podMonitor, customJob, and probe. 
   * Valid values for a Prometheus instance for ECS: customJob and probe.
   * 
   * This parameter is required.
   * 
   * @example
   * podMonitor
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      configYaml: 'ConfigYaml',
      monitoringName: 'MonitoringName',
      regionId: 'RegionId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      configYaml: 'string',
      monitoringName: 'string',
      regionId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrometheusMonitoringResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The result of the operation.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 626037F5-FDEB-45B0-804C-B3C92797****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrometheusMonitoringResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdatePrometheusMonitoringResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdatePrometheusMonitoringResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrometheusMonitoringStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the Prometheus instance.
   * 
   * This parameter is required.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The name of the monitoring configuration.
   * 
   * This parameter is required.
   * 
   * @example
   * customJob1
   */
  monitoringName?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The status of the monitoring configuration. Valid values: run and stop. The status of Probe cannot be modified.
   * 
   * This parameter is required.
   * 
   * @example
   * run
   */
  status?: string;
  /**
   * @remarks
   * The type of the monitoring configuration. 
   * Valid values for a Prometheus instance for Container Service: serviceMonitor, podMonitor, and customJob. 
   * Valid value for a Prometheus instance for ECS: customJob. 
   * The status of probe cannot be modified.
   * 
   * This parameter is required.
   * 
   * @example
   * customJob
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      monitoringName: 'MonitoringName',
      regionId: 'RegionId',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      monitoringName: 'string',
      regionId: 'string',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrometheusMonitoringStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The result of the operation.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 21E85B16-75A6-429A-9F65-8AAC9A54****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrometheusMonitoringStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdatePrometheusMonitoringStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdatePrometheusMonitoringStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRumAppRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to restart the application the next day. Valid values: true and false.
   * 
   * @example
   * true
   */
  autoRestart?: boolean;
  /**
   * @remarks
   * The collection configurations of the mobile SDK. You can enable or disable collection configurations based on the app version.
   * 
   * @example
   * {\\"moduleConfig\\":{\\"enable\\":true,\\"defaultConfig\\":{\\"network\\":{\\"enable\\":true},\\"h5\\":{\\"enable\\":true},\\"routechange\\":{\\"enable\\":true},\\"crash\\":{\\"enable\\":true},\\"view\\":{\\"enable\\":true},\\"coollaunch\\":{\\"enable\\":true},\\"hotlaunch\\":{\\"enable\\":true},\\"action\\":{\\"enable\\":true},\\"lagstuck\\":{\\"enable\\":true},\\"lagfps\\":{\\"enable\\":true},\\"statechange\\":{\\"enable\\":true},\\"anr\\":{\\"enable\\":true},\\"customlog\\":{\\"enable\\":true},\\"customevent\\":{\\"enable\\":true},\\"custommetric\\":{\\"enable\\":true}},\\"versionConfigs\\":{\\"1.1.0\\":{\\"useCustom\\":true,\\"customConfig\\":{\\"network\\":{\\"enable\\":true},\\"h5\\":{\\"enable\\":true},\\"routechange\\":{\\"enable\\":true},\\"crash\\":{\\"enable\\":true},\\"view\\":{\\"enable\\":true},\\"coollaunch\\":{\\"enable\\":true},\\"hotlaunch\\":{\\"enable\\":true},\\"action\\":{\\"enable\\":true},\\"lagstuck\\":{\\"enable\\":false},\\"lagfps\\":{\\"enable\\":false},\\"statechange\\":{\\"enable\\":true},\\"anr\\":{\\"enable\\":true},\\"customlog\\":{\\"enable\\":true},\\"customevent\\":{\\"enable\\":true},\\"custommetric\\":{\\"enable\\":true}}},\\"1.2.0\\":{\\"useCustom\\":false,\\"customConfig\\":{}}}}}
   */
  backendServiceTraceRegion?: string;
  /**
   * @remarks
   * The collection configurations of the mobile SDK. You can enable or disable collection configurations based on the app version.
   * 
   * @example
   * {\\"moduleConfig\\":{\\"enable\\":true,\\"defaultConfig\\":{\\"network\\":{\\"enable\\":true},\\"h5\\":{\\"enable\\":true},\\"routechange\\":{\\"enable\\":true},\\"crash\\":{\\"enable\\":true},\\"view\\":{\\"enable\\":true},\\"coollaunch\\":{\\"enable\\":true},\\"hotlaunch\\":{\\"enable\\":true},\\"action\\":{\\"enable\\":true},\\"lagstuck\\":{\\"enable\\":true},\\"lagfps\\":{\\"enable\\":true},\\"statechange\\":{\\"enable\\":true},\\"anr\\":{\\"enable\\":true},\\"customlog\\":{\\"enable\\":true},\\"customevent\\":{\\"enable\\":true},\\"custommetric\\":{\\"enable\\":true}},\\"versionConfigs\\":{\\"1.1.0\\":{\\"useCustom\\":true,\\"customConfig\\":{\\"network\\":{\\"enable\\":true},\\"h5\\":{\\"enable\\":true},\\"routechange\\":{\\"enable\\":true},\\"crash\\":{\\"enable\\":true},\\"view\\":{\\"enable\\":true},\\"coollaunch\\":{\\"enable\\":true},\\"hotlaunch\\":{\\"enable\\":true},\\"action\\":{\\"enable\\":true},\\"lagstuck\\":{\\"enable\\":false},\\"lagfps\\":{\\"enable\\":false},\\"statechange\\":{\\"enable\\":true},\\"anr\\":{\\"enable\\":true},\\"customlog\\":{\\"enable\\":true},\\"customevent\\":{\\"enable\\":true},\\"custommetric\\":{\\"enable\\":true}}},\\"1.2.0\\":{\\"useCustom\\":false,\\"customConfig\\":{}}}}}
   */
  bonreeSDKConfigJson?: string;
  /**
   * @remarks
   * The description of the application.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * Specifies whether you want to subscribe to the application. Valid values: true and false.
   * 
   * @example
   * true
   */
  isSubscribe?: boolean;
  /**
   * @remarks
   * The alias of the application.
   * 
   * @example
   * Android Test
   */
  nickname?: string;
  /**
   * @remarks
   * The application ID.
   * 
   * This parameter is required.
   * 
   * @example
   * b5xxxxs@d8deedfa9bf****
   */
  pid?: string;
  /**
   * @remarks
   * Backend application deployment area (used in end-to-end link scenarios).
   * 
   * @example
   * cn-hangzhou
   */
  realRegionId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * Specifies whether to restart the application. Valid values: true and false.
   * 
   * @example
   * true
   */
  restart?: boolean;
  /**
   * @remarks
   * The service domain name of the application. You can create, modify, and delete service domain name configurations.
   * 
   * @example
   * {\\"Op\\":\\"Update\\",\\"Domain\\":\\"example.com\\",\\"Config\\":{\\"Description\\":\\"message\\",\\"Tracing\\":\\"true\\",\\"PropagatorTypes\\":[\\"sw8\\"]}}
   */
  serviceDomainOperationJson?: string;
  /**
   * @remarks
   * Specifies whether to stop the application. Valid values: true and false.
   * 
   * @example
   * true
   */
  stop?: boolean;
  static names(): { [key: string]: string } {
    return {
      autoRestart: 'AutoRestart',
      backendServiceTraceRegion: 'BackendServiceTraceRegion',
      bonreeSDKConfigJson: 'BonreeSDKConfigJson',
      description: 'Description',
      isSubscribe: 'IsSubscribe',
      nickname: 'Nickname',
      pid: 'Pid',
      realRegionId: 'RealRegionId',
      regionId: 'RegionId',
      restart: 'Restart',
      serviceDomainOperationJson: 'ServiceDomainOperationJson',
      stop: 'Stop',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRestart: 'boolean',
      backendServiceTraceRegion: 'string',
      bonreeSDKConfigJson: 'string',
      description: 'string',
      isSubscribe: 'boolean',
      nickname: 'string',
      pid: 'string',
      realRegionId: 'string',
      regionId: 'string',
      restart: 'boolean',
      serviceDomainOperationJson: 'string',
      stop: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRumAppResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The details of the returned results.
   */
  data?: UpdateRumAppResponseBodyData;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * message
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * E9C9DA3D-10FE-472E-9EEF-2D0A3E41****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: UpdateRumAppResponseBodyData,
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRumAppResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateRumAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateRumAppResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRumFileStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The file name.
   * 
   * @example
   * test.js.map
   */
  fileName?: string;
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * atc8xxxx
   * cf@d8deedfa9bf****
   */
  pid?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The size of the file. Unit: bytes.
   * 
   * @example
   * 20
   */
  size?: string;
  /**
   * @remarks
   * The status of the file. Valid values: SUCCESS and INIT.
   * 
   * @example
   * SUCCESS
   */
  status?: string;
  /**
   * @remarks
   * The unique ID of the file. If you do not set this parameter, the system automatically sets a UUID for you.
   * 
   * @example
   * MS4wLjAtbWFpbi4wZjM0NzRlOSxxxxxx
   */
  uuid?: string;
  /**
   * @remarks
   * The version number of the file.
   * 
   * @example
   * 1.0.0
   */
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      fileName: 'FileName',
      pid: 'Pid',
      regionId: 'RegionId',
      size: 'Size',
      status: 'Status',
      uuid: 'Uuid',
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileName: 'string',
      pid: 'string',
      regionId: 'string',
      size: 'string',
      status: 'string',
      uuid: 'string',
      versionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRumFileStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 626037F5-FDEB-45B0-804C-B3C92797****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRumFileStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateRumFileStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateRumFileStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTimingSyntheticTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The list of assertions.
   */
  availableAssertions?: UpdateTimingSyntheticTaskRequestAvailableAssertions[];
  /**
   * @remarks
   * The general settings.
   */
  commonSetting?: UpdateTimingSyntheticTaskRequestCommonSetting;
  /**
   * @remarks
   * The custom cycle.
   */
  customPeriod?: UpdateTimingSyntheticTaskRequestCustomPeriod;
  /**
   * @remarks
   * The detection frequency. Valid values: 1m, 5m, 10m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, and 24h.
   * 
   * @example
   * 5m
   */
  frequency?: string;
  /**
   * @remarks
   * The monitoring configurations.
   */
  monitorConf?: UpdateTimingSyntheticTaskRequestMonitorConf;
  /**
   * @remarks
   * The list of monitoring points.
   */
  monitors?: UpdateTimingSyntheticTaskRequestMonitors[];
  /**
   * @remarks
   * The name of the task.
   * 
   * @example
   * AlibabaCloud DNS Task
   */
  name?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The resource group ID.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The list of tags.
   */
  tags?: UpdateTimingSyntheticTaskRequestTags[];
  /**
   * @remarks
   * The ID of the synthetic monitoring task.
   * 
   * @example
   * 5308a2691f59422c8c3b7aeccxxxxxxx
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      availableAssertions: 'AvailableAssertions',
      commonSetting: 'CommonSetting',
      customPeriod: 'CustomPeriod',
      frequency: 'Frequency',
      monitorConf: 'MonitorConf',
      monitors: 'Monitors',
      name: 'Name',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      tags: 'Tags',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableAssertions: { 'type': 'array', 'itemType': UpdateTimingSyntheticTaskRequestAvailableAssertions },
      commonSetting: UpdateTimingSyntheticTaskRequestCommonSetting,
      customPeriod: UpdateTimingSyntheticTaskRequestCustomPeriod,
      frequency: 'string',
      monitorConf: UpdateTimingSyntheticTaskRequestMonitorConf,
      monitors: { 'type': 'array', 'itemType': UpdateTimingSyntheticTaskRequestMonitors },
      name: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      tags: { 'type': 'array', 'itemType': UpdateTimingSyntheticTaskRequestTags },
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTimingSyntheticTaskShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The list of assertions.
   */
  availableAssertionsShrink?: string;
  /**
   * @remarks
   * The general settings.
   */
  commonSettingShrink?: string;
  /**
   * @remarks
   * The custom cycle.
   */
  customPeriodShrink?: string;
  /**
   * @remarks
   * The detection frequency. Valid values: 1m, 5m, 10m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, and 24h.
   * 
   * @example
   * 5m
   */
  frequency?: string;
  /**
   * @remarks
   * The monitoring configurations.
   */
  monitorConfShrink?: string;
  /**
   * @remarks
   * The list of monitoring points.
   */
  monitorsShrink?: string;
  /**
   * @remarks
   * The name of the task.
   * 
   * @example
   * AlibabaCloud DNS Task
   */
  name?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The resource group ID.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The list of tags.
   */
  tagsShrink?: string;
  /**
   * @remarks
   * The ID of the synthetic monitoring task.
   * 
   * @example
   * 5308a2691f59422c8c3b7aeccxxxxxxx
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      availableAssertionsShrink: 'AvailableAssertions',
      commonSettingShrink: 'CommonSetting',
      customPeriodShrink: 'CustomPeriod',
      frequency: 'Frequency',
      monitorConfShrink: 'MonitorConf',
      monitorsShrink: 'Monitors',
      name: 'Name',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      tagsShrink: 'Tags',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableAssertionsShrink: 'string',
      commonSettingShrink: 'string',
      customPeriodShrink: 'string',
      frequency: 'string',
      monitorConfShrink: 'string',
      monitorsShrink: 'string',
      name: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      tagsShrink: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTimingSyntheticTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The struct returned.
   */
  data?: UpdateTimingSyntheticTaskResponseBodyData;
  /**
   * @remarks
   * The message returned.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F7781D4A-2818-41E7-B7BB-79D809E9****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: UpdateTimingSyntheticTaskResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTimingSyntheticTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTimingSyntheticTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTimingSyntheticTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWebhookRequest extends $tea.Model {
  /**
   * @remarks
   * The notification template that is sent when an alert is triggered. This parameter is required if the **Method** parameter is set to **Post**. You can use the $content placeholder to specify the notification content. The content cannot exceed 500 characters in length.
   * 
   * This parameter is required.
   * 
   * @example
   * { "Alert name":"{{ .commonLabels.alertname }}{{if .commonLabels.clustername }}", "Cluster name":"{{ .commonLabels.clustername }} {{ end }}{{if eq "app" .commonLabels._aliyun_arms_involvedObject_kind }}", "Application name":"{{ .commonLabels._aliyun_arms_involvedObject_name }} {{ end }}", "Notification policy":"{{ .dispatchRuleName }}", "Alert time":"{{ .startTime }}", "Alert content":"{{ for .alerts }} {{ .annotations.message }} {{ end }}" }
   */
  body?: string;
  /**
   * @remarks
   * The ID of the webhook alert contact. You can call the **SearchAlertContact** operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 48716
   */
  contactId?: number;
  /**
   * @remarks
   * The name of the webhook alert contact.
   * 
   * This parameter is required.
   * 
   * @example
   * Webhook alert
   */
  contactName?: string;
  /**
   * @remarks
   * The HTTP request headers.
   * 
   * @example
   * [{"Content-Type":"application/json"}]
   */
  httpHeaders?: string;
  /**
   * @remarks
   * The parameters in the HTTP request.
   * 
   * @example
   * [{"name":"mike"}]
   */
  httpParams?: string;
  /**
   * @remarks
   * The HTTP request method. Valid values:
   * 
   * *   `Get`
   * *   `Post`
   * 
   * This parameter is required.
   * 
   * @example
   * Post
   */
  method?: string;
  /**
   * @remarks
   * The notification template that is sent when an alert is resolved. This parameter is required if the **Method** parameter is set to **Post**. You can use the $content placeholder to specify the notification content. The content cannot exceed 500 characters in length.
   * 
   * @example
   * { "Alert name":"{{ .commonLabels.alertname }}{{if .commonLabels.clustername }}", "Cluster name":"{{ .commonLabels.clustername }} {{ end }}{{if eq "app" .commonLabels._aliyun_arms_involvedObject_kind }}", "Application name":"{{ .commonLabels._aliyun_arms_involvedObject_name }} {{ end }}", "Notification policy":"{{ .dispatchRuleName }}", "Recovery time":"{{ .endTime }}", "Alert content":"{{ for .alerts }} {{ .annotations.message }} {{ end }}" }
   */
  recoverBody?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The URL of the HTTP request method.
   * 
   * This parameter is required.
   * 
   * @example
   * https://oapi.dingtalk.com/robot/send?access_token=e1a049121ddbfce1ca963d115ef88cc7219583c4fb79fe6e398fbfb688******
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      body: 'Body',
      contactId: 'ContactId',
      contactName: 'ContactName',
      httpHeaders: 'HttpHeaders',
      httpParams: 'HttpParams',
      method: 'Method',
      recoverBody: 'RecoverBody',
      regionId: 'RegionId',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      body: 'string',
      contactId: 'number',
      contactName: 'string',
      httpHeaders: 'string',
      httpParams: 'string',
      method: 'string',
      recoverBody: 'string',
      regionId: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWebhookResponseBody extends $tea.Model {
  /**
   * @remarks
   * The result returned. Valid values:
   * 
   * *   `true`: The modification is successful.
   * *   `false`: The modification fails.
   * 
   * @example
   * true
   */
  isSuccess?: boolean;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 16AF921B-8187-489F-9913-43C808B4****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      isSuccess: 'IsSuccess',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isSuccess: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWebhookResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateWebhookResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateWebhookResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpgradeAddonReleaseRequest extends $tea.Model {
  /**
   * @remarks
   * The version of the add-on.
   * 
   * This parameter is required.
   * 
   * @example
   * 0.0.2
   */
  addonVersion?: string;
  /**
   * @remarks
   * Specifies whether to perform only a dry run, without performing the actual request.
   * 
   * @example
   * false
   */
  dryRun?: boolean;
  /**
   * @remarks
   * The environment ID.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The name of the release.
   * 
   * This parameter is required.
   * 
   * @example
   * mysql-1695372983039
   */
  releaseName?: string;
  /**
   * @remarks
   * The metadata information.
   * 
   * This parameter is required.
   * 
   * @example
   * {"host":"mysql-service.default","port":3306,"username":"root","password":"roots"}
   */
  values?: string;
  static names(): { [key: string]: string } {
    return {
      addonVersion: 'AddonVersion',
      dryRun: 'DryRun',
      environmentId: 'EnvironmentId',
      regionId: 'RegionId',
      releaseName: 'ReleaseName',
      values: 'Values',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addonVersion: 'string',
      dryRun: 'boolean',
      environmentId: 'string',
      regionId: 'string',
      releaseName: 'string',
      values: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpgradeAddonReleaseResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  data?: string;
  /**
   * @remarks
   * The error message returned if the request parameters are invalid.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 27E653FA-5958-45BE-8AA9-14D884DC****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpgradeAddonReleaseResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpgradeAddonReleaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpgradeAddonReleaseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpgradeEnvironmentFeatureRequest extends $tea.Model {
  /**
   * @remarks
   * The language. Valid values: zh and en. Default value: zh.
   * 
   * @example
   * zh
   */
  aliyunLang?: string;
  /**
   * @remarks
   * The environment ID.
   * 
   * This parameter is required.
   * 
   * @example
   * env-xxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The feature name. Valid values: app-agent-pilot, metric-agent, ebpf-agent, and service-check.
   * 
   * This parameter is required.
   * 
   * @example
   * metric-agent
   */
  featureName?: string;
  /**
   * @remarks
   * The version of the feature.
   * 
   * @example
   * 1.1.17
   */
  featureVersion?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * Specifies whether to enable service discovery. For PodAnnotation, set the value to run or mini. For PodMonitor and ServiceMonitor, set the value to true or false.
   * 
   * @example
   * {"PodAnnotation":"run"}
   */
  values?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunLang: 'AliyunLang',
      environmentId: 'EnvironmentId',
      featureName: 'FeatureName',
      featureVersion: 'FeatureVersion',
      regionId: 'RegionId',
      values: 'Values',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunLang: 'string',
      environmentId: 'string',
      featureName: 'string',
      featureVersion: 'string',
      regionId: 'string',
      values: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpgradeEnvironmentFeatureResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code. The status code 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  code?: number;
  /**
   * @remarks
   * The status of the job.
   */
  data?: { [key: string]: string };
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * success
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 01FF8DD9-A09C-47A1-895A-B6E321BE77B6
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      data: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpgradeEnvironmentFeatureResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpgradeEnvironmentFeatureResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpgradeEnvironmentFeatureResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadRequest extends $tea.Model {
  /**
   * @remarks
   * The version of the SourceMap file.
   * 
   * @example
   * 0.0.0
   */
  edition?: string;
  /**
   * @remarks
   * The string of the SourceMap file.
   * 
   * @example
   * test file content
   */
  file?: string;
  /**
   * @remarks
   * The name of the SourceMap file.
   * 
   * This parameter is required.
   * 
   * @example
   * test.js.map
   */
  fileName?: string;
  /**
   * @remarks
   * The application ID.
   * 
   * Log on to the **ARMS console**. In the left-side navigation pane, choose **Browser Monitoring** > **Browser Monitoring**. On the Browser Monitoring page, click the name of an application. The URL in the address bar contains the process ID (PID) of the application. The PID is indicated in the pid=xxx format. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is eb4zdose6v%409781be0f44d\\*\\*\\*\\*, you must replace %40 with @ to obtain eb4zdose6v@9781be0f44d\\*\\*\\*\\*.
   * 
   * This parameter is required.
   * 
   * @example
   * b590lhguqs@8cc3f6354******
   */
  pid?: string;
  /**
   * @remarks
   * The ID of the region to which the SourceMap file is uploaded.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * We recommend that you do not specify this parameter.
   * 
   * @example
   * null
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      edition: 'Edition',
      file: 'File',
      fileName: 'FileName',
      pid: 'Pid',
      regionId: 'RegionId',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      edition: 'string',
      file: 'string',
      fileName: 'string',
      pid: 'string',
      regionId: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * A5EC8221-08F2-4C95-9AF1-49FD998C****
   */
  requestId?: string;
  /**
   * @remarks
   * The returned data.
   */
  uploadResult?: UploadResponseBodyUploadResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      uploadResult: 'UploadResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      uploadResult: UploadResponseBodyUploadResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UploadResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UploadResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrafanaWorkspaceTags extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'key',
      value: 'value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAliClusterIdsToPrometheusGlobalViewResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The Info-level information.
   * 
   * @example
   * {regionId: the region where the aggregation instance resides. globalViewClusterId: the ID of the aggregation instance. failedClusterIds: the ID of the cluster that failed to be added. A cluster may fail to be added because the specified cluster ID is invalid or the cluster is added across continents.}
   */
  info?: string;
  /**
   * @remarks
   * The additional information.
   * 
   * @example
   * OK
   */
  msg?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * *   `true`: The request was successful.
   * *   `false`: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      info: 'Info',
      msg: 'Msg',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      info: 'string',
      msg: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPrometheusGlobalViewRequestTag extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * http.status_code
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * 200
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPrometheusGlobalViewResponseBodyDataInfo extends $tea.Model {
  /**
   * @remarks
   * The list of instances that failed to be added.
   * 
   * @example
   * [{"sourceName": "Data source name- ArmsPrometheus","sourceType":"AlibabaPrometheus","userId":"UserID","clusterId":"ClusterId",}]
   */
  failedInstances?: string;
  /**
   * @remarks
   * The ID of the global aggregation instance.
   * 
   * @example
   * global-v2-cn-1483223059272121-jmjjfznz
   */
  globalViewClusterId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      failedInstances: 'FailedInstances',
      globalViewClusterId: 'GlobalViewClusterId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failedInstances: 'string',
      globalViewClusterId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPrometheusGlobalViewResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The Info-level information.
   */
  info?: AddPrometheusGlobalViewResponseBodyDataInfo;
  /**
   * @remarks
   * The additional information.
   * 
   * @example
   * OK
   */
  msg?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      info: 'Info',
      msg: 'Msg',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      info: AddPrometheusGlobalViewResponseBodyDataInfo,
      msg: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPrometheusGlobalViewByAliClusterIdsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The Info-level information.
   * 
   * @example
   * {regionId: the region where the aggregation instance resides. globalViewClusterId: the ID of the aggregation instance. failedClusterIds: the ID of the cluster that failed to be added. A cluster may fail to be added because the specified cluster ID is invalid or the cluster is added across continents.}
   */
  info?: string;
  /**
   * @remarks
   * The additional information.
   * 
   * @example
   * success
   */
  msg?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      info: 'Info',
      msg: 'Msg',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      info: 'string',
      msg: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPrometheusIntegrationResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the exporter.
   * 
   * @example
   * 2829
   */
  instanceId?: number;
  /**
   * @remarks
   * The name of the exporter.
   * 
   * @example
   * hw-cloud02
   */
  instanceName?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'number',
      instanceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AppendInstancesToPrometheusGlobalViewResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The Info-level information.
   * 
   * @example
   * {regionId: the region where the aggregation instance resides. globalViewClusterId: the ID of the aggregation instance. failedInstances: the ID of the object that failed to be added.}
   */
  info?: string;
  /**
   * @remarks
   * The additional information.
   * 
   * @example
   * OK
   */
  msg?: string;
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * *   `true`: The call was successful.
   * *   `false`: The call failed.
   * 
   * @example
   * True
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      info: 'Info',
      msg: 'Msg',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      info: 'string',
      msg: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeResourceGroupResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-aek2vezare****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The resource ID.
   * 
   * @example
   * ggxw4lnjuz@cfd34a78f******
   */
  resourceId?: string;
  static names(): { [key: string]: string } {
    return {
      resourceGroupId: 'ResourceGroupId',
      resourceId: 'ResourceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceGroupId: 'string',
      resourceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEnvPodMonitorResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * Indicates whether targets are matched.
   * 
   * @example
   * Match successful.
   */
  matchedMsg?: string;
  /**
   * @remarks
   * The number of matched targets.
   * 
   * @example
   * 1
   */
  matchedTargetCount?: string;
  /**
   * @remarks
   * The namespace.
   * 
   * @example
   * arms-prom
   */
  namespace?: string;
  /**
   * @remarks
   * The name of the created PodMonitor.
   * 
   * @example
   * arms-admin-pm1
   */
  podMonitorName?: string;
  static names(): { [key: string]: string } {
    return {
      matchedMsg: 'MatchedMsg',
      matchedTargetCount: 'MatchedTargetCount',
      namespace: 'Namespace',
      podMonitorName: 'PodMonitorName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      matchedMsg: 'string',
      matchedTargetCount: 'string',
      namespace: 'string',
      podMonitorName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEnvServiceMonitorResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * Indicates whether targets are matched.
   * 
   * @example
   * Match successful.
   */
  matchedMsg?: string;
  /**
   * @remarks
   * The number of matched targets.
   * 
   * @example
   * 1
   */
  matchedTargetCount?: number;
  /**
   * @remarks
   * The namespace.
   * 
   * @example
   * arms-prom
   */
  namespace?: string;
  /**
   * @remarks
   * The name of the created ServiceMonitor.
   * 
   * @example
   * arms-admin1
   */
  serviceMonitorName?: string;
  static names(): { [key: string]: string } {
    return {
      matchedMsg: 'MatchedMsg',
      matchedTargetCount: 'MatchedTargetCount',
      namespace: 'Namespace',
      serviceMonitorName: 'ServiceMonitorName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      matchedMsg: 'string',
      matchedTargetCount: 'number',
      namespace: 'string',
      serviceMonitorName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEnvironmentRequestTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * TestKey
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * TestValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateGrafanaWorkspaceRequestTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * TestKey
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * TestValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateIntegrationResponseBodyIntegration extends $tea.Model {
  /**
   * @remarks
   * Indicates whether alert events are automatically cleared. Default value: true. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  autoRecover?: boolean;
  /**
   * @remarks
   * The description of the alert integration.
   * 
   * @example
   * Test
   */
  description?: string;
  /**
   * @remarks
   * The ID of the alert integration.
   * 
   * @example
   * 1234
   */
  integrationId?: number;
  /**
   * @remarks
   * The name of the alert integration.
   * 
   * @example
   * CloudMonitor integration
   */
  integrationName?: string;
  /**
   * @remarks
   * The service of the alert integration. Valid values:
   * 
   * *   CLOUD_MONITOR: CloudMonitor
   * *   LOG_SERVICE: Log Service
   * 
   * @example
   * CLOUD_MONITOR
   */
  integrationProductType?: string;
  /**
   * @remarks
   * The period of time within which alert events are automatically cleared. Unit: seconds. Default value: 300.
   * 
   * @example
   * 300
   */
  recoverTime?: number;
  static names(): { [key: string]: string } {
    return {
      autoRecover: 'AutoRecover',
      description: 'Description',
      integrationId: 'IntegrationId',
      integrationName: 'IntegrationName',
      integrationProductType: 'IntegrationProductType',
      recoverTime: 'RecoverTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRecover: 'boolean',
      description: 'string',
      integrationId: 'number',
      integrationName: 'string',
      integrationProductType: 'string',
      recoverTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateAlertRuleRequestMarkTags extends $tea.Model {
  /**
   * @remarks
   * The Tag Key.
   * 
   * @example
   * service
   */
  key?: string;
  /**
   * @remarks
   * The Tag Value.
   * 
   * @example
   * proudct
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateAlertRuleRequestTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * owner
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * John
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems extends $tea.Model {
  /**
   * @remarks
   * The aggregation method of the alert condition. Valid values:
   * 
   * *   AVG: calculates the average value
   * *   SUM: calculates the total value
   * *   MAX: selects the maximum value
   * *   MIN: selects the minimum value
   * 
   * @example
   * AVG
   */
  aggregate?: string;
  /**
   * @remarks
   * The metric of the alert condition.
   * 
   * @example
   * appstat.jvm.non_heap_used
   */
  metricKey?: string;
  /**
   * @remarks
   * Indicates the last N minutes.
   * 
   * @example
   * 1
   */
  n?: number;
  /**
   * @remarks
   * The comparison operator that was used to compare the metric value with the threshold. Valid values:
   * 
   * *   CURRENT_GTE: greater than or equal to
   * *   CURRENT_LTE: less than or equal to
   * *   PREVIOUS_UP: the increase percentage compared with the last period
   * *   PREVIOUS_DOWN: the decrease percentage compared with the last period
   * *   HOH_UP: the increase percentage compared with the last hour
   * *   HOH_DOWN: the decrease percentage compared with the last hour
   * *   DOD_UP: the increase percentage compared with the last day
   * *   DOD_DOWN: the decrease percentage compared with the last day
   * 
   * @example
   * CURRENT_GTE
   */
  operator?: string;
  /**
   * @remarks
   * The threshold of the alert condition.
   * 
   * @example
   * 1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      aggregate: 'Aggregate',
      metricKey: 'MetricKey',
      n: 'N',
      operator: 'Operator',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aggregate: 'string',
      metricKey: 'string',
      n: 'number',
      operator: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent extends $tea.Model {
  /**
   * @remarks
   * The trigger conditions of the Application Monitoring or Browser Monitoring alert rule.
   */
  alertRuleItems?: CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems[];
  /**
   * @remarks
   * The relationship between multiple alert conditions that were specified for the Application Monitoring or Browser Monitoring alert rule. Valid values:
   * 
   * *   OR: meets any of the specified conditions.
   * *   AND: meets all the specified conditions.
   * 
   * @example
   * "|"
   */
  condition?: string;
  static names(): { [key: string]: string } {
    return {
      alertRuleItems: 'AlertRuleItems',
      condition: 'Condition',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertRuleItems: { 'type': 'array', 'itemType': CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems },
      condition: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations extends $tea.Model {
  /**
   * @remarks
   * The key of the annotation.
   * 
   * @example
   * 123
   */
  name?: string;
  /**
   * @remarks
   * The value of the annotation.
   * 
   * @example
   * abc
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters extends $tea.Model {
  /**
   * @remarks
   * The key of the filter condition.
   * 
   * @example
   * username
   */
  key?: string;
  /**
   * @remarks
   * The logical operator of the filter condition. Valid values:
   * 
   * *   \\=: equal to
   * *   not: not equal to
   * 
   * @example
   * =
   */
  opt?: string;
  /**
   * @remarks
   * Indicates whether this filter condition was displayed on the frontend.
   * 
   * @example
   * false
   */
  show?: boolean;
  /**
   * @remarks
   * The log type of Browser Monitoring. This field was not included in other filter conditions.
   * 
   * @example
   * null
   */
  t?: string;
  /**
   * @remarks
   * The value of the filter condition.
   * 
   * @example
   * test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      opt: 'Opt',
      show: 'Show',
      t: 'T',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      opt: 'string',
      show: 'boolean',
      t: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters extends $tea.Model {
  /**
   * @remarks
   * The key of the filter condition.
   * 
   * @example
   * rootIp
   */
  filterKey?: string;
  /**
   * @remarks
   * The logical operator of the filter condition.
   * 
   * @example
   * ALL
   */
  filterOpt?: string;
  /**
   * @remarks
   * The details of the filter condition.
   */
  filterValues?: string[];
  static names(): { [key: string]: string } {
    return {
      filterKey: 'FilterKey',
      filterOpt: 'FilterOpt',
      filterValues: 'FilterValues',
    };
  }

  static types(): { [key: string]: any } {
    return {
      filterKey: 'string',
      filterOpt: 'string',
      filterValues: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters extends $tea.Model {
  /**
   * @remarks
   * The custom filter condition of the Browser Monitoring alert rule.
   */
  customSLSFilters?: CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters[];
  /**
   * @remarks
   * The information of the aggregation dimension.
   */
  customSLSGroupByDimensions?: string[];
  /**
   * @remarks
   * The details of the custom filter condition.
   */
  customSLSWheres?: string[];
  /**
   * @remarks
   * The information about each filter condition of the Application Monitoring or Browser Monitoring alert rule.
   */
  dimFilters?: CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters[];
  static names(): { [key: string]: string } {
    return {
      customSLSFilters: 'CustomSLSFilters',
      customSLSGroupByDimensions: 'CustomSLSGroupByDimensions',
      customSLSWheres: 'CustomSLSWheres',
      dimFilters: 'DimFilters',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customSLSFilters: { 'type': 'array', 'itemType': CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters },
      customSLSGroupByDimensions: { 'type': 'array', 'itemType': 'string' },
      customSLSWheres: { 'type': 'array', 'itemType': 'string' },
      dimFilters: { 'type': 'array', 'itemType': CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * 123
   */
  name?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * abc
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateAlertRuleResponseBodyAlertRuleTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * owner
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * John
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateAlertRuleResponseBodyAlertRule extends $tea.Model {
  /**
   * @remarks
   * The alert check type of the Prometheus alert rule. Valid values:
   * 
   * *   STATIC: a static threshold value.
   * *   CUSTOM: a custom PromQL statement.
   * 
   * @example
   * STATIC
   */
  alertCheckType?: string;
  /**
   * @remarks
   * The alert contact group ID of the Prometheus alert rule. Valid values:
   * 
   * *   \\-1: custom PromQL
   * *   1: Kubernetes load
   * *   15: Kubernetes node
   * 
   * @example
   * -1
   */
  alertGroup?: number;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * @example
   * 5510445
   */
  alertId?: number;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * @example
   * arms-test
   */
  alertName?: string;
  /**
   * @remarks
   * The content of the Application Monitoring or Browser Monitoring alert rule.
   */
  alertRuleContent?: CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent;
  /**
   * @remarks
   * The status of the alert rule. Valid values:
   * 
   * *   RUNNING
   * *   STOPPED
   * *   PAUSED
   * 
   * > The PAUSED status indicates that the alert rule is abnormal and is actively paused by the system. The alert rule may be paused because that it is not unique or the associated cluster has been deleted.
   * 
   * @example
   * RUNNING
   */
  alertStatus?: string;
  /**
   * @remarks
   * The type of the alert rule. Valid values:
   * 
   * *   APPLICATION_MONITORING_ALERT_RULE: alert rule for Application Monitoring
   * *   BROWSER_MONITORING_ALERT_RULE: alert rule for Browser Monitoring
   * *   PROMETHEUS_MONITORING_ALERT_RULE: alert rule for Prometheus Service
   * 
   * @example
   * APPLICATION_MONITORING_ALERT_RULE
   */
  alertType?: string;
  /**
   * @remarks
   * The annotations of the Prometheus alert rule.
   */
  annotations?: CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations[];
  /**
   * @remarks
   * Indicates whether the alert rule was applied to new applications that were created in Application Monitoring or Browser Monitoring. Valid values:
   * 
   * *   `true`: enables the health check feature.
   * *   `false`: disables the automatic backup feature.
   * 
   * @example
   * false
   */
  autoAddNewApplication?: boolean;
  /**
   * @remarks
   * The ID of the monitored cluster.
   * 
   * @example
   * ceba9b9ea5b924dd0b6726d2de6******
   */
  clusterId?: string;
  /**
   * @remarks
   * The timestamp generated when the alert rule was created. Unit: seconds.
   * 
   * @example
   * 1641438611000
   */
  createdTime?: number;
  /**
   * @remarks
   * The duration of the Prometheus alert rule. Unit: minutes.
   * 
   * @example
   * 1
   */
  duration?: string;
  /**
   * @remarks
   * The extended fields.
   * 
   * @example
   * {\\\\"alarmContext\\\\":\\\\"{\\\\\\\\\\"content\\\\\\\\\\":\\\\\\\\Alert name: $Alert name\\\\\\\\\\\\nFilter condition: $Filter condition\\\\\\\\\\\\nAlert time: $Alert time\\\\\\\\\\\\nAlert content: $Alert content\\\\\\\\\\\\nNote: The alert persists before you receive an email that reminds you to clear the alert. You will be reminded of the alert again 24 hours later. \\\\\\\\\\",\\\\\\\\\\"subTitle\\\\\\\\\\":\\\\\\\\\\"\\\\\\\\\\"}\\\\",\\\\"alertWays\\\\":\\\\"[0,1]\\\\",\\\\"contactGroupIds\\\\":\\\\"381,5075\\\\",\\\\"notice\\\\":\\\\"{\\\\\\\\\\"endTime\\\\\\\\\\":1480607940000,\\\\\\\\\\"noticeEndTime\\\\\\\\\\":1480607940000,\\\\\\\\\\"noticeStartTime\\\\\\\\\\":1480521600000,\\\\\\\\\\"startTime\\\\\\\\\\":1480521600000}\\\\"}
   */
  extend?: string;
  /**
   * @remarks
   * The filter conditions of the Application Monitoring or Browser Monitoring alert rule.
   */
  filters?: CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters;
  /**
   * @remarks
   * The tags of the Prometheus alert rule.
   */
  labels?: CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels[];
  /**
   * @remarks
   * The severity level of the Prometheus alert rule.
   * 
   * *   P1: Alert notifications are sent for major issues that affect the availability of core business, have a huge impact, and may lead to serious consequences.
   * *   P2: Alert notifications are sent for service errors that affect the system availability with relatively limited impact.
   * *   P3: Alert notifications are sent for issues that may cause service errors or negative effects, or alert notifications for services that are relatively less important.
   * *   P4: Alert notifications are sent for low-priority issues that do not affect your business.
   * *   Default: Alert notifications are sent regardless of alert levels.
   * 
   * @example
   * P2
   */
  level?: string;
  /**
   * @remarks
   * The alert message of the Prometheus alert rule.
   * 
   * @example
   * Namespace: {{$labels.namespace}} / Pod: {{$labels.pod_name}} / Container: {{$labels.container}} Memory usage exceeds 80%. Current value: {{ printf \\\\\\\\\\"%.2f\\\\\\\\\\" $value }}%
   */
  message?: string;
  /**
   * @remarks
   * The metric type of the Application Monitoring or Browser Monitoring alert rule.
   * 
   * @example
   * JVM
   */
  metricsType?: string;
  /**
   * @remarks
   * Notification Mode.
   * 
   * @example
   * NORMAL_MODE
   */
  notifyMode?: string;
  /**
   * @remarks
   * The name of the notification policy.
   * 
   * @example
   * ALERT_MANAGER
   */
  notifyStrategy?: string;
  /**
   * @remarks
   * The process ID (PID) that was associated with the Application Monitoring or Browser Monitoring alert rule.
   */
  pids?: string[];
  /**
   * @remarks
   * The PromQL statement of the Prometheus alert rule.
   * 
   * @example
   * node_memory_MemAvailable_bytes{} / node_memory_MemTotal_bytes{} * 100
   */
  promQL?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The list of tags.
   */
  tags?: CreateOrUpdateAlertRuleResponseBodyAlertRuleTags[];
  /**
   * @remarks
   * The timestamp generated when the alert rule was updated. Unit: seconds.
   * 
   * @example
   * 1641438611000
   */
  updatedTime?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 1131971649******
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      alertCheckType: 'AlertCheckType',
      alertGroup: 'AlertGroup',
      alertId: 'AlertId',
      alertName: 'AlertName',
      alertRuleContent: 'AlertRuleContent',
      alertStatus: 'AlertStatus',
      alertType: 'AlertType',
      annotations: 'Annotations',
      autoAddNewApplication: 'AutoAddNewApplication',
      clusterId: 'ClusterId',
      createdTime: 'CreatedTime',
      duration: 'Duration',
      extend: 'Extend',
      filters: 'Filters',
      labels: 'Labels',
      level: 'Level',
      message: 'Message',
      metricsType: 'MetricsType',
      notifyMode: 'NotifyMode',
      notifyStrategy: 'NotifyStrategy',
      pids: 'Pids',
      promQL: 'PromQL',
      regionId: 'RegionId',
      tags: 'Tags',
      updatedTime: 'UpdatedTime',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertCheckType: 'string',
      alertGroup: 'number',
      alertId: 'number',
      alertName: 'string',
      alertRuleContent: CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent,
      alertStatus: 'string',
      alertType: 'string',
      annotations: { 'type': 'array', 'itemType': CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations },
      autoAddNewApplication: 'boolean',
      clusterId: 'string',
      createdTime: 'number',
      duration: 'string',
      extend: 'string',
      filters: CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters,
      labels: { 'type': 'array', 'itemType': CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels },
      level: 'string',
      message: 'string',
      metricsType: 'string',
      notifyMode: 'string',
      notifyStrategy: 'string',
      pids: { 'type': 'array', 'itemType': 'string' },
      promQL: 'string',
      regionId: 'string',
      tags: { 'type': 'array', 'itemType': CreateOrUpdateAlertRuleResponseBodyAlertRuleTags },
      updatedTime: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateContactResponseBodyAlertContact extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert contact.
   * 
   * @example
   * 123
   */
  contactId?: number;
  /**
   * @remarks
   * The name of the alert contact.
   * 
   * @example
   * JohnDoe
   */
  contactName?: string;
  /**
   * @remarks
   * The webhook URL of the DingTalk chatbot.
   * 
   * @example
   * https://test1.com
   */
  dingRobotUrl?: string;
  /**
   * @remarks
   * The email address of the alert contact.
   * 
   * @example
   * someone@example.com
   */
  email?: string;
  /**
   * @remarks
   * Indicates whether the mobile number was verified. Valid values:
   * 
   * *   `false` (default value): No
   * *   `true`: Yes
   * 
   * You can call the **SendTTSVerifyLink** operation to verify the mobile number of an alert contact. Only verified mobile numbers can be specified in a notification policy to receive phone calls.
   * 
   * @example
   * false
   */
  isVerify?: boolean;
  /**
   * @remarks
   * The mobile number of the alert contact.
   * 
   * @example
   * 1381111****
   */
  phone?: string;
  /**
   * @remarks
   * The operation that you want to perform if phone calls fail to be answered. Valid values: 0: No operation is performed. 1: A phone call is made again. 2: A text message is sent. 3 (default value): The global default value is used.
   * 
   * @example
   * 3
   */
  reissueSendNotice?: number;
  /**
   * @remarks
   * Indicates whether the email address was verified.
   * 
   * @example
   * true
   */
  isEmailVerify?: boolean;
  static names(): { [key: string]: string } {
    return {
      contactId: 'ContactId',
      contactName: 'ContactName',
      dingRobotUrl: 'DingRobotUrl',
      email: 'Email',
      isVerify: 'IsVerify',
      phone: 'Phone',
      reissueSendNotice: 'ReissueSendNotice',
      isEmailVerify: 'isEmailVerify',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactId: 'number',
      contactName: 'string',
      dingRobotUrl: 'string',
      email: 'string',
      isVerify: 'boolean',
      phone: 'string',
      reissueSendNotice: 'number',
      isEmailVerify: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateContactGroupResponseBodyAlertContactGroup extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert contact group.
   * 
   * @example
   * 123
   */
  contactGroupId?: number;
  /**
   * @remarks
   * The name of the alert contact group.
   * 
   * @example
   * TestGroup
   */
  contactGroupName?: string;
  /**
   * @remarks
   * The IDs of the contacts that are included in the alert contact group.
   * 
   * @example
   * [1,2,3]
   */
  contactIds?: string;
  static names(): { [key: string]: string } {
    return {
      contactGroupId: 'ContactGroupId',
      contactGroupName: 'ContactGroupName',
      contactIds: 'ContactIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroupId: 'number',
      contactGroupName: 'string',
      contactIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration extends $tea.Model {
  /**
   * @remarks
   * The AccessKey ID that is used to connect to EventBridge.
   * 
   * @example
   * abc******************
   */
  accessKey?: string;
  /**
   * @remarks
   * The AccessKey secret that is used to connect to EventBridge.
   * 
   * @example
   * abc******************
   */
  accessSecret?: string;
  /**
   * @remarks
   * The description of the EventBridge integration.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The public endpoint of EventBridge.
   * 
   * @example
   * http://xxxxx
   */
  endpoint?: string;
  /**
   * @remarks
   * The name of the event bus.
   * 
   * @example
   * EventBus_Test
   */
  eventBusName?: string;
  /**
   * @remarks
   * The region ID of the event bus.
   * 
   * @example
   * cn-hangzhou
   */
  eventBusRegionId?: string;
  /**
   * @remarks
   * The ID of the EventBridge integration.
   * 
   * @example
   * 123
   */
  id?: number;
  /**
   * @remarks
   * The name of the EventBridge integration.
   * 
   * @example
   * EventBridge_Test
   */
  name?: string;
  /**
   * @remarks
   * The event source.
   * 
   * @example
   * arms
   */
  source?: string;
  static names(): { [key: string]: string } {
    return {
      accessKey: 'AccessKey',
      accessSecret: 'AccessSecret',
      description: 'Description',
      endpoint: 'Endpoint',
      eventBusName: 'EventBusName',
      eventBusRegionId: 'EventBusRegionId',
      id: 'Id',
      name: 'Name',
      source: 'Source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKey: 'string',
      accessSecret: 'string',
      description: 'string',
      endpoint: 'string',
      eventBusName: 'string',
      eventBusRegionId: 'string',
      id: 'number',
      name: 'string',
      source: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateIMRobotResponseBodyAlertRobot extends $tea.Model {
  /**
   * @remarks
   * The configurations of the alert card template.
   * 
   * @example
   * {     "button": [         "claim",         "close",         "follow",         "send_itsm",         "block",         "unResolvedIncident"     ],     "field": [         {             "fieldName": "alarmName",             "visible": true         },         {             "fieldName": "notificationPolicy",             "visible": true         },         {             "fieldName": "alarmContent",             "visible": true         },         {             "fieldName": "alarmTime",             "visible": true         },         {             "fieldName": "seriesChart",             "visible": true         },         {             "fieldName": "includeEvent",             "visible": true         },         {             "fieldName": "assigned",             "visible": true         },         {             "fieldName": "similarAlarm",             "visible": true         },         {             "fieldName": "operator",             "visible": true         }     ] }
   */
  cardTemplate?: string;
  /**
   * @remarks
   * Indicates whether daily statistics are sent. Valid values:
   * 
   * *   `false` (default): Daily statistics are not sent.
   * *   `true`: Daily statistics are sent.
   * 
   * @example
   * true
   */
  dailyNoc?: boolean;
  /**
   * @remarks
   * The point in time at which the daily statistics are sent. The information that ARMS sends at the specified points in time includes the total number of alerts generated on the current day, the number of cleared alerts, and the number of alerts to be cleared.
   * 
   * @example
   * 09:30,17:00
   */
  dailyNocTime?: string;
  /**
   * @remarks
   * Indicates whether the Outgoing feature is enabled.
   * 
   * @example
   * true
   */
  enableOutgoing?: boolean;
  /**
   * @remarks
   * The webhook URL of the IM chatbot.
   * 
   * @example
   * https://oapi.dingtalk.com/robot/send?access_token=e1a049121******
   */
  robotAddress?: string;
  /**
   * @remarks
   * The ID of the IM chatbot.
   * 
   * @example
   * 123
   */
  robotId?: number;
  /**
   * @remarks
   * The name of the IM chatbot.
   * 
   * @example
   * Chatbot name
   */
  robotName?: string;
  /**
   * @remarks
   * The token required to enable the Outgoing feature.
   * 
   * @example
   * 1656558719183be1245ab44********
   */
  token?: string;
  /**
   * @remarks
   * The type of the IM chatbot. Valid values:
   * 
   * *   `dingding`: DingTalk chatbot
   * *   `wechat`: WeCom chatbot
   * 
   * @example
   * dingding
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      cardTemplate: 'CardTemplate',
      dailyNoc: 'DailyNoc',
      dailyNocTime: 'DailyNocTime',
      enableOutgoing: 'EnableOutgoing',
      robotAddress: 'RobotAddress',
      robotId: 'RobotId',
      robotName: 'RobotName',
      token: 'Token',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cardTemplate: 'string',
      dailyNoc: 'boolean',
      dailyNocTime: 'string',
      enableOutgoing: 'boolean',
      robotAddress: 'string',
      robotId: 'number',
      robotName: 'string',
      token: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule extends $tea.Model {
  /**
   * @remarks
   * The time interval of grouping. Unit: seconds. Default value: 30.
   * 
   * @example
   * 30
   */
  groupInterval?: number;
  /**
   * @remarks
   * The waiting time for grouping. Unit: seconds. Default value: 5.
   * 
   * @example
   * 5
   */
  groupWait?: number;
  /**
   * @remarks
   * An array of alert event group objects.
   * 
   * *   If you do not specify the groupingFields field, all alerts will be sent to contacts based on `alertname`.
   * *   If you specify the groupingFields field, alerts with the same field will be sent to contacts in one notification.
   */
  groupingFields?: string[];
  static names(): { [key: string]: string } {
    return {
      groupInterval: 'GroupInterval',
      groupWait: 'GroupWait',
      groupingFields: 'GroupingFields',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupInterval: 'number',
      groupWait: 'number',
      groupingFields: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions extends $tea.Model {
  /**
   * @remarks
   * The key of the matching condition.
   * 
   * @example
   * altertname
   */
  key?: string;
  /**
   * @remarks
   * The logical operator of the matching condition. Valid values:
   * 
   * *   `eq`: equal to
   * *   `neq`: not equal to
   * *   `in`: contains
   * *   `nin`: does not contain
   * *   `re`: regular expression match
   * *   `nre`: regular expression mismatch
   * 
   * @example
   * eq
   */
  operator?: string;
  /**
   * @remarks
   * The value of the matching condition.
   * 
   * @example
   * test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      operator: 'Operator',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      operator: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules extends $tea.Model {
  /**
   * @remarks
   * The matching conditions.
   */
  matchingConditions?: CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions[];
  static names(): { [key: string]: string } {
    return {
      matchingConditions: 'MatchingConditions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      matchingConditions: { 'type': 'array', 'itemType': CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects extends $tea.Model {
  /**
   * @remarks
   * The notification methods specified for a contact.
   */
  notifyChannels?: string[];
  /**
   * @remarks
   * The ID of the notification object.
   * 
   * @example
   * 123
   */
  notifyObjectId?: number;
  /**
   * @remarks
   * The name of the notification object.
   * 
   * @example
   * test
   */
  notifyObjectName?: string;
  /**
   * @remarks
   * The type of the notification object. Valid values:
   * 
   * *   CONTACT: contact
   * *   CONTACT_GROUP: contact group
   * *   ARMS_CONTACT: ARMS contact
   * *   ARMS_CONTACT_GROUP: ARMS contact group
   * *   DING_ROBOT_GROUP: DingTalk, Lark, WeCom, or IM robot
   * *   CONTACT_SCHEDULE: user on duty defined by a schedule
   * 
   * @example
   * CONTACT
   */
  notifyObjectType?: string;
  static names(): { [key: string]: string } {
    return {
      notifyChannels: 'NotifyChannels',
      notifyObjectId: 'NotifyObjectId',
      notifyObjectName: 'NotifyObjectName',
      notifyObjectType: 'NotifyObjectType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      notifyChannels: { 'type': 'array', 'itemType': 'string' },
      notifyObjectId: 'number',
      notifyObjectName: 'string',
      notifyObjectType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule extends $tea.Model {
  /**
   * @remarks
   * The notification method.
   */
  notifyChannels?: string[];
  /**
   * @remarks
   * The end time of the notification window.
   * 
   * @example
   * 23:59
   */
  notifyEndTime?: string;
  /**
   * @remarks
   * An array of notification objects.
   */
  notifyObjects?: CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects[];
  /**
   * @remarks
   * The start time of the notification window.
   * 
   * @example
   * 00:00
   */
  notifyStartTime?: string;
  static names(): { [key: string]: string } {
    return {
      notifyChannels: 'NotifyChannels',
      notifyEndTime: 'NotifyEndTime',
      notifyObjects: 'NotifyObjects',
      notifyStartTime: 'NotifyStartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      notifyChannels: { 'type': 'array', 'itemType': 'string' },
      notifyEndTime: 'string',
      notifyObjects: { 'type': 'array', 'itemType': CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects },
      notifyStartTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate extends $tea.Model {
  /**
   * @remarks
   * The content of the alert notification sent through email.
   * 
   * @example
   * Alert name: {{ .commonLabels.alertname }}{{if .commonLabels.clustername }} Cluster name: {{ .commonLabels.clustername }} {{ end }}{{if eq "app" .commonLabels._aliyun_arms_involvedObject_kind }} Application name: {{ .commonLabels._aliyun_arms_involvedObject_name }} {{ end }} Notification policy: {{ .dispatchRuleName }} Alert time: {{ .startTime }} Alert content: {{ for .alerts }} {{.annotations.message}} {{if .generatorURL }} \\<a href="{{.generatorURL}}" >Link\\</a> {{end}} {{end}}
   */
  emailContent?: string;
  /**
   * @remarks
   * The content of the alert resolution notification sent through email.
   * 
   * @example
   * Alert name: {{ .commonLabels.alertname }}{{if .commonLabels.clustername }} Cluster name: {{ .commonLabels.clustername }} {{ end }}{{if eq "app" .commonLabels._aliyun_arms_involvedObject_kind }} Application name: {{ .commonLabels._aliyun_arms_involvedObject_name }} {{ end }} Notification policy: {{ .dispatchRuleName }} Alert resolution time: {{ .endTime }} Alert content: {{ for .alerts }} {{.annotations.message}} {{if .generatorURL }} \\<a href="{{.generatorURL}}" >Link\\</a> {{end}} {{end}}
   */
  emailRecoverContent?: string;
  /**
   * @remarks
   * The title of the alert resolution notification sent through email.
   * 
   * @example
   * {{ .commonLabels.alertname }}
   */
  emailRecoverTitle?: string;
  /**
   * @remarks
   * The title of the alert notification sent through email.
   * 
   * @example
   * {{ .commonLabels.alertname }}
   */
  emailTitle?: string;
  /**
   * @remarks
   * The content of the alert notification sent by the IM robot.
   * 
   * @example
   * {{if .commonLabels.clustername }} > Cluster name: {{ .commonLabels.clustername }} {{ end }}{{if eq "app" .commonLabels._aliyun_arms_involvedObject_kind }} > Application name: {{ .commonLabels._aliyun_arms_involvedObject_name }} {{ end }}{{ for .alerts }}> {{.annotations.message}} {{if .generatorURL }} [Link]\\({{.generatorURL}}) {{ end }} {{if eq "true" .labels._aliyun_arms_is_denoise_filtered }} (Suspected noise) {{end}} {{end}}
   */
  robotContent?: string;
  /**
   * @remarks
   * The content of the alert notification sent through text message.
   * 
   * @example
   * \\<SmsContent>Notification on the occurrence of a {{ .level }} alert. Alert name: {{ .commonLabels.alertname }}{{if .commonLabels.clustername }} Cluster name: {{ .commonLabels.clustername }} {{ end }}{{if eq "app" .commonLabels._aliyun_arms_involvedObject_kind }} Application name: {{ .commonLabels._aliyun_arms_involvedObject_name }} {{ end }} Notification policy: {{ .dispatchRuleName }} Alert time: {{ .startTime }} Alert content: {{ for .alerts }} {{.annotations.message}} {{ end }}\\</SmsContent>
   */
  smsContent?: string;
  /**
   * @remarks
   * The content of the alert resolution notification sent through text message.
   * 
   * @example
   * \\<SmsRecoverContent>Alert resolution notification. Alert name: {{ .commonLabels.alertname }}{{if .commonLabels.clustername }} Cluster name: {{ .commonLabels.clustername }} {{ end }}{{if eq "app" .commonLabels._aliyun_arms_involvedObject_kind }} Application name: {{ .commonLabels._aliyun_arms_involvedObject_name }} {{ end }} Notification policy: {{ .dispatchRuleName }} Alert resolution time: {{ .endTime }} Alert content: {{ for .alerts }} {{.annotations.message}} {{ end }}\\</SmsRecoverContent>
   */
  smsRecoverContent?: string;
  /**
   * @remarks
   * The content of the alert notification by phone.
   * 
   * @example
   * \\<TtsContent>Alert name: {{ .commonLabels.alertname }}{{if .commonLabels.clustername }} Cluster name: {{ .commonLabels.clustername }} {{ end }}{{if eq "app" .commonLabels._aliyun_arms_involvedObject_kind }} Application name: {{ .commonLabels._aliyun_arms_involvedObject_name }} {{ end }} Notification policy: {{ .dispatchRuleName }} Alert time: {{ .startTime }} Alert content: {{ for .alerts }} {{.annotations.message}} {{ end }}\\</TtsContent>
   */
  ttsContent?: string;
  /**
   * @remarks
   * The content of the alert resolution notification by phone.
   * 
   * @example
   * \\<TtsRecoverContent>Alert name: {{ .commonLabels.alertname }}{{if .commonLabels.clustername }} Cluster name: {{ .commonLabels.clustername }} {{ end }}{{if eq "app" .commonLabels._aliyun_arms_involvedObject_kind }} Application name: {{ .commonLabels._aliyun_arms_involvedObject_name }} {{ end }} Notification policy: {{ .dispatchRuleName }} Alert resolution time: {{ .endTime }} Alert content: {{ for .alerts }} {{.annotations.message}} {{ end }}\\</TtsRecoverContent>
   */
  ttsRecoverContent?: string;
  static names(): { [key: string]: string } {
    return {
      emailContent: 'EmailContent',
      emailRecoverContent: 'EmailRecoverContent',
      emailRecoverTitle: 'EmailRecoverTitle',
      emailTitle: 'EmailTitle',
      robotContent: 'RobotContent',
      smsContent: 'SmsContent',
      smsRecoverContent: 'SmsRecoverContent',
      ttsContent: 'TtsContent',
      ttsRecoverContent: 'TtsRecoverContent',
    };
  }

  static types(): { [key: string]: any } {
    return {
      emailContent: 'string',
      emailRecoverContent: 'string',
      emailRecoverTitle: 'string',
      emailTitle: 'string',
      robotContent: 'string',
      smsContent: 'string',
      smsRecoverContent: 'string',
      ttsContent: 'string',
      ttsRecoverContent: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to enable simple mode.
   * 
   * @example
   * false
   */
  directedMode?: boolean;
  /**
   * @remarks
   * The ID of the escalation policy.
   * 
   * @example
   * 123
   */
  escalationPolicyId?: number;
  /**
   * @remarks
   * An array of alert event group objects.
   */
  groupRule?: CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule;
  /**
   * @remarks
   * The ID of the notification policy.
   * 
   * @example
   * 1234
   */
  id?: number;
  /**
   * @remarks
   * The integration ID of the ticket system to which alerts are pushed.
   * 
   * @example
   * 34
   */
  integrationId?: number;
  /**
   * @remarks
   * The matching rules.
   */
  matchingRules?: CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules[];
  /**
   * @remarks
   * The name of the notification policy.
   * 
   * @example
   * notificationpolicy_test
   */
  name?: string;
  /**
   * @remarks
   * An array of notification rule objects.
   */
  notifyRule?: CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule;
  /**
   * @remarks
   * The notification template.
   */
  notifyTemplate?: CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate;
  /**
   * @remarks
   * Indicates whether a notification is resent for a long-lasting unresolved alert. Default value: true. Valid values:
   * 
   * *   `true`: The system resends a notification for a long-lasting unresolved alert at a specified time interval.
   * *   `false`: The system sends a notification for a long-lasting unresolved alert based on an escalation policy.
   * 
   * @example
   * true
   */
  repeat?: boolean;
  /**
   * @remarks
   * The time interval at which a notification is resent for a long-lasting unresolved alert. Unit: seconds.
   * 
   * @example
   * 600
   */
  repeatInterval?: number;
  /**
   * @remarks
   * Indicates whether the status of an alert automatically changes to Resolved when all events related to the alert change to the Restored state. ARMS notifies contacts when the alert status changes to Resolved.
   * 
   * *   `true`: The system sends a notification.
   * *   `false`: The system does not send a notification.
   * 
   * @example
   * true
   */
  sendRecoverMessage?: boolean;
  /**
   * @remarks
   * Indicates whether the notification policy is enabled. Valid values: enable and disable.
   * 
   * @example
   * enable
   */
  state?: string;
  static names(): { [key: string]: string } {
    return {
      directedMode: 'DirectedMode',
      escalationPolicyId: 'EscalationPolicyId',
      groupRule: 'GroupRule',
      id: 'Id',
      integrationId: 'IntegrationId',
      matchingRules: 'MatchingRules',
      name: 'Name',
      notifyRule: 'NotifyRule',
      notifyTemplate: 'NotifyTemplate',
      repeat: 'Repeat',
      repeatInterval: 'RepeatInterval',
      sendRecoverMessage: 'SendRecoverMessage',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      directedMode: 'boolean',
      escalationPolicyId: 'number',
      groupRule: CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule,
      id: 'number',
      integrationId: 'number',
      matchingRules: { 'type': 'array', 'itemType': CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules },
      name: 'string',
      notifyRule: CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule,
      notifyTemplate: CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate,
      repeat: 'boolean',
      repeatInterval: 'number',
      sendRecoverMessage: 'boolean',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions extends $tea.Model {
  /**
   * @remarks
   * The key of the matching condition.
   * 
   * @example
   * altertname
   */
  key?: string;
  /**
   * @remarks
   * The logical operator of the matching condition. Valid values:
   * 
   * *   `eq`: equal to
   * *   `neq`: not equal to
   * *   `in`: contains
   * *   `nin`: does not contain
   * *   `re`: regular expression match
   * *   `nre`: regular expression mismatch
   * 
   * @example
   * eq
   */
  operator?: string;
  /**
   * @remarks
   * The value of the matching condition.
   * 
   * @example
   * test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      operator: 'Operator',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      operator: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules extends $tea.Model {
  /**
   * @remarks
   * A list of matching conditions.
   */
  matchingConditions?: CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions[];
  static names(): { [key: string]: string } {
    return {
      matchingConditions: 'MatchingConditions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      matchingConditions: { 'type': 'array', 'itemType': CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateSilencePolicyResponseBodySilencePolicy extends $tea.Model {
  effectiveTimeType?: string;
  /**
   * @remarks
   * The ID of the silence policy.
   * 
   * @example
   * 1234
   */
  id?: number;
  /**
   * @remarks
   * A list of matching rules.
   */
  matchingRules?: CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules[];
  /**
   * @remarks
   * The name of the silence policy.
   * 
   * @example
   * silencepolicy_test
   */
  name?: string;
  /**
   * @remarks
   * Specifies whether to enable the silence policy. Valid values: enable and disable.
   * 
   * @example
   * enable
   */
  state?: string;
  timePeriod?: string;
  timeSlots?: string;
  static names(): { [key: string]: string } {
    return {
      effectiveTimeType: 'EffectiveTimeType',
      id: 'Id',
      matchingRules: 'MatchingRules',
      name: 'Name',
      state: 'State',
      timePeriod: 'TimePeriod',
      timeSlots: 'TimeSlots',
    };
  }

  static types(): { [key: string]: any } {
    return {
      effectiveTimeType: 'string',
      id: 'number',
      matchingRules: { 'type': 'array', 'itemType': CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules },
      name: 'string',
      state: 'string',
      timePeriod: 'string',
      timeSlots: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook extends $tea.Model {
  /**
   * @remarks
   * The HTTP request headers.
   * 
   * @example
   * [{"Content-Type":"application/json;charset=utf-8"}]
   */
  bizHeaders?: string;
  /**
   * @remarks
   * The parameters in the HTTP request.
   * 
   * @example
   * [{"content":"mike"}]
   */
  bizParams?: string;
  /**
   * @remarks
   * The alert notification template.
   * 
   * @example
   * { "Alert name":"{{ .commonLabels.alertname }}{{if .commonLabels.clustername }}", "Cluster name":"{{ .commonLabels.clustername }} {{ end }}{{if eq "app" .commonLabels._aliyun_arms_involvedObject_kind }}", "Application name":"{{ .commonLabels._aliyun_arms_involvedObject_name }} {{ end }}", "Notification policy":"{{ .dispatchRuleName }}", "Alert time":"{{ .startTime }}", "Alert content":"{{ for .alerts }} {{ .annotations.message }} {{ end }}" }
   */
  body?: string;
  /**
   * @remarks
   * The HTTP request method.
   * 
   * *   Post
   * *   Get
   * 
   * @example
   * Post
   */
  method?: string;
  /**
   * @remarks
   * The notification template for clearing alerts.
   * 
   * @example
   * { "Alert name":"{{ .commonLabels.alertname }}{{if .commonLabels.clustername }}", "Cluster name":"{{ .commonLabels.clustername }} {{ end }}{{if eq "app" .commonLabels._aliyun_arms_involvedObject_kind }}", "Application name":"{{ .commonLabels._aliyun_arms_involvedObject_name }} {{ end }}", "Notification policy":"{{ .dispatchRuleName }}", "Recovery time":"{{ .endTime }}", "Alert content":"{{ for .alerts }} {{ .annotations.message }} {{ end }}" }
   */
  recoverBody?: string;
  /**
   * @remarks
   * The URL of the request method.
   * 
   * @example
   * https://oapi.dingtalk.com/robot/send?access_token=e1a049121******
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      bizHeaders: 'BizHeaders',
      bizParams: 'BizParams',
      body: 'Body',
      method: 'Method',
      recoverBody: 'RecoverBody',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizHeaders: 'string',
      bizParams: 'string',
      body: 'string',
      method: 'string',
      recoverBody: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateWebhookContactResponseBodyWebhookContact extends $tea.Model {
  /**
   * @remarks
   * The information about the webhook alert contact.
   */
  webhook?: CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook;
  /**
   * @remarks
   * The ID of the webhook alert contact.
   * 
   * @example
   * 123
   */
  webhookId?: number;
  /**
   * @remarks
   * The name of the webhook alert contact.
   * 
   * @example
   * Webhook alert
   */
  webhookName?: string;
  static names(): { [key: string]: string } {
    return {
      webhook: 'Webhook',
      webhookId: 'WebhookId',
      webhookName: 'WebhookName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      webhook: CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook,
      webhookId: 'number',
      webhookName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePrometheusAlertRuleRequestTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * type
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * value1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations extends $tea.Model {
  /**
   * @remarks
   * The name of the annotation.
   * 
   * @example
   * message
   */
  name?: string;
  /**
   * @remarks
   * The value of the annotation.
   * 
   * @example
   * The CPU utilization of ${{$labels.pod_name}} has exceeded 80%. Current value: {{$value}}%
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels extends $tea.Model {
  /**
   * @remarks
   * The name of the tag.
   * 
   * @example
   * severity
   */
  name?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * critical
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * @example
   * 3888704
   */
  alertId?: number;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * @example
   * Prometheus_Alert
   */
  alertName?: string;
  /**
   * @remarks
   * The annotations of the alert rule.
   */
  annotations?: CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations[];
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * @example
   * c0bad479465464e1d8c1e641b0afb****
   */
  clusterId?: string;
  /**
   * @remarks
   * The ID of the notification policy.
   * 
   * @example
   * 10282
   */
  dispatchRuleId?: number;
  /**
   * @remarks
   * The duration. The value ranges from 1 to 1440 minutes.
   * 
   * @example
   * 10m
   */
  duration?: string;
  /**
   * @remarks
   * The expression of the alert rule.
   * 
   * @example
   * 100 * (sum(rate(container_cpu_usage_seconds_total[1m])) by (pod_name) / sum(label_replace(kube_pod_container_resource_limits_cpu_cores, \\"pod_name\\", \\"$1\\", \\"pod\\", \\"(.*)\\")) by (pod_name))>75
   */
  expression?: string;
  /**
   * @remarks
   * The tags of the alert rule.
   */
  labels?: CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels[];
  /**
   * @remarks
   * The content of the alert notification. Tags can be referenced in the {{$labels.xxx}} format.
   * 
   * @example
   * The CPU utilization of ${{$labels.pod_name}} has exceeded 80%. Current value: {{$value}}%
   */
  message?: string;
  /**
   * @remarks
   * The method that is used to send alert notifications. Valid values:
   * 
   * - ALERT_MANAGER: Alert notifications are sent by Operation Center.
   * - DISPATCH_RULE: Alert notifications are sent based on the specified notification policy.
   * 
   * @example
   * ALERT_MANAGER
   */
  notifyType?: string;
  /**
   * @remarks
   * Indicates whether the alert rule is enabled. Valid values:
   * 
   * - `1`: The alert rule is enabled.
   * - `0`: The alert rule is disabled.
   * 
   * @example
   * 1
   */
  status?: number;
  /**
   * @remarks
   * The type of the alert rule.
   * 
   * @example
   * Kubernetes component alert
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      alertId: 'AlertId',
      alertName: 'AlertName',
      annotations: 'Annotations',
      clusterId: 'ClusterId',
      dispatchRuleId: 'DispatchRuleId',
      duration: 'Duration',
      expression: 'Expression',
      labels: 'Labels',
      message: 'Message',
      notifyType: 'NotifyType',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertId: 'number',
      alertName: 'string',
      annotations: { 'type': 'array', 'itemType': CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations },
      clusterId: 'string',
      dispatchRuleId: 'number',
      duration: 'string',
      expression: 'string',
      labels: { 'type': 'array', 'itemType': CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels },
      message: 'string',
      notifyType: 'string',
      status: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePrometheusInstanceRequestTags extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRetcodeAppRequestTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * TestKey
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * TestValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * TestKey
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * TestValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRetcodeAppResponseBodyRetcodeAppDataBeanTags extends $tea.Model {
  tags?: CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags[];
  static names(): { [key: string]: string } {
    return {
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tags: { 'type': 'array', 'itemType': CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRetcodeAppResponseBodyRetcodeAppDataBean extends $tea.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * 135143
   */
  appId?: number;
  /**
   * @remarks
   * The process identifier (PID) of the application.
   * 
   * @example
   * aokcdqn3ly@a195c6d6421****
   */
  pid?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The tags of the task.
   */
  tags?: CreateRetcodeAppResponseBodyRetcodeAppDataBeanTags;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      pid: 'Pid',
      resourceGroupId: 'ResourceGroupId',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'number',
      pid: 'string',
      resourceGroupId: 'string',
      tags: CreateRetcodeAppResponseBodyRetcodeAppDataBeanTags,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRumAppRequestTag extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * app
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * ecs
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRumAppResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The domain name of the SDK.
   * 
   * @example
   * bxxxxxxx-sdk.rum.aliyuncs.com/v2/browser-sdk.js
   */
  cdnDomain?: string;
  /**
   * @remarks
   * The endpoint that is used to report application data.
   * 
   * @example
   * xxxxxxxx-default-cn.rum.aliyuncs.com
   */
  endpoint?: string;
  /**
   * @remarks
   * The process ID (PID) of the application.
   * 
   * @example
   * avccccxxxx@24cxxxxbf384dc6
   */
  pid?: string;
  static names(): { [key: string]: string } {
    return {
      cdnDomain: 'CdnDomain',
      endpoint: 'Endpoint',
      pid: 'Pid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cdnDomain: 'string',
      endpoint: 'string',
      pid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSyntheticTaskRequestCommonParamAlertList extends $tea.Model {
  /**
   * @remarks
   * Specifies whether the condition must be met.
   * 
   * @example
   * true
   */
  isCritical?: number;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * For network synthetic monitoring, use the following names:
   * 
   * *   Latency: PING_SET
   * *   Packet loss rate: PING_LOST_RATE
   * *   Hijacking: HIJACKPER
   * 
   * @example
   * PING_SET
   */
  name?: string;
  /**
   * @remarks
   * Specifies how the condition is evaluated. Valid values:
   * 
   * *   1: greater than
   * *   0: less than
   * 
   * @example
   * 1
   */
  symbols?: number;
  static names(): { [key: string]: string } {
    return {
      isCritical: 'IsCritical',
      name: 'Name',
      symbols: 'Symbols',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isCritical: 'number',
      name: 'string',
      symbols: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSyntheticTaskRequestCommonParam extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to create an alert rule.
   * 
   * *   1: creates an alert.
   * *   0: does not create an alert.
   * 
   * @example
   * 1
   */
  alarmFlag?: string;
  /**
   * @remarks
   * The alert parameters.
   */
  alertList?: CreateSyntheticTaskRequestCommonParamAlertList[];
  /**
   * @remarks
   * The ID of the alert recipient. Separate multiple recipients with commas (,).
   * 
   * @example
   * 123
   */
  alertNotifierId?: string;
  /**
   * @remarks
   * The ID of the notification policy.
   * 
   * @example
   * 1234
   */
  alertPolicyId?: string;
  /**
   * @remarks
   * Specifies whether to evenly distribute monitoring samples. Valid values:
   * 
   * *   0: no
   * *   1: yes
   * 
   * @example
   * 0
   */
  monitorSamples?: number;
  /**
   * @remarks
   * The time when execution starts.
   * 
   * @example
   * 2022-07-20 10
   */
  startExecutionTime?: number;
  static names(): { [key: string]: string } {
    return {
      alarmFlag: 'AlarmFlag',
      alertList: 'AlertList',
      alertNotifierId: 'AlertNotifierId',
      alertPolicyId: 'AlertPolicyId',
      monitorSamples: 'MonitorSamples',
      startExecutionTime: 'StartExecutionTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmFlag: 'string',
      alertList: { 'type': 'array', 'itemType': CreateSyntheticTaskRequestCommonParamAlertList },
      alertNotifierId: 'string',
      alertPolicyId: 'string',
      monitorSamples: 'number',
      startExecutionTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSyntheticTaskRequestDownload extends $tea.Model {
  /**
   * @remarks
   * The connection timeout period.
   * 
   * @example
   * 200
   */
  connectionTimeout?: number;
  /**
   * @remarks
   * The items to be ignored in a certificate error. Pass the values of the check boxes that are separated with vertical bars (|).
   * 
   * @example
   * Host:www.example.com|Referer:www.example.com
   */
  downloadCustomHeaderContent?: string;
  /**
   * @remarks
   * The custom host mode.
   * 
   * *   1: round robin
   * *   0: random
   * 
   * @example
   * 1
   */
  downloadCustomHost?: number;
  /**
   * @remarks
   * The custom host IP address. You can enter multiple IP addresses. Separate the IP addresses with commas (,).
   * 
   * @example
   * ipv4:192.168.2.1,192.168.2.5:img.a.com|192.168.2.1[8080]:img.a.com
   */
  downloadCustomHostIp?: string;
  /**
   * @remarks
   * The items to be ignored in a certificate error. Pass the values of the check boxes that are separated with vertical bars (|).
   * 
   * @example
   * 1|2|4
   */
  downloadIgnoreCertificateError?: string;
  /**
   * @remarks
   * The kernel type.
   * 
   * *   1: curl
   * *   0: WinInet
   * 
   * @example
   * 1
   */
  downloadKernel?: number;
  /**
   * @remarks
   * Specifies whether to support redirection.
   * 
   * @example
   * 0
   */
  downloadRedirection?: number;
  /**
   * @remarks
   * The size of the download file. Unit: KB.
   * 
   * @example
   * 10240
   */
  downloadTransmissionSize?: number;
  /**
   * @remarks
   * The monitoring duration.
   * 
   * @example
   * 30
   */
  monitorTimeout?: number;
  /**
   * @remarks
   * The QUIC protocol type.
   * 
   * *   1: http1
   * *   2: http2
   * *   3: http3
   * 
   * @example
   * 1
   */
  quickProtocol?: string;
  /**
   * @remarks
   * The keyword that is used in verification.
   * 
   * @example
   * keyword
   */
  validateKeywords?: string;
  /**
   * @remarks
   * The verification method.
   * 
   * *   0: no verification
   * *   1: string verification
   * *   2: MD5 verification
   * 
   * @example
   * 0
   */
  verifyWay?: number;
  /**
   * @remarks
   * The whitelist for DNS hijacking.
   * 
   * @example
   * [{\\"src\\":\\"211.154.166.174\\"}]
   */
  whiteList?: string;
  static names(): { [key: string]: string } {
    return {
      connectionTimeout: 'ConnectionTimeout',
      downloadCustomHeaderContent: 'DownloadCustomHeaderContent',
      downloadCustomHost: 'DownloadCustomHost',
      downloadCustomHostIp: 'DownloadCustomHostIp',
      downloadIgnoreCertificateError: 'DownloadIgnoreCertificateError',
      downloadKernel: 'DownloadKernel',
      downloadRedirection: 'DownloadRedirection',
      downloadTransmissionSize: 'DownloadTransmissionSize',
      monitorTimeout: 'MonitorTimeout',
      quickProtocol: 'QuickProtocol',
      validateKeywords: 'ValidateKeywords',
      verifyWay: 'VerifyWay',
      whiteList: 'WhiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connectionTimeout: 'number',
      downloadCustomHeaderContent: 'string',
      downloadCustomHost: 'number',
      downloadCustomHostIp: 'string',
      downloadIgnoreCertificateError: 'string',
      downloadKernel: 'number',
      downloadRedirection: 'number',
      downloadTransmissionSize: 'number',
      monitorTimeout: 'number',
      quickProtocol: 'string',
      validateKeywords: 'string',
      verifyWay: 'number',
      whiteList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSyntheticTaskRequestExtendInterval extends $tea.Model {
  /**
   * @remarks
   * The day on which synthetic monitoring is performed.
   */
  days?: number[];
  /**
   * @remarks
   * The hour at which synthetic monitoring ends.
   * 
   * @example
   * 23
   */
  endHour?: number;
  /**
   * @remarks
   * The minute at which synthetic monitoring ends.
   * 
   * @example
   * 00
   */
  endMinute?: number;
  /**
   * @remarks
   * The time when synthetic monitoring ends. The format is `yyyy-MM-dd HH`.
   * 
   * @example
   * 2022-08-20 10
   */
  endTime?: string;
  /**
   * @remarks
   * The hour at which synthetic monitoring starts.
   * 
   * @example
   * 00
   */
  startHour?: number;
  /**
   * @remarks
   * The minute at which synthetic monitoring starts.
   * 
   * @example
   * 00
   */
  startMinute?: number;
  /**
   * @remarks
   * The time when synthetic monitoring starts. The format is `yyyy-MM-dd HH`.
   * 
   * @example
   * 2022-07-20 10
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      days: 'Days',
      endHour: 'EndHour',
      endMinute: 'EndMinute',
      endTime: 'EndTime',
      startHour: 'StartHour',
      startMinute: 'StartMinute',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      days: { 'type': 'array', 'itemType': 'number' },
      endHour: 'number',
      endMinute: 'number',
      endTime: 'string',
      startHour: 'number',
      startMinute: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSyntheticTaskRequestMonitorList extends $tea.Model {
  /**
   * @remarks
   * The ID of the city to which the monitoring point belongs.
   * 
   * This parameter is required.
   * 
   * @example
   * 1100101
   */
  cityCode?: number;
  /**
   * @remarks
   * The carrier type:
   * 
   * *   IDC
   * *   LastMilie
   * 
   * This parameter is required.
   * 
   * @example
   * IDC
   */
  monitorType?: number;
  /**
   * @remarks
   * The ID of the carrier.
   * 
   * This parameter is required.
   * 
   * @example
   * 18
   */
  netServiceId?: number;
  static names(): { [key: string]: string } {
    return {
      cityCode: 'CityCode',
      monitorType: 'MonitorType',
      netServiceId: 'NetServiceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cityCode: 'number',
      monitorType: 'number',
      netServiceId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSyntheticTaskRequestNavigation extends $tea.Model {
  /**
   * @remarks
   * The whitelist for DNS hijacking.
   * 
   * @example
   * www.aliyun.com:202.0.3.55|203.3.44.67
   */
  DNSHijackWhiteList?: string;
  /**
   * @remarks
   * The element blacklist.
   * 
   * @example
   * *.a.com
   */
  elementBlacklist?: string;
  /**
   * @remarks
   * Specifies whether to execute ActiveX.
   * 
   * *   3: yes
   * *   0: no
   * 
   * >  This parameter is supported only by IE Full Elements.
   * 
   * @example
   * 3
   */
  executeActiveX?: number;
  /**
   * @remarks
   * Specifies whether to run applets.
   * 
   * *   1: yes
   * *   0: no
   * 
   * >  This parameter is supported only by IE Full Elements.
   * 
   * @example
   * 1
   */
  executeApplication?: number;
  /**
   * @remarks
   * Specifies whether to execute scripts.
   * 
   * *   1: yes
   * *   0: no
   * 
   * >  This parameter is supported only by IE Full Elements.
   * 
   * @example
   * 1
   */
  executeScript?: number;
  /**
   * @remarks
   * Specifies whether to filter invalid IP addresses.
   * 
   * *   1: no
   * *   0: yes
   * 
   * @example
   * 1
   */
  filterInvalidIP?: number;
  /**
   * @remarks
   * The element that is used in DNS hijacking.
   * 
   * @example
   * 50
   */
  flowHijackJumpTimes?: number;
  /**
   * @remarks
   * The tag that is used in DNS hijacking.
   * 
   * @example
   * test
   */
  flowHijackLogo?: string;
  /**
   * @remarks
   * The timeout period of monitoring. Unit: seconds.
   * 
   * @example
   * 20
   */
  monitorTimeout?: string;
  /**
   * @remarks
   * Specifies whether to automatically scroll up and down the screen to load a page.
   * 
   * *   1: yes
   * *   0: no
   * 
   * @example
   * 1
   */
  navAutomaticScrolling?: string;
  /**
   * @remarks
   * The method that is used to customize the header. Valid values:
   * 
   * *   0: disables the customer header.
   * *   1: modifies the first package.
   * *   2: modifies all packages.
   * 
   * @example
   * 0
   */
  navCustomHeader?: string;
  /**
   * @remarks
   * The format of the custom header. You can specify multiple fields. Separate the fields with vertical bars (|).
   * 
   * @example
   * Host:www.example.com|Referer:www.example.com
   */
  navCustomHeaderContent?: string;
  /**
   * @remarks
   * The custom host mode.
   * 
   * *   1: round robin
   * *   0: random
   * 
   * @example
   * 1
   */
  navCustomHost?: number;
  /**
   * @remarks
   * The custom host IP address. You can enter multiple IP addresses. Separate the IP addresses with commas (,).
   * 
   * @example
   * ipv4:192.168.2.1,192.168.2.5:img.a.com|192.168.2.1[8080]:img.a.com
   */
  navCustomHostIp?: string;
  /**
   * @remarks
   * Specifies whether to disable caching.
   * 
   * *   1: disable
   * *   0: enable
   * 
   * @example
   * 1
   */
  navDisableCache?: number;
  /**
   * @remarks
   * Specifies whether to enable the feature of using the Accept-Encoding field to determine whether to accept compressed files.
   * 
   * *   1: disable
   * *   0: enable
   * 
   * @example
   * 1
   */
  navDisableCompression?: string;
  /**
   * @remarks
   * Specifies whether to ignore certificate errors during certificate verification in the SSL handshake and continue browsing.
   * 
   * *   1: ignore
   * *   0: does not ignore
   * 
   * @example
   * 1
   */
  navIgnoreCertificateError?: number;
  /**
   * @remarks
   * Specifies whether to continue browsing after a redirection occurs.
   * 
   * *   1: yes
   * *   0: no
   * 
   * @example
   * 1
   */
  navRedirection?: number;
  /**
   * @remarks
   * Specifies whether to return the elements on the page.
   * 
   * *   1: no. Returns the basic document data.
   * *   2: yes. Returns all document data.
   * 
   * @example
   * 2
   */
  navReturnElement?: number;
  /**
   * @remarks
   * The web page defacement.
   * 
   * @example
   * www.example.com:202.0.3.55|203.3.44.67
   */
  pageTamper?: string;
  /**
   * @remarks
   * The process ID.
   * 
   * @example
   * ssh
   */
  processName?: string;
  /**
   * @remarks
   * The domain name of the QUIC request element.
   * 
   * >  This parameter is supported by all elements of only Chrome
   * 
   * @example
   * www.example.com
   */
  QUICDomain?: string;
  /**
   * @remarks
   * The Quick UDP Internet Connections (QUIC) protocol version. Default value: 0. Valid values:
   * 
   * *
   * *   35
   * *   39
   * *   43
   * *   44
   * 
   * >  This parameter is supported by all elements of only Chrome
   * 
   * @example
   * 0
   */
  QUICVersion?: number;
  /**
   * @remarks
   * Specifies whether to return the request header.
   * 
   * *   0: does not return the response header.
   * *   1: returns the basic document header.
   * *   2: returns all headers.
   * 
   * @example
   * 0
   */
  requestHeader?: number;
  /**
   * @remarks
   * The method that is used to return the response header. Valid values:
   * 
   * *   0: does not return the response header.
   * *   1: returns the basic document header.
   * *   2: returns all headers.
   * 
   * @example
   * 0
   */
  responseHeader?: number;
  /**
   * @remarks
   * The time threshold that is used to define a slow element. Unit: seconds.
   * 
   * @example
   * 5
   */
  slowElementThreshold?: number;
  /**
   * @remarks
   * The blacklist for string verification.
   * 
   * @example
   * Regex:*.example|expalme|
   */
  verifyStringBlacklist?: string;
  /**
   * @remarks
   * The whitelist for string verification.
   * 
   * @example
   * Regex:*.example|expalme|
   */
  verifyStringWhiteList?: string;
  /**
   * @remarks
   * The timeout period of waiting for the monitoring to complete.
   * 
   * @example
   * 15
   */
  waitCompletionTime?: number;
  static names(): { [key: string]: string } {
    return {
      DNSHijackWhiteList: 'DNSHijackWhiteList',
      elementBlacklist: 'ElementBlacklist',
      executeActiveX: 'ExecuteActiveX',
      executeApplication: 'ExecuteApplication',
      executeScript: 'ExecuteScript',
      filterInvalidIP: 'FilterInvalidIP',
      flowHijackJumpTimes: 'FlowHijackJumpTimes',
      flowHijackLogo: 'FlowHijackLogo',
      monitorTimeout: 'MonitorTimeout',
      navAutomaticScrolling: 'NavAutomaticScrolling',
      navCustomHeader: 'NavCustomHeader',
      navCustomHeaderContent: 'NavCustomHeaderContent',
      navCustomHost: 'NavCustomHost',
      navCustomHostIp: 'NavCustomHostIp',
      navDisableCache: 'NavDisableCache',
      navDisableCompression: 'NavDisableCompression',
      navIgnoreCertificateError: 'NavIgnoreCertificateError',
      navRedirection: 'NavRedirection',
      navReturnElement: 'NavReturnElement',
      pageTamper: 'PageTamper',
      processName: 'ProcessName',
      QUICDomain: 'QUICDomain',
      QUICVersion: 'QUICVersion',
      requestHeader: 'RequestHeader',
      responseHeader: 'ResponseHeader',
      slowElementThreshold: 'SlowElementThreshold',
      verifyStringBlacklist: 'VerifyStringBlacklist',
      verifyStringWhiteList: 'VerifyStringWhiteList',
      waitCompletionTime: 'WaitCompletionTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DNSHijackWhiteList: 'string',
      elementBlacklist: 'string',
      executeActiveX: 'number',
      executeApplication: 'number',
      executeScript: 'number',
      filterInvalidIP: 'number',
      flowHijackJumpTimes: 'number',
      flowHijackLogo: 'string',
      monitorTimeout: 'string',
      navAutomaticScrolling: 'string',
      navCustomHeader: 'string',
      navCustomHeaderContent: 'string',
      navCustomHost: 'number',
      navCustomHostIp: 'string',
      navDisableCache: 'number',
      navDisableCompression: 'string',
      navIgnoreCertificateError: 'number',
      navRedirection: 'number',
      navReturnElement: 'number',
      pageTamper: 'string',
      processName: 'string',
      QUICDomain: 'string',
      QUICVersion: 'number',
      requestHeader: 'number',
      responseHeader: 'number',
      slowElementThreshold: 'number',
      verifyStringBlacklist: 'string',
      verifyStringWhiteList: 'string',
      waitCompletionTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSyntheticTaskRequestNet extends $tea.Model {
  /**
   * @remarks
   * The DNS server.
   * 
   * @example
   * 114.114.XX.XX
   */
  netDNSNs?: string;
  /**
   * @remarks
   * The DNS query method. Valid values:
   * 
   * *   1: recursion
   * *   2: iteration
   * 
   * @example
   * 1
   */
  netDNSQueryMethod?: number;
  /**
   * @remarks
   * The IP address type of the DNS server.
   * 
   * *   0: IPv4
   * *   1: IPv6
   * *   2: an automatic IP address
   * 
   * @example
   * 0
   */
  netDNSServer?: number;
  /**
   * @remarks
   * Specifies whether to enable domain name system (DNS) monitoring.
   * 
   * *   0: Off.
   * *   1: On. You must set DNS parameters if you want to enable DNS monitoring.
   * 
   * @example
   * 1
   */
  netDNSSwitch?: number;
  /**
   * @remarks
   * The timeout period of DNS monitoring. Default value: 5 seconds. Valid values: 0 to 45 seconds.
   * 
   * @example
   * 5
   */
  netDNSTimeout?: number;
  /**
   * @remarks
   * Specifies whether to display the data in the DIG format. Valid values:
   * 
   * *   0: no
   * *   1: yes
   * 
   * @example
   * 0
   */
  netDigSwitch?: number;
  /**
   * @remarks
   * The protocol type. Valid values:
   * 
   * *   0: ICMP
   * *   1: TCP
   * 
   * @example
   * 0
   */
  netICMPActive?: number;
  /**
   * @remarks
   * Specifies whether to split packages.
   * 
   * *   0: no
   * *   1: yes
   * 
   * @example
   * 0
   */
  netICMPDataCut?: number;
  /**
   * @remarks
   * The interval at which the network synthetic monitoring task is executed. Unit: seconds.
   * 
   * @example
   * 1
   */
  netICMPInterval?: number;
  /**
   * @remarks
   * The number of packages.
   * 
   * @example
   * 4
   */
  netICMPNum?: number;
  /**
   * @remarks
   * The package size.
   * 
   * @example
   * 32
   */
  netICMPSize?: number;
  /**
   * @remarks
   * Specifies whether to enable ping monitoring.
   * 
   * *   0: Off.
   * *   1: On. You must set Internet control message protocol (ICMP) parameters if you want to enable ping monitoring.
   * 
   * @example
   * 1
   */
  netICMPSwitch?: number;
  /**
   * @remarks
   * The timeout period of Ping monitoring.
   * 
   * @example
   * 20
   */
  netICMPTimeout?: number;
  /**
   * @remarks
   * The maximum number of active monitoring points.
   * 
   * @example
   * 20
   */
  netTraceRouteNum?: number;
  /**
   * @remarks
   * Specifies whether to enable tracert monitoring.
   * 
   * *   0: Off.
   * *   1: On. You must set the tracert parameters if you want to enable tracert monitoring.
   * 
   * @example
   * 1
   */
  netTraceRouteSwitch?: number;
  /**
   * @remarks
   * The timeout period of tracert monitoring. Valid values: 0 to 300 seconds.
   * 
   * @example
   * 60
   */
  netTraceRouteTimeout?: number;
  /**
   * @remarks
   * The whitelist for DNS hijacking. The format is `Domain name: Matching rule`.
   * 
   * >  Wireless application protocol (WAP) networks do not support DNS hijacking.
   * 
   * @example
   * www.aliyun.com:202.0.3.55|203.3.44.67
   */
  whiteList?: string;
  static names(): { [key: string]: string } {
    return {
      netDNSNs: 'NetDNSNs',
      netDNSQueryMethod: 'NetDNSQueryMethod',
      netDNSServer: 'NetDNSServer',
      netDNSSwitch: 'NetDNSSwitch',
      netDNSTimeout: 'NetDNSTimeout',
      netDigSwitch: 'NetDigSwitch',
      netICMPActive: 'NetICMPActive',
      netICMPDataCut: 'NetICMPDataCut',
      netICMPInterval: 'NetICMPInterval',
      netICMPNum: 'NetICMPNum',
      netICMPSize: 'NetICMPSize',
      netICMPSwitch: 'NetICMPSwitch',
      netICMPTimeout: 'NetICMPTimeout',
      netTraceRouteNum: 'NetTraceRouteNum',
      netTraceRouteSwitch: 'NetTraceRouteSwitch',
      netTraceRouteTimeout: 'NetTraceRouteTimeout',
      whiteList: 'WhiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      netDNSNs: 'string',
      netDNSQueryMethod: 'number',
      netDNSServer: 'number',
      netDNSSwitch: 'number',
      netDNSTimeout: 'number',
      netDigSwitch: 'number',
      netICMPActive: 'number',
      netICMPDataCut: 'number',
      netICMPInterval: 'number',
      netICMPNum: 'number',
      netICMPSize: 'number',
      netICMPSwitch: 'number',
      netICMPTimeout: 'number',
      netTraceRouteNum: 'number',
      netTraceRouteSwitch: 'number',
      netTraceRouteTimeout: 'number',
      whiteList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSyntheticTaskRequestProtocolRequestContentBodyFormData extends $tea.Model {
  /**
   * @remarks
   * The key of **form-data**.
   * 
   * @example
   * appId
   */
  key?: string;
  /**
   * @remarks
   * The value of **form-data**.
   * 
   * @example
   * 3425
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding extends $tea.Model {
  /**
   * @remarks
   * The key of **x-www-form-urlencoded**.
   * 
   * @example
   * appId
   */
  key?: string;
  /**
   * @remarks
   * The value of **x-www-form-urlencoded**.
   * 
   * @example
   * 11080
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSyntheticTaskRequestProtocolRequestContentBody extends $tea.Model {
  /**
   * @remarks
   * The data that is passed when the **Mode** parameter is set to **form-data**.
   */
  formData?: CreateSyntheticTaskRequestProtocolRequestContentBodyFormData[];
  /**
   * @remarks
   * The language that is selected when the Mode parameter is set to raw.
   * 
   * *   json
   * *   xml
   * *   javascript
   * *   html
   * *   text
   * 
   * @example
   * json
   */
  language?: string;
  /**
   * @remarks
   * The data type of the content.
   * 
   * *   form-data
   * *   x-www-form-urlencoded
   * *   raw
   * 
   * @example
   * form-data
   */
  mode?: string;
  /**
   * @remarks
   * The data that is passed when the **Mode** parameter is set to **raw**.
   * 
   * @example
   * content
   */
  raw?: string;
  /**
   * @remarks
   * The data that is passed when the **Mode** parameter is set to **x-www-form-urlencoded**.
   */
  urlEncoding?: CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding[];
  static names(): { [key: string]: string } {
    return {
      formData: 'FormData',
      language: 'Language',
      mode: 'Mode',
      raw: 'Raw',
      urlEncoding: 'UrlEncoding',
    };
  }

  static types(): { [key: string]: any } {
    return {
      formData: { 'type': 'array', 'itemType': CreateSyntheticTaskRequestProtocolRequestContentBodyFormData },
      language: 'string',
      mode: 'string',
      raw: 'string',
      urlEncoding: { 'type': 'array', 'itemType': CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSyntheticTaskRequestProtocolRequestContentHeader extends $tea.Model {
  /**
   * @remarks
   * The key of the request header.
   * 
   * @example
   * regionId
   */
  key?: string;
  /**
   * @remarks
   * The value of the request header.
   * 
   * @example
   * cn-hangzhou
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSyntheticTaskRequestProtocolRequestContent extends $tea.Model {
  /**
   * @remarks
   * The custom body of a request to initiate an API performance synthetic monitoring task.
   */
  body?: CreateSyntheticTaskRequestProtocolRequestContentBody;
  /**
   * @remarks
   * The custom header of a request to initiate an API performance synthetic monitoring task.
   */
  header?: CreateSyntheticTaskRequestProtocolRequestContentHeader[];
  /**
   * @remarks
   * The request method.
   * 
   * *   POST
   * *   GET
   * 
   * @example
   * POST
   */
  method?: string;
  static names(): { [key: string]: string } {
    return {
      body: 'Body',
      header: 'Header',
      method: 'Method',
    };
  }

  static types(): { [key: string]: any } {
    return {
      body: CreateSyntheticTaskRequestProtocolRequestContentBody,
      header: { 'type': 'array', 'itemType': CreateSyntheticTaskRequestProtocolRequestContentHeader },
      method: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSyntheticTaskRequestProtocol extends $tea.Model {
  /**
   * @remarks
   * The encoding format.
   * 
   * *   0: UTF-8
   * *   1: GBK
   * *   2: GB2312
   * *   3: Unicode
   * 
   * @example
   * 0
   */
  characterEncoding?: number;
  /**
   * @remarks
   * The custom host mode.
   * 
   * *   1: round robin
   * *   0: random
   * 
   * @example
   * 1
   */
  customHost?: number;
  /**
   * @remarks
   * The custom host IP address. You can enter multiple IP addresses. Separate the IP addresses with commas (,).
   * 
   * @example
   * ipv4:192.168.2.1,192.168.2.5:img.a.com|192.168.2.1[8080]:img.a.com
   */
  customHostIp?: string;
  /**
   * @remarks
   * The connection timeout period of the protocol. Unit: seconds.
   * 
   * @example
   * 3
   */
  protocolConnectionTime?: number;
  /**
   * @remarks
   * The timeout period of API performance synthetic monitoring. Unit: seconds.
   * 
   * @example
   * 30
   */
  protocolMonitorTimeout?: string;
  /**
   * @remarks
   * The size of the received data. This parameter is required when you set the value of the VerifyWay parameter to 2.
   * 
   * @example
   * 500
   */
  receivedDataSize?: number;
  /**
   * @remarks
   * The request content, including the request header and request body.
   */
  requestContent?: CreateSyntheticTaskRequestProtocolRequestContent;
  /**
   * @remarks
   * The verification string.
   * 
   * @example
   * "code":200
   */
  verifyContent?: string;
  /**
   * @remarks
   * The method that is used to verify the response content.
   * 
   * *   0: no verification.
   * *   1: exact match with the verification string.
   * *   2: partial match with the verification string.
   * *   3: MD5 verification.
   * 
   * @example
   * 0
   */
  verifyWay?: number;
  static names(): { [key: string]: string } {
    return {
      characterEncoding: 'CharacterEncoding',
      customHost: 'CustomHost',
      customHostIp: 'CustomHostIp',
      protocolConnectionTime: 'ProtocolConnectionTime',
      protocolMonitorTimeout: 'ProtocolMonitorTimeout',
      receivedDataSize: 'ReceivedDataSize',
      requestContent: 'RequestContent',
      verifyContent: 'VerifyContent',
      verifyWay: 'VerifyWay',
    };
  }

  static types(): { [key: string]: any } {
    return {
      characterEncoding: 'number',
      customHost: 'number',
      customHostIp: 'string',
      protocolConnectionTime: 'number',
      protocolMonitorTimeout: 'string',
      receivedDataSize: 'number',
      requestContent: CreateSyntheticTaskRequestProtocolRequestContent,
      verifyContent: 'string',
      verifyWay: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSyntheticTaskResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the synthetic monitoring task.
   * 
   * @example
   * 1234
   */
  taskId?: number;
  static names(): { [key: string]: string } {
    return {
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTimingSyntheticTaskRequestAvailableAssertions extends $tea.Model {
  /**
   * @remarks
   * The expected value.
   * 
   * This parameter is required.
   * 
   * @example
   * 200
   */
  expect?: string;
  /**
   * @remarks
   * The condition. gt: greater than. gte: greater than or equal to. lt: less than. lte: less than or equal to. eq: equal to. neq: not equal to. ctn: contain. nctn: does not contain. exist: exist. n_exist: does not exist. belong: belong to. n_belong: does not belong to. reg_match: regular expression.
   * 
   * This parameter is required.
   * 
   * @example
   * eq
   */
  operator?: string;
  /**
   * @remarks
   * The check target. If you set the type parameter to HttpResCode, HttpResBody, or HttpResponseTime, you do not need to set the target parameter. If you set the type parameter to HttpResHead, you must specify the key in the header. If you set the type parameter to HttpResBodyJson, use jsonPath.
   * 
   * @example
   * key
   */
  target?: string;
  /**
   * @remarks
   * The assertion type. Valid values: HttpResCode, HttpResHead, HttpResBody, HttpResBodyJson, HttpResponseTime, IcmpPackLoss (packet loss rate), IcmpPackMaxLatency (maximum packet latency), IcmpPackAvgLatency (average packet latency), TraceRouteHops (number of hops), DnsARecord (A record), DnsCName (CNAME), websiteTTFB (time to first packet), websiteTTLB (time to last packet), websiteFST (first paint time), websiteFFST (first meaningful paint), websiteOnload (full loaded time). For more information, see the following description.
   * 
   * This parameter is required.
   * 
   * @example
   * DnsARecord
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      expect: 'Expect',
      operator: 'Operator',
      target: 'Target',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expect: 'string',
      operator: 'string',
      target: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTimingSyntheticTaskRequestCommonSettingCustomHostHosts extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The IP version. Valid values:
   * 
   * *   0: A version is automatically selected.
   * *   1: IPv4.
   * *   2: IPv6.
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  ipType?: number;
  /**
   * @remarks
   * The list of IP addresses.
   * 
   * This parameter is required.
   */
  ips?: string[];
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      ipType: 'IpType',
      ips: 'Ips',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      ipType: 'number',
      ips: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTimingSyntheticTaskRequestCommonSettingCustomHost extends $tea.Model {
  /**
   * @remarks
   * The list of hosts.
   * 
   * This parameter is required.
   */
  hosts?: CreateTimingSyntheticTaskRequestCommonSettingCustomHostHosts[];
  /**
   * @remarks
   * The selection mode. Valid values:
   * 
   * *   0: random
   * *   1: polling
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  selectType?: number;
  static names(): { [key: string]: string } {
    return {
      hosts: 'Hosts',
      selectType: 'SelectType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hosts: { 'type': 'array', 'itemType': CreateTimingSyntheticTaskRequestCommonSettingCustomHostHosts },
      selectType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTimingSyntheticTaskRequestCommonSettingCustomPrometheusSetting extends $tea.Model {
  /**
   * @remarks
   * A reserved parameter.
   * 
   * @example
   * null
   */
  prometheusClusterId?: string;
  /**
   * @remarks
   * A reserved parameter.
   * 
   * @example
   * null
   */
  prometheusClusterRegion?: string;
  /**
   * @remarks
   * A reserved parameter.
   */
  prometheusLabels?: { [key: string]: string };
  static names(): { [key: string]: string } {
    return {
      prometheusClusterId: 'PrometheusClusterId',
      prometheusClusterRegion: 'PrometheusClusterRegion',
      prometheusLabels: 'PrometheusLabels',
    };
  }

  static types(): { [key: string]: any } {
    return {
      prometheusClusterId: 'string',
      prometheusClusterRegion: 'string',
      prometheusLabels: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTimingSyntheticTaskRequestCommonSettingCustomVPCSetting extends $tea.Model {
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the security group to which the client belongs. The security group specifies the inbound and outbound rules of the client for the VPC. You need to allow the security group to which the client belongs to access the security group to which the VPC belongs. Otherwise, the client cannot access resources in the VPC.
   * 
   * @example
   * sg-bp13wzf9vuwegmpxxxxx
   */
  secureGroupId?: string;
  /**
   * @remarks
   * The vSwitch ID.
   * 
   * @example
   * vsw-bp14crq29vpycxp8xxxxx
   */
  vSwitchId?: string;
  /**
   * @remarks
   * VPC ID.
   * 
   * @example
   * vpc-bp1muectbr8f90vjxxxxx
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      secureGroupId: 'SecureGroupId',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      secureGroupId: 'string',
      vSwitchId: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTimingSyntheticTaskRequestCommonSetting extends $tea.Model {
  /**
   * @remarks
   * The custom host settings.
   */
  customHost?: CreateTimingSyntheticTaskRequestCommonSettingCustomHost;
  /**
   * @remarks
   * The reserved parameters.
   */
  customPrometheusSetting?: CreateTimingSyntheticTaskRequestCommonSettingCustomPrometheusSetting;
  /**
   * @remarks
   * The information about the virtual private cloud (VPC). If the destination URL is an Alibaba Cloud internal endpoint, you need to configure a VPC.
   */
  customVPCSetting?: CreateTimingSyntheticTaskRequestCommonSettingCustomVPCSetting;
  /**
   * @remarks
   * The IP version. Valid values:
   * 
   * *   0: A version is automatically selected.
   * *   1: IPv4.
   * *   2: IPv6.
   * 
   * @example
   * 0
   */
  ipType?: number;
  /**
   * @remarks
   * Specifies whether to enable tracing.
   * 
   * @example
   * true
   */
  isOpenTrace?: boolean;
  /**
   * @remarks
   * Specifies whether to evenly distribute monitoring samples. Valid values:
   * 
   * *   0: no
   * *   1: yes
   * 
   * @example
   * 0
   */
  monitorSamples?: number;
  /**
   * @remarks
   * The type of the client for tracing. Valid values:
   * 
   * *   0: ARMS agent
   * *   1: OpenTelemetry
   * *   2: Jaeger
   * 
   * @example
   * 1
   */
  traceClientType?: number;
  /**
   * @remarks
   * The region to which trace data is reported.
   * 
   * @example
   * cn-hangzhou
   */
  xtraceRegion?: string;
  static names(): { [key: string]: string } {
    return {
      customHost: 'CustomHost',
      customPrometheusSetting: 'CustomPrometheusSetting',
      customVPCSetting: 'CustomVPCSetting',
      ipType: 'IpType',
      isOpenTrace: 'IsOpenTrace',
      monitorSamples: 'MonitorSamples',
      traceClientType: 'TraceClientType',
      xtraceRegion: 'XtraceRegion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customHost: CreateTimingSyntheticTaskRequestCommonSettingCustomHost,
      customPrometheusSetting: CreateTimingSyntheticTaskRequestCommonSettingCustomPrometheusSetting,
      customVPCSetting: CreateTimingSyntheticTaskRequestCommonSettingCustomVPCSetting,
      ipType: 'number',
      isOpenTrace: 'boolean',
      monitorSamples: 'number',
      traceClientType: 'number',
      xtraceRegion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTimingSyntheticTaskRequestCustomPeriod extends $tea.Model {
  /**
   * @remarks
   * The custom host settings.
   * 
   * This parameter is required.
   * 
   * @example
   * 22
   */
  endHour?: number;
  /**
   * @remarks
   * The list of hosts.
   * 
   * This parameter is required.
   * 
   * @example
   * 8
   */
  startHour?: number;
  static names(): { [key: string]: string } {
    return {
      endHour: 'EndHour',
      startHour: 'StartHour',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endHour: 'number',
      startHour: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody extends $tea.Model {
  /**
   * @remarks
   * The content of the request body. Format: JSON string. The parameter is required if the Type parameter is set to text/plain, application/json, application/xml, or text/html. Format: JSON string.
   * 
   * @example
   * {
   *   "key1": "value1",
   *   "key2": "value2"
   * }
   */
  content?: string;
  /**
   * @remarks
   * The type of the request body. Valid values: text/plain, application/json, application/x-www-form-urlencoded, multipart/form-data, application/xml, and text/html.
   * 
   * @example
   * application/json
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTimingSyntheticTaskRequestMonitorConfApiHTTP extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to verify the certificate. Default value: no.
   * 
   * @example
   * true
   */
  checkCert?: boolean;
  /**
   * @remarks
   * The connection timeout period. Unit: milliseconds. Default value: 5000. Minimum value: 1000. Maximum value: 300000.
   * 
   * @example
   * 5000
   */
  connectTimeout?: number;
  /**
   * @remarks
   * The request method. Valid values: GET and POST.
   * 
   * @example
   * GET
   */
  method?: string;
  /**
   * @remarks
   * The ALPN protocol version. You can configure this parameter when you perform an HTTPS synthetic test on a WAP mobile client. Valid values:
   * 
   * 0: default
   * 
   * 1: http/1.1
   * 
   * 2: h2
   * 
   * 3: disables the ALPN protocol
   * 
   * @example
   * 1
   */
  protocolAlpnProtocol?: number;
  /**
   * @remarks
   * The HTTP request body.
   */
  requestBody?: CreateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody;
  /**
   * @remarks
   * The HTTP request header.
   */
  requestHeaders?: { [key: string]: string };
  /**
   * @remarks
   * The URL or request path for synthetic monitoring.
   * 
   * This parameter is required.
   * 
   * @example
   * http://www.demo.com/api/list
   */
  targetUrl?: string;
  /**
   * @remarks
   * The timeout period. Unit: milliseconds. Default value: 10000. Minimum value: 1000. Maximum value: 300000.
   * 
   * @example
   * 10000
   */
  timeout?: number;
  static names(): { [key: string]: string } {
    return {
      checkCert: 'CheckCert',
      connectTimeout: 'ConnectTimeout',
      method: 'Method',
      protocolAlpnProtocol: 'ProtocolAlpnProtocol',
      requestBody: 'RequestBody',
      requestHeaders: 'RequestHeaders',
      targetUrl: 'TargetUrl',
      timeout: 'Timeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkCert: 'boolean',
      connectTimeout: 'number',
      method: 'string',
      protocolAlpnProtocol: 'number',
      requestBody: CreateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody,
      requestHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      targetUrl: 'string',
      timeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTimingSyntheticTaskRequestMonitorConfFileDownload extends $tea.Model {
  /**
   * @remarks
   * Unit: milliseconds. Minimum value: 1000. Maximum value: 120000. Default value: 5000.
   * 
   * @example
   * 5000
   */
  connectionTimeout?: number;
  /**
   * @remarks
   * The content of the custom request header.
   */
  customHeaderContent?: { [key: string]: string };
  /**
   * @remarks
   * The kernel type. Valid values:
   * 
   * *   1: curl
   * *   0: WinInet
   * 
   * Default value: 1
   * 
   * @example
   * 1
   */
  downloadKernel?: number;
  /**
   * @remarks
   * Specifies whether to ignore CA certificate authentication errors. Valid values: 0: no. 1: yes. Default value: 1.
   * 
   * @example
   * 1
   */
  ignoreCertificateAuthError?: number;
  /**
   * @remarks
   * Specifies whether to ignore certificate revocation errors. Valid values: 0: no. 1: yes. Default value: 1.
   * 
   * @example
   * 1
   */
  ignoreCertificateCanceledError?: number;
  /**
   * @remarks
   * Specifies whether to ignore certificate invalidity. Valid values: 0: no. 1: yes. Default value: 1.
   * 
   * @example
   * 1
   */
  ignoreCertificateOutOfDateError?: number;
  /**
   * @remarks
   * Specifies whether to ignore certificate status errors. Valid values: 0: no. 1: yes. Default value: 1.
   * 
   * @example
   * 1
   */
  ignoreCertificateStatusError?: number;
  /**
   * @remarks
   * Specifies whether to ignore certificate incredibility. Valid values: 0: no. 1: yes. Default value: 1.
   * 
   * @example
   * 1
   */
  ignoreCertificateUntrustworthyError?: number;
  /**
   * @remarks
   * Specifies whether to ignore certificate usage errors. Valid values: 0: no. 1: yes. Default value: 1.
   * 
   * @example
   * 1
   */
  ignoreCertificateUsingError?: number;
  /**
   * @remarks
   * Specifies whether to ignore host invalidity. Valid values: 0: no. 1: yes. Default value: 1.
   * 
   * @example
   * 1
   */
  ignoreInvalidHostError?: number;
  /**
   * @remarks
   * The monitoring timeout period. Unit: milliseconds. Minimum value: 1000. Maximum value: 120000. Default value: 60000.
   * 
   * @example
   * 60000
   */
  monitorTimeout?: number;
  /**
   * @remarks
   * The QUIC protocol type. Valid values:
   * 
   * *   1: HTTP/1
   * *   2: HTTP/2
   * *   3: HTTP/3
   * 
   * Default value: 1
   * 
   * @example
   * 1
   */
  quickProtocol?: number;
  /**
   * @remarks
   * Specifies whether to support redirection. Valid values: 0: no. 1: yes. Default value: 1.
   * 
   * @example
   * 1
   */
  redirection?: number;
  /**
   * @remarks
   * The URL that is used to download the file.
   * 
   * This parameter is required.
   * 
   * @example
   * https://img.alicdn.com/tfs/TB13DzOjXP7gK0jSZFjXXc5aXXa-212-48.png
   */
  targetUrl?: string;
  /**
   * @remarks
   * The maximum file size of a single transfer. Unit: KB. Minimum value: 1. Maximum value: 20480. Valid values: 2048.
   * 
   * @example
   * 2048
   */
  transmissionSize?: number;
  /**
   * @remarks
   * The keyword that is used in verification.
   * 
   * @example
   * aliyun
   */
  validateKeywords?: string;
  /**
   * @remarks
   * The verification method. Valid values:
   * 
   * *   0: no verification
   * *   1: string verification
   * *   2: MD5 verification
   * 
   * @example
   * 0
   */
  verifyWay?: number;
  /**
   * @remarks
   * The whitelisted objects that are used to avoid DNS hijacking. The objects can be IP addresses, wildcard mask, subnet mask, or CNAME records. Separate multiple objects with vertical bars (|). Example: www.aliyun.com:203.0.3.55|203.3.44.67. It indicates that all IP addresses that belong to the www.aliyun.com domain name except 203.0.3.55 and 203.3.44.67 are hijacked.
   * 
   * @example
   * www.aliyun.com:203.0.3.55|203.3.44.67
   */
  whiteList?: string;
  static names(): { [key: string]: string } {
    return {
      connectionTimeout: 'ConnectionTimeout',
      customHeaderContent: 'CustomHeaderContent',
      downloadKernel: 'DownloadKernel',
      ignoreCertificateAuthError: 'IgnoreCertificateAuthError',
      ignoreCertificateCanceledError: 'IgnoreCertificateCanceledError',
      ignoreCertificateOutOfDateError: 'IgnoreCertificateOutOfDateError',
      ignoreCertificateStatusError: 'IgnoreCertificateStatusError',
      ignoreCertificateUntrustworthyError: 'IgnoreCertificateUntrustworthyError',
      ignoreCertificateUsingError: 'IgnoreCertificateUsingError',
      ignoreInvalidHostError: 'IgnoreInvalidHostError',
      monitorTimeout: 'MonitorTimeout',
      quickProtocol: 'QuickProtocol',
      redirection: 'Redirection',
      targetUrl: 'TargetUrl',
      transmissionSize: 'TransmissionSize',
      validateKeywords: 'ValidateKeywords',
      verifyWay: 'VerifyWay',
      whiteList: 'WhiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connectionTimeout: 'number',
      customHeaderContent: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      downloadKernel: 'number',
      ignoreCertificateAuthError: 'number',
      ignoreCertificateCanceledError: 'number',
      ignoreCertificateOutOfDateError: 'number',
      ignoreCertificateStatusError: 'number',
      ignoreCertificateUntrustworthyError: 'number',
      ignoreCertificateUsingError: 'number',
      ignoreInvalidHostError: 'number',
      monitorTimeout: 'number',
      quickProtocol: 'number',
      redirection: 'number',
      targetUrl: 'string',
      transmissionSize: 'number',
      validateKeywords: 'string',
      verifyWay: 'number',
      whiteList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTimingSyntheticTaskRequestMonitorConfNetDNS extends $tea.Model {
  /**
   * @remarks
   * The IP version of the DNS server.
   * 
   * *   0 (default): IPv4.
   * *   1: IPv6.
   * *   2: A version is automatically selected.
   * 
   * @example
   * 0
   */
  dnsServerIpType?: number;
  /**
   * @remarks
   * The IP address of the DNS server. Default value: 114.114.114.114.
   * 
   * @example
   * 114.114.114.114
   */
  nsServer?: string;
  /**
   * @remarks
   * The DNS query method. Valid values:
   * 
   * *   0 (default): recursive
   * *   1: iterative
   * 
   * @example
   * 0
   */
  queryMethod?: number;
  /**
   * @remarks
   * The destination domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * www.aliyun.com
   */
  targetUrl?: string;
  /**
   * @remarks
   * The timeout period for the DNS synthetic test. Unit: milliseconds. Minimum value: 1000. Maximum value: 45000. Default value: 5000.
   * 
   * @example
   * 5000
   */
  timeout?: number;
  static names(): { [key: string]: string } {
    return {
      dnsServerIpType: 'DnsServerIpType',
      nsServer: 'NsServer',
      queryMethod: 'QueryMethod',
      targetUrl: 'TargetUrl',
      timeout: 'Timeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dnsServerIpType: 'number',
      nsServer: 'string',
      queryMethod: 'number',
      targetUrl: 'string',
      timeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTimingSyntheticTaskRequestMonitorConfNetICMP extends $tea.Model {
  /**
   * @remarks
   * The interval at which ICMP packets are sent. Unit: milliseconds. Minimum value: 200. Maximum value: 2000. Default value: 200.
   * 
   * @example
   * 200
   */
  interval?: number;
  /**
   * @remarks
   * The number of ICMP packets that are sent. Minimum value: 1. Maximum value: 50. Default value: 4.
   * 
   * @example
   * 4
   */
  packageNum?: number;
  /**
   * @remarks
   * The size of each ICMP packet. Unit: bytes. Valid values: 32, 64, 128, 256, 512, 1024, 1080, and 1450.
   * 
   * @example
   * 32
   */
  packageSize?: number;
  /**
   * @remarks
   * Specifies whether to split ICMP packets. Default value: true.
   * 
   * @example
   * true
   */
  splitPackage?: boolean;
  /**
   * @remarks
   * The destination IP address or domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * www.example.com
   */
  targetUrl?: string;
  /**
   * @remarks
   * The timeout period for the ICMP synthetic test. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 20000.
   * 
   * @example
   * 20000
   */
  timeout?: number;
  /**
   * @remarks
   * Specifies whether to enable the tracert command. Default value: true.
   * 
   * @example
   * true
   */
  tracertEnable?: boolean;
  /**
   * @remarks
   * The maximum number of hops for the tracert command. Minimum value: 1. Maximum value: 128. Default value: 20.
   * 
   * @example
   * 20
   */
  tracertNumMax?: number;
  /**
   * @remarks
   * The timeout period of the tracert command. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 60000.
   * 
   * @example
   * 60000
   */
  tracertTimeout?: number;
  static names(): { [key: string]: string } {
    return {
      interval: 'Interval',
      packageNum: 'PackageNum',
      packageSize: 'PackageSize',
      splitPackage: 'SplitPackage',
      targetUrl: 'TargetUrl',
      timeout: 'Timeout',
      tracertEnable: 'TracertEnable',
      tracertNumMax: 'TracertNumMax',
      tracertTimeout: 'TracertTimeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      interval: 'number',
      packageNum: 'number',
      packageSize: 'number',
      splitPackage: 'boolean',
      targetUrl: 'string',
      timeout: 'number',
      tracertEnable: 'boolean',
      tracertNumMax: 'number',
      tracertTimeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTimingSyntheticTaskRequestMonitorConfNetTCP extends $tea.Model {
  /**
   * @remarks
   * The number of TCP connections that are established. Minimum value: 1. Maximum value: 16. Default value: 4.
   * 
   * @example
   * 4
   */
  connectTimes?: number;
  /**
   * @remarks
   * The interval at which TCP connections are established. Unit: milliseconds. Minimum value: 200. Maximum value: 10000. Default value: 200.
   * 
   * @example
   * 200
   */
  interval?: number;
  /**
   * @remarks
   * The IP address of the destination host.
   * 
   * This parameter is required.
   * 
   * @example
   * www.example.com
   */
  targetUrl?: string;
  /**
   * @remarks
   * The timeout period for the TCP synthetic test. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 20000.
   * 
   * @example
   * 20000
   */
  timeout?: number;
  /**
   * @remarks
   * Specifies whether to enable the tracert command. Default value: true.
   * 
   * @example
   * true
   */
  tracertEnable?: boolean;
  /**
   * @remarks
   * The maximum number of hops for the tracert command. Minimum value: 1. Maximum value: 128. Default value: 20.
   * 
   * @example
   * 20
   */
  tracertNumMax?: number;
  /**
   * @remarks
   * The timeout period of the tracert command. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 60000.
   * 
   * @example
   * 60000
   */
  tracertTimeout?: number;
  static names(): { [key: string]: string } {
    return {
      connectTimes: 'ConnectTimes',
      interval: 'Interval',
      targetUrl: 'TargetUrl',
      timeout: 'Timeout',
      tracertEnable: 'TracertEnable',
      tracertNumMax: 'TracertNumMax',
      tracertTimeout: 'TracertTimeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connectTimes: 'number',
      interval: 'number',
      targetUrl: 'string',
      timeout: 'number',
      tracertEnable: 'boolean',
      tracertNumMax: 'number',
      tracertTimeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTimingSyntheticTaskRequestMonitorConfStream extends $tea.Model {
  /**
   * @remarks
   * The custom header. Format: JSON map.
   */
  customHeaderContent?: { [key: string]: string };
  /**
   * @remarks
   * The player. Default value: 12. Valid values:
   * 
   * *   12: VLC
   * *   2: Flash Player
   * 
   * @example
   * 12
   */
  playerType?: number;
  /**
   * @remarks
   * The address type of the resource. Valid values:
   * 
   * *   1: resource URL
   * *   0 (default): page URL
   * 
   * @example
   * 0
   */
  streamAddressType?: number;
  /**
   * @remarks
   * The monitoring duration. Unit: seconds. Maximum and default value: 60.
   * 
   * @example
   * 30
   */
  streamMonitorTimeout?: number;
  /**
   * @remarks
   * Specifies whether the resource is a video or audio. Valid values: 0: video. 1: audio.
   * 
   * @example
   * 0
   */
  streamType?: number;
  /**
   * @remarks
   * The resource URL of the streaming media.
   * 
   * @example
   * http://www.aliyun.com/stream/test.mp4
   */
  targetUrl?: string;
  /**
   * @remarks
   * The whitelisted objects that are used to avoid DNS hijacking. The objects can be IP addresses, wildcard mask, subnet mask, or CNAME records. Separate multiple objects with vertical bars (|). Example: www.aliyun.com:203.0.3.55|203.3.44.67. It indicates that all IP addresses that belong to the www.aliyun.com domain name except 203.0.3.55 and 203.3.44.67 are hijacked.
   * 
   * @example
   * www.aliyun.com:203.0.3.55|203.3.44.67
   */
  whiteList?: string;
  static names(): { [key: string]: string } {
    return {
      customHeaderContent: 'CustomHeaderContent',
      playerType: 'PlayerType',
      streamAddressType: 'StreamAddressType',
      streamMonitorTimeout: 'StreamMonitorTimeout',
      streamType: 'StreamType',
      targetUrl: 'TargetUrl',
      whiteList: 'WhiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customHeaderContent: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      playerType: 'number',
      streamAddressType: 'number',
      streamMonitorTimeout: 'number',
      streamType: 'number',
      targetUrl: 'string',
      whiteList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTimingSyntheticTaskRequestMonitorConfWebsite extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to automatically scroll up and down the screen to load a page.
   * 
   * *   0 (default): no
   * *   1: yes
   * 
   * @example
   * 0
   */
  automaticScrolling?: number;
  /**
   * @remarks
   * Specifies whether to create a custom header.
   * 
   * *   0 (default): No custom header is created.
   * *   1: A custom header is created for the first packet.
   * *   2: A custom header is created for all packets.
   * 
   * @example
   * 0
   */
  customHeader?: number;
  /**
   * @remarks
   * The custom header. Format: JSON map.
   */
  customHeaderContent?: { [key: string]: string };
  /**
   * @remarks
   * If the IP address or CNAME record resolved from a domain name is not included in the DNS whitelist, you cannot access the domain name, or an IP address that belongs to a different domain name is returned. If the IP address or CNAME record is included in the DNS whitelist, DNS hijacking does not occur.
   * 
   * Format: \\<domain name>:\\<objects>. The objects can be IP addresses, wildcard mask, subnet mask, or CNAME records. Separate multiple objects with vertical bars (|). Example: www.aliyun.com:203.0.3.55|203.3.44.67. It indicates that all IP addresses that belong to the www.aliyun.com domain name except 203.0.3.55 and 203.3.44.67 are hijacked.
   * 
   * @example
   * www.aliyun.com:203.0.3.55|203.3.44.67
   */
  DNSHijackWhitelist?: string;
  /**
   * @remarks
   * Specifies whether to disable caching.
   * 
   * *   0: no
   * *   1 (default): yes
   * 
   * @example
   * 1
   */
  disableCache?: number;
  /**
   * @remarks
   * Specifies whether to accept compressed files based on the HTTP Accept-Encoding request header. Valid values: 0: no. 1: yes. Default value: 0.
   * 
   * @example
   * 0
   */
  disableCompression?: number;
  /**
   * @remarks
   * The elements not to be loaded in the page loading process.
   * 
   * @example
   * www.example.com/a.jpg
   */
  elementBlacklist?: string;
  /**
   * @remarks
   * Specifies whether to exclude invalid IP addresses. Valid values: 0: yes. 1: no. Default value: 0.
   * 
   * @example
   * 0
   */
  filterInvalidIP?: number;
  /**
   * @remarks
   * The total number of elements on the page.
   * 
   * @example
   * 10
   */
  flowHijackJumpTimes?: number;
  /**
   * @remarks
   * The keyword that is used to identify hijacking. Asterisks (\\*) are allowed.
   * 
   * @example
   * aliyun
   */
  flowHijackLogo?: string;
  /**
   * @remarks
   * Specifies whether to ignore certificate errors during certificate verification in the SSL handshake process and continue browsing. Valid values: 0: no. 1: yes. Default value: 1.
   * 
   * @example
   * 1
   */
  ignoreCertificateError?: number;
  /**
   * @remarks
   * The monitoring timeout period. Unit: milliseconds. This parameter is optional. Default value: 20000.
   * 
   * @example
   * 20000
   */
  monitorTimeout?: number;
  /**
   * @remarks
   * Elements that are not included in the whitelist and appear on the page are tampered with. These elements can be pop-up ads, floating ads, and page redirection.
   * 
   * Format: \\<domain name>:\\<elements>. The elements can be wildcard masks. Separate multiple elements with vertical bars (|). Example: www.aliyun.com:|/cc/bb/a.gif|/vv/bb/cc.jpg. It indicates that all elements that belong to the www.aliyun.com domain name except the basic documents, /cc/bb/a.gif, and /vv/bb/cc.jpg are tampered with.
   * 
   * @example
   * www.aliyun.com:|/cc/bb/a.gif|/vv/bb/cc.jpg
   */
  pageTamper?: string;
  /**
   * @remarks
   * Specifies whether to continue browsing after redirection. Valid values: 0: no. 1: yes. Default value: 1.
   * 
   * @example
   * 1
   */
  redirection?: number;
  /**
   * @remarks
   * The time threshold that is used to define a slow element. Unit: milliseconds. Default value: 5000. Minimum value: 1. Maximum value: 300000.
   * 
   * @example
   * 5000
   */
  slowElementThreshold?: number;
  /**
   * @remarks
   * The URL of the website.
   * 
   * This parameter is required.
   * 
   * @example
   * https://www.aliyun.com
   */
  targetUrl?: string;
  /**
   * @remarks
   * An arbitrary string in the source code of the page for verification. If the source code returned by the client contains a string that is in the blacklist, the 650 error code is reported, which indicates that the string fails to be verified. Separate multiple strings with vertical bars (|).
   * 
   * @example
   * error
   */
  verifyStringBlacklist?: string;
  /**
   * @remarks
   * An arbitrary string in the source code of the page for verification. If the source code returned by the client contains a string that is not in the whitelist, the 650 error code is reported, which indicates that the string fails to be verified. Separate multiple strings with vertical bars (|).
   * 
   * @example
   * success
   */
  verifyStringWhitelist?: string;
  /**
   * @remarks
   * The maximum waiting time. Unit: milliseconds. Default value: 5000. Minimum value: 5000. Maximum value: 300000.
   * 
   * @example
   * 5000
   */
  waitCompletionTime?: number;
  static names(): { [key: string]: string } {
    return {
      automaticScrolling: 'AutomaticScrolling',
      customHeader: 'CustomHeader',
      customHeaderContent: 'CustomHeaderContent',
      DNSHijackWhitelist: 'DNSHijackWhitelist',
      disableCache: 'DisableCache',
      disableCompression: 'DisableCompression',
      elementBlacklist: 'ElementBlacklist',
      filterInvalidIP: 'FilterInvalidIP',
      flowHijackJumpTimes: 'FlowHijackJumpTimes',
      flowHijackLogo: 'FlowHijackLogo',
      ignoreCertificateError: 'IgnoreCertificateError',
      monitorTimeout: 'MonitorTimeout',
      pageTamper: 'PageTamper',
      redirection: 'Redirection',
      slowElementThreshold: 'SlowElementThreshold',
      targetUrl: 'TargetUrl',
      verifyStringBlacklist: 'VerifyStringBlacklist',
      verifyStringWhitelist: 'VerifyStringWhitelist',
      waitCompletionTime: 'WaitCompletionTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      automaticScrolling: 'number',
      customHeader: 'number',
      customHeaderContent: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      DNSHijackWhitelist: 'string',
      disableCache: 'number',
      disableCompression: 'number',
      elementBlacklist: 'string',
      filterInvalidIP: 'number',
      flowHijackJumpTimes: 'number',
      flowHijackLogo: 'string',
      ignoreCertificateError: 'number',
      monitorTimeout: 'number',
      pageTamper: 'string',
      redirection: 'number',
      slowElementThreshold: 'number',
      targetUrl: 'string',
      verifyStringBlacklist: 'string',
      verifyStringWhitelist: 'string',
      waitCompletionTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTimingSyntheticTaskRequestMonitorConf extends $tea.Model {
  /**
   * @remarks
   * The parameters of the HTTP(S) synthetic test.
   */
  apiHTTP?: CreateTimingSyntheticTaskRequestMonitorConfApiHTTP;
  /**
   * @remarks
   * The parameters of file downloading.
   */
  fileDownload?: CreateTimingSyntheticTaskRequestMonitorConfFileDownload;
  /**
   * @remarks
   * The parameters of the DNS synthetic test. This parameter is required if the TaskType parameter is set to 3.
   */
  netDNS?: CreateTimingSyntheticTaskRequestMonitorConfNetDNS;
  /**
   * @remarks
   * The parameters of the ICMP synthetic test. This parameter is required if the TaskType parameter is set to 1.
   */
  netICMP?: CreateTimingSyntheticTaskRequestMonitorConfNetICMP;
  /**
   * @remarks
   * The parameters of the TCP synthetic test. This parameter is required if the TaskType parameter is set to 2.
   */
  netTCP?: CreateTimingSyntheticTaskRequestMonitorConfNetTCP;
  /**
   * @remarks
   * The parameters of the streaming-media synthetic test.
   */
  stream?: CreateTimingSyntheticTaskRequestMonitorConfStream;
  /**
   * @remarks
   * The parameters of the website speed measurement.
   */
  website?: CreateTimingSyntheticTaskRequestMonitorConfWebsite;
  static names(): { [key: string]: string } {
    return {
      apiHTTP: 'ApiHTTP',
      fileDownload: 'FileDownload',
      netDNS: 'NetDNS',
      netICMP: 'NetICMP',
      netTCP: 'NetTCP',
      stream: 'Stream',
      website: 'Website',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiHTTP: CreateTimingSyntheticTaskRequestMonitorConfApiHTTP,
      fileDownload: CreateTimingSyntheticTaskRequestMonitorConfFileDownload,
      netDNS: CreateTimingSyntheticTaskRequestMonitorConfNetDNS,
      netICMP: CreateTimingSyntheticTaskRequestMonitorConfNetICMP,
      netTCP: CreateTimingSyntheticTaskRequestMonitorConfNetTCP,
      stream: CreateTimingSyntheticTaskRequestMonitorConfStream,
      website: CreateTimingSyntheticTaskRequestMonitorConfWebsite,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTimingSyntheticTaskRequestMonitors extends $tea.Model {
  /**
   * @remarks
   * The city code.
   * 
   * This parameter is required.
   * 
   * @example
   * 100023
   */
  cityCode?: string;
  /**
   * @remarks
   * The client type of the detection point. Valid values:
   * 
   * - 1: data center
   * - 2: Internet
   * - 3: mobile device
   * - 4: ECS instance
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  clientType?: number;
  /**
   * @remarks
   * The carrier code.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  operatorCode?: string;
  static names(): { [key: string]: string } {
    return {
      cityCode: 'CityCode',
      clientType: 'ClientType',
      operatorCode: 'OperatorCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cityCode: 'string',
      clientType: 'number',
      operatorCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTimingSyntheticTaskRequestTags extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * Key
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * 500
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTimingSyntheticTaskResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The task status. Valid values:
   * 
   * - INIT: The task is in the initial state.
   * - RELEASE: The task is being parsed.
   * - RUNNING: The task is running.
   * - STOP: The task is suspended.
   * - SYSTEM_STOP: The task is suspended by the system.
   * - CANCEL: The task is canceled.
   * - SYSTEM_CANCEL: The task is canceled by the system.
   * - DONE: The task is complete.
   * 
   * @example
   * RUNNING
   */
  status?: string;
  /**
   * @remarks
   * The ID of the synthetic monitoring task.
   * 
   * @example
   * 5308a2691f59422c8c3b7aeccec9cd3b
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTraceAppRequestDeleteReasonReasonIds extends $tea.Model {
  /**
   * @remarks
   * The ID of the reason for deletion.
   * 
   * @example
   * 0
   */
  id?: number;
  /**
   * @remarks
   * A description of the reason for removal.
   * 
   * @example
   * The function is not perfect, and the root cause of the problem cannot be located.
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTraceAppRequestDeleteReason extends $tea.Model {
  /**
   * @remarks
   * Reasons Ids.
   */
  reasonIds?: DeleteTraceAppRequestDeleteReasonReasonIds[];
  /**
   * @remarks
   * Additional remarks when none of the reasons for removal provided are met.
   * 
   * @example
   * The business scenario cannot be satisfied.
   */
  remark?: string;
  static names(): { [key: string]: string } {
    return {
      reasonIds: 'ReasonIds',
      remark: 'Remark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      reasonIds: { 'type': 'array', 'itemType': DeleteTraceAppRequestDeleteReasonReasonIds },
      remark: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAddonReleaseResponseBodyDataReleaseConditions extends $tea.Model {
  /**
   * @remarks
   * The first transition time.
   * 
   * @example
   * 2018-01-31T14:32:19Z
   */
  firstTransitionTime?: string;
  /**
   * @remarks
   * The last transition time.
   * 
   * @example
   * 2018-01-31T14:32:19Z
   */
  lastTransitionTime?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * xxxx
   */
  message?: string;
  /**
   * @remarks
   * The reason for the failure.
   * 
   * @example
   * xxxx
   */
  reason?: string;
  /**
   * @remarks
   * The status of the phase.
   * 
   * @example
   * True
   */
  status?: string;
  /**
   * @remarks
   * The type of the phase.
   * 
   * @example
   * Loaded
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      firstTransitionTime: 'FirstTransitionTime',
      lastTransitionTime: 'LastTransitionTime',
      message: 'Message',
      reason: 'Reason',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firstTransitionTime: 'string',
      lastTransitionTime: 'string',
      message: 'string',
      reason: 'string',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAddonReleaseResponseBodyDataRelease extends $tea.Model {
  /**
   * @remarks
   * The name of the add-on.
   * 
   * @example
   * mysql
   */
  addonName?: string;
  /**
   * @remarks
   * The number of alert rules.
   * 
   * @example
   * 1
   */
  alertRuleCount?: number;
  /**
   * @remarks
   * The installation phase.
   */
  conditions?: DescribeAddonReleaseResponseBodyDataReleaseConditions[];
  /**
   * @remarks
   * The time when the add-on was created.
   * 
   * @example
   * 2023-09-22T16:56:29+08:00
   */
  createTime?: string;
  /**
   * @remarks
   * The number of dashboards.
   * 
   * @example
   * 1
   */
  dashboardCount?: number;
  /**
   * @remarks
   * The environment ID.
   * 
   * @example
   * env-xxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The number of exporters.
   * 
   * @example
   * 2
   */
  exporterCount?: number;
  /**
   * @remarks
   * Indicates whether the configuration is available.
   * 
   * @example
   * true
   */
  haveConfig?: boolean;
  /**
   * @remarks
   * The user ID.
   * 
   * @example
   * 23810923891
   */
  installUserId?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * zh
   */
  language?: string;
  /**
   * @remarks
   * Indicates whether the component is fully managed.
   */
  managed?: boolean;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-heyuan
   */
  regionId?: string;
  /**
   * @remarks
   * The release ID after installation.
   * 
   * @example
   * be29c093-3fd6-4fb6-9430-797030cc183a
   */
  releaseId?: string;
  /**
   * @remarks
   * The name of the release.
   * 
   * @example
   * mysql-1695372983039
   */
  releaseName?: string;
  /**
   * @remarks
   * The scenario.
   * 
   * @example
   * database
   */
  scene?: string;
  /**
   * @remarks
   * The status.
   * 
   * @example
   * 0
   */
  status?: string;
  /**
   * @remarks
   * The time when the add-on was updated.
   * 
   * @example
   * 2023-09-22T16:56:29+08:00
   */
  updateTime?: string;
  /**
   * @remarks
   * The user ID.
   * 
   * @example
   * 13818734031
   */
  userID?: string;
  /**
   * @remarks
   * The version of the add-on.
   * 
   * @example
   * 0.0.1
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      addonName: 'AddonName',
      alertRuleCount: 'AlertRuleCount',
      conditions: 'Conditions',
      createTime: 'CreateTime',
      dashboardCount: 'DashboardCount',
      environmentId: 'EnvironmentId',
      exporterCount: 'ExporterCount',
      haveConfig: 'HaveConfig',
      installUserId: 'InstallUserId',
      language: 'Language',
      managed: 'Managed',
      regionId: 'RegionId',
      releaseId: 'ReleaseId',
      releaseName: 'ReleaseName',
      scene: 'Scene',
      status: 'Status',
      updateTime: 'UpdateTime',
      userID: 'UserID',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addonName: 'string',
      alertRuleCount: 'number',
      conditions: { 'type': 'array', 'itemType': DescribeAddonReleaseResponseBodyDataReleaseConditions },
      createTime: 'string',
      dashboardCount: 'number',
      environmentId: 'string',
      exporterCount: 'number',
      haveConfig: 'boolean',
      installUserId: 'string',
      language: 'string',
      managed: 'boolean',
      regionId: 'string',
      releaseId: 'string',
      releaseName: 'string',
      scene: 'string',
      status: 'string',
      updateTime: 'string',
      userID: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAddonReleaseResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The configuration information of the add-on release.
   * 
   * @example
   * {"host":"mysql-service.default","port":3306,"username":"root","password":"roots"}
   */
  config?: string;
  /**
   * @remarks
   * The release information.
   */
  release?: DescribeAddonReleaseResponseBodyDataRelease;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      release: 'Release',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      release: DescribeAddonReleaseResponseBodyDataRelease,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert contact.
   * 
   * @example
   * 100117
   */
  armsContactId?: number;
  /**
   * @remarks
   * The ID of the alert contact.
   * 
   * @example
   * 456
   */
  contactId?: number;
  /**
   * @remarks
   * The name of the alert contact.
   * 
   * @example
   * John Doe
   */
  contactName?: string;
  /**
   * @remarks
   * The email address of the alert contact.
   * 
   * @example
   * someone@example.com
   */
  email?: string;
  /**
   * @remarks
   * The mobile number of the alert contact.
   * 
   * @example
   * 1381111****
   */
  phone?: string;
  static names(): { [key: string]: string } {
    return {
      armsContactId: 'ArmsContactId',
      contactId: 'ContactId',
      contactName: 'ContactName',
      email: 'Email',
      phone: 'Phone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      armsContactId: 'number',
      contactId: 'number',
      contactName: 'string',
      email: 'string',
      phone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactGroupsResponseBodyPageBeanAlertContactGroups extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert contact group.
   * 
   * @example
   * 83261
   */
  armsContactGroupId?: number;
  /**
   * @remarks
   * The ID of the alert contact group.
   * 
   * @example
   * 123
   */
  contactGroupId?: number;
  /**
   * @remarks
   * The name of the alert contact group.
   * 
   * @example
   * TestGroup
   */
  contactGroupName?: string;
  /**
   * @remarks
   * The contact information. If the **IsDetail** parameter is set to `false`, no **contact** information is displayed.
   */
  contacts?: DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts[];
  static names(): { [key: string]: string } {
    return {
      armsContactGroupId: 'ArmsContactGroupId',
      contactGroupId: 'ContactGroupId',
      contactGroupName: 'ContactGroupName',
      contacts: 'Contacts',
    };
  }

  static types(): { [key: string]: any } {
    return {
      armsContactGroupId: 'number',
      contactGroupId: 'number',
      contactGroupName: 'string',
      contacts: { 'type': 'array', 'itemType': DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactGroupsResponseBodyPageBean extends $tea.Model {
  /**
   * @remarks
   * The name of the alert contact group.
   */
  alertContactGroups?: DescribeContactGroupsResponseBodyPageBeanAlertContactGroups[];
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of alert contact groups displayed on each page.
   * 
   * @example
   * 20
   */
  size?: number;
  /**
   * @remarks
   * The total number of alert contact groups.
   * 
   * @example
   * 1
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      alertContactGroups: 'AlertContactGroups',
      page: 'Page',
      size: 'Size',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertContactGroups: { 'type': 'array', 'itemType': DescribeContactGroupsResponseBodyPageBeanAlertContactGroups },
      page: 'number',
      size: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactsResponseBodyPageBeanAlertContacts extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert contact.
   * 
   * @example
   * 100147
   */
  armsContactId?: number;
  /**
   * @remarks
   * The ID of the alert contact.
   * 
   * @example
   * 123
   */
  contactId?: number;
  /**
   * @remarks
   * The name of the alert contact.
   * 
   * @example
   * John Doe
   */
  contactName?: string;
  /**
   * @remarks
   * The email address of the alert contact.
   * 
   * @example
   * someone@example.com
   */
  email?: string;
  /**
   * @remarks
   * Indicates whether the email address was verified.
   * 
   * @example
   * true
   */
  isEmailVerify?: boolean;
  /**
   * @remarks
   * Indicates whether the mobile number was verified. Valid values:
   * 
   * *   `false`: no
   * *   `true`: yes
   * 
   * @example
   * false
   */
  isVerify?: boolean;
  /**
   * @remarks
   * The mobile number of the alert contact.
   * 
   * @example
   * 1381111****
   */
  phone?: string;
  /**
   * @remarks
   * The operation that you want to perform if phone calls fail to be answered. Valid values:
   * 
   * *   0: No operation is performed.
   * *   1: A phone call is made again.
   * *   2: A text message is sent.
   * *   3 (default value): The global default value is used.
   * 
   * @example
   * 3
   */
  reissueSendNotice?: number;
  static names(): { [key: string]: string } {
    return {
      armsContactId: 'ArmsContactId',
      contactId: 'ContactId',
      contactName: 'ContactName',
      email: 'Email',
      isEmailVerify: 'IsEmailVerify',
      isVerify: 'IsVerify',
      phone: 'Phone',
      reissueSendNotice: 'ReissueSendNotice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      armsContactId: 'number',
      contactId: 'number',
      contactName: 'string',
      email: 'string',
      isEmailVerify: 'boolean',
      isVerify: 'boolean',
      phone: 'string',
      reissueSendNotice: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContactsResponseBodyPageBean extends $tea.Model {
  /**
   * @remarks
   * The alert contacts.
   */
  alertContacts?: DescribeContactsResponseBodyPageBeanAlertContacts[];
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of alert contacts returned per page.
   * 
   * @example
   * 20
   */
  size?: number;
  /**
   * @remarks
   * The total number of alert contacts.
   * 
   * @example
   * 1
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      alertContacts: 'AlertContacts',
      page: 'Page',
      size: 'Size',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertContacts: { 'type': 'array', 'itemType': DescribeContactsResponseBodyPageBeanAlertContacts },
      page: 'number',
      size: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDispatchRuleResponseBodyDispatchRuleGroupRules extends $tea.Model {
  /**
   * @remarks
   * The ID of the group.
   * 
   * @example
   * 1
   */
  groupId?: number;
  /**
   * @remarks
   * The grouping interval.
   * 
   * @example
   * 15
   */
  groupInterval?: number;
  /**
   * @remarks
   * The waiting time for grouping.
   * 
   * @example
   * 10
   */
  groupWaitTime?: number;
  /**
   * @remarks
   * The grouping fields.
   */
  groupingFields?: string[];
  /**
   * @remarks
   * The time interval at which a notification is resent for a long-lasting unresolved alert. Unit: seconds.
   * 
   * @example
   * 20
   */
  repeatInterval?: number;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      groupInterval: 'GroupInterval',
      groupWaitTime: 'GroupWaitTime',
      groupingFields: 'GroupingFields',
      repeatInterval: 'RepeatInterval',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      groupInterval: 'number',
      groupWaitTime: 'number',
      groupingFields: { 'type': 'array', 'itemType': 'string' },
      repeatInterval: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions extends $tea.Model {
  /**
   * @remarks
   * The key of the tag of the dispatch rule. Valid values:
   * 
   * *   `_aliyun_arms_userid`: user ID
   * *   `_aliyun_arms_involvedObject_kind`: type of the associated object
   * *   `_aliyun_arms_involvedObject_id`: ID of the associated object
   * *   `_aliyun_arms_involvedObject_name`: name of the associated object
   * *   `_aliyun_arms_alert_name`: alert name
   * *   `_aliyun_arms_alert_rule_id`: alert rule ID
   * *   `_aliyun_arms_alert_type`: alert type
   * *   `_aliyun_arms_alert_level`: alert severity
   * 
   * @example
   * _aliyun_arms_involvedObject_kind
   */
  key?: string;
  /**
   * @remarks
   * The operator used in the dispatch rule. Valid values:
   * 
   * *   `eq`: equals to.
   * *   `re`: matches a regular expression.
   * 
   * @example
   * eq
   */
  operator?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * app
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      operator: 'Operator',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      operator: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups extends $tea.Model {
  /**
   * @remarks
   * The collection of conditions of the dispatch rule.
   */
  labelMatchExpressions?: DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions[];
  static names(): { [key: string]: string } {
    return {
      labelMatchExpressions: 'LabelMatchExpressions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      labelMatchExpressions: { 'type': 'array', 'itemType': DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGrid extends $tea.Model {
  /**
   * @remarks
   * The collection of dispatch rules.
   */
  labelMatchExpressionGroups?: DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups[];
  static names(): { [key: string]: string } {
    return {
      labelMatchExpressionGroups: 'LabelMatchExpressionGroups',
    };
  }

  static types(): { [key: string]: any } {
    return {
      labelMatchExpressionGroups: { 'type': 'array', 'itemType': DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects extends $tea.Model {
  /**
   * @remarks
   * The name of the contact or contact group.
   * 
   * @example
   * JohnDoe
   */
  name?: string;
  /**
   * @remarks
   * The ID of the contact or contact group.
   * 
   * @example
   * 1
   */
  notifyObjectId?: string;
  /**
   * @remarks
   * The type of the alert contact. Valid values:
   * 
   * - `CONTACT`: contact
   * - `CONTACT_GROUP`: contact group
   * 
   * @example
   * CONTACT
   */
  notifyType?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      notifyObjectId: 'NotifyObjectId',
      notifyType: 'NotifyType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      notifyObjectId: 'string',
      notifyType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules extends $tea.Model {
  /**
   * @remarks
   * The notification method Array.
   */
  notifyChannels?: string[];
  /**
   * @remarks
   * The collection of alert contacts.
   */
  notifyObjects?: DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects[];
  static names(): { [key: string]: string } {
    return {
      notifyChannels: 'NotifyChannels',
      notifyObjects: 'NotifyObjects',
    };
  }

  static types(): { [key: string]: any } {
    return {
      notifyChannels: { 'type': 'array', 'itemType': 'string' },
      notifyObjects: { 'type': 'array', 'itemType': DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDispatchRuleResponseBodyDispatchRule extends $tea.Model {
  /**
   * @remarks
   * Alarm handling method.
   * 
   * CREATE_ALERT: Generate an alert.
   * 
   * DISCARD_ALERT: Discard the alarm event, that is, no alarm.
   * 
   * @example
   * CREATE_ALERT
   */
  dispatchType?: string;
  /**
   * @remarks
   * The information about groups.
   */
  groupRules?: DescribeDispatchRuleResponseBodyDispatchRuleGroupRules[];
  /**
   * @remarks
   * Whether to send recovered alerts.
   * true: send.
   * false: do not send.
   * 
   * @example
   * true
   */
  isRecover?: boolean;
  /**
   * @remarks
   * The information about the dispatch rule.
   */
  labelMatchExpressionGrid?: DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGrid;
  /**
   * @remarks
   * The name of the dispatch policy.
   * 
   * @example
   * Prometheus Alert
   */
  name?: string;
  /**
   * @remarks
   * The collection of notification methods.
   */
  notifyRules?: DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules[];
  /**
   * @remarks
   * The ID of the dispatch rule.
   * 
   * @example
   * 10282
   */
  ruleId?: number;
  /**
   * @remarks
   * Indicates whether the dispatch policy is enabled. Valid values: 
   * 
   * - `true`: enabled
   * - `false`: disabled
   * 
   * @example
   * true
   */
  state?: string;
  static names(): { [key: string]: string } {
    return {
      dispatchType: 'DispatchType',
      groupRules: 'GroupRules',
      isRecover: 'IsRecover',
      labelMatchExpressionGrid: 'LabelMatchExpressionGrid',
      name: 'Name',
      notifyRules: 'NotifyRules',
      ruleId: 'RuleId',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dispatchType: 'string',
      groupRules: { 'type': 'array', 'itemType': DescribeDispatchRuleResponseBodyDispatchRuleGroupRules },
      isRecover: 'boolean',
      labelMatchExpressionGrid: DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGrid,
      name: 'string',
      notifyRules: { 'type': 'array', 'itemType': DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules },
      ruleId: 'number',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEnvCustomJobResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * If the **encryptYaml** parameter is set to `true`, a Base64-encoded YAML string is returned. Otherwise, a plaintext YAML string is returned.
   * 
   * @example
   * Refer to supplementary instructions.
   */
  configYaml?: string;
  /**
   * @remarks
   * The name of the custom job.
   * 
   * @example
   * customJob1
   */
  customJobName?: string;
  /**
   * @remarks
   * The ID of the environment instance.
   * 
   * @example
   * env-xxxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The status. Valid values:
   * 
   * *   run
   * *   stop
   * 
   * @example
   * run
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      configYaml: 'ConfigYaml',
      customJobName: 'CustomJobName',
      environmentId: 'EnvironmentId',
      regionId: 'RegionId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configYaml: 'string',
      customJobName: 'string',
      environmentId: 'string',
      regionId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEnvPodMonitorResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The YAML string of the PodMonitor.
   * 
   * @example
   * Refer to supplementary instructions.
   */
  configYaml?: string;
  /**
   * @remarks
   * The ID of the environment instance.
   * 
   * @example
   * env-xxxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The namespace.
   * 
   * @example
   * arms-prom
   */
  namespace?: string;
  /**
   * @remarks
   * The name of the PodMonitor.
   * 
   * @example
   * podMonitor1
   */
  podMonitorName?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The status. Valid values:
   * 
   * *   run
   * *   stop
   * 
   * @example
   * run
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      configYaml: 'ConfigYaml',
      environmentId: 'EnvironmentId',
      namespace: 'Namespace',
      podMonitorName: 'PodMonitorName',
      regionId: 'RegionId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configYaml: 'string',
      environmentId: 'string',
      namespace: 'string',
      podMonitorName: 'string',
      regionId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEnvServiceMonitorResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The YAML configuration file of the ServiceMonitor.
   * 
   * @example
   * Refer to supplementary instructions.
   */
  configYaml?: string;
  /**
   * @remarks
   * The ID of the environment instance.
   * 
   * @example
   * env-xxxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The namespace.
   * 
   * @example
   * arms-prom
   */
  namespace?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The name of the ServiceMonitor.
   * 
   * @example
   * serviceMonitor1
   */
  serviceMonitorName?: string;
  /**
   * @remarks
   * The status. Valid values:
   * 
   * *   run
   * *   stop
   * 
   * @example
   * run
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      configYaml: 'ConfigYaml',
      environmentId: 'EnvironmentId',
      namespace: 'Namespace',
      regionId: 'RegionId',
      serviceMonitorName: 'ServiceMonitorName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configYaml: 'string',
      environmentId: 'string',
      namespace: 'string',
      regionId: 'string',
      serviceMonitorName: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEnvironmentResponseBodyDataTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * user1
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * p_dev
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEnvironmentResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the resource associated with the environment, such as the ACK cluster ID or VPC ID.
   * 
   * @example
   * vpc-xxxxx
   */
  bindResourceId?: string;
  /**
   * @remarks
   * The profile of the resource.
   * 
   * @example
   * Default
   */
  bindResourceProfile?: string;
  /**
   * @remarks
   * The status of the resource.
   * 
   * @example
   * running
   */
  bindResourceStatus?: string;
  /**
   * @remarks
   * The retention period of the resource. Unit: days.
   * 
   * @example
   * 15
   */
  bindResourceStoreDuration?: string;
  /**
   * @remarks
   * The resource type.
   * 
   * @example
   * ECS
   */
  bindResourceType?: string;
  /**
   * @remarks
   * The VPC CIDR block.
   * 
   * @example
   * 192.168.0.0/16
   */
  bindVpcCidr?: string;
  /**
   * @remarks
   * The status of the database that is bound to the Prometheus instance.
   * 
   * Valid values:
   * 
   * *   UNINSTALLING
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   INSTALLING
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   UNINSTALLED
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   RUNNING
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   MODIFYING
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * @example
   * RUNNING
   */
  dbInstanceStatus?: string;
  /**
   * @remarks
   * The ID of the environment instance.
   * 
   * @example
   * env-xxxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The environment name.
   * 
   * @example
   * env1
   */
  environmentName?: string;
  /**
   * @remarks
   * Environment subtypes:
   * - CS: Currently supports ACK.
   * - ECS: ECS is currently supported.
   * - Cloud: Currently supports Cloud.
   * 
   * @example
   * ACK
   */
  environmentSubType?: string;
  /**
   * @remarks
   * The type of the environment. Valid values:
   * 
   * *   CS: Container Service for Kubernetes (ACK)
   * *   ECS: Elastic Compute Service
   * *   Cloud: cloud service
   * 
   * @example
   * CS
   */
  environmentType?: string;
  /**
   * @remarks
   * The payable resource plan. Valid values:
   * 
   * *   If the EnvironmentType parameter is set to CS, set the value to CS_Basic or CS_Pro.
   * *   Otherwise, leave the parameter empty.
   * 
   * @example
   * CS_Basic
   */
  feePackage?: string;
  /**
   * @remarks
   * The name of the Grafana data source.
   * 
   * @example
   * datasource1
   */
  grafaDataSourceName?: string;
  /**
   * @remarks
   * The unique ID of the Grafana data source.
   * 
   * @example
   * zuvw
   */
  grafanaDatasourceUid?: string;
  /**
   * @remarks
   * The name of the Grafana directory.
   * 
   * @example
   * folder1
   */
  grafanaFolderTitle?: string;
  /**
   * @remarks
   * The unique ID of the Grafana directory.
   * 
   * @example
   * xyz
   */
  grafanaFolderUid?: string;
  /**
   * @remarks
   * The URL of the Grafana directory.
   * 
   * @example
   * https://g.console.aliyun.com/dashboards/f/xxx/yyyy
   */
  grafanaFolderUrl?: string;
  /**
   * @remarks
   * The ID of the Grafana workspace.
   * 
   * @example
   * grafana-cn-27a3m8eem0a
   */
  grafanaWorkspaceId?: string;
  /**
   * @remarks
   * managed type:
   * - none: unmanaged. The default value for ACK clusters.
   * - agent: managed agent (including KSM). The default values for ASK, ACS, and AckOne clusters.
   * - agent-exporter: managed agent and exporters. The default value for the cloud service type.
   * 
   * @example
   * none
   */
  managedType?: string;
  /**
   * @remarks
   * The ID of the Prometheus instance.
   * 
   * @example
   * xxxxyyyyyzzzzz
   */
  prometheusInstanceId?: string;
  /**
   * @remarks
   * The name of the Prometheus instance.
   * 
   * @example
   * name1
   */
  prometheusInstanceName?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-aek2vezare****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The ID of the security group associated with the environment.
   * 
   * @example
   * sg-8vbdgmf4nraiqa9bx0jo
   */
  securityGroupId?: string;
  /**
   * @remarks
   * The tags.
   */
  tags?: DescribeEnvironmentResponseBodyDataTags[];
  /**
   * @remarks
   * The user ID.
   * 
   * @example
   * 13002222xxxx
   */
  userId?: string;
  /**
   * @remarks
   * The VPC ID.
   * 
   * @example
   * vpc-8vb02uk57qbcktqcvqqqj
   */
  vpcId?: string;
  /**
   * @remarks
   * The ID of the vSwitch associated with the environment.
   * 
   * @example
   * vsw-2ze7yr3f1x8snryaioo7u
   */
  vswitchId?: string;
  static names(): { [key: string]: string } {
    return {
      bindResourceId: 'BindResourceId',
      bindResourceProfile: 'BindResourceProfile',
      bindResourceStatus: 'BindResourceStatus',
      bindResourceStoreDuration: 'BindResourceStoreDuration',
      bindResourceType: 'BindResourceType',
      bindVpcCidr: 'BindVpcCidr',
      dbInstanceStatus: 'DbInstanceStatus',
      environmentId: 'EnvironmentId',
      environmentName: 'EnvironmentName',
      environmentSubType: 'EnvironmentSubType',
      environmentType: 'EnvironmentType',
      feePackage: 'FeePackage',
      grafaDataSourceName: 'GrafaDataSourceName',
      grafanaDatasourceUid: 'GrafanaDatasourceUid',
      grafanaFolderTitle: 'GrafanaFolderTitle',
      grafanaFolderUid: 'GrafanaFolderUid',
      grafanaFolderUrl: 'GrafanaFolderUrl',
      grafanaWorkspaceId: 'GrafanaWorkspaceId',
      managedType: 'ManagedType',
      prometheusInstanceId: 'PrometheusInstanceId',
      prometheusInstanceName: 'PrometheusInstanceName',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      securityGroupId: 'SecurityGroupId',
      tags: 'Tags',
      userId: 'UserId',
      vpcId: 'VpcId',
      vswitchId: 'VswitchId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindResourceId: 'string',
      bindResourceProfile: 'string',
      bindResourceStatus: 'string',
      bindResourceStoreDuration: 'string',
      bindResourceType: 'string',
      bindVpcCidr: 'string',
      dbInstanceStatus: 'string',
      environmentId: 'string',
      environmentName: 'string',
      environmentSubType: 'string',
      environmentType: 'string',
      feePackage: 'string',
      grafaDataSourceName: 'string',
      grafanaDatasourceUid: 'string',
      grafanaFolderTitle: 'string',
      grafanaFolderUid: 'string',
      grafanaFolderUrl: 'string',
      grafanaWorkspaceId: 'string',
      managedType: 'string',
      prometheusInstanceId: 'string',
      prometheusInstanceName: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      securityGroupId: 'string',
      tags: { 'type': 'array', 'itemType': DescribeEnvironmentResponseBodyDataTags },
      userId: 'string',
      vpcId: 'string',
      vswitchId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEnvironmentFeatureResponseBodyDataFeature extends $tea.Model {
  /**
   * @remarks
   * The alias of the feature.
   * 
   * @example
   * Prometheus agent.
   */
  alias?: string;
  /**
   * @remarks
   * The configuration of the feature.
   */
  config?: { [key: string]: string };
  /**
   * @remarks
   * The description of the feature.
   * 
   * @example
   * Collect Metric data using the Prometheus collection specification.
   */
  description?: string;
  /**
   * @remarks
   * The environment ID.
   * 
   * @example
   * env-xxxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The URL of the icon.
   * 
   * @example
   * http://xxx
   */
  icon?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * zh
   */
  language?: string;
  /**
   * @remarks
   * The latest version number.
   * 
   * @example
   * 1.1.17
   */
  latestVersion?: string;
  /**
   * @remarks
   * Indicates whether the component is fully managed.
   */
  managed?: boolean;
  /**
   * @remarks
   * The name of the feature.
   * 
   * @example
   * metric-agent
   */
  name?: string;
  /**
   * @remarks
   * The installation status of the agent.
   * 
   * *   Installing: The agent is being installed.
   * *   Success: The agent is installed.
   * *   Failed: The agent failed to be installed.
   * *   UnInstall: The agent is uninstalled or has not been installed.
   * *   Uninstalling: The agent is being uninstalled.
   * *   UnInstallFailed: The agent failed to be uninstalled.
   * 
   * @example
   * Success
   */
  status?: string;
  /**
   * @remarks
   * The version number.
   * 
   * @example
   * 1.1.17
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      config: 'Config',
      description: 'Description',
      environmentId: 'EnvironmentId',
      icon: 'Icon',
      language: 'Language',
      latestVersion: 'LatestVersion',
      managed: 'Managed',
      name: 'Name',
      status: 'Status',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      config: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      description: 'string',
      environmentId: 'string',
      icon: 'string',
      language: 'string',
      latestVersion: 'string',
      managed: 'boolean',
      name: 'string',
      status: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers extends $tea.Model {
  /**
   * @remarks
   * The container parameters.
   */
  args?: string[];
  /**
   * @remarks
   * The container image.
   * 
   * @example
   * registry-cn-hangzhou-vpc.ack.aliyuncs.com/acs/arms-prometheus-agent:v4.0.0
   */
  image?: string;
  /**
   * @remarks
   * The container name.
   * 
   * @example
   * arms-prometheus-operator
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      args: 'Args',
      image: 'Image',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      args: { 'type': 'array', 'itemType': 'string' },
      image: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEnvironmentFeatureResponseBodyDataFeatureStatus extends $tea.Model {
  /**
   * @remarks
   * The ID of the resource.
   * 
   * @example
   * c013823b55e4b4d6bb6b6f28682bd38a7
   */
  bindResourceId?: string;
  /**
   * @remarks
   * The containers of the feature.
   */
  featureContainers?: DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers[];
  /**
   * @remarks
   * The IP address of the pod.
   */
  ips?: string[];
  /**
   * @remarks
   * The Kubernetes resource name of the feature.
   * 
   * @example
   * arms-prometheus-ack-arms-prometheus
   */
  name?: string;
  /**
   * @remarks
   * The namespace.
   * 
   * @example
   * arms-prom
   */
  namespace?: string;
  /**
   * @remarks
   * The ID of the security group.
   * 
   * @example
   * sg-bp1c9fcexoalq9po6cp8
   */
  securityGroupId?: string;
  /**
   * @remarks
   * The status of the agent. Valid values:
   * 
   * *   Success: The agent is running.
   * *   Failed: The agent failed to run.
   * *   Not Found: The agent is not installed.
   * 
   * @example
   * Success
   */
  status?: string;
  /**
   * @remarks
   * The ID of the vSwitch.
   * 
   * @example
   * vsw-bp1qt6ict0dbxgv4wer8l
   */
  vSwitchId?: string;
  static names(): { [key: string]: string } {
    return {
      bindResourceId: 'BindResourceId',
      featureContainers: 'FeatureContainers',
      ips: 'Ips',
      name: 'Name',
      namespace: 'Namespace',
      securityGroupId: 'SecurityGroupId',
      status: 'Status',
      vSwitchId: 'VSwitchId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindResourceId: 'string',
      featureContainers: { 'type': 'array', 'itemType': DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers },
      ips: { 'type': 'array', 'itemType': 'string' },
      name: 'string',
      namespace: 'string',
      securityGroupId: 'string',
      status: 'string',
      vSwitchId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEnvironmentFeatureResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The installation information about the feature.
   */
  feature?: DescribeEnvironmentFeatureResponseBodyDataFeature;
  /**
   * @remarks
   * The status of the feature.
   */
  featureStatus?: DescribeEnvironmentFeatureResponseBodyDataFeatureStatus;
  static names(): { [key: string]: string } {
    return {
      feature: 'Feature',
      featureStatus: 'FeatureStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      feature: DescribeEnvironmentFeatureResponseBodyDataFeature,
      featureStatus: DescribeEnvironmentFeatureResponseBodyDataFeatureStatus,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules extends $tea.Model {
  /**
   * @remarks
   * The ID of the notification policy.
   * 
   * @example
   * 12345
   */
  id?: number;
  /**
   * @remarks
   * The name of the notification policy.
   * 
   * @example
   * Notification policy test
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'id',
      name: 'name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIMRobotsResponseBodyPageBeanAlertIMRobots extends $tea.Model {
  /**
   * @remarks
   * The time when the IM chatbot was created.
   * 
   * @example
   * 2023-01-16 17:21:48
   */
  createTime?: string;
  /**
   * @remarks
   * Indicates whether daily statistics are sent. Valid values:
   * 
   * *   `false` (default): Daily statistics are not sent.
   * *   `true`: Daily statistics are sent.
   * 
   * @example
   * true
   */
  dailyNoc?: boolean;
  /**
   * @remarks
   * The point in time at which the daily statistics are sent. The information that ARMS sends at the specified points in time includes the total number of alerts generated on the current day, the number of cleared alerts, and the number of alerts to be cleared.
   * 
   * @example
   * 09:30,17:30
   */
  dailyNocTime?: string;
  /**
   * @remarks
   * The signature key of DingTalk. If you specify a signature key, DingTalk authentication is performed by using the signature key. If you do not specify a signature key, a whitelist is used for authentication by default. The keyword of the whitelist is **Alert**.
   * 
   * @example
   * ******
   */
  dingSignKey?: string;
  /**
   * @remarks
   * The notification policies.
   */
  dispatchRules?: DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules[];
  /**
   * @remarks
   * The webhook URL of the IM chatbot.
   * 
   * @example
   * https://oapi.dingtalk.com/robot/send?access_token=e1a049121******
   */
  robotAddr?: string;
  /**
   * @remarks
   * The ID of the IM chatbot.
   * 
   * @example
   * 123
   */
  robotId?: number;
  /**
   * @remarks
   * The name of the IM chatbot.
   * 
   * @example
   * Chatbot name
   */
  robotName?: string;
  /**
   * @remarks
   * The type of the IM chatbot. Valid values:
   * 
   * *   `dingding`: DingTalk chatbot
   * *   `wechat`: WeCom chatbot
   * 
   * @example
   * dingding
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      dailyNoc: 'DailyNoc',
      dailyNocTime: 'DailyNocTime',
      dingSignKey: 'DingSignKey',
      dispatchRules: 'DispatchRules',
      robotAddr: 'RobotAddr',
      robotId: 'RobotId',
      robotName: 'RobotName',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      dailyNoc: 'boolean',
      dailyNocTime: 'string',
      dingSignKey: 'string',
      dispatchRules: { 'type': 'array', 'itemType': DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules },
      robotAddr: 'string',
      robotId: 'number',
      robotName: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIMRobotsResponseBodyPageBean extends $tea.Model {
  /**
   * @remarks
   * The queried IM chatbots.
   */
  alertIMRobots?: DescribeIMRobotsResponseBodyPageBeanAlertIMRobots[];
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of IM chatbots returned per page.
   * 
   * @example
   * 20
   */
  size?: number;
  /**
   * @remarks
   * The total number of queried IM chatbots.
   * 
   * @example
   * 1
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      alertIMRobots: 'AlertIMRobots',
      page: 'Page',
      size: 'Size',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertIMRobots: { 'type': 'array', 'itemType': DescribeIMRobotsResponseBodyPageBeanAlertIMRobots },
      page: 'number',
      size: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations extends $tea.Model {
  /**
   * @remarks
   * The name of the annotation.
   * 
   * @example
   * message
   */
  name?: string;
  /**
   * @remarks
   * The value of the annotation.
   * 
   * @example
   * The CPU utilization of ${{$labels.pod_name}} has exceeded 80%. Current value: {{$value}}%
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels extends $tea.Model {
  /**
   * @remarks
   * The name of the tag.
   * 
   * @example
   * severity
   */
  name?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * critical
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * @example
   * 3888704
   */
  alertId?: number;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * @example
   * Prometheus_Alert
   */
  alertName?: string;
  /**
   * @remarks
   * The annotations of the alert rule.
   */
  annotations?: DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations[];
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * @example
   * c0bad479465464e1d8c1e641b0afb****
   */
  clusterId?: string;
  /**
   * @remarks
   * The ID of the notification policy. This parameter is returned if the **NotifyType** parameter is set to `DISPATCH_RULE`.
   * 
   * @example
   * 10282
   */
  dispatchRuleId?: number;
  /**
   * @remarks
   * The duration of the alert. Valid values: 1 to 1440. Unit: minutes.
   * 
   * @example
   * 1m
   */
  duration?: string;
  /**
   * @remarks
   * The expression of the alert rule.
   * 
   * @example
   * 100 * (sum(rate(container_cpu_usage_seconds_total[1m])) by (pod_name) / sum(label_replace(kube_pod_container_resource_limits_cpu_cores, \\"pod_name\\", \\"$1\\", \\"pod\\", \\"(.*)\\")) by (pod_name))>75
   */
  expression?: string;
  /**
   * @remarks
   * The tags of the alert rule.
   */
  labels?: DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels[];
  /**
   * @remarks
   * The alert message. Tags can be referenced in the {{$labels.xxx}} format.
   * 
   * @example
   * The CPU utilization of ${{$labels.pod_name}} has exceeded 80%. Current value: {{$value}}%
   */
  message?: string;
  /**
   * @remarks
   * The method of that is used to send alert notifications. Valid values:
   * 
   * *   `ALERT_MANAGER`: Alert notifications are sent by Operation Center.
   * *   `DISPATCH_RULE`: Alert notifications are sent based on the specified notification policy.
   * 
   * @example
   * ALERT_MANAGER
   */
  notifyType?: string;
  /**
   * @remarks
   * Indicates whether the alert rule is enabled. Valid values:
   * 
   * *   `1`: The alert rule is enabled.
   * *   `0`: The alert rule is disabled.
   * 
   * @example
   * 1
   */
  status?: number;
  /**
   * @remarks
   * The type of the alert rule.
   * 
   * @example
   * Kubernetes component alert
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      alertId: 'AlertId',
      alertName: 'AlertName',
      annotations: 'Annotations',
      clusterId: 'ClusterId',
      dispatchRuleId: 'DispatchRuleId',
      duration: 'Duration',
      expression: 'Expression',
      labels: 'Labels',
      message: 'Message',
      notifyType: 'NotifyType',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertId: 'number',
      alertName: 'string',
      annotations: { 'type': 'array', 'itemType': DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations },
      clusterId: 'string',
      dispatchRuleId: 'number',
      duration: 'string',
      expression: 'string',
      labels: { 'type': 'array', 'itemType': DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels },
      message: 'string',
      notifyType: 'string',
      status: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook extends $tea.Model {
  /**
   * @remarks
   * The header of the HTTP request.
   * 
   * @example
   * [{"Content-Type":"application/json"}]
   */
  bizHeaders?: { [key: string]: any };
  /**
   * @remarks
   * The parameters in the HTTP request.
   * 
   * @example
   * [{"content:"mike"}]
   */
  bizParams?: { [key: string]: any };
  /**
   * @remarks
   * The alert notification template.
   * 
   * @example
   * { "Alert name":"{{ .commonLabels.alertname }}{{if .commonLabels.clustername }}", "Cluster name":"{{ .commonLabels.clustername }} {{ end }}{{if eq "app" .commonLabels._aliyun_arms_involvedObject_kind }}", "Application name":"{{ .commonLabels._aliyun_arms_involvedObject_name }} {{ end }}", "Notification policy":"{{ .dispatchRuleName }}", "Alert time":"{{ .startTime }}", "Alert content":"{{ for .alerts }} {{ .annotations.message }} {{ end }}" }
   */
  body?: string;
  /**
   * @remarks
   * The HTTP request method.
   * 
   * *   Get
   * *   Post
   * 
   * @example
   * Post
   */
  method?: string;
  /**
   * @remarks
   * The notification template for clearing alerts.
   * 
   * @example
   * { "Alert name":"{{ .commonLabels.alertname }}{{if .commonLabels.clustername }}", "Cluster name":"{{ .commonLabels.clustername }} {{ end }}{{if eq "app" .commonLabels._aliyun_arms_involvedObject_kind }}", "Application name":"{{ .commonLabels._aliyun_arms_involvedObject_name }} {{ end }}", "Notification policy":"{{ .dispatchRuleName }}", "Recovery time":"{{ .endTime }}", "Alert content":"{{ for .alerts }} {{ .annotations.message }} {{ end }}" }
   */
  recoverBody?: string;
  /**
   * @remarks
   * The URL of the request method.
   * 
   * @example
   * https://oapi.dingtalk.com/robot/send?access_token=91f2f6****
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      bizHeaders: 'BizHeaders',
      bizParams: 'BizParams',
      body: 'Body',
      method: 'Method',
      recoverBody: 'RecoverBody',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      bizParams: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      body: 'string',
      method: 'string',
      recoverBody: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebhookContactsResponseBodyPageBeanWebhookContacts extends $tea.Model {
  /**
   * @remarks
   * The details of the webhook alert contact.
   */
  webhook?: DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook;
  /**
   * @remarks
   * The ID of the webhook alert contact.
   * 
   * @example
   * 123
   */
  webhookId?: number;
  /**
   * @remarks
   * The name of the webhook alert contact.
   * 
   * @example
   * Webhook name
   */
  webhookName?: string;
  static names(): { [key: string]: string } {
    return {
      webhook: 'Webhook',
      webhookId: 'WebhookId',
      webhookName: 'WebhookName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      webhook: DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook,
      webhookId: 'number',
      webhookName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebhookContactsResponseBodyPageBean extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of alert contacts displayed on each page.
   * 
   * @example
   * 20
   */
  size?: number;
  /**
   * @remarks
   * The total number of alert contacts.
   * 
   * @example
   * 1
   */
  total?: number;
  /**
   * @remarks
   * The list of webhook alert contacts.
   */
  webhookContacts?: DescribeWebhookContactsResponseBodyPageBeanWebhookContacts[];
  static names(): { [key: string]: string } {
    return {
      page: 'Page',
      size: 'Size',
      total: 'Total',
      webhookContacts: 'WebhookContacts',
    };
  }

  static types(): { [key: string]: any } {
    return {
      page: 'number',
      size: 'number',
      total: 'number',
      webhookContacts: { 'type': 'array', 'itemType': DescribeWebhookContactsResponseBodyPageBeanWebhookContacts },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAgentDownloadUrlV2ResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The download URL of the agent.
   * 
   * @example
   * http://arms-apm-cn-hangzhou.oss-cn-hangzhou-internal.aliyuncs.com/3.2.9/ArmsAgent.zip
   */
  url?: string;
  /**
   * @remarks
   * The version number of the agent.
   * 
   * @example
   * 3.2.9
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      url: 'Url',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      url: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAlertRulesRequestTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * type
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * prod
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems extends $tea.Model {
  /**
   * @remarks
   * The aggregation method of the alert condition. Valid values:
   * 
   * *   AVG: calculates the average value
   * *   SUM: calculates the total value
   * *   MAX: selects the maximum value
   * *   MIN: selects the minimum value
   * 
   * @example
   * AVG
   */
  aggregate?: string;
  /**
   * @remarks
   * The metric of the alert condition.
   * 
   * @example
   * appstat.jvm.non_heap_used
   */
  metricKey?: string;
  /**
   * @remarks
   * The last N minutes.
   * 
   * @example
   * 1
   */
  n?: number;
  /**
   * @remarks
   * The operator that is used to compare the metric value with the threshold. Valid values:
   * 
   * *   CURRENT_GTE: greater than or equal to
   * *   CURRENT_LTE: less than or equal to
   * *   PREVIOUS_UP: increase in percentage compared with the previous period
   * *   PREVIOUS_DOWN: decrease in percentage compared with the previous period
   * *   HOH_UP: increase in percentage compared with the same period in the previous hour
   * *   HOH_DOWN: decrease in percentage compared with the same period in the previous hour
   * *   DOD_UP: increase in percentage compared with the same period in the previous day
   * *   DOD_DOWN: decrease in percentage compared with the same period in the previous day
   * 
   * @example
   * CURRENT_GTE
   */
  operator?: string;
  /**
   * @remarks
   * The threshold of the alert condition.
   * 
   * @example
   * 1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      aggregate: 'Aggregate',
      metricKey: 'MetricKey',
      n: 'N',
      operator: 'Operator',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aggregate: 'string',
      metricKey: 'string',
      n: 'number',
      operator: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent extends $tea.Model {
  /**
   * @remarks
   * The trigger conditions of the Application Monitoring or Browser Monitoring alert rule.
   */
  alertRuleItems?: GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems[];
  /**
   * @remarks
   * The relationship between multiple alert conditions specified for the Application Monitoring or Browser Monitoring alert rule. Valid values:
   * 
   * *   OR: The alert rule is triggered if one of the conditions is met.
   * *   AND: The alert rule is triggered if all the conditions are met.
   * 
   * @example
   * OR
   */
  condition?: string;
  static names(): { [key: string]: string } {
    return {
      alertRuleItems: 'AlertRuleItems',
      condition: 'Condition',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertRuleItems: { 'type': 'array', 'itemType': GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems },
      condition: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations extends $tea.Model {
  /**
   * @remarks
   * The key of the annotation.
   * 
   * @example
   * 123
   */
  name?: string;
  /**
   * @remarks
   * The value of the annotation.
   * 
   * @example
   * abc
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters extends $tea.Model {
  /**
   * @remarks
   * The key of the filter condition.
   * 
   * @example
   * username
   */
  key?: string;
  /**
   * @remarks
   * The logical operator of the filter condition. Valid values:
   * 
   * *   \\=: equal to
   * *   not: not equal to
   * 
   * @example
   * =
   */
  opt?: string;
  /**
   * @remarks
   * Indicates whether this filter condition is displayed on the frontend.
   * 
   * @example
   * false
   */
  show?: boolean;
  /**
   * @remarks
   * The log type of Browser Monitoring. This field is not included in other filter conditions.
   * 
   * @example
   * null
   */
  t?: string;
  /**
   * @remarks
   * The value of the filter condition.
   * 
   * @example
   * test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      opt: 'Opt',
      show: 'Show',
      t: 'T',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      opt: 'string',
      show: 'boolean',
      t: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters extends $tea.Model {
  /**
   * @remarks
   * The key of the filter condition.
   * 
   * @example
   * rootIp
   */
  filterKey?: string;
  /**
   * @remarks
   * The logical operator of the filter condition.
   * 
   * @example
   * ALL
   */
  filterOpt?: string;
  /**
   * @remarks
   * The details of the filter condition.
   */
  filterValues?: string[];
  static names(): { [key: string]: string } {
    return {
      filterKey: 'FilterKey',
      filterOpt: 'FilterOpt',
      filterValues: 'FilterValues',
    };
  }

  static types(): { [key: string]: any } {
    return {
      filterKey: 'string',
      filterOpt: 'string',
      filterValues: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAlertRulesResponseBodyPageBeanAlertRulesFilters extends $tea.Model {
  /**
   * @remarks
   * The custom filter condition of the Browser Monitoring alert rule.
   */
  customSLSFilters?: GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters[];
  /**
   * @remarks
   * The information about the aggregation dimension.
   */
  customSLSGroupByDimensions?: string[];
  /**
   * @remarks
   * The details of the custom filter condition.
   */
  customSLSWheres?: string[];
  /**
   * @remarks
   * The information about each filter condition of the Application Monitoring or Browser Monitoring alert rule.
   */
  dimFilters?: GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters[];
  static names(): { [key: string]: string } {
    return {
      customSLSFilters: 'CustomSLSFilters',
      customSLSGroupByDimensions: 'CustomSLSGroupByDimensions',
      customSLSWheres: 'CustomSLSWheres',
      dimFilters: 'DimFilters',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customSLSFilters: { 'type': 'array', 'itemType': GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters },
      customSLSGroupByDimensions: { 'type': 'array', 'itemType': 'string' },
      customSLSWheres: { 'type': 'array', 'itemType': 'string' },
      dimFilters: { 'type': 'array', 'itemType': GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAlertRulesResponseBodyPageBeanAlertRulesLabels extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * 123
   */
  name?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * abc
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAlertRulesResponseBodyPageBeanAlertRulesTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * type
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * prod
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAlertRulesResponseBodyPageBeanAlertRules extends $tea.Model {
  /**
   * @remarks
   * The alert check type of the Prometheus alert rule.
   * 
   * *   STATIC: static threshold
   * *   CUSTOM: custom PromQL
   * 
   * @example
   * STATIC
   */
  alertCheckType?: string;
  /**
   * @remarks
   * The alert contact group ID of the Prometheus alert rule.
   * 
   * *   \\-1: custom PromQL
   * *   1: Kubernetes load
   * *   15: Kubernetes node
   * 
   * @example
   * 1
   */
  alertGroup?: number;
  /**
   * @remarks
   * The alert rule ID.
   * 
   * @example
   * 5730***
   */
  alertId?: number;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * @example
   * arms-test
   */
  alertName?: string;
  /**
   * @remarks
   * The content of the Application Monitoring or Browser Monitoring alert rule.
   */
  alertRuleContent?: GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent;
  /**
   * @remarks
   * The status of the alert rule. Valid values:
   * 
   * *   RUNNING
   * *   STOPPED
   * *   PAUSED
   * 
   * >  The PAUSED state indicates that the alert rule is abnormal and has been suspended. This may be because the specified threshold value is excessively large, or the associated cluster has been deleted.
   * 
   * @example
   * RUNNING
   */
  alertStatus?: string;
  /**
   * @remarks
   * The type of the alert rule. Valid values:
   * 
   * *   APPLICATION_MONITORING_ALERT_RULE: alert rule for Application Monitoring
   * *   BROWSER_MONITORING_ALERT_RULE: alert rule for Browser Monitoring
   * *   PROMETHEUS_MONITORING_ALERT_RULE: Prometheus alert rule
   * 
   * @example
   * APPLICATION_MONITORING_ALERT_RULE
   */
  alertType?: string;
  /**
   * @remarks
   * The annotations of the Prometheus alert rule.
   */
  annotations?: GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations[];
  /**
   * @remarks
   * Indicates whether the alert rule is applied to new applications that are created in Application Monitoring or Browser Monitoring. Valid values:
   * 
   * *   `true`: yes
   * *   `false`: no
   * 
   * @example
   * false
   */
  autoAddNewApplication?: boolean;
  /**
   * @remarks
   * The cluster ID of the Prometheus alert rule.
   * 
   * @example
   * ceba9b9ea5b924dd0b6726d2de6******
   */
  clusterId?: string;
  /**
   * @remarks
   * The time when the alert rule was created. The value is a timestamp. Unit: milliseconds.
   * 
   * @example
   * 1640333981000
   */
  createdTime?: number;
  /**
   * @remarks
   * The duration of the Prometheus alert rule.
   * 
   * @example
   * 1
   */
  duration?: string;
  /**
   * @remarks
   * The extended fields.
   * 
   * >  For existing Application Monitoring alert rules, the fields contain information such as contacts, alert template, and notification content.
   * 
   * @example
   * {\\\\"alarmContext\\\\":\\\\"{\\\\\\\\\\"content\\\\\\\\\\":\\\\\\\\Alert name: $Alert name\\\\\\\\\\\\nFilter condition: $Filter condition\\\\\\\\\\\\nAlert time: $Alert time\\\\\\\\\\\\nAlert content: $Alert content\\\\\\\\\\\\nNote: The alert persists before you receive an email that reminds you to clear the alert. You will be reminded of the alert again 24 hours later. \\\\\\\\\\",\\\\\\\\\\"subTitle\\\\\\\\\\":\\\\\\\\\\"\\\\\\\\\\"}\\\\",\\\\"alertWays\\\\":\\\\"[0,1]\\\\",\\\\"contactGroupIds\\\\":\\\\"381,5075\\\\",\\\\"notice\\\\":\\\\"{\\\\\\\\\\"endTime\\\\\\\\\\":1480607940000,\\\\\\\\\\"noticeEndTime\\\\\\\\\\":1480607940000,\\\\\\\\\\"noticeStartTime\\\\\\\\\\":1480521600000,\\\\\\\\\\"startTime\\\\\\\\\\":1480521600000}\\\\"}
   */
  extend?: string;
  /**
   * @remarks
   * The filter conditions of the Application Monitoring or Browser Monitoring alert rule.
   */
  filters?: GetAlertRulesResponseBodyPageBeanAlertRulesFilters;
  /**
   * @remarks
   * The tags of the Prometheus alert rule.
   */
  labels?: GetAlertRulesResponseBodyPageBeanAlertRulesLabels[];
  /**
   * @remarks
   * The severity level of the Prometheus alert rule.
   * 
   * *   P1: Alert notifications are sent for major issues that affect the availability of core business, have a huge impact, and may lead to serious consequences.
   * *   P2: Alert notifications are sent for service errors that affect the system availability with relatively limited impact.
   * *   P3: Alert notifications are sent for issues that may cause service errors or negative effects, or alert notifications for services that are relatively less important.
   * *   P4: Alert notifications are sent for low-priority issues that do not affect your business.
   * *   Default: Alert notifications are sent regardless of alert levels.
   * 
   * @example
   * P2
   */
  level?: string;
  /**
   * @remarks
   * The alert message of the Prometheus alert rule.
   * 
   * @example
   * Namespace: {{$labels.namespace}} / Pod: {{$labels.pod_name}} / Container: {{$labels.container}} CPU usage: {{$labels.metrics_params_opt_label_value}} {{$labels.metrics_params_value}}%. Current value: {{ printf "%.2f" $value }}%
   */
  message?: string;
  /**
   * @remarks
   * The metric type of the Application Monitoring or Browser Monitoring alert rule.
   * 
   * @example
   * JVM
   */
  metricsType?: string;
  /**
   * @remarks
   * The name of the notification policy.
   * 
   * @example
   * ALERT_MANAGER
   */
  notifyStrategy?: string;
  /**
   * @remarks
   * The process ID (PID) of the application to which the Application Monitoring or Browser Monitoring alert rule is applied.
   */
  pids?: string[];
  /**
   * @remarks
   * The PromQL statement of the Prometheus alert rule.
   * 
   * @example
   * node_memory_MemAvailable_bytes{} / node_memory_MemTotal_bytes{} * 100
   */
  promQL?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The tags of the alert rule.
   */
  tags?: GetAlertRulesResponseBodyPageBeanAlertRulesTags[];
  /**
   * @remarks
   * The time when the alert rule was updated. The value is a timestamp. Unit: milliseconds.
   * 
   * @example
   * 1640333981000
   */
  updatedTime?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 1131971649******
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      alertCheckType: 'AlertCheckType',
      alertGroup: 'AlertGroup',
      alertId: 'AlertId',
      alertName: 'AlertName',
      alertRuleContent: 'AlertRuleContent',
      alertStatus: 'AlertStatus',
      alertType: 'AlertType',
      annotations: 'Annotations',
      autoAddNewApplication: 'AutoAddNewApplication',
      clusterId: 'ClusterId',
      createdTime: 'CreatedTime',
      duration: 'Duration',
      extend: 'Extend',
      filters: 'Filters',
      labels: 'Labels',
      level: 'Level',
      message: 'Message',
      metricsType: 'MetricsType',
      notifyStrategy: 'NotifyStrategy',
      pids: 'Pids',
      promQL: 'PromQL',
      regionId: 'RegionId',
      tags: 'Tags',
      updatedTime: 'UpdatedTime',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertCheckType: 'string',
      alertGroup: 'number',
      alertId: 'number',
      alertName: 'string',
      alertRuleContent: GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent,
      alertStatus: 'string',
      alertType: 'string',
      annotations: { 'type': 'array', 'itemType': GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations },
      autoAddNewApplication: 'boolean',
      clusterId: 'string',
      createdTime: 'number',
      duration: 'string',
      extend: 'string',
      filters: GetAlertRulesResponseBodyPageBeanAlertRulesFilters,
      labels: { 'type': 'array', 'itemType': GetAlertRulesResponseBodyPageBeanAlertRulesLabels },
      level: 'string',
      message: 'string',
      metricsType: 'string',
      notifyStrategy: 'string',
      pids: { 'type': 'array', 'itemType': 'string' },
      promQL: 'string',
      regionId: 'string',
      tags: { 'type': 'array', 'itemType': GetAlertRulesResponseBodyPageBeanAlertRulesTags },
      updatedTime: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAlertRulesResponseBodyPageBean extends $tea.Model {
  /**
   * @remarks
   * The alert rules.
   */
  alertRules?: GetAlertRulesResponseBodyPageBeanAlertRules[];
  /**
   * @remarks
   * The number of pages returned.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of alert rules returned per page.
   * 
   * @example
   * 20
   */
  size?: number;
  /**
   * @remarks
   * The total number of queried alert rules.
   * 
   * @example
   * 1
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      alertRules: 'AlertRules',
      page: 'Page',
      size: 'Size',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertRules: { 'type': 'array', 'itemType': GetAlertRulesResponseBodyPageBeanAlertRules },
      page: 'number',
      size: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAppApiByPageResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * Is completed.
   * 
   * @example
   * false
   */
  completed?: boolean;
  /**
   * @remarks
   * The data entries.
   */
  items?: { [key: string]: any }[];
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 0
   */
  total?: string;
  static names(): { [key: string]: string } {
    return {
      completed: 'Completed',
      items: 'Items',
      page: 'Page',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      completed: 'boolean',
      items: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
      page: 'number',
      pageSize: 'number',
      total: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAppJVMConfigResponseBodyJvmInfoList extends $tea.Model {
  /**
   * @remarks
   * The version of the agent.
   * 
   * @example
   * 1.7.0-SNAPSHOT_3.0.3_3756244
   */
  agentVersion?: string;
  /**
   * @remarks
   * The hostname.
   * 
   * @example
   * host_name
   */
  hostName?: string;
  /**
   * @remarks
   * The IP address.
   * 
   * @example
   * 47.91.59.244
   */
  ip?: string;
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * dsv9zcel92@1455182510c5369
   */
  pid?: string;
  /**
   * @remarks
   * The process ID.
   * 
   * @example
   * 1
   */
  procId?: string;
  /**
   * @remarks
   * The VM parameters.
   * 
   * @example
   * [-javaagent:/home/admin/.opt/ArmsAgent/arms-bootstrap-1.7.0-SNAPSHOT.jar, -Doneagent.plugin.arms-agent.enabled=true, -Darms.licenseKey=[******], -Darms.agent.env=K8s, -Darms.agent.podinfo.path=/etc/podinfo, -Darms.appName=productservice, -Doneagent.region=cn-hangzhou, -Dproject.name=Product]
   */
  vmArgs?: string;
  static names(): { [key: string]: string } {
    return {
      agentVersion: 'AgentVersion',
      hostName: 'HostName',
      ip: 'Ip',
      pid: 'Pid',
      procId: 'ProcId',
      vmArgs: 'VmArgs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      agentVersion: 'string',
      hostName: 'string',
      ip: 'string',
      pid: 'string',
      procId: 'string',
      vmArgs: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCloudClusterAllUrlResponseBodyDataRemoteUrl extends $tea.Model {
  /**
   * @remarks
   * Indicates whether authentication is enabled.
   * 
   * @example
   * true
   */
  authToken?: boolean;
  /**
   * @remarks
   * The internal URL for Grafana.
   * 
   * @example
   * "http://cn-hangzhou-intranet.arms.aliyuncs.com:9090/api/v1/prometheus/XXXXXXXXXXXXXXXXX"
   */
  grafanaUrl?: string;
  /**
   * @remarks
   * The public URL for Grafana.
   * 
   * @example
   * "http://cn-hangzhou.arms.aliyuncs.com:9090/api/v1/prometheus/XXXXXXXXXXXXXXXXX"
   */
  internetGrafanaUrl?: string;
  /**
   * @remarks
   * The public URL for Pushgateway.
   * 
   * @example
   * "http://cn-hangzhou.arms.aliyuncs.com:9090/api/v1/prometheus/XXXXXXXXXXXXXXXXX"
   */
  internetPushGatewayUrl?: string;
  /**
   * @remarks
   * The public URL for remote read.
   * 
   * @example
   * "http://cn-hangzhou.arms.aliyuncs.com:9090/api/v1/prometheus/XXXXXXXXXXXXXXXXX"
   */
  internetRemoteReadUrl?: string;
  /**
   * @remarks
   * The public URL for remote write.
   * 
   * @example
   * "http://cn-hangzhou.arms.aliyuncs.com:9090/api/v1/prometheus/XXXXXXXXXXXXXXXXX"
   */
  internetRemoteWriteUrl?: string;
  /**
   * @remarks
   * The internal URL for Pushgateway.
   * 
   * @example
   * "http://cn-hangzhou-intranet.arms.aliyuncs.com:9090/api/v1/prometheus/XXXXXXXXXXXXXXXXX"
   */
  pushGatewayUrl?: string;
  /**
   * @remarks
   * The internal URL for remote read.
   * 
   * @example
   * "http://cn-hangzhou-intranet.arms.aliyuncs.com:9090/api/v1/prometheus/XXXXXXXXXXXXXXXXX"
   */
  remoteReadUrl?: string;
  /**
   * @remarks
   * The internal URL for remote write.
   * 
   * @example
   * "http://cn-hangzhou-intranet.arms.aliyuncs.com:9090/api/v1/prometheus/XXXXXXXXXXXXXXXXX"
   */
  remoteWriteUrl?: string;
  /**
   * @remarks
   * The token value used for authentication.
   * 
   * @example
   * "eyJhbGciOiJIUzI1NiJ9.DKEIFJSL.KYK6uOtNVxTVHXJbH5MNqlsAuUtKzNlUvmAIiKc-QXw"
   */
  token?: string;
  static names(): { [key: string]: string } {
    return {
      authToken: 'AuthToken',
      grafanaUrl: 'GrafanaUrl',
      internetGrafanaUrl: 'InternetGrafanaUrl',
      internetPushGatewayUrl: 'InternetPushGatewayUrl',
      internetRemoteReadUrl: 'InternetRemoteReadUrl',
      internetRemoteWriteUrl: 'InternetRemoteWriteUrl',
      pushGatewayUrl: 'PushGatewayUrl',
      remoteReadUrl: 'RemoteReadUrl',
      remoteWriteUrl: 'RemoteWriteUrl',
      token: 'Token',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authToken: 'boolean',
      grafanaUrl: 'string',
      internetGrafanaUrl: 'string',
      internetPushGatewayUrl: 'string',
      internetRemoteReadUrl: 'string',
      internetRemoteWriteUrl: 'string',
      pushGatewayUrl: 'string',
      remoteReadUrl: 'string',
      remoteWriteUrl: 'string',
      token: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCloudClusterAllUrlResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The identifier of the cloud service.
   * 
   * @example
   * amp
   */
  productCode?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The URLs for remote read and write. The value is a JSON string.
   */
  remoteUrl?: GetCloudClusterAllUrlResponseBodyDataRemoteUrl;
  static names(): { [key: string]: string } {
    return {
      productCode: 'ProductCode',
      region: 'Region',
      remoteUrl: 'RemoteUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productCode: 'string',
      region: 'string',
      remoteUrl: GetCloudClusterAllUrlResponseBodyDataRemoteUrl,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCommercialStatusResponseBodyUserAndCommodityStatus extends $tea.Model {
  /**
   * @remarks
   * Indicates whether you are using the Basic Edition.
   * 
   * @example
   * false
   */
  basic?: boolean;
  /**
   * @remarks
   * The billing method.
   * 
   * @example
   * usage
   */
  chargeType?: string;
  /**
   * @remarks
   * Indicates whether the service is activated.
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The additional information.
   * 
   * @example
   * info
   */
  extraInfo?: { [key: string]: any };
  /**
   * @remarks
   * The number of days during which the service is free of charge.
   * 
   * @example
   * 10
   */
  freeDays?: number;
  /**
   * @remarks
   * The tags.
   * 
   * @example
   * NEW
   */
  lable?: string;
  /**
   * @remarks
   * The commercialization status.
   * 
   * Valid values:
   * 
   * *   Normal: The service is activated.
   * *   Abnormal: An exception occurs during activation.
   * *   Free: The service is not activated.
   * 
   * @example
   * Normal
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      basic: 'Basic',
      chargeType: 'ChargeType',
      enable: 'Enable',
      extraInfo: 'ExtraInfo',
      freeDays: 'FreeDays',
      lable: 'Lable',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      basic: 'boolean',
      chargeType: 'string',
      enable: 'boolean',
      extraInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      freeDays: 'number',
      lable: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * http.status.code
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * 200
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList extends $tea.Model {
  /**
   * @remarks
   * The tags of the trace.
   */
  tagEntryList?: GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList[];
  /**
   * @remarks
   * The time when the log was generated. The value is a timestamp.
   * 
   * @example
   * 1595174501747
   */
  timestamp?: number;
  static names(): { [key: string]: string } {
    return {
      tagEntryList: 'TagEntryList',
      timestamp: 'Timestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagEntryList: { 'type': 'array', 'itemType': GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList },
      timestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * http.status.code
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * 200
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMultipleTraceResponseBodyMultiCallChainInfosSpans extends $tea.Model {
  /**
   * @remarks
   * The amount of time consumed by the trace. Unit: milliseconds.
   * 
   * @example
   * 11
   */
  duration?: number;
  /**
   * @remarks
   * Indicates whether a method stack was provided.
   * 
   * *   `true`: A method stack was provided.
   * *   `false`: No method stack was provided.
   * 
   * @example
   * true
   */
  haveStack?: boolean;
  /**
   * @remarks
   * The log events in the trace.
   */
  logEventList?: GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList[];
  /**
   * @remarks
   * The name of the traced span.
   * 
   * @example
   * /demo/queryNotExistDB/11
   */
  operationName?: string;
  /**
   * @remarks
   * The ID of the parent span.
   * 
   * @example
   * 18
   */
  parentSpanId?: string;
  /**
   * @remarks
   * The status code returned.
   * 
   * @example
   * 1
   */
  resultCode?: string;
  /**
   * @remarks
   * RPC ID
   * 
   * @example
   * 0.1
   */
  rpcId?: string;
  /**
   * @remarks
   * The type of the remote procedure call (RPC) mode.
   * 
   * *   0: HTTP entry
   * *   25: HTTP call
   * *   1: High-speed Service Framework (HSF) call
   * *   2: HSF provision
   * *   40: on-premises API call
   * *   60: MySQL call
   * *   62: Oracle call
   * *   63: PostgreSQL call
   * *   70: Redis call
   * *   4: Taobao Distributed Data Layer (TDDL) call
   * *   5: Tair call
   * *   13: MetaQ message sending
   * *   252: MetaQ message receiving
   * *   3: notification sending
   * *   254: notification receiving
   * *   7: Apache Dubbo call
   * *   8: Apache Dubbo provision
   * *   19: SOFARPC call
   * *   18: SOFARPC provision
   * *   11: Distributed Service Framework (DSF) call
   * *   12: DSF provision
   * *   \\-1: unknown call
   * 
   * @example
   * 0
   */
  rpcType?: number;
  /**
   * @remarks
   * The IP address of the host where the application resides.
   * 
   * @example
   * 172.20.XX.XX
   */
  serviceIp?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * arms-k8s-demo-subcomponent
   */
  serviceName?: string;
  /**
   * @remarks
   * The span ID.
   * 
   * @example
   * 1234
   */
  spanId?: string;
  /**
   * @remarks
   * The tags of the trace.
   */
  tagEntryList?: GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList[];
  /**
   * @remarks
   * The timestamp.
   * 
   * @example
   * 1595174501747
   */
  timestamp?: number;
  /**
   * @remarks
   * The trace ID.
   * 
   * @example
   * ac1400a115951745017447033d****
   */
  traceID?: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
      haveStack: 'HaveStack',
      logEventList: 'LogEventList',
      operationName: 'OperationName',
      parentSpanId: 'ParentSpanId',
      resultCode: 'ResultCode',
      rpcId: 'RpcId',
      rpcType: 'RpcType',
      serviceIp: 'ServiceIp',
      serviceName: 'ServiceName',
      spanId: 'SpanId',
      tagEntryList: 'TagEntryList',
      timestamp: 'Timestamp',
      traceID: 'TraceID',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'number',
      haveStack: 'boolean',
      logEventList: { 'type': 'array', 'itemType': GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList },
      operationName: 'string',
      parentSpanId: 'string',
      resultCode: 'string',
      rpcId: 'string',
      rpcType: 'number',
      serviceIp: 'string',
      serviceName: 'string',
      spanId: 'string',
      tagEntryList: { 'type': 'array', 'itemType': GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList },
      timestamp: 'number',
      traceID: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMultipleTraceResponseBodyMultiCallChainInfos extends $tea.Model {
  /**
   * @remarks
   * The details of the trace.
   */
  spans?: GetMultipleTraceResponseBodyMultiCallChainInfosSpans[];
  /**
   * @remarks
   * The trace ID.
   * 
   * @example
   * ac1400a115951745017447033d****
   */
  traceID?: string;
  static names(): { [key: string]: string } {
    return {
      spans: 'Spans',
      traceID: 'TraceID',
    };
  }

  static types(): { [key: string]: any } {
    return {
      spans: { 'type': 'array', 'itemType': GetMultipleTraceResponseBodyMultiCallChainInfosSpans },
      traceID: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact extends $tea.Model {
  /**
   * @remarks
   * The ID of the user on duty.
   * 
   * @example
   * 123
   */
  id?: number;
  /**
   * @remarks
   * The name of the user on duty.
   * 
   * @example
   * Employee 1
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries extends $tea.Model {
  /**
   * @remarks
   * The date on which the user completed shift work.
   * 
   * @example
   * 2022-10-30
   */
  end?: string;
  /**
   * @remarks
   * The information about the user on duty.
   */
  simpleContact?: GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact;
  /**
   * @remarks
   * The date from which the user started shift work.
   * 
   * @example
   * 2022-10-01
   */
  start?: string;
  static names(): { [key: string]: string } {
    return {
      end: 'End',
      simpleContact: 'SimpleContact',
      start: 'Start',
    };
  }

  static types(): { [key: string]: any } {
    return {
      end: 'string',
      simpleContact: GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact,
      start: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact extends $tea.Model {
  /**
   * @remarks
   * The ID of the scheduled user.
   * 
   * @example
   * 123
   */
  id?: number;
  /**
   * @remarks
   * The name of the scheduled user.
   * 
   * @example
   * Employee 1
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntries extends $tea.Model {
  /**
   * @remarks
   * The date from which the scheduled user was supposed to start shift work.
   * 
   * @example
   * 2022-10-01
   */
  start?: string;
  /**
   * @remarks
   * The date on which the scheduled user was supposed to complete shift work.
   * 
   * @example
   * 2022-10-30
   */
  end?: string;
  /**
   * @remarks
   * The information about the scheduled user.
   */
  simpleContact?: GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact;
  static names(): { [key: string]: string } {
    return {
      start: 'Start',
      end: 'End',
      simpleContact: 'SimpleContact',
    };
  }

  static types(): { [key: string]: any } {
    return {
      start: 'string',
      end: 'string',
      simpleContact: GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact extends $tea.Model {
  /**
   * @remarks
   * The ID of the substitute.
   * 
   * @example
   * 234
   */
  id?: number;
  /**
   * @remarks
   * The name of the substitute.
   * 
   * @example
   * Employee 2
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries extends $tea.Model {
  /**
   * @remarks
   * The date on which the substitute was supposed to complete shift work.
   * 
   * @example
   * 2022-10-30
   */
  end?: string;
  /**
   * @remarks
   * The information about the substitute.
   */
  simpleContact?: GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact;
  /**
   * @remarks
   * The date from which the substitute was supposed to start shift work.
   * 
   * @example
   * 2022-10-01
   */
  start?: string;
  static names(): { [key: string]: string } {
    return {
      end: 'End',
      simpleContact: 'SimpleContact',
      start: 'Start',
    };
  }

  static types(): { [key: string]: any } {
    return {
      end: 'string',
      simpleContact: GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact,
      start: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions extends $tea.Model {
  /**
   * @remarks
   * The end time of the shift per day.
   * 
   * @example
   * 18:00
   */
  endTimeOfDay?: string;
  /**
   * @remarks
   * The type of the limit. Valid values:
   * 
   * *   daily_restriction
   * *   weekly_restriction
   * 
   * @example
   * daily_restriction
   */
  restrictionType?: string;
  /**
   * @remarks
   * The start time of the shift per day.
   * 
   * @example
   * 09:00
   */
  startTimeOfDay?: string;
  static names(): { [key: string]: string } {
    return {
      endTimeOfDay: 'EndTimeOfDay',
      restrictionType: 'RestrictionType',
      startTimeOfDay: 'StartTimeOfDay',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTimeOfDay: 'string',
      restrictionType: 'string',
      startTimeOfDay: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOnCallSchedulesDetailResponseBodyDataScheduleLayers extends $tea.Model {
  /**
   * @remarks
   * The ID list of users on duty.
   */
  contactIds?: number[];
  /**
   * @remarks
   * The limit on the time of the shift.
   */
  restrictions?: GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions[];
  /**
   * @remarks
   * The type of the shift. Valid values:
   * 
   * *   DAY
   * *   WEEK
   * *   CUSTOM
   * 
   * @example
   * DAY
   */
  rotationType?: string;
  /**
   * @remarks
   * The shift cycle. Unit: hours.
   * 
   * @example
   * 8
   */
  shiftLength?: number;
  /**
   * @remarks
   * The date on which the shift change took effect.
   * 
   * @example
   * 2022-10-01
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      contactIds: 'ContactIds',
      restrictions: 'Restrictions',
      rotationType: 'RotationType',
      shiftLength: 'ShiftLength',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactIds: { 'type': 'array', 'itemType': 'number' },
      restrictions: { 'type': 'array', 'itemType': GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions },
      rotationType: 'string',
      shiftLength: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOnCallSchedulesDetailResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The URL of the DingTalk chatbot, which is used to receive notifications about shift changes.
   * 
   * @example
   * https://oapi.dingtalk.com/robot/send?access_token=69d4e009547e11069c6513309414937b7bf0482fb9284125b5******
   */
  alertRobotId?: number;
  /**
   * @remarks
   * The description of the scheduling policy.
   * 
   * @example
   * Test
   */
  description?: string;
  /**
   * @remarks
   * The ID of the scheduling policy.
   * 
   * @example
   * 1234
   */
  id?: number;
  /**
   * @remarks
   * The name of the scheduling policy.
   * 
   * @example
   * Scheduling policy test
   */
  name?: string;
  /**
   * @remarks
   * The information about the final user on duty.
   */
  renderedFinnalEntries?: GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries[];
  /**
   * @remarks
   * The scheduled users on duty within a time range.
   */
  renderedLayerEntries?: GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntries[][];
  /**
   * @remarks
   * The information about the substitutes within a time range.
   */
  renderedSubstitudeEntries?: GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries[];
  /**
   * @remarks
   * The information about the shift.
   */
  scheduleLayers?: GetOnCallSchedulesDetailResponseBodyDataScheduleLayers[];
  static names(): { [key: string]: string } {
    return {
      alertRobotId: 'AlertRobotId',
      description: 'Description',
      id: 'Id',
      name: 'Name',
      renderedFinnalEntries: 'RenderedFinnalEntries',
      renderedLayerEntries: 'RenderedLayerEntries',
      renderedSubstitudeEntries: 'RenderedSubstitudeEntries',
      scheduleLayers: 'ScheduleLayers',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertRobotId: 'number',
      description: 'string',
      id: 'number',
      name: 'string',
      renderedFinnalEntries: { 'type': 'array', 'itemType': GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries },
      renderedLayerEntries: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntries } },
      renderedSubstitudeEntries: { 'type': 'array', 'itemType': GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries },
      scheduleLayers: { 'type': 'array', 'itemType': GetOnCallSchedulesDetailResponseBodyDataScheduleLayers },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPrometheusInstanceResponseBodyDataTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * tag1
   */
  tagKey?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * tagValue1
   */
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPrometheusInstanceResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The permission type. Valid values: readWrite, readOnly, and httpReadOnly
   * 
   * @example
   * readWrite
   */
  accessType?: string;
  /**
   * @remarks
   * The number of days for which data is automatically archived after the storage duration expires. Valid values: 60, 90, 180, and 365. 0 indicates that the data is not archived.
   * 
   * @example
   * 60
   */
  archiveDuration?: number;
  /**
   * @remarks
   * The whitelist of IP addresses for which password-free read is enabled.
   * 
   * @example
   * null
   */
  authFreeReadPolicy?: string;
  /**
   * @remarks
   * The whitelist of IP addresses for which password-free write is enabled.
   * 
   * @example
   * null
   */
  authFreeWritePolicy?: string;
  /**
   * @remarks
   * The authorization token.
   * 
   * @example
   * GciOiJIUzI1NiJ9***
   */
  authToken?: string;
  /**
   * @remarks
   * The ID of the Prometheus instance.
   * 
   * @example
   * c589a1b8db05c4561aefbb898ca8fb1cf
   */
  clusterId?: string;
  /**
   * @remarks
   * The name of the monitoring object.
   * 
   * @example
   * prom1
   */
  clusterName?: string;
  /**
   * @remarks
   * *   remote-write: general-purpose Prometheus instance
   * *   ecs: Prometheus instances for ECS
   * *   cloud-monitor: Prometheus instance for Alibaba Cloud services in the Chinese mainland
   * *   cloud-product: Prometheus instance for Alibaba Cloud services outside the Chinese mainland
   * *   global-view: global aggregation instance
   * *   aliyun-cs: Prometheus instance for Container Service
   * 
   * @example
   * remote-write
   */
  clusterType?: string;
  /**
   * @remarks
   * The data storage status at the backend.
   * 
   * @example
   * RUNNING
   */
  dbInstanceStatus?: string;
  /**
   * @remarks
   * Indicates whether password-free read is enabled.
   * 
   * @example
   * false
   */
  enableAuthFreeRead?: boolean;
  /**
   * @remarks
   * Indicates whether password-free write is enabled.
   * 
   * @example
   * false
   */
  enableAuthFreeWrite?: boolean;
  /**
   * @remarks
   * Indicates whether access token authentication is enabled.
   * 
   * @example
   * true
   */
  enableAuthToken?: string;
  /**
   * @remarks
   * 扩展信息（仅控制台请求才返回）
   */
  extraInfo?: { [key: string]: string };
  /**
   * @remarks
   * The ID of the Grafana workspace.
   * 
   * @example
   * grafana-rnggfvhlcdl6m71***
   */
  grafanaInstanceId?: string;
  /**
   * @remarks
   * The public URL for the HTTP API.
   * 
   * @example
   * https://cn-beijing.arms.aliyuncs.com:9443/api/v1/prometheus/xxx
   */
  httpApiInterUrl?: string;
  /**
   * @remarks
   * The internal URL for the HTTP API.
   * 
   * @example
   * http://cn-beijing-intranet.arms.aliyuncs.com:9090/api/v1/prometheus/xxx
   */
  httpApiIntraUrl?: string;
  /**
   * @remarks
   * The billing method. Valid values:
   * 
   * *   PREPAY: subscription
   * *   POSTPAY: pay-as-you-go
   * 
   * @example
   * PREPAY
   */
  paymentType?: string;
  /**
   * @remarks
   * The product to which the Prometheus instance belongs. Valid values: arms and cms.
   * 
   * @example
   * arms
   */
  product?: string;
  /**
   * @remarks
   * The public URL for Pushgateway.
   * 
   * @example
   * https://cn-beijing.arms.aliyuncs.com/prometheus/xxx/api/v2
   */
  pushGatewayInterUrl?: string;
  /**
   * @remarks
   * The internal URL for Pushgateway.
   * 
   * @example
   * http://cn-beijing-intranet.arms.aliyuncs.com/prometheus/xxx/api/v2
   */
  pushGatewayIntraUrl?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-beijing
   */
  regionId?: string;
  /**
   * @remarks
   * The public URL for remote read.
   * 
   * @example
   * http://cn-beijing.arms.aliyuncs.com:9090/api/v1/prometheus/xxx/api/v1/read
   */
  remoteReadInterUrl?: string;
  /**
   * @remarks
   * The internal URL for remote read.
   * 
   * @example
   * http://cn-beijing-intranet.arms.aliyuncs.com:9090/api/v1/prometheus/xxx/api/v1/read
   */
  remoteReadIntraUrl?: string;
  /**
   * @remarks
   * The public URL for remote write.
   * 
   * @example
   * https://cn-beijing.arms.aliyuncs.com/prometheus/xxx/api/v3/write
   */
  remoteWriteInterUrl?: string;
  /**
   * @remarks
   * The internal URL for remote write.
   * 
   * @example
   * http://cn-beijing-intranet.arms.aliyuncs.com/prometheus/xxx/api/v3/write
   */
  remoteWriteIntraUrl?: string;
  /**
   * @remarks
   * The ID of the resource group to which the instance belongs.
   * 
   * @example
   * rg-aek2vezare****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The type of the resource. Set the value to PROMETHEUS.
   * 
   * @example
   * PROMETHEUS
   */
  resourceType?: string;
  /**
   * @remarks
   * The ID of the security group. This parameter is returned only for Prometheus instances for ECS.
   * 
   * @example
   * sg-8vbdgmf4nraiqa9bx0jo
   */
  securityGroupId?: string;
  /**
   * @remarks
   * The data storage duration. Unit: days.
   * 
   * @example
   * 90
   */
  storageDuration?: number;
  /**
   * @remarks
   * The child instances of the Prometheus instance for GlobalView. The value is a JSON string.
   * 
   * @example
   * [{"headers":{},"regionId":"cn-hangzhou","sourceType":"AlibabaPrometheus","extras":{},"clusterId":"c39a1048921e04fceb039db2fbb73\\*\\*\\*","sourceName":"arms-luyao-test","dataSource":"","userId":"167275301789\\*\\*\\*"},{"headers":{},"regionId":"cn-beijing","sourceType":"AlibabaPrometheus","extras":{},"clusterId":"c6b6485496d5b400abde22cb47b5\\*\\*\\*\\*","sourceName":"agent-321-test","dataSource":"","userId":"1672753017899\\*\\*\\*"},{"headers":{},"regionId":"cn-zhangjiakou","sourceType":"AlibabaPrometheus","extras":{},"clusterId":"c261a4f3200c446659133f1ade789b15e","sourceName":"zaifeng-cardinality-01","dataSource":"","userId":"167275301789\\*\\*\\*"}]
   */
  subClustersJson?: string;
  /**
   * @remarks
   * Supported authentication types.
   */
  supportAuthTypes?: string[];
  /**
   * @remarks
   * The tags of the instance.
   */
  tags?: GetPrometheusInstanceResponseBodyDataTags[];
  /**
   * @remarks
   * The user ID.
   * 
   * @example
   * 167275301789****
   */
  userId?: string;
  /**
   * @remarks
   * The vSwitch ID. This parameter is returned only for Prometheus instances for ECS.
   * 
   * @example
   * vsw-f8z73vcja1tqnw90aav5a
   */
  vSwitchId?: string;
  /**
   * @remarks
   * The VPC ID. This parameter is returned only for Prometheus instances for ECS.
   * 
   * @example
   * vpc-8vb02uk57qbcktqcvqqqj
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      accessType: 'AccessType',
      archiveDuration: 'ArchiveDuration',
      authFreeReadPolicy: 'AuthFreeReadPolicy',
      authFreeWritePolicy: 'AuthFreeWritePolicy',
      authToken: 'AuthToken',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      clusterType: 'ClusterType',
      dbInstanceStatus: 'DbInstanceStatus',
      enableAuthFreeRead: 'EnableAuthFreeRead',
      enableAuthFreeWrite: 'EnableAuthFreeWrite',
      enableAuthToken: 'EnableAuthToken',
      extraInfo: 'ExtraInfo',
      grafanaInstanceId: 'GrafanaInstanceId',
      httpApiInterUrl: 'HttpApiInterUrl',
      httpApiIntraUrl: 'HttpApiIntraUrl',
      paymentType: 'PaymentType',
      product: 'Product',
      pushGatewayInterUrl: 'PushGatewayInterUrl',
      pushGatewayIntraUrl: 'PushGatewayIntraUrl',
      regionId: 'RegionId',
      remoteReadInterUrl: 'RemoteReadInterUrl',
      remoteReadIntraUrl: 'RemoteReadIntraUrl',
      remoteWriteInterUrl: 'RemoteWriteInterUrl',
      remoteWriteIntraUrl: 'RemoteWriteIntraUrl',
      resourceGroupId: 'ResourceGroupId',
      resourceType: 'ResourceType',
      securityGroupId: 'SecurityGroupId',
      storageDuration: 'StorageDuration',
      subClustersJson: 'SubClustersJson',
      supportAuthTypes: 'SupportAuthTypes',
      tags: 'Tags',
      userId: 'UserId',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessType: 'string',
      archiveDuration: 'number',
      authFreeReadPolicy: 'string',
      authFreeWritePolicy: 'string',
      authToken: 'string',
      clusterId: 'string',
      clusterName: 'string',
      clusterType: 'string',
      dbInstanceStatus: 'string',
      enableAuthFreeRead: 'boolean',
      enableAuthFreeWrite: 'boolean',
      enableAuthToken: 'string',
      extraInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      grafanaInstanceId: 'string',
      httpApiInterUrl: 'string',
      httpApiIntraUrl: 'string',
      paymentType: 'string',
      product: 'string',
      pushGatewayInterUrl: 'string',
      pushGatewayIntraUrl: 'string',
      regionId: 'string',
      remoteReadInterUrl: 'string',
      remoteReadIntraUrl: 'string',
      remoteWriteInterUrl: 'string',
      remoteWriteIntraUrl: 'string',
      resourceGroupId: 'string',
      resourceType: 'string',
      securityGroupId: 'string',
      storageDuration: 'number',
      subClustersJson: 'string',
      supportAuthTypes: { 'type': 'array', 'itemType': 'string' },
      tags: { 'type': 'array', 'itemType': GetPrometheusInstanceResponseBodyDataTags },
      userId: 'string',
      vSwitchId: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPrometheusIntegrationResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the exporter can be deleted.
   * 
   * @example
   * true
   */
  canDelete?: boolean;
  /**
   * @remarks
   * Indicates whether the exporter can be modified.
   * 
   * @example
   * true
   */
  canEditor?: boolean;
  /**
   * @remarks
   * The ID of the Prometheus instance.
   * 
   * @example
   * c589a1b8db05c4561aefbb898ca8fb1cf
   */
  clusterId?: string;
  /**
   * @remarks
   * The container name.
   * 
   * @example
   * kafka-exporter-1
   */
  containerName?: string;
  /**
   * @remarks
   * The description of the exporter.
   * 
   * @example
   * "{}"
   */
  describe?: string;
  /**
   * @remarks
   * The type of the exporter.
   * 
   * @example
   * tidb-exporter
   */
  exporterType?: string;
  /**
   * @remarks
   * The ID of the exporter.
   * 
   * @example
   * 2893
   */
  instanceId?: number;
  /**
   * @remarks
   * The name of the exporter.
   * 
   * @example
   * lpd-skyeye
   */
  instanceName?: string;
  /**
   * @remarks
   * The integration type. Valid values: kafka, mysql, redis, snmp, emr, nubela, and tidb.
   * 
   * @example
   * tidb
   */
  integrationType?: string;
  /**
   * @remarks
   * The namespace.
   * 
   * @example
   * arms-prom
   */
  namespace?: string;
  /**
   * @remarks
   * Indicates whether an upgrade is required.
   * 
   * @example
   * True
   */
  needUpgrade?: boolean;
  /**
   * @remarks
   * The parameters of the exporter. Format: JSON string.
   * 
   * @example
   * {
   *       "port": "5554",
   *       "name": "kafka-test12",
   *       "kafka_instance": "kafka-test",
   *       "__label_value": "kafka-test",
   *       "scrape_interval": 33,
   *       "metrics_path": "/metrics",
   *       "__label_key": "kafka-test"
   * }
   */
  param?: string;
  /**
   * @remarks
   * Indicates whether the description is displayed.
   * 
   * @example
   * true
   */
  showDescribe?: boolean;
  /**
   * @remarks
   * Indicates whether the exporter logs are displayed.
   * 
   * @example
   * true
   */
  showLog?: string;
  /**
   * @remarks
   * The status of the exporter.
   * 
   * @example
   * installed
   */
  status?: string;
  /**
   * @remarks
   * The monitored IP address.
   * 
   * @example
   * 127.0.0.1:3422
   */
  target?: string;
  /**
   * @remarks
   * The version information.
   * 
   * @example
   * 1.0.0
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      canDelete: 'CanDelete',
      canEditor: 'CanEditor',
      clusterId: 'ClusterId',
      containerName: 'ContainerName',
      describe: 'Describe',
      exporterType: 'ExporterType',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      integrationType: 'IntegrationType',
      namespace: 'Namespace',
      needUpgrade: 'NeedUpgrade',
      param: 'Param',
      showDescribe: 'ShowDescribe',
      showLog: 'ShowLog',
      status: 'Status',
      target: 'Target',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canDelete: 'boolean',
      canEditor: 'boolean',
      clusterId: 'string',
      containerName: 'string',
      describe: 'string',
      exporterType: 'string',
      instanceId: 'number',
      instanceName: 'string',
      integrationType: 'string',
      namespace: 'string',
      needUpgrade: 'boolean',
      param: 'string',
      showDescribe: 'boolean',
      showLog: 'string',
      status: 'string',
      target: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPrometheusMonitoringResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the Prometheus instance.
   * 
   * @example
   * c589a1b8db05c4561aefbb898ca8fb1cf
   */
  clusterId?: string;
  /**
   * @remarks
   * The monitoring configuration. The value is a YAML string.
   * 
   * @example
   * apiVersion: monitoring.coreos.com/v1
   * kind: ServiceMonitor
   * metadata:
   *   name: tomcat-demo
   *   namespace: default
   * spec:
   *   endpoints:
   *     - interval: 30s
   *       path: /metrics
   *       port: tomcat-monitor
   *   namespaceSelector:
   *     any: true
   *   selector:
   *     matchLabels:
   *       app: tomcat
   */
  configYaml?: string;
  /**
   * @remarks
   * The name of the monitoring configuration.
   * 
   * @example
   * customJob1
   */
  monitoringName?: string;
  /**
   * @remarks
   * The status of the monitoring configuration. Valid values: run and stop.
   * 
   * @example
   * run
   */
  status?: string;
  /**
   * @remarks
   * The type of the monitoring configuration. Valid values: serviceMonitor, podMonitor, customJob, and probe.
   * 
   * @example
   * serviceMonitor
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      configYaml: 'ConfigYaml',
      monitoringName: 'MonitoringName',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      configYaml: 'string',
      monitoringName: 'string',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRetcodeAppByPidRequestTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * TestKey
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * TestValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRetcodeAppByPidResponseBodyRetcodeAppTags extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * testKey
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * testValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRetcodeAppByPidResponseBodyRetcodeApp extends $tea.Model {
  /**
   * @remarks
   * The ID of the application. The parameter is an auto-increment parameter.
   * 
   * @example
   * 2787XXXX
   */
  appId?: string;
  /**
   * @remarks
   * The name of the application that is monitored by Browser Monitoring.
   * 
   * @example
   * testRetcodeAppXXXX
   */
  appName?: string;
  /**
   * @remarks
   * The process identifier (PID) of the application.
   * 
   * @example
   * b590lhguqs@9781be0f44dXXXX
   */
  pid?: string;
  /**
   * @remarks
   * The ID of the resource group. You can obtain the resource group ID in the **Resource Management** console.
   * 
   * @example
   * rg-acfmxidtzXXXX
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The type of the application that is monitored by Browser Monitoring. Valid values:
   * 
   * *   `web`: web application
   * *   `weex`: Weex mobile app
   * *   `mini_dd`: DingTalk mini program
   * *   `mini_alipay`: Alipay mini program
   * *   `mini_wx`: WeChat mini program
   * *   `mini_common`: mini program on other platforms
   * 
   * @example
   * web
   */
  retcodeAppType?: string;
  /**
   * @remarks
   * The tags that are attached to the instance.
   */
  tags?: GetRetcodeAppByPidResponseBodyRetcodeAppTags[];
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      pid: 'Pid',
      resourceGroupId: 'ResourceGroupId',
      retcodeAppType: 'RetcodeAppType',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      appName: 'string',
      pid: 'string',
      resourceGroupId: 'string',
      retcodeAppType: 'string',
      tags: { 'type': 'array', 'itemType': GetRetcodeAppByPidResponseBodyRetcodeAppTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig extends $tea.Model {
  /**
   * @remarks
   * The Log Service Logstore.
   * 
   * @example
   * log-test-220431
   */
  logstore?: string;
  /**
   * @remarks
   * The Log Service project.
   * 
   * @example
   * test-project
   */
  project?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      logstore: 'Logstore',
      project: 'Project',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logstore: 'string',
      project: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRetcodeLogstoreResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The content of the log.
   * 
   * @example
   * retcode app or task can not be found!
   */
  message?: string;
  /**
   * @remarks
   * The information about Log Service.
   */
  retcodeSLSConfig?: GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig;
  /**
   * @remarks
   * The status of the request.
   * 
   * @example
   * true
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      retcodeSLSConfig: 'RetcodeSLSConfig',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      retcodeSLSConfig: GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig,
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumAppInfoResponseBodyDataBonreeSDKConfigModuleConfig extends $tea.Model {
  /**
   * @remarks
   * The default configuration of the application.
   */
  defaultConfig?: { [key: string]: DataBonreeSDKConfigModuleConfigDefaultConfigValue };
  /**
   * @remarks
   * Indicates whether the configuration is enabled.
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The version configurations of the application.
   */
  versionConfigs?: { [key: string]: DataBonreeSDKConfigModuleConfigVersionConfigsValue };
  static names(): { [key: string]: string } {
    return {
      defaultConfig: 'defaultConfig',
      enable: 'enable',
      versionConfigs: 'versionConfigs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultConfig: { 'type': 'map', 'keyType': 'string', 'valueType': DataBonreeSDKConfigModuleConfigDefaultConfigValue },
      enable: 'boolean',
      versionConfigs: { 'type': 'map', 'keyType': 'string', 'valueType': DataBonreeSDKConfigModuleConfigVersionConfigsValue },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumAppInfoResponseBodyDataBonreeSDKConfigSamplingConfig extends $tea.Model {
  samplingRate?: number;
  samplingType?: number;
  static names(): { [key: string]: string } {
    return {
      samplingRate: 'samplingRate',
      samplingType: 'samplingType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      samplingRate: 'number',
      samplingType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumAppInfoResponseBodyDataBonreeSDKConfig extends $tea.Model {
  /**
   * @remarks
   * The module configuration.
   */
  moduleConfig?: GetRumAppInfoResponseBodyDataBonreeSDKConfigModuleConfig;
  samplingConfig?: GetRumAppInfoResponseBodyDataBonreeSDKConfigSamplingConfig;
  static names(): { [key: string]: string } {
    return {
      moduleConfig: 'moduleConfig',
      samplingConfig: 'samplingConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      moduleConfig: GetRumAppInfoResponseBodyDataBonreeSDKConfigModuleConfig,
      samplingConfig: GetRumAppInfoResponseBodyDataBonreeSDKConfigSamplingConfig,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumAppInfoResponseBodyDataServiceDomainConfigs extends $tea.Model {
  /**
   * @remarks
   * The description.
   * 
   * @example
   * Test
   */
  description?: string;
  /**
   * @remarks
   * The domain name or IP address.
   * 
   * @example
   * example.com
   */
  domain?: string;
  /**
   * @remarks
   * The trace propagation protocols. This parameter is required if the tracing analysis feature is enabled.
   */
  propagatorTypes?: string[];
  samplingRate?: number;
  /**
   * @remarks
   * Indicates whether the tracing analysis feature is enabled. To enable the tracing analysis feature, you must activate Managed Service for OpenTelemetry. Valid values:
   * 
   * *   `true`: enables the tracing analysis feature. If you enable the tracing analysis feature, related headers are inserted into requests for the domain name.
   * *   `false`: disables the tracing analysis feature.
   * 
   * @example
   * true
   */
  tracing?: boolean;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      domain: 'Domain',
      propagatorTypes: 'PropagatorTypes',
      samplingRate: 'SamplingRate',
      tracing: 'Tracing',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      domain: 'string',
      propagatorTypes: { 'type': 'array', 'itemType': 'string' },
      samplingRate: 'number',
      tracing: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumAppInfoResponseBodyDataTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * Label
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * Value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumAppInfoResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The group to which the application belongs.
   * 
   * @example
   * default
   */
  appGroup?: string;
  /**
   * @remarks
   * The application type. Valid values: web, miniapp, ios, and android.
   * 
   * @example
   * web
   */
  appType?: string;
  /**
   * @example
   * cn-hangzhou
   */
  backendServiceTraceRegion?: string;
  /**
   * @remarks
   * The mobile collection configurations.
   */
  bonreeSDKConfig?: GetRumAppInfoResponseBodyDataBonreeSDKConfig;
  /**
   * @remarks
   * The domain name of the SDK.
   * 
   * @example
   * b59xxxxxxxx-sdk.rum.aliyuncs.com/v2/browser-sdk.js
   */
  cdnDomain?: string;
  /**
   * @remarks
   * The time when the application was created. The value is a timestamp. Unit: milliseconds.
   * 
   * @example
   * 1683353594000
   */
  createTime?: string;
  /**
   * @remarks
   * The description of the application.
   */
  description?: string;
  /**
   * @remarks
   * The endpoint that is used to report application data.
   * 
   * @example
   * xxxxxxxx-default-cn.rum.aliyuncs.com
   */
  endpoint?: string;
  /**
   * @remarks
   * Indicates whether the application is subscribed. Valid values: true and false.
   * 
   * @example
   * true
   */
  isSubscription?: string;
  /**
   * @remarks
   * The application name.
   * 
   * @example
   * tomcat-demo-test
   */
  name?: string;
  /**
   * @remarks
   * The alias of the application.
   * 
   * @example
   * nickname
   */
  nickName?: string;
  /**
   * @remarks
   * The name of the application package.
   * 
   * @example
   * com.alibaba.rum
   */
  packageName?: string;
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * avccccefy0@24cccccbf384dc6
   */
  pid?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-aek2vezare****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The list of service domain configurations. Only mobile applications are supported.
   */
  serviceDomainConfigs?: GetRumAppInfoResponseBodyDataServiceDomainConfigs[];
  /**
   * @remarks
   * The name of the Simple Log Service Logstore that stores application data.
   * 
   * @example
   * logstore-rum
   */
  slsLogstore?: string;
  /**
   * @remarks
   * The name of the Simple Log Service project that stores application data.
   * 
   * @example
   * proj-xtrace-xxxxxxxxxxxxxxxxxxxxxxx-cn-hangzhou
   */
  slsProject?: string;
  /**
   * @remarks
   * The status of the application. Valid values: created, running, and stopped.
   * 
   * @example
   * running
   */
  status?: string;
  /**
   * @remarks
   * The tags.
   */
  tags?: GetRumAppInfoResponseBodyDataTags[];
  /**
   * @remarks
   * The type of the application. Valid value: RUM.
   * 
   * @example
   * RUM
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      appGroup: 'AppGroup',
      appType: 'AppType',
      backendServiceTraceRegion: 'BackendServiceTraceRegion',
      bonreeSDKConfig: 'BonreeSDKConfig',
      cdnDomain: 'CdnDomain',
      createTime: 'CreateTime',
      description: 'Description',
      endpoint: 'Endpoint',
      isSubscription: 'IsSubscription',
      name: 'Name',
      nickName: 'NickName',
      packageName: 'PackageName',
      pid: 'Pid',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      serviceDomainConfigs: 'ServiceDomainConfigs',
      slsLogstore: 'SlsLogstore',
      slsProject: 'SlsProject',
      status: 'Status',
      tags: 'Tags',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appGroup: 'string',
      appType: 'string',
      backendServiceTraceRegion: 'string',
      bonreeSDKConfig: GetRumAppInfoResponseBodyDataBonreeSDKConfig,
      cdnDomain: 'string',
      createTime: 'string',
      description: 'string',
      endpoint: 'string',
      isSubscription: 'string',
      name: 'string',
      nickName: 'string',
      packageName: 'string',
      pid: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      serviceDomainConfigs: { 'type': 'array', 'itemType': GetRumAppInfoResponseBodyDataServiceDomainConfigs },
      slsLogstore: 'string',
      slsProject: 'string',
      status: 'string',
      tags: { 'type': 'array', 'itemType': GetRumAppInfoResponseBodyDataTags },
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumAppsRequestTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * TestKey
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * TestValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumAppsResponseBodyAppListServiceDomainConfigs extends $tea.Model {
  /**
   * @remarks
   * The description.
   * 
   * @example
   * Test
   */
  description?: string;
  /**
   * @remarks
   * The domain name or IP address.
   * 
   * @example
   * example.com
   */
  domain?: string;
  /**
   * @remarks
   * The trace propagation protocols. This parameter is required if the tracing analysis feature is enabled.
   */
  propagatorTypes?: string[];
  /**
   * @remarks
   * Indicates whether the tracing analysis feature is enabled. To enable the tracing analysis feature, you must activate Managed Service for OpenTelemetry. Valid values:
   * 
   * *   `true`: enables the tracing analysis feature. If you enable the tracing analysis feature, related headers are inserted into requests for the domain name.
   * *   `false`: disables the tracing analysis feature.
   * 
   * @example
   * true
   */
  tracing?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      domain: 'Domain',
      propagatorTypes: 'PropagatorTypes',
      tracing: 'Tracing',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      domain: 'string',
      propagatorTypes: { 'type': 'array', 'itemType': 'string' },
      tracing: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumAppsResponseBodyAppListTags extends $tea.Model {
  /**
   * @remarks
   * The tag key. The tag key can be up to 128 characters in length. It cannot start with aliyun or acs: and cannot contain http:// or https://.
   * 
   * @example
   * tag1
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * ok
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumAppsResponseBodyAppList extends $tea.Model {
  /**
   * @remarks
   * The application type. Valid values: web, miniapp, ios, and android.
   * 
   * @example
   * web
   */
  appType?: string;
  /**
   * @remarks
   * The time when the application was created. The value is a timestamp.
   * 
   * @example
   * 1685686960872
   */
  createTime?: any;
  /**
   * @remarks
   * The description of the application.
   * 
   * @example
   * TEST
   */
  description?: string;
  /**
   * @remarks
   * The endpoint that is used to report application data.
   * 
   * @example
   * xxxxxxxx-default-cn.rum.aliyuncs.com
   */
  endpoint?: string;
  /**
   * @remarks
   * Indicates whether the application is subscribed. Valid values: true and false.
   * 
   * @example
   * true
   */
  isSubscription?: boolean;
  /**
   * @remarks
   * The application name.
   * 
   * @example
   * home page
   */
  name?: string;
  /**
   * @remarks
   * The alias of the application.
   * 
   * @example
   * Williamtag
   */
  nickName?: string;
  /**
   * @remarks
   * The package name of the Android application.
   * 
   * @example
   * com.zy.yxws
   */
  packageName?: string;
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * xxxxx@cc08bdxxxx20b15
   */
  pid?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfmzaq3ypaqkdy
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The list of service domain configurations. Only mobile applications are supported.
   */
  serviceDomainConfigs?: GetRumAppsResponseBodyAppListServiceDomainConfigs[];
  /**
   * @remarks
   * The name of the Simple Log Service Logstore that stores application data.
   * 
   * @example
   * logstore-rum
   */
  slsLogstore?: string;
  /**
   * @remarks
   * The name of the Simple Log Service project that stores application data.
   * 
   * @example
   * proj-xtrace-xxxxxxxba6ef5466b5debf9e2f951-cn-hangzhou
   */
  slsProject?: string;
  /**
   * @remarks
   * The status of the application. Valid values: created, running, and stopped.
   * 
   * @example
   * running
   */
  status?: string;
  /**
   * @remarks
   * The tags.
   */
  tags?: GetRumAppsResponseBodyAppListTags[];
  /**
   * @remarks
   * The type of the application. Valid value: RUM.
   * 
   * @example
   * RUM
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      appType: 'AppType',
      createTime: 'CreateTime',
      description: 'Description',
      endpoint: 'Endpoint',
      isSubscription: 'IsSubscription',
      name: 'Name',
      nickName: 'NickName',
      packageName: 'PackageName',
      pid: 'Pid',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      serviceDomainConfigs: 'ServiceDomainConfigs',
      slsLogstore: 'SlsLogstore',
      slsProject: 'SlsProject',
      status: 'Status',
      tags: 'Tags',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appType: 'string',
      createTime: 'any',
      description: 'string',
      endpoint: 'string',
      isSubscription: 'boolean',
      name: 'string',
      nickName: 'string',
      packageName: 'string',
      pid: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      serviceDomainConfigs: { 'type': 'array', 'itemType': GetRumAppsResponseBodyAppListServiceDomainConfigs },
      slsLogstore: 'string',
      slsProject: 'string',
      status: 'string',
      tags: { 'type': 'array', 'itemType': GetRumAppsResponseBodyAppListTags },
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumDataForPageResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * A reserved parameter. Ignore this parameter.
   * 
   * @example
   * null
   */
  authentication?: string;
  /**
   * @remarks
   * Indicates whether the query ends. Valid values: true and false.
   * 
   * @example
   * true
   */
  completion?: string;
  /**
   * @remarks
   * The queried data.
   */
  items?: { [key: string]: any }[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  page?: string;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: string;
  /**
   * @remarks
   * A reserved parameter. Ignore this parameter.
   * 
   * @example
   * null
   */
  preference?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 7
   */
  total?: string;
  static names(): { [key: string]: string } {
    return {
      authentication: 'Authentication',
      completion: 'Completion',
      items: 'Items',
      page: 'Page',
      pageSize: 'PageSize',
      preference: 'Preference',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authentication: 'string',
      completion: 'string',
      items: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
      page: 'string',
      pageSize: 'string',
      preference: 'string',
      total: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumExceptionStackResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The list of stacks.
   */
  lines?: string[];
  /**
   * @remarks
   * The thread ID.
   * 
   * @example
   * 16643
   */
  threadId?: string;
  static names(): { [key: string]: string } {
    return {
      lines: 'Lines',
      threadId: 'ThreadId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lines: { 'type': 'array', 'itemType': 'string' },
      threadId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumOcuStatisticDataRequestFilter extends $tea.Model {
  /**
   * @remarks
   * The key of the filter condition. Three types of filter conditions are provided:
   * 
   * *   Application name: pid (Note that the application name is displayed, but the application ID is actually specified)
   * *   Application type: siteType
   * *   Data type: dataType
   * 
   * @example
   * pid
   */
  key?: string;
  /**
   * @remarks
   * The type of the operator. Valid value: in.
   * 
   * @example
   * in
   */
  opType?: string;
  /**
   * @remarks
   * The value of the filter condition. The value is a JSON array of strings.
   * 
   * @example
   * ["b590xxxxx@2dcbxxxxx9", "b590xxxxx@2dcbxxxxx8"]
   */
  value?: any;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      opType: 'OpType',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      opType: 'string',
      value: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumOcuStatisticDataResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the next page exists.
   * 
   * @example
   * true
   */
  complete?: boolean;
  /**
   * @remarks
   * The queried data.
   */
  items?: { [key: string]: any }[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 100
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 100
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      complete: 'Complete',
      items: 'Items',
      page: 'Page',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      complete: 'boolean',
      items: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
      page: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRumUploadFilesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The file name.
   * 
   * @example
   * test.js.map
   */
  fileName?: string;
  /**
   * @remarks
   * The time when the file was last modified. The value is a timestamp.
   * 
   * @example
   * 1682863151000
   */
  lastModifiedTime?: any;
  /**
   * @remarks
   * The size of the file. Unit: bytes.
   * 
   * @example
   * 1000
   */
  size?: string;
  /**
   * @remarks
   * The file ID.
   * 
   * @example
   * cxxxerfewrfwerfwerffvrt
   */
  uuid?: string;
  /**
   * @remarks
   * The version number of the file.
   * 
   * @example
   * 1.0.0
   */
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      fileName: 'FileName',
      lastModifiedTime: 'LastModifiedTime',
      size: 'Size',
      uuid: 'Uuid',
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileName: 'string',
      lastModifiedTime: 'any',
      size: 'string',
      uuid: 'string',
      versionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSourceMapInfoResponseBodySourceMapList extends $tea.Model {
  /**
   * @remarks
   * The ID of the SourceMap file.
   */
  fid?: string;
  /**
   * @remarks
   * The name of the SourceMap file.
   * 
   * @example
   * test.sourcemap.js
   */
  fileName?: string;
  /**
   * @remarks
   * The size of the file. Unit: KB.
   * 
   * @example
   * 201223
   */
  size?: string;
  /**
   * @remarks
   * The timestamp that indicates when the file was uploaded.
   * 
   * @example
   * 1590657842000
   */
  uploadTime?: string;
  /**
   * @remarks
   * The version of the file.
   * 
   * @example
   * 0.0.0
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      fid: 'Fid',
      fileName: 'FileName',
      size: 'Size',
      uploadTime: 'UploadTime',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fid: 'string',
      fileName: 'string',
      size: 'string',
      uploadTime: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStackResponseBodyStackInfoExtInfo extends $tea.Model {
  /**
   * @remarks
   * The content of the custom parameter.
   * 
   * @example
   * input=254275&amp;
   */
  info?: string;
  /**
   * @remarks
   * The type of the custom parameter.
   * 
   * @example
   * 41
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      info: 'Info',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      info: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStackResponseBodyStackInfo extends $tea.Model {
  /**
   * @remarks
   * The name of the operation.
   * 
   * @example
   * Tomcat Servlet Process
   */
  api?: string;
  /**
   * @remarks
   * The duration. Unit: milliseconds.
   * 
   * @example
   * 32
   */
  duration?: number;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * java.lang.NullPointerException
   */
  exception?: string;
  /**
   * @remarks
   * The information about the array object.
   */
  extInfo?: GetStackResponseBodyStackInfoExtInfo;
  /**
   * @remarks
   * The number of rows in the method stack information.
   * 
   * @example
   * 34
   */
  line?: string;
  /**
   * @remarks
   * The ID of the RPC mode.
   * 
   * @example
   * 0.1
   */
  rpcId?: string;
  /**
   * @remarks
   * The name of the service.
   * 
   * @example
   * /com/test
   */
  serviceName?: string;
  /**
   * @remarks
   * The start time of the call method.
   * 
   * @example
   * 1653555396
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      api: 'Api',
      duration: 'Duration',
      exception: 'Exception',
      extInfo: 'ExtInfo',
      line: 'Line',
      rpcId: 'RpcId',
      serviceName: 'ServiceName',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      api: 'string',
      duration: 'number',
      exception: 'string',
      extInfo: GetStackResponseBodyStackInfoExtInfo,
      line: 'string',
      rpcId: 'string',
      serviceName: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticMonitorsRequestFilter extends $tea.Model {
  /**
   * @remarks
   * The type of the monitoring point. Valid values: 1: PC. 2: mobile device.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  monitorCategory?: number;
  /**
   * @remarks
   * The network type. Valid values: 1: private network. 2: Internet.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  network?: number;
  /**
   * @remarks
   * The type of the monitoring task. Valid values:
   * 
   * 1: ICMP. 2: TCP. 3: DNS. 4: HTTP. 5: website speed. 6: file download.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  taskType?: number;
  static names(): { [key: string]: string } {
    return {
      monitorCategory: 'MonitorCategory',
      network: 'Network',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      monitorCategory: 'number',
      network: 'number',
      taskType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticMonitorsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the monitoring point is available. Valid values: true and false.
   * 
   * @example
   * true
   */
  available?: string;
  /**
   * @remarks
   * Indicates whether the monitoring point is selected. Valid values: true and false.
   * 
   * @example
   * true
   */
  canBeSelected?: boolean;
  /**
   * @remarks
   * The city.
   * 
   * @example
   * Beijing
   */
  city?: string;
  /**
   * @remarks
   * The city code.
   * 
   * @example
   * 1100101
   */
  cityCode?: string;
  /**
   * @remarks
   * The client type of the monitoring point. Valid values: 1: data center. 2: Internet. 3: mobile device. 4: ECS instance.
   * 
   * @example
   * 1
   */
  clientType?: number;
  /**
   * @remarks
   * The country.
   * 
   * @example
   * China
   */
  country?: string;
  /**
   * @remarks
   * Indicates whether IPv6 is supported. Valid values: 0: IPv6 is not supported. 1: IPv6 is supported.
   * 
   * @example
   * 0
   */
  ipv6?: number;
  /**
   * @remarks
   * The carrier.
   * 
   * @example
   * Alibaba Cloud
   */
  operator?: string;
  /**
   * @remarks
   * The carrier code.
   * 
   * @example
   * 1
   */
  operatorCode?: string;
  /**
   * @remarks
   * The region.
   * 
   * @example
   * Beijing
   */
  region?: string;
  static names(): { [key: string]: string } {
    return {
      available: 'Available',
      canBeSelected: 'CanBeSelected',
      city: 'City',
      cityCode: 'CityCode',
      clientType: 'ClientType',
      country: 'Country',
      ipv6: 'Ipv6',
      operator: 'Operator',
      operatorCode: 'OperatorCode',
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      available: 'string',
      canBeSelected: 'boolean',
      city: 'string',
      cityCode: 'string',
      clientType: 'number',
      country: 'string',
      ipv6: 'number',
      operator: 'string',
      operatorCode: 'string',
      region: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList extends $tea.Model {
  /**
   * @remarks
   * The low-risk alert.
   * 
   * @example
   * 1
   */
  generalAlert?: string;
  /**
   * @remarks
   * Indicates whether the condition is essential.
   * 
   * @example
   * 0
   */
  isCritical?: string;
  /**
   * @remarks
   * The alert name.
   * 
   * @example
   * alert-test
   */
  name?: string;
  /**
   * @remarks
   * The Critical-level alert.
   * 
   * @example
   * 1
   */
  seriousAlert?: string;
  /**
   * @remarks
   * Greater than or less than.
   * 
   * @example
   * 1
   */
  symbols?: string;
  static names(): { [key: string]: string } {
    return {
      generalAlert: 'GeneralAlert',
      isCritical: 'IsCritical',
      name: 'Name',
      seriousAlert: 'SeriousAlert',
      symbols: 'Symbols',
    };
  }

  static types(): { [key: string]: any } {
    return {
      generalAlert: 'string',
      isCritical: 'string',
      name: 'string',
      seriousAlert: 'string',
      symbols: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam extends $tea.Model {
  /**
   * @remarks
   * The identifier of the alert.
   * 
   * @example
   * 1
   */
  alarmFlag?: number;
  /**
   * @remarks
   * The list of alerts.
   */
  alertList?: GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList[];
  /**
   * @remarks
   * The ID of the alert identifier.
   * 
   * @example
   * 1
   */
  alertNotifierId?: string;
  /**
   * @remarks
   * The ID of the alert policy.
   * 
   * @example
   * 1
   */
  alertPolicyId?: string;
  /**
   * @remarks
   * The monitoring samples.
   * 
   * @example
   * 1
   */
  monitorSamples?: string;
  /**
   * @remarks
   * The start time of the execution.
   * 
   * @example
   * 1664427128
   */
  startExecutionTime?: string;
  static names(): { [key: string]: string } {
    return {
      alarmFlag: 'AlarmFlag',
      alertList: 'AlertList',
      alertNotifierId: 'AlertNotifierId',
      alertPolicyId: 'AlertPolicyId',
      monitorSamples: 'MonitorSamples',
      startExecutionTime: 'StartExecutionTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmFlag: 'number',
      alertList: { 'type': 'array', 'itemType': GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList },
      alertNotifierId: 'string',
      alertPolicyId: 'string',
      monitorSamples: 'string',
      startExecutionTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticTaskDetailResponseBodyTaskDetailDownload extends $tea.Model {
  /**
   * @remarks
   * The timeout period of the file download task.
   * 
   * @example
   * 200
   */
  connectionTimeout?: number;
  /**
   * @remarks
   * The items to be ignored in a certificate error. Multiple values are concatenated with vertical bars (|).
   * 
   * @example
   * char
   */
  downloadCustomHeaderContent?: string;
  /**
   * @remarks
   * The custom host. Valid values:
   * 
   * *   1: round robin
   * *   0: random
   * 
   * @example
   * 0
   */
  downloadCustomHost?: number;
  /**
   * @remarks
   * The custom IP address of the host. Multiple IP addresses are separated with commas (,).
   * 
   * @example
   * 168.23.45.1
   */
  downloadCustomHostIp?: string;
  /**
   * @remarks
   * The kernel type. Valid values:
   * 
   * *   1: curl
   * *   0: WinInet
   * 
   * @example
   * 1
   */
  downloadKernel?: number;
  /**
   * @remarks
   * Indicates whether redirection is supported.
   * 
   * @example
   * 1
   */
  downloadRedirect?: number;
  /**
   * @remarks
   * The file size. Unit: KB.
   * 
   * @example
   * 20
   */
  downloadTransmissionSize?: number;
  /**
   * @remarks
   * The monitoring duration.
   * 
   * @example
   * 12
   */
  monitorTimeout?: number;
  /**
   * @remarks
   * The QUIC protocol type. Valid values:
   * 
   * *   1: HTTP/1
   * *   2: HTTP/2
   * *   3: http3
   * 
   * @example
   * 1
   */
  quickProtocol?: string;
  /**
   * @remarks
   * The keyword that is used in verification.
   * 
   * @example
   * test
   */
  validateKeywords?: string;
  /**
   * @remarks
   * The method that is used to verify the response content. Valid values:
   * 
   * *   0: no verification.
   * *   1: exact match with the verification string.
   * *   2: partial match with the verification string.
   * *   3: MD5 verification.
   * 
   * @example
   * 0
   */
  verifyWay?: number;
  /**
   * @remarks
   * The whitelisted objects that are used to avoid DNS hijacking. Format: `<domain name>:<objects>`.
   * 
   * >  WAP networks do not support hijacking.
   * 
   * @example
   * [{\\"src\\":\\"211.154.166.174\\"}]
   */
  whiteList?: string;
  static names(): { [key: string]: string } {
    return {
      connectionTimeout: 'ConnectionTimeout',
      downloadCustomHeaderContent: 'DownloadCustomHeaderContent',
      downloadCustomHost: 'DownloadCustomHost',
      downloadCustomHostIp: 'DownloadCustomHostIp',
      downloadKernel: 'DownloadKernel',
      downloadRedirect: 'DownloadRedirect',
      downloadTransmissionSize: 'DownloadTransmissionSize',
      monitorTimeout: 'MonitorTimeout',
      quickProtocol: 'QuickProtocol',
      validateKeywords: 'ValidateKeywords',
      verifyWay: 'VerifyWay',
      whiteList: 'WhiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connectionTimeout: 'number',
      downloadCustomHeaderContent: 'string',
      downloadCustomHost: 'number',
      downloadCustomHostIp: 'string',
      downloadKernel: 'number',
      downloadRedirect: 'number',
      downloadTransmissionSize: 'number',
      monitorTimeout: 'number',
      quickProtocol: 'string',
      validateKeywords: 'string',
      verifyWay: 'number',
      whiteList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval extends $tea.Model {
  /**
   * @remarks
   * The day on which synthetic monitoring is performed. Valid values:
   * 
   * *   \\-1: every day
   * *   0: Sunday
   * *   1: Monday
   * *   2: Tuesday
   * *   3: Wednesday
   * *   4: Thursday
   * *   5: Friday
   * *   6: Saturday
   */
  days?: number[];
  /**
   * @remarks
   * The minute at which synthetic monitoring ends.
   * 
   * @example
   * 20
   */
  endMinute?: number;
  /**
   * @remarks
   * The time when synthetic monitoring ends. Format: `yyyy-MM-dd HH`.
   * 
   * @example
   * 2022-05-03 11:40
   */
  endTime?: string;
  /**
   * @remarks
   * The hour at which synthetic monitoring ends.
   * 
   * @example
   * 12
   */
  endhour?: number;
  /**
   * @remarks
   * The hour at which synthetic monitoring starts.
   * 
   * @example
   * 9
   */
  startHour?: number;
  /**
   * @remarks
   * The minute at which synthetic monitoring starts.
   * 
   * @example
   * 20
   */
  startMinute?: number;
  /**
   * @remarks
   * The time when synthetic monitoring starts. Format: yyyy-MM-dd HH.
   * 
   * @example
   * 2022-02-26 11:40
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      days: 'Days',
      endMinute: 'EndMinute',
      endTime: 'EndTime',
      endhour: 'Endhour',
      startHour: 'StartHour',
      startMinute: 'StartMinute',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      days: { 'type': 'array', 'itemType': 'number' },
      endMinute: 'number',
      endTime: 'string',
      endhour: 'number',
      startHour: 'number',
      startMinute: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList extends $tea.Model {
  /**
   * @remarks
   * The city code.
   * 
   * @example
   * 110100
   */
  cityCode?: number;
  /**
   * @remarks
   * The type of the detection point.
   * 
   * @example
   * IDC
   */
  monitorType?: number;
  /**
   * @remarks
   * The ID of the network service.
   * 
   * @example
   * 12001
   */
  netServiceId?: number;
  /**
   * @remarks
   * The number of times that the system sends detection requests.
   * 
   * @example
   * 20
   */
  sendCount?: number;
  static names(): { [key: string]: string } {
    return {
      cityCode: 'CityCode',
      monitorType: 'MonitorType',
      netServiceId: 'NetServiceId',
      sendCount: 'SendCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cityCode: 'number',
      monitorType: 'number',
      netServiceId: 'number',
      sendCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticTaskDetailResponseBodyTaskDetailNav extends $tea.Model {
  /**
   * @remarks
   * The DNS whitelist.
   * 
   * @example
   * 119.119.53.156
   */
  dnsHijackWhitelist?: string;
  /**
   * @remarks
   * The element blacklist.
   * 
   * @example
   * test
   */
  elementBlacklist?: string;
  /**
   * @remarks
   * Indicates whether ActiveX is executed. Valid values:
   * 
   * *   3: yes
   * *   0: no
   * 
   * >  Only IE elements support this parameter.
   * 
   * @example
   * 3
   */
  executeActiveX?: number;
  /**
   * @remarks
   * Indicates whether the applet is executed. Valid values:
   * 
   * *   0: no
   * *   1: yes
   * 
   * @example
   * 1
   */
  executeApplet?: number;
  /**
   * @remarks
   * Indicates whether scripts are executed. Valid values:
   * 
   * *   1: yes
   * *   0: no
   * 
   * >  Only IE elements support this parameter.
   * 
   * @example
   * 1
   */
  executeScript?: number;
  /**
   * @remarks
   * Indicates whether invalid IP addresses are excluded. Valid values:
   * 
   * *   1: no
   * *   0: yes
   * 
   * @example
   * 1
   */
  filterInvalidIP?: number;
  /**
   * @remarks
   * The element that is used in DNS hijacking.
   * 
   * @example
   * 12
   */
  flowHijackJumpTimes?: number;
  /**
   * @remarks
   * The tag that is used in DNS hijacking.
   * 
   * @example
   * target
   */
  flowHijackLogo?: string;
  /**
   * @remarks
   * The monitoring timeout period.
   * 
   * @example
   * 20
   */
  monitorTimeout?: number;
  /**
   * @remarks
   * Indicates whether the screen is automatically scrolled up and down to load a page. Valid values:
   * 
   * *   1: yes
   * *   0: no
   * 
   * @example
   * 1
   */
  navAutomaticScrolling?: number;
  /**
   * @remarks
   * Indicates whether a custom header is created. Valid values:
   * 
   * *   0: no
   * *   1: A custom header is created for the first packet.
   * *   2: A custom header is created for all packets.
   * 
   * @example
   * 0
   */
  navCustomHeader?: string;
  /**
   * @remarks
   * The format of the custom header. Multiple fields are separated with vertical bars (|).
   * 
   * @example
   * content
   */
  navCustomHeaderContent?: string;
  /**
   * @remarks
   * The custom host mode. Valid values:
   * 
   * *   1: round robin
   * *   0: random
   * 
   * @example
   * 1
   */
  navCustomHost?: number;
  /**
   * @remarks
   * The custom IP address of the host. Multiple IP addresses are separated with commas (,).
   * 
   * @example
   * 119.119.53.156/32
   */
  navCustomHostIp?: string;
  /**
   * @remarks
   * Indicates whether caching is disabled. Valid values:
   * 
   * *   1: Caching is disabled.
   * *   0: Caching is enabled.
   * 
   * @example
   * 1
   */
  navDisableCache?: number;
  /**
   * @remarks
   * Indicates whether compression is disabled. Valid values:
   * 
   * *   0: Compression is enabled.
   * *   1: Compression is disabled.
   * 
   * @example
   * 0
   */
  navDisableCompression?: number;
  /**
   * @remarks
   * Indicates whether certificate errors are ignored during certificate verification in the SSL handshake. Valid values:
   * 
   * *   1: yes
   * *   0: no
   * 
   * @example
   * 1
   */
  navIgnoreCertificateError?: number;
  /**
   * @remarks
   * Indicates whether redirection is enabled. Valid values:
   * 
   * *   0: no
   * *   1: yes
   * 
   * @example
   * 1
   */
  navRedirect?: number;
  /**
   * @remarks
   * Indicates whether the elements on the page are returned.
   * 
   * *   1: no. The basic document data is returned.
   * *   2: yes. All document data is returned.
   * 
   * @example
   * 1
   */
  navReturnElement?: number;
  /**
   * @remarks
   * The page tampering.
   * 
   * @example
   * content
   */
  pageTampering?: string;
  /**
   * @remarks
   * The process ID.
   * 
   * @example
   * ssh
   */
  processName?: string;
  /**
   * @remarks
   * The domain name of the QUIC request element.
   * 
   * @example
   * www.example.com
   */
  quicDomain?: string;
  /**
   * @remarks
   * The QUIC version. Default value: 0. Valid values:
   * 
   * *   35
   * *   39
   * *   43
   * *   44
   * 
   * >  Only Chrome elements support this parameter.
   * 
   * @example
   * 0
   */
  quicVersion?: number;
  /**
   * @remarks
   * Indicates whether request headers are returned. Valid values:
   * 
   * *   0: no
   * *   1: The headers of base documents are returned.
   * *   2: All headers are returned.
   * 
   * @example
   * 0
   */
  requestHeader?: number;
  /**
   * @remarks
   * The time threshold that is used to define a slow element. Unit: seconds.
   * 
   * @example
   * 30
   */
  slowElementThreshold?: number;
  /**
   * @remarks
   * The blacklist for string verification.
   * 
   * @example
   * test
   */
  verifyStringBlacklist?: string;
  /**
   * @remarks
   * The whitelist for string verification.
   * 
   * @example
   * test
   */
  verifyStringWhitelist?: string;
  /**
   * @remarks
   * The timeout period of waiting for the monitoring to complete.
   * 
   * @example
   * 20
   */
  waitCompletionTime?: number;
  static names(): { [key: string]: string } {
    return {
      dnsHijackWhitelist: 'DnsHijackWhitelist',
      elementBlacklist: 'ElementBlacklist',
      executeActiveX: 'ExecuteActiveX',
      executeApplet: 'ExecuteApplet',
      executeScript: 'ExecuteScript',
      filterInvalidIP: 'FilterInvalidIP',
      flowHijackJumpTimes: 'FlowHijackJumpTimes',
      flowHijackLogo: 'FlowHijackLogo',
      monitorTimeout: 'MonitorTimeout',
      navAutomaticScrolling: 'NavAutomaticScrolling',
      navCustomHeader: 'NavCustomHeader',
      navCustomHeaderContent: 'NavCustomHeaderContent',
      navCustomHost: 'NavCustomHost',
      navCustomHostIp: 'NavCustomHostIp',
      navDisableCache: 'NavDisableCache',
      navDisableCompression: 'NavDisableCompression',
      navIgnoreCertificateError: 'NavIgnoreCertificateError',
      navRedirect: 'NavRedirect',
      navReturnElement: 'NavReturnElement',
      pageTampering: 'PageTampering',
      processName: 'ProcessName',
      quicDomain: 'QuicDomain',
      quicVersion: 'QuicVersion',
      requestHeader: 'RequestHeader',
      slowElementThreshold: 'SlowElementThreshold',
      verifyStringBlacklist: 'VerifyStringBlacklist',
      verifyStringWhitelist: 'VerifyStringWhitelist',
      waitCompletionTime: 'WaitCompletionTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dnsHijackWhitelist: 'string',
      elementBlacklist: 'string',
      executeActiveX: 'number',
      executeApplet: 'number',
      executeScript: 'number',
      filterInvalidIP: 'number',
      flowHijackJumpTimes: 'number',
      flowHijackLogo: 'string',
      monitorTimeout: 'number',
      navAutomaticScrolling: 'number',
      navCustomHeader: 'string',
      navCustomHeaderContent: 'string',
      navCustomHost: 'number',
      navCustomHostIp: 'string',
      navDisableCache: 'number',
      navDisableCompression: 'number',
      navIgnoreCertificateError: 'number',
      navRedirect: 'number',
      navReturnElement: 'number',
      pageTampering: 'string',
      processName: 'string',
      quicDomain: 'string',
      quicVersion: 'number',
      requestHeader: 'number',
      slowElementThreshold: 'number',
      verifyStringBlacklist: 'string',
      verifyStringWhitelist: 'string',
      waitCompletionTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticTaskDetailResponseBodyTaskDetailNet extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the data is displayed in the DIG format. Valid values:
   * 
   * *   0: no
   * *   1: yes
   * 
   * @example
   * 0
   */
  netDigSwitch?: number;
  /**
   * @remarks
   * The NS server.
   * 
   * @example
   * 189.12.32.124
   */
  netDnsNs?: string;
  /**
   * @remarks
   * The DNS query method. Valid values:
   * 
   * *   1: recursive
   * *   2: iterative
   * 
   * @example
   * 1
   */
  netDnsQueryMethod?: string;
  /**
   * @remarks
   * The type of the DNS server. Valid values:
   * 
   * *   0: ipv4
   * *   1: ipv6
   * *   2: A version is automatically selected.
   * 
   * @example
   * 0
   */
  netDnsServer?: number;
  /**
   * @remarks
   * Indicates whether DNS test is enabled. Valid values:
   * 
   * *   0: no
   * *   1: yes
   * 
   * @example
   * 0
   */
  netDnsSwitch?: number;
  /**
   * @remarks
   * The timeout period of DNS requests.
   * 
   * @example
   * 10
   */
  netDnsTimeout?: string;
  /**
   * @remarks
   * The protocol type. Valid values:
   * 
   * *   0 : ICMP
   * *   1 : TCP
   * 
   * @example
   * 0
   */
  netIcmpActive?: number;
  /**
   * @remarks
   * Indicates whether packets are split. Valid values:
   * 
   * *   0: no
   * *   1: yes
   * 
   * @example
   * 0
   */
  netIcmpDataCut?: number;
  /**
   * @remarks
   * The interval at which the synthetic monitoring task is executed.
   * 
   * @example
   * 10
   */
  netIcmpInterval?: number;
  /**
   * @remarks
   * The number of packets.
   * 
   * @example
   * 10
   */
  netIcmpNum?: number;
  /**
   * @remarks
   * The packet size.
   * 
   * @example
   * 30
   */
  netIcmpSize?: number;
  /**
   * @remarks
   * Indicates whether ICMP test is enabled. Valid values:
   * 
   * *   0: no.
   * *   1: yes. If you set this parameter to 1, you must also set the Icmp parameter.
   * 
   * @example
   * 0
   */
  netIcmpSwitch?: number;
  /**
   * @remarks
   * The monitoring timeout period.
   * 
   * @example
   * 20
   */
  netIcmpTimeout?: number;
  /**
   * @remarks
   * The maximum number of active detection points.
   * 
   * @example
   * 30
   */
  netTraceRouteNum?: number;
  /**
   * @remarks
   * Indicates whether Tracert test is enabled. Valid values:
   * 
   * *   0: no
   * *   1: yes. If you set this parameter to 1, you must also set the Tracert parameter.
   * 
   * @example
   * 0
   */
  netTraceRouteSwitch?: number;
  /**
   * @remarks
   * The monitoring timeout period. Valid values: 0 to 300. Unit: seconds.
   * 
   * @example
   * 20
   */
  netTraceRouteTimeout?: number;
  /**
   * @remarks
   * The whitelisted objects that are used to avoid DNS hijacking. Format: `<domain name>:<objects>`.
   * 
   * >  WAP networks do not support hijacking.
   * 
   * @example
   * 119.119.53.156/32
   */
  whiteList?: string;
  static names(): { [key: string]: string } {
    return {
      netDigSwitch: 'NetDigSwitch',
      netDnsNs: 'NetDnsNs',
      netDnsQueryMethod: 'NetDnsQueryMethod',
      netDnsServer: 'NetDnsServer',
      netDnsSwitch: 'NetDnsSwitch',
      netDnsTimeout: 'NetDnsTimeout',
      netIcmpActive: 'NetIcmpActive',
      netIcmpDataCut: 'NetIcmpDataCut',
      netIcmpInterval: 'NetIcmpInterval',
      netIcmpNum: 'NetIcmpNum',
      netIcmpSize: 'NetIcmpSize',
      netIcmpSwitch: 'NetIcmpSwitch',
      netIcmpTimeout: 'NetIcmpTimeout',
      netTraceRouteNum: 'NetTraceRouteNum',
      netTraceRouteSwitch: 'NetTraceRouteSwitch',
      netTraceRouteTimeout: 'NetTraceRouteTimeout',
      whiteList: 'WhiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      netDigSwitch: 'number',
      netDnsNs: 'string',
      netDnsQueryMethod: 'string',
      netDnsServer: 'number',
      netDnsSwitch: 'number',
      netDnsTimeout: 'string',
      netIcmpActive: 'number',
      netIcmpDataCut: 'number',
      netIcmpInterval: 'number',
      netIcmpNum: 'number',
      netIcmpSize: 'number',
      netIcmpSwitch: 'number',
      netIcmpTimeout: 'number',
      netTraceRouteNum: 'number',
      netTraceRouteSwitch: 'number',
      netTraceRouteTimeout: 'number',
      whiteList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata extends $tea.Model {
  /**
   * @remarks
   * The key of the **form-data**.
   * 
   * @example
   * appId
   */
  key?: string;
  /**
   * @remarks
   * The value of the form-data.
   * 
   * @example
   * 3425
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * appId
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * 11080
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody extends $tea.Model {
  /**
   * @remarks
   * The data content. This parameter is returned when Mode is set to form-data.
   */
  formdata?: GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata;
  /**
   * @remarks
   * The language used when Mode is set to raw. Valid values:
   * 
   * *   json
   * *   xml
   * *   javascript
   * *   html
   * *   text
   * 
   * @example
   * xml
   */
  language?: string;
  /**
   * @remarks
   * The type of the content. Valid values:
   * 
   * *   form-data
   * *   x-www-form-urlencoded
   * *   raw
   * 
   * @example
   * form-data
   */
  mode?: string;
  /**
   * @remarks
   * The data content. This parameter is returned when **Mode** is set to **raw**.
   * 
   * @example
   * content
   */
  raw?: string;
  /**
   * @remarks
   * The URL of the body content.
   */
  urlencoded?: GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded;
  static names(): { [key: string]: string } {
    return {
      formdata: 'Formdata',
      language: 'Language',
      mode: 'Mode',
      raw: 'Raw',
      urlencoded: 'Urlencoded',
    };
  }

  static types(): { [key: string]: any } {
    return {
      formdata: GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata,
      language: 'string',
      mode: 'string',
      raw: 'string',
      urlencoded: GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader extends $tea.Model {
  /**
   * @remarks
   * The key of the header in the request parameters.
   * 
   * @example
   * regionId
   */
  key?: string;
  /**
   * @remarks
   * The value of the header in the request parameters.
   * 
   * @example
   * cn-hangzhou
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent extends $tea.Model {
  /**
   * @remarks
   * The content of the request body.
   */
  body?: GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody;
  /**
   * @remarks
   * The request header.
   */
  header?: GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader[];
  /**
   * @remarks
   * The request method. Valid values:
   * 
   * *   POST
   * *   GET
   * 
   * @example
   * POST
   */
  method?: string;
  static names(): { [key: string]: string } {
    return {
      body: 'Body',
      header: 'Header',
      method: 'Method',
    };
  }

  static types(): { [key: string]: any } {
    return {
      body: GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody,
      header: { 'type': 'array', 'itemType': GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader },
      method: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticTaskDetailResponseBodyTaskDetailProtocol extends $tea.Model {
  /**
   * @remarks
   * The encoding format. Valid values:
   * 
   * *   0: UTF-8
   * *   1: GBK
   * *   2: GB2312
   * *   3: Unicode
   * 
   * @example
   * 0
   */
  characterEncoding?: number;
  /**
   * @remarks
   * The custom host. Valid values:
   * 
   * *   1: round robin
   * *   0: random
   * 
   * @example
   * 1
   */
  customHost?: number;
  /**
   * @remarks
   * The custom IP address of the host. Multiple IP addresses are separated with commas (,).
   * 
   * @example
   * 119.119.53.156
   */
  customHostIp?: string;
  /**
   * @remarks
   * The timeout period.
   * 
   * @example
   * 20
   */
  protocolConnectionTimeout?: number;
  /**
   * @remarks
   * The timeout period of API performance monitoring. Unit: seconds.
   * 
   * @example
   * 30
   */
  protocolMonitorTimeout?: number;
  /**
   * @remarks
   * The size of the received data. This parameter is returned when **VerifyWay** is set to 2.
   * 
   * @example
   * 30
   */
  receivedDataSize?: number;
  /**
   * @remarks
   * The request content, including the header and body.
   */
  requestContent?: GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent;
  /**
   * @remarks
   * The verification string.
   * 
   * @example
   * list
   */
  verifyContent?: string;
  /**
   * @remarks
   * The method that is used to verify the response content. Valid values:
   * 
   * *   0: no verification.
   * *   1: exact match with the verification string.
   * *   2: partial match with the verification string.
   * *   3: MD5 verification.
   * 
   * @example
   * 0
   */
  verifyWay?: number;
  static names(): { [key: string]: string } {
    return {
      characterEncoding: 'CharacterEncoding',
      customHost: 'CustomHost',
      customHostIp: 'CustomHostIp',
      protocolConnectionTimeout: 'ProtocolConnectionTimeout',
      protocolMonitorTimeout: 'ProtocolMonitorTimeout',
      receivedDataSize: 'ReceivedDataSize',
      requestContent: 'RequestContent',
      verifyContent: 'VerifyContent',
      verifyWay: 'VerifyWay',
    };
  }

  static types(): { [key: string]: any } {
    return {
      characterEncoding: 'number',
      customHost: 'number',
      customHostIp: 'string',
      protocolConnectionTimeout: 'number',
      protocolMonitorTimeout: 'number',
      receivedDataSize: 'number',
      requestContent: GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent,
      verifyContent: 'string',
      verifyWay: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticTaskDetailResponseBodyTaskDetail extends $tea.Model {
  /**
   * @remarks
   * The list of common parameters.
   */
  commonParam?: GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam;
  /**
   * @remarks
   * The file download task.
   */
  download?: GetSyntheticTaskDetailResponseBodyTaskDetailDownload;
  /**
   * @remarks
   * The frequency.
   */
  extendInterval?: GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval;
  /**
   * @remarks
   * The interval at which synthetic monitoring is performed. Unit: minutes. Valid values:
   * 
   * *   1
   * *   5
   * *   10
   * *   15
   * *   20
   * *   30
   * *   60
   * *   120
   * *   180
   * *   240
   * *   360
   * *   480
   * *   720
   * *   1440
   * 
   * @example
   * 20
   */
  intervalTime?: number;
  /**
   * @remarks
   * The interval type. Valid values:
   * 
   * *   0: daily
   * *   1: custom frequency
   * 
   * @example
   * 0
   */
  intervalType?: number;
  /**
   * @remarks
   * The IP version. Valid values:
   * 
   * *   0: A version is automatically selected.
   * *   1: IPv4.
   * *   2: IPv6.
   * 
   * @example
   * 0
   */
  ipType?: number;
  /**
   * @remarks
   * The detection points.
   */
  monitorList?: GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList[];
  /**
   * @remarks
   * The detection points.
   * 
   * @example
   * 12
   */
  monitorListString?: string;
  /**
   * @remarks
   * The browser test task.
   */
  nav?: GetSyntheticTaskDetailResponseBodyTaskDetailNav;
  /**
   * @remarks
   * The network synthetic monitoring task.
   */
  net?: GetSyntheticTaskDetailResponseBodyTaskDetailNet;
  /**
   * @remarks
   * The synthetic monitoring task of the API performance type.
   */
  protocol?: GetSyntheticTaskDetailResponseBodyTaskDetailProtocol;
  /**
   * @remarks
   * The ID of the synthetic monitoring task.
   * 
   * @example
   * 19584
   */
  taskId?: number;
  /**
   * @remarks
   * The name of the task.
   * 
   * @example
   * net-test
   */
  taskName?: string;
  /**
   * @remarks
   * The type of the task. Valid values:
   * 
   * 1.  3: web page performance - IE
   * 2.  34: web page performance - Chrome
   * 3.  0: network quality
   * 4.  40: file download
   * 5.  7: API performance
   * 
   * @example
   * 0
   */
  taskType?: number;
  /**
   * @remarks
   * The URL for synthetic monitoring.
   * 
   * @example
   * www.example.com
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      commonParam: 'CommonParam',
      download: 'Download',
      extendInterval: 'ExtendInterval',
      intervalTime: 'IntervalTime',
      intervalType: 'IntervalType',
      ipType: 'IpType',
      monitorList: 'MonitorList',
      monitorListString: 'MonitorListString',
      nav: 'Nav',
      net: 'Net',
      protocol: 'Protocol',
      taskId: 'TaskId',
      taskName: 'TaskName',
      taskType: 'TaskType',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonParam: GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam,
      download: GetSyntheticTaskDetailResponseBodyTaskDetailDownload,
      extendInterval: GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval,
      intervalTime: 'number',
      intervalType: 'number',
      ipType: 'number',
      monitorList: { 'type': 'array', 'itemType': GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList },
      monitorListString: 'string',
      nav: GetSyntheticTaskDetailResponseBodyTaskDetailNav,
      net: GetSyntheticTaskDetailResponseBodyTaskDetailNet,
      protocol: GetSyntheticTaskDetailResponseBodyTaskDetailProtocol,
      taskId: 'number',
      taskName: 'string',
      taskType: 'number',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticTaskListResponseBodyPageInfoList extends $tea.Model {
  /**
   * @remarks
   * The time when the task was created.
   * 
   * @example
   * 1634005438000
   */
  createTime?: string;
  /**
   * @remarks
   * The number of detection points.
   * 
   * @example
   * 2
   */
  monitorNumber?: number;
  /**
   * @remarks
   * The ID of the synthetic monitoring task.
   * 
   * @example
   * 2118709
   */
  taskId?: string;
  /**
   * @remarks
   * The task name.
   * 
   * @example
   * net-test
   */
  taskName?: string;
  /**
   * @remarks
   * The status of the task. Valid values:
   * 
   * *   **0**: The task is stopped.
   * *   **1**: The task is started.
   * *   **9**: The task is ended.
   * 
   * @example
   * 0
   */
  taskStatus?: string;
  /**
   * @remarks
   * The type of the task. Valid values:
   * 
   * 1.  3: web page performance - IE
   * 2.  34: web page performance - Chrome
   * 3.  0: network quality
   * 4.  40: file download
   * 5.  7: API performance
   * 
   * @example
   * 0
   */
  taskType?: number;
  /**
   * @remarks
   * The name of the task type.
   */
  taskTypeName?: string;
  /**
   * @remarks
   * The URL for synthetic monitoring.
   * 
   * @example
   * www.example.com
   */
  url?: string;
  /**
   * @remarks
   * The availability. Only the data of the last day is counted. If no data is available for the last day, an empty value is returned.
   * 
   * @example
   * 0.80
   */
  usable?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      monitorNumber: 'MonitorNumber',
      taskId: 'TaskId',
      taskName: 'TaskName',
      taskStatus: 'TaskStatus',
      taskType: 'TaskType',
      taskTypeName: 'TaskTypeName',
      url: 'Url',
      usable: 'Usable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      monitorNumber: 'number',
      taskId: 'string',
      taskName: 'string',
      taskStatus: 'string',
      taskType: 'number',
      taskTypeName: 'string',
      url: 'string',
      usable: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticTaskListResponseBodyPageInfo extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the current page is followed by a page.
   * 
   * @example
   * false
   */
  hasNextPage?: string;
  /**
   * @remarks
   * Indicates whether a previous page exists.
   * 
   * @example
   * true
   */
  hasPreviousPage?: boolean;
  /**
   * @remarks
   * Indicates whether the page is the first page.
   * 
   * @example
   * true
   */
  isFirstPage?: boolean;
  /**
   * @remarks
   * Indicates whether the page is the last page.
   * 
   * @example
   * true
   */
  isLastPage?: boolean;
  /**
   * @remarks
   * The task information.
   */
  list?: GetSyntheticTaskListResponseBodyPageInfoList[];
  /**
   * @remarks
   * The first page on the navigation bar.
   * 
   * @example
   * 1
   */
  navigateFirstPage?: string;
  /**
   * @remarks
   * The last page on the navigation bar.
   * 
   * @example
   * 3
   */
  navigateLastPage?: string;
  /**
   * @remarks
   * All navigation page numbers.
   * 
   * @example
   * 1,2,3
   */
  navigatePageNums?: string;
  /**
   * @remarks
   * The next page.
   * 
   * @example
   * 3
   */
  nextPage?: string;
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 10
   */
  pages?: string;
  /**
   * @remarks
   * The previous page.
   * 
   * @example
   * 1
   */
  prepage?: string;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  size?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 15
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      hasNextPage: 'HasNextPage',
      hasPreviousPage: 'HasPreviousPage',
      isFirstPage: 'IsFirstPage',
      isLastPage: 'IsLastPage',
      list: 'List',
      navigateFirstPage: 'NavigateFirstPage',
      navigateLastPage: 'NavigateLastPage',
      navigatePageNums: 'NavigatePageNums',
      nextPage: 'NextPage',
      pages: 'Pages',
      prepage: 'Prepage',
      size: 'Size',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hasNextPage: 'string',
      hasPreviousPage: 'boolean',
      isFirstPage: 'boolean',
      isLastPage: 'boolean',
      list: { 'type': 'array', 'itemType': GetSyntheticTaskListResponseBodyPageInfoList },
      navigateFirstPage: 'string',
      navigateLastPage: 'string',
      navigatePageNums: 'string',
      nextPage: 'string',
      pages: 'string',
      prepage: 'string',
      size: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSyntheticTaskMonitorsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The task status.
   * 
   * *   0: active
   * *   1: busy
   * 
   * @example
   * 0
   */
  busy?: number;
  /**
   * @remarks
   * The name of the city to which the monitoring point belongs.
   * 
   * @example
   * Beijing
   */
  city?: string;
  /**
   * @remarks
   * The ID of the city to which the monitoring point belongs.
   * 
   * @example
   * 1100101
   */
  cityCode?: number;
  /**
   * @remarks
   * The client type:
   * 
   * *   1: IDC
   * *   2: Last mile
   * 
   * @example
   * 1
   */
  clientType?: number;
  /**
   * @remarks
   * The region to which the monitoring point belongs.
   * 
   * @example
   * Beijing
   */
  district?: string;
  /**
   * @remarks
   * The ID of the carrier.
   * 
   * @example
   * 18
   */
  netServiceId?: number;
  /**
   * @remarks
   * The name of the carrier.
   * 
   * @example
   * XXX
   */
  netServiceName?: string;
  static names(): { [key: string]: string } {
    return {
      busy: 'Busy',
      city: 'City',
      cityCode: 'CityCode',
      clientType: 'ClientType',
      district: 'District',
      netServiceId: 'NetServiceId',
      netServiceName: 'NetServiceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      busy: 'number',
      city: 'string',
      cityCode: 'number',
      clientType: 'number',
      district: 'string',
      netServiceId: 'number',
      netServiceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTimingSyntheticTaskResponseBodyDataAvailableAssertions extends $tea.Model {
  /**
   * @remarks
   * The expected value.
   * 
   * @example
   * 100
   */
  expect?: string;
  /**
   * @remarks
   * The condition. gt: greater than. gte: greater than or equal to. lt: less than. lte: less than or equal to. eq: equal to. neq: not equal to. ctn: contain. nctn: does not contain. exist: exist. n_exist: does not exist. belong: belong to. n_belong: does not belong to. reg_match: regular expression.
   * 
   * @example
   * gt
   */
  operator?: string;
  /**
   * @remarks
   * The check target. If you set the type parameter to HttpResCode, HttpResBody, or HttpResponseTime, you do not need to set the target parameter. If you set the type parameter to HttpResHead, you must specify the key in the header. If you set the type parameter to HttpResBodyJson, use jsonPath.
   * 
   * @example
   * key
   */
  target?: string;
  /**
   * @remarks
   * The assertion type. Valid values: HttpResCode, HttpResHead, HttpResBody, HttpResBodyJson, HttpResponseTime, IcmpPackLoss (packet loss rate), IcmpPackMaxLatency (maximum packet latency), IcmpPackAvgLatency (average packet latency), TraceRouteHops (number of hops), DnsARecord (A record), DnsCName (CNAME), websiteTTFB (time to first packet), websiteTTLB (time to last packet), websiteFST (first paint time), websiteFFST (first meaningful paint), websiteOnload (full loaded time). For more information, see the following description.
   * 
   * @example
   * websiteTTLB
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      expect: 'Expect',
      operator: 'Operator',
      target: 'Target',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expect: 'string',
      operator: 'string',
      target: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHostHosts extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The IP version. Valid values:
   * 
   * *   0: A version is automatically selected.
   * *   1: IPv4
   * *   2: IPv6
   * 
   * @example
   * 0
   */
  ipType?: number;
  /**
   * @remarks
   * The list of IP addresses.
   */
  ips?: string[];
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      ipType: 'IpType',
      ips: 'Ips',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      ipType: 'number',
      ips: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHost extends $tea.Model {
  /**
   * @remarks
   * The list of hosts.
   */
  hosts?: GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHostHosts[];
  /**
   * @remarks
   * The selection mode. 0: Random. 1: Polling.
   * 
   * @example
   * 0
   */
  selectType?: number;
  static names(): { [key: string]: string } {
    return {
      hosts: 'Hosts',
      selectType: 'SelectType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hosts: { 'type': 'array', 'itemType': GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHostHosts },
      selectType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomPrometheusSetting extends $tea.Model {
  /**
   * @remarks
   * A reserved parameter.
   * 
   * @example
   * Reserved parameter
   */
  prometheusClusterId?: string;
  /**
   * @remarks
   * A reserved parameter.
   * 
   * @example
   * Reserved parameter
   */
  prometheusClusterRegion?: string;
  /**
   * @remarks
   * A reserved parameter.
   */
  prometheusLabels?: { [key: string]: string };
  static names(): { [key: string]: string } {
    return {
      prometheusClusterId: 'PrometheusClusterId',
      prometheusClusterRegion: 'PrometheusClusterRegion',
      prometheusLabels: 'PrometheusLabels',
    };
  }

  static types(): { [key: string]: any } {
    return {
      prometheusClusterId: 'string',
      prometheusClusterRegion: 'string',
      prometheusLabels: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomVPCSetting extends $tea.Model {
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * Security group ID. This security group is where the dial-up client is located. The security group limits the inbound and outbound rules of the dial-up client in the VPC. You need to set the inbound rules of the security group where your VPC is located to allow the security group where the dial-up client is located to access. Otherwise, the dial-up client cannot smoothly access the resources in your VPC.
   * 
   * @example
   * sg-xxxxxxx
   */
  secureGroupId?: string;
  /**
   * @remarks
   * The vSwitch ID.
   * 
   * @example
   * vsw-bp1i0xezblf1yrz4xxxxx
   */
  vSwitchId?: string;
  /**
   * @remarks
   * VPC ID.
   * 
   * @example
   * vpc-2zexy5nae9q2otaxxxx
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      secureGroupId: 'SecureGroupId',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      secureGroupId: 'string',
      vSwitchId: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTimingSyntheticTaskResponseBodyDataCommonSetting extends $tea.Model {
  /**
   * @remarks
   * The custom host.
   */
  customHost?: GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHost;
  /**
   * @remarks
   * The reserved parameters.
   */
  customPrometheusSetting?: GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomPrometheusSetting;
  /**
   * @remarks
   * User VPC information. If the dial-up is to the Alibaba Cloud intranet address, you need to configure the VPC information.
   */
  customVPCSetting?: GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomVPCSetting;
  /**
   * @remarks
   * The IP version. Valid values:
   * 
   * *   0: A version is automatically selected.
   * *   1: IPv4
   * *   2: IPv6
   * 
   * @example
   * 0
   */
  ipType?: number;
  /**
   * @remarks
   * Whether to enable tracing.
   * 
   * @example
   * true
   */
  isOpenTrace?: boolean;
  /**
   * @remarks
   * Specifies whether to evenly distribute monitoring samples. Valid values:
   * 
   * *   0: No
   * *   1: Yes
   * 
   * @example
   * 0
   */
  monitorSamples?: number;
  /**
   * @remarks
   * Tracing client type:
   * 
   * - 0: ARMS Agent
   * - 1: Open Telemetry
   * - 2: Jaeger
   * 
   * @example
   * 1
   */
  traceClientType?: number;
  /**
   * @remarks
   * Tracing data reporting region.
   * 
   * @example
   * cn-hangzhou
   */
  xtraceRegion?: string;
  static names(): { [key: string]: string } {
    return {
      customHost: 'CustomHost',
      customPrometheusSetting: 'CustomPrometheusSetting',
      customVPCSetting: 'CustomVPCSetting',
      ipType: 'IpType',
      isOpenTrace: 'IsOpenTrace',
      monitorSamples: 'MonitorSamples',
      traceClientType: 'TraceClientType',
      xtraceRegion: 'XtraceRegion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customHost: GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHost,
      customPrometheusSetting: GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomPrometheusSetting,
      customVPCSetting: GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomVPCSetting,
      ipType: 'number',
      isOpenTrace: 'boolean',
      monitorSamples: 'number',
      traceClientType: 'number',
      xtraceRegion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTimingSyntheticTaskResponseBodyDataCustomPeriod extends $tea.Model {
  /**
   * @remarks
   * The hour at which the test ends. Valid values: 0 to 24.
   * 
   * @example
   * 22
   */
  endHour?: number;
  /**
   * @remarks
   * The hour at which the test starts. Valid values: 0 to 24.
   * 
   * @example
   * 14
   */
  startHour?: number;
  static names(): { [key: string]: string } {
    return {
      endHour: 'EndHour',
      startHour: 'StartHour',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endHour: 'number',
      startHour: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTPRequestBody extends $tea.Model {
  /**
   * @remarks
   * The content of the request body. Format: JSON string. The parameter is required if the type parameter is set to text/plain, application/json, application/xml, or text/html. Format: JSON string.
   * 
   * @example
   * text/plain
   */
  content?: string;
  /**
   * @remarks
   * The type of the request body. Valid values: text/plain, application/json, application/x-www-form-urlencoded, multipart/form-data, application/xml, and text/html.
   * 
   * @example
   * multipart/form-data
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP extends $tea.Model {
  /**
   * @remarks
   * Whether to verify the certificate. The default is no.
   * 
   * @example
   * false
   */
  checkCert?: boolean;
  /**
   * @remarks
   * The connection timeout period. Unit: milliseconds. Default value: 5000. Minimum value: 1000. Maximum value: 300000.
   * 
   * @example
   * 5000
   */
  connectTimeout?: number;
  /**
   * @remarks
   * The request method.
   * 
   * *   POST
   * *   GET
   * 
   * @example
   * POST
   */
  method?: string;
  /**
   * @remarks
   * The ALPN protocol version. You can configure this parameter when you perform an HTTPS synthetic test on a WAP mobile client. Valid values:
   * 
   * 0: default
   * 
   * 1: HTTP/1.1
   * 
   * 2: HTTP/2
   * 
   * 3: disables the ALPN protocol
   * 
   * @example
   * 1
   */
  protocolAlpnProtocol?: number;
  /**
   * @remarks
   * The HTTP request body.
   */
  requestBody?: GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTPRequestBody;
  /**
   * @remarks
   * The HTTP request header.
   */
  requestHeaders?: { [key: string]: string };
  /**
   * @remarks
   * The URL for synthetic monitoring.
   * 
   * @example
   * http://127.0.0.1:8090/api/list
   */
  targetUrl?: string;
  /**
   * @remarks
   * The timeout period. Unit: milliseconds. Default value: 10000. Minimum value: 1000. Maximum value: 300000.
   * 
   * @example
   * 10000
   */
  timeout?: number;
  static names(): { [key: string]: string } {
    return {
      checkCert: 'CheckCert',
      connectTimeout: 'ConnectTimeout',
      method: 'Method',
      protocolAlpnProtocol: 'ProtocolAlpnProtocol',
      requestBody: 'RequestBody',
      requestHeaders: 'RequestHeaders',
      targetUrl: 'TargetUrl',
      timeout: 'Timeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkCert: 'boolean',
      connectTimeout: 'number',
      method: 'string',
      protocolAlpnProtocol: 'number',
      requestBody: GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTPRequestBody,
      requestHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      targetUrl: 'string',
      timeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload extends $tea.Model {
  /**
   * @remarks
   * The connection timeout period. Unit: milliseconds. Minimum value: 1000. Maximum value: 120000. Default value: 5000.
   * 
   * @example
   * 5000
   */
  connectionTimeout?: number;
  /**
   * @remarks
   * The content of the custom request header.
   */
  customHeaderContent?: { [key: string]: string };
  /**
   * @remarks
   * The kernel type.
   * 
   * *   1: curl
   * *   0: WinInet
   * 
   * @example
   * 0
   */
  downloadKernel?: number;
  /**
   * @remarks
   * Specifies whether to ignore CA certificate authentication errors. 0: No. 1: Yes. Default value: 1.
   * 
   * @example
   * 0
   */
  ignoreCertificateAuthError?: number;
  /**
   * @remarks
   * Specifies whether to ignore certificate revocation errors. 0: No. 1: Yes. Default value: 1.
   * 
   * @example
   * 0
   */
  ignoreCertificateCanceledError?: number;
  /**
   * @remarks
   * Specifies whether to ignore certificate invalidity. 0: No. 1: Yes. Default value: 1.
   * 
   * @example
   * 0
   */
  ignoreCertificateOutOfDateError?: number;
  /**
   * @remarks
   * Specifies whether to ignore certificate status errors. 0: No. 1: Yes. Default value: 1.
   * 
   * @example
   * 0
   */
  ignoreCertificateStatusError?: number;
  /**
   * @remarks
   * Specifies whether to ignore certificate incredibility. 0: No. 1: Yes. Default value: 1.
   * 
   * @example
   * 0
   */
  ignoreCertificateUntrustworthyError?: number;
  /**
   * @remarks
   * Specifies whether to ignore certificate usage errors. 0: No. 1: Yes. Default value: 1.
   * 
   * @example
   * 0
   */
  ignoreCertificateUsingError?: number;
  /**
   * @remarks
   * Specifies whether to ignore host invalidity. 0: No. 1: Yes. Default value: 1.
   * 
   * @example
   * 0
   */
  ignoreInvalidHostError?: number;
  /**
   * @remarks
   * The monitoring timeout period. Unit: milliseconds. Minimum value: 1000. Maximum value: 120000. Default value: 60000.
   * 
   * @example
   * 6000
   */
  monitorTimeout?: number;
  /**
   * @remarks
   * The QUIC protocol type.
   * 
   * *   1: http1
   * *   2: http2
   * *   3: http3
   * 
   * @example
   * 1
   */
  quickProtocol?: number;
  /**
   * @remarks
   * Specifies whether to support redirection. 0: No. 1: Yes. Default value: 1.
   * 
   * @example
   * 0
   */
  redirection?: number;
  /**
   * @remarks
   * The file download URL.
   * 
   * @example
   * https://********
   */
  targetUrl?: string;
  /**
   * @remarks
   * The maximum file size of a single transfer. Unit: KB. Minimum value: 1. Maximum value: 20480. Valid values: 2048.
   * 
   * @example
   * 2048
   */
  transmissionSize?: number;
  /**
   * @remarks
   * Verify keywords.
   * 
   * @example
   * success
   */
  validateKeywords?: string;
  /**
   * @remarks
   * Verification method.
   * 
   * - 0: No verification
   * - 1: Verification string
   * - 2: MD5 verification
   * 
   * @example
   * 0
   */
  verifyWay?: number;
  /**
   * @remarks
   * DNS hijacking whitelist. Matching rules support IP, IP wildcard, subnet mask and CNAME. You can fill in multiple matching rules, and multiple matching rules are separated by vertical bars (|). For example: `www.aliyun.com:203.0.3.55|203.3.44.67`, which means that all IPs except 203.0.3.55 and 203.3.44.67 under the www.aliyun.com domain name are hijacked.
   * 
   * @example
   * www.aliyun.com:203.0.3.55|203.3.44.67
   */
  whiteList?: string;
  static names(): { [key: string]: string } {
    return {
      connectionTimeout: 'ConnectionTimeout',
      customHeaderContent: 'CustomHeaderContent',
      downloadKernel: 'DownloadKernel',
      ignoreCertificateAuthError: 'IgnoreCertificateAuthError',
      ignoreCertificateCanceledError: 'IgnoreCertificateCanceledError',
      ignoreCertificateOutOfDateError: 'IgnoreCertificateOutOfDateError',
      ignoreCertificateStatusError: 'IgnoreCertificateStatusError',
      ignoreCertificateUntrustworthyError: 'IgnoreCertificateUntrustworthyError',
      ignoreCertificateUsingError: 'IgnoreCertificateUsingError',
      ignoreInvalidHostError: 'IgnoreInvalidHostError',
      monitorTimeout: 'MonitorTimeout',
      quickProtocol: 'QuickProtocol',
      redirection: 'Redirection',
      targetUrl: 'TargetUrl',
      transmissionSize: 'TransmissionSize',
      validateKeywords: 'ValidateKeywords',
      verifyWay: 'VerifyWay',
      whiteList: 'WhiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connectionTimeout: 'number',
      customHeaderContent: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      downloadKernel: 'number',
      ignoreCertificateAuthError: 'number',
      ignoreCertificateCanceledError: 'number',
      ignoreCertificateOutOfDateError: 'number',
      ignoreCertificateStatusError: 'number',
      ignoreCertificateUntrustworthyError: 'number',
      ignoreCertificateUsingError: 'number',
      ignoreInvalidHostError: 'number',
      monitorTimeout: 'number',
      quickProtocol: 'number',
      redirection: 'number',
      targetUrl: 'string',
      transmissionSize: 'number',
      validateKeywords: 'string',
      verifyWay: 'number',
      whiteList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS extends $tea.Model {
  /**
   * @remarks
   * The IP version of the DNS server. 0: IPv4. 1: IPv6. 2: A version is automatically selected. Default value: 0.
   * 
   * @example
   * 0
   */
  dnsServerIpType?: number;
  /**
   * @remarks
   * The IP address of the DNS server. Default value: 114.114.114.114.
   * 
   * @example
   * 114.114.114.114
   */
  nsServer?: string;
  /**
   * @remarks
   * The DNS query. 0: recursive, 1: iterative. Default value: 0.
   * 
   * @example
   * 0
   */
  queryMethod?: number;
  /**
   * @remarks
   * The destination domain name.
   * 
   * @example
   * www.aliyun.com
   */
  targetUrl?: string;
  /**
   * @remarks
   * The timeout period for the DNS synthetic test. Unit: milliseconds. The minimum value is 1000 and the maximum value is 45000. Default value: 5000.
   * 
   * @example
   * 5000
   */
  timeout?: number;
  static names(): { [key: string]: string } {
    return {
      dnsServerIpType: 'DnsServerIpType',
      nsServer: 'NsServer',
      queryMethod: 'QueryMethod',
      targetUrl: 'TargetUrl',
      timeout: 'Timeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dnsServerIpType: 'number',
      nsServer: 'string',
      queryMethod: 'number',
      targetUrl: 'string',
      timeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP extends $tea.Model {
  /**
   * @remarks
   * The interval at which ICMP packets are sent. Unit: milliseconds. Minimum value: 200. Maximum value: 2000. Default value: 200.
   * 
   * @example
   * 200
   */
  interval?: number;
  /**
   * @remarks
   * The number of ICMP packets that are sent. Minimum value: 1. Maximum value: 50. Default value: 4.
   * 
   * @example
   * 4
   */
  packageNum?: number;
  /**
   * @remarks
   * The size of each ICMP packet. Unit: bytes. Valid values: 32, 64, 128, 256, 512, 1024.
   * 
   * @example
   * 1024
   */
  packageSize?: number;
  /**
   * @remarks
   * Specifies whether to split ICMP packets. Default value: true.
   * 
   * @example
   * true
   */
  splitPackage?: boolean;
  /**
   * @remarks
   * The destination host IP address or domain name
   * 
   * @example
   * www.aliyun.com
   */
  targetUrl?: string;
  /**
   * @remarks
   * The timeout period for the TCP synthetic test. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 20000.
   * 
   * @example
   * 2000
   */
  timeout?: number;
  /**
   * @remarks
   * Specifies whether to enable the tracert command. Default value: true.
   * 
   * @example
   * true
   */
  tracertEnable?: boolean;
  /**
   * @remarks
   * The maximum number of hops for tracert. Minimum value: 1. Maximum value: 128. Default value: 64.
   * 
   * @example
   * 64
   */
  tracertNumMax?: number;
  /**
   * @remarks
   * The timeout period of tracert. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 60000.
   * 
   * @example
   * 60000
   */
  tracertTimeout?: number;
  static names(): { [key: string]: string } {
    return {
      interval: 'Interval',
      packageNum: 'PackageNum',
      packageSize: 'PackageSize',
      splitPackage: 'SplitPackage',
      targetUrl: 'TargetUrl',
      timeout: 'Timeout',
      tracertEnable: 'TracertEnable',
      tracertNumMax: 'TracertNumMax',
      tracertTimeout: 'TracertTimeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      interval: 'number',
      packageNum: 'number',
      packageSize: 'number',
      splitPackage: 'boolean',
      targetUrl: 'string',
      timeout: 'number',
      tracertEnable: 'boolean',
      tracertNumMax: 'number',
      tracertTimeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP extends $tea.Model {
  /**
   * @remarks
   * The number of TCP connections that are established in a test. Minimum value: 1. Maximum value: 16. Default value: 4.
   * 
   * @example
   * 4
   */
  connectTimes?: number;
  /**
   * @remarks
   * The interval at which TCP connections are established. Unit: milliseconds. Minimum value: 200. Maximum value: 10000. Default value: 200.
   * 
   * @example
   * 200
   */
  interval?: number;
  /**
   * @remarks
   * The destination host IP address.
   * 
   * @example
   * 127.0.0.1:8888
   */
  targetUrl?: string;
  /**
   * @remarks
   * The timeout period for the TCP synthetic test. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 20000.
   * 
   * @example
   * 20000
   */
  timeout?: number;
  /**
   * @remarks
   * Specifies whether to enable the tracert command. Default value: true.
   * 
   * @example
   * true
   */
  tracertEnable?: boolean;
  /**
   * @remarks
   * The maximum number of hops for tracert. Minimum value: 1. Maximum value: 128. Default value: 20.
   * 
   * @example
   * 20
   */
  tracertNumMax?: number;
  /**
   * @remarks
   * The timeout period of tracert. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 60000.
   * 
   * @example
   * 60000
   */
  tracertTimeout?: number;
  static names(): { [key: string]: string } {
    return {
      connectTimes: 'ConnectTimes',
      interval: 'Interval',
      targetUrl: 'TargetUrl',
      timeout: 'Timeout',
      tracertEnable: 'TracertEnable',
      tracertNumMax: 'TracertNumMax',
      tracertTimeout: 'TracertTimeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connectTimes: 'number',
      interval: 'number',
      targetUrl: 'string',
      timeout: 'number',
      tracertEnable: 'boolean',
      tracertNumMax: 'number',
      tracertTimeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTimingSyntheticTaskResponseBodyDataMonitorConfStream extends $tea.Model {
  /**
   * @remarks
   * Custom header, JSON Map format.
   */
  customHeaderContent?: { [key: string]: string };
  /**
   * @remarks
   * Player, default is 12 if not specified.
   * 
   * - 12: VLC
   * - 2: Flash Player
   * 
   * @example
   * 12
   */
  playerType?: number;
  /**
   * @remarks
   * Resource address type:
   * 
   * - 1: Resource address.
   * - 0: Page address. If not passed, the default value is 0.
   * 
   * @example
   * 0
   */
  streamAddressType?: number;
  /**
   * @remarks
   * Monitoring duration, in seconds, supports up to 60 seconds. If not specified, the default value is 60 seconds.
   * 
   * @example
   * 30
   */
  streamMonitorTimeout?: number;
  /**
   * @remarks
   * Audio and video flag:
   * 
   * - 0: video
   * - 1: audio
   * 
   * @example
   * 0
   */
  streamType?: number;
  /**
   * @remarks
   * Streaming media resource address.
   * 
   * @example
   * http://www.aliyun.com/stream/test.mp4
   */
  targetUrl?: string;
  /**
   * @remarks
   * DNS hijacking whitelist. Matching rules support IP, IP wildcard, subnet mask and CNAME. You can fill in multiple matching rules, and multiple matching rules are separated by vertical bars (|). For example: `www.aliyun.com:203.0.3.55|203.3.44.67`, which means that all IPs except 203.0.3.55 and 203.3.44.67 under the www.aliyun.com domain name are hijacked.
   * 
   * @example
   * www.aliyun.com:203.0.3.55|203.3.44.67
   */
  whiteList?: string;
  static names(): { [key: string]: string } {
    return {
      customHeaderContent: 'CustomHeaderContent',
      playerType: 'PlayerType',
      streamAddressType: 'StreamAddressType',
      streamMonitorTimeout: 'StreamMonitorTimeout',
      streamType: 'StreamType',
      targetUrl: 'TargetUrl',
      whiteList: 'WhiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customHeaderContent: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      playerType: 'number',
      streamAddressType: 'number',
      streamMonitorTimeout: 'number',
      streamType: 'number',
      targetUrl: 'string',
      whiteList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to automatically scroll up and down the screen to load a page. 0: No. 1: Yes. Default value: 0.
   * 
   * @example
   * 0
   */
  automaticScrolling?: number;
  /**
   * @remarks
   * Specifies whether to create a custom header. 0: No. 1: The first packet is modified. 2: All packets are modified. Default value: 0.
   * 
   * @example
   * 0
   */
  customHeader?: number;
  /**
   * @remarks
   * The custom header. Format: JSON map.
   */
  customHeaderContent?: { [key: string]: string };
  /**
   * @remarks
   * When resolving a domain name (such as www.aliyun.com), if the resolved IP address or CNAME is not in the DNS hijacking whitelist, the user will fail to access or return a non-Aliyun target IP; if the IP or CNAME in the resolution result is in the DNS whitelist, it will be deemed that no DNS hijacking has occurred.
   * 
   * Fill in the format: `domain name: matching rule`. Matching rules support IP, IP wildcard, subnet mask and CNAME. You can fill in multiple matching rules, and multiple matching rules are separated by vertical bars (|). 
   * 
   * For example: `www.aliyun.com:203.0.3.55|203.3.44.67`, which means that all IPs except 203.0.3.55 and 203.3.44.67 under the www.aliyun.com domain name are hijacked.
   * 
   * @example
   * www.aliyun.com:203.0.3.55|203.3.44.67
   */
  DNSHijackWhitelist?: string;
  /**
   * @remarks
   * Specifies whether to disable the cache. 0: No. 1: Yes. Default value: 1.
   * 
   * @example
   * 1
   */
  disableCache?: number;
  /**
   * @remarks
   * Specifies whether to accept compressed files based on the HTTP Accept-Encoding request header. 0: No. 1: Yes. Default value: 0.
   * 
   * @example
   * 0
   */
  disableCompression?: number;
  /**
   * @remarks
   * If an element configured in the element blacklist appears during page loading, no request will be made to load the element.
   * 
   * @example
   * www.example.com/a.jpg
   */
  elementBlacklist?: string;
  /**
   * @remarks
   * Specifies whether to exclude invalid IP addresses.
   * 
   * *   1: No
   * *   0: Yes
   * 
   * @example
   * 0
   */
  filterInvalidIP?: number;
  /**
   * @remarks
   * Identify elements: Set the total number of elements to browse the page.
   * 
   * @example
   * 0
   */
  flowHijackJumpTimes?: number;
  /**
   * @remarks
   * Hijacking flag: Set the key information for matching. Fill in the hijacking judgment keyword or key element, and asterisks (*) are allowed.
   * 
   * @example
   * aliyun
   */
  flowHijackLogo?: string;
  /**
   * @remarks
   * Specifies whether to ignore SSL certificate errors during browsing. 0: No. 1: Yes. Default value: 1.
   * 
   * @example
   * 0
   */
  ignoreCertificateError?: number;
  /**
   * @remarks
   * The monitoring timeout period. Unit: milliseconds. Default value: 20000. Minimum value: 5000. Maximum value: 300000.
   * 
   * @example
   * 20000
   */
  monitorTimeout?: number;
  /**
   * @remarks
   * If any element other than the domain name setting appears on the monitoring page, it means that the page has been tampered. Common manifestations include pop-up ads, floating ads, jumps, etc.
   * 
   * Fill in the format: `domain name: element`. Elements support wildcards, and multiple elements can be filled in. Multiple elements are separated by vertical bars (|). For example: `www.aliyun.com:|/cc/bb/a.gif|/vv/bb/cc.jpg`, which means that all elements except the basic document, /cc/bb/a.gif and /vv/bb/cc.jpg under the www.aliyun.com domain name are considered to be tampered with.
   * 
   * @example
   * www.aliyun.com:|/cc/bb/a.gif|/vv/bb/cc.jpg
   */
  pageTamper?: string;
  /**
   * @remarks
   * Specifies whether to continue browsing after redirection. 0: No, 1:Yes. Default value: 1.
   * 
   * @example
   * 1
   */
  redirection?: number;
  /**
   * @remarks
   * The time threshold that is used to define a slow element. Unit: milliseconds. Default value: 5000. Minimum value: 1. Maximum value: 300000.
   * 
   * @example
   * 5000
   */
  slowElementThreshold?: number;
  /**
   * @remarks
   * The destination URL.
   * 
   * @example
   * http://www.aliyun.com
   */
  targetUrl?: string;
  /**
   * @remarks
   * The verification string is an arbitrary string in the source code of the monitoring page. If the source code returned by the client contains any string in the blacklist, an error 650 &quot;Verification string failed&quot; will be reported. Multiple strings are separated by vertical bars (|).
   * 
   * @example
   * error
   */
  verifyStringBlacklist?: string;
  /**
   * @remarks
   * The verification string is an arbitrary string in the source code of the monitoring page. The source code returned by the client must contain all the strings in the whitelist, otherwise an error 650 &quot;Verification string failed&quot; will be reported. Multiple strings are separated by a vertical bar (|).
   * 
   * @example
   * success
   */
  verifyStringWhitelist?: string;
  /**
   * @remarks
   * The maximum waiting time. Unit: milliseconds. Default value: 5000. Minimum value: 5000. Maximum value: 300000.
   * 
   * @example
   * 5000
   */
  waitCompletionTime?: number;
  static names(): { [key: string]: string } {
    return {
      automaticScrolling: 'AutomaticScrolling',
      customHeader: 'CustomHeader',
      customHeaderContent: 'CustomHeaderContent',
      DNSHijackWhitelist: 'DNSHijackWhitelist',
      disableCache: 'DisableCache',
      disableCompression: 'DisableCompression',
      elementBlacklist: 'ElementBlacklist',
      filterInvalidIP: 'FilterInvalidIP',
      flowHijackJumpTimes: 'FlowHijackJumpTimes',
      flowHijackLogo: 'FlowHijackLogo',
      ignoreCertificateError: 'IgnoreCertificateError',
      monitorTimeout: 'MonitorTimeout',
      pageTamper: 'PageTamper',
      redirection: 'Redirection',
      slowElementThreshold: 'SlowElementThreshold',
      targetUrl: 'TargetUrl',
      verifyStringBlacklist: 'VerifyStringBlacklist',
      verifyStringWhitelist: 'VerifyStringWhitelist',
      waitCompletionTime: 'WaitCompletionTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      automaticScrolling: 'number',
      customHeader: 'number',
      customHeaderContent: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      DNSHijackWhitelist: 'string',
      disableCache: 'number',
      disableCompression: 'number',
      elementBlacklist: 'string',
      filterInvalidIP: 'number',
      flowHijackJumpTimes: 'number',
      flowHijackLogo: 'string',
      ignoreCertificateError: 'number',
      monitorTimeout: 'number',
      pageTamper: 'string',
      redirection: 'number',
      slowElementThreshold: 'number',
      targetUrl: 'string',
      verifyStringBlacklist: 'string',
      verifyStringWhitelist: 'string',
      waitCompletionTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTimingSyntheticTaskResponseBodyDataMonitorConf extends $tea.Model {
  /**
   * @remarks
   * The parameters of the HTTP(S) synthetic test.
   */
  apiHTTP?: GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP;
  /**
   * @remarks
   * The file download parameters.
   */
  fileDownload?: GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload;
  /**
   * @remarks
   * The DNS synthetic test parameters. This parameter is required if the TaskType parameter is set to 3.
   */
  netDNS?: GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS;
  /**
   * @remarks
   * The ICMP synthetic test parameters. This parameter is required if the TaskType parameter is set to 1.
   */
  netICMP?: GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP;
  /**
   * @remarks
   * The TCP synthetic tests parameters. This parameter is required if the TaskType parameter is set to 2.
   */
  netTCP?: GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP;
  /**
   * @remarks
   * Streaming media dial test configuration.
   */
  stream?: GetTimingSyntheticTaskResponseBodyDataMonitorConfStream;
  /**
   * @remarks
   * The website-speed measurement parameters.
   */
  website?: GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite;
  static names(): { [key: string]: string } {
    return {
      apiHTTP: 'ApiHTTP',
      fileDownload: 'FileDownload',
      netDNS: 'NetDNS',
      netICMP: 'NetICMP',
      netTCP: 'NetTCP',
      stream: 'Stream',
      website: 'Website',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiHTTP: GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP,
      fileDownload: GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload,
      netDNS: GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS,
      netICMP: GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP,
      netTCP: GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP,
      stream: GetTimingSyntheticTaskResponseBodyDataMonitorConfStream,
      website: GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTimingSyntheticTaskResponseBodyDataMonitors extends $tea.Model {
  /**
   * @remarks
   * The city code.
   * 
   * @example
   * 110100
   */
  cityCode?: string;
  /**
   * @remarks
   * The client type of the monitoring point. Valid values: 1: data center. 2: Internet. 3: mobile device. 4: ECS instance.
   * 
   * @example
   * 1
   */
  clientType?: number;
  /**
   * @remarks
   * The carrier code.
   * 
   * @example
   * 1
   */
  operatorCode?: string;
  static names(): { [key: string]: string } {
    return {
      cityCode: 'CityCode',
      clientType: 'ClientType',
      operatorCode: 'OperatorCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cityCode: 'string',
      clientType: 'number',
      operatorCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTimingSyntheticTaskResponseBodyDataTags extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * user1
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * myweb
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTimingSyntheticTaskResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The list of assertions.
   */
  availableAssertions?: GetTimingSyntheticTaskResponseBodyDataAvailableAssertions[];
  /**
   * @remarks
   * The general settings.
   */
  commonSetting?: GetTimingSyntheticTaskResponseBodyDataCommonSetting;
  /**
   * @remarks
   * The custom cycle.
   */
  customPeriod?: GetTimingSyntheticTaskResponseBodyDataCustomPeriod;
  /**
   * @remarks
   * The detection frequency. Valid values: 1m, 5m, 10m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, and 24h.
   * 
   * @example
   * 5m
   */
  frequency?: string;
  /**
   * @remarks
   * The detection point type. 1: PC. 2: mobile device.
   * 
   * @example
   * 1
   */
  monitorCategory?: number;
  /**
   * @remarks
   * The monitoring configurations.
   */
  monitorConf?: GetTimingSyntheticTaskResponseBodyDataMonitorConf;
  /**
   * @remarks
   * The list of monitoring points.
   */
  monitors?: GetTimingSyntheticTaskResponseBodyDataMonitors[];
  /**
   * @remarks
   * The name of the task.
   * 
   * @example
   * AlibabaCloud DNS Task
   */
  name?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * default
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * CREATING: The task is being created. RUNNING: The task is running. PARTIAL_RUNNING: The task is partially running. STOP: The task is stopped. LIMIT_STOP: The task is stopped due to quota insufficiency. EXCEPTION: The task is abnormal. DELETE: The task is deleted. DELETE_EXCEPTION: The task failed to be deleted.
   * 
   * @example
   * RUNNING
   */
  status?: string;
  /**
   * @remarks
   * The tag.
   */
  tags?: GetTimingSyntheticTaskResponseBodyDataTags[];
  /**
   * @remarks
   * The ID of the synthetic monitoring task.
   * 
   * @example
   * 5308a2691f59422c8c3b7aeccec9cd3b
   */
  taskId?: string;
  /**
   * @remarks
   * The type of the task. Valid values:
   * 
   * ICMP TCP DNS HTTP Website speed measurement File download
   * 
   * @example
   * 5
   */
  taskType?: number;
  static names(): { [key: string]: string } {
    return {
      availableAssertions: 'AvailableAssertions',
      commonSetting: 'CommonSetting',
      customPeriod: 'CustomPeriod',
      frequency: 'Frequency',
      monitorCategory: 'MonitorCategory',
      monitorConf: 'MonitorConf',
      monitors: 'Monitors',
      name: 'Name',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      status: 'Status',
      tags: 'Tags',
      taskId: 'TaskId',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableAssertions: { 'type': 'array', 'itemType': GetTimingSyntheticTaskResponseBodyDataAvailableAssertions },
      commonSetting: GetTimingSyntheticTaskResponseBodyDataCommonSetting,
      customPeriod: GetTimingSyntheticTaskResponseBodyDataCustomPeriod,
      frequency: 'string',
      monitorCategory: 'number',
      monitorConf: GetTimingSyntheticTaskResponseBodyDataMonitorConf,
      monitors: { 'type': 'array', 'itemType': GetTimingSyntheticTaskResponseBodyDataMonitors },
      name: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      status: 'string',
      tags: { 'type': 'array', 'itemType': GetTimingSyntheticTaskResponseBodyDataTags },
      taskId: 'string',
      taskType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTraceResponseBodySpansLogEventListTagEntryList extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * http.status.code
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * 200
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTraceResponseBodySpansLogEventList extends $tea.Model {
  /**
   * @remarks
   * The tags of the trace.
   */
  tagEntryList?: GetTraceResponseBodySpansLogEventListTagEntryList[];
  /**
   * @remarks
   * The timestamp when the log event was generated.
   * 
   * @example
   * 1590388651
   */
  timestamp?: number;
  static names(): { [key: string]: string } {
    return {
      tagEntryList: 'TagEntryList',
      timestamp: 'Timestamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagEntryList: { 'type': 'array', 'itemType': GetTraceResponseBodySpansLogEventListTagEntryList },
      timestamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTraceResponseBodySpansTagEntryList extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * http.status.code
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * 200
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTraceResponseBodySpans extends $tea.Model {
  /**
   * @remarks
   * The child spans of the current span.
   */
  children?: { [key: string]: any }[];
  /**
   * @remarks
   * The amount of time consumed by the trace. Unit: milliseconds.
   * 
   * @example
   * 1000
   */
  duration?: number;
  /**
   * @remarks
   * Indicates whether a method stack was provided.
   * 
   * *   `true`: A method stack was provided.
   * *   `false`: No method stack was provided.
   * 
   * @example
   * false
   */
  haveStack?: boolean;
  /**
   * @remarks
   * The log events in the trace.
   */
  logEventList?: GetTraceResponseBodySpansLogEventList[];
  /**
   * @remarks
   * The name of the traced span.
   * 
   * @example
   * /api/demo
   */
  operationName?: string;
  /**
   * @remarks
   * The ID of the parent span.
   * 
   * @example
   * 18
   */
  parentSpanId?: string;
  /**
   * @remarks
   * The status code.
   * 
   * @example
   * 222
   */
  resultCode?: string;
  /**
   * @remarks
   * The ID of the RPC mode.
   * 
   * @example
   * 0
   */
  rpcId?: string;
  /**
   * @remarks
   * The type of the remote procedure call (RPC) mode.
   * 
   * *   0: HTTP entry
   * *   25: HTTP call
   * *   1: High-speed Service Framework (HSF) call
   * *   2: HSF provision
   * *   40: on-premises API call
   * *   60: MySQL call
   * *   62: Oracle call
   * *   63: PostgreSQL call
   * *   70: Redis call
   * *   4: Taobao Distributed Data Layer (TDDL) call
   * *   5: Tair call
   * *   13: MetaQ message sending
   * *   252: MetaQ message receiving
   * *   3: notification sending
   * *   254: notification receiving
   * *   7: Apache Dubbo call
   * *   8: Apache Dubbo provision
   * *   19: SOFARPC call
   * *   18: SOFARPC provision
   * *   11: Distributed Service Framework (DSF) call
   * *   12: DSF provision
   * *   \\-1: unknown call
   * 
   * @example
   * 1
   */
  rpcType?: number;
  /**
   * @remarks
   * The IP address of the host where the application resides.
   * 
   * @example
   * 172.20.XX.XX
   */
  serviceIp?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * arms-demo
   */
  serviceName?: string;
  /**
   * @remarks
   * The span ID.
   * 
   * @example
   * 1234
   */
  spanId?: string;
  /**
   * @remarks
   * The tags of the trace.
   */
  tagEntryList?: GetTraceResponseBodySpansTagEntryList[];
  /**
   * @remarks
   * The timestamp generated when the span was generated.
   * 
   * @example
   * 1590388651
   */
  timestamp?: number;
  /**
   * @remarks
   * The trace ID.
   * 
   * @example
   * ac14001a15954493811405707d****
   */
  traceID?: string;
  static names(): { [key: string]: string } {
    return {
      children: 'Children',
      duration: 'Duration',
      haveStack: 'HaveStack',
      logEventList: 'LogEventList',
      operationName: 'OperationName',
      parentSpanId: 'ParentSpanId',
      resultCode: 'ResultCode',
      rpcId: 'RpcId',
      rpcType: 'RpcType',
      serviceIp: 'ServiceIp',
      serviceName: 'ServiceName',
      spanId: 'SpanId',
      tagEntryList: 'TagEntryList',
      timestamp: 'Timestamp',
      traceID: 'TraceID',
    };
  }

  static types(): { [key: string]: any } {
    return {
      children: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
      duration: 'number',
      haveStack: 'boolean',
      logEventList: { 'type': 'array', 'itemType': GetTraceResponseBodySpansLogEventList },
      operationName: 'string',
      parentSpanId: 'string',
      resultCode: 'string',
      rpcId: 'string',
      rpcType: 'number',
      serviceIp: 'string',
      serviceName: 'string',
      spanId: 'string',
      tagEntryList: { 'type': 'array', 'itemType': GetTraceResponseBodySpansTagEntryList },
      timestamp: 'number',
      traceID: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTraceAppRequestTags extends $tea.Model {
  /**
   * @remarks
   * 标签的键（key）。
   * 
   * @example
   * TestKey
   */
  key?: string;
  /**
   * @remarks
   * 标签的值（value）。
   * 
   * @example
   * TestValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTraceAppResponseBodyTraceAppTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * TestKey
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * TestValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTraceAppResponseBodyTraceApp extends $tea.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * 123
   */
  appId?: number;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * arms-k8s-demo
   */
  appName?: string;
  /**
   * @remarks
   * Cluster ID, used only in K8s scenarios.
   * 
   * @example
   * c905d1364c2dd4b6284a3f41790c4****
   */
  clusterId?: string;
  /**
   * @remarks
   * The timestamp generated when the task was created.
   * 
   * @example
   * 1576599253000
   */
  createTime?: number;
  /**
   * @remarks
   * The aliases of the application.
   */
  labels?: string[];
  /**
   * @remarks
   * Coding Language.
   * 
   * @example
   * java
   */
  language?: string;
  /**
   * @remarks
   * The process identifier (PID) of the application.
   * 
   * @example
   * b590lhguqs@d8deedfa9bf****
   */
  pid?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * Indicates whether the application is displayed in the Application Real-Time Monitoring Service (ARMS) console. Valid values:
   * 
   * *   `true`: yes
   * *   `false`: no
   * 
   * @example
   * true
   */
  show?: boolean;
  /**
   * @remarks
   * The source of the application.
   * 
   * @example
   * ACSK8S
   */
  source?: string;
  /**
   * @remarks
   * A list of key-value pairs.
   */
  tags?: GetTraceAppResponseBodyTraceAppTags[];
  /**
   * @remarks
   * The type of the monitoring task. Valid values:
   * 
   * *   `TRACE`: Application Monitoring
   * *   `RETCODE`: Browser Monitoring
   * 
   * @example
   * TRACE
   */
  type?: string;
  /**
   * @remarks
   * The timestamp generated when the task information was updated.
   * 
   * @example
   * 1635700348000
   */
  updateTime?: number;
  /**
   * @remarks
   * The user ID.
   * 
   * @example
   * 113197164949****
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      clusterId: 'ClusterId',
      createTime: 'CreateTime',
      labels: 'Labels',
      language: 'Language',
      pid: 'Pid',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      show: 'Show',
      source: 'Source',
      tags: 'Tags',
      type: 'Type',
      updateTime: 'UpdateTime',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'number',
      appName: 'string',
      clusterId: 'string',
      createTime: 'number',
      labels: { 'type': 'array', 'itemType': 'string' },
      language: 'string',
      pid: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      show: 'boolean',
      source: 'string',
      tags: { 'type': 'array', 'itemType': GetTraceAppResponseBodyTraceAppTags },
      type: 'string',
      updateTime: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportAppAlertRulesRequestTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * type
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * prod
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallAddonResponseBodyDataConditions extends $tea.Model {
  /**
   * @remarks
   * The first transition time.
   * 
   * @example
   * 2018-01-31T14:32:19Z
   */
  firstTransitionTime?: string;
  /**
   * @remarks
   * The last transition time.
   * 
   * @example
   * 2018-01-31T14:32:19Z
   */
  lastTransitionTime?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * xxxx
   */
  message?: string;
  /**
   * @remarks
   * The reason for the failure.
   * 
   * @example
   * xxxx
   */
  reason?: string;
  /**
   * @remarks
   * The status of the phase.
   * 
   * @example
   * True
   */
  status?: string;
  /**
   * @remarks
   * The type of the phase.
   * 
   * @example
   * Loaded
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      firstTransitionTime: 'FirstTransitionTime',
      lastTransitionTime: 'LastTransitionTime',
      message: 'Message',
      reason: 'Reason',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firstTransitionTime: 'string',
      lastTransitionTime: 'string',
      message: 'string',
      reason: 'string',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallAddonResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The name of the add-on.
   * 
   * @example
   * mysql
   */
  addonName?: string;
  /**
   * @remarks
   * The number of alert rules.
   * 
   * @example
   * 1
   */
  alertRuleCount?: number;
  /**
   * @remarks
   * The installation phase.
   */
  conditions?: InstallAddonResponseBodyDataConditions[];
  /**
   * @remarks
   * The time when the add-on was created.
   * 
   * @example
   * 2023-09-22T16:56:29+08:00
   */
  createTime?: string;
  /**
   * @remarks
   * The number of dashboards.
   * 
   * @example
   * 1
   */
  dashboardCount?: number;
  /**
   * @remarks
   * The environment ID.
   * 
   * @example
   * env-xxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The number of exporters.
   * 
   * @example
   * 2
   */
  exporterCount?: number;
  /**
   * @remarks
   * Indicates whether the configuration is available.
   * 
   * @example
   * true
   */
  haveConfig?: boolean;
  /**
   * @remarks
   * The user ID.
   * 
   * @example
   * 123456
   */
  installUserId?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * zh
   */
  language?: string;
  /**
   * @remarks
   * Indicates whether the component is fully managed.
   * 
   * @example
   * true
   */
  managed?: boolean;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-heyuan
   */
  regionId?: string;
  /**
   * @remarks
   * The release ID after installation.
   * 
   * @example
   * be29c093-3fd6-4fb6-9430-797030cc183a
   */
  releaseId?: string;
  /**
   * @remarks
   * The name of the release.
   * 
   * @example
   * mysql-1695372983039
   */
  releaseName?: string;
  /**
   * @remarks
   * The scenario.
   * 
   * @example
   * database
   */
  scene?: string;
  /**
   * @remarks
   * The status.
   * 
   * @example
   * 0
   */
  status?: string;
  /**
   * @remarks
   * The time when the add-on was updated.
   * 
   * @example
   * 2023-09-22T16:56:29+08:00
   */
  updateTime?: string;
  /**
   * @remarks
   * The user ID.
   * 
   * @example
   * 111
   */
  userId?: string;
  /**
   * @remarks
   * The version of the add-on.
   * 
   * @example
   * 0.0.1
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      addonName: 'AddonName',
      alertRuleCount: 'AlertRuleCount',
      conditions: 'Conditions',
      createTime: 'CreateTime',
      dashboardCount: 'DashboardCount',
      environmentId: 'EnvironmentId',
      exporterCount: 'ExporterCount',
      haveConfig: 'HaveConfig',
      installUserId: 'InstallUserId',
      language: 'Language',
      managed: 'Managed',
      regionId: 'RegionId',
      releaseId: 'ReleaseId',
      releaseName: 'ReleaseName',
      scene: 'Scene',
      status: 'Status',
      updateTime: 'UpdateTime',
      userId: 'UserId',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addonName: 'string',
      alertRuleCount: 'number',
      conditions: { 'type': 'array', 'itemType': InstallAddonResponseBodyDataConditions },
      createTime: 'string',
      dashboardCount: 'number',
      environmentId: 'string',
      exporterCount: 'number',
      haveConfig: 'boolean',
      installUserId: 'string',
      language: 'string',
      managed: 'boolean',
      regionId: 'string',
      releaseId: 'string',
      releaseName: 'string',
      scene: 'string',
      status: 'string',
      updateTime: 'string',
      userId: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListActivatedAlertsResponseBodyPageAlertsDispatchRules extends $tea.Model {
  /**
   * @remarks
   * The ID of the notification policy.
   * 
   * @example
   * 7021
   */
  ruleId?: number;
  /**
   * @remarks
   * The name of the notification policy.
   * 
   * @example
   * NotificationPolicy1
   */
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      ruleId: 'RuleId',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleId: 'number',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListActivatedAlertsResponseBodyPageAlerts extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * @example
   * 3888704
   */
  alertId?: string;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * @example
   * Container CPU usage is greater than 80%
   */
  alertName?: string;
  /**
   * @remarks
   * The type of the alert.
   * 
   * @example
   * PROMETHEUS_MONITORING_ALERT_RULE
   */
  alertType?: string;
  /**
   * @remarks
   * The number of times that the alert event was received.
   * 
   * @example
   * 598
   */
  count?: number;
  /**
   * @remarks
   * The timestamp when the alert rule was created.
   * 
   * @example
   * 1616466300000
   */
  createTime?: number;
  /**
   * @remarks
   * The notification policies.
   */
  dispatchRules?: ListActivatedAlertsResponseBodyPageAlertsDispatchRules[];
  /**
   * @remarks
   * The timestamp when the alert was ended.
   * 
   * @example
   * 1616502540000
   */
  endsAt?: number;
  /**
   * @remarks
   * The extended fields that indicate the following tags:
   * 
   * *   The tags that are carried in the metrics of the alert rule expression.
   * *   The tags that are created based on the alert rule.
   * *   The default tags of Application Real-Time Monitoring Service (ARMS).
   */
  expandFields?: { [key: string]: any };
  /**
   * @remarks
   * The name of the object that is associated with the alert.
   * 
   * @example
   * testphp2
   */
  integrationName?: string;
  /**
   * @remarks
   * The type of the service integration that generated the alert.
   * 
   * @example
   * PROMETHEUS
   */
  integrationType?: string;
  /**
   * @remarks
   * The type of the object that is associated with the alert.
   * 
   * @example
   * cluster
   */
  involvedObjectKind?: string;
  /**
   * @remarks
   * The name of the service integration that generated the alert.
   * 
   * @example
   * Test integration-prometheus
   */
  involvedObjectName?: string;
  /**
   * @remarks
   * The description of the alert.
   * 
   * @example
   * Alarm name: PodRestart_testphp2,\\n Pod night-test-group-1-1-5f5d6f4d84-pszns is restart, Value: 133.33%, 1.33%
   */
  message?: string;
  /**
   * @remarks
   * The level of the alert. Valid values:
   * 
   * *   `critical`
   * *   `error`
   * *   `warn`
   * *   `page`
   * 
   * @example
   * critical
   */
  severity?: string;
  /**
   * @remarks
   * The timestamp when the alert was generated.
   * 
   * @example
   * 1616466300000
   */
  startsAt?: number;
  /**
   * @remarks
   * The status of the alert. Valid values:
   * 
   * *   `Active`
   * *   `Inhibited`
   * *   `Silenced`
   * *   `Resolved`
   * 
   * @example
   * Active
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      alertId: 'AlertId',
      alertName: 'AlertName',
      alertType: 'AlertType',
      count: 'Count',
      createTime: 'CreateTime',
      dispatchRules: 'DispatchRules',
      endsAt: 'EndsAt',
      expandFields: 'ExpandFields',
      integrationName: 'IntegrationName',
      integrationType: 'IntegrationType',
      involvedObjectKind: 'InvolvedObjectKind',
      involvedObjectName: 'InvolvedObjectName',
      message: 'Message',
      severity: 'Severity',
      startsAt: 'StartsAt',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertId: 'string',
      alertName: 'string',
      alertType: 'string',
      count: 'number',
      createTime: 'number',
      dispatchRules: { 'type': 'array', 'itemType': ListActivatedAlertsResponseBodyPageAlertsDispatchRules },
      endsAt: 'number',
      expandFields: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      integrationName: 'string',
      integrationType: 'string',
      involvedObjectKind: 'string',
      involvedObjectName: 'string',
      message: 'string',
      severity: 'string',
      startsAt: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListActivatedAlertsResponseBodyPage extends $tea.Model {
  /**
   * @remarks
   * The alerts that have been triggered.
   */
  alerts?: ListActivatedAlertsResponseBodyPageAlerts[];
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 5
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      alerts: 'Alerts',
      page: 'Page',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alerts: { 'type': 'array', 'itemType': ListActivatedAlertsResponseBodyPageAlerts },
      page: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAddonReleasesResponseBodyDataReleasesConditions extends $tea.Model {
  /**
   * @remarks
   * The first transition time.
   * 
   * @example
   * 2018-01-31T14:32:19Z
   */
  firstTransitionTime?: string;
  /**
   * @remarks
   * The last transition time.
   * 
   * @example
   * 2018-01-31T14:32:19Z
   */
  lastTransitionTime?: string;
  /**
   * @remarks
   * The detailed information.
   * 
   * @example
   * xxxx
   */
  message?: string;
  /**
   * @remarks
   * The reason for the failure.
   * 
   * @example
   * xxxx
   */
  reason?: string;
  /**
   * @remarks
   * The status of the phase.
   * 
   * @example
   * True
   */
  status?: string;
  /**
   * @remarks
   * The type of the phase.
   * 
   * @example
   * Loaded
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      firstTransitionTime: 'FirstTransitionTime',
      lastTransitionTime: 'LastTransitionTime',
      message: 'Message',
      reason: 'Reason',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firstTransitionTime: 'string',
      lastTransitionTime: 'string',
      message: 'string',
      reason: 'string',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAddonReleasesResponseBodyDataReleases extends $tea.Model {
  /**
   * @remarks
   * The name of the add-on.
   * 
   * @example
   * mysql
   */
  addonName?: string;
  /**
   * @remarks
   * The number of alert rules.
   * 
   * @example
   * 1
   */
  alertRuleCount?: number;
  /**
   * @remarks
   * The installation phase.
   */
  conditions?: ListAddonReleasesResponseBodyDataReleasesConditions[];
  /**
   * @remarks
   * The time when the add-on was created.
   * 
   * @example
   * 2023-09-22T16:56:29+08:00
   */
  createTime?: string;
  /**
   * @remarks
   * The number of dashboards.
   * 
   * @example
   * 1
   */
  dashboardCount?: number;
  /**
   * @remarks
   * The environment ID.
   * 
   * @example
   * env-xxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The number of exporters.
   * 
   * @example
   * 2
   */
  exporterCount?: number;
  /**
   * @remarks
   * Indicates whether the configuration is available.
   * 
   * @example
   * true
   */
  haveConfig?: boolean;
  /**
   * @remarks
   * The user ID.
   * 
   * @example
   * 1268790592387
   */
  installUserId?: string;
  /**
   * @remarks
   * The language.
   * 
   * @example
   * zh
   */
  language?: string;
  managed?: boolean;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-heyuan
   */
  regionId?: string;
  /**
   * @remarks
   * The release ID after installation.
   * 
   * @example
   * be29c093-3fd6-4fb6-9430-797030cc183a
   */
  releaseId?: string;
  /**
   * @remarks
   * The name of the release.
   * 
   * @example
   * mysql-1695372983039
   */
  releaseName?: string;
  /**
   * @remarks
   * The scenario.
   * 
   * @example
   * database
   */
  scene?: string;
  /**
   * @remarks
   * The status.
   * 
   * @example
   * 0
   */
  status?: string;
  /**
   * @remarks
   * The time when the add-on was updated.
   * 
   * @example
   * 2023-09-22T16:56:29+08:00
   */
  updateTime?: string;
  /**
   * @remarks
   * The user ID.
   * 
   * @example
   * 111
   */
  userId?: string;
  /**
   * @remarks
   * The version of the add-on.
   * 
   * @example
   * 0.0.1
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      addonName: 'AddonName',
      alertRuleCount: 'AlertRuleCount',
      conditions: 'Conditions',
      createTime: 'CreateTime',
      dashboardCount: 'DashboardCount',
      environmentId: 'EnvironmentId',
      exporterCount: 'ExporterCount',
      haveConfig: 'HaveConfig',
      installUserId: 'InstallUserId',
      language: 'Language',
      managed: 'Managed',
      regionId: 'RegionId',
      releaseId: 'ReleaseId',
      releaseName: 'ReleaseName',
      scene: 'Scene',
      status: 'Status',
      updateTime: 'UpdateTime',
      userId: 'UserId',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addonName: 'string',
      alertRuleCount: 'number',
      conditions: { 'type': 'array', 'itemType': ListAddonReleasesResponseBodyDataReleasesConditions },
      createTime: 'string',
      dashboardCount: 'number',
      environmentId: 'string',
      exporterCount: 'number',
      haveConfig: 'boolean',
      installUserId: 'string',
      language: 'string',
      managed: 'boolean',
      regionId: 'string',
      releaseId: 'string',
      releaseName: 'string',
      scene: 'string',
      status: 'string',
      updateTime: 'string',
      userId: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAddonReleasesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The queried add-ons.
   */
  releases?: ListAddonReleasesResponseBodyDataReleases[];
  /**
   * @remarks
   * The total number of entries.
   * 
   * @example
   * 12
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      releases: 'Releases',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      releases: { 'type': 'array', 'itemType': ListAddonReleasesResponseBodyDataReleases },
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAddonsResponseBodyDataDashboards extends $tea.Model {
  /**
   * @remarks
   * The description of the dashboard.
   * 
   * @example
   * MySQL monitors the market information, monitoring the connection information, usage information and other indicators
   */
  description?: string;
  /**
   * @remarks
   * The name of the dashboard.
   * 
   * @example
   * mysql-overview
   */
  name?: string;
  /**
   * @remarks
   * The URL of the dashboard.
   * 
   * @example
   * http://xxxx
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAddonsResponseBodyDataEnvironmentsDependencies extends $tea.Model {
  /**
   * @remarks
   * The supported cluster types.
   */
  clusterTypes?: string[];
  /**
   * @remarks
   * The feature on which the environment depends.
   */
  features?: { [key: string]: boolean };
  /**
   * @remarks
   * The services.
   */
  services?: string[];
  static names(): { [key: string]: string } {
    return {
      clusterTypes: 'ClusterTypes',
      features: 'Features',
      services: 'Services',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterTypes: { 'type': 'array', 'itemType': 'string' },
      features: { 'type': 'map', 'keyType': 'string', 'valueType': 'boolean' },
      services: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAddonsResponseBodyDataEnvironmentsPoliciesMetricCheckRule extends $tea.Model {
  /**
   * @remarks
   * The PromQL statements.
   */
  promQL?: string[];
  static names(): { [key: string]: string } {
    return {
      promQL: 'PromQL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      promQL: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAddonsResponseBodyDataEnvironmentsPoliciesProtocols extends $tea.Model {
  /**
   * @remarks
   * The description of the protocol.
   * 
   * @example
   * ARMS
   */
  description?: string;
  /**
   * @remarks
   * The URL of the protocol icon.
   * 
   * @example
   * http://xxxxxxx
   */
  icon?: string;
  /**
   * @remarks
   * The tag of the protocol.
   * 
   * @example
   * ARMS
   */
  label?: string;
  /**
   * @remarks
   * The name of the protocol.
   * 
   * @example
   * arms
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      icon: 'Icon',
      label: 'Label',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      icon: 'string',
      label: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAddonsResponseBodyDataEnvironmentsPolicies extends $tea.Model {
  /**
   * @remarks
   * The default alert status.
   * 
   * @example
   * default
   */
  alertDefaultStatus?: string;
  /**
   * @remarks
   * The default installation status.
   * 
   * @example
   * false
   */
  defaultInstall?: boolean;
  /**
   * @remarks
   * Indicates whether a service account is enabled.
   * 
   * @example
   * false.
   */
  enableServiceAccount?: boolean;
  /**
   * @remarks
   * The metric check rule.
   */
  metricCheckRule?: ListAddonsResponseBodyDataEnvironmentsPoliciesMetricCheckRule;
  /**
   * @remarks
   * Indicates whether a restart is required after the installation.
   * 
   * @example
   * false
   */
  needRestartAfterIntegration?: boolean;
  /**
   * @remarks
   * The supported protocols.
   */
  protocols?: ListAddonsResponseBodyDataEnvironmentsPoliciesProtocols[];
  /**
   * @remarks
   * The target name of the add-on.
   * 
   * @example
   * cloud-rds-mysql
   */
  targetAddonName?: string;
  static names(): { [key: string]: string } {
    return {
      alertDefaultStatus: 'AlertDefaultStatus',
      defaultInstall: 'DefaultInstall',
      enableServiceAccount: 'EnableServiceAccount',
      metricCheckRule: 'MetricCheckRule',
      needRestartAfterIntegration: 'NeedRestartAfterIntegration',
      protocols: 'Protocols',
      targetAddonName: 'TargetAddonName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertDefaultStatus: 'string',
      defaultInstall: 'boolean',
      enableServiceAccount: 'boolean',
      metricCheckRule: ListAddonsResponseBodyDataEnvironmentsPoliciesMetricCheckRule,
      needRestartAfterIntegration: 'boolean',
      protocols: { 'type': 'array', 'itemType': ListAddonsResponseBodyDataEnvironmentsPoliciesProtocols },
      targetAddonName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAddonsResponseBodyDataEnvironments extends $tea.Model {
  /**
   * @remarks
   * The dependencies of the environment.
   */
  dependencies?: ListAddonsResponseBodyDataEnvironmentsDependencies;
  /**
   * @remarks
   * The description of the environment.
   * 
   * @example
   * The MySQL service is deployed in a Kubernetes cluster.
   */
  description?: string;
  /**
   * @remarks
   * Indicates whether the feature is enabled.
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The tag of the environment.
   * 
   * @example
   * Container
   */
  label?: string;
  /**
   * @remarks
   * The name of the environment.
   * 
   * @example
   * CS
   */
  name?: string;
  /**
   * @remarks
   * The control policies in the environment.
   */
  policies?: ListAddonsResponseBodyDataEnvironmentsPolicies;
  static names(): { [key: string]: string } {
    return {
      dependencies: 'Dependencies',
      description: 'Description',
      enable: 'Enable',
      label: 'Label',
      name: 'Name',
      policies: 'Policies',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dependencies: ListAddonsResponseBodyDataEnvironmentsDependencies,
      description: 'string',
      enable: 'boolean',
      label: 'string',
      name: 'string',
      policies: ListAddonsResponseBodyDataEnvironmentsPolicies,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAddonsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The alias of the add-on.
   * 
   * @example
   * MySQL
   */
  alias?: string;
  /**
   * @remarks
   * The tags of the add-on.
   */
  categories?: string[];
  /**
   * @remarks
   * The dashboards.
   */
  dashboards?: ListAddonsResponseBodyDataDashboards[];
  /**
   * @remarks
   * The description of the add-on.
   * 
   * @example
   * Monitor database indicators with MySQL Exporter
   */
  description?: string;
  /**
   * @remarks
   * The supported environments.
   */
  environments?: ListAddonsResponseBodyDataEnvironments[];
  /**
   * @remarks
   * The URL of the icon.
   * 
   * @example
   * http://xxxx
   */
  icon?: string;
  /**
   * @remarks
   * The collection of keywords.
   */
  keywords?: string[];
  /**
   * @remarks
   * The language.
   * 
   * @example
   * zh
   */
  language?: string;
  /**
   * @remarks
   * The time when the instance was last created.
   * 
   * @example
   * 2023-09-22T16:56:29+08:00
   */
  latestReleaseCreateTime?: string;
  /**
   * @remarks
   * The name of the add-on.
   * 
   * @example
   * mysql
   */
  name?: string;
  /**
   * @remarks
   * Indicates whether the add-on can be installed only once.
   * 
   * @example
   * false
   */
  once?: boolean;
  /**
   * @remarks
   * The scenario.
   * 
   * @example
   * database
   */
  scene?: string;
  /**
   * @remarks
   * The version of the agent.
   * 
   * @example
   * 0.0.1
   */
  version?: string;
  /**
   * @remarks
   * The weight.
   * 
   * @example
   * 857
   */
  weight?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      categories: 'Categories',
      dashboards: 'Dashboards',
      description: 'Description',
      environments: 'Environments',
      icon: 'Icon',
      keywords: 'Keywords',
      language: 'Language',
      latestReleaseCreateTime: 'LatestReleaseCreateTime',
      name: 'Name',
      once: 'Once',
      scene: 'Scene',
      version: 'Version',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      categories: { 'type': 'array', 'itemType': 'string' },
      dashboards: { 'type': 'array', 'itemType': ListAddonsResponseBodyDataDashboards },
      description: 'string',
      environments: { 'type': 'array', 'itemType': ListAddonsResponseBodyDataEnvironments },
      icon: 'string',
      keywords: { 'type': 'array', 'itemType': 'string' },
      language: 'string',
      latestReleaseCreateTime: 'string',
      name: 'string',
      once: 'boolean',
      scene: 'string',
      version: 'string',
      weight: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAlertEventsResponseBodyPageBeanEventsAlarms extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert.
   * 
   * @example
   * 77444
   */
  alarmId?: number;
  /**
   * @remarks
   * The name of the alert.
   * 
   * @example
   * Test-triggered alert
   */
  alarmName?: string;
  /**
   * @remarks
   * The time when the alert was created.
   * 
   * @example
   * 2021-12-20 07:10:18
   */
  createTime?: string;
  /**
   * @remarks
   * The status of the alert. Valid values:
   * 
   * *   0: The alert is pending.
   * *   1: The alert is being handled.
   * *   2: The alert is cleared.
   * 
   * @example
   * 0
   */
  state?: number;
  static names(): { [key: string]: string } {
    return {
      alarmId: 'AlarmId',
      alarmName: 'AlarmName',
      createTime: 'CreateTime',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmId: 'number',
      alarmName: 'string',
      createTime: 'string',
      state: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAlertEventsResponseBodyPageBeanEventsNotificationPolicies extends $tea.Model {
  /**
   * @remarks
   * The ID of the notification policy.
   * 
   * @example
   * 646093
   */
  id?: number;
  /**
   * @remarks
   * The name of the notification policy.
   * 
   * @example
   * P1 alert notification policy
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAlertEventsResponseBodyPageBeanEvents extends $tea.Model {
  /**
   * @remarks
   * The associated alerts.
   */
  alarms?: ListAlertEventsResponseBodyPageBeanEventsAlarms[];
  /**
   * @remarks
   * The name of the alert.
   * 
   * @example
   * Test-triggered alert
   */
  alertName?: string;
  /**
   * @remarks
   * The annotations.
   * 
   * @example
   * [{\\"Name\\":\\"annotation-a\\",\\"Value\\":\\"annotation a value\\"}]
   */
  annotations?: string;
  /**
   * @remarks
   * The description of the alert event.
   * 
   * @example
   * Test
   */
  description?: string;
  /**
   * @remarks
   * The end time.
   * 
   * @example
   * 2021-12-20 17:42:16
   */
  endTime?: string;
  /**
   * @remarks
   * The URL of the alert event.
   * 
   * @example
   * https://xxx.xx/
   */
  generatorURL?: string;
  /**
   * @remarks
   * The user who handled the alert.
   * 
   * @example
   * Tom
   */
  handlerName?: string;
  /**
   * @remarks
   * The name of the alert integration.
   * 
   * @example
   * Custom integration
   */
  integrationName?: string;
  /**
   * @remarks
   * The type of the alert integration.
   * 
   * @example
   * CUSTOM
   */
  integrationType?: string;
  /**
   * @remarks
   * The tags.
   * 
   * @example
   * [{\\"name\\":\\"severity\\",\\"value\\":\\"error\\"}]
   */
  labels?: string;
  /**
   * @remarks
   * The associated notification policies.
   */
  notificationPolicies?: ListAlertEventsResponseBodyPageBeanEventsNotificationPolicies[];
  /**
   * @remarks
   * The time when the alert event was received.
   * 
   * @example
   * 2021-12-20 17:42:16
   */
  receiveTime?: string;
  /**
   * @remarks
   * The severity level of the alert. Valid values:
   * 
   * *   critical: P1
   * *   error: P2
   * *   warning: P3
   * *   page: P4
   * *   default: P6
   * 
   * @example
   * critical
   */
  severity?: string;
  /**
   * @remarks
   * The start time.
   * 
   * @example
   * 2021-12-20 17:42:16
   */
  startTime?: string;
  /**
   * @remarks
   * The status of the alert event. Valid values:
   * 
   * *   Active
   * *   Silenced
   * *   Resolved
   * 
   * @example
   * Active
   */
  status?: string;
  /**
   * @remarks
   * The number of times the event is triggered.
   * 
   * @example
   * 10
   */
  triggerCount?: number;
  static names(): { [key: string]: string } {
    return {
      alarms: 'Alarms',
      alertName: 'AlertName',
      annotations: 'Annotations',
      description: 'Description',
      endTime: 'EndTime',
      generatorURL: 'GeneratorURL',
      handlerName: 'HandlerName',
      integrationName: 'IntegrationName',
      integrationType: 'IntegrationType',
      labels: 'Labels',
      notificationPolicies: 'NotificationPolicies',
      receiveTime: 'ReceiveTime',
      severity: 'Severity',
      startTime: 'StartTime',
      status: 'Status',
      triggerCount: 'TriggerCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarms: { 'type': 'array', 'itemType': ListAlertEventsResponseBodyPageBeanEventsAlarms },
      alertName: 'string',
      annotations: 'string',
      description: 'string',
      endTime: 'string',
      generatorURL: 'string',
      handlerName: 'string',
      integrationName: 'string',
      integrationType: 'string',
      labels: 'string',
      notificationPolicies: { 'type': 'array', 'itemType': ListAlertEventsResponseBodyPageBeanEventsNotificationPolicies },
      receiveTime: 'string',
      severity: 'string',
      startTime: 'string',
      status: 'string',
      triggerCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAlertEventsResponseBodyPageBean extends $tea.Model {
  /**
   * @remarks
   * The queried historical alert events.
   */
  events?: ListAlertEventsResponseBodyPageBeanEvents[];
  /**
   * @remarks
   * The number of the page returned.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 20
   */
  size?: number;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 24
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      events: 'Events',
      page: 'Page',
      size: 'Size',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      events: { 'type': 'array', 'itemType': ListAlertEventsResponseBodyPageBeanEvents },
      page: 'number',
      size: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAlertsResponseBodyPageBeanListAlertsActivities extends $tea.Model {
  /**
   * @remarks
   * The content of the alert notification.
   * 
   * @example
   * [Notification policy: Send notifications to DingTalk groups] Host monitoring. Host IP address: 10.76.XX.XX. Average memory usage of the host in the last 1 minute ≥ 1.0%. Current value: 84.7454%.
   */
  content?: string;
  /**
   * @remarks
   * The description of the activity.
   * 
   * @example
   * [Alert Claimed] The alert is claimed
   */
  description?: string;
  /**
   * @remarks
   * The name of the handler.
   * 
   * @example
   * O\\&M Engineer A
   */
  handlerName?: string;
  /**
   * @remarks
   * The operation time of the activity.
   * 
   * @example
   * 2021-12-20 19:08:57
   */
  time?: string;
  /**
   * @remarks
   * The type of the activity. Valid values:
   * 
   * *   1: The alert is claimed.
   * *   2: The alert is disclaimed.
   * *   3: A comment is added for the alert.
   * *   4: The alert is disabled.
   * *   5: An alert notification is sent.
   * 
   * @example
   * 1
   */
  type?: number;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      description: 'Description',
      handlerName: 'HandlerName',
      time: 'Time',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      description: 'string',
      handlerName: 'string',
      time: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAlertsResponseBodyPageBeanListAlertsAlertEvents extends $tea.Model {
  /**
   * @remarks
   * The name of the event.
   * 
   * @example
   * Test-triggered alert
   */
  alertName?: string;
  /**
   * @remarks
   * The annotations.
   * 
   * @example
   * { "_aliyun_arms_alert_value":"4.0" "_aliyun_arms_alert_traceId":"ac10c43116421327442277073d5461-105075299"}
   */
  annotations?: string;
  /**
   * @remarks
   * The description of the event.
   * 
   * @example
   * Host monitoring. Host IP address: 10.76.XX.XX. Average memory usage of the host in the last 1 minute ≥ 1.0%. Current value: 84.7454%.
   */
  description?: string;
  /**
   * @remarks
   * The time when the event ended.
   * 
   * @example
   * 2022-01-19 17:10:31
   */
  endTime?: string;
  /**
   * @remarks
   * The URL of the event.
   * 
   * @example
   * http://arms.console.aliyun.com
   */
  generatorURL?: string;
  /**
   * @remarks
   * The name of the integration that corresponds to the alert event.
   * 
   * @example
   * ARMS
   */
  integrationName?: string;
  /**
   * @remarks
   * The type of the integration that corresponds to the alert event. Valid values:
   * 
   * *   ARMS
   * *   CLOUD_MONITOR
   * *   MSE
   * *   ARMS_CLOUD_DIALTEST
   * *   PROMETHEUS
   * *   LOG_SERVICE
   * *   CUSTOM
   * *   ARMS_PROMETHEUS
   * *   ARMS_APP_MON
   * *   ARMS_FRONT_MON
   * *   ARMS_CUSTOM
   * *   XTRACE
   * *   GRAFANA
   * *   ZABBIX
   * *   SKYWALKING
   * *   EVENT_BRIDGE
   * *   NAGIOS
   * *   OPENFALCON
   * *   ARMS_INSIGHTS
   * 
   * @example
   * ARMS_APP_MON
   */
  integrationType?: string;
  /**
   * @remarks
   * The tags.
   * 
   * @example
   * { "severity":"warning" "_aliyun_arms_alert_level":"ERROR" "_aliyun_arms_entropy":"0.30170457417889235"}
   */
  labels?: string;
  /**
   * @remarks
   * The time when the event was created.
   * 
   * @example
   * 2022-01-19 17:05:42
   */
  receiveTime?: string;
  /**
   * @remarks
   * The severity level of the event. Valid values:
   * 
   * *   critical
   * *   error
   * *   warning
   * *   info
   * 
   * @example
   * warning
   */
  severity?: string;
  /**
   * @remarks
   * The time when the event started.
   * 
   * @example
   * 2022-01-18 00:14:00
   */
  startTime?: string;
  /**
   * @remarks
   * The status of the event. Valid values:
   * 
   * *   Active: The event is not cleared.
   * *   Silenced: The event is silenced.
   * *   Resolved: The event is cleared.
   * 
   * @example
   * Active
   */
  state?: string;
  static names(): { [key: string]: string } {
    return {
      alertName: 'AlertName',
      annotations: 'Annotations',
      description: 'Description',
      endTime: 'EndTime',
      generatorURL: 'GeneratorURL',
      integrationName: 'IntegrationName',
      integrationType: 'IntegrationType',
      labels: 'Labels',
      receiveTime: 'ReceiveTime',
      severity: 'Severity',
      startTime: 'StartTime',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertName: 'string',
      annotations: 'string',
      description: 'string',
      endTime: 'string',
      generatorURL: 'string',
      integrationName: 'string',
      integrationType: 'string',
      labels: 'string',
      receiveTime: 'string',
      severity: 'string',
      startTime: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAlertsResponseBodyPageBeanListAlerts extends $tea.Model {
  acknowledgeTime?: number;
  /**
   * @remarks
   * The list of activities.
   */
  activities?: ListAlertsResponseBodyPageBeanListAlertsActivities[];
  /**
   * @remarks
   * The list of events.
   */
  alertEvents?: ListAlertsResponseBodyPageBeanListAlertsAlertEvents[];
  /**
   * @remarks
   * The alert ID.
   * 
   * @example
   * 2279
   */
  alertId?: number;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * @example
   * Test alert
   */
  alertName?: string;
  /**
   * @remarks
   * The time when the alert was created.
   * 
   * @example
   * 2022-01-18 00:21:35
   */
  createTime?: string;
  describe?: string;
  /**
   * @remarks
   * The ID of the notification policy.
   * 
   * @example
   * 12345
   */
  dispatchRuleId?: number;
  /**
   * @remarks
   * The name of the notification policy.
   * 
   * @example
   * DingTalk Notification
   */
  dispatchRuleName?: string;
  handler?: string;
  notifyRobots?: string;
  owner?: string;
  recoverTime?: number;
  /**
   * @remarks
   * The severity level of the alert. Valid values: P6, P5, P4, P3, P2, and P1. The preceding values are listed in ascending order of severity.
   * 
   * @example
   * P6
   */
  severity?: string;
  /**
   * @remarks
   * The Alert solution.
   * 
   * @example
   * --
   */
  solution?: string;
  /**
   * @remarks
   * The status of the alert. Valid values:
   * 
   * *   0: The alert is pending.
   * *   1: The alert is being handled.
   * *   2: The alert is handled.
   * 
   * @example
   * 0
   */
  state?: number;
  static names(): { [key: string]: string } {
    return {
      acknowledgeTime: 'AcknowledgeTime',
      activities: 'Activities',
      alertEvents: 'AlertEvents',
      alertId: 'AlertId',
      alertName: 'AlertName',
      createTime: 'CreateTime',
      describe: 'Describe',
      dispatchRuleId: 'DispatchRuleId',
      dispatchRuleName: 'DispatchRuleName',
      handler: 'Handler',
      notifyRobots: 'NotifyRobots',
      owner: 'Owner',
      recoverTime: 'RecoverTime',
      severity: 'Severity',
      solution: 'Solution',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acknowledgeTime: 'number',
      activities: { 'type': 'array', 'itemType': ListAlertsResponseBodyPageBeanListAlertsActivities },
      alertEvents: { 'type': 'array', 'itemType': ListAlertsResponseBodyPageBeanListAlertsAlertEvents },
      alertId: 'number',
      alertName: 'string',
      createTime: 'string',
      describe: 'string',
      dispatchRuleId: 'number',
      dispatchRuleName: 'string',
      handler: 'string',
      notifyRobots: 'string',
      owner: 'string',
      recoverTime: 'number',
      severity: 'string',
      solution: 'string',
      state: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAlertsResponseBodyPageBean extends $tea.Model {
  /**
   * @remarks
   * The alerts for which the alert sending history is queried.
   */
  listAlerts?: ListAlertsResponseBodyPageBeanListAlerts[];
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of alerts returned per page.
   * 
   * @example
   * 20
   */
  size?: number;
  /**
   * @remarks
   * The total number of queried alerts.
   * 
   * @example
   * 1
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      listAlerts: 'ListAlerts',
      page: 'Page',
      size: 'Size',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      listAlerts: { 'type': 'array', 'itemType': ListAlertsResponseBodyPageBeanListAlerts },
      page: 'number',
      size: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterFromGrafanaResponseBodyPromClusterList extends $tea.Model {
  /**
   * @remarks
   * The status of the Prometheus agent on the cluster. Valid values:
   * 
   * *   INSTALL_FAILED: The Prometheus agent failed to be installed.
   * *   INSTALL_SUCCEED: The Prometheus agent was installed.
   * *   NOT_REGISTER: You have not registered an Alibaba Cloud account.
   * 
   * @example
   * INSTALL_FAILED
   */
  agentStatus?: string;
  /**
   * @remarks
   * The cluster ID.
   * 
   * @example
   * c0df7ad9db0ed43128925ca04774c469e
   */
  clusterId?: string;
  /**
   * @remarks
   * The name of the cluster.
   * 
   * @example
   * ay-ads-hangzhou
   */
  clusterName?: string;
  /**
   * @remarks
   * The type of the cluster.
   * 
   * @example
   * cloud-product-prometheus
   */
  clusterType?: string;
  /**
   * @remarks
   * The controller ID.
   * 
   * @example
   * 1092
   */
  controllerId?: string;
  /**
   * @remarks
   * The time when the dashboard was created.
   * 
   * @example
   * 2021-12-09T02:05:04Z
   */
  createTime?: number;
  /**
   * @remarks
   * The extended fields. This parameter is a JSON string.
   * 
   * @example
   * {\\"app_id\\":\\"bbd\\",\\"task_id\\":\\"4305ba5bf14942daa6e553ed91f46988\\"}
   */
  extra?: string;
  /**
   * @remarks
   * The ID of a database in the cluster.
   * 
   * @example
   * 16136
   */
  id?: number;
  /**
   * @remarks
   * The timestamp when the Prometheus agent was installed.
   * 
   * @example
   * 1653532518000
   */
  installTime?: number;
  /**
   * @remarks
   * Indicates whether the Prometheus agent was installed. Valid values:
   * 
   * *   true: The Prometheus agent was installed.
   * *   false: The Prometheus agent was not installed.
   * 
   * @example
   * true
   */
  isControllerInstalled?: boolean;
  /**
   * @remarks
   * The time when the last heartbeat was reported.
   * 
   * @example
   * 1653532518000
   */
  lastHeartBeatTime?: number;
  /**
   * @remarks
   * The number of nodes.
   * 
   * @example
   * 3
   */
  nodeNum?: number;
  /**
   * @remarks
   * The custom parameter.
   * 
   * @example
   * {\\"Option\\": [\\"betaTestApproved\\"]}
   */
  options?: string;
  /**
   * @remarks
   * The list of nodejsonar logs.
   * 
   * @example
   * {}
   */
  pluginsJsonArray?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-beijing
   */
  regionId?: string;
  /**
   * @remarks
   * The information about applications deployed in the cluster.
   * 
   * @example
   * {}
   */
  stateJson?: string;
  /**
   * @remarks
   * The time when the dashboard was updated.
   * 
   * @example
   * 2021-11-16T08:49:34Z
   */
  updateTime?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account to which the cluster belongs.
   * 
   * @example
   * 1247285**
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      agentStatus: 'AgentStatus',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      clusterType: 'ClusterType',
      controllerId: 'ControllerId',
      createTime: 'CreateTime',
      extra: 'Extra',
      id: 'Id',
      installTime: 'InstallTime',
      isControllerInstalled: 'IsControllerInstalled',
      lastHeartBeatTime: 'LastHeartBeatTime',
      nodeNum: 'NodeNum',
      options: 'Options',
      pluginsJsonArray: 'PluginsJsonArray',
      regionId: 'RegionId',
      stateJson: 'StateJson',
      updateTime: 'UpdateTime',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      agentStatus: 'string',
      clusterId: 'string',
      clusterName: 'string',
      clusterType: 'string',
      controllerId: 'string',
      createTime: 'number',
      extra: 'string',
      id: 'number',
      installTime: 'number',
      isControllerInstalled: 'boolean',
      lastHeartBeatTime: 'number',
      nodeNum: 'number',
      options: 'string',
      pluginsJsonArray: 'string',
      regionId: 'string',
      stateJson: 'string',
      updateTime: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCmsInstancesResponseBodyDataProducts extends $tea.Model {
  /**
   * @example
   * -
   */
  descr?: string;
  /**
   * @example
   * 20210
   */
  id?: string;
  /**
   * @example
   * cloudserver
   */
  instance?: string;
  /**
   * @example
   * hologres
   */
  name?: string;
  /**
   * @example
   * face
   */
  prod?: string;
  /**
   * @example
   * arms
   */
  source?: string;
  /**
   * @example
   * true
   */
  state?: string;
  /**
   * @example
   * 1647852021000
   */
  time?: string;
  /**
   * @example
   * HOLOGRES
   */
  type?: string;
  /**
   * @example
   * https://g.console.aliyun.com/d/1098370038733503-35894-565/cms-hologres?orgId\\u003d9\\u0026refresh\\u003d60s
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      descr: 'Descr',
      id: 'Id',
      instance: 'Instance',
      name: 'Name',
      prod: 'Prod',
      source: 'Source',
      state: 'State',
      time: 'Time',
      type: 'Type',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      descr: 'string',
      id: 'string',
      instance: 'string',
      name: 'string',
      prod: 'string',
      source: 'string',
      state: 'string',
      time: 'string',
      type: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCmsInstancesResponseBodyData extends $tea.Model {
  /**
   * @example
   * true
   */
  enableTag?: boolean;
  products?: ListCmsInstancesResponseBodyDataProducts[];
  static names(): { [key: string]: string } {
    return {
      enableTag: 'EnableTag',
      products: 'Products',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableTag: 'boolean',
      products: { 'type': 'array', 'itemType': ListCmsInstancesResponseBodyDataProducts },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDashboardsResponseBodyDashboardVosI18nChild extends $tea.Model {
  /**
   * @remarks
   * The type of the Grafana dashboard. This parameter has the same effect as the Exporter parameter whereas provides clearer implication.
   * 
   * @example
   * Node
   */
  dashboardType?: string;
  /**
   * @remarks
   * The type of the exporter access source. Valid values:
   * 
   * *   Prometheus
   * *   Node
   * *   GPU
   * *   Redis
   * *   MySQL
   * *   Kafka
   * *   NGINX V2
   * *   Nginx
   * *   ZooKeeper
   * *   MongoDB
   * *   RabbitMQ
   * *   PostgreSQL
   * *   Kubernetes
   * *   Client Library
   * *   Elasticsearch
   * *   RocketMQ
   * 
   * @example
   * Nginx
   */
  exporter?: string;
  /**
   * @remarks
   * The URL of the Grafana dashboard.
   * 
   * @example
   * http://g.console.aliyun.com/d/1131971649496228-*****-59/ApiServer?orgId=3**&refresh=60s
   */
  httpUrl?: string;
  /**
   * @remarks
   * The URL of the Grafana dashboard.
   * 
   * @example
   * http://g.console.aliyun.com/d/1131971649496228-*****-59/ApiServer?orgId=3**&refresh=60s
   */
  httpsUrl?: string;
  /**
   * @remarks
   * The ID of the Grafana dashboard. The value is unique only when you install the Grafana dashboard.
   * 
   * @example
   * 1100**
   */
  id?: string;
  /**
   * @remarks
   * Indicates whether the exporter is provided by ARMS.
   * 
   * *   `true:` The exporter is provided by ARMS.
   * *   `false:`: The exporter is not provided by ARMS.
   * 
   * @example
   * false
   */
  isArmsExporter?: boolean;
  /**
   * @remarks
   * The category of the Grafana dashboard. Valid values: BASIC, THIRD, LIMIT, and CUSTOM.
   * 
   * @example
   * BASIC
   */
  kind?: string;
  /**
   * @remarks
   * The language of the Grafana dashboard.
   * 
   * @example
   * zh
   */
  language?: string;
  /**
   * @remarks
   * The name of the Grafana dashboard. This parameter is different from the **Title** parameter as this parameter cannot be changed.
   * 
   * @example
   * k8s-node-overview
   */
  name?: string;
  /**
   * @remarks
   * Indicates whether the Grafana dashboard has a new version that is available for upgrade.
   * 
   * @example
   * false
   */
  needUpdate?: boolean;
  /**
   * @remarks
   * The tags of the Grafana dashboard.
   */
  tags?: string[];
  /**
   * @remarks
   * The time when the Grafana dashboard was created. The value is a timestamp.
   * 
   * @example
   * 1590136924
   */
  time?: string;
  /**
   * @remarks
   * The title of the Grafana dashboard.
   * 
   * @example
   * ApiServer
   */
  title?: string;
  /**
   * @remarks
   * The type of the Grafana dashboard. Valid values:
   * 
   * *   `dash-db`: a dashboard
   * *   `dash-folder`: a folder that can include a dashboard
   * 
   * @example
   * dash-db
   */
  type?: string;
  /**
   * @remarks
   * The unique identifier of the Grafana dashboard.
   * 
   * @example
   * 1131971649496228-*****-59
   */
  uid?: string;
  /**
   * @remarks
   * The complete URL of the Grafana dashboard.
   * 
   * @example
   * http://g.console.aliyun.com/d/1131971649496228-*****-59/ApiServer?orgId=3**&refresh=60s
   */
  url?: string;
  /**
   * @remarks
   * The version of the Grafana dashboard. The combination of version and name uniquely identifies a dashboard.
   * 
   * @example
   * v2
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      dashboardType: 'DashboardType',
      exporter: 'Exporter',
      httpUrl: 'HttpUrl',
      httpsUrl: 'HttpsUrl',
      id: 'Id',
      isArmsExporter: 'IsArmsExporter',
      kind: 'Kind',
      language: 'Language',
      name: 'Name',
      needUpdate: 'NeedUpdate',
      tags: 'Tags',
      time: 'Time',
      title: 'Title',
      type: 'Type',
      uid: 'Uid',
      url: 'Url',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dashboardType: 'string',
      exporter: 'string',
      httpUrl: 'string',
      httpsUrl: 'string',
      id: 'string',
      isArmsExporter: 'boolean',
      kind: 'string',
      language: 'string',
      name: 'string',
      needUpdate: 'boolean',
      tags: { 'type': 'array', 'itemType': 'string' },
      time: 'string',
      title: 'string',
      type: 'string',
      uid: 'string',
      url: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDashboardsResponseBodyDashboardVos extends $tea.Model {
  /**
   * @remarks
   * The type of the Grafana dashboard. This parameter has the same effect as the Exporter parameter whereas provides clearer implication.
   * 
   * @example
   * Node
   */
  dashboardType?: string;
  /**
   * @remarks
   * The type of the exporter access source. Valid values:
   * 
   * *   Prometheus
   * *   Node
   * *   GPU
   * *   Redis
   * *   MySQL
   * *   Kafka
   * *   NGINX V2
   * *   Nginx
   * *   ZooKeeper
   * *   MongoDB
   * *   RabbitMQ
   * *   PostgreSQL
   * *   Kubernetes
   * *   Client Library
   * *   Elasticsearch
   * *   RocketMQ
   * 
   * @example
   * Nginx
   */
  exporter?: string;
  /**
   * @remarks
   * The URL of the Grafana dashboard.
   * 
   * @example
   * http://g.console.aliyun.com/d/1131971649496228-*****-59/ApiServer?orgId=3**&refresh=60s
   */
  httpUrl?: string;
  /**
   * @remarks
   * The URL of the Grafana dashboard.
   * 
   * @example
   * http://g.console.aliyun.com/d/1131971649496228-*****-59/ApiServer?orgId=3**&refresh=60s
   */
  httpsUrl?: string;
  /**
   * @remarks
   * The information about the Grafana dashboard.
   */
  i18nChild?: ListDashboardsResponseBodyDashboardVosI18nChild;
  /**
   * @remarks
   * The ID of the Grafana dashboard. The value is unique only when you install the Grafana dashboard.
   * 
   * @example
   * 1100**
   */
  id?: string;
  /**
   * @remarks
   * Indicates whether the exporter is provided by Application Real-Time Monitoring Service (ARMS).
   * 
   * *   `true:` The exporter is provided by ARMS.
   * *   `false:`: The exporter is not provided by ARMS.
   * 
   * @example
   * false
   */
  isArmsExporter?: boolean;
  /**
   * @remarks
   * The category of the Grafana dashboard. Valid values: BASIC, THIRD, LIMIT, and CUSTOM.
   * 
   * @example
   * BASIC
   */
  kind?: string;
  /**
   * @remarks
   * The language of the Grafana dashboard.
   * 
   * @example
   * en
   */
  language?: string;
  /**
   * @remarks
   * The name of the Grafana dashboard. This parameter is different from the **Title** parameter as this parameter cannot be changed.
   * 
   * @example
   * k8s-node-overview
   */
  name?: string;
  /**
   * @remarks
   * Indicates whether the Grafana dashboard has a new version that is available for upgrade.
   * 
   * @example
   * false
   */
  needUpdate?: boolean;
  /**
   * @remarks
   * The tags of the Grafana dashboard.
   */
  tags?: string[];
  /**
   * @remarks
   * The time when the Grafana dashboard was created. The value is a timestamp. Unit: seconds.
   * 
   * @example
   * 1590136924
   */
  time?: string;
  /**
   * @remarks
   * The title of the Grafana dashboard.
   * 
   * @example
   * ApiServer
   */
  title?: string;
  /**
   * @remarks
   * The type of the Grafana dashboard. Valid values:
   * 
   * *   `dash-db`: a dashboard
   * *   `dash-folder`: a folder that can include a dashboard
   * 
   * @example
   * dash-db
   */
  type?: string;
  /**
   * @remarks
   * The unique identifier of the Grafana dashboard.
   * 
   * @example
   * 1131971649496228-*****-59
   */
  uid?: string;
  /**
   * @remarks
   * The complete URL of the Grafana dashboard.
   * 
   * @example
   * http://g.console.aliyun.com/d/1131971649496228-*****-59/ApiServer?orgId=3**&refresh=60s
   */
  url?: string;
  /**
   * @remarks
   * The version of the Grafana dashboard. The combination of version and name uniquely identifies a dashboard.
   * 
   * @example
   * v2
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      dashboardType: 'DashboardType',
      exporter: 'Exporter',
      httpUrl: 'HttpUrl',
      httpsUrl: 'HttpsUrl',
      i18nChild: 'I18nChild',
      id: 'Id',
      isArmsExporter: 'IsArmsExporter',
      kind: 'Kind',
      language: 'Language',
      name: 'Name',
      needUpdate: 'NeedUpdate',
      tags: 'Tags',
      time: 'Time',
      title: 'Title',
      type: 'Type',
      uid: 'Uid',
      url: 'Url',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dashboardType: 'string',
      exporter: 'string',
      httpUrl: 'string',
      httpsUrl: 'string',
      i18nChild: ListDashboardsResponseBodyDashboardVosI18nChild,
      id: 'string',
      isArmsExporter: 'boolean',
      kind: 'string',
      language: 'string',
      name: 'string',
      needUpdate: 'boolean',
      tags: { 'type': 'array', 'itemType': 'string' },
      time: 'string',
      title: 'string',
      type: 'string',
      uid: 'string',
      url: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDispatchRuleResponseBodyDispatchRules extends $tea.Model {
  /**
   * @remarks
   * The name of the notification policy.
   * 
   * @example
   * Prod
   */
  name?: string;
  /**
   * @remarks
   * The ID of the notification policy.
   * 
   * @example
   * 10282
   */
  ruleId?: number;
  /**
   * @remarks
   * Indicates whether the notification policy is enabled. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  state?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      ruleId: 'RuleId',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      ruleId: 'number',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvCustomJobsResponseBodyDataScrapeConfigs extends $tea.Model {
  /**
   * @remarks
   * The name of the job.
   * 
   * @example
   * custom-sd-demo
   */
  jobName?: string;
  /**
   * @remarks
   * The path of the metric.
   * 
   * @example
   * /metrics
   */
  metricsPath?: string;
  /**
   * @remarks
   * The service discovery methods.
   */
  scrapeDiscoverys?: string[];
  /**
   * @remarks
   * The capture interval.
   * 
   * @example
   * 30s
   */
  scrapeInterval?: string;
  static names(): { [key: string]: string } {
    return {
      jobName: 'JobName',
      metricsPath: 'MetricsPath',
      scrapeDiscoverys: 'ScrapeDiscoverys',
      scrapeInterval: 'ScrapeInterval',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobName: 'string',
      metricsPath: 'string',
      scrapeDiscoverys: { 'type': 'array', 'itemType': 'string' },
      scrapeInterval: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvCustomJobsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The name of the add-on to which the custom job belongs.
   * 
   * @example
   * mysql
   */
  addonName?: string;
  /**
   * @remarks
   * The instance name of the add-on.
   * 
   * @example
   * mysql1
   */
  addonReleaseName?: string;
  /**
   * @remarks
   * The version of the add-on.
   * 
   * @example
   * 1.1.0
   */
  addonVersion?: string;
  /**
   * @remarks
   * If the request parameter EncryptYaml is set to true, a Base64-encoded YAML string is returned. Otherwise, a plaintext YAML string is returned.
   * 
   * @example
   * Refer to supplementary instructions.
   */
  configYaml?: string;
  /**
   * @remarks
   * The time when the custom job was created. The value of this parameter is a timestamp.
   * 
   * @example
   * 2022-01-01T10:11:34Z
   */
  creationTimestamp?: string;
  /**
   * @remarks
   * The name of the custom job.
   * 
   * @example
   * job1
   */
  customJobName?: string;
  /**
   * @remarks
   * The ID of the environment instance.
   * 
   * @example
   * env-xxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The capture configurations.
   */
  scrapeConfigs?: ListEnvCustomJobsResponseBodyDataScrapeConfigs[];
  /**
   * @remarks
   * The status of the custom job.
   * 
   * @example
   * run
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      addonName: 'AddonName',
      addonReleaseName: 'AddonReleaseName',
      addonVersion: 'AddonVersion',
      configYaml: 'ConfigYaml',
      creationTimestamp: 'CreationTimestamp',
      customJobName: 'CustomJobName',
      environmentId: 'EnvironmentId',
      regionId: 'RegionId',
      scrapeConfigs: 'ScrapeConfigs',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addonName: 'string',
      addonReleaseName: 'string',
      addonVersion: 'string',
      configYaml: 'string',
      creationTimestamp: 'string',
      customJobName: 'string',
      environmentId: 'string',
      regionId: 'string',
      scrapeConfigs: { 'type': 'array', 'itemType': ListEnvCustomJobsResponseBodyDataScrapeConfigs },
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvPodMonitorsResponseBodyDataEndpoints extends $tea.Model {
  /**
   * @remarks
   * The collection interval.
   * 
   * @example
   * 30s
   */
  interval?: string;
  /**
   * @remarks
   * The number of pods that match the PodMonitor endpoint.
   * 
   * @example
   * 1
   */
  matchedTargetCount?: number;
  /**
   * @remarks
   * The collection path.
   * 
   * @example
   * /metrics
   */
  path?: string;
  /**
   * @remarks
   * The external port.
   * 
   * @example
   * 9182
   */
  port?: string;
  /**
   * @remarks
   * The destination port.
   * 
   * @example
   * 3306
   */
  targetPort?: number;
  static names(): { [key: string]: string } {
    return {
      interval: 'Interval',
      matchedTargetCount: 'MatchedTargetCount',
      path: 'Path',
      port: 'Port',
      targetPort: 'TargetPort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      interval: 'string',
      matchedTargetCount: 'number',
      path: 'string',
      port: 'string',
      targetPort: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvPodMonitorsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The name of the add-on to which the PodMonitor belongs.
   * 
   * @example
   * mysql
   */
  addonName?: string;
  /**
   * @remarks
   * The instance name of the add-on.
   * 
   * @example
   * mysql1
   */
  addonReleaseName?: string;
  /**
   * @remarks
   * The version of the add-on.
   * 
   * @example
   * 1.0.5
   */
  addonVersion?: string;
  /**
   * @remarks
   * The YAML configuration string.
   * 
   * @example
   * Refer to supplementary instructions.
   */
  configYaml?: string;
  /**
   * @remarks
   * The time when the PodMonitor was created. The value of this parameter is a timestamp.
   * 
   * @example
   * 2011-01-02T11:34:22Z
   */
  creationTimestamp?: string;
  /**
   * @remarks
   * The endpoints of the PodMonitor.
   */
  endpoints?: ListEnvPodMonitorsResponseBodyDataEndpoints[];
  /**
   * @remarks
   * The environment ID.
   * 
   * @example
   * env-xxxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The namespace.
   * 
   * @example
   * arms-prom
   */
  namespace?: string;
  /**
   * @remarks
   * The name of the PodMonitor.
   * 
   * @example
   * pm1
   */
  podMonitorName?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-beijing
   */
  regionId?: string;
  /**
   * @remarks
   * The status of the PodMonitor.
   * 
   * @example
   * run
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      addonName: 'AddonName',
      addonReleaseName: 'AddonReleaseName',
      addonVersion: 'AddonVersion',
      configYaml: 'ConfigYaml',
      creationTimestamp: 'CreationTimestamp',
      endpoints: 'Endpoints',
      environmentId: 'EnvironmentId',
      namespace: 'Namespace',
      podMonitorName: 'PodMonitorName',
      regionId: 'RegionId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addonName: 'string',
      addonReleaseName: 'string',
      addonVersion: 'string',
      configYaml: 'string',
      creationTimestamp: 'string',
      endpoints: { 'type': 'array', 'itemType': ListEnvPodMonitorsResponseBodyDataEndpoints },
      environmentId: 'string',
      namespace: 'string',
      podMonitorName: 'string',
      regionId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvServiceMonitorsResponseBodyDataEndpoints extends $tea.Model {
  /**
   * @remarks
   * The collection interval.
   * 
   * @example
   * 30s
   */
  interval?: string;
  /**
   * @remarks
   * The number of pods that match the ServiceMonitor endpoint.
   * 
   * @example
   * 1
   */
  matchedTargetCount?: number;
  /**
   * @remarks
   * The collection path.
   * 
   * @example
   * /metrics
   */
  path?: string;
  /**
   * @remarks
   * The external port.
   * 
   * @example
   * 9101
   */
  port?: string;
  /**
   * @remarks
   * The destination port.
   * 
   * @example
   * 443
   */
  targetPort?: number;
  static names(): { [key: string]: string } {
    return {
      interval: 'Interval',
      matchedTargetCount: 'MatchedTargetCount',
      path: 'Path',
      port: 'Port',
      targetPort: 'TargetPort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      interval: 'string',
      matchedTargetCount: 'number',
      path: 'string',
      port: 'string',
      targetPort: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvServiceMonitorsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The name of the add-on to which the ServiceMonitor belongs.
   * 
   * @example
   * mysql
   */
  addonName?: string;
  /**
   * @remarks
   * The instance name of the add-on.
   * 
   * @example
   * mysql1
   */
  addonReleaseName?: string;
  /**
   * @remarks
   * The version of the add-on.
   * 
   * @example
   * 1.1.0
   */
  addonVersion?: string;
  /**
   * @remarks
   * The YAML configuration string.
   * 
   * @example
   * Refer to supplementary instructions.
   */
  configYaml?: string;
  /**
   * @remarks
   * The time when the ServiceMonitor was created. The value of this parameter is a timestamp.
   * 
   * @example
   * 2011-10-11T22:32:11Z
   */
  creationTimestamp?: string;
  /**
   * @remarks
   * The endpoints of the ServiceMonitor.
   */
  endpoints?: ListEnvServiceMonitorsResponseBodyDataEndpoints[];
  /**
   * @remarks
   * The environment ID.
   * 
   * @example
   * env-xxxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The number of matched services.
   * 
   * @example
   * 1
   */
  matchedServiceCount?: number;
  /**
   * @remarks
   * The namespace.
   * 
   * @example
   * arms-prom
   */
  namespace?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-beijing
   */
  regionId?: string;
  /**
   * @remarks
   * The name of the ServiceMonitor.
   * 
   * @example
   * sm1
   */
  serviceMonitorName?: string;
  /**
   * @remarks
   * The status of the ServiceMonitor.
   * 
   * @example
   * run
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      addonName: 'AddonName',
      addonReleaseName: 'AddonReleaseName',
      addonVersion: 'AddonVersion',
      configYaml: 'ConfigYaml',
      creationTimestamp: 'CreationTimestamp',
      endpoints: 'Endpoints',
      environmentId: 'EnvironmentId',
      matchedServiceCount: 'MatchedServiceCount',
      namespace: 'Namespace',
      regionId: 'RegionId',
      serviceMonitorName: 'ServiceMonitorName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addonName: 'string',
      addonReleaseName: 'string',
      addonVersion: 'string',
      configYaml: 'string',
      creationTimestamp: 'string',
      endpoints: { 'type': 'array', 'itemType': ListEnvServiceMonitorsResponseBodyDataEndpoints },
      environmentId: 'string',
      matchedServiceCount: 'number',
      namespace: 'string',
      regionId: 'string',
      serviceMonitorName: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvironmentDashboardsResponseBodyDataDashboards extends $tea.Model {
  /**
   * @remarks
   * The UID of the folder.
   * 
   * @example
   * 1374923841627893
   */
  folderUid?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The keyword.
   */
  tags?: string[];
  /**
   * @remarks
   * The title of the Grafana dashboard.
   * 
   * @example
   * kafka-instance
   */
  title?: string;
  /**
   * @remarks
   * The unique identifier of the dashboard.
   * 
   * @example
   * 1537863211936042
   */
  uid?: string;
  /**
   * @remarks
   * The complete URL of the dashboard.
   * 
   * @example
   * http://xxx
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      folderUid: 'FolderUid',
      region: 'Region',
      tags: 'Tags',
      title: 'Title',
      uid: 'Uid',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      folderUid: 'string',
      region: 'string',
      tags: { 'type': 'array', 'itemType': 'string' },
      title: 'string',
      uid: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvironmentDashboardsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The dashboards.
   */
  dashboards?: ListEnvironmentDashboardsResponseBodyDataDashboards[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 1
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      dashboards: 'Dashboards',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dashboards: { 'type': 'array', 'itemType': ListEnvironmentDashboardsResponseBodyDataDashboards },
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvironmentFeaturesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The alias of the feature.
   * 
   * @example
   * Prometheus Agent
   */
  alias?: string;
  /**
   * @remarks
   * The feature configuration.
   */
  config?: { [key: string]: string };
  /**
   * @remarks
   * The description of the feature.
   * 
   * @example
   * Collect Metric data using the Prometheus collection specification.
   */
  description?: string;
  /**
   * @remarks
   * The ID of the environment instance.
   * 
   * @example
   * env-xxxxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The URL of the icon.
   * 
   * @example
   * http://xxx
   */
  icon?: string;
  /**
   * @remarks
   * The language. Valid values:
   * 
   * *   zh: Chinese
   * *   en: English
   * 
   * @example
   * zh
   */
  language?: string;
  /**
   * @remarks
   * The latest version number.
   * 
   * @example
   * 1.1.17
   */
  latestVersion?: string;
  /**
   * @remarks
   * Indicates whether the component is fully managed.
   * 
   * @example
   * true
   */
  managed?: boolean;
  /**
   * @remarks
   * The name of the feature.
   * 
   * @example
   * metric-agent
   */
  name?: string;
  /**
   * @remarks
   * The status of the feature. Valid values:
   * 
   * *   Installing: The agent is being installed.
   * *   Success: The agent is installed.
   * *   Failed: The agent failed to be installed.
   * *   UnInstall: The agent is uninstalled.
   * *   Uninstalling: The agent is being uninstalled.
   * *   UnInstallFailed: The agent failed to be uninstalled.
   * 
   * @example
   * Success
   */
  status?: string;
  /**
   * @remarks
   * The version of the feature.
   * 
   * @example
   * 1.1.17
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      config: 'Config',
      description: 'Description',
      environmentId: 'EnvironmentId',
      icon: 'Icon',
      language: 'Language',
      latestVersion: 'LatestVersion',
      managed: 'Managed',
      name: 'Name',
      status: 'Status',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      config: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      description: 'string',
      environmentId: 'string',
      icon: 'string',
      language: 'string',
      latestVersion: 'string',
      managed: 'boolean',
      name: 'string',
      status: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvironmentsRequestTag extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * env
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * gfn_web_outbound_add
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvironmentsResponseBodyDataEnvironmentsAddons extends $tea.Model {
  /**
   * @remarks
   * The alias of the add-on.
   * 
   * @example
   * MySQL Exporter
   */
  alias?: string;
  /**
   * @remarks
   * The description of the add-on.
   * 
   * @example
   * Collect mysql indicator information
   */
  description?: string;
  /**
   * @remarks
   * The URL of the icon.
   * 
   * @example
   * http://xxxx
   */
  icon?: string;
  /**
   * @remarks
   * The name of the add-on.
   * 
   * @example
   * metric-agent
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      description: 'Description',
      icon: 'Icon',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      description: 'string',
      icon: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvironmentsResponseBodyDataEnvironmentsFeatures extends $tea.Model {
  /**
   * @remarks
   * The alias of the feature.
   * 
   * @example
   * Prometheus Agent
   */
  alias?: string;
  /**
   * @remarks
   * The description of the feature.
   * 
   * @example
   * Collect Metric data using the Prometheus collection specification
   */
  description?: string;
  /**
   * @remarks
   * The URL of the icon.
   * 
   * @example
   * http://xxx
   */
  icon?: string;
  /**
   * @remarks
   * The name of the feature.
   * 
   * @example
   * metirc-agent
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      description: 'Description',
      icon: 'Icon',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      description: 'string',
      icon: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvironmentsResponseBodyDataEnvironmentsTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * fpx-tag
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * cn-beijing
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvironmentsResponseBodyDataEnvironments extends $tea.Model {
  /**
   * @remarks
   * The add-ons.
   */
  addons?: ListEnvironmentsResponseBodyDataEnvironmentsAddons[];
  /**
   * @remarks
   * The ID of the resource bound to the environment instance. The resource can be a Kubernetes cluster or a VPC.
   * 
   * @example
   * vpc-bp1bgo8ronn
   */
  bindResourceId?: string;
  /**
   * @remarks
   * The profile that is bound to the resource.
   * 
   * @example
   * xxx
   */
  bindResourceProfile?: string;
  /**
   * @remarks
   * The resource type.
   * 
   * @example
   * VPC
   */
  bindResourceType?: string;
  /**
   * @remarks
   * The CIDR block that is bound to the VPC.
   * 
   * @example
   * 172.16.0.0/12
   */
  bindVpcCidr?: string;
  /**
   * @remarks
   * The time when the environment instance was created.
   * 
   * @example
   * 2023-03-24 11:58:35 +0800
   */
  createTime?: string;
  /**
   * @remarks
   * The user ID.
   * 
   * @example
   * 12378523784982
   */
  createdUserId?: string;
  /**
   * @remarks
   * The ID of the environment instance.
   * 
   * @example
   * env-xxx
   */
  environmentId?: string;
  /**
   * @remarks
   * The name of the environment instance.
   * 
   * @example
   * feiliks-biz-prod-edas
   */
  environmentName?: string;
  /**
   * @remarks
   * The type of the environment instance. Valid values:
   * 
   * *   CS: Container Service
   * *   ECS: Elastic Compute Service
   * *   Cloud: cloud service
   * 
   * @example
   * CS
   */
  environmentType?: string;
  /**
   * @remarks
   * The parameters of the feature.
   */
  features?: ListEnvironmentsResponseBodyDataEnvironmentsFeatures[];
  /**
   * @remarks
   * The payable resource plan.
   * 
   * *   If the EnvironmentType parameter is set to CS, set the value to CS_Basic or CS_Pro.
   * *   Otherwise, leave the parameter empty.
   * 
   * @example
   * CS_Pro
   */
  feePackage?: string;
  /**
   * @remarks
   * The unique ID of the Grafana data source.
   * 
   * @example
   * 12374890
   */
  grafanaDatasourceUid?: string;
  /**
   * @remarks
   * The name of the Grafana directory.
   * 
   * @example
   * filepath
   */
  grafanaFolderTitle?: string;
  /**
   * @remarks
   * The unique ID of the Grafana directory.
   * 
   * @example
   * 1798319482935
   */
  grafanaFolderUid?: string;
  /**
   * @remarks
   * The time when the last add-on was created.
   * 
   * @example
   * 2023-09-22T16:56:29+08:00
   */
  latestReleaseCreateTime?: string;
  /**
   * @remarks
   * Indicates whether agents or exporters are managed. Valid values:
   * 
   * *   none: No. By default, no managed agents or exporters are provided for ACK clusters.
   * *   agent: Agents are managed. By default, managed agents are provided for ASK clusters, ACS clusters, and ACK One clusters.
   * *   agent-exproter: Agents and exporters are managed. By default, managed agents and exporters are provided for cloud services.
   * 
   * @example
   * agent
   */
  managedType?: string;
  /**
   * @remarks
   * The Prometheus ID.
   * 
   * @example
   * 124769812
   */
  prometheusId?: number;
  /**
   * @remarks
   * The ID of the Prometheus instance.
   * 
   * @example
   * vpc-m5e4alj2i24ndbn
   */
  prometheusInstanceId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-zhangjiakou
   */
  regionId?: string;
  /**
   * @remarks
   * The number of installed add-ons.
   * 
   * @example
   * 122
   */
  releaseCount?: number;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfmvt3xpr5aema
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The tags of the environment resource.
   */
  tags?: ListEnvironmentsResponseBodyDataEnvironmentsTags[];
  /**
   * @remarks
   * The user ID.
   * 
   * @example
   * 13990957477389
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      addons: 'Addons',
      bindResourceId: 'BindResourceId',
      bindResourceProfile: 'BindResourceProfile',
      bindResourceType: 'BindResourceType',
      bindVpcCidr: 'BindVpcCidr',
      createTime: 'CreateTime',
      createdUserId: 'CreatedUserId',
      environmentId: 'EnvironmentId',
      environmentName: 'EnvironmentName',
      environmentType: 'EnvironmentType',
      features: 'Features',
      feePackage: 'FeePackage',
      grafanaDatasourceUid: 'GrafanaDatasourceUid',
      grafanaFolderTitle: 'GrafanaFolderTitle',
      grafanaFolderUid: 'GrafanaFolderUid',
      latestReleaseCreateTime: 'LatestReleaseCreateTime',
      managedType: 'ManagedType',
      prometheusId: 'PrometheusId',
      prometheusInstanceId: 'PrometheusInstanceId',
      regionId: 'RegionId',
      releaseCount: 'ReleaseCount',
      resourceGroupId: 'ResourceGroupId',
      tags: 'Tags',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addons: { 'type': 'array', 'itemType': ListEnvironmentsResponseBodyDataEnvironmentsAddons },
      bindResourceId: 'string',
      bindResourceProfile: 'string',
      bindResourceType: 'string',
      bindVpcCidr: 'string',
      createTime: 'string',
      createdUserId: 'string',
      environmentId: 'string',
      environmentName: 'string',
      environmentType: 'string',
      features: { 'type': 'array', 'itemType': ListEnvironmentsResponseBodyDataEnvironmentsFeatures },
      feePackage: 'string',
      grafanaDatasourceUid: 'string',
      grafanaFolderTitle: 'string',
      grafanaFolderUid: 'string',
      latestReleaseCreateTime: 'string',
      managedType: 'string',
      prometheusId: 'number',
      prometheusInstanceId: 'string',
      regionId: 'string',
      releaseCount: 'number',
      resourceGroupId: 'string',
      tags: { 'type': 'array', 'itemType': ListEnvironmentsResponseBodyDataEnvironmentsTags },
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnvironmentsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The queried environments.
   */
  environments?: ListEnvironmentsResponseBodyDataEnvironments[];
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 12
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      environments: 'Environments',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      environments: { 'type': 'array', 'itemType': ListEnvironmentsResponseBodyDataEnvironments },
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies extends $tea.Model {
  /**
   * @remarks
   * The ID of the escalation policy.
   * 
   * @example
   * 1234
   */
  id?: number;
  /**
   * @remarks
   * The name of the escalation policy.
   * 
   * @example
   * prod escalation policy
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEscalationPoliciesResponseBodyPageBean extends $tea.Model {
  /**
   * @remarks
   * The list of escalation policies.
   */
  escalationPolicies?: ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies[];
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 20
   */
  size?: number;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 1
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      escalationPolicies: 'EscalationPolicies',
      page: 'Page',
      size: 'Size',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      escalationPolicies: { 'type': 'array', 'itemType': ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies },
      page: 'number',
      size: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations extends $tea.Model {
  /**
   * @remarks
   * The description of the EventBridge integration.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The ID of the EventBridge integration.
   * 
   * @example
   * 123
   */
  id?: number;
  /**
   * @remarks
   * The name of the EventBridge integration.
   * 
   * @example
   * EventBridge_Test
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEventBridgeIntegrationsResponseBodyPageBean extends $tea.Model {
  /**
   * @remarks
   * The EventBridge integrations.
   */
  eventBridgeIntegrations?: ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations[];
  /**
   * @remarks
   * The number of the returned page.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 15
   */
  size?: number;
  /**
   * @remarks
   * The total number of EventBridge integrations that are returned.
   * 
   * @example
   * 1
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      eventBridgeIntegrations: 'EventBridgeIntegrations',
      page: 'Page',
      size: 'Size',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventBridgeIntegrations: { 'type': 'array', 'itemType': ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations },
      page: 'number',
      size: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGrafanaWorkspaceRequestTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * TestKey
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * TestValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInsightsEventsResponseBodyInsightsEvents extends $tea.Model {
  /**
   * @remarks
   * The time when the event occurred. The value is a timestamp.
   * 
   * @example
   * 1658890560
   */
  date?: number;
  /**
   * @remarks
   * The description of the alert event.
   * 
   * @example
   * The overall response time of the [HTTP] service of the application [sd] spikes at [2022-07-27 10:57:00]
   */
  desc?: string;
  /**
   * @remarks
   * The severity of the event.
   * 
   * @example
   * P3
   */
  level?: string;
  /**
   * @remarks
   * The ID of the application associated with the event.
   * 
   * @example
   * dsv9zcel92@7da413b******
   */
  pid?: string;
  /**
   * @remarks
   * The problem identifier.
   * 
   * @example
   * erep3o9zue@01ebe697ab70566|@1499161100890550|@cn-hangzhou|@1701841800000|@1701842040000|@daa6c51a-3c44-4d57-9548-4e212c******
   */
  problemId?: string;
  /**
   * @remarks
   * The title of the event.
   * 
   * @example
   * Average response-time spikes of application services
   */
  title?: string;
  /**
   * @remarks
   * The type of the event.
   * 
   * @example
   * rtIncrease
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      date: 'Date',
      desc: 'Desc',
      level: 'Level',
      pid: 'Pid',
      problemId: 'ProblemId',
      title: 'Title',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      date: 'number',
      desc: 'string',
      level: 'string',
      pid: 'string',
      problemId: 'string',
      title: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail extends $tea.Model {
  /**
   * @remarks
   * Indicates whether alert events are automatically cleared. Valid values:
   * 
   * *   true (default)
   * *   false
   * 
   * @example
   * true
   */
  autoRecover?: boolean;
  /**
   * @remarks
   * The description of the alert integration.
   * 
   * @example
   * Test
   */
  description?: string;
  /**
   * @remarks
   * The fields whose values are deduplicated.
   * 
   * @example
   * LABEL.alertname::LABEL.severity
   */
  duplicateKey?: string;
  /**
   * @remarks
   * The extended mapped fields of the alert source.
   */
  extendedFieldRedefineRules?: { [key: string]: any }[];
  /**
   * @remarks
   * The predefined mapped fields of the alert source.
   */
  fieldRedefineRules?: { [key: string]: any }[];
  /**
   * @remarks
   * The field for clearing alert events. The system queries alert events based on the field of alert clearing events and clears the alert events.
   * 
   * > Only the Log Service alert integration supports the parameter.
   * 
   * @example
   * $.status
   */
  initiativeRecoverField?: string;
  /**
   * @remarks
   * The value of the field for clearing alert events. The system queries alert events based on the field of alert clearing events and clears the alert events.
   * 
   * > Only the Log Service alert integration supports the parameter.
   * 
   * @example
   * ok
   */
  initiativeRecoverValue?: string;
  /**
   * @remarks
   * The time when alert events are automatically cleared. Unit: seconds. Default value: 300.
   * 
   * @example
   * 300
   */
  recoverTime?: number;
  /**
   * @remarks
   * The total number of alert events and the number of abnormal alert events in the last hour.
   */
  stat?: number[];
  static names(): { [key: string]: string } {
    return {
      autoRecover: 'AutoRecover',
      description: 'Description',
      duplicateKey: 'DuplicateKey',
      extendedFieldRedefineRules: 'ExtendedFieldRedefineRules',
      fieldRedefineRules: 'FieldRedefineRules',
      initiativeRecoverField: 'InitiativeRecoverField',
      initiativeRecoverValue: 'InitiativeRecoverValue',
      recoverTime: 'RecoverTime',
      stat: 'Stat',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRecover: 'boolean',
      description: 'string',
      duplicateKey: 'string',
      extendedFieldRedefineRules: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
      fieldRedefineRules: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
      initiativeRecoverField: 'string',
      initiativeRecoverValue: 'string',
      recoverTime: 'number',
      stat: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListIntegrationResponseBodyPageInfoIntegrations extends $tea.Model {
  /**
   * @remarks
   * The endpoint of the alert integration.
   * 
   * @example
   * https://alerts.aliyuncs.com/api/v1/integrations/custom/ymQBN******
   */
  apiEndpoint?: string;
  /**
   * @remarks
   * The time when the alert integration was created.
   * 
   * @example
   * 2022-06-18
   */
  createTime?: string;
  /**
   * @remarks
   * The information about the alert events.
   */
  integrationDetail?: ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail;
  /**
   * @remarks
   * The ID of the alert integration.
   * 
   * @example
   * 1234
   */
  integrationId?: number;
  /**
   * @remarks
   * The name of the alert integration.
   * 
   * @example
   * CloudMonitor integration
   */
  integrationName?: string;
  /**
   * @remarks
   * The type of the alert integration. Valid values:
   * 
   * *   CLOUD_MONITOR: CloudMonitor
   * *   LOG_SERVICE: Log Service
   * 
   * @example
   * CLOUD_MONITOR
   */
  integrationProductType?: string;
  /**
   * @remarks
   * The activity of the alert integration
   * 
   * @example
   * ready
   */
  liveness?: string;
  /**
   * @remarks
   * The authentication token of the alert integration.
   * 
   * @example
   * ymQBN******
   */
  shortToken?: string;
  /**
   * @remarks
   * Indicates whether the alert integration was enabled. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  state?: boolean;
  static names(): { [key: string]: string } {
    return {
      apiEndpoint: 'ApiEndpoint',
      createTime: 'CreateTime',
      integrationDetail: 'IntegrationDetail',
      integrationId: 'IntegrationId',
      integrationName: 'IntegrationName',
      integrationProductType: 'IntegrationProductType',
      liveness: 'Liveness',
      shortToken: 'ShortToken',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiEndpoint: 'string',
      createTime: 'string',
      integrationDetail: ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail,
      integrationId: 'number',
      integrationName: 'string',
      integrationProductType: 'string',
      liveness: 'string',
      shortToken: 'string',
      state: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListIntegrationResponseBodyPageInfo extends $tea.Model {
  /**
   * @remarks
   * The information about each alert integration.
   */
  integrations?: ListIntegrationResponseBodyPageInfoIntegrations[];
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of alert integrations returned per page.
   * 
   * @example
   * 10
   */
  size?: number;
  /**
   * @remarks
   * The total number of alert integrations.
   * 
   * @example
   * 1
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      integrations: 'Integrations',
      page: 'Page',
      size: 'Size',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      integrations: { 'type': 'array', 'itemType': ListIntegrationResponseBodyPageInfoIntegrations },
      page: 'number',
      size: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule extends $tea.Model {
  /**
   * @remarks
   * The time interval of grouping. Unit: seconds. Default value: 30.
   * 
   * @example
   * 30
   */
  groupInterval?: number;
  /**
   * @remarks
   * The waiting time for grouping. Unit: seconds. Default value: 5.
   * 
   * @example
   * 5
   */
  groupWait?: number;
  /**
   * @remarks
   * An array of alert event group objects.
   * 
   * *   If you do not specify the groupingFields field, all alerts will be sent to contacts based on `alertname`.
   * *   If you specify the groupingFields field, alerts with the same field will be sent to contacts in one notification.
   */
  groupingFields?: string[];
  static names(): { [key: string]: string } {
    return {
      groupInterval: 'GroupInterval',
      groupWait: 'GroupWait',
      groupingFields: 'GroupingFields',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupInterval: 'number',
      groupWait: 'number',
      groupingFields: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions extends $tea.Model {
  /**
   * @remarks
   * The key of the matching condition.
   * 
   * @example
   * altertname
   */
  key?: string;
  /**
   * @remarks
   * The logical operator of the matching condition. Valid values:
   * 
   * *   `eq`: equal to
   * *   `neq`: not equal to
   * *   `in`: contains
   * *   `nin`: does not contain
   * *   `re`: regular expression match
   * *   `nre`: regular expression mismatch
   * 
   * @example
   * eq
   */
  operator?: string;
  /**
   * @remarks
   * The value of the matching condition.
   * 
   * @example
   * test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      operator: 'Operator',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      operator: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules extends $tea.Model {
  /**
   * @remarks
   * The matching conditions.
   */
  matchingConditions?: ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions[];
  static names(): { [key: string]: string } {
    return {
      matchingConditions: 'MatchingConditions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      matchingConditions: { 'type': 'array', 'itemType': ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects extends $tea.Model {
  /**
   * @remarks
   * The notification methods specified for a contact.
   */
  notifyChannels?: string[];
  /**
   * @remarks
   * The ID of the notification object.
   * 
   * @example
   * 123
   */
  notifyObjectId?: number;
  /**
   * @remarks
   * The name of the notification object.
   * 
   * @example
   * test
   */
  notifyObjectName?: string;
  /**
   * @remarks
   * The type of the notification object. Valid values:
   * 
   * - CONTACT: an individual contact
   * - CONTACT_GROUP: a contact group
   * - DING_ROBOT: an instant messaging (IM) chatbot
   * - CONTACT_SCHEDULE: a person on duty based on an established schedule
   * 
   * @example
   * CONTACT
   */
  notifyObjectType?: string;
  static names(): { [key: string]: string } {
    return {
      notifyChannels: 'NotifyChannels',
      notifyObjectId: 'NotifyObjectId',
      notifyObjectName: 'NotifyObjectName',
      notifyObjectType: 'NotifyObjectType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      notifyChannels: { 'type': 'array', 'itemType': 'string' },
      notifyObjectId: 'number',
      notifyObjectName: 'string',
      notifyObjectType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule extends $tea.Model {
  /**
   * @remarks
   * The notification method.
   */
  notifyChannels?: string[];
  /**
   * @remarks
   * The end time of the notification window.
   * 
   * @example
   * 23:59
   */
  notifyEndTime?: string;
  /**
   * @remarks
   * The notification objects.
   */
  notifyObjects?: ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects[];
  /**
   * @remarks
   * The start time of the notification window.
   * 
   * @example
   * 00:00
   */
  notifyStartTime?: string;
  static names(): { [key: string]: string } {
    return {
      notifyChannels: 'NotifyChannels',
      notifyEndTime: 'NotifyEndTime',
      notifyObjects: 'NotifyObjects',
      notifyStartTime: 'NotifyStartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      notifyChannels: { 'type': 'array', 'itemType': 'string' },
      notifyEndTime: 'string',
      notifyObjects: { 'type': 'array', 'itemType': ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects },
      notifyStartTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate extends $tea.Model {
  /**
   * @remarks
   * The content of the alert notification sent by email.
   * 
   * @example
   * Alert name: {{ .commonLabels.alertname }}{{if .commonLabels.clustername }} Cluster name: {{ .commonLabels.clustername }} {{ end }}{{if eq "app" .commonLabels._aliyun_arms_involvedObject_kind }} Application name: {{ .commonLabels._aliyun_arms_involvedObject_name }} {{ end }} Notification policy: {{ .dispatchRuleName }} Alert time: {{ .startTime }} Alert content: {{ for .alerts }} {{.annotations.message}} {{if .generatorURL }} \\<a href="{{.generatorURL}}" >Link\\</a> {{end}} {{end}}
   */
  emailContent?: string;
  /**
   * @remarks
   * The content of the alert resolution notification sent by email.
   * 
   * @example
   * Alert name: {{ .commonLabels.alertname }}{{if .commonLabels.clustername }} Cluster name: {{ .commonLabels.clustername }} {{ end }}{{if eq "app" .commonLabels._aliyun_arms_involvedObject_kind }} Application name: {{ .commonLabels._aliyun_arms_involvedObject_name }} {{ end }} Notification policy: {{ .dispatchRuleName }} Alert resolution time: {{ .endTime }} Alert content: {{ for .alerts }} {{.annotations.message}} {{if .generatorURL }} \\<a href="{{.generatorURL}}" >Link\\</a> {{end}} {{end}}
   */
  emailRecoverContent?: string;
  /**
   * @remarks
   * The title of the alert resolution notification sent by email.
   * 
   * @example
   * {{ .commonLabels.alertname }}
   */
  emailRecoverTitle?: string;
  /**
   * @remarks
   * The title of the alert notification sent by email.
   * 
   * @example
   * {{ .commonLabels.alertname }}
   */
  emailTitle?: string;
  /**
   * @remarks
   * The content of the alert notification sent by an IM chatbot.
   * 
   * @example
   * {{if .commonLabels.clustername }} > Cluster name: {{ .commonLabels.clustername }} {{ end }}{{if eq "app" .commonLabels._aliyun_arms_involvedObject_kind }} > Application name: {{ .commonLabels._aliyun_arms_involvedObject_name }} {{ end }}{{ for .alerts }}> {{.annotations.message}} {{if .generatorURL }} [Link]\\({{.generatorURL}}) {{ end }} {{if eq "true" .labels._aliyun_arms_is_denoise_filtered }} (Suspected noise) {{end}} {{end}}
   */
  robotContent?: string;
  /**
   * @remarks
   * The content of the alert notification sent by text message.
   * 
   * @example
   * \\<SmsContent>Notification on the occurrence of a {{ .level }} alert. Alert name: {{ .commonLabels.alertname }}{{if .commonLabels.clustername }} Cluster name: {{ .commonLabels.clustername }} {{ end }}{{if eq "app" .commonLabels._aliyun_arms_involvedObject_kind }} Application name: {{ .commonLabels._aliyun_arms_involvedObject_name }} {{ end }} Notification policy: {{ .dispatchRuleName }} Alert time: {{ .startTime }} Alert content: {{ for .alerts }} {{.annotations.message}} {{ end }}\\</SmsContent>
   */
  smsContent?: string;
  /**
   * @remarks
   * The content of the alert resolution notification sent by text message.
   * 
   * @example
   * \\<SmsRecoverContent>Alert resolution notification. Alert name: {{ .commonLabels.alertname }}{{if .commonLabels.clustername }} Cluster name: {{ .commonLabels.clustername }} {{ end }}{{if eq "app" .commonLabels._aliyun_arms_involvedObject_kind }} Application name: {{ .commonLabels._aliyun_arms_involvedObject_name }} {{ end }} Notification policy: {{ .dispatchRuleName }} Alert resolution time: {{ .endTime }} Alert content: {{ for .alerts }} {{.annotations.message}} {{ end }}\\</SmsRecoverContent>
   */
  smsRecoverContent?: string;
  /**
   * @remarks
   * The content of the alert notification sent by phone.
   * 
   * @example
   * \\<TtsContent>Alert name: {{ .commonLabels.alertname }}{{if .commonLabels.clustername }} Cluster name: {{ .commonLabels.clustername }} {{ end }}{{if eq "app" .commonLabels._aliyun_arms_involvedObject_kind }} Application name: {{ .commonLabels._aliyun_arms_involvedObject_name }} {{ end }} Notification policy: {{ .dispatchRuleName }} Alert time: {{ .startTime }} Alert content: {{ for .alerts }} {{.annotations.message}} {{ end }}\\</TtsContent>
   */
  ttsContent?: string;
  /**
   * @remarks
   * The content of the alert resolution notification sent by phone.
   * 
   * @example
   * \\<TtsRecoverContent>Alert name: {{ .commonLabels.alertname }}{{if .commonLabels.clustername }} Cluster name: {{ .commonLabels.clustername }} {{ end }}{{if eq "app" .commonLabels._aliyun_arms_involvedObject_kind }} Application name: {{ .commonLabels._aliyun_arms_involvedObject_name }} {{ end }} Notification policy: {{ .dispatchRuleName }} Alert resolution time: {{ .endTime }} Alert content: {{ for .alerts }} {{.annotations.message}} {{ end }}\\</TtsRecoverContent>
   */
  ttsRecoverContent?: string;
  static names(): { [key: string]: string } {
    return {
      emailContent: 'EmailContent',
      emailRecoverContent: 'EmailRecoverContent',
      emailRecoverTitle: 'EmailRecoverTitle',
      emailTitle: 'EmailTitle',
      robotContent: 'RobotContent',
      smsContent: 'SmsContent',
      smsRecoverContent: 'SmsRecoverContent',
      ttsContent: 'TtsContent',
      ttsRecoverContent: 'TtsRecoverContent',
    };
  }

  static types(): { [key: string]: any } {
    return {
      emailContent: 'string',
      emailRecoverContent: 'string',
      emailRecoverTitle: 'string',
      emailTitle: 'string',
      robotContent: 'string',
      smsContent: 'string',
      smsRecoverContent: 'string',
      ttsContent: 'string',
      ttsRecoverContent: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies extends $tea.Model {
  /**
   * @remarks
   * Indicates whether simple mode is enabled.
   * 
   * @example
   * true
   */
  directedMode?: boolean;
  /**
   * @remarks
   * The ID of the escalation policy.
   * 
   * @example
   * 123
   */
  escalationPolicyId?: number;
  /**
   * @remarks
   * The grouping rule for alert events.
   */
  groupRule?: ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule;
  /**
   * @remarks
   * The ID of the notification policy.
   * 
   * @example
   * 1234
   */
  id?: number;
  /**
   * @remarks
   * The integration ID of the ticket system to which alerts are pushed.
   * 
   * @example
   * 34
   */
  integrationId?: number;
  /**
   * @remarks
   * The matching rules for alert events.
   */
  matchingRules?: ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules[];
  /**
   * @remarks
   * The name of the notification policy.
   * 
   * @example
   * notificationpolicy_test
   */
  name?: string;
  /**
   * @remarks
   * The notification rule.
   */
  notifyRule?: ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule;
  /**
   * @remarks
   * The notification template.
   */
  notifyTemplate?: ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate;
  /**
   * @remarks
   * Indicates whether the system resends notifications for a long-lasting unresolved alert. Valid values:
   * 
   * - `true` (default): The system resends notifications for a long-lasting unresolved alert at a specified time interval.
   * - `false`: The system resends notifications for a long-lasting unresolved alert based on an escalation policy.
   * 
   * @example
   * true
   */
  repeat?: boolean;
  /**
   * @remarks
   * The time interval at which a notification is resent for a long-lasting unresolved alert. Unit: seconds.
   * 
   * @example
   * 600
   */
  repeatInterval?: number;
  /**
   * @remarks
   * Indicates whether the status of an alert automatically changes to Resolved when all events related to the alert change to the Restored state. The system sends a notification to the alert contacts when the alert status changes to Resolved.
   * 
   * - `true` (default): The system sends a notification.
   * - `false`: The system does not send a notification.
   * 
   * @example
   * true
   */
  sendRecoverMessage?: boolean;
  /**
   * @remarks
   * Indicates whether the notification policy is enabled. Valid values: enable and disable.
   * 
   * @example
   * enable
   */
  state?: string;
  static names(): { [key: string]: string } {
    return {
      directedMode: 'DirectedMode',
      escalationPolicyId: 'EscalationPolicyId',
      groupRule: 'GroupRule',
      id: 'Id',
      integrationId: 'IntegrationId',
      matchingRules: 'MatchingRules',
      name: 'Name',
      notifyRule: 'NotifyRule',
      notifyTemplate: 'NotifyTemplate',
      repeat: 'Repeat',
      repeatInterval: 'RepeatInterval',
      sendRecoverMessage: 'SendRecoverMessage',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      directedMode: 'boolean',
      escalationPolicyId: 'number',
      groupRule: ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule,
      id: 'number',
      integrationId: 'number',
      matchingRules: { 'type': 'array', 'itemType': ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules },
      name: 'string',
      notifyRule: ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule,
      notifyTemplate: ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate,
      repeat: 'boolean',
      repeatInterval: 'number',
      sendRecoverMessage: 'boolean',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNotificationPoliciesResponseBodyPageBean extends $tea.Model {
  /**
   * @remarks
   * The queried notification policies.
   */
  notificationPolicies?: ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies[];
  /**
   * @remarks
   * The number of the page returned.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of entries that are returned on each page.
   * 
   * @example
   * 20
   */
  size?: number;
  /**
   * @remarks
   * The number of notification policies that are returned.
   * 
   * @example
   * 24
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      notificationPolicies: 'NotificationPolicies',
      page: 'Page',
      size: 'Size',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      notificationPolicies: { 'type': 'array', 'itemType': ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies },
      page: 'number',
      size: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules extends $tea.Model {
  /**
   * @remarks
   * The description of the scheduling policy.
   * 
   * @example
   * Test scheduling policy
   */
  description?: string;
  /**
   * @remarks
   * The ID of the scheduling policy.
   * 
   * @example
   * 1234
   */
  id?: number;
  /**
   * @remarks
   * The name of the scheduling policy.
   * 
   * @example
   * OnCallSchedule_test
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOnCallSchedulesResponseBodyPageBean extends $tea.Model {
  /**
   * @remarks
   * The information about the scheduling policy.
   */
  onCallSchedules?: ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules[];
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 20
   */
  size?: number;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 1
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      onCallSchedules: 'OnCallSchedules',
      page: 'Page',
      size: 'Size',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      onCallSchedules: { 'type': 'array', 'itemType': ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules },
      page: 'number',
      size: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusAlertRulesRequestTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * owner
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * zhangsan
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations extends $tea.Model {
  /**
   * @remarks
   * The name of the annotation.
   * 
   * @example
   * message
   */
  name?: string;
  /**
   * @remarks
   * The value of the annotation.
   * 
   * @example
   * The CPU utilization of ${{$labels.pod_name}} exceeds 80%. Current value: {{$value}}%
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels extends $tea.Model {
  /**
   * @remarks
   * The name of the tag.
   * 
   * @example
   * severity
   */
  name?: string;
  /**
   * @remarks
   * The value of the tag associated with the instance.
   * 
   * @example
   * critical
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * key
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusAlertRulesResponseBodyPrometheusAlertRules extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * @example
   * 3888704
   */
  alertId?: number;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * @example
   * Prometheus_Alert
   */
  alertName?: string;
  /**
   * @remarks
   * The annotations of the alert rule.
   */
  annotations?: ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations[];
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * @example
   * c0bad479465464e1d8c1e641b0afb****
   */
  clusterId?: string;
  /**
   * @remarks
   * The ID of the notification policy. This parameter is returned if the NotifyType parameter is set to `DISPATCH_RULE`.
   * 
   * @example
   * 10282
   */
  dispatchRuleId?: number;
  /**
   * @remarks
   * The duration of the alert. Valid values: 1 to 1440. Unit: minutes.
   * 
   * @example
   * 1m
   */
  duration?: string;
  /**
   * @remarks
   * The expression of the alert rule.
   * 
   * @example
   * 100 * (sum(rate(container_cpu_usage_seconds_total[1m])) by (pod_name) / sum(label_replace(kube_pod_container_resource_limits_cpu_cores, \\"pod_name\\", \\"$1\\", \\"pod\\", \\"(.*)\\")) by (pod_name))>75
   */
  expression?: string;
  /**
   * @remarks
   * The tags of the alert rule.
   */
  labels?: ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels[];
  /**
   * @remarks
   * The alert message. Tags can be referenced in the {{$labels.xxx}} format.
   * 
   * @example
   * The CPU utilization of ${{$labels.pod_name}} exceeds 80%. Current value: {{$value}}%
   */
  message?: string;
  /**
   * @remarks
   * The method that is used to send alert notifications. Valid values:
   * 
   * - ALERT_MANAGER: Alert notifications are sent by Operation Center.
   * - DISPATCH_RULE: Alert notifications are
   * 
   * @example
   * ALERT_MANAGER
   */
  notifyType?: string;
  /**
   * @remarks
   * Indicates whether the alert rule is enabled. Valid values:
   * 
   * - 1: The alert rule is enabled.
   * - 0: The alert rule is disabled.
   * 
   * @example
   * 1
   */
  status?: number;
  /**
   * @remarks
   * The tags.
   */
  tags?: ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags[];
  /**
   * @remarks
   * The type of the alert rule.
   * 
   * @example
   * Custom
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      alertId: 'AlertId',
      alertName: 'AlertName',
      annotations: 'Annotations',
      clusterId: 'ClusterId',
      dispatchRuleId: 'DispatchRuleId',
      duration: 'Duration',
      expression: 'Expression',
      labels: 'Labels',
      message: 'Message',
      notifyType: 'NotifyType',
      status: 'Status',
      tags: 'Tags',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertId: 'number',
      alertName: 'string',
      annotations: { 'type': 'array', 'itemType': ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations },
      clusterId: 'string',
      dispatchRuleId: 'number',
      duration: 'string',
      expression: 'string',
      labels: { 'type': 'array', 'itemType': ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels },
      message: 'string',
      notifyType: 'string',
      status: 'number',
      tags: { 'type': 'array', 'itemType': ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags },
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations extends $tea.Model {
  /**
   * @remarks
   * The name of the annotation.
   * 
   * @example
   * message
   */
  name?: string;
  /**
   * @remarks
   * The value of the annotation.
   * 
   * @example
   * The available memory on node {{ $labels.instance }} is less than 10%. Available memory: {{ $value }}%
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels extends $tea.Model {
  /**
   * @remarks
   * The name of the tag.
   * 
   * @example
   * severity
   */
  name?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * warning
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates extends $tea.Model {
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * @example
   * The available memory on the node is less than 10%
   */
  alertName?: string;
  /**
   * @remarks
   * The annotations of the alert rule.
   */
  annotations?: ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations[];
  /**
   * @remarks
   * The content of the alert notification. Tags can be referenced in the {{$labels.xxx}} format.
   * 
   * @example
   * The available memory on node {{ $labels.instance }} is less than 10%. Available memory: {{ $value }}%
   */
  description?: string;
  /**
   * @remarks
   * The duration of the alert. Valid values: 1 to 1440. Unit: minutes.
   * 
   * @example
   * 1m
   */
  duration?: string;
  /**
   * @remarks
   * The expression of the alert rule.
   * 
   * @example
   * node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes * 100 < 10
   */
  expression?: string;
  /**
   * @remarks
   * The tags of the alert rule.
   */
  labels?: ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels[];
  /**
   * @remarks
   * The type of the alert rule.
   * 
   * @example
   * Node
   */
  type?: string;
  /**
   * @remarks
   * The version of the alert rule.
   * 
   * @example
   * 1.0
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      alertName: 'AlertName',
      annotations: 'Annotations',
      description: 'Description',
      duration: 'Duration',
      expression: 'Expression',
      labels: 'Labels',
      type: 'Type',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertName: 'string',
      annotations: { 'type': 'array', 'itemType': ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations },
      description: 'string',
      duration: 'string',
      expression: 'string',
      labels: { 'type': 'array', 'itemType': ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels },
      type: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusInstanceByTagAndResourceGroupIdRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * fpx-tag
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * fvt-tag-value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * ac-cus-tag-3
   */
  tagKey?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * asg-2vc8qq7x89o11rus9uvu
   */
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances extends $tea.Model {
  /**
   * @remarks
   * The authorization token.
   * 
   * @example
   * ad32dxxxx
   */
  authToken?: string;
  /**
   * @remarks
   * The ID of the Prometheus instance.
   * 
   * @example
   * c9d5dda1aeca64220853ace304baeb03d
   */
  clusterId?: string;
  /**
   * @remarks
   * The name of the Prometheus instance.
   * 
   * @example
   * prom1
   */
  clusterName?: string;
  /**
   * @remarks
   * The instance type. Valid values:
   * 
   * *   remote-write: Prometheus instance for Remote Write
   * *   ecs: Prometheus instances for ECS
   * *   cloud-monitor: Prometheus instance for Alibaba Cloud services in the Chinese mainland
   * *   cloud-product: Prometheus instance for Alibaba Cloud services outside the Chinese mainland
   * *   global-view: global aggregation instance
   * *   aliyun-cs: Prometheus instance for Container Service
   * 
   * @example
   * ecs
   */
  clusterType?: string;
  /**
   * @remarks
   * The ID of the Grafana workspace.
   * 
   * @example
   * grafana-rnggfvhlcdl6m71l**
   */
  grafanaInstanceId?: string;
  /**
   * @remarks
   * The public URL for the HTTP API.
   * 
   * @example
   * http://cn-beijing.arms.aliyuncs.com:9090/api/v1/prometheus/xxx/cn-beijing
   */
  httpApiInterUrl?: string;
  /**
   * @remarks
   * The internal URL for the HTTP API.
   * 
   * @example
   * http://cn-beijing-intranet.arms.aliyuncs.com:9090/api/v1/prometheus/xxx/cn-beijing
   */
  httpApiIntraUrl?: string;
  /**
   * @remarks
   * The billing method. Valid values:
   * 
   * *   PREPAY: subscription
   * *   POSTPAY: pay-as-you-go
   * 
   * @example
   * POSTPAY
   */
  paymentType?: string;
  /**
   * @remarks
   * The public URL for Pushgateway.
   * 
   * @example
   * http://cn-beijing.arms.aliyuncs.com/prometheus/xxx/api/v2
   */
  pushGatewayInterUrl?: string;
  /**
   * @remarks
   * The internal URL for Pushgateway.
   * 
   * @example
   * http://cn-beijing-intranet.arms.aliyuncs.com/prometheus/xxx/api/v2
   */
  pushGatewayIntraUrl?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-shanghai
   */
  regionId?: string;
  /**
   * @remarks
   * The public URL for remote read.
   * 
   * @example
   * http://cn-beijing.arms.aliyuncs.com:9090/api/v1/prometheus/xxx/api/v1/read
   */
  remoteReadInterUrl?: string;
  /**
   * @remarks
   * The internal URL for remote read.
   * 
   * @example
   * http://cn-beijing-intranet.arms.aliyuncs.com:9090/api/v1/prometheus/xxx/api/v1/read
   */
  remoteReadIntraUrl?: string;
  /**
   * @remarks
   * The public URL for remote write.
   * 
   * @example
   * http://cn-beijing.arms.aliyuncs.com/prometheus/xxx/api/v3/write
   */
  remoteWriteInterUrl?: string;
  /**
   * @remarks
   * The internal URL for remote write.
   * 
   * @example
   * http://cn-beijing-intranet.arms.aliyuncs.com/prometheus/xxx/api/v3/write
   */
  remoteWriteIntraUrl?: string;
  /**
   * @remarks
   * The ID of the resource group to which the Prometheus instance belongs.
   * 
   * @example
   * rg-acfmz7nocpeidcy
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The resource type.
   * 
   * @example
   * PROMETHEUS
   */
  resourceType?: string;
  /**
   * @remarks
   * The ID of the security group.
   * 
   * @example
   * sg-f8zd1toc10wmbi1v5rom
   */
  securityGroupId?: string;
  /**
   * @remarks
   * The child instances of the global aggregation instance. The value is a JSON string.
   * 
   * @example
   * [ { "headers": {}, "regionId": "cn-hangzhou", "sourceType": "AlibabaPrometheus", "extras": {}, "clusterId": "c39a1048921e04fceb039db2fb\\*\\*\\*\\*", "sourceName": "arms-luyao-test", "dataSource": "", "userId": "167275301789\\*\\*\\*\\*" }, { "headers": {}, "regionId": "cn-beijing", "sourceType": "AlibabaPrometheus", "extras": {}, "clusterId": "c6b6485496d5b400abde22cb47b5\\*\\*\\*\\*", "sourceName": "agent-321-test", "dataSource": "", "userId": "167275301789\\*\\*\\*\\*" }, { "headers": {}, "regionId": "cn-zhangjiakou", "sourceType": "AlibabaPrometheus", "extras": {}, "clusterId": "c261a4f3200c446659133f1ade78\\*\\*\\*\\*", "sourceName": "zaifeng-cardinality-01", "dataSource": "", "userId": "167275301789\\*\\*\\*\\*" } ]
   */
  subClustersJson?: string;
  /**
   * @remarks
   * The list of tags.
   */
  tags?: ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags[];
  /**
   * @remarks
   * The ID of the user.
   * 
   * @example
   * 1672753017899***
   */
  userId?: string;
  /**
   * @remarks
   * The ID of the vSwitch.
   * 
   * @example
   * vsw-f8z73vcja1tqnw90aav5a
   */
  vSwitchId?: string;
  /**
   * @remarks
   * The ID of the virtual private cloud (VPC).
   * 
   * @example
   * vpc-8vbtp1fsm8mir18l8rl0u
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      authToken: 'AuthToken',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      clusterType: 'ClusterType',
      grafanaInstanceId: 'GrafanaInstanceId',
      httpApiInterUrl: 'HttpApiInterUrl',
      httpApiIntraUrl: 'HttpApiIntraUrl',
      paymentType: 'PaymentType',
      pushGatewayInterUrl: 'PushGatewayInterUrl',
      pushGatewayIntraUrl: 'PushGatewayIntraUrl',
      regionId: 'RegionId',
      remoteReadInterUrl: 'RemoteReadInterUrl',
      remoteReadIntraUrl: 'RemoteReadIntraUrl',
      remoteWriteInterUrl: 'RemoteWriteInterUrl',
      remoteWriteIntraUrl: 'RemoteWriteIntraUrl',
      resourceGroupId: 'ResourceGroupId',
      resourceType: 'ResourceType',
      securityGroupId: 'SecurityGroupId',
      subClustersJson: 'SubClustersJson',
      tags: 'Tags',
      userId: 'UserId',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authToken: 'string',
      clusterId: 'string',
      clusterName: 'string',
      clusterType: 'string',
      grafanaInstanceId: 'string',
      httpApiInterUrl: 'string',
      httpApiIntraUrl: 'string',
      paymentType: 'string',
      pushGatewayInterUrl: 'string',
      pushGatewayIntraUrl: 'string',
      regionId: 'string',
      remoteReadInterUrl: 'string',
      remoteReadIntraUrl: 'string',
      remoteWriteInterUrl: 'string',
      remoteWriteIntraUrl: 'string',
      resourceGroupId: 'string',
      resourceType: 'string',
      securityGroupId: 'string',
      subClustersJson: 'string',
      tags: { 'type': 'array', 'itemType': ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags },
      userId: 'string',
      vSwitchId: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The queried Prometheus instances.
   */
  prometheusInstances?: ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances[];
  static names(): { [key: string]: string } {
    return {
      prometheusInstances: 'PrometheusInstances',
    };
  }

  static types(): { [key: string]: any } {
    return {
      prometheusInstances: { 'type': 'array', 'itemType': ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusIntegrationResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the exporter can be deleted.
   * 
   * @example
   * true
   */
  canDelete?: boolean;
  /**
   * @remarks
   * Indicates whether the exporter can be edited.
   * 
   * @example
   * true
   */
  canEditor?: boolean;
  /**
   * @remarks
   * The ID of the Prometheus instance.
   * 
   * @example
   * c589a1b8db05c4561aefbb898ca8fb1cf
   */
  clusterId?: string;
  /**
   * @remarks
   * The name of the container.
   * 
   * @example
   * container-1
   */
  containerName?: string;
  /**
   * @remarks
   * The description of the exporter.
   * 
   * @example
   * "{}"
   */
  describe?: string;
  /**
   * @remarks
   * The type of the exporter.
   * 
   * @example
   * kafka-exporter
   */
  exporterType?: string;
  /**
   * @remarks
   * The ID of the exporter.
   * 
   * @example
   * 29374
   */
  instanceId?: number;
  /**
   * @remarks
   * The name of the exporter.
   * 
   * @example
   * inet
   */
  instanceName?: string;
  /**
   * @remarks
   * The integration type. Valid values: kafka, mysql, redis, snmp, emr, nubela, and tidb.
   * 
   * @example
   * Kafka, mysql, redis, snmp, emr, nubela, and tidb
   */
  integrationType?: string;
  /**
   * @remarks
   * The namespace.
   * 
   * @example
   * arms-prom
   */
  namespace?: string;
  /**
   * @remarks
   * Indicates whether an upgrade is required.
   * 
   * @example
   * true
   */
  needUpgrade?: boolean;
  /**
   * @remarks
   * The configurations of the exporter. The value is a JSON string.
   * 
   * @example
   * {
   *       "port": "5554",
   *       "name": "kafka-test12",
   *       "kafka_instance": "kafka-test",
   *       "__label_value": "kafka-test",
   *       "scrape_interval": 33,
   *       "metrics_path": "/metrics",
   *       "__label_key": "kafka-test"
   * }
   */
  param?: string;
  /**
   * @remarks
   * The pod name of the exporter.
   * 
   * @example
   * kafka-exporter-1
   */
  podName?: string;
  /**
   * @remarks
   * Indicates whether the description is displayed.
   * 
   * @example
   * true
   */
  showDescribe?: boolean;
  /**
   * @remarks
   * Indicates whether the exporter logs are displayed.
   * 
   * @example
   * true
   */
  showLog?: boolean;
  /**
   * @remarks
   * The status of the exporter.
   * 
   * @example
   * installed
   */
  status?: string;
  /**
   * @remarks
   * The monitored IP address.
   * 
   * @example
   * 121.40.62.240:3342
   */
  target?: string;
  /**
   * @remarks
   * The version number.
   * 
   * @example
   * 1.0.0
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      canDelete: 'CanDelete',
      canEditor: 'CanEditor',
      clusterId: 'ClusterId',
      containerName: 'ContainerName',
      describe: 'Describe',
      exporterType: 'ExporterType',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      integrationType: 'IntegrationType',
      namespace: 'Namespace',
      needUpgrade: 'NeedUpgrade',
      param: 'Param',
      podName: 'PodName',
      showDescribe: 'ShowDescribe',
      showLog: 'ShowLog',
      status: 'Status',
      target: 'Target',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canDelete: 'boolean',
      canEditor: 'boolean',
      clusterId: 'string',
      containerName: 'string',
      describe: 'string',
      exporterType: 'string',
      instanceId: 'number',
      instanceName: 'string',
      integrationType: 'string',
      namespace: 'string',
      needUpgrade: 'boolean',
      param: 'string',
      podName: 'string',
      showDescribe: 'boolean',
      showLog: 'boolean',
      status: 'string',
      target: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrometheusMonitoringResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the Prometheus instance.
   * 
   * @example
   * c589a1b8db05c4561aefbb898ca8fb1cf
   */
  clusterId?: string;
  /**
   * @remarks
   * The monitoring configuration. The value is a YAML string.
   * 
   * @example
   * apiVersion: monitoring.coreos.com/v1
   * kind: ServiceMonitor
   * metadata:
   *   name: tomcat-demo
   *   namespace: default
   * spec:
   *   endpoints:
   *     - interval: 30s
   *       path: /metrics
   *       port: tomcat-monitor
   *   namespaceSelector:
   *     any: true
   *   selector:
   *     matchLabels:
   *       app: tomcat
   */
  configYaml?: string;
  /**
   * @remarks
   * The name of the monitoring configuration.
   * 
   * @example
   * podMonitor1
   */
  monitoringName?: string;
  /**
   * @remarks
   * The status of the monitoring configuration.
   * 
   * @example
   * run
   */
  status?: string;
  /**
   * @remarks
   * The type of the monitoring configuration.
   * 
   * @example
   * podMonitor
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      configYaml: 'ConfigYaml',
      monitoringName: 'MonitoringName',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      configYaml: 'string',
      monitoringName: 'string',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRetcodeAppsRequestTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * TestKey
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * TestValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRetcodeAppsResponseBodyRetcodeAppsTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * TestKey
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * TestValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRetcodeAppsResponseBodyRetcodeApps extends $tea.Model {
  /**
   * @remarks
   * The ID of the application. The parameter is an auto-increment parameter.
   * 
   * @example
   * 16064
   */
  appId?: number;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * A1
   */
  appName?: string;
  /**
   * @remarks
   * The alias of the application monitored by Browser Monitoring.
   * 
   * @example
   * B1
   */
  nickName?: string;
  /**
   * @remarks
   * The process identifier (PID) of the application.
   * 
   * @example
   * atc889zkcf@d8deedfa9bf****
   */
  pid?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The type of the application. Valid values:
   * 
   * *   `web`: web application
   * *   `weex`: Weex mobile app
   * *   `mini_dd`: DingTalk mini program
   * *   `mini_alipay`: Alipay mini program
   * *   `mini_wx`: WeChat mini program
   * *   `mini_common`: mini program on other platforms
   * 
   * @example
   * web
   */
  retcodeAppType?: string;
  /**
   * @remarks
   * The tags of the task.
   */
  tags?: ListRetcodeAppsResponseBodyRetcodeAppsTags[];
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      nickName: 'NickName',
      pid: 'Pid',
      resourceGroupId: 'ResourceGroupId',
      retcodeAppType: 'RetcodeAppType',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'number',
      appName: 'string',
      nickName: 'string',
      pid: 'string',
      resourceGroupId: 'string',
      retcodeAppType: 'string',
      tags: { 'type': 'array', 'itemType': ListRetcodeAppsResponseBodyRetcodeAppsTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScenarioResponseBodyArmsScenarios extends $tea.Model {
  /**
   * @remarks
   * The ID of the application.
   * 
   * @example
   * b590lhguqs@28f515462******
   */
  appId?: string;
  /**
   * @remarks
   * The time when the business monitoring job was created.
   * 
   * @example
   * 1585214916000
   */
  createTime?: string;
  /**
   * @remarks
   * The extended information. The value is a JSON string.
   * 
   * @example
   * {"_MODE": "CUSTOM-TRANSACTION","_SCENARIO": "USER-DEFINED"}
   */
  extensions?: string;
  /**
   * @remarks
   * The ID of the business monitoring job.
   * 
   * @example
   * 132
   */
  id?: number;
  /**
   * @remarks
   * The name of the business monitoring job.
   * 
   * @example
   * k8s_deployment_css-guns-vip-main-prod_silence
   */
  name?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-zhangjiakou
   */
  regionId?: string;
  /**
   * @remarks
   * The code of the business monitoring job.
   * 
   * @example
   * a9f8****
   */
  sign?: string;
  /**
   * @remarks
   * The time when the business monitoring job was updated.
   * 
   * @example
   * 1585214916000
   */
  updateTime?: string;
  /**
   * @remarks
   * The ID of the user.
   * 
   * @example
   * 113197164949****
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      createTime: 'CreateTime',
      extensions: 'Extensions',
      id: 'Id',
      name: 'Name',
      regionId: 'RegionId',
      sign: 'Sign',
      updateTime: 'UpdateTime',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      createTime: 'string',
      extensions: 'string',
      id: 'number',
      name: 'string',
      regionId: 'string',
      sign: 'string',
      updateTime: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions extends $tea.Model {
  /**
   * @remarks
   * The key of the matching condition.
   * 
   * @example
   * altertname
   */
  key?: string;
  /**
   * @remarks
   * The logical operator of the matching condition. Valid values:
   * 
   * *   `eq`: equal to
   * *   `neq`: not equal to
   * *   `in`: contains
   * *   `nin`: does not contain
   * *   `re`: regular expression match
   * *   `nre`: regular expression mismatch
   * 
   * @example
   * eq
   */
  operator?: string;
  /**
   * @remarks
   * The value of the matching condition.
   * 
   * @example
   * test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      operator: 'Operator',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      operator: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules extends $tea.Model {
  /**
   * @remarks
   * The matching conditions.
   */
  matchingConditions?: ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions[];
  static names(): { [key: string]: string } {
    return {
      matchingConditions: 'MatchingConditions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      matchingConditions: { 'type': 'array', 'itemType': ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSilencePoliciesResponseBodyPageBeanSilencePolicies extends $tea.Model {
  effectiveTimeType?: string;
  /**
   * @remarks
   * The ID of the silence policy.
   * 
   * @example
   * 123
   */
  id?: number;
  /**
   * @remarks
   * The matching rules.
   */
  matchingRules?: ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules[];
  /**
   * @remarks
   * The name of the silence policy.
   * 
   * @example
   * silencepolicy_test
   */
  name?: string;
  /**
   * @remarks
   * Indicates whether the silence policy is enabled. Valid values: enable and disable.
   * 
   * @example
   * enable
   */
  state?: string;
  timePeriod?: string;
  timeSlots?: string;
  static names(): { [key: string]: string } {
    return {
      effectiveTimeType: 'EffectiveTimeType',
      id: 'Id',
      matchingRules: 'MatchingRules',
      name: 'Name',
      state: 'State',
      timePeriod: 'TimePeriod',
      timeSlots: 'TimeSlots',
    };
  }

  static types(): { [key: string]: any } {
    return {
      effectiveTimeType: 'string',
      id: 'number',
      matchingRules: { 'type': 'array', 'itemType': ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules },
      name: 'string',
      state: 'string',
      timePeriod: 'string',
      timeSlots: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSilencePoliciesResponseBodyPageBean extends $tea.Model {
  /**
   * @remarks
   * The number of the page returned.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The queried silence policies.
   */
  silencePolicies?: ListSilencePoliciesResponseBodyPageBeanSilencePolicies[];
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 20
   */
  size?: number;
  /**
   * @remarks
   * The number of silence policies that were returned.
   * 
   * @example
   * 1
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      page: 'Page',
      silencePolicies: 'SilencePolicies',
      size: 'Size',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      page: 'number',
      silencePolicies: { 'type': 'array', 'itemType': ListSilencePoliciesResponseBodyPageBeanSilencePolicies },
      size: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSyntheticDetailRequestAdvancedFilters extends $tea.Model {
  /**
   * @remarks
   * The filter condition. The taskType and dataId fields are supported.
   * 
   * *   To query the list of synthetic test results, set the key to taskType.
   * *   To query the result details of a synthetic monitoring task, set the key to dataId.
   * 
   * @example
   * taskType
   */
  key?: string;
  /**
   * @remarks
   * The type of the filter condition. Valid values: eq and in. eq: equal to. in: include.
   * 
   * @example
   * eq
   */
  opType?: string;
  /**
   * @remarks
   * The value of the filter condition. The type of the task. Valid values: 1: ICMP 2: TCP 3: DNS 4: HTTP 5: website speed measurement 6: file download
   * 
   * @example
   * 1
   */
  value?: any;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      opType: 'OpType',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      opType: 'string',
      value: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSyntheticDetailRequestExactFilters extends $tea.Model {
  /**
   * @remarks
   * A reserved field.
   * 
   * @example
   * null
   */
  key?: string;
  /**
   * @remarks
   * A reserved field.
   * 
   * @example
   * null
   */
  opType?: string;
  /**
   * @remarks
   * A reserved field.
   * 
   * @example
   * null
   */
  value?: any;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      opType: 'OpType',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      opType: 'string',
      value: 'any',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSyntheticDetailResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The list of results.
   */
  items?: { [key: string]: any }[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of entries returned on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * A reserved field.
   * 
   * @example
   * null
   */
  taskCreateTime?: number;
  /**
   * @remarks
   * The total number of entries.
   * 
   * @example
   * 12
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
      page: 'Page',
      pageSize: 'PageSize',
      taskCreateTime: 'TaskCreateTime',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
      page: 'number',
      pageSize: 'number',
      taskCreateTime: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTimingSyntheticTasksRequestSearch extends $tea.Model {
  /**
   * @remarks
   * The task name.
   * 
   * @example
   * AlibabaCloud DNS Task
   */
  name?: string;
  /**
   * @remarks
   * The order by which tasks are sorted. 1: ascending order. -1: descending order.
   * 
   * @example
   * 1
   */
  order?: number;
  /**
   * @remarks
   * The condition by which tasks are sorted. You can sort tasks by gmtCreate, gmtModified, status, or monitorCount.
   * 
   * @example
   * status
   */
  orderField?: string;
  /**
   * @remarks
   * The page number. This parameter is required.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of entries per page. This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The task status. CREATING: The task is being created. RUNNING: The task is running. PARTIAL_RUNNING: The task is partially running. STOP: The task is stopped. LIMIT_STOP: The task is stopped due to quota limit. EXCEPTION: The task is abnormal. DELETE: The task is deleted. DELETE_EXCEPTION: An exception occurs while deleting the task.
   * 
   * @example
   * CREATING
   */
  status?: string;
  /**
   * @remarks
   * The task IDs.
   */
  taskIds?: string[];
  /**
   * @remarks
   * The task types.
   */
  taskTypes?: number[];
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      order: 'Order',
      orderField: 'OrderField',
      page: 'Page',
      pageSize: 'PageSize',
      status: 'Status',
      taskIds: 'TaskIds',
      taskTypes: 'TaskTypes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      order: 'number',
      orderField: 'string',
      page: 'number',
      pageSize: 'number',
      status: 'string',
      taskIds: { 'type': 'array', 'itemType': 'string' },
      taskTypes: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTimingSyntheticTasksRequestTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * mark
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * value1111
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomHostHosts extends $tea.Model {
  /**
   * @remarks
   * The destination domain name.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The IP version. Valid values:
   * 
   * *   0: A version is automatically selected.
   * *   1: IPv4.
   * *   2: IPv6.
   * 
   * @example
   * 0
   */
  ipType?: number;
  /**
   * @remarks
   * The IP address.
   */
  ips?: string[];
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      ipType: 'IpType',
      ips: 'Ips',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      ipType: 'number',
      ips: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomHost extends $tea.Model {
  /**
   * @remarks
   * The custom host settings.
   */
  hosts?: ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomHostHosts[];
  /**
   * @remarks
   * The selection mode. Valid values:
   * 
   * *   0: random
   * *   1: polling
   * 
   * @example
   * 0
   */
  selectType?: number;
  static names(): { [key: string]: string } {
    return {
      hosts: 'Hosts',
      selectType: 'SelectType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hosts: { 'type': 'array', 'itemType': ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomHostHosts },
      selectType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomPrometheusSetting extends $tea.Model {
  /**
   * @remarks
   * A reserved field.
   * 
   * @example
   * Reserved field
   */
  prometheusClusterId?: string;
  /**
   * @remarks
   * A reserved field.
   * 
   * @example
   * Reserved field
   */
  prometheusClusterRegion?: string;
  /**
   * @remarks
   * A reserved field.
   */
  prometheusLabels?: { [key: string]: string };
  static names(): { [key: string]: string } {
    return {
      prometheusClusterId: 'PrometheusClusterId',
      prometheusClusterRegion: 'PrometheusClusterRegion',
      prometheusLabels: 'PrometheusLabels',
    };
  }

  static types(): { [key: string]: any } {
    return {
      prometheusClusterId: 'string',
      prometheusClusterRegion: 'string',
      prometheusLabels: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomVPCSetting extends $tea.Model {
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-zhangjiakou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the security group to which the client belongs. The security group specifies the inbound and outbound rules of the client for the VPC. You need to allow the security group to which the client belongs to access the security group to which the VPC belongs. Otherwise, the client cannot access resources in the VPC.
   * 
   * @example
   * sg-xxxxxxxxxxxxxx
   */
  secureGroupId?: string;
  /**
   * @remarks
   * The vSwitch ID.
   * 
   * @example
   * vsw-bp1bcmj81kxxxxxxx
   */
  vSwitchId?: string;
  /**
   * @remarks
   * The VPC ID.
   * 
   * @example
   * vpc-2zehbd4dfzahxxxxxxx
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      secureGroupId: 'SecureGroupId',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      secureGroupId: 'string',
      vSwitchId: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTimingSyntheticTasksResponseBodyDataItemsCommonSetting extends $tea.Model {
  /**
   * @remarks
   * The custom host settings.
   */
  customHost?: ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomHost;
  /**
   * @remarks
   * A reserved field.
   */
  customPrometheusSetting?: ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomPrometheusSetting;
  /**
   * @remarks
   * The information about the virtual private cloud (VPC). If the destination URL is an Alibaba Cloud internal endpoint, you need to configure a VPC.
   */
  customVPCSetting?: ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomVPCSetting;
  /**
   * @remarks
   * The IP version. Valid values:
   * 
   * *   0: A version is automatically selected.
   * *   1: IPv4.
   * *   2: IPv6.
   * 
   * @example
   * 0
   */
  ipType?: number;
  /**
   * @remarks
   * Indicates whether tracing is enabled.
   * 
   * @example
   * false
   */
  isOpenTrace?: boolean;
  /**
   * @remarks
   * Indicates whether monitoring samples are evenly distributed. Valid values:
   * 
   * *   0: No
   * *   1: Yes
   * 
   * @example
   * 0
   */
  monitorSamples?: number;
  /**
   * @remarks
   * The type of the client for tracing. Valid values:
   * 
   * *   0: ARMS agent
   * *   1: OpenTelemetry
   * *   2: Jaeger
   * 
   * @example
   * 1
   */
  traceClientType?: number;
  /**
   * @remarks
   * The region to which trace data is reported.
   * 
   * @example
   * cn-hangzhou
   */
  xtraceRegion?: string;
  static names(): { [key: string]: string } {
    return {
      customHost: 'CustomHost',
      customPrometheusSetting: 'CustomPrometheusSetting',
      customVPCSetting: 'CustomVPCSetting',
      ipType: 'IpType',
      isOpenTrace: 'IsOpenTrace',
      monitorSamples: 'MonitorSamples',
      traceClientType: 'TraceClientType',
      xtraceRegion: 'XtraceRegion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customHost: ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomHost,
      customPrometheusSetting: ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomPrometheusSetting,
      customVPCSetting: ListTimingSyntheticTasksResponseBodyDataItemsCommonSettingCustomVPCSetting,
      ipType: 'number',
      isOpenTrace: 'boolean',
      monitorSamples: 'number',
      traceClientType: 'number',
      xtraceRegion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTimingSyntheticTasksResponseBodyDataItemsTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * key
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTimingSyntheticTasksResponseBodyDataItems extends $tea.Model {
  /**
   * @remarks
   * The general settings.
   */
  commonSetting?: ListTimingSyntheticTasksResponseBodyDataItemsCommonSetting;
  /**
   * @remarks
   * The detection frequency. Valid values: 1m, 5m, 10m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, and 24h.
   * 
   * @example
   * 1m
   */
  frequency?: string;
  /**
   * @remarks
   * The time when the task was created.
   * 
   * @example
   * 1671454758000
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The time when the task was modified.
   * 
   * @example
   * 1673085633000
   */
  gmtModified?: string;
  /**
   * @remarks
   * The detection point type. 1: PC. 2: mobile device.
   * 
   * @example
   * 1
   */
  monitorCategory?: number;
  /**
   * @remarks
   * The number of detection points.
   * 
   * @example
   * 10
   */
  monitorNum?: string;
  /**
   * @remarks
   * The task name.
   * 
   * @example
   * AlibabaCloud DNS Task
   */
  name?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-aekzgwtq5vxxxxx
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The task status. CREATING: The task is being created. RUNNING: The task is running. PARTIAL_RUNNING: The task is partially running. STOP: The task is stopped. LIMIT_STOP: The task is stopped due to quota limit. EXCEPTION: The task is abnormal. DELETE: The task is deleted. DELETE_EXCEPTION: An exception occurs while deleting the task.
   * 
   * @example
   * RUNNING
   */
  status?: string;
  /**
   * @remarks
   * The tags.
   */
  tags?: ListTimingSyntheticTasksResponseBodyDataItemsTags[];
  /**
   * @remarks
   * The ID of the synthetic monitoring task.
   * 
   * @example
   * 5308a2691f59422c8c3b7aeccec9cd3b
   */
  taskId?: string;
  /**
   * @remarks
   * The type of the task. Valid values:
   * 
   * 1: ICMP. 2: TCP. 3: DNS. 4: HTTP. 5: website speed. 6: file download.
   * 
   * @example
   * 1
   */
  taskType?: number;
  /**
   * @remarks
   * The URL for synthetic monitoring.
   * 
   * @example
   * https://www.example.com
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      commonSetting: 'CommonSetting',
      frequency: 'Frequency',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      monitorCategory: 'MonitorCategory',
      monitorNum: 'MonitorNum',
      name: 'Name',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      status: 'Status',
      tags: 'Tags',
      taskId: 'TaskId',
      taskType: 'TaskType',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonSetting: ListTimingSyntheticTasksResponseBodyDataItemsCommonSetting,
      frequency: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      monitorCategory: 'number',
      monitorNum: 'string',
      name: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      status: 'string',
      tags: { 'type': 'array', 'itemType': ListTimingSyntheticTasksResponseBodyDataItemsTags },
      taskId: 'string',
      taskType: 'number',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTimingSyntheticTasksResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The queried tasks.
   */
  items?: ListTimingSyntheticTasksResponseBodyDataItems[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of tasks.
   * 
   * @example
   * 100
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
      page: 'Page',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': ListTimingSyntheticTasksResponseBodyDataItems },
      page: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTraceAppsRequestTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * TestKey
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * TestValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTraceAppsResponseBodyTraceAppsTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * TestKey
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * TestValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTraceAppsResponseBodyTraceApps extends $tea.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * 123
   */
  appId?: number;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * test-app
   */
  appName?: string;
  /**
   * @remarks
   * The cluster ID.
   * 
   * @example
   * cc7a37ee31aea4ed1a059eff8034b****
   */
  clusterId?: string;
  /**
   * @remarks
   * The time when the monitoring task was created. The value is a timestamp. Unit: milliseconds.
   * 
   * @example
   * 1529667762000
   */
  createTime?: number;
  /**
   * @remarks
   * The labels of the application.
   */
  labels?: string[];
  /**
   * @remarks
   * The language.
   * 
   * @example
   * PHP
   */
  language?: string;
  /**
   * @remarks
   * The namespace.
   * 
   * @example
   * default
   */
  namespace?: string;
  /**
   * @remarks
   * The process identifier (PID) of the application.
   * 
   * @example
   * a5f9bdeb-2627-4dbe-9247-****
   */
  pid?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The resource group ID.
   * 
   * @example
   * Resource group
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * Indicates whether the application is displayed in the Application Real-Time Monitoring Service (ARMS) console. Valid values:
   * 
   * *   `true`: yes
   * *   `false`: no
   * 
   * @example
   * true
   */
  show?: boolean;
  /**
   * @remarks
   * The application source.
   * 
   * @example
   * ACK
   */
  source?: string;
  /**
   * @remarks
   * The tags.
   */
  tags?: ListTraceAppsResponseBodyTraceAppsTags[];
  /**
   * @remarks
   * The type of the monitoring task. Valid values:
   * 
   * *   `TRACE`: Application Monitoring
   * *   `RETCODE`: Browser Monitoring
   * 
   * @example
   * TRACE
   */
  type?: string;
  /**
   * @remarks
   * The time when the monitoring task was updated. The value is a timestamp. Unit: milliseconds.
   * 
   * @example
   * 1529667762000
   */
  updateTime?: number;
  /**
   * @remarks
   * The user ID.
   * 
   * @example
   * 113197164949****
   */
  userId?: string;
  /**
   * @remarks
   * The type of the workload.
   * 
   * @example
   * Deployment
   */
  workloadKind?: string;
  /**
   * @remarks
   * The name of the workload.
   * 
   * @example
   * nginx-deployment
   */
  workloadName?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      clusterId: 'ClusterId',
      createTime: 'CreateTime',
      labels: 'Labels',
      language: 'Language',
      namespace: 'Namespace',
      pid: 'Pid',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      show: 'Show',
      source: 'Source',
      tags: 'Tags',
      type: 'Type',
      updateTime: 'UpdateTime',
      userId: 'UserId',
      workloadKind: 'WorkloadKind',
      workloadName: 'WorkloadName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'number',
      appName: 'string',
      clusterId: 'string',
      createTime: 'number',
      labels: { 'type': 'array', 'itemType': 'string' },
      language: 'string',
      namespace: 'string',
      pid: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      show: 'boolean',
      source: 'string',
      tags: { 'type': 'array', 'itemType': ListTraceAppsResponseBodyTraceAppsTags },
      type: 'string',
      updateTime: 'number',
      userId: 'string',
      workloadKind: 'string',
      workloadName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCommercialUsageRequestAdvancedFilters extends $tea.Model {
  /**
   * @remarks
   * The key of the filter condition.
   * 
   * @example
   * regionId
   */
  key?: string;
  /**
   * @remarks
   * The operator. Valid values: eq and in.
   * 
   * @example
   * eq
   */
  opType?: string;
  /**
   * @remarks
   * The value of the filter condition.
   * 
   * @example
   * cn-hangzhou
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      opType: 'OpType',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      opType: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryCommercialUsageResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * Indicates whether a multi-region query is complete. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  complete?: boolean;
  /**
   * @remarks
   * The returned struct.
   */
  items?: { [key: string]: any }[];
  static names(): { [key: string]: string } {
    return {
      complete: 'Complete',
      items: 'Items',
    };
  }

  static types(): { [key: string]: any } {
    return {
      complete: 'boolean',
      items: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMetricByPageRequestFilters extends $tea.Model {
  /**
   * @remarks
   * The key of the filter condition. You must set the key to `pid` or `regionId`.
   * 
   * @example
   * pid
   */
  key?: string;
  /**
   * @remarks
   * The value of the filter condition. You must set the value of the `pid` or `regionId` condition. For information about how to obtain the `pid`, see the "Obtain the PID of an application" section.
   * 
   * @example
   * xxx@74xxx
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMetricByPageResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * Whether the paging query ends.
   * 
   * true: end.
   * false: Need to continue pagination (continue to query after CurrentPage+1).
   * 
   * @example
   * false
   */
  completed?: boolean;
  /**
   * @remarks
   * The data entries returned.
   */
  items?: { [key: string]: any }[];
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  page?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 1
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 2
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      completed: 'Completed',
      items: 'Items',
      page: 'Page',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      completed: 'boolean',
      items: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
      page: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPromInstallStatusResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * true: The call was successful. false: The call fails.
   * 
   * @example
   * true
   */
  isControllerInstalled?: boolean;
  static names(): { [key: string]: string } {
    return {
      isControllerInstalled: 'isControllerInstalled',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isControllerInstalled: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The Info-level information.
   * 
   * @example
   * {regionId: the region where the global aggregation instance resides. globalViewClusterId: the ID of the global aggregation instance. failedClusterIds: the IDs of the clusters that failed to be added. A cluster may fail to be added if the specified cluster ID is invalid.}
   */
  info?: string;
  /**
   * @remarks
   * The additional information.
   * 
   * @example
   * OK
   */
  msg?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      info: 'Info',
      msg: 'Msg',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      info: 'string',
      msg: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveSourcesFromPrometheusGlobalViewResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The Info-level information.
   * 
   * @example
   * {regionId: the region where the aggregation instance resides. globalViewClusterId: the ID of the aggregation instance.
   */
  info?: string;
  /**
   * @remarks
   * The additional information.
   * 
   * @example
   * OK
   */
  msg?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * True
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      info: 'Info',
      msg: 'Msg',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      info: 'string',
      msg: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveTraceAppConfigRequestSettings extends $tea.Model {
  /**
   * @remarks
   * The key of the settings that you want to modify. For more information about the supported settings, see the following sections.
   * 
   * *   Trace sampling settings
   * *   Agent switch settings
   * *   Threshold settings
   * *   Advanced settings
   * *   Thread settings
   * *   Memory snapshot settings
   * *   URL convergence settings
   * *   Business log association settings
   * 
   * @example
   * sampling.enable
   */
  key?: string;
  /**
   * @remarks
   * The value of the settings that you want to modify. For more information about the supported settings, see the following sections.
   * 
   * *   Trace sampling settings
   * *   Agent switch settings
   * *   Threshold settings
   * *   Advanced settings
   * *   Thread settings
   * *   Memory snapshot settings
   * *   URL convergence settings
   * *   Business log association settings
   * 
   * @example
   * true
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchAlertContactResponseBodyPageBeanContacts extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert contact.
   * 
   * @example
   * 123
   */
  contactId?: number;
  /**
   * @remarks
   * The name of the alert contact.
   * 
   * @example
   * John Doe
   */
  contactName?: string;
  /**
   * @remarks
   * The contact group to which the contact belongs. If your contacts are added to multiple contact groups, the contact groups are separated by vertical bars (|).
   * 
   * @example
   * Default Group | SRE Group
   */
  content?: string;
  /**
   * @remarks
   * The timestamp generated when the alert contact was created.
   * 
   * @example
   * 1572349025000
   */
  createTime?: number;
  /**
   * @remarks
   * The webhook URL of the DingTalk chatbot.
   * 
   * @example
   * https://oapi.dingtalk.com/robot/send?access_token=91f2f6****
   */
  dingRobot?: string;
  /**
   * @remarks
   * The email address of the alert contact.
   * 
   * @example
   * someone@example.com
   */
  email?: string;
  /**
   * @remarks
   * The mobile number of the alert contact.
   * 
   * @example
   * 1381111*****
   */
  phone?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * Indicates whether the alert contact receives system notifications. Valid values:
   * 
   * *   `true`: The alert contact receives system notifications.
   * *   `false`: The alert contact does not receive system notifications.
   * 
   * @example
   * false
   */
  systemNoc?: boolean;
  /**
   * @remarks
   * The timestamp generated when the alert contact was updated.
   * 
   * @example
   * 1580258717000
   */
  updateTime?: number;
  /**
   * @remarks
   * The ID of the user.
   * 
   * @example
   * 113197164949****
   */
  userId?: string;
  /**
   * @remarks
   * The information about the webhook.
   * 
   * @example
   * {\\"body\\":\\"{   \\\\\\"msg_type\\\\\\": \\\\\\"text\\\\\\",   \\\\\\"content\\\\\\": {     \\\\\\"text\\\\\\": \\\\\\"$content\\\\\\"   } }\\",\\"header\\":{\\"Arms-Content-Type\\":\\"json\\"},\\"method\\":\\"post\\",\\"params\\":{},\\"url\\":\\"https://***",\\"userId\\":\\"1131971649***\\"}",
   */
  webhook?: string;
  static names(): { [key: string]: string } {
    return {
      contactId: 'ContactId',
      contactName: 'ContactName',
      content: 'Content',
      createTime: 'CreateTime',
      dingRobot: 'DingRobot',
      email: 'Email',
      phone: 'Phone',
      resourceGroupId: 'ResourceGroupId',
      systemNoc: 'SystemNoc',
      updateTime: 'UpdateTime',
      userId: 'UserId',
      webhook: 'Webhook',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactId: 'number',
      contactName: 'string',
      content: 'string',
      createTime: 'number',
      dingRobot: 'string',
      email: 'string',
      phone: 'string',
      resourceGroupId: 'string',
      systemNoc: 'boolean',
      updateTime: 'number',
      userId: 'string',
      webhook: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchAlertContactResponseBodyPageBean extends $tea.Model {
  /**
   * @remarks
   * The information about the alert contacts.
   */
  contacts?: SearchAlertContactResponseBodyPageBeanContacts[];
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 23
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      contacts: 'Contacts',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contacts: { 'type': 'array', 'itemType': SearchAlertContactResponseBodyPageBeanContacts },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchAlertContactGroupResponseBodyContactGroupsContacts extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert contact.
   * 
   * @example
   * 123
   */
  contactId?: number;
  /**
   * @remarks
   * The name of the alert contact.
   * 
   * @example
   * John Doe
   */
  contactName?: string;
  /**
   * @remarks
   * The time when the alert contact group list was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1572349025000
   */
  createTime?: number;
  /**
   * @remarks
   * The webhook URL of the DingTalk chatbot.
   * 
   * @example
   * https://oapi.dingtalk.com/robot/send?access_token=91f2f6****
   */
  dingRobot?: string;
  /**
   * @remarks
   * The email address of the alert contact.
   * 
   * @example
   * someone@example.com
   */
  email?: string;
  /**
   * @remarks
   * The mobile number of the alert contact.
   * 
   * @example
   * 1381111*****
   */
  phone?: string;
  /**
   * @remarks
   * Indicates whether the alert contact receives system notifications. Valid values:
   * 
   * *   true: receives system notifications.
   * *   false: does not receive system notifications.
   * 
   * @example
   * false
   */
  systemNoc?: boolean;
  /**
   * @remarks
   * The time when the alert contact group was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1580258717000
   */
  updateTime?: number;
  /**
   * @remarks
   * The ID of the user.
   * 
   * @example
   * 113197164949****
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      contactId: 'ContactId',
      contactName: 'ContactName',
      createTime: 'CreateTime',
      dingRobot: 'DingRobot',
      email: 'Email',
      phone: 'Phone',
      systemNoc: 'SystemNoc',
      updateTime: 'UpdateTime',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactId: 'number',
      contactName: 'string',
      createTime: 'number',
      dingRobot: 'string',
      email: 'string',
      phone: 'string',
      systemNoc: 'boolean',
      updateTime: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchAlertContactGroupResponseBodyContactGroups extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert contact group.
   * 
   * @example
   * 746
   */
  contactGroupId?: number;
  /**
   * @remarks
   * The name of the alert contact group.
   * 
   * @example
   * TestGroup
   */
  contactGroupName?: string;
  /**
   * @remarks
   * The alert contact list.
   */
  contacts?: SearchAlertContactGroupResponseBodyContactGroupsContacts[];
  /**
   * @remarks
   * The time when the alert contact group list was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1529668855000
   */
  createTime?: number;
  /**
   * @remarks
   * The time when the alert contact group was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1529668855000
   */
  updateTime?: number;
  /**
   * @remarks
   * The ID of the user.
   * 
   * @example
   * 113197164949****
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      contactGroupId: 'ContactGroupId',
      contactGroupName: 'ContactGroupName',
      contacts: 'Contacts',
      createTime: 'CreateTime',
      updateTime: 'UpdateTime',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contactGroupId: 'number',
      contactGroupName: 'string',
      contacts: { 'type': 'array', 'itemType': SearchAlertContactGroupResponseBodyContactGroupsContacts },
      createTime: 'number',
      updateTime: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchAlertHistoriesResponseBodyPageBeanAlarmHistories extends $tea.Model {
  /**
   * @remarks
   * The content of the alert notification.
   * 
   * @example
   * "Alert name: Alert1\\nAlert time: 2020-07-24 12:14:00\\nAlert content: A total of four alerts are triggered: \\*\\*\\*\\*"
   */
  alarmContent?: string;
  /**
   * @remarks
   * The response code returned after the alert notification was sent.
   * 
   * @example
   * 200
   */
  alarmResponseCode?: number;
  /**
   * @remarks
   * The webhook URL, such as the webhook URL of a DingTalk chatbot.
   * 
   * @example
   * https://oapi.dingtalk.com/robot/send?access_token=91f2f65002fefe0ab9b71e6590c5ca504348cad742ff01e9c8ab204439ca****
   */
  alarmSources?: string;
  /**
   * @remarks
   * The time when the alert notification was sent.
   * 
   * @example
   * 1595564179000
   */
  alarmTime?: number;
  /**
   * @remarks
   * The type of the alert rule. Default value: 4. Valid values:
   * 
   * *   `1`: a custom alert rule that is used to monitor drill-down data sets
   * *   `3`: a custom alert rule that is used to monitor tiled data sets
   * *   `4`: an alert rule that is used to monitor web pages, including the default alert rule for browser monitoring
   * *   `5`: an alert rule that is used to monitor applications, including the default alert rule for application monitoring
   * *   `6`: the default alert rule for browser monitoring
   * *   `7`: the default alert rule for application monitoring
   * *   `8`: a Tracing Analysis alert rule
   * *   `101`: a Prometheus alert rule
   * 
   * @example
   * 4
   */
  alarmType?: number;
  /**
   * @remarks
   * The email address of the alert contact.
   * 
   * @example
   * someone@example.com
   */
  emails?: string;
  /**
   * @remarks
   * The ID of the alert notification.
   * 
   * @example
   * 123
   */
  id?: number;
  /**
   * @remarks
   * The mobile phone number of the alert contact.
   * 
   * @example
   * 1381111****
   */
  phones?: string;
  /**
   * @remarks
   * The internal fields.
   * 
   * @example
   * ""
   */
  strategyId?: string;
  /**
   * @remarks
   * The internal fields.
   * 
   * @example
   * ""
   */
  target?: string;
  /**
   * @remarks
   * The ID of the user.
   * 
   * @example
   * 113197164949****
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      alarmContent: 'AlarmContent',
      alarmResponseCode: 'AlarmResponseCode',
      alarmSources: 'AlarmSources',
      alarmTime: 'AlarmTime',
      alarmType: 'AlarmType',
      emails: 'Emails',
      id: 'Id',
      phones: 'Phones',
      strategyId: 'StrategyId',
      target: 'Target',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmContent: 'string',
      alarmResponseCode: 'number',
      alarmSources: 'string',
      alarmTime: 'number',
      alarmType: 'number',
      emails: 'string',
      id: 'number',
      phones: 'string',
      strategyId: 'string',
      target: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchAlertHistoriesResponseBodyPageBean extends $tea.Model {
  /**
   * @remarks
   * The information about alert records.
   */
  alarmHistories?: SearchAlertHistoriesResponseBodyPageBeanAlarmHistories[];
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      alarmHistories: 'AlarmHistories',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmHistories: { 'type': 'array', 'itemType': SearchAlertHistoriesResponseBodyPageBeanAlarmHistories },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchAlertRulesRequestTags extends $tea.Model {
  /**
   * @remarks
   * The key of the tag. The following system preset fields are provided:
   * 
   * *   traceId: the ID of the trace.
   * *   serverApp: the name of the server application.
   * *   clientApp: the name of the client application.
   * *   service: the name of the operation.
   * *   rpc: the type of the call.
   * *   msOfSpan: the duration exceeds a specific value.
   * *   clientIp: the IP address of the client.
   * *   serverIp: the IP address of the server.
   * *   isError: specifies whether the call is abnormal.
   * *   hasTprof: contains only thread profiling.
   * 
   * @example
   * TestKey
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * TestValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext extends $tea.Model {
  /**
   * @remarks
   * The sub-title of the alert notification content.
   * 
   * @example
   * TestSubTitle
   */
  alarmContentSubTitle?: string;
  /**
   * @remarks
   * The template of the alert notification.
   * 
   * @example
   * Alert name: $Alert name\\nFilter condition: $Filter\\nAlert time: $Alert time\\nAlert content: $Alert content\\nNote: The alert persists until a reply email is received. The system will remind you again in 24 hours.
   */
  alarmContentTemplate?: string;
  /**
   * @remarks
   * The content of the alert notification.
   * 
   * @example
   * Alert name: $Alert name\\nFilter condition: $Filter\\nAlert time: $Alert time\\nAlert content: $Alert content\\nNote: The alert persists until a reply email is received. The system will remind you again in 24 hours.
   */
  content?: string;
  /**
   * @remarks
   * The sub-title of the alert notification.
   * 
   * @example
   * test
   */
  subTitle?: string;
  static names(): { [key: string]: string } {
    return {
      alarmContentSubTitle: 'AlarmContentSubTitle',
      alarmContentTemplate: 'AlarmContentTemplate',
      content: 'Content',
      subTitle: 'SubTitle',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmContentSubTitle: 'string',
      alarmContentTemplate: 'string',
      content: 'string',
      subTitle: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules extends $tea.Model {
  /**
   * @remarks
   * The aggregation logic of the metric data of the alert rule. Valid values:
   * 
   * *   `AVG`: calculates the average value for each minute
   * *   `SUM`: calculates the total value for each minute
   * *   `MAX`: calculates the maximum value for each minute
   * *   `MIN`: calculates the minimum value for each minute
   * 
   * @example
   * AVG
   */
  aggregates?: string;
  /**
   * @remarks
   * The displayed description of the alert metric.
   * 
   * @example
   * response time_ms
   */
  alias?: string;
  /**
   * @remarks
   * The metric based on which alerts are triggered. For more information, see the "[Alert metrics](https://help.aliyun.com/document_detail/175825.html#h2-url-4)" section in this topic.
   * 
   * @example
   * appstat.jvm.SystemDiskFree
   */
  measure?: string;
  /**
   * @remarks
   * The time range when data is requested. Unit: minutes. For example, a value of 5 indicates that the alert rule applies to the data in the last 5 minutes.
   * 
   * @example
   * 5
   */
  NValue?: number;
  /**
   * @remarks
   * The operation logic of the condition. Valid values:
   * 
   * *   CURRENT_GTE: greater than or equal to
   * *   CURRENT_LTE: less than or equal to
   * *   PREVIOUS_UP: the increase percentage compared with the last period
   * *   PREVIOUS_DOWN: the decrease percentage compared with the last period
   * *   HOH_UP: the increase percentage compared with the last hour
   * *   HOH_DOWN: the decrease percentage compared with the last hour
   * *   DOD_UP: the increase percentage compared with the last day
   * *   DOD_DOWN: the decrease percentage compared with the last day
   * 
   * @example
   * CURRENT_GTE
   */
  operator?: string;
  /**
   * @remarks
   * The threshold of the condition.
   * 
   * @example
   * 30
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      aggregates: 'Aggregates',
      alias: 'Alias',
      measure: 'Measure',
      NValue: 'NValue',
      operator: 'Operator',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aggregates: 'string',
      alias: 'string',
      measure: 'string',
      NValue: 'number',
      operator: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule extends $tea.Model {
  /**
   * @remarks
   * The logical operator between conditions. Valid values: `&`: AND. `|`: OR.
   * 
   * @example
   * |
   */
  operator?: string;
  /**
   * @remarks
   * The condition of the alert rule.
   */
  rules?: SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules[];
  static names(): { [key: string]: string } {
    return {
      operator: 'Operator',
      rules: 'Rules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operator: 'string',
      rules: { 'type': 'array', 'itemType': SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions extends $tea.Model {
  /**
   * @remarks
   * The key of the dimension. Valid values:
   * 
   * *   `rpc`: the name of the API
   * *   `rpcType`: the type of the API call, such as HTTP or DUBBO
   * *   `endpoint`: the name of the database
   * *   `rootIp`: the IP address of the host
   * 
   * @example
   * rootIp
   */
  key?: string;
  /**
   * @remarks
   * The type of the dimension. Valid values:
   * 
   * *   `STATIC`: checks only the value of this dimension. In this case, you must set the **dimensions.value** parameter.
   * *   `ALL`: checks the values of all dimensions. The metrics of all API calls are checked. If an API call triggers an alert, the name of the API is displayed in the alert notification. In this case, you do not need to set the **dimensions.value** parameter.
   * *   `DISABLE`: aggregates the values of all dimensions. In this case, you do not need to set the **dimensions.value** parameter.
   * 
   * @example
   * DISABLE
   */
  type?: string;
  /**
   * @remarks
   * The value of the dimension.
   * 
   * @example
   * "127.0.0.1"
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam extends $tea.Model {
  /**
   * @remarks
   * The ID of the application group that is associated with the alert rule. This parameter is applicable to Enterprise Distributed Application Service (EDAS) applications.
   * 
   * @example
   * DEFAULT
   */
  appGroupId?: string;
  /**
   * @remarks
   * The auto-increment ID of the ARMS application. You can ignore this ID.
   * 
   * @example
   * 123
   */
  appId?: string;
  /**
   * @remarks
   * The dimensions in the condition.
   */
  dimensions?: SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions[];
  /**
   * @remarks
   * The PID of the application that is associated with the alert rule.
   * 
   * @example
   * 9870ca99-8105-4da7-a3a4-d72dd1b1****
   */
  pid?: string;
  /**
   * @remarks
   * The type of the metric. Valid values:
   * 
   * *   `txn`: the number of API calls during application monitoring
   * *   `txn_type`: the types of API calls during application monitoring
   * *   `db`: database metrics
   * *   `jvm`: Java virtual machine (JVM) metrics
   * *   `host`: host metrics
   * *   `exception`: API call errors
   * 
   * @example
   * DB
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      appGroupId: 'AppGroupId',
      appId: 'AppId',
      dimensions: 'Dimensions',
      pid: 'Pid',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appGroupId: 'string',
      appId: 'string',
      dimensions: { 'type': 'array', 'itemType': SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions },
      pid: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchAlertRulesResponseBodyPageBeanAlertRulesNotice extends $tea.Model {
  /**
   * @remarks
   * The end of the time range when the alert rule takes effect within 24 hours per day. This value is a UNIX timestamp. The year, month, and day that are indicated by the timestamp are not displayed in this value. Only the hour, minute, and second are displayed.
   * 
   * @example
   * 1480607940000
   */
  endTime?: number;
  /**
   * @remarks
   * The end of the time range when alert notifications are sent based on the alert rule within 24 hours per day. This value is a UNIX timestamp. The year, month, and day that are indicated by the timestamp are not displayed in this value. Only the hour, minute, and second are displayed.
   * 
   * @example
   * 1480607940000
   */
  noticeEndTime?: number;
  /**
   * @remarks
   * The beginning of the time range when alert notifications are sent based on the alert rule within 24 hours per day. This value is a UNIX timestamp. The year, month, and day that are indicated by the timestamp are not displayed in this value. Only the hour, minute, and second are displayed.
   * 
   * @example
   * 1480521600000
   */
  noticeStartTime?: number;
  /**
   * @remarks
   * The beginning of the time range when the alert rule takes effect within 24 hours per day. This value is a UNIX timestamp. The year, month, and day that are indicated by the timestamp are not displayed in this value. Only the hour, minute, and second are displayed.
   * 
   * @example
   * 1480521600000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      noticeEndTime: 'NoticeEndTime',
      noticeStartTime: 'NoticeStartTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      noticeEndTime: 'number',
      noticeStartTime: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchAlertRulesResponseBodyPageBeanAlertRules extends $tea.Model {
  /**
   * @remarks
   * The format of the alert notification.
   */
  alarmContext?: SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext;
  /**
   * @remarks
   * The severity of the alerts. Only the value `WARN` is supported.
   * 
   * @example
   * WARN
   */
  alertLevel?: string;
  /**
   * @remarks
   * The conditions of the alert rule. Multiple conditions are separated by the AND or OR logical operators.
   */
  alertRule?: SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule;
  /**
   * @remarks
   * The name of the alert rule.
   * 
   * @example
   * TestAlertRule
   */
  alertTitle?: string;
  /**
   * @remarks
   * The type of the alert rule. Valid values:
   * 
   * *   `1`: custom alert rules that are used to monitor drill-down data sets
   * *   `3`: custom alert rules that are used to monitor tiled data sets
   * *   `4`: alert rules that are used to monitor the browser, including the default frontend alert rules
   * *   `5`: alert rules that are used to monitor applications, including the default application alert rules
   * *   `6`: the default browser alert rules
   * *   `7`: the default application alert rules
   * *   `8`: Tracing Analysis alert rules
   * *   `101`: Prometheus alert rules
   * 
   * @example
   * 4
   */
  alertType?: number;
  /**
   * @remarks
   * The version of the alert rule. Default value: `1`.
   * 
   * @example
   * 1
   */
  alertVersion?: number;
  /**
   * @remarks
   * Sending method of alarm notification.
   */
  alertWays?: string[];
  /**
   * @remarks
   * The configuration items of the alert rule. The value is a JSON string.
   * 
   * The configuration item **continuous** indicates whether alert notifications are continuously sent. Valid values:
   * 
   * *   `true`: Alert notifications are sent every minute.
   * *   `false`: The alert silence feature is enabled.
   * 
   * The configuration item **dataRevision** indicates the data revision policy that is used if no data is obtained or the data is null. Default value: 2. Valid values:
   * 
   * *   `0`: overwrites the data by using the value 0
   * *   `1`: overwrites the data by using the value 1
   * *   `2`: overwrites the data by using the value null. This value indicates that no alert is triggered if no data exists
   * 
   * @example
   * {\\"continuous\\":true,\\"dataRevision\\":2}
   */
  config?: string;
  /**
   * @remarks
   * The ID of the contact group. Multiple IDs are separated by commas (,).
   * 
   * @example
   * 381*,572*
   */
  contactGroupIdList?: string;
  /**
   * @remarks
   * The IDs of the alert contact groups. The value is a JSON array.
   * 
   * @example
   * [123, 234]
   */
  contactGroupIds?: string;
  /**
   * @remarks
   * The timestamp that shows when the alert rule was created.
   * 
   * @example
   * 1579508519683
   */
  createTime?: number;
  /**
   * @remarks
   * Indicates whether the alert is sent through the alert center. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  hostByAlertManager?: boolean;
  /**
   * @remarks
   * The ID of the alert rule.
   * 
   * @example
   * 123
   */
  id?: number;
  /**
   * @remarks
   * The information about the application that is associated with the alert rule.
   */
  metricParam?: SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam;
  /**
   * @remarks
   * The time ranges when the alert rule takes effect and when alert notifications are sent.
   */
  notice?: SearchAlertRulesResponseBodyPageBeanAlertRulesNotice;
  /**
   * @remarks
   * The ID of the region to which the alert rule belongs.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The status of the alert rule. `RUNNING`: The alert rule is enabled. `STOPPED`: The alert rule is disabled.
   * 
   * @example
   * RUNNING
   */
  status?: string;
  /**
   * @remarks
   * The ID of the Application Real-Time Monitoring Service (ARMS) task that is associated with the alert rule.
   * 
   * @example
   * 123
   */
  taskId?: number;
  /**
   * @remarks
   * The status of the task. This parameter is hidden from users.
   * 
   * @example
   * ""
   */
  taskStatus?: string;
  /**
   * @remarks
   * The name of the alert.
   * 
   * @example
   * AlertTest
   */
  title?: string;
  /**
   * @remarks
   * The timestamp that shows when the alert rule was updated.
   * 
   * @example
   * 1480521600000
   */
  updateTime?: number;
  /**
   * @remarks
   * The ID of the user to which the alert rule belongs.
   * 
   * @example
   * 113197164949****
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      alarmContext: 'AlarmContext',
      alertLevel: 'AlertLevel',
      alertRule: 'AlertRule',
      alertTitle: 'AlertTitle',
      alertType: 'AlertType',
      alertVersion: 'AlertVersion',
      alertWays: 'AlertWays',
      config: 'Config',
      contactGroupIdList: 'ContactGroupIdList',
      contactGroupIds: 'ContactGroupIds',
      createTime: 'CreateTime',
      hostByAlertManager: 'HostByAlertManager',
      id: 'Id',
      metricParam: 'MetricParam',
      notice: 'Notice',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      status: 'Status',
      taskId: 'TaskId',
      taskStatus: 'TaskStatus',
      title: 'Title',
      updateTime: 'UpdateTime',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmContext: SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext,
      alertLevel: 'string',
      alertRule: SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule,
      alertTitle: 'string',
      alertType: 'number',
      alertVersion: 'number',
      alertWays: { 'type': 'array', 'itemType': 'string' },
      config: 'string',
      contactGroupIdList: 'string',
      contactGroupIds: 'string',
      createTime: 'number',
      hostByAlertManager: 'boolean',
      id: 'number',
      metricParam: SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam,
      notice: SearchAlertRulesResponseBodyPageBeanAlertRulesNotice,
      regionId: 'string',
      resourceGroupId: 'string',
      status: 'string',
      taskId: 'number',
      taskStatus: 'string',
      title: 'string',
      updateTime: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchAlertRulesResponseBodyPageBean extends $tea.Model {
  /**
   * @remarks
   * The details of the alert rules.
   */
  alertRules?: SearchAlertRulesResponseBodyPageBeanAlertRules[];
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 23
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      alertRules: 'AlertRules',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertRules: { 'type': 'array', 'itemType': SearchAlertRulesResponseBodyPageBeanAlertRules },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchEventsResponseBodyPageBeanEvent extends $tea.Model {
  /**
   * @remarks
   * The ID of the alert rule that is associated with the event.
   * 
   * @example
   * 123
   */
  alertId?: number;
  /**
   * @remarks
   * The name of the alert rule that is associated with the event.
   * 
   * @example
   * alertName
   */
  alertName?: string;
  /**
   * @remarks
   * The condition of the alert rule.
   * 
   * @example
   * {\\"operator\\":\\"&\\",\\"rules\\":[{\\"aggregates\\":\\"AVG\\",\\"alias\\":\\"JVM_线程总数\\",\\"measure\\":\\"appstat.jvm.ThreadCount\\",\\"nValue\\":1,\\"operator\\":\\"HOH_DOWN\\",\\"value\\":50.0}]}
   */
  alertRule?: string;
  /**
   * @remarks
   * The type of the alert rule. This parameter is not returned. Valid values:
   * 
   * *   `1`: custom alert rules to monitor drill-down data sets
   * *   `3`: custom alert rules to monitor tiled data sets
   * *   `4`: alert rules to monitor the frontend, including the default frontend alert rules
   * *   `5`: alert rules to monitor applications, including the default application alert rules
   * *   `6`: the default frontend alert rules
   * *   `7`: the default application alert rules
   * *   `8`: Tracing Analysis alert rules
   * *   `101`: Prometheus alert rules
   * 
   * @example
   * 4
   */
  alertType?: number;
  /**
   * @remarks
   * The severity of the event.
   * 
   * @example
   * 1
   */
  eventLevel?: string;
  /**
   * @remarks
   * The timestamp when the event occurred.
   * 
   * @example
   * 1595569020000
   */
  eventTime?: number;
  /**
   * @remarks
   * The ID of the event record.
   * 
   * @example
   * 123
   */
  id?: number;
  /**
   * @remarks
   * The list of event URLs.
   */
  links?: string[];
  /**
   * @remarks
   * The event content. The parameter value is a JSON string. Each key indicates a dimension and each value indicates the alert content in the dimension.
   * 
   * @example
   * unknow紧急报警\\nip：172.27.XX.XX\\n应用名 = test\\nRegion = cn-shenzhen\\n异常信息 = {\\"timestamp\\"：\\"1615447972235\\"}
   */
  message?: string;
  static names(): { [key: string]: string } {
    return {
      alertId: 'AlertId',
      alertName: 'AlertName',
      alertRule: 'AlertRule',
      alertType: 'AlertType',
      eventLevel: 'EventLevel',
      eventTime: 'EventTime',
      id: 'Id',
      links: 'Links',
      message: 'Message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertId: 'number',
      alertName: 'string',
      alertRule: 'string',
      alertType: 'number',
      eventLevel: 'string',
      eventTime: 'number',
      id: 'number',
      links: { 'type': 'array', 'itemType': 'string' },
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchEventsResponseBodyPageBean extends $tea.Model {
  /**
   * @remarks
   * The information about the alert events.
   */
  event?: SearchEventsResponseBodyPageBeanEvent[];
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      event: 'Event',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      event: { 'type': 'array', 'itemType': SearchEventsResponseBodyPageBeanEvent },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchRetcodeAppByPageRequestTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * TestKey
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * TestValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * TestKey
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * TestValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps extends $tea.Model {
  /**
   * @remarks
   * The ID of the application. The parameter is an auto-increment parameter.
   * 
   * @example
   * 16064
   */
  appId?: number;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * a3
   */
  appName?: string;
  /**
   * @remarks
   * The time when the task was created.
   * 
   * @example
   * 1545363321000
   */
  createTime?: number;
  /**
   * @remarks
   * The alias of the application.
   * 
   * @example
   * c1
   */
  nickName?: string;
  /**
   * @remarks
   * The process identifier (PID) of the application.
   * 
   * @example
   * eb4zdose6v@9781be0f44d****
   */
  pid?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The type of the application. Valid values:
   * 
   * *   `web`: web application
   * *   `weex`: Weex mobile app
   * *   `mini_dd`: DingTalk mini program
   * *   `mini_alipay`: Alipay mini program
   * *   `mini_wx`: WeChat mini program
   * *   `mini_common`: mini program on other platforms
   * 
   * @example
   * web
   */
  retcodeAppType?: string;
  /**
   * @remarks
   * The tag.
   */
  tags?: SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags[];
  /**
   * @remarks
   * The type of the monitoring task. Valid values:
   * 
   * *   `TRACE`: Application Monitoring
   * *   `RETCODE`: Browser Monitoring
   * 
   * @example
   * RETCODE
   */
  type?: string;
  /**
   * @remarks
   * The time when the task was updated.
   * 
   * @example
   * 1545363321000
   */
  updateTime?: number;
  /**
   * @remarks
   * The user ID.
   * 
   * @example
   * 12341234
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      createTime: 'CreateTime',
      nickName: 'NickName',
      pid: 'Pid',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      retcodeAppType: 'RetcodeAppType',
      tags: 'Tags',
      type: 'Type',
      updateTime: 'UpdateTime',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'number',
      appName: 'string',
      createTime: 'number',
      nickName: 'string',
      pid: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      retcodeAppType: 'string',
      tags: { 'type': 'array', 'itemType': SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags },
      type: 'string',
      updateTime: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchRetcodeAppByPageResponseBodyPageBean extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 2
   */
  pageSize?: number;
  /**
   * @remarks
   * The browser monitoring tasks that are returned.
   */
  retcodeApps?: SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps[];
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 8
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      retcodeApps: 'RetcodeApps',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      retcodeApps: { 'type': 'array', 'itemType': SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTraceAppByNameRequestTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * TestKey
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * TestValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTraceAppByNameResponseBodyTraceAppsTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * TestKey
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * TestValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTraceAppByNameResponseBodyTraceApps extends $tea.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * 123
   */
  appId?: number;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * test-app
   */
  appName?: string;
  /**
   * @remarks
   * The timestamp generated when the task was created.
   * 
   * @example
   * 1593486786000
   */
  createTime?: number;
  /**
   * @remarks
   * The aliases of the application.
   */
  labels?: string[];
  /**
   * @remarks
   * The process identifier (PID) of the application.
   * 
   * @example
   * a5f9bdeb-2627-4dbe-9247-****
   */
  pid?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * Indicates whether the application is displayed in the Application Real-Time Monitoring Service (ARMS) console. Valid values:
   * 
   * *   `true`: yes
   * *   `false`: no
   * 
   * @example
   * true
   */
  show?: boolean;
  /**
   * @remarks
   * A list of tags.
   */
  tags?: SearchTraceAppByNameResponseBodyTraceAppsTags[];
  /**
   * @remarks
   * The type of the monitoring task. Valid values:
   * 
   * *   `TRACE`: Application Monitoring
   * *   `RETCODE`: Browser Monitoring
   * 
   * @example
   * TRACE
   */
  type?: string;
  /**
   * @remarks
   * The timestamp generated when the task information was updated.
   * 
   * @example
   * 1593486786000
   */
  updateTime?: number;
  /**
   * @remarks
   * The user ID.
   * 
   * @example
   * 113197164949****
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      createTime: 'CreateTime',
      labels: 'Labels',
      pid: 'Pid',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      show: 'Show',
      tags: 'Tags',
      type: 'Type',
      updateTime: 'UpdateTime',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'number',
      appName: 'string',
      createTime: 'number',
      labels: { 'type': 'array', 'itemType': 'string' },
      pid: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      show: 'boolean',
      tags: { 'type': 'array', 'itemType': SearchTraceAppByNameResponseBodyTraceAppsTags },
      type: 'string',
      updateTime: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTraceAppByPageRequestTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * TestKey
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * TestValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * TestKey
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * TestValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTraceAppByPageResponseBodyPageBeanTraceApps extends $tea.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * 123
   */
  appId?: number;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * test-app
   */
  appName?: string;
  /**
   * @remarks
   * The timestamp generated when the task was created.
   * 
   * @example
   * 1531291867000
   */
  createTime?: number;
  /**
   * @remarks
   * The aliases of the application.
   */
  labels?: string[];
  /**
   * @remarks
   * The process identifier (PID) of the application.
   * 
   * @example
   * atc889zkcf@d8deedfa9bf****
   */
  pid?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The resource group ID.
   * 
   * @example
   * rg-acfmxyexli2****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * Indicates whether the application is displayed in the Application Real-Time Monitoring Service (ARMS) console. Valid values:
   * 
   * *   `true`: yes
   * *   `false`: no
   * 
   * @example
   * true
   */
  show?: boolean;
  /**
   * @remarks
   * A list of tags.
   */
  tags?: SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags[];
  /**
   * @remarks
   * The type of the monitoring task. Valid values:
   * 
   * *   `TRACE`: Application Monitoring
   * *   `RETCODE`: Browser Monitoring
   * 
   * @example
   * TRACE
   */
  type?: string;
  /**
   * @remarks
   * The timestamp generated when the task information was updated.
   * 
   * @example
   * 1531291867000
   */
  updateTime?: number;
  /**
   * @remarks
   * The user ID.
   * 
   * @example
   * 113197164949****
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      createTime: 'CreateTime',
      labels: 'Labels',
      pid: 'Pid',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      show: 'Show',
      tags: 'Tags',
      type: 'Type',
      updateTime: 'UpdateTime',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'number',
      appName: 'string',
      createTime: 'number',
      labels: { 'type': 'array', 'itemType': 'string' },
      pid: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      show: 'boolean',
      tags: { 'type': 'array', 'itemType': SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags },
      type: 'string',
      updateTime: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTraceAppByPageResponseBodyPageBean extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 3
   */
  totalCount?: number;
  /**
   * @remarks
   * The information about the monitoring task.
   */
  traceApps?: SearchTraceAppByPageResponseBodyPageBeanTraceApps[];
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
      traceApps: 'TraceApps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
      traceApps: { 'type': 'array', 'itemType': SearchTraceAppByPageResponseBodyPageBeanTraceApps },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTracesRequestExclusionFilters extends $tea.Model {
  /**
   * @remarks
   * The key that is used to filter the query results.
   * 
   * @example
   * http.status_code
   */
  key?: string;
  /**
   * @remarks
   * The value of the key that is used to filter the query results.
   * 
   * @example
   * 404
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTracesRequestTag extends $tea.Model {
  /**
   * @remarks
   * The tag key. The following system preset fields are provided:
   * 
   * *   serverApp: the name of the server application.
   * *   clientApp: the name of the client application.
   * *   service: the name of the operation.
   * *   rpc: the type of the call.
   * *   msOfSpan: the duration exceeds a specific value.
   * *   clientIp: the IP address of the client.
   * *   serverIp: the IP address of the server.
   * *   isError: specifies whether the call is abnormal.
   * *   hasTprof: contains only thread profiling.
   * 
   * @example
   * http.status_code
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * 200
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTracesResponseBodyTraceInfos extends $tea.Model {
  /**
   * @remarks
   * The amount of time consumed by the trace. Unit: milliseconds.
   * 
   * @example
   * 6
   */
  duration?: number;
  /**
   * @remarks
   * The name of the traced span.
   * 
   * @example
   * get***
   */
  operationName?: string;
  /**
   * @remarks
   * The IP address of the host where the application resides.
   * 
   * @example
   * ``172.20.**.**``
   */
  serviceIp?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * arms-k8s-demo-subcomponent
   */
  serviceName?: string;
  /**
   * @remarks
   * The timestamp.
   * 
   * @example
   * 1595174436993
   */
  timestamp?: number;
  /**
   * @remarks
   * The trace ID.
   * 
   * @example
   * ac1400a115951744369937024d****
   */
  traceID?: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
      operationName: 'OperationName',
      serviceIp: 'ServiceIp',
      serviceName: 'ServiceName',
      timestamp: 'Timestamp',
      traceID: 'TraceID',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'number',
      operationName: 'string',
      serviceIp: 'string',
      serviceName: 'string',
      timestamp: 'number',
      traceID: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTracesByPageRequestExclusionFilters extends $tea.Model {
  /**
   * @remarks
   * The key that is used to filter the query results.
   * 
   * @example
   * http.status_code
   */
  key?: string;
  /**
   * @remarks
   * The value of the key that is used to filter the query results.
   * 
   * @example
   * 404
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTracesByPageRequestTags extends $tea.Model {
  /**
   * @remarks
   * The key of the tag. The following system preset fields are provided:
   * 
   * *   traceId: the ID of the trace.
   * *   serverApp: the name of the server application.
   * *   clientApp: the name of the client application.
   * *   service: the name of the interface.
   * *   rpc: the type of the call.
   * *   msOfSpan: the duration exceeds a specific value.
   * *   clientIp: the IP address of the client.
   * *   serverIp: the IP address of the server.
   * *   isError: specifies whether the call is abnormal.
   * 
   * @example
   * http.status_code
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * 200
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTracesByPageResponseBodyPageBeanTraceInfos extends $tea.Model {
  /**
   * @remarks
   * The amount of time consumed by the trace. Unit: milliseconds.
   * 
   * @example
   * 679
   */
  duration?: number;
  /**
   * @remarks
   * The name of the traced span.
   * 
   * @example
   * /demo/queryException/12
   */
  operationName?: string;
  /**
   * @remarks
   * The IP address of the host where the application resides.
   * 
   * @example
   * 172.20.XX.XX
   */
  serviceIp?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * arms-k8s-demo-subcomponent
   */
  serviceName?: string;
  /**
   * @remarks
   * The timestamp.
   * 
   * @example
   * 1595174436994
   */
  timestamp?: number;
  /**
   * @remarks
   * The trace ID.
   * 
   * @example
   * ac1400a115951744369947025d****
   */
  traceID?: string;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
      operationName: 'OperationName',
      serviceIp: 'ServiceIp',
      serviceName: 'ServiceName',
      timestamp: 'Timestamp',
      traceID: 'TraceID',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'number',
      operationName: 'string',
      serviceIp: 'string',
      serviceName: 'string',
      timestamp: 'number',
      traceID: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTracesByPageResponseBodyPageBean extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 5
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 1601
   */
  total?: number;
  /**
   * @remarks
   * The details of the returned traces.
   */
  traceInfos?: SearchTracesByPageResponseBodyPageBeanTraceInfos[];
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      total: 'Total',
      traceInfos: 'TraceInfos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      total: 'number',
      traceInfos: { 'type': 'array', 'itemType': SearchTracesByPageResponseBodyPageBeanTraceInfos },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * Key1
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * Test1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesRequestTags extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * TestKey
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * TestValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEnvPodMonitorResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * Indicates whether targets are matched.
   * 
   * @example
   * Match successful.
   */
  matchedMsg?: string;
  /**
   * @remarks
   * The number of matched targets.
   * 
   * @example
   * 1
   */
  matchedTargetCount?: string;
  static names(): { [key: string]: string } {
    return {
      matchedMsg: 'MatchedMsg',
      matchedTargetCount: 'MatchedTargetCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      matchedMsg: 'string',
      matchedTargetCount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEnvServiceMonitorResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * Indicates whether targets are matched.
   * 
   * @example
   * Match successful.
   */
  matchedMsg?: string;
  /**
   * @remarks
   * The number of matched targets.
   * 
   * @example
   * 1
   */
  matchedTargetCount?: string;
  static names(): { [key: string]: string } {
    return {
      matchedMsg: 'MatchedMsg',
      matchedTargetCount: 'MatchedTargetCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      matchedMsg: 'string',
      matchedTargetCount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateIntegrationResponseBodyIntegration extends $tea.Model {
  /**
   * @remarks
   * The endpoint of the alert integration.
   * 
   * @example
   * https://alerts.aliyuncs.com/api/v1/integrations/custom/ymQBN******
   */
  apiEndpoint?: string;
  /**
   * @remarks
   * Indicates whether alert events are automatically cleared. Valid values:
   * 
   * *   true (default)
   * *   false
   * 
   * @example
   * true
   */
  autoRecover?: boolean;
  /**
   * @remarks
   * The description of the alert integration.
   * 
   * @example
   * Test
   */
  description?: string;
  /**
   * @remarks
   * The fields whose values are deduplicated.
   * 
   * @example
   * LABEL.dimensions::LABEL.ruleId
   */
  duplicateKey?: string;
  /**
   * @remarks
   * The extended mapped fields of the alert source.
   */
  extendedFieldRedefineRules?: { [key: string]: any }[];
  /**
   * @remarks
   * The predefined mapped fields of the alert source.
   */
  fieldRedefineRules?: { [key: string]: any }[];
  /**
   * @remarks
   * The field for clearing alert events. The system queries alert events based on the field of alert clearing events and clears the alert events.
   * 
   * > Only Log Service supports this parameter.
   * 
   * @example
   * $.status
   */
  initiativeRecoverField?: string;
  /**
   * @remarks
   * The value of the field for clearing alert events. The system queries alert events based on the field of alert clearing events and clears the alert events.
   * 
   * > Only Log Service supports this parameter.
   * 
   * @example
   * ok
   */
  initiativeRecoverValue?: string;
  /**
   * @remarks
   * The ID of the alert integration.
   * 
   * @example
   * 1234
   */
  integrationId?: number;
  /**
   * @remarks
   * The name of the alert integration.
   * 
   * @example
   * CloudMonitor integration
   */
  integrationName?: string;
  /**
   * @remarks
   * The service of the alert integration. Valid values:
   * 
   * *   CLOUD_MONITOR: CloudMonitor
   * *   LOG_SERVICE: Log Service
   * 
   * @example
   * CLOUD_MONITOR
   */
  integrationProductType?: string;
  /**
   * @remarks
   * The activity of the alert integration
   * 
   * @example
   * ready
   */
  liveness?: string;
  /**
   * @remarks
   * The time when alert events are automatically cleared. Unit: seconds. Default value: 300.
   * 
   * @example
   * 300
   */
  recoverTime?: number;
  /**
   * @remarks
   * The authentication token of the alert integration.
   * 
   * @example
   * ymQBN******
   */
  shortToken?: string;
  /**
   * @remarks
   * The total number of alert events and the number of abnormal alert events in the last hour.
   */
  stat?: number[];
  /**
   * @remarks
   * Indicates whether the alert integration is enabled. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  state?: boolean;
  static names(): { [key: string]: string } {
    return {
      apiEndpoint: 'ApiEndpoint',
      autoRecover: 'AutoRecover',
      description: 'Description',
      duplicateKey: 'DuplicateKey',
      extendedFieldRedefineRules: 'ExtendedFieldRedefineRules',
      fieldRedefineRules: 'FieldRedefineRules',
      initiativeRecoverField: 'InitiativeRecoverField',
      initiativeRecoverValue: 'InitiativeRecoverValue',
      integrationId: 'IntegrationId',
      integrationName: 'IntegrationName',
      integrationProductType: 'IntegrationProductType',
      liveness: 'Liveness',
      recoverTime: 'RecoverTime',
      shortToken: 'ShortToken',
      stat: 'Stat',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiEndpoint: 'string',
      autoRecover: 'boolean',
      description: 'string',
      duplicateKey: 'string',
      extendedFieldRedefineRules: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
      fieldRedefineRules: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
      initiativeRecoverField: 'string',
      initiativeRecoverValue: 'string',
      integrationId: 'number',
      integrationName: 'string',
      integrationProductType: 'string',
      liveness: 'string',
      recoverTime: 'number',
      shortToken: 'string',
      stat: { 'type': 'array', 'itemType': 'number' },
      state: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrometheusAlertRuleRequestTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * TestKey
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * TestValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations extends $tea.Model {
  /**
   * @example
   * message
   */
  name?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels extends $tea.Model {
  /**
   * @example
   * severity
   */
  name?: string;
  /**
   * @example
   * critical
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule extends $tea.Model {
  /**
   * @example
   * 3888704
   */
  alertId?: number;
  /**
   * @example
   * Prometheus_Alert
   */
  alertName?: string;
  annotations?: UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations[];
  /**
   * @example
   * c0bad479465464e1d8c1e641b0afb****
   */
  clusterId?: string;
  /**
   * @example
   * 10282
   */
  dispatchRuleId?: number;
  /**
   * @example
   * 1
   */
  duration?: string;
  /**
   * @example
   * 100 * (sum(rate(container_cpu_usage_seconds_total[1m])) by (pod_name) / sum(label_replace(kube_pod_container_resource_limits_cpu_cores, \\"pod_name\\", \\"$1\\", \\"pod\\", \\"(.*)\\")) by (pod_name))>75
   */
  expression?: string;
  labels?: UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels[];
  message?: string;
  /**
   * @example
   * ALERT_MANAGER
   */
  notifyType?: string;
  /**
   * @example
   * 1
   */
  status?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      alertId: 'AlertId',
      alertName: 'AlertName',
      annotations: 'Annotations',
      clusterId: 'ClusterId',
      dispatchRuleId: 'DispatchRuleId',
      duration: 'Duration',
      expression: 'Expression',
      labels: 'Labels',
      message: 'Message',
      notifyType: 'NotifyType',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertId: 'number',
      alertName: 'string',
      annotations: { 'type': 'array', 'itemType': UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations },
      clusterId: 'string',
      dispatchRuleId: 'number',
      duration: 'string',
      expression: 'string',
      labels: { 'type': 'array', 'itemType': UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels },
      message: 'string',
      notifyType: 'string',
      status: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrometheusGlobalViewResponseBodyDataFailedInstances extends $tea.Model {
  /**
   * @remarks
   * The ID of the Prometheus instance.
   * 
   * @example
   * cdb65ed2d527345*********
   */
  clusterId?: string;
  /**
   * @remarks
   * The name of the data source.
   * 
   * @example
   * sourcename-test
   */
  sourceName?: string;
  /**
   * @remarks
   * The type of the data source. AlibabaPrometheus MetricStore CustomPrometheus
   * 
   * @example
   * AlibabaPrometheus
   */
  sourceType?: string;
  /**
   * @remarks
   * The user ID.
   * 
   * @example
   * 23784673825*******
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      sourceName: 'SourceName',
      sourceType: 'SourceType',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      sourceName: 'string',
      sourceType: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrometheusGlobalViewResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The data sources that failed to be updated.
   */
  failedInstances?: UpdatePrometheusGlobalViewResponseBodyDataFailedInstances[];
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   `true`
   * *   `false`
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      failedInstances: 'FailedInstances',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failedInstances: { 'type': 'array', 'itemType': UpdatePrometheusGlobalViewResponseBodyDataFailedInstances },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePrometheusIntegrationResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The exporter ID.
   * 
   * @example
   * 2866
   */
  instanceId?: number;
  /**
   * @remarks
   * The exporter name.
   * 
   * @example
   * inet
   */
  instanceName?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'number',
      instanceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRumAppResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The user configurations. This is a reserved parameter.
   * 
   * @example
   * null
   */
  config?: string;
  /**
   * @remarks
   * The QPS limit. Unit: bytes.
   * 
   * @example
   * 100000
   */
  limit?: number;
  /**
   * @remarks
   * Indicates whether the request is throttled due to the QPS limit. Valid values: true and false.
   * 
   * @example
   * true
   */
  limited?: boolean;
  /**
   * @remarks
   * The usage. Unit: bytes.
   * 
   * @example
   * 10000
   */
  usage?: number;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      limit: 'Limit',
      limited: 'Limited',
      usage: 'Usage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      limit: 'number',
      limited: 'boolean',
      usage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTimingSyntheticTaskRequestAvailableAssertions extends $tea.Model {
  /**
   * @remarks
   * The expected value.
   * 
   * @example
   * 200
   */
  expect?: string;
  /**
   * @remarks
   * The condition. gt: greater than. gte: greater than or equal to. lt: less than. lte: less than or equal to. eq: equal to. neq: not equal to. ctn: contain. nctn: does not contain. exist: exist. n_exist: does not exist. belong: belong to. n_belong: does not belong to. reg_match: regular expression.
   * 
   * @example
   * eq
   */
  operator?: string;
  /**
   * @remarks
   * The check target. If you set the type parameter to HttpResCode, HttpResBody, or HttpResponseTime, you do not need to set the target parameter. If you set the type parameter to HttpResHead, you must specify the key in the header. If you set the type parameter to HttpResBodyJson, use jsonPath.
   * 
   * @example
   * HttpResponseTime
   */
  target?: string;
  /**
   * @remarks
   * The assertion type. Valid values: HttpResCode, HttpResHead, HttpResBody, HttpResBodyJson, HttpResponseTime, IcmpPackLoss (packet loss rate), IcmpPackMaxLatency (maximum packet latency), IcmpPackAvgLatency (average packet latency), TraceRouteHops (number of hops), DnsARecord (A record), DnsCName (CNAME), websiteTTFB (time to first packet), websiteTTLB (time to last packet), websiteFST (first paint time), websiteFFST (first meaningful paint), websiteOnload (full loaded time). For more information, see the following description.
   * 
   * @example
   * TraceRouteHops
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      expect: 'Expect',
      operator: 'Operator',
      target: 'Target',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expect: 'string',
      operator: 'string',
      target: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTimingSyntheticTaskRequestCommonSettingCustomHostHosts extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * www.aliyun.com
   */
  domain?: string;
  /**
   * @remarks
   * The IP version. Valid values:
   * 
   * *   0: A version is automatically selected.
   * *   1: IPv4
   * *   2: IPv6
   * 
   * @example
   * 0
   */
  ipType?: number;
  /**
   * @remarks
   * The list of IP addresses.
   */
  ips?: string[];
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      ipType: 'IpType',
      ips: 'Ips',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      ipType: 'number',
      ips: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTimingSyntheticTaskRequestCommonSettingCustomHost extends $tea.Model {
  /**
   * @remarks
   * The list of hosts.
   */
  hosts?: UpdateTimingSyntheticTaskRequestCommonSettingCustomHostHosts[];
  /**
   * @remarks
   * The selection mode. Valid values:
   * 
   * *   0: random
   * *   1: polling
   * 
   * @example
   * 0
   */
  selectType?: number;
  static names(): { [key: string]: string } {
    return {
      hosts: 'Hosts',
      selectType: 'SelectType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hosts: { 'type': 'array', 'itemType': UpdateTimingSyntheticTaskRequestCommonSettingCustomHostHosts },
      selectType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTimingSyntheticTaskRequestCommonSettingCustomPrometheusSetting extends $tea.Model {
  /**
   * @remarks
   * A reserved parameter.
   */
  prometheusClusterId?: string;
  /**
   * @remarks
   * A reserved parameter.
   */
  prometheusClusterRegion?: string;
  /**
   * @remarks
   * The reserved parameters.
   */
  prometheusLabels?: { [key: string]: string };
  static names(): { [key: string]: string } {
    return {
      prometheusClusterId: 'PrometheusClusterId',
      prometheusClusterRegion: 'PrometheusClusterRegion',
      prometheusLabels: 'PrometheusLabels',
    };
  }

  static types(): { [key: string]: any } {
    return {
      prometheusClusterId: 'string',
      prometheusClusterRegion: 'string',
      prometheusLabels: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTimingSyntheticTaskRequestCommonSettingCustomVPCSetting extends $tea.Model {
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the security group to which the client belongs. The security group specifies the inbound and outbound rules of the client for the VPC. You need to allow the security group to which the client belongs to access the security group to which the VPC belongs. Otherwise, the client cannot access resources in the VPC.
   * 
   * @example
   * sg-xxxxxxxx
   */
  secureGroupId?: string;
  /**
   * @remarks
   * The vSwitch ID.
   * 
   * @example
   * vsw-2zevek6r3mpny7wxxxxxv
   */
  vSwitchId?: string;
  /**
   * @remarks
   * VPC ID.
   * 
   * @example
   * vpc-bp15bjtubjytclwxxxxxx
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      secureGroupId: 'SecureGroupId',
      vSwitchId: 'VSwitchId',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      secureGroupId: 'string',
      vSwitchId: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTimingSyntheticTaskRequestCommonSetting extends $tea.Model {
  /**
   * @remarks
   * The custom host settings.
   */
  customHost?: UpdateTimingSyntheticTaskRequestCommonSettingCustomHost;
  /**
   * @remarks
   * The reserved parameters.
   */
  customPrometheusSetting?: UpdateTimingSyntheticTaskRequestCommonSettingCustomPrometheusSetting;
  /**
   * @remarks
   * The information about the virtual private cloud (VPC). If the destination URL is an Alibaba Cloud internal endpoint, you need to configure a VPC.
   */
  customVPCSetting?: UpdateTimingSyntheticTaskRequestCommonSettingCustomVPCSetting;
  /**
   * @remarks
   * The IP version. Valid values:
   * 
   * *   0: A version is automatically selected.
   * *   1: IPv4
   * *   2: IPv6
   * 
   * @example
   * 0
   */
  ipType?: number;
  /**
   * @remarks
   * Specifies whether to enable tracing.
   * 
   * @example
   * true
   */
  isOpenTrace?: boolean;
  /**
   * @remarks
   * Specifies whether to evenly distribute monitoring samples. Valid values:
   * 
   * *   0: no
   * *   1: yes
   * 
   * @example
   * 0
   */
  monitorSamples?: number;
  /**
   * @remarks
   * The type of the client for tracing. Valid values:
   * 
   * *   0: ARMS agent
   * *   1: OpenTelemetry
   * *   2: Jaeger
   * 
   * @example
   * 1
   */
  traceClientType?: number;
  /**
   * @remarks
   * The region to which trace data is reported.
   * 
   * @example
   * cn-hangzhou
   */
  xtraceRegion?: string;
  static names(): { [key: string]: string } {
    return {
      customHost: 'CustomHost',
      customPrometheusSetting: 'CustomPrometheusSetting',
      customVPCSetting: 'CustomVPCSetting',
      ipType: 'IpType',
      isOpenTrace: 'IsOpenTrace',
      monitorSamples: 'MonitorSamples',
      traceClientType: 'TraceClientType',
      xtraceRegion: 'XtraceRegion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customHost: UpdateTimingSyntheticTaskRequestCommonSettingCustomHost,
      customPrometheusSetting: UpdateTimingSyntheticTaskRequestCommonSettingCustomPrometheusSetting,
      customVPCSetting: UpdateTimingSyntheticTaskRequestCommonSettingCustomVPCSetting,
      ipType: 'number',
      isOpenTrace: 'boolean',
      monitorSamples: 'number',
      traceClientType: 'number',
      xtraceRegion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTimingSyntheticTaskRequestCustomPeriod extends $tea.Model {
  /**
   * @remarks
   * The hour at which the test ends. Valid values: 0 to 24.
   * 
   * @example
   * 22
   */
  endHour?: number;
  /**
   * @remarks
   * The hour at which the test starts. Valid values: 0 to 24.
   * 
   * @example
   * 14
   */
  startHour?: number;
  static names(): { [key: string]: string } {
    return {
      endHour: 'EndHour',
      startHour: 'StartHour',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endHour: 'number',
      startHour: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody extends $tea.Model {
  /**
   * @remarks
   * The content of the request body. Format: JSON string. The parameter is required if the Type parameter is set to text/plain, application/json, application/xml, or text/html. Format: JSON string.
   * 
   * @example
   * {
   *       "key1": "value1",
   *       "key2": "value2"
   * }
   */
  content?: string;
  /**
   * @remarks
   * The type of the request body. Valid values: text/plain, application/json, application/x-www-form-urlencoded, multipart/form-data, application/xml, and text/html.
   * 
   * @example
   * application/json
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to verify the certificate. Default value: false.
   * 
   * @example
   * true
   */
  checkCert?: boolean;
  /**
   * @remarks
   * The connection timeout period. Unit: milliseconds. Default value: 5000. Minimum value: 1000. Maximum value: 300000.
   * 
   * @example
   * 5000
   */
  connectTimeout?: number;
  /**
   * @remarks
   * The request method. Valid values:
   * 
   * *   POST
   * *   GET
   * 
   * @example
   * POST
   */
  method?: string;
  /**
   * @remarks
   * The ALPN protocol version. You can configure this parameter when you perform an HTTPS synthetic test on a WAP mobile client. Valid values:
   * 
   * 0: default
   * 
   * 1-http/1.1
   * 
   * 2-h2
   * 
   * 3: disables the ALPN protocol
   * 
   * @example
   * 0
   */
  protocolAlpnProtocol?: number;
  /**
   * @remarks
   * The HTTP request body.
   */
  requestBody?: UpdateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody;
  /**
   * @remarks
   * The custom header field.
   */
  requestHeaders?: { [key: string]: string };
  /**
   * @remarks
   * The URL or request path for synthetic monitoring.
   * 
   * @example
   * https://********
   */
  targetUrl?: string;
  /**
   * @remarks
   * The timeout period. Unit: milliseconds. Default value: 10000. Minimum value: 1000. Maximum value: 300000.
   * 
   * @example
   * 5000
   */
  timeout?: number;
  static names(): { [key: string]: string } {
    return {
      checkCert: 'CheckCert',
      connectTimeout: 'ConnectTimeout',
      method: 'Method',
      protocolAlpnProtocol: 'ProtocolAlpnProtocol',
      requestBody: 'RequestBody',
      requestHeaders: 'RequestHeaders',
      targetUrl: 'TargetUrl',
      timeout: 'Timeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkCert: 'boolean',
      connectTimeout: 'number',
      method: 'string',
      protocolAlpnProtocol: 'number',
      requestBody: UpdateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody,
      requestHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      targetUrl: 'string',
      timeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTimingSyntheticTaskRequestMonitorConfFileDownload extends $tea.Model {
  /**
   * @remarks
   * Unit: milliseconds. Minimum value: 1000. Maximum value: 120000. Default value: 5000.
   * 
   * @example
   * 5000
   */
  connectionTimeout?: number;
  /**
   * @remarks
   * The content of the custom request header. Format: JSON map.
   */
  customHeaderContent?: { [key: string]: string };
  /**
   * @remarks
   * The kernel type. Valid values:
   * 
   * *   1: curl
   * *   0: WinInet
   * 
   * @example
   * 0
   */
  downloadKernel?: number;
  /**
   * @remarks
   * Specifies whether to ignore CA certificate authentication errors. Valid values: 0: no. 1: yes. Default value: 1.
   * 
   * @example
   * 0
   */
  ignoreCertificateAuthError?: number;
  /**
   * @remarks
   * Specifies whether to ignore certificate revocation errors. Valid values: 0: no. 1: yes. Default value: 1.
   * 
   * @example
   * 0
   */
  ignoreCertificateCanceledError?: number;
  /**
   * @remarks
   * Specifies whether to ignore certificate invalidity. Valid values: 0: no. 1: yes. Default value: 1.
   * 
   * @example
   * 0
   */
  ignoreCertificateOutOfDateError?: number;
  /**
   * @remarks
   * Specifies whether to ignore certificate status errors. 0: no. 1: yes. Default value: 1.
   * 
   * @example
   * 0
   */
  ignoreCertificateStatusError?: number;
  /**
   * @remarks
   * Specifies whether to ignore certificate incredibility. Valid values: 0: no. 1: yes. Default value: 1.
   * 
   * @example
   * 0
   */
  ignoreCertificateUntrustworthyError?: number;
  /**
   * @remarks
   * Specifies whether to ignore certificate usage errors. Valid values: 0: no. 1: yes. Default value: 1.
   * 
   * @example
   * 0
   */
  ignoreCertificateUsingError?: number;
  /**
   * @remarks
   * Specifies whether to ignore host invalidity. Valid values: 0: no. 1: yes. Default value: 1.
   * 
   * @example
   * 0
   */
  ignoreInvalidHostError?: number;
  /**
   * @remarks
   * The monitoring timeout period. Unit: milliseconds. Minimum value: 1000. Maximum value: 120000. Default value: 60000.
   * 
   * @example
   * 60000
   */
  monitorTimeout?: number;
  /**
   * @remarks
   * The QUIC protocol type. Valid values:
   * 
   * *   1: HTTP/1
   * *   2: HTTP/2
   * *   3: http3
   * 
   * @example
   * 1
   */
  quickProtocol?: number;
  /**
   * @remarks
   * Specifies whether to support redirection. Valid values: 0: no. 1: yes. Default value: 1.
   * 
   * @example
   * 0
   */
  redirection?: number;
  /**
   * @remarks
   * The URL that is used to download the file.
   * 
   * @example
   * https://img.alicdn.com/tfs/TB13DzOjXP7gK0jSZFjXXc5aXXa-212-48.png
   */
  targetUrl?: string;
  /**
   * @remarks
   * The maximum file size of a single transfer. Unit: KB. Minimum value: 1. Maximum value: 20480. Valid values: 2048.
   * 
   * @example
   * 2048
   */
  transmissionSize?: number;
  /**
   * @remarks
   * The keyword that is used in verification.
   * 
   * @example
   * aliyun
   */
  validateKeywords?: string;
  /**
   * @remarks
   * The verification method. Valid values:
   * 
   * *   0: no verification
   * *   1: string verification
   * *   2: MD5 verification
   * 
   * @example
   * 0
   */
  verifyWay?: number;
  /**
   * @remarks
   * The whitelisted objects that are used to avoid DNS hijacking. The objects can be IP addresses, wildcard mask, subnet mask, or CNAME records. Separate multiple objects with vertical bars (|). Example: www.aliyun.com:203.0.3.55|203.3.44.67. It indicates that all IP addresses that belong to the www.aliyun.com domain name except 203.0.3.55 and 203.3.44.67 are hijacked.
   * 
   * @example
   * www.aliyun.com:203.0.3.55|203.3.44.67
   */
  whiteList?: string;
  static names(): { [key: string]: string } {
    return {
      connectionTimeout: 'ConnectionTimeout',
      customHeaderContent: 'CustomHeaderContent',
      downloadKernel: 'DownloadKernel',
      ignoreCertificateAuthError: 'IgnoreCertificateAuthError',
      ignoreCertificateCanceledError: 'IgnoreCertificateCanceledError',
      ignoreCertificateOutOfDateError: 'IgnoreCertificateOutOfDateError',
      ignoreCertificateStatusError: 'IgnoreCertificateStatusError',
      ignoreCertificateUntrustworthyError: 'IgnoreCertificateUntrustworthyError',
      ignoreCertificateUsingError: 'IgnoreCertificateUsingError',
      ignoreInvalidHostError: 'IgnoreInvalidHostError',
      monitorTimeout: 'MonitorTimeout',
      quickProtocol: 'QuickProtocol',
      redirection: 'Redirection',
      targetUrl: 'TargetUrl',
      transmissionSize: 'TransmissionSize',
      validateKeywords: 'ValidateKeywords',
      verifyWay: 'VerifyWay',
      whiteList: 'WhiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connectionTimeout: 'number',
      customHeaderContent: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      downloadKernel: 'number',
      ignoreCertificateAuthError: 'number',
      ignoreCertificateCanceledError: 'number',
      ignoreCertificateOutOfDateError: 'number',
      ignoreCertificateStatusError: 'number',
      ignoreCertificateUntrustworthyError: 'number',
      ignoreCertificateUsingError: 'number',
      ignoreInvalidHostError: 'number',
      monitorTimeout: 'number',
      quickProtocol: 'number',
      redirection: 'number',
      targetUrl: 'string',
      transmissionSize: 'number',
      validateKeywords: 'string',
      verifyWay: 'number',
      whiteList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTimingSyntheticTaskRequestMonitorConfNetDNS extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to use the dig command to display the data. Valid values: 0: no. 1: yes.
   * 
   * @example
   * 0
   */
  dig?: number;
  /**
   * @remarks
   * The IP version of the DNS server. Valid values: 0: IPv4. 1: IPv6. 2: A version is automatically selected. Default value: 0.
   * 
   * @example
   * 0
   */
  dnsServerIpType?: number;
  /**
   * @remarks
   * The IP address of the DNS server. Default value: 114.114.114.114.
   * 
   * @example
   * 114.114.114.114
   */
  nsServer?: string;
  /**
   * @remarks
   * The DNS query method. Valid values: 0: recursive. 1: iterative. Default value: 0.
   * 
   * @example
   * 0
   */
  queryMethod?: number;
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * www.aliyun.com
   */
  targetUrl?: string;
  /**
   * @remarks
   * The timeout period for the DNS synthetic test. Unit: milliseconds. Minimum value: 1000. Maximum value: 45000. Default value: 5000.
   * 
   * @example
   * 1000
   */
  timeout?: number;
  static names(): { [key: string]: string } {
    return {
      dig: 'Dig',
      dnsServerIpType: 'DnsServerIpType',
      nsServer: 'NsServer',
      queryMethod: 'QueryMethod',
      targetUrl: 'TargetUrl',
      timeout: 'Timeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dig: 'number',
      dnsServerIpType: 'number',
      nsServer: 'string',
      queryMethod: 'number',
      targetUrl: 'string',
      timeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTimingSyntheticTaskRequestMonitorConfNetICMP extends $tea.Model {
  /**
   * @remarks
   * The interval at which ICMP packets are sent. Unit: milliseconds. Minimum value: 200. Maximum value: 10000.
   * 
   * @example
   * 300
   */
  interval?: number;
  /**
   * @remarks
   * The number of ICMP packets that are sent. Minimum value: 1. Maximum value: 50. Default value: 4.
   * 
   * @example
   * 4
   */
  packageNum?: number;
  /**
   * @remarks
   * The size of each ICMP packet. Unit: bytes. Valid values: 32, 64, 128, 256, 512, 1024, 1080, and 1450.
   * 
   * @example
   * 32
   */
  packageSize?: number;
  /**
   * @remarks
   * Specifies whether to split ICMP packets. Default value: true.
   * 
   * @example
   * true
   */
  splitPackage?: boolean;
  /**
   * @remarks
   * The IP address or domain name of the destination host. The value cannot contain port numbers, protocol headers, or request paths.
   * 
   * @example
   * www.aliyun.com
   */
  targetUrl?: string;
  /**
   * @remarks
   * The timeout period for the ICMP synthetic test. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 20000.
   * 
   * @example
   * 5000
   */
  timeout?: number;
  /**
   * @remarks
   * Specifies whether to enable the tracert command. Default value: true.
   * 
   * @example
   * true
   */
  tracertEnable?: boolean;
  /**
   * @remarks
   * The maximum number of hops for the tracert command. Minimum value: 1. Maximum value: 128. Default value: 20.
   * 
   * @example
   * 20
   */
  tracertNumMax?: number;
  /**
   * @remarks
   * The timeout period of the tracert command. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 60000.
   * 
   * @example
   * 60000
   */
  tracertTimeout?: number;
  static names(): { [key: string]: string } {
    return {
      interval: 'Interval',
      packageNum: 'PackageNum',
      packageSize: 'PackageSize',
      splitPackage: 'SplitPackage',
      targetUrl: 'TargetUrl',
      timeout: 'Timeout',
      tracertEnable: 'TracertEnable',
      tracertNumMax: 'TracertNumMax',
      tracertTimeout: 'TracertTimeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      interval: 'number',
      packageNum: 'number',
      packageSize: 'number',
      splitPackage: 'boolean',
      targetUrl: 'string',
      timeout: 'number',
      tracertEnable: 'boolean',
      tracertNumMax: 'number',
      tracertTimeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTimingSyntheticTaskRequestMonitorConfNetTCP extends $tea.Model {
  /**
   * @remarks
   * The number of TCP connections that are established. Minimum value: 1. Maximum value: 16. Default value: 4.
   * 
   * @example
   * 4
   */
  connectTimes?: number;
  /**
   * @remarks
   * The interval at which TCP connections are established. Unit: milliseconds. Minimum value: 200. Maximum value: 10000. Default value: 200.
   * 
   * @example
   * 300
   */
  interval?: number;
  /**
   * @remarks
   * The IP address of the destination host.
   * 
   * @example
   * 127.0.0.1:8888
   */
  targetUrl?: string;
  /**
   * @remarks
   * The timeout period for the TCP synthetic test. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 20000.
   * 
   * @example
   * 1000
   */
  timeout?: number;
  /**
   * @remarks
   * Specifies whether to enable the tracert command. Default value: true.
   * 
   * @example
   * true
   */
  tracertEnable?: boolean;
  /**
   * @remarks
   * The maximum number of hops for the tracert command. Minimum value: 1. Maximum value: 128. Default value: 20.
   * 
   * @example
   * 20
   */
  tracertNumMax?: number;
  /**
   * @remarks
   * The timeout period of the tracert command. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 60000.
   * 
   * @example
   * 1000
   */
  tracertTimeout?: number;
  static names(): { [key: string]: string } {
    return {
      connectTimes: 'ConnectTimes',
      interval: 'Interval',
      targetUrl: 'TargetUrl',
      timeout: 'Timeout',
      tracertEnable: 'TracertEnable',
      tracertNumMax: 'TracertNumMax',
      tracertTimeout: 'TracertTimeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connectTimes: 'number',
      interval: 'number',
      targetUrl: 'string',
      timeout: 'number',
      tracertEnable: 'boolean',
      tracertNumMax: 'number',
      tracertTimeout: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTimingSyntheticTaskRequestMonitorConfStream extends $tea.Model {
  /**
   * @remarks
   * The custom header. Format: JSON map.
   */
  customHeaderContent?: { [key: string]: string };
  /**
   * @remarks
   * The player. Default value: 12. Valid values:
   * 
   * *   12: VLC
   * *   2: Flash Player
   * 
   * @example
   * 2
   */
  playerType?: number;
  /**
   * @remarks
   * The address type of the resource. Valid values:
   * 
   * *   1: resource URL.
   * *   0: page URL. Default value: 0.
   * 
   * @example
   * 1
   */
  streamAddressType?: number;
  /**
   * @remarks
   * The monitoring duration. Unit: seconds. Maximum and default value: 60.
   * 
   * @example
   * 30
   */
  streamMonitorTimeout?: number;
  /**
   * @remarks
   * Specifies whether the resource is a video or audio. Valid values: 0: video. 1: audio.
   * 
   * @example
   * 0
   */
  streamType?: number;
  /**
   * @remarks
   * The resource URL of the streaming media.
   * 
   * @example
   * http://www.aliyun.com/stream/test.mp4
   */
  targetUrl?: string;
  /**
   * @remarks
   * The whitelisted objects that are used to avoid DNS hijacking. The objects can be IP addresses, wildcard mask, subnet mask, or CNAME records. Separate multiple objects with vertical bars (|). Example: www.aliyun.com:203.0.3.55|203.3.44.67. It indicates that all IP addresses that belong to the www.aliyun.com domain name except 203.0.3.55 and 203.3.44.67 are hijacked.
   * 
   * @example
   * www.aliyun.com:203.0.3.55|203.3.44.67
   */
  whiteList?: string;
  static names(): { [key: string]: string } {
    return {
      customHeaderContent: 'CustomHeaderContent',
      playerType: 'PlayerType',
      streamAddressType: 'StreamAddressType',
      streamMonitorTimeout: 'StreamMonitorTimeout',
      streamType: 'StreamType',
      targetUrl: 'TargetUrl',
      whiteList: 'WhiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customHeaderContent: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      playerType: 'number',
      streamAddressType: 'number',
      streamMonitorTimeout: 'number',
      streamType: 'number',
      targetUrl: 'string',
      whiteList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTimingSyntheticTaskRequestMonitorConfWebsite extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to automatically scroll up and down the screen to load a page. Valid values: 0: no. 1: yes. Default value: 0.
   * 
   * @example
   * 0
   */
  automaticScrolling?: number;
  /**
   * @remarks
   * Specifies whether to create a custom header. Valid values: 0: no. 1: The first packet is modified. 2: All packets are modified. Default value: 0.
   * 
   * @example
   * 0
   */
  customHeader?: number;
  /**
   * @remarks
   * The custom header. Format: JSON map.
   */
  customHeaderContent?: { [key: string]: string };
  /**
   * @remarks
   * If the IP address or CNAME record resolved from a domain name is not included in the DNS whitelist, you cannot access the domain name, or an IP address that belongs to a different domain name is returned. If the IP address or CNAME record is included in the DNS whitelist, DNS hijacking does not occur.
   * 
   * Format: \\<domain name>:\\<objects>. The objects can be IP addresses, wildcard mask, subnet mask, or CNAME records. Separate multiple objects with vertical bars (|). Example: www.aliyun.com:203.0.3.55|203.3.44.67. It indicates that all IP addresses that belong to the www.aliyun.com domain name except 203.0.3.55 and 203.3.44.67 are hijacked.
   * 
   * @example
   * www.aliyun.com:203.0.3.55|203.3.44.67
   */
  DNSHijackWhitelist?: string;
  /**
   * @remarks
   * Specifies whether to disable the cache. Valid values: 0: no. 1: yes. Default value: 1.
   * 
   * @example
   * 0
   */
  disableCache?: number;
  /**
   * @remarks
   * Specifies whether to accept compressed files based on the HTTP Accept-Encoding request header. Valid values: 0: no. 1: yes. Default value: 0.
   * 
   * @example
   * 0
   */
  disableCompression?: number;
  /**
   * @remarks
   * The elements not to be loaded in the page loading process.
   * 
   * @example
   * a.jpg
   */
  elementBlacklist?: string;
  /**
   * @remarks
   * Specifies whether to exclude invalid IP addresses. Valid values:
   * 
   * *   1: no
   * *   0: yes
   * 
   * @example
   * 0
   */
  filterInvalidIP?: number;
  /**
   * @remarks
   * The total number of elements on the page.
   * 
   * @example
   * 1
   */
  flowHijackJumpTimes?: number;
  /**
   * @remarks
   * The keyword that is used to identify hijacking. Asterisks (\\*) are allowed.
   * 
   * @example
   * aliyun
   */
  flowHijackLogo?: string;
  /**
   * @remarks
   * Specifies whether to ignore SSL certificate errors during browsing. Valid values: 0: no. 1: yes. Default value: 1.
   * 
   * @example
   * 0
   */
  ignoreCertificateError?: number;
  /**
   * @remarks
   * The monitoring timeout period. Unit: milliseconds. Minimum value: 5000. Maximum value: 300000. Default value: 40000.
   * 
   * @example
   * 20000
   */
  monitorTimeout?: number;
  /**
   * @remarks
   * Elements that are not included in the whitelist and appear on the page are manipulated. These elements can be pop-up ads, floating ads, and page redirection.
   * 
   * @example
   * www.aliyun.com:|/cc/bb/a.gif|/vv/bb/cc.jpg
   */
  pageTamper?: string;
  /**
   * @remarks
   * Specifies whether to continue browsing after redirection. Valid values: 0: no. 1: yes. Default value: 1.
   * 
   * @example
   * 0
   */
  redirection?: number;
  /**
   * @remarks
   * The time threshold that is used to define a slow element. Unit: milliseconds. Default value: 5000. Minimum value: 1. Maximum value: 300000.
   * 
   * @example
   * 5000
   */
  slowElementThreshold?: number;
  /**
   * @remarks
   * The URL of the website.
   * 
   * @example
   * https://********
   */
  targetUrl?: string;
  /**
   * @remarks
   * An arbitrary string in the source code of the page for verification. If the source code returned by the client contains a string that is in the blacklist, the 650 error code is reported, which indicates that the string fails to be verified. Separate multiple strings with vertical bars (|).
   * 
   * @example
   * error
   */
  verifyStringBlacklist?: string;
  /**
   * @remarks
   * An arbitrary string in the source code of the page for verification. If the source code returned by the client contains a string that is not in the whitelist, the 650 error code is reported, which indicates that the string fails to be verified. Separate multiple strings with vertical bars (|).
   * 
   * @example
   * success
   */
  verifyStringWhitelist?: string;
  /**
   * @remarks
   * The maximum waiting time. Unit: milliseconds. Default value: 5000. Minimum value: 5000. Maximum value: 300000.
   * 
   * @example
   * 5000
   */
  waitCompletionTime?: number;
  static names(): { [key: string]: string } {
    return {
      automaticScrolling: 'AutomaticScrolling',
      customHeader: 'CustomHeader',
      customHeaderContent: 'CustomHeaderContent',
      DNSHijackWhitelist: 'DNSHijackWhitelist',
      disableCache: 'DisableCache',
      disableCompression: 'DisableCompression',
      elementBlacklist: 'ElementBlacklist',
      filterInvalidIP: 'FilterInvalidIP',
      flowHijackJumpTimes: 'FlowHijackJumpTimes',
      flowHijackLogo: 'FlowHijackLogo',
      ignoreCertificateError: 'IgnoreCertificateError',
      monitorTimeout: 'MonitorTimeout',
      pageTamper: 'PageTamper',
      redirection: 'Redirection',
      slowElementThreshold: 'SlowElementThreshold',
      targetUrl: 'TargetUrl',
      verifyStringBlacklist: 'VerifyStringBlacklist',
      verifyStringWhitelist: 'VerifyStringWhitelist',
      waitCompletionTime: 'WaitCompletionTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      automaticScrolling: 'number',
      customHeader: 'number',
      customHeaderContent: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      DNSHijackWhitelist: 'string',
      disableCache: 'number',
      disableCompression: 'number',
      elementBlacklist: 'string',
      filterInvalidIP: 'number',
      flowHijackJumpTimes: 'number',
      flowHijackLogo: 'string',
      ignoreCertificateError: 'number',
      monitorTimeout: 'number',
      pageTamper: 'string',
      redirection: 'number',
      slowElementThreshold: 'number',
      targetUrl: 'string',
      verifyStringBlacklist: 'string',
      verifyStringWhitelist: 'string',
      waitCompletionTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTimingSyntheticTaskRequestMonitorConf extends $tea.Model {
  /**
   * @remarks
   * The parameters of the HTTP(S) synthetic test.
   */
  apiHTTP?: UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP;
  /**
   * @remarks
   * The parameters of file downloading.
   */
  fileDownload?: UpdateTimingSyntheticTaskRequestMonitorConfFileDownload;
  /**
   * @remarks
   * The parameters of the DNS synthetic test.
   */
  netDNS?: UpdateTimingSyntheticTaskRequestMonitorConfNetDNS;
  /**
   * @remarks
   * The parameters of the ICMP synthetic test.
   */
  netICMP?: UpdateTimingSyntheticTaskRequestMonitorConfNetICMP;
  /**
   * @remarks
   * The parameters of the TCP synthetic test.
   */
  netTCP?: UpdateTimingSyntheticTaskRequestMonitorConfNetTCP;
  /**
   * @remarks
   * The parameters of the streaming-media synthetic test.
   */
  stream?: UpdateTimingSyntheticTaskRequestMonitorConfStream;
  /**
   * @remarks
   * The parameters of the website speed measurement.
   */
  website?: UpdateTimingSyntheticTaskRequestMonitorConfWebsite;
  static names(): { [key: string]: string } {
    return {
      apiHTTP: 'ApiHTTP',
      fileDownload: 'FileDownload',
      netDNS: 'NetDNS',
      netICMP: 'NetICMP',
      netTCP: 'NetTCP',
      stream: 'Stream',
      website: 'Website',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiHTTP: UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP,
      fileDownload: UpdateTimingSyntheticTaskRequestMonitorConfFileDownload,
      netDNS: UpdateTimingSyntheticTaskRequestMonitorConfNetDNS,
      netICMP: UpdateTimingSyntheticTaskRequestMonitorConfNetICMP,
      netTCP: UpdateTimingSyntheticTaskRequestMonitorConfNetTCP,
      stream: UpdateTimingSyntheticTaskRequestMonitorConfStream,
      website: UpdateTimingSyntheticTaskRequestMonitorConfWebsite,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTimingSyntheticTaskRequestMonitors extends $tea.Model {
  /**
   * @remarks
   * The city code.
   * 
   * @example
   * 100001
   */
  cityCode?: string;
  /**
   * @remarks
   * The client type of the monitoring point. Valid values: 1: data center. 2: Internet. 3: mobile device. 4: ECS instance.
   * 
   * @example
   * 4
   */
  clientType?: number;
  /**
   * @remarks
   * The carrier code.
   * 
   * @example
   * 1
   */
  operatorCode?: string;
  static names(): { [key: string]: string } {
    return {
      cityCode: 'CityCode',
      clientType: 'ClientType',
      operatorCode: 'OperatorCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cityCode: 'string',
      clientType: 'number',
      operatorCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTimingSyntheticTaskRequestTags extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * key
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTimingSyntheticTaskResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The task ID.
   * 
   * @example
   * 1eeb351722c84e05b52c82fd0dc9953e
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadResponseBodyUploadResult extends $tea.Model {
  /**
   * @remarks
   * The ID of the SourceMap file.
   * 
   * @example
   * 123
   */
  fid?: string;
  /**
   * @remarks
   * The name of the SourceMap file.
   * 
   * @example
   * test.js.map
   */
  fileName?: string;
  /**
   * @remarks
   * The time when the file was uploaded.
   * 
   * @example
   * 1650272251
   */
  uploadTime?: string;
  static names(): { [key: string]: string } {
    return {
      fid: 'Fid',
      fileName: 'FileName',
      uploadTime: 'UploadTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fid: 'string',
      fileName: 'string',
      uploadTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends OpenApi {

  constructor(config: $OpenApi.Config) {
    super(config);
    this._productId = "ARMS";
    let gatewayClient = new GatewayClient();
    this._spi = gatewayClient;
    this._endpointRule = "regional";
    this._endpointMap = {
      'ap-northeast-2-pop': "arms.aliyuncs.com",
      'cn-beijing-finance-1': "arms.aliyuncs.com",
      'cn-beijing-finance-pop': "arms.aliyuncs.com",
      'cn-beijing-gov-1': "arms.aliyuncs.com",
      'cn-beijing-nu16-b01': "arms.aliyuncs.com",
      'cn-edge-1': "arms.aliyuncs.com",
      'cn-fujian': "arms.aliyuncs.com",
      'cn-haidian-cm12-c01': "arms.aliyuncs.com",
      'cn-hangzhou-bj-b01': "arms.aliyuncs.com",
      'cn-hangzhou-internal-prod-1': "arms.aliyuncs.com",
      'cn-hangzhou-internal-test-1': "arms.aliyuncs.com",
      'cn-hangzhou-internal-test-2': "arms.aliyuncs.com",
      'cn-hangzhou-internal-test-3': "arms.aliyuncs.com",
      'cn-hangzhou-test-306': "arms.aliyuncs.com",
      'cn-hongkong-finance-pop': "arms.aliyuncs.com",
      'cn-huhehaote-nebula-1': "arms.aliyuncs.com",
      'cn-qingdao-nebula': "arms.aliyuncs.com",
      'cn-shanghai-et15-b01': "arms.aliyuncs.com",
      'cn-shanghai-et2-b01': "arms.aliyuncs.com",
      'cn-shanghai-inner': "arms.aliyuncs.com",
      'cn-shanghai-internal-test-1': "arms.aliyuncs.com",
      'cn-shenzhen-inner': "arms.aliyuncs.com",
      'cn-shenzhen-st4-d01': "arms.aliyuncs.com",
      'cn-shenzhen-su18-b01': "arms.aliyuncs.com",
      'cn-wuhan': "arms.aliyuncs.com",
      'cn-yushanfang': "arms.aliyuncs.com",
      'cn-zhangbei': "arms.aliyuncs.com",
      'cn-zhangbei-na61-b01': "arms.aliyuncs.com",
      'cn-zhangjiakou-na62-a01': "arms.aliyuncs.com",
      'cn-zhengzhou-nebula-1': "arms.aliyuncs.com",
      'eu-west-1-oxs': "arms.aliyuncs.com",
      'me-east-1': "arms.aliyuncs.com",
      'rus-west-1-pop': "arms.aliyuncs.com",
    };
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("arms", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!Util.empty(endpoint)) {
      return endpoint;
    }

    if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  /**
   * Adds data sources to a global aggregation instance in Prometheus Service.
   * 
   * @param request - AddAliClusterIdsToPrometheusGlobalViewRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddAliClusterIdsToPrometheusGlobalViewResponse
   */
  async addAliClusterIdsToPrometheusGlobalViewWithOptions(request: AddAliClusterIdsToPrometheusGlobalViewRequest, runtime: $Util.RuntimeOptions): Promise<AddAliClusterIdsToPrometheusGlobalViewResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterIds)) {
      query["ClusterIds"] = request.clusterIds;
    }

    if (!Util.isUnset(request.globalViewClusterId)) {
      query["GlobalViewClusterId"] = request.globalViewClusterId;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddAliClusterIdsToPrometheusGlobalView",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<AddAliClusterIdsToPrometheusGlobalViewResponse>(await this.callApi(params, req, runtime), new AddAliClusterIdsToPrometheusGlobalViewResponse({}));
    } else {
      return $tea.cast<AddAliClusterIdsToPrometheusGlobalViewResponse>(await this.execute(params, req, runtime), new AddAliClusterIdsToPrometheusGlobalViewResponse({}));
    }

  }

  /**
   * Adds data sources to a global aggregation instance in Prometheus Service.
   * 
   * @param request - AddAliClusterIdsToPrometheusGlobalViewRequest
   * @returns AddAliClusterIdsToPrometheusGlobalViewResponse
   */
  async addAliClusterIdsToPrometheusGlobalView(request: AddAliClusterIdsToPrometheusGlobalViewRequest): Promise<AddAliClusterIdsToPrometheusGlobalViewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addAliClusterIdsToPrometheusGlobalViewWithOptions(request, runtime);
  }

  /**
   * Integrates the dashboard of Prometheus Service.
   * 
   * @param request - AddGrafanaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddGrafanaResponse
   */
  async addGrafanaWithOptions(request: AddGrafanaRequest, runtime: $Util.RuntimeOptions): Promise<AddGrafanaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.integration)) {
      query["Integration"] = request.integration;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddGrafana",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<AddGrafanaResponse>(await this.callApi(params, req, runtime), new AddGrafanaResponse({}));
    } else {
      return $tea.cast<AddGrafanaResponse>(await this.execute(params, req, runtime), new AddGrafanaResponse({}));
    }

  }

  /**
   * Integrates the dashboard of Prometheus Service.
   * 
   * @param request - AddGrafanaRequest
   * @returns AddGrafanaResponse
   */
  async addGrafana(request: AddGrafanaRequest): Promise<AddGrafanaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addGrafanaWithOptions(request, runtime);
  }

  /**
   * Integrates the dashboard and collection rules of Prometheus Service.
   * 
   * @deprecated OpenAPI AddIntegration is deprecated, please use ARMS::2019-08-08::InstallAddon instead.
   * 
   * @param request - AddIntegrationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddIntegrationResponse
   */
  // Deprecated
  async addIntegrationWithOptions(request: AddIntegrationRequest, runtime: $Util.RuntimeOptions): Promise<AddIntegrationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.integration)) {
      query["Integration"] = request.integration;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddIntegration",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<AddIntegrationResponse>(await this.callApi(params, req, runtime), new AddIntegrationResponse({}));
    } else {
      return $tea.cast<AddIntegrationResponse>(await this.execute(params, req, runtime), new AddIntegrationResponse({}));
    }

  }

  /**
   * Integrates the dashboard and collection rules of Prometheus Service.
   * 
   * @deprecated OpenAPI AddIntegration is deprecated, please use ARMS::2019-08-08::InstallAddon instead.
   * 
   * @param request - AddIntegrationRequest
   * @returns AddIntegrationResponse
   */
  // Deprecated
  async addIntegration(request: AddIntegrationRequest): Promise<AddIntegrationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addIntegrationWithOptions(request, runtime);
  }

  /**
   * Adds a global aggregation instance in Prometheus Service.
   * 
   * @param request - AddPrometheusGlobalViewRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddPrometheusGlobalViewResponse
   */
  async addPrometheusGlobalViewWithOptions(request: AddPrometheusGlobalViewRequest, runtime: $Util.RuntimeOptions): Promise<AddPrometheusGlobalViewResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusters)) {
      query["Clusters"] = request.clusters;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddPrometheusGlobalView",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<AddPrometheusGlobalViewResponse>(await this.callApi(params, req, runtime), new AddPrometheusGlobalViewResponse({}));
    } else {
      return $tea.cast<AddPrometheusGlobalViewResponse>(await this.execute(params, req, runtime), new AddPrometheusGlobalViewResponse({}));
    }

  }

  /**
   * Adds a global aggregation instance in Prometheus Service.
   * 
   * @param request - AddPrometheusGlobalViewRequest
   * @returns AddPrometheusGlobalViewResponse
   */
  async addPrometheusGlobalView(request: AddPrometheusGlobalViewRequest): Promise<AddPrometheusGlobalViewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addPrometheusGlobalViewWithOptions(request, runtime);
  }

  /**
   * Creates a global aggregation instance in Prometheus Service.
   * 
   * @param request - AddPrometheusGlobalViewByAliClusterIdsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddPrometheusGlobalViewByAliClusterIdsResponse
   */
  async addPrometheusGlobalViewByAliClusterIdsWithOptions(request: AddPrometheusGlobalViewByAliClusterIdsRequest, runtime: $Util.RuntimeOptions): Promise<AddPrometheusGlobalViewByAliClusterIdsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterIds)) {
      query["ClusterIds"] = request.clusterIds;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.productCode)) {
      query["ProductCode"] = request.productCode;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddPrometheusGlobalViewByAliClusterIds",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<AddPrometheusGlobalViewByAliClusterIdsResponse>(await this.callApi(params, req, runtime), new AddPrometheusGlobalViewByAliClusterIdsResponse({}));
    } else {
      return $tea.cast<AddPrometheusGlobalViewByAliClusterIdsResponse>(await this.execute(params, req, runtime), new AddPrometheusGlobalViewByAliClusterIdsResponse({}));
    }

  }

  /**
   * Creates a global aggregation instance in Prometheus Service.
   * 
   * @param request - AddPrometheusGlobalViewByAliClusterIdsRequest
   * @returns AddPrometheusGlobalViewByAliClusterIdsResponse
   */
  async addPrometheusGlobalViewByAliClusterIds(request: AddPrometheusGlobalViewByAliClusterIdsRequest): Promise<AddPrometheusGlobalViewByAliClusterIdsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addPrometheusGlobalViewByAliClusterIdsWithOptions(request, runtime);
  }

  /**
   * Creates a Prometheus instance for Remote Write.
   * 
   * @deprecated OpenAPI AddPrometheusInstance is deprecated, please use ARMS::2019-08-08::CreatePrometheusInstance instead.
   * 
   * @param request - AddPrometheusInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddPrometheusInstanceResponse
   */
  // Deprecated
  async addPrometheusInstanceWithOptions(request: AddPrometheusInstanceRequest, runtime: $Util.RuntimeOptions): Promise<AddPrometheusInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddPrometheusInstance",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<AddPrometheusInstanceResponse>(await this.callApi(params, req, runtime), new AddPrometheusInstanceResponse({}));
    } else {
      return $tea.cast<AddPrometheusInstanceResponse>(await this.execute(params, req, runtime), new AddPrometheusInstanceResponse({}));
    }

  }

  /**
   * Creates a Prometheus instance for Remote Write.
   * 
   * @deprecated OpenAPI AddPrometheusInstance is deprecated, please use ARMS::2019-08-08::CreatePrometheusInstance instead.
   * 
   * @param request - AddPrometheusInstanceRequest
   * @returns AddPrometheusInstanceResponse
   */
  // Deprecated
  async addPrometheusInstance(request: AddPrometheusInstanceRequest): Promise<AddPrometheusInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addPrometheusInstanceWithOptions(request, runtime);
  }

  /**
   * Adds an exporter to a Prometheus instance for Container Service or a Prometheus instance for ECS.
   * 
   * @param request - AddPrometheusIntegrationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddPrometheusIntegrationResponse
   */
  async addPrometheusIntegrationWithOptions(request: AddPrometheusIntegrationRequest, runtime: $Util.RuntimeOptions): Promise<AddPrometheusIntegrationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.integrationType)) {
      query["IntegrationType"] = request.integrationType;
    }

    if (!Util.isUnset(request.param)) {
      query["Param"] = request.param;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddPrometheusIntegration",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<AddPrometheusIntegrationResponse>(await this.callApi(params, req, runtime), new AddPrometheusIntegrationResponse({}));
    } else {
      return $tea.cast<AddPrometheusIntegrationResponse>(await this.execute(params, req, runtime), new AddPrometheusIntegrationResponse({}));
    }

  }

  /**
   * Adds an exporter to a Prometheus instance for Container Service or a Prometheus instance for ECS.
   * 
   * @param request - AddPrometheusIntegrationRequest
   * @returns AddPrometheusIntegrationResponse
   */
  async addPrometheusIntegration(request: AddPrometheusIntegrationRequest): Promise<AddPrometheusIntegrationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addPrometheusIntegrationWithOptions(request, runtime);
  }

  /**
   * Creates or updates a recording rule of Managed Service for Prometheus.
   * 
   * @param request - AddRecordingRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddRecordingRuleResponse
   */
  async addRecordingRuleWithOptions(request: AddRecordingRuleRequest, runtime: $Util.RuntimeOptions): Promise<AddRecordingRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.ruleYaml)) {
      query["RuleYaml"] = request.ruleYaml;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddRecordingRule",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<AddRecordingRuleResponse>(await this.callApi(params, req, runtime), new AddRecordingRuleResponse({}));
    } else {
      return $tea.cast<AddRecordingRuleResponse>(await this.execute(params, req, runtime), new AddRecordingRuleResponse({}));
    }

  }

  /**
   * Creates or updates a recording rule of Managed Service for Prometheus.
   * 
   * @param request - AddRecordingRuleRequest
   * @returns AddRecordingRuleResponse
   */
  async addRecordingRule(request: AddRecordingRuleRequest): Promise<AddRecordingRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addRecordingRuleWithOptions(request, runtime);
  }

  /**
   * Attaches the workspace ID and workspace name tags to the Prometheus instance corresponding to a Flink workspace.
   * 
   * @param request - AddTagToFlinkClusterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddTagToFlinkClusterResponse
   */
  async addTagToFlinkClusterWithOptions(request: AddTagToFlinkClusterRequest, runtime: $Util.RuntimeOptions): Promise<AddTagToFlinkClusterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.flinkWorkSpaceId)) {
      query["FlinkWorkSpaceId"] = request.flinkWorkSpaceId;
    }

    if (!Util.isUnset(request.flinkWorkSpaceName)) {
      query["FlinkWorkSpaceName"] = request.flinkWorkSpaceName;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.targetUserId)) {
      query["TargetUserId"] = request.targetUserId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddTagToFlinkCluster",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<AddTagToFlinkClusterResponse>(await this.callApi(params, req, runtime), new AddTagToFlinkClusterResponse({}));
    } else {
      return $tea.cast<AddTagToFlinkClusterResponse>(await this.execute(params, req, runtime), new AddTagToFlinkClusterResponse({}));
    }

  }

  /**
   * Attaches the workspace ID and workspace name tags to the Prometheus instance corresponding to a Flink workspace.
   * 
   * @param request - AddTagToFlinkClusterRequest
   * @returns AddTagToFlinkClusterResponse
   */
  async addTagToFlinkCluster(request: AddTagToFlinkClusterRequest): Promise<AddTagToFlinkClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addTagToFlinkClusterWithOptions(request, runtime);
  }

  /**
   * Adds a data source to a global aggregation instance.
   * 
   * @param request - AppendInstancesToPrometheusGlobalViewRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AppendInstancesToPrometheusGlobalViewResponse
   */
  async appendInstancesToPrometheusGlobalViewWithOptions(request: AppendInstancesToPrometheusGlobalViewRequest, runtime: $Util.RuntimeOptions): Promise<AppendInstancesToPrometheusGlobalViewResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusters)) {
      query["Clusters"] = request.clusters;
    }

    if (!Util.isUnset(request.globalViewClusterId)) {
      query["GlobalViewClusterId"] = request.globalViewClusterId;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AppendInstancesToPrometheusGlobalView",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<AppendInstancesToPrometheusGlobalViewResponse>(await this.callApi(params, req, runtime), new AppendInstancesToPrometheusGlobalViewResponse({}));
    } else {
      return $tea.cast<AppendInstancesToPrometheusGlobalViewResponse>(await this.execute(params, req, runtime), new AppendInstancesToPrometheusGlobalViewResponse({}));
    }

  }

  /**
   * Adds a data source to a global aggregation instance.
   * 
   * @param request - AppendInstancesToPrometheusGlobalViewRequest
   * @returns AppendInstancesToPrometheusGlobalViewResponse
   */
  async appendInstancesToPrometheusGlobalView(request: AppendInstancesToPrometheusGlobalViewRequest): Promise<AppendInstancesToPrometheusGlobalViewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.appendInstancesToPrometheusGlobalViewWithOptions(request, runtime);
  }

  /**
   * @param tmpReq - ApplyScenarioRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ApplyScenarioResponse
   */
  async applyScenarioWithOptions(tmpReq: ApplyScenarioRequest, runtime: $Util.RuntimeOptions): Promise<ApplyScenarioResponse> {
    Util.validateModel(tmpReq);
    let request = new ApplyScenarioShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.config)) {
      request.configShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.config, "Config", "json");
    }

    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.configShrink)) {
      query["Config"] = request.configShrink;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.scenario)) {
      query["Scenario"] = request.scenario;
    }

    if (!Util.isUnset(request.sign)) {
      query["Sign"] = request.sign;
    }

    if (!Util.isUnset(request.snDump)) {
      query["SnDump"] = request.snDump;
    }

    if (!Util.isUnset(request.snForce)) {
      query["SnForce"] = request.snForce;
    }

    if (!Util.isUnset(request.snStat)) {
      query["SnStat"] = request.snStat;
    }

    if (!Util.isUnset(request.snTransfer)) {
      query["SnTransfer"] = request.snTransfer;
    }

    if (!Util.isUnset(request.updateOption)) {
      query["UpdateOption"] = request.updateOption;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ApplyScenario",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ApplyScenarioResponse>(await this.callApi(params, req, runtime), new ApplyScenarioResponse({}));
    } else {
      return $tea.cast<ApplyScenarioResponse>(await this.execute(params, req, runtime), new ApplyScenarioResponse({}));
    }

  }

  /**
   * @param request - ApplyScenarioRequest
   * @returns ApplyScenarioResponse
   */
  async applyScenario(request: ApplyScenarioRequest): Promise<ApplyScenarioResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.applyScenarioWithOptions(request, runtime);
  }

  /**
   * Binds a Grafana workspace to a Prometheus instance.
   * 
   * @param request - BindPrometheusGrafanaInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BindPrometheusGrafanaInstanceResponse
   */
  async bindPrometheusGrafanaInstanceWithOptions(request: BindPrometheusGrafanaInstanceRequest, runtime: $Util.RuntimeOptions): Promise<BindPrometheusGrafanaInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.grafanaInstanceId)) {
      query["GrafanaInstanceId"] = request.grafanaInstanceId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BindPrometheusGrafanaInstance",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<BindPrometheusGrafanaInstanceResponse>(await this.callApi(params, req, runtime), new BindPrometheusGrafanaInstanceResponse({}));
    } else {
      return $tea.cast<BindPrometheusGrafanaInstanceResponse>(await this.execute(params, req, runtime), new BindPrometheusGrafanaInstanceResponse({}));
    }

  }

  /**
   * Binds a Grafana workspace to a Prometheus instance.
   * 
   * @param request - BindPrometheusGrafanaInstanceRequest
   * @returns BindPrometheusGrafanaInstanceResponse
   */
  async bindPrometheusGrafanaInstance(request: BindPrometheusGrafanaInstanceRequest): Promise<BindPrometheusGrafanaInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.bindPrometheusGrafanaInstanceWithOptions(request, runtime);
  }

  /**
   * Blocks alert notifications in a time period.
   * 
   * @param request - BlockAlarmNotificationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BlockAlarmNotificationResponse
   */
  async blockAlarmNotificationWithOptions(request: BlockAlarmNotificationRequest, runtime: $Util.RuntimeOptions): Promise<BlockAlarmNotificationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alarmId)) {
      query["AlarmId"] = request.alarmId;
    }

    if (!Util.isUnset(request.handlerId)) {
      query["HandlerId"] = request.handlerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.timeout)) {
      query["Timeout"] = request.timeout;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BlockAlarmNotification",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<BlockAlarmNotificationResponse>(await this.callApi(params, req, runtime), new BlockAlarmNotificationResponse({}));
    } else {
      return $tea.cast<BlockAlarmNotificationResponse>(await this.execute(params, req, runtime), new BlockAlarmNotificationResponse({}));
    }

  }

  /**
   * Blocks alert notifications in a time period.
   * 
   * @param request - BlockAlarmNotificationRequest
   * @returns BlockAlarmNotificationResponse
   */
  async blockAlarmNotification(request: BlockAlarmNotificationRequest): Promise<BlockAlarmNotificationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.blockAlarmNotificationWithOptions(request, runtime);
  }

  /**
   * Modifies the severity level of an alert.
   * 
   * @param request - ChangeAlarmSeverityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ChangeAlarmSeverityResponse
   */
  async changeAlarmSeverityWithOptions(request: ChangeAlarmSeverityRequest, runtime: $Util.RuntimeOptions): Promise<ChangeAlarmSeverityResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alarmId)) {
      query["AlarmId"] = request.alarmId;
    }

    if (!Util.isUnset(request.handlerId)) {
      query["HandlerId"] = request.handlerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.severity)) {
      query["Severity"] = request.severity;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ChangeAlarmSeverity",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ChangeAlarmSeverityResponse>(await this.callApi(params, req, runtime), new ChangeAlarmSeverityResponse({}));
    } else {
      return $tea.cast<ChangeAlarmSeverityResponse>(await this.execute(params, req, runtime), new ChangeAlarmSeverityResponse({}));
    }

  }

  /**
   * Modifies the severity level of an alert.
   * 
   * @param request - ChangeAlarmSeverityRequest
   * @returns ChangeAlarmSeverityResponse
   */
  async changeAlarmSeverity(request: ChangeAlarmSeverityRequest): Promise<ChangeAlarmSeverityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.changeAlarmSeverityWithOptions(request, runtime);
  }

  /**
   * Moves a resource to a specific resource group.
   * 
   * @param request - ChangeResourceGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ChangeResourceGroupResponse
   */
  async changeResourceGroupWithOptions(request: ChangeResourceGroupRequest, runtime: $Util.RuntimeOptions): Promise<ChangeResourceGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.newResourceGroupId)) {
      query["NewResourceGroupId"] = request.newResourceGroupId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ChangeResourceGroup",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ChangeResourceGroupResponse>(await this.callApi(params, req, runtime), new ChangeResourceGroupResponse({}));
    } else {
      return $tea.cast<ChangeResourceGroupResponse>(await this.execute(params, req, runtime), new ChangeResourceGroupResponse({}));
    }

  }

  /**
   * Moves a resource to a specific resource group.
   * 
   * @param request - ChangeResourceGroupRequest
   * @returns ChangeResourceGroupResponse
   */
  async changeResourceGroup(request: ChangeResourceGroupRequest): Promise<ChangeResourceGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.changeResourceGroupWithOptions(request, runtime);
  }

  /**
   * Checks whether Application Real-Time Monitoring Service (ARMS) is available for commercial use in a region.
   * 
   * @remarks
   * You can call this operation to check whether ARMS is available for commercial use in a region.
   * 
   * @param request - CheckCommercialStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CheckCommercialStatusResponse
   */
  async checkCommercialStatusWithOptions(request: CheckCommercialStatusRequest, runtime: $Util.RuntimeOptions): Promise<CheckCommercialStatusResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CheckCommercialStatus",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CheckCommercialStatusResponse>(await this.callApi(params, req, runtime), new CheckCommercialStatusResponse({}));
    } else {
      return $tea.cast<CheckCommercialStatusResponse>(await this.execute(params, req, runtime), new CheckCommercialStatusResponse({}));
    }

  }

  /**
   * Checks whether Application Real-Time Monitoring Service (ARMS) is available for commercial use in a region.
   * 
   * @remarks
   * You can call this operation to check whether ARMS is available for commercial use in a region.
   * 
   * @param request - CheckCommercialStatusRequest
   * @returns CheckCommercialStatusResponse
   */
  async checkCommercialStatus(request: CheckCommercialStatusRequest): Promise<CheckCommercialStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.checkCommercialStatusWithOptions(request, runtime);
  }

  /**
   * Checks the status of a service in the current cluster, such as whether the service is activated and whether the payment is overdue.
   * 
   * @param request - CheckServiceStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CheckServiceStatusResponse
   */
  async checkServiceStatusWithOptions(request: CheckServiceStatusRequest, runtime: $Util.RuntimeOptions): Promise<CheckServiceStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.svcCode)) {
      query["SvcCode"] = request.svcCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CheckServiceStatus",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CheckServiceStatusResponse>(await this.callApi(params, req, runtime), new CheckServiceStatusResponse({}));
    } else {
      return $tea.cast<CheckServiceStatusResponse>(await this.execute(params, req, runtime), new CheckServiceStatusResponse({}));
    }

  }

  /**
   * Checks the status of a service in the current cluster, such as whether the service is activated and whether the payment is overdue.
   * 
   * @param request - CheckServiceStatusRequest
   * @returns CheckServiceStatusResponse
   */
  async checkServiceStatus(request: CheckServiceStatusRequest): Promise<CheckServiceStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.checkServiceStatusWithOptions(request, runtime);
  }

  /**
   * Claims an alert. This operation can be used together with escalation policies. When multiple handlers are involved in alert management, each handler can call this operation to claim alerts. After an alert is claimed, the alert enters the Being Processed state.
   * 
   * @param request - ClaimAlarmRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ClaimAlarmResponse
   */
  async claimAlarmWithOptions(request: ClaimAlarmRequest, runtime: $Util.RuntimeOptions): Promise<ClaimAlarmResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alarmId)) {
      query["AlarmId"] = request.alarmId;
    }

    if (!Util.isUnset(request.handlerId)) {
      query["HandlerId"] = request.handlerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ClaimAlarm",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ClaimAlarmResponse>(await this.callApi(params, req, runtime), new ClaimAlarmResponse({}));
    } else {
      return $tea.cast<ClaimAlarmResponse>(await this.execute(params, req, runtime), new ClaimAlarmResponse({}));
    }

  }

  /**
   * Claims an alert. This operation can be used together with escalation policies. When multiple handlers are involved in alert management, each handler can call this operation to claim alerts. After an alert is claimed, the alert enters the Being Processed state.
   * 
   * @param request - ClaimAlarmRequest
   * @returns ClaimAlarmResponse
   */
  async claimAlarm(request: ClaimAlarmRequest): Promise<ClaimAlarmResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.claimAlarmWithOptions(request, runtime);
  }

  /**
   * Disables an alert. Make sure that the alert is resolved before you disable the alert. If an alert is not resolved, new alerts can be triggered even after the alert is disabled.
   * 
   * @param request - CloseAlarmRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CloseAlarmResponse
   */
  async closeAlarmWithOptions(request: CloseAlarmRequest, runtime: $Util.RuntimeOptions): Promise<CloseAlarmResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alarmId)) {
      query["AlarmId"] = request.alarmId;
    }

    if (!Util.isUnset(request.handlerId)) {
      query["HandlerId"] = request.handlerId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.solution)) {
      query["Solution"] = request.solution;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CloseAlarm",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CloseAlarmResponse>(await this.callApi(params, req, runtime), new CloseAlarmResponse({}));
    } else {
      return $tea.cast<CloseAlarmResponse>(await this.execute(params, req, runtime), new CloseAlarmResponse({}));
    }

  }

  /**
   * Disables an alert. Make sure that the alert is resolved before you disable the alert. If an alert is not resolved, new alerts can be triggered even after the alert is disabled.
   * 
   * @param request - CloseAlarmRequest
   * @returns CloseAlarmResponse
   */
  async closeAlarm(request: CloseAlarmRequest): Promise<CloseAlarmResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.closeAlarmWithOptions(request, runtime);
  }

  /**
   * Turns on or off the main switch of an ARMS agent, or queries the status of the main switch.
   * 
   * @remarks
   * ***
   * 
   * @param request - ConfigAppRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ConfigAppResponse
   */
  async configAppWithOptions(request: ConfigAppRequest, runtime: $Util.RuntimeOptions): Promise<ConfigAppResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appIds)) {
      query["AppIds"] = request.appIds;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ConfigApp",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ConfigAppResponse>(await this.callApi(params, req, runtime), new ConfigAppResponse({}));
    } else {
      return $tea.cast<ConfigAppResponse>(await this.execute(params, req, runtime), new ConfigAppResponse({}));
    }

  }

  /**
   * Turns on or off the main switch of an ARMS agent, or queries the status of the main switch.
   * 
   * @remarks
   * ***
   * 
   * @param request - ConfigAppRequest
   * @returns ConfigAppResponse
   */
  async configApp(request: ConfigAppRequest): Promise<ConfigAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.configAppWithOptions(request, runtime);
  }

  /**
   * Creates an alert contact.
   * 
   * @remarks
   * This operation is no longer maintained. To create or modify an alert contact, call the CreateOrUpdateContact operation provided by the new version of the Alert Management module.
   * 
   * @param request - CreateAlertContactRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateAlertContactResponse
   */
  async createAlertContactWithOptions(request: CreateAlertContactRequest, runtime: $Util.RuntimeOptions): Promise<CreateAlertContactResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contactName)) {
      query["ContactName"] = request.contactName;
    }

    if (!Util.isUnset(request.dingRobotWebhookUrl)) {
      query["DingRobotWebhookUrl"] = request.dingRobotWebhookUrl;
    }

    if (!Util.isUnset(request.email)) {
      query["Email"] = request.email;
    }

    if (!Util.isUnset(request.phoneNum)) {
      query["PhoneNum"] = request.phoneNum;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.systemNoc)) {
      query["SystemNoc"] = request.systemNoc;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateAlertContact",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CreateAlertContactResponse>(await this.callApi(params, req, runtime), new CreateAlertContactResponse({}));
    } else {
      return $tea.cast<CreateAlertContactResponse>(await this.execute(params, req, runtime), new CreateAlertContactResponse({}));
    }

  }

  /**
   * Creates an alert contact.
   * 
   * @remarks
   * This operation is no longer maintained. To create or modify an alert contact, call the CreateOrUpdateContact operation provided by the new version of the Alert Management module.
   * 
   * @param request - CreateAlertContactRequest
   * @returns CreateAlertContactResponse
   */
  async createAlertContact(request: CreateAlertContactRequest): Promise<CreateAlertContactResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createAlertContactWithOptions(request, runtime);
  }

  /**
   * Creates an alert contact group.
   * 
   * @remarks
   * The current API operation is no longer maintained. Call the CreateOrUpdateContactGroup operation of the new Alert Management module to create or modify alert contact groups.
   * 
   * @param request - CreateAlertContactGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateAlertContactGroupResponse
   */
  async createAlertContactGroupWithOptions(request: CreateAlertContactGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateAlertContactGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contactGroupName)) {
      query["ContactGroupName"] = request.contactGroupName;
    }

    if (!Util.isUnset(request.contactIds)) {
      query["ContactIds"] = request.contactIds;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateAlertContactGroup",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CreateAlertContactGroupResponse>(await this.callApi(params, req, runtime), new CreateAlertContactGroupResponse({}));
    } else {
      return $tea.cast<CreateAlertContactGroupResponse>(await this.execute(params, req, runtime), new CreateAlertContactGroupResponse({}));
    }

  }

  /**
   * Creates an alert contact group.
   * 
   * @remarks
   * The current API operation is no longer maintained. Call the CreateOrUpdateContactGroup operation of the new Alert Management module to create or modify alert contact groups.
   * 
   * @param request - CreateAlertContactGroupRequest
   * @returns CreateAlertContactGroupResponse
   */
  async createAlertContactGroup(request: CreateAlertContactGroupRequest): Promise<CreateAlertContactGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createAlertContactGroupWithOptions(request, runtime);
  }

  /**
   * Creates a dispatch policy.
   * 
   * @param request - CreateDispatchRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDispatchRuleResponse
   */
  async createDispatchRuleWithOptions(request: CreateDispatchRuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateDispatchRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dispatchRule)) {
      query["DispatchRule"] = request.dispatchRule;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDispatchRule",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CreateDispatchRuleResponse>(await this.callApi(params, req, runtime), new CreateDispatchRuleResponse({}));
    } else {
      return $tea.cast<CreateDispatchRuleResponse>(await this.execute(params, req, runtime), new CreateDispatchRuleResponse({}));
    }

  }

  /**
   * Creates a dispatch policy.
   * 
   * @param request - CreateDispatchRuleRequest
   * @returns CreateDispatchRuleResponse
   */
  async createDispatchRule(request: CreateDispatchRuleRequest): Promise<CreateDispatchRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDispatchRuleWithOptions(request, runtime);
  }

  /**
   * Creates a custom job for an environment.
   * 
   * @param request - CreateEnvCustomJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateEnvCustomJobResponse
   */
  async createEnvCustomJobWithOptions(request: CreateEnvCustomJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateEnvCustomJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliyunLang)) {
      query["AliyunLang"] = request.aliyunLang;
    }

    if (!Util.isUnset(request.customJobName)) {
      query["CustomJobName"] = request.customJobName;
    }

    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.configYaml)) {
      body["ConfigYaml"] = request.configYaml;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateEnvCustomJob",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CreateEnvCustomJobResponse>(await this.callApi(params, req, runtime), new CreateEnvCustomJobResponse({}));
    } else {
      return $tea.cast<CreateEnvCustomJobResponse>(await this.execute(params, req, runtime), new CreateEnvCustomJobResponse({}));
    }

  }

  /**
   * Creates a custom job for an environment.
   * 
   * @param request - CreateEnvCustomJobRequest
   * @returns CreateEnvCustomJobResponse
   */
  async createEnvCustomJob(request: CreateEnvCustomJobRequest): Promise<CreateEnvCustomJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEnvCustomJobWithOptions(request, runtime);
  }

  /**
   * Creates a PodMonitor for an environment.
   * 
   * @param request - CreateEnvPodMonitorRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateEnvPodMonitorResponse
   */
  async createEnvPodMonitorWithOptions(request: CreateEnvPodMonitorRequest, runtime: $Util.RuntimeOptions): Promise<CreateEnvPodMonitorResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliyunLang)) {
      query["AliyunLang"] = request.aliyunLang;
    }

    if (!Util.isUnset(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.configYaml)) {
      body["ConfigYaml"] = request.configYaml;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateEnvPodMonitor",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CreateEnvPodMonitorResponse>(await this.callApi(params, req, runtime), new CreateEnvPodMonitorResponse({}));
    } else {
      return $tea.cast<CreateEnvPodMonitorResponse>(await this.execute(params, req, runtime), new CreateEnvPodMonitorResponse({}));
    }

  }

  /**
   * Creates a PodMonitor for an environment.
   * 
   * @param request - CreateEnvPodMonitorRequest
   * @returns CreateEnvPodMonitorResponse
   */
  async createEnvPodMonitor(request: CreateEnvPodMonitorRequest): Promise<CreateEnvPodMonitorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEnvPodMonitorWithOptions(request, runtime);
  }

  /**
   * Creates a ServiceMonitor for an environment.
   * 
   * @param request - CreateEnvServiceMonitorRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateEnvServiceMonitorResponse
   */
  async createEnvServiceMonitorWithOptions(request: CreateEnvServiceMonitorRequest, runtime: $Util.RuntimeOptions): Promise<CreateEnvServiceMonitorResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliyunLang)) {
      query["AliyunLang"] = request.aliyunLang;
    }

    if (!Util.isUnset(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.configYaml)) {
      body["ConfigYaml"] = request.configYaml;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateEnvServiceMonitor",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CreateEnvServiceMonitorResponse>(await this.callApi(params, req, runtime), new CreateEnvServiceMonitorResponse({}));
    } else {
      return $tea.cast<CreateEnvServiceMonitorResponse>(await this.execute(params, req, runtime), new CreateEnvServiceMonitorResponse({}));
    }

  }

  /**
   * Creates a ServiceMonitor for an environment.
   * 
   * @param request - CreateEnvServiceMonitorRequest
   * @returns CreateEnvServiceMonitorResponse
   */
  async createEnvServiceMonitor(request: CreateEnvServiceMonitorRequest): Promise<CreateEnvServiceMonitorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEnvServiceMonitorWithOptions(request, runtime);
  }

  /**
   * Creates an environment instance.
   * 
   * @param request - CreateEnvironmentRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateEnvironmentResponse
   */
  async createEnvironmentWithOptions(request: CreateEnvironmentRequest, runtime: $Util.RuntimeOptions): Promise<CreateEnvironmentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliyunLang)) {
      query["AliyunLang"] = request.aliyunLang;
    }

    if (!Util.isUnset(request.bindResourceId)) {
      query["BindResourceId"] = request.bindResourceId;
    }

    if (!Util.isUnset(request.environmentName)) {
      query["EnvironmentName"] = request.environmentName;
    }

    if (!Util.isUnset(request.environmentSubType)) {
      query["EnvironmentSubType"] = request.environmentSubType;
    }

    if (!Util.isUnset(request.environmentType)) {
      query["EnvironmentType"] = request.environmentType;
    }

    if (!Util.isUnset(request.feePackage)) {
      query["FeePackage"] = request.feePackage;
    }

    if (!Util.isUnset(request.grafanaWorkspaceId)) {
      query["GrafanaWorkspaceId"] = request.grafanaWorkspaceId;
    }

    if (!Util.isUnset(request.initEnvironment)) {
      query["InitEnvironment"] = request.initEnvironment;
    }

    if (!Util.isUnset(request.managedType)) {
      query["ManagedType"] = request.managedType;
    }

    if (!Util.isUnset(request.prometheusInstanceId)) {
      query["PrometheusInstanceId"] = request.prometheusInstanceId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateEnvironment",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CreateEnvironmentResponse>(await this.callApi(params, req, runtime), new CreateEnvironmentResponse({}));
    } else {
      return $tea.cast<CreateEnvironmentResponse>(await this.execute(params, req, runtime), new CreateEnvironmentResponse({}));
    }

  }

  /**
   * Creates an environment instance.
   * 
   * @param request - CreateEnvironmentRequest
   * @returns CreateEnvironmentResponse
   */
  async createEnvironment(request: CreateEnvironmentRequest): Promise<CreateEnvironmentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEnvironmentWithOptions(request, runtime);
  }

  /**
   * Creates a workspace in Managed Service for Grafana.
   * 
   * @remarks
   * Before you call the operation, make sure that you have learned about the billing methods and [pricing](https://www.alibabacloud.com/help/zh/grafana/product-overview/billing-4?spm=a2c4g.11186623.0.0.14c2d253B3SDbt) of Managed Service for Grafana.
   * > 
   * *   To create workspaces, you must complete real-name verification.
   * *   Regular users can create workspaces only in Managed Service for Grafana Developer Edition, Pro Edition, and Advanced Edition. `These editions charge fees.`
   * *   Internal users can create workspaces only in Managed Service for Grafana Beta Edition and Standard Edition. `These editions do not charge fees.`
   * 
   * @param tmpReq - CreateGrafanaWorkspaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateGrafanaWorkspaceResponse
   */
  async createGrafanaWorkspaceWithOptions(tmpReq: CreateGrafanaWorkspaceRequest, runtime: $Util.RuntimeOptions): Promise<CreateGrafanaWorkspaceResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateGrafanaWorkspaceShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.tags)) {
      request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, "Tags", "json");
    }

    let query = { };
    if (!Util.isUnset(request.aliyunLang)) {
      query["AliyunLang"] = request.aliyunLang;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.grafanaVersion)) {
      query["GrafanaVersion"] = request.grafanaVersion;
    }

    if (!Util.isUnset(request.grafanaWorkspaceEdition)) {
      query["GrafanaWorkspaceEdition"] = request.grafanaWorkspaceEdition;
    }

    if (!Util.isUnset(request.grafanaWorkspaceName)) {
      query["GrafanaWorkspaceName"] = request.grafanaWorkspaceName;
    }

    if (!Util.isUnset(request.password)) {
      query["Password"] = request.password;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.tagsShrink)) {
      query["Tags"] = request.tagsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateGrafanaWorkspace",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CreateGrafanaWorkspaceResponse>(await this.callApi(params, req, runtime), new CreateGrafanaWorkspaceResponse({}));
    } else {
      return $tea.cast<CreateGrafanaWorkspaceResponse>(await this.execute(params, req, runtime), new CreateGrafanaWorkspaceResponse({}));
    }

  }

  /**
   * Creates a workspace in Managed Service for Grafana.
   * 
   * @remarks
   * Before you call the operation, make sure that you have learned about the billing methods and [pricing](https://www.alibabacloud.com/help/zh/grafana/product-overview/billing-4?spm=a2c4g.11186623.0.0.14c2d253B3SDbt) of Managed Service for Grafana.
   * > 
   * *   To create workspaces, you must complete real-name verification.
   * *   Regular users can create workspaces only in Managed Service for Grafana Developer Edition, Pro Edition, and Advanced Edition. `These editions charge fees.`
   * *   Internal users can create workspaces only in Managed Service for Grafana Beta Edition and Standard Edition. `These editions do not charge fees.`
   * 
   * @param request - CreateGrafanaWorkspaceRequest
   * @returns CreateGrafanaWorkspaceResponse
   */
  async createGrafanaWorkspace(request: CreateGrafanaWorkspaceRequest): Promise<CreateGrafanaWorkspaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createGrafanaWorkspaceWithOptions(request, runtime);
  }

  /**
   * Creates an alert integration.
   * 
   * @param request - CreateIntegrationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateIntegrationResponse
   */
  async createIntegrationWithOptions(request: CreateIntegrationRequest, runtime: $Util.RuntimeOptions): Promise<CreateIntegrationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.autoRecover)) {
      body["AutoRecover"] = request.autoRecover;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.integrationName)) {
      body["IntegrationName"] = request.integrationName;
    }

    if (!Util.isUnset(request.integrationProductType)) {
      body["IntegrationProductType"] = request.integrationProductType;
    }

    if (!Util.isUnset(request.recoverTime)) {
      body["RecoverTime"] = request.recoverTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateIntegration",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CreateIntegrationResponse>(await this.callApi(params, req, runtime), new CreateIntegrationResponse({}));
    } else {
      return $tea.cast<CreateIntegrationResponse>(await this.execute(params, req, runtime), new CreateIntegrationResponse({}));
    }

  }

  /**
   * Creates an alert integration.
   * 
   * @param request - CreateIntegrationRequest
   * @returns CreateIntegrationResponse
   */
  async createIntegration(request: CreateIntegrationRequest): Promise<CreateIntegrationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createIntegrationWithOptions(request, runtime);
  }

  /**
   * Creates or modifies an alert rule.
   * 
   * @param request - CreateOrUpdateAlertRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateOrUpdateAlertRuleResponse
   */
  async createOrUpdateAlertRuleWithOptions(request: CreateOrUpdateAlertRuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateOrUpdateAlertRuleResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.alertCheckType)) {
      body["AlertCheckType"] = request.alertCheckType;
    }

    if (!Util.isUnset(request.alertGroup)) {
      body["AlertGroup"] = request.alertGroup;
    }

    if (!Util.isUnset(request.alertId)) {
      body["AlertId"] = request.alertId;
    }

    if (!Util.isUnset(request.alertName)) {
      body["AlertName"] = request.alertName;
    }

    if (!Util.isUnset(request.alertPiplines)) {
      body["AlertPiplines"] = request.alertPiplines;
    }

    if (!Util.isUnset(request.alertRuleContent)) {
      body["AlertRuleContent"] = request.alertRuleContent;
    }

    if (!Util.isUnset(request.alertStatus)) {
      body["AlertStatus"] = request.alertStatus;
    }

    if (!Util.isUnset(request.alertType)) {
      body["AlertType"] = request.alertType;
    }

    if (!Util.isUnset(request.annotations)) {
      body["Annotations"] = request.annotations;
    }

    if (!Util.isUnset(request.autoAddNewApplication)) {
      body["AutoAddNewApplication"] = request.autoAddNewApplication;
    }

    if (!Util.isUnset(request.autoAddTargetConfig)) {
      body["AutoAddTargetConfig"] = request.autoAddTargetConfig;
    }

    if (!Util.isUnset(request.clusterId)) {
      body["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dataConfig)) {
      body["DataConfig"] = request.dataConfig;
    }

    if (!Util.isUnset(request.duration)) {
      body["Duration"] = request.duration;
    }

    if (!Util.isUnset(request.filters)) {
      body["Filters"] = request.filters;
    }

    if (!Util.isUnset(request.labels)) {
      body["Labels"] = request.labels;
    }

    if (!Util.isUnset(request.level)) {
      body["Level"] = request.level;
    }

    if (!Util.isUnset(request.markTags)) {
      body["MarkTags"] = request.markTags;
    }

    if (!Util.isUnset(request.message)) {
      body["Message"] = request.message;
    }

    if (!Util.isUnset(request.metricsKey)) {
      body["MetricsKey"] = request.metricsKey;
    }

    if (!Util.isUnset(request.metricsType)) {
      body["MetricsType"] = request.metricsType;
    }

    if (!Util.isUnset(request.notice)) {
      body["Notice"] = request.notice;
    }

    if (!Util.isUnset(request.notifyMode)) {
      body["NotifyMode"] = request.notifyMode;
    }

    if (!Util.isUnset(request.notifyStrategy)) {
      body["NotifyStrategy"] = request.notifyStrategy;
    }

    if (!Util.isUnset(request.pids)) {
      body["Pids"] = request.pids;
    }

    if (!Util.isUnset(request.product)) {
      body["Product"] = request.product;
    }

    if (!Util.isUnset(request.promQL)) {
      body["PromQL"] = request.promQL;
    }

    if (!Util.isUnset(request.regionId)) {
      body["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.tags)) {
      body["Tags"] = request.tags;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateOrUpdateAlertRule",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CreateOrUpdateAlertRuleResponse>(await this.callApi(params, req, runtime), new CreateOrUpdateAlertRuleResponse({}));
    } else {
      return $tea.cast<CreateOrUpdateAlertRuleResponse>(await this.execute(params, req, runtime), new CreateOrUpdateAlertRuleResponse({}));
    }

  }

  /**
   * Creates or modifies an alert rule.
   * 
   * @param request - CreateOrUpdateAlertRuleRequest
   * @returns CreateOrUpdateAlertRuleResponse
   */
  async createOrUpdateAlertRule(request: CreateOrUpdateAlertRuleRequest): Promise<CreateOrUpdateAlertRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOrUpdateAlertRuleWithOptions(request, runtime);
  }

  /**
   * Creates or modifies an alert contact.
   * 
   * @param request - CreateOrUpdateContactRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateOrUpdateContactResponse
   */
  async createOrUpdateContactWithOptions(request: CreateOrUpdateContactRequest, runtime: $Util.RuntimeOptions): Promise<CreateOrUpdateContactResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dingRobotUrl)) {
      query["DingRobotUrl"] = request.dingRobotUrl;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.contactId)) {
      body["ContactId"] = request.contactId;
    }

    if (!Util.isUnset(request.contactName)) {
      body["ContactName"] = request.contactName;
    }

    if (!Util.isUnset(request.corpUserId)) {
      body["CorpUserId"] = request.corpUserId;
    }

    if (!Util.isUnset(request.email)) {
      body["Email"] = request.email;
    }

    if (!Util.isUnset(request.isEmailVerify)) {
      body["IsEmailVerify"] = request.isEmailVerify;
    }

    if (!Util.isUnset(request.phone)) {
      body["Phone"] = request.phone;
    }

    if (!Util.isUnset(request.reissueSendNotice)) {
      body["ReissueSendNotice"] = request.reissueSendNotice;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateOrUpdateContact",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CreateOrUpdateContactResponse>(await this.callApi(params, req, runtime), new CreateOrUpdateContactResponse({}));
    } else {
      return $tea.cast<CreateOrUpdateContactResponse>(await this.execute(params, req, runtime), new CreateOrUpdateContactResponse({}));
    }

  }

  /**
   * Creates or modifies an alert contact.
   * 
   * @param request - CreateOrUpdateContactRequest
   * @returns CreateOrUpdateContactResponse
   */
  async createOrUpdateContact(request: CreateOrUpdateContactRequest): Promise<CreateOrUpdateContactResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOrUpdateContactWithOptions(request, runtime);
  }

  /**
   * Creates or modifies an alert contact group.
   * 
   * @param request - CreateOrUpdateContactGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateOrUpdateContactGroupResponse
   */
  async createOrUpdateContactGroupWithOptions(request: CreateOrUpdateContactGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateOrUpdateContactGroupResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.contactGroupId)) {
      body["ContactGroupId"] = request.contactGroupId;
    }

    if (!Util.isUnset(request.contactGroupName)) {
      body["ContactGroupName"] = request.contactGroupName;
    }

    if (!Util.isUnset(request.contactIds)) {
      body["ContactIds"] = request.contactIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateOrUpdateContactGroup",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CreateOrUpdateContactGroupResponse>(await this.callApi(params, req, runtime), new CreateOrUpdateContactGroupResponse({}));
    } else {
      return $tea.cast<CreateOrUpdateContactGroupResponse>(await this.execute(params, req, runtime), new CreateOrUpdateContactGroupResponse({}));
    }

  }

  /**
   * Creates or modifies an alert contact group.
   * 
   * @param request - CreateOrUpdateContactGroupRequest
   * @returns CreateOrUpdateContactGroupResponse
   */
  async createOrUpdateContactGroup(request: CreateOrUpdateContactGroupRequest): Promise<CreateOrUpdateContactGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOrUpdateContactGroupWithOptions(request, runtime);
  }

  /**
   * Creates or modifies an EventBridge integration.
   * 
   * @param request - CreateOrUpdateEventBridgeIntegrationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateOrUpdateEventBridgeIntegrationResponse
   */
  async createOrUpdateEventBridgeIntegrationWithOptions(request: CreateOrUpdateEventBridgeIntegrationRequest, runtime: $Util.RuntimeOptions): Promise<CreateOrUpdateEventBridgeIntegrationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessKey)) {
      body["AccessKey"] = request.accessKey;
    }

    if (!Util.isUnset(request.accessSecret)) {
      body["AccessSecret"] = request.accessSecret;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.endpoint)) {
      body["Endpoint"] = request.endpoint;
    }

    if (!Util.isUnset(request.eventBusName)) {
      body["EventBusName"] = request.eventBusName;
    }

    if (!Util.isUnset(request.eventBusRegionId)) {
      body["EventBusRegionId"] = request.eventBusRegionId;
    }

    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.source)) {
      body["Source"] = request.source;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateOrUpdateEventBridgeIntegration",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CreateOrUpdateEventBridgeIntegrationResponse>(await this.callApi(params, req, runtime), new CreateOrUpdateEventBridgeIntegrationResponse({}));
    } else {
      return $tea.cast<CreateOrUpdateEventBridgeIntegrationResponse>(await this.execute(params, req, runtime), new CreateOrUpdateEventBridgeIntegrationResponse({}));
    }

  }

  /**
   * Creates or modifies an EventBridge integration.
   * 
   * @param request - CreateOrUpdateEventBridgeIntegrationRequest
   * @returns CreateOrUpdateEventBridgeIntegrationResponse
   */
  async createOrUpdateEventBridgeIntegration(request: CreateOrUpdateEventBridgeIntegrationRequest): Promise<CreateOrUpdateEventBridgeIntegrationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOrUpdateEventBridgeIntegrationWithOptions(request, runtime);
  }

  /**
   * Creates or updates an IM chatbot.
   * 
   * @param request - CreateOrUpdateIMRobotRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateOrUpdateIMRobotResponse
   */
  async createOrUpdateIMRobotWithOptions(request: CreateOrUpdateIMRobotRequest, runtime: $Util.RuntimeOptions): Promise<CreateOrUpdateIMRobotResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.cardTemplate)) {
      body["CardTemplate"] = request.cardTemplate;
    }

    if (!Util.isUnset(request.dailyNoc)) {
      body["DailyNoc"] = request.dailyNoc;
    }

    if (!Util.isUnset(request.dailyNocTime)) {
      body["DailyNocTime"] = request.dailyNocTime;
    }

    if (!Util.isUnset(request.dingSignKey)) {
      body["DingSignKey"] = request.dingSignKey;
    }

    if (!Util.isUnset(request.enableOutgoing)) {
      body["EnableOutgoing"] = request.enableOutgoing;
    }

    if (!Util.isUnset(request.robotAddress)) {
      body["RobotAddress"] = request.robotAddress;
    }

    if (!Util.isUnset(request.robotId)) {
      body["RobotId"] = request.robotId;
    }

    if (!Util.isUnset(request.robotName)) {
      body["RobotName"] = request.robotName;
    }

    if (!Util.isUnset(request.token)) {
      body["Token"] = request.token;
    }

    if (!Util.isUnset(request.type)) {
      body["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateOrUpdateIMRobot",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CreateOrUpdateIMRobotResponse>(await this.callApi(params, req, runtime), new CreateOrUpdateIMRobotResponse({}));
    } else {
      return $tea.cast<CreateOrUpdateIMRobotResponse>(await this.execute(params, req, runtime), new CreateOrUpdateIMRobotResponse({}));
    }

  }

  /**
   * Creates or updates an IM chatbot.
   * 
   * @param request - CreateOrUpdateIMRobotRequest
   * @returns CreateOrUpdateIMRobotResponse
   */
  async createOrUpdateIMRobot(request: CreateOrUpdateIMRobotRequest): Promise<CreateOrUpdateIMRobotResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOrUpdateIMRobotWithOptions(request, runtime);
  }

  /**
   * Creates or modifies a notification policy.
   * 
   * @param request - CreateOrUpdateNotificationPolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateOrUpdateNotificationPolicyResponse
   */
  async createOrUpdateNotificationPolicyWithOptions(request: CreateOrUpdateNotificationPolicyRequest, runtime: $Util.RuntimeOptions): Promise<CreateOrUpdateNotificationPolicyResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.directedMode)) {
      body["DirectedMode"] = request.directedMode;
    }

    if (!Util.isUnset(request.escalationPolicyId)) {
      body["EscalationPolicyId"] = request.escalationPolicyId;
    }

    if (!Util.isUnset(request.groupRule)) {
      body["GroupRule"] = request.groupRule;
    }

    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    if (!Util.isUnset(request.integrationId)) {
      body["IntegrationId"] = request.integrationId;
    }

    if (!Util.isUnset(request.matchingRules)) {
      body["MatchingRules"] = request.matchingRules;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.notifyRule)) {
      body["NotifyRule"] = request.notifyRule;
    }

    if (!Util.isUnset(request.notifyTemplate)) {
      body["NotifyTemplate"] = request.notifyTemplate;
    }

    if (!Util.isUnset(request.regionId)) {
      body["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.repeat)) {
      body["Repeat"] = request.repeat;
    }

    if (!Util.isUnset(request.repeatInterval)) {
      body["RepeatInterval"] = request.repeatInterval;
    }

    if (!Util.isUnset(request.sendRecoverMessage)) {
      body["SendRecoverMessage"] = request.sendRecoverMessage;
    }

    if (!Util.isUnset(request.state)) {
      body["State"] = request.state;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateOrUpdateNotificationPolicy",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CreateOrUpdateNotificationPolicyResponse>(await this.callApi(params, req, runtime), new CreateOrUpdateNotificationPolicyResponse({}));
    } else {
      return $tea.cast<CreateOrUpdateNotificationPolicyResponse>(await this.execute(params, req, runtime), new CreateOrUpdateNotificationPolicyResponse({}));
    }

  }

  /**
   * Creates or modifies a notification policy.
   * 
   * @param request - CreateOrUpdateNotificationPolicyRequest
   * @returns CreateOrUpdateNotificationPolicyResponse
   */
  async createOrUpdateNotificationPolicy(request: CreateOrUpdateNotificationPolicyRequest): Promise<CreateOrUpdateNotificationPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOrUpdateNotificationPolicyWithOptions(request, runtime);
  }

  /**
   * Creates or modifies a silence policy.
   * 
   * @param request - CreateOrUpdateSilencePolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateOrUpdateSilencePolicyResponse
   */
  async createOrUpdateSilencePolicyWithOptions(request: CreateOrUpdateSilencePolicyRequest, runtime: $Util.RuntimeOptions): Promise<CreateOrUpdateSilencePolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.effectiveTimeType)) {
      query["EffectiveTimeType"] = request.effectiveTimeType;
    }

    if (!Util.isUnset(request.timePeriod)) {
      query["TimePeriod"] = request.timePeriod;
    }

    if (!Util.isUnset(request.timeSlots)) {
      query["TimeSlots"] = request.timeSlots;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    if (!Util.isUnset(request.matchingRules)) {
      body["MatchingRules"] = request.matchingRules;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.regionId)) {
      body["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.state)) {
      body["State"] = request.state;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateOrUpdateSilencePolicy",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CreateOrUpdateSilencePolicyResponse>(await this.callApi(params, req, runtime), new CreateOrUpdateSilencePolicyResponse({}));
    } else {
      return $tea.cast<CreateOrUpdateSilencePolicyResponse>(await this.execute(params, req, runtime), new CreateOrUpdateSilencePolicyResponse({}));
    }

  }

  /**
   * Creates or modifies a silence policy.
   * 
   * @param request - CreateOrUpdateSilencePolicyRequest
   * @returns CreateOrUpdateSilencePolicyResponse
   */
  async createOrUpdateSilencePolicy(request: CreateOrUpdateSilencePolicyRequest): Promise<CreateOrUpdateSilencePolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOrUpdateSilencePolicyWithOptions(request, runtime);
  }

  /**
   * Creates or modifies a webhook alert contact.
   * 
   * @param request - CreateOrUpdateWebhookContactRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateOrUpdateWebhookContactResponse
   */
  async createOrUpdateWebhookContactWithOptions(request: CreateOrUpdateWebhookContactRequest, runtime: $Util.RuntimeOptions): Promise<CreateOrUpdateWebhookContactResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizHeaders)) {
      body["BizHeaders"] = request.bizHeaders;
    }

    if (!Util.isUnset(request.bizParams)) {
      body["BizParams"] = request.bizParams;
    }

    if (!Util.isUnset(request.body)) {
      body["Body"] = request.body;
    }

    if (!Util.isUnset(request.method)) {
      body["Method"] = request.method;
    }

    if (!Util.isUnset(request.recoverBody)) {
      body["RecoverBody"] = request.recoverBody;
    }

    if (!Util.isUnset(request.url)) {
      body["Url"] = request.url;
    }

    if (!Util.isUnset(request.webhookId)) {
      body["WebhookId"] = request.webhookId;
    }

    if (!Util.isUnset(request.webhookName)) {
      body["WebhookName"] = request.webhookName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateOrUpdateWebhookContact",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CreateOrUpdateWebhookContactResponse>(await this.callApi(params, req, runtime), new CreateOrUpdateWebhookContactResponse({}));
    } else {
      return $tea.cast<CreateOrUpdateWebhookContactResponse>(await this.execute(params, req, runtime), new CreateOrUpdateWebhookContactResponse({}));
    }

  }

  /**
   * Creates or modifies a webhook alert contact.
   * 
   * @param request - CreateOrUpdateWebhookContactRequest
   * @returns CreateOrUpdateWebhookContactResponse
   */
  async createOrUpdateWebhookContact(request: CreateOrUpdateWebhookContactRequest): Promise<CreateOrUpdateWebhookContactResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOrUpdateWebhookContactWithOptions(request, runtime);
  }

  /**
   * Creates an alert rule.
   * 
   * @param request - CreatePrometheusAlertRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreatePrometheusAlertRuleResponse
   */
  async createPrometheusAlertRuleWithOptions(request: CreatePrometheusAlertRuleRequest, runtime: $Util.RuntimeOptions): Promise<CreatePrometheusAlertRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertName)) {
      query["AlertName"] = request.alertName;
    }

    if (!Util.isUnset(request.annotations)) {
      query["Annotations"] = request.annotations;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dispatchRuleId)) {
      query["DispatchRuleId"] = request.dispatchRuleId;
    }

    if (!Util.isUnset(request.duration)) {
      query["Duration"] = request.duration;
    }

    if (!Util.isUnset(request.expression)) {
      query["Expression"] = request.expression;
    }

    if (!Util.isUnset(request.labels)) {
      query["Labels"] = request.labels;
    }

    if (!Util.isUnset(request.message)) {
      query["Message"] = request.message;
    }

    if (!Util.isUnset(request.notifyType)) {
      query["NotifyType"] = request.notifyType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreatePrometheusAlertRule",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CreatePrometheusAlertRuleResponse>(await this.callApi(params, req, runtime), new CreatePrometheusAlertRuleResponse({}));
    } else {
      return $tea.cast<CreatePrometheusAlertRuleResponse>(await this.execute(params, req, runtime), new CreatePrometheusAlertRuleResponse({}));
    }

  }

  /**
   * Creates an alert rule.
   * 
   * @param request - CreatePrometheusAlertRuleRequest
   * @returns CreatePrometheusAlertRuleResponse
   */
  async createPrometheusAlertRule(request: CreatePrometheusAlertRuleRequest): Promise<CreatePrometheusAlertRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createPrometheusAlertRuleWithOptions(request, runtime);
  }

  /**
   * Creates a Prometheus instance.
   * 
   * @param request - CreatePrometheusInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreatePrometheusInstanceResponse
   */
  async createPrometheusInstanceWithOptions(request: CreatePrometheusInstanceRequest, runtime: $Util.RuntimeOptions): Promise<CreatePrometheusInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.allSubClustersSuccess)) {
      query["AllSubClustersSuccess"] = request.allSubClustersSuccess;
    }

    if (!Util.isUnset(request.archiveDuration)) {
      query["ArchiveDuration"] = request.archiveDuration;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.clusterName)) {
      query["ClusterName"] = request.clusterName;
    }

    if (!Util.isUnset(request.clusterType)) {
      query["ClusterType"] = request.clusterType;
    }

    if (!Util.isUnset(request.duration)) {
      query["Duration"] = request.duration;
    }

    if (!Util.isUnset(request.grafanaInstanceId)) {
      query["GrafanaInstanceId"] = request.grafanaInstanceId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.securityGroupId)) {
      query["SecurityGroupId"] = request.securityGroupId;
    }

    if (!Util.isUnset(request.subClustersJson)) {
      query["SubClustersJson"] = request.subClustersJson;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    if (!Util.isUnset(request.vSwitchId)) {
      query["VSwitchId"] = request.vSwitchId;
    }

    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreatePrometheusInstance",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CreatePrometheusInstanceResponse>(await this.callApi(params, req, runtime), new CreatePrometheusInstanceResponse({}));
    } else {
      return $tea.cast<CreatePrometheusInstanceResponse>(await this.execute(params, req, runtime), new CreatePrometheusInstanceResponse({}));
    }

  }

  /**
   * Creates a Prometheus instance.
   * 
   * @param request - CreatePrometheusInstanceRequest
   * @returns CreatePrometheusInstanceResponse
   */
  async createPrometheusInstance(request: CreatePrometheusInstanceRequest): Promise<CreatePrometheusInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createPrometheusInstanceWithOptions(request, runtime);
  }

  /**
   * Creates a monitoring configuration for a Prometheus instance.
   * 
   * @param request - CreatePrometheusMonitoringRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreatePrometheusMonitoringResponse
   */
  async createPrometheusMonitoringWithOptions(request: CreatePrometheusMonitoringRequest, runtime: $Util.RuntimeOptions): Promise<CreatePrometheusMonitoringResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.configYaml)) {
      body["ConfigYaml"] = request.configYaml;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreatePrometheusMonitoring",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CreatePrometheusMonitoringResponse>(await this.callApi(params, req, runtime), new CreatePrometheusMonitoringResponse({}));
    } else {
      return $tea.cast<CreatePrometheusMonitoringResponse>(await this.execute(params, req, runtime), new CreatePrometheusMonitoringResponse({}));
    }

  }

  /**
   * Creates a monitoring configuration for a Prometheus instance.
   * 
   * @param request - CreatePrometheusMonitoringRequest
   * @returns CreatePrometheusMonitoringResponse
   */
  async createPrometheusMonitoring(request: CreatePrometheusMonitoringRequest): Promise<CreatePrometheusMonitoringResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createPrometheusMonitoringWithOptions(request, runtime);
  }

  /**
   * Creates a Browser Monitoring task for an application.
   * 
   * @param request - CreateRetcodeAppRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateRetcodeAppResponse
   */
  async createRetcodeAppWithOptions(request: CreateRetcodeAppRequest, runtime: $Util.RuntimeOptions): Promise<CreateRetcodeAppResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.retcodeAppName)) {
      query["RetcodeAppName"] = request.retcodeAppName;
    }

    if (!Util.isUnset(request.retcodeAppType)) {
      query["RetcodeAppType"] = request.retcodeAppType;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateRetcodeApp",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CreateRetcodeAppResponse>(await this.callApi(params, req, runtime), new CreateRetcodeAppResponse({}));
    } else {
      return $tea.cast<CreateRetcodeAppResponse>(await this.execute(params, req, runtime), new CreateRetcodeAppResponse({}));
    }

  }

  /**
   * Creates a Browser Monitoring task for an application.
   * 
   * @param request - CreateRetcodeAppRequest
   * @returns CreateRetcodeAppResponse
   */
  async createRetcodeApp(request: CreateRetcodeAppRequest): Promise<CreateRetcodeAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createRetcodeAppWithOptions(request, runtime);
  }

  /**
   * Create a Real User Monitoring (RUM) application.
   * 
   * @param tmpReq - CreateRumAppRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateRumAppResponse
   */
  async createRumAppWithOptions(tmpReq: CreateRumAppRequest, runtime: $Util.RuntimeOptions): Promise<CreateRumAppResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateRumAppShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.tag)) {
      request.tagShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tag, "Tag", "json");
    }

    let query = { };
    if (!Util.isUnset(request.appGroup)) {
      query["AppGroup"] = request.appGroup;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.nickName)) {
      query["NickName"] = request.nickName;
    }

    if (!Util.isUnset(request.packageName)) {
      query["PackageName"] = request.packageName;
    }

    if (!Util.isUnset(request.realRegionId)) {
      query["RealRegionId"] = request.realRegionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.siteType)) {
      query["SiteType"] = request.siteType;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    if (!Util.isUnset(request.tagShrink)) {
      query["Tag"] = request.tagShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateRumApp",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CreateRumAppResponse>(await this.callApi(params, req, runtime), new CreateRumAppResponse({}));
    } else {
      return $tea.cast<CreateRumAppResponse>(await this.execute(params, req, runtime), new CreateRumAppResponse({}));
    }

  }

  /**
   * Create a Real User Monitoring (RUM) application.
   * 
   * @param request - CreateRumAppRequest
   * @returns CreateRumAppResponse
   */
  async createRumApp(request: CreateRumAppRequest): Promise<CreateRumAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createRumAppWithOptions(request, runtime);
  }

  /**
   * Creates a file upload URL to upload SourceMap files, symbol table files, or dSYM files.
   * 
   * @remarks
   * This operation returns a URL. You can upload files to the URL. For more information, see [Upload local files with signed URLs](https://help.aliyun.com/document_detail/2579659.html).
   * 
   * @param request - CreateRumUploadFileUrlRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateRumUploadFileUrlResponse
   */
  async createRumUploadFileUrlWithOptions(request: CreateRumUploadFileUrlRequest, runtime: $Util.RuntimeOptions): Promise<CreateRumUploadFileUrlResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.contentType)) {
      query["ContentType"] = request.contentType;
    }

    if (!Util.isUnset(request.fileName)) {
      query["FileName"] = request.fileName;
    }

    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.sourcemapType)) {
      query["SourcemapType"] = request.sourcemapType;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    if (!Util.isUnset(request.versionId)) {
      query["VersionId"] = request.versionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateRumUploadFileUrl",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CreateRumUploadFileUrlResponse>(await this.callApi(params, req, runtime), new CreateRumUploadFileUrlResponse({}));
    } else {
      return $tea.cast<CreateRumUploadFileUrlResponse>(await this.execute(params, req, runtime), new CreateRumUploadFileUrlResponse({}));
    }

  }

  /**
   * Creates a file upload URL to upload SourceMap files, symbol table files, or dSYM files.
   * 
   * @remarks
   * This operation returns a URL. You can upload files to the URL. For more information, see [Upload local files with signed URLs](https://help.aliyun.com/document_detail/2579659.html).
   * 
   * @param request - CreateRumUploadFileUrlRequest
   * @returns CreateRumUploadFileUrlResponse
   */
  async createRumUploadFileUrl(request: CreateRumUploadFileUrlRequest): Promise<CreateRumUploadFileUrlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createRumUploadFileUrlWithOptions(request, runtime);
  }

  /**
   * Creates or updates a synthetic monitoring task.
   * 
   * @param tmpReq - CreateSyntheticTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateSyntheticTaskResponse
   */
  async createSyntheticTaskWithOptions(tmpReq: CreateSyntheticTaskRequest, runtime: $Util.RuntimeOptions): Promise<CreateSyntheticTaskResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateSyntheticTaskShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.commonParam)) {
      request.commonParamShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.commonParam, "CommonParam", "json");
    }

    if (!Util.isUnset(tmpReq.download)) {
      request.downloadShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.download, "Download", "json");
    }

    if (!Util.isUnset(tmpReq.extendInterval)) {
      request.extendIntervalShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extendInterval, "ExtendInterval", "json");
    }

    if (!Util.isUnset(tmpReq.monitorList)) {
      request.monitorListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.monitorList, "MonitorList", "json");
    }

    if (!Util.isUnset(tmpReq.navigation)) {
      request.navigationShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.navigation, "Navigation", "json");
    }

    if (!Util.isUnset(tmpReq.net)) {
      request.netShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.net, "Net", "json");
    }

    if (!Util.isUnset(tmpReq.protocol)) {
      request.protocolShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.protocol, "Protocol", "json");
    }

    let query = { };
    if (!Util.isUnset(request.commonParamShrink)) {
      query["CommonParam"] = request.commonParamShrink;
    }

    if (!Util.isUnset(request.downloadShrink)) {
      query["Download"] = request.downloadShrink;
    }

    if (!Util.isUnset(request.extendIntervalShrink)) {
      query["ExtendInterval"] = request.extendIntervalShrink;
    }

    if (!Util.isUnset(request.intervalTime)) {
      query["IntervalTime"] = request.intervalTime;
    }

    if (!Util.isUnset(request.intervalType)) {
      query["IntervalType"] = request.intervalType;
    }

    if (!Util.isUnset(request.ipType)) {
      query["IpType"] = request.ipType;
    }

    if (!Util.isUnset(request.monitorListShrink)) {
      query["MonitorList"] = request.monitorListShrink;
    }

    if (!Util.isUnset(request.navigationShrink)) {
      query["Navigation"] = request.navigationShrink;
    }

    if (!Util.isUnset(request.netShrink)) {
      query["Net"] = request.netShrink;
    }

    if (!Util.isUnset(request.protocolShrink)) {
      query["Protocol"] = request.protocolShrink;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.taskName)) {
      query["TaskName"] = request.taskName;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    if (!Util.isUnset(request.updateTask)) {
      query["UpdateTask"] = request.updateTask;
    }

    if (!Util.isUnset(request.url)) {
      query["Url"] = request.url;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateSyntheticTask",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CreateSyntheticTaskResponse>(await this.callApi(params, req, runtime), new CreateSyntheticTaskResponse({}));
    } else {
      return $tea.cast<CreateSyntheticTaskResponse>(await this.execute(params, req, runtime), new CreateSyntheticTaskResponse({}));
    }

  }

  /**
   * Creates or updates a synthetic monitoring task.
   * 
   * @param request - CreateSyntheticTaskRequest
   * @returns CreateSyntheticTaskResponse
   */
  async createSyntheticTask(request: CreateSyntheticTaskRequest): Promise<CreateSyntheticTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSyntheticTaskWithOptions(request, runtime);
  }

  /**
   * Creates a scheduled synthetic test task.
   * 
   * @param tmpReq - CreateTimingSyntheticTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateTimingSyntheticTaskResponse
   */
  async createTimingSyntheticTaskWithOptions(tmpReq: CreateTimingSyntheticTaskRequest, runtime: $Util.RuntimeOptions): Promise<CreateTimingSyntheticTaskResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateTimingSyntheticTaskShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.availableAssertions)) {
      request.availableAssertionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.availableAssertions, "AvailableAssertions", "json");
    }

    if (!Util.isUnset(tmpReq.commonSetting)) {
      request.commonSettingShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.commonSetting, "CommonSetting", "json");
    }

    if (!Util.isUnset(tmpReq.customPeriod)) {
      request.customPeriodShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.customPeriod, "CustomPeriod", "json");
    }

    if (!Util.isUnset(tmpReq.monitorConf)) {
      request.monitorConfShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.monitorConf, "MonitorConf", "json");
    }

    if (!Util.isUnset(tmpReq.monitors)) {
      request.monitorsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.monitors, "Monitors", "json");
    }

    if (!Util.isUnset(tmpReq.tags)) {
      request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, "Tags", "json");
    }

    let query = { };
    if (!Util.isUnset(request.availableAssertionsShrink)) {
      query["AvailableAssertions"] = request.availableAssertionsShrink;
    }

    if (!Util.isUnset(request.commonSettingShrink)) {
      query["CommonSetting"] = request.commonSettingShrink;
    }

    if (!Util.isUnset(request.customPeriodShrink)) {
      query["CustomPeriod"] = request.customPeriodShrink;
    }

    if (!Util.isUnset(request.frequency)) {
      query["Frequency"] = request.frequency;
    }

    if (!Util.isUnset(request.monitorCategory)) {
      query["MonitorCategory"] = request.monitorCategory;
    }

    if (!Util.isUnset(request.monitorConfShrink)) {
      query["MonitorConf"] = request.monitorConfShrink;
    }

    if (!Util.isUnset(request.monitorsShrink)) {
      query["Monitors"] = request.monitorsShrink;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.tagsShrink)) {
      query["Tags"] = request.tagsShrink;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateTimingSyntheticTask",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CreateTimingSyntheticTaskResponse>(await this.callApi(params, req, runtime), new CreateTimingSyntheticTaskResponse({}));
    } else {
      return $tea.cast<CreateTimingSyntheticTaskResponse>(await this.execute(params, req, runtime), new CreateTimingSyntheticTaskResponse({}));
    }

  }

  /**
   * Creates a scheduled synthetic test task.
   * 
   * @param request - CreateTimingSyntheticTaskRequest
   * @returns CreateTimingSyntheticTaskResponse
   */
  async createTimingSyntheticTask(request: CreateTimingSyntheticTaskRequest): Promise<CreateTimingSyntheticTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createTimingSyntheticTaskWithOptions(request, runtime);
  }

  /**
   * Adds a contact for webhook alerts.
   * 
   * @param request - CreateWebhookRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateWebhookResponse
   */
  async createWebhookWithOptions(request: CreateWebhookRequest, runtime: $Util.RuntimeOptions): Promise<CreateWebhookResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.body)) {
      query["Body"] = request.body;
    }

    if (!Util.isUnset(request.contactName)) {
      query["ContactName"] = request.contactName;
    }

    if (!Util.isUnset(request.httpHeaders)) {
      query["HttpHeaders"] = request.httpHeaders;
    }

    if (!Util.isUnset(request.httpParams)) {
      query["HttpParams"] = request.httpParams;
    }

    if (!Util.isUnset(request.method)) {
      query["Method"] = request.method;
    }

    if (!Util.isUnset(request.recoverBody)) {
      query["RecoverBody"] = request.recoverBody;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.url)) {
      query["Url"] = request.url;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateWebhook",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<CreateWebhookResponse>(await this.callApi(params, req, runtime), new CreateWebhookResponse({}));
    } else {
      return $tea.cast<CreateWebhookResponse>(await this.execute(params, req, runtime), new CreateWebhookResponse({}));
    }

  }

  /**
   * Adds a contact for webhook alerts.
   * 
   * @param request - CreateWebhookRequest
   * @returns CreateWebhookResponse
   */
  async createWebhook(request: CreateWebhookRequest): Promise<CreateWebhookResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createWebhookWithOptions(request, runtime);
  }

  /**
   * Disables an authentication token.
   * 
   * @param request - DelAuthTokenRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DelAuthTokenResponse
   */
  async delAuthTokenWithOptions(request: DelAuthTokenRequest, runtime: $Util.RuntimeOptions): Promise<DelAuthTokenResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DelAuthToken",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DelAuthTokenResponse>(await this.callApi(params, req, runtime), new DelAuthTokenResponse({}));
    } else {
      return $tea.cast<DelAuthTokenResponse>(await this.execute(params, req, runtime), new DelAuthTokenResponse({}));
    }

  }

  /**
   * Disables an authentication token.
   * 
   * @param request - DelAuthTokenRequest
   * @returns DelAuthTokenResponse
   */
  async delAuthToken(request: DelAuthTokenRequest): Promise<DelAuthTokenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.delAuthTokenWithOptions(request, runtime);
  }

  /**
   * Delete AddonRelease data by AddonRelease name.
   * 
   * @param request - DeleteAddonReleaseRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteAddonReleaseResponse
   */
  async deleteAddonReleaseWithOptions(request: DeleteAddonReleaseRequest, runtime: $Util.RuntimeOptions): Promise<DeleteAddonReleaseResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.addonName)) {
      query["AddonName"] = request.addonName;
    }

    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.force)) {
      query["Force"] = request.force;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.releaseName)) {
      query["ReleaseName"] = request.releaseName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteAddonRelease",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteAddonReleaseResponse>(await this.callApi(params, req, runtime), new DeleteAddonReleaseResponse({}));
    } else {
      return $tea.cast<DeleteAddonReleaseResponse>(await this.execute(params, req, runtime), new DeleteAddonReleaseResponse({}));
    }

  }

  /**
   * Delete AddonRelease data by AddonRelease name.
   * 
   * @param request - DeleteAddonReleaseRequest
   * @returns DeleteAddonReleaseResponse
   */
  async deleteAddonRelease(request: DeleteAddonReleaseRequest): Promise<DeleteAddonReleaseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteAddonReleaseWithOptions(request, runtime);
  }

  /**
   * Deletes an DeleteAlertContact contact.
   * 
   * @remarks
   * *******
   * 
   * @param request - DeleteAlertContactRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteAlertContactResponse
   */
  async deleteAlertContactWithOptions(request: DeleteAlertContactRequest, runtime: $Util.RuntimeOptions): Promise<DeleteAlertContactResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contactId)) {
      query["ContactId"] = request.contactId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteAlertContact",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteAlertContactResponse>(await this.callApi(params, req, runtime), new DeleteAlertContactResponse({}));
    } else {
      return $tea.cast<DeleteAlertContactResponse>(await this.execute(params, req, runtime), new DeleteAlertContactResponse({}));
    }

  }

  /**
   * Deletes an DeleteAlertContact contact.
   * 
   * @remarks
   * *******
   * 
   * @param request - DeleteAlertContactRequest
   * @returns DeleteAlertContactResponse
   */
  async deleteAlertContact(request: DeleteAlertContactRequest): Promise<DeleteAlertContactResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteAlertContactWithOptions(request, runtime);
  }

  /**
   * Deletes an DeleteAlertContactGroup contact group.
   * 
   * @param request - DeleteAlertContactGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteAlertContactGroupResponse
   */
  async deleteAlertContactGroupWithOptions(request: DeleteAlertContactGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteAlertContactGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contactGroupId)) {
      query["ContactGroupId"] = request.contactGroupId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteAlertContactGroup",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteAlertContactGroupResponse>(await this.callApi(params, req, runtime), new DeleteAlertContactGroupResponse({}));
    } else {
      return $tea.cast<DeleteAlertContactGroupResponse>(await this.execute(params, req, runtime), new DeleteAlertContactGroupResponse({}));
    }

  }

  /**
   * Deletes an DeleteAlertContactGroup contact group.
   * 
   * @param request - DeleteAlertContactGroupRequest
   * @returns DeleteAlertContactGroupResponse
   */
  async deleteAlertContactGroup(request: DeleteAlertContactGroupRequest): Promise<DeleteAlertContactGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteAlertContactGroupWithOptions(request, runtime);
  }

  /**
   * Deletes an alert rule.
   * 
   * @param request - DeleteAlertRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteAlertRuleResponse
   */
  async deleteAlertRuleWithOptions(request: DeleteAlertRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteAlertRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertId)) {
      query["AlertId"] = request.alertId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteAlertRule",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteAlertRuleResponse>(await this.callApi(params, req, runtime), new DeleteAlertRuleResponse({}));
    } else {
      return $tea.cast<DeleteAlertRuleResponse>(await this.execute(params, req, runtime), new DeleteAlertRuleResponse({}));
    }

  }

  /**
   * Deletes an alert rule.
   * 
   * @param request - DeleteAlertRuleRequest
   * @returns DeleteAlertRuleResponse
   */
  async deleteAlertRule(request: DeleteAlertRuleRequest): Promise<DeleteAlertRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteAlertRuleWithOptions(request, runtime);
  }

  /**
   * Deletes alert rules.
   * 
   * @remarks
   * The current operation is no longer maintained. Call the DeleteAlertRule operation of Alert Management (New) to delete alert rules.
   * 
   * @param request - DeleteAlertRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteAlertRulesResponse
   */
  async deleteAlertRulesWithOptions(request: DeleteAlertRulesRequest, runtime: $Util.RuntimeOptions): Promise<DeleteAlertRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertIds)) {
      query["AlertIds"] = request.alertIds;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteAlertRules",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteAlertRulesResponse>(await this.callApi(params, req, runtime), new DeleteAlertRulesResponse({}));
    } else {
      return $tea.cast<DeleteAlertRulesResponse>(await this.execute(params, req, runtime), new DeleteAlertRulesResponse({}));
    }

  }

  /**
   * Deletes alert rules.
   * 
   * @remarks
   * The current operation is no longer maintained. Call the DeleteAlertRule operation of Alert Management (New) to delete alert rules.
   * 
   * @param request - DeleteAlertRulesRequest
   * @returns DeleteAlertRulesResponse
   */
  async deleteAlertRules(request: DeleteAlertRulesRequest): Promise<DeleteAlertRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteAlertRulesWithOptions(request, runtime);
  }

  /**
   * Deletes multiple applications at a time based on the process IDs (PIDs).
   * 
   * @param request - DeleteAppListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteAppListResponse
   */
  async deleteAppListWithOptions(request: DeleteAppListRequest, runtime: $Util.RuntimeOptions): Promise<DeleteAppListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pids)) {
      query["Pids"] = request.pids;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteAppList",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteAppListResponse>(await this.callApi(params, req, runtime), new DeleteAppListResponse({}));
    } else {
      return $tea.cast<DeleteAppListResponse>(await this.execute(params, req, runtime), new DeleteAppListResponse({}));
    }

  }

  /**
   * Deletes multiple applications at a time based on the process IDs (PIDs).
   * 
   * @param request - DeleteAppListRequest
   * @returns DeleteAppListResponse
   */
  async deleteAppList(request: DeleteAppListRequest): Promise<DeleteAppListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteAppListWithOptions(request, runtime);
  }

  /**
   * Releases a Prometheus instance for Alibaba Cloud services.
   * 
   * @deprecated OpenAPI DeleteCmsExporter is deprecated, please use ARMS::2019-08-08::DeleteAddonRelease instead.
   * 
   * @param request - DeleteCmsExporterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteCmsExporterResponse
   */
  // Deprecated
  async deleteCmsExporterWithOptions(request: DeleteCmsExporterRequest, runtime: $Util.RuntimeOptions): Promise<DeleteCmsExporterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteCmsExporter",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteCmsExporterResponse>(await this.callApi(params, req, runtime), new DeleteCmsExporterResponse({}));
    } else {
      return $tea.cast<DeleteCmsExporterResponse>(await this.execute(params, req, runtime), new DeleteCmsExporterResponse({}));
    }

  }

  /**
   * Releases a Prometheus instance for Alibaba Cloud services.
   * 
   * @deprecated OpenAPI DeleteCmsExporter is deprecated, please use ARMS::2019-08-08::DeleteAddonRelease instead.
   * 
   * @param request - DeleteCmsExporterRequest
   * @returns DeleteCmsExporterResponse
   */
  // Deprecated
  async deleteCmsExporter(request: DeleteCmsExporterRequest): Promise<DeleteCmsExporterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteCmsExporterWithOptions(request, runtime);
  }

  /**
   * Deletes alert contacts.
   * 
   * @param request - DeleteContactRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteContactResponse
   */
  async deleteContactWithOptions(request: DeleteContactRequest, runtime: $Util.RuntimeOptions): Promise<DeleteContactResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contactId)) {
      query["ContactId"] = request.contactId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteContact",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteContactResponse>(await this.callApi(params, req, runtime), new DeleteContactResponse({}));
    } else {
      return $tea.cast<DeleteContactResponse>(await this.execute(params, req, runtime), new DeleteContactResponse({}));
    }

  }

  /**
   * Deletes alert contacts.
   * 
   * @param request - DeleteContactRequest
   * @returns DeleteContactResponse
   */
  async deleteContact(request: DeleteContactRequest): Promise<DeleteContactResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteContactWithOptions(request, runtime);
  }

  /**
   * Deletes an alert contact group.
   * 
   * @param request - DeleteContactGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteContactGroupResponse
   */
  async deleteContactGroupWithOptions(request: DeleteContactGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteContactGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contactGroupId)) {
      query["ContactGroupId"] = request.contactGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteContactGroup",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteContactGroupResponse>(await this.callApi(params, req, runtime), new DeleteContactGroupResponse({}));
    } else {
      return $tea.cast<DeleteContactGroupResponse>(await this.execute(params, req, runtime), new DeleteContactGroupResponse({}));
    }

  }

  /**
   * Deletes an alert contact group.
   * 
   * @param request - DeleteContactGroupRequest
   * @returns DeleteContactGroupResponse
   */
  async deleteContactGroup(request: DeleteContactGroupRequest): Promise<DeleteContactGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteContactGroupWithOptions(request, runtime);
  }

  /**
   * Deletes the dispatch policy of a specified ID.
   * 
   * @param request - DeleteDispatchRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDispatchRuleResponse
   */
  async deleteDispatchRuleWithOptions(request: DeleteDispatchRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDispatchRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDispatchRule",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteDispatchRuleResponse>(await this.callApi(params, req, runtime), new DeleteDispatchRuleResponse({}));
    } else {
      return $tea.cast<DeleteDispatchRuleResponse>(await this.execute(params, req, runtime), new DeleteDispatchRuleResponse({}));
    }

  }

  /**
   * Deletes the dispatch policy of a specified ID.
   * 
   * @param request - DeleteDispatchRuleRequest
   * @returns DeleteDispatchRuleResponse
   */
  async deleteDispatchRule(request: DeleteDispatchRuleRequest): Promise<DeleteDispatchRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDispatchRuleWithOptions(request, runtime);
  }

  /**
   * Deletes a custom job for an environment.
   * 
   * @param request - DeleteEnvCustomJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteEnvCustomJobResponse
   */
  async deleteEnvCustomJobWithOptions(request: DeleteEnvCustomJobRequest, runtime: $Util.RuntimeOptions): Promise<DeleteEnvCustomJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.customJobName)) {
      query["CustomJobName"] = request.customJobName;
    }

    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteEnvCustomJob",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteEnvCustomJobResponse>(await this.callApi(params, req, runtime), new DeleteEnvCustomJobResponse({}));
    } else {
      return $tea.cast<DeleteEnvCustomJobResponse>(await this.execute(params, req, runtime), new DeleteEnvCustomJobResponse({}));
    }

  }

  /**
   * Deletes a custom job for an environment.
   * 
   * @param request - DeleteEnvCustomJobRequest
   * @returns DeleteEnvCustomJobResponse
   */
  async deleteEnvCustomJob(request: DeleteEnvCustomJobRequest): Promise<DeleteEnvCustomJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteEnvCustomJobWithOptions(request, runtime);
  }

  /**
   * Deletes the PodMonitor of an environment.
   * 
   * @param request - DeleteEnvPodMonitorRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteEnvPodMonitorResponse
   */
  async deleteEnvPodMonitorWithOptions(request: DeleteEnvPodMonitorRequest, runtime: $Util.RuntimeOptions): Promise<DeleteEnvPodMonitorResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.podMonitorName)) {
      query["PodMonitorName"] = request.podMonitorName;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteEnvPodMonitor",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteEnvPodMonitorResponse>(await this.callApi(params, req, runtime), new DeleteEnvPodMonitorResponse({}));
    } else {
      return $tea.cast<DeleteEnvPodMonitorResponse>(await this.execute(params, req, runtime), new DeleteEnvPodMonitorResponse({}));
    }

  }

  /**
   * Deletes the PodMonitor of an environment.
   * 
   * @param request - DeleteEnvPodMonitorRequest
   * @returns DeleteEnvPodMonitorResponse
   */
  async deleteEnvPodMonitor(request: DeleteEnvPodMonitorRequest): Promise<DeleteEnvPodMonitorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteEnvPodMonitorWithOptions(request, runtime);
  }

  /**
   * Deletes the ServiceMonitor of an environment.
   * 
   * @param request - DeleteEnvServiceMonitorRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteEnvServiceMonitorResponse
   */
  async deleteEnvServiceMonitorWithOptions(request: DeleteEnvServiceMonitorRequest, runtime: $Util.RuntimeOptions): Promise<DeleteEnvServiceMonitorResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.serviceMonitorName)) {
      query["ServiceMonitorName"] = request.serviceMonitorName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteEnvServiceMonitor",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteEnvServiceMonitorResponse>(await this.callApi(params, req, runtime), new DeleteEnvServiceMonitorResponse({}));
    } else {
      return $tea.cast<DeleteEnvServiceMonitorResponse>(await this.execute(params, req, runtime), new DeleteEnvServiceMonitorResponse({}));
    }

  }

  /**
   * Deletes the ServiceMonitor of an environment.
   * 
   * @param request - DeleteEnvServiceMonitorRequest
   * @returns DeleteEnvServiceMonitorResponse
   */
  async deleteEnvServiceMonitor(request: DeleteEnvServiceMonitorRequest): Promise<DeleteEnvServiceMonitorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteEnvServiceMonitorWithOptions(request, runtime);
  }

  /**
   * Deletes an environment instance.
   * 
   * @param request - DeleteEnvironmentRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteEnvironmentResponse
   */
  async deleteEnvironmentWithOptions(request: DeleteEnvironmentRequest, runtime: $Util.RuntimeOptions): Promise<DeleteEnvironmentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deletePromInstance)) {
      query["DeletePromInstance"] = request.deletePromInstance;
    }

    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteEnvironment",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteEnvironmentResponse>(await this.callApi(params, req, runtime), new DeleteEnvironmentResponse({}));
    } else {
      return $tea.cast<DeleteEnvironmentResponse>(await this.execute(params, req, runtime), new DeleteEnvironmentResponse({}));
    }

  }

  /**
   * Deletes an environment instance.
   * 
   * @param request - DeleteEnvironmentRequest
   * @returns DeleteEnvironmentResponse
   */
  async deleteEnvironment(request: DeleteEnvironmentRequest): Promise<DeleteEnvironmentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteEnvironmentWithOptions(request, runtime);
  }

  /**
   * Deletes a feature.
   * 
   * @param request - DeleteEnvironmentFeatureRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteEnvironmentFeatureResponse
   */
  async deleteEnvironmentFeatureWithOptions(request: DeleteEnvironmentFeatureRequest, runtime: $Util.RuntimeOptions): Promise<DeleteEnvironmentFeatureResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.featureName)) {
      query["FeatureName"] = request.featureName;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteEnvironmentFeature",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteEnvironmentFeatureResponse>(await this.callApi(params, req, runtime), new DeleteEnvironmentFeatureResponse({}));
    } else {
      return $tea.cast<DeleteEnvironmentFeatureResponse>(await this.execute(params, req, runtime), new DeleteEnvironmentFeatureResponse({}));
    }

  }

  /**
   * Deletes a feature.
   * 
   * @param request - DeleteEnvironmentFeatureRequest
   * @returns DeleteEnvironmentFeatureResponse
   */
  async deleteEnvironmentFeature(request: DeleteEnvironmentFeatureRequest): Promise<DeleteEnvironmentFeatureResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteEnvironmentFeatureWithOptions(request, runtime);
  }

  /**
   * Deletes an EventBridge integration.
   * 
   * @param request - DeleteEventBridgeIntegrationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteEventBridgeIntegrationResponse
   */
  async deleteEventBridgeIntegrationWithOptions(request: DeleteEventBridgeIntegrationRequest, runtime: $Util.RuntimeOptions): Promise<DeleteEventBridgeIntegrationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteEventBridgeIntegration",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteEventBridgeIntegrationResponse>(await this.callApi(params, req, runtime), new DeleteEventBridgeIntegrationResponse({}));
    } else {
      return $tea.cast<DeleteEventBridgeIntegrationResponse>(await this.execute(params, req, runtime), new DeleteEventBridgeIntegrationResponse({}));
    }

  }

  /**
   * Deletes an EventBridge integration.
   * 
   * @param request - DeleteEventBridgeIntegrationRequest
   * @returns DeleteEventBridgeIntegrationResponse
   */
  async deleteEventBridgeIntegration(request: DeleteEventBridgeIntegrationRequest): Promise<DeleteEventBridgeIntegrationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteEventBridgeIntegrationWithOptions(request, runtime);
  }

  /**
   * Deletes Grafana dashboard resources from a cluster monitored by Prometheus Service.
   * 
   * @param request - DeleteGrafanaResourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteGrafanaResourceResponse
   */
  async deleteGrafanaResourceWithOptions(request: DeleteGrafanaResourceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteGrafanaResourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.clusterId)) {
      body["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.clusterName)) {
      body["ClusterName"] = request.clusterName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteGrafanaResource",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteGrafanaResourceResponse>(await this.callApi(params, req, runtime), new DeleteGrafanaResourceResponse({}));
    } else {
      return $tea.cast<DeleteGrafanaResourceResponse>(await this.execute(params, req, runtime), new DeleteGrafanaResourceResponse({}));
    }

  }

  /**
   * Deletes Grafana dashboard resources from a cluster monitored by Prometheus Service.
   * 
   * @param request - DeleteGrafanaResourceRequest
   * @returns DeleteGrafanaResourceResponse
   */
  async deleteGrafanaResource(request: DeleteGrafanaResourceRequest): Promise<DeleteGrafanaResourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteGrafanaResourceWithOptions(request, runtime);
  }

  /**
   * Deletes a Managed Service for Prometheus workspace.
   * 
   * @remarks
   *   You can delete workspaces only in Managed Service for Prometheus Beta Edition, which is `free of charge`.
   * *   You cannot delete workspaces in Managed Service for Prometheus Developer Edition, Pro Edition, and Advanced Edition. You can go to the [User Center](https://usercenter2.aliyun.com/refund/refund) to unsubscribe from workspaces.
   * 
   * @param request - DeleteGrafanaWorkspaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteGrafanaWorkspaceResponse
   */
  async deleteGrafanaWorkspaceWithOptions(request: DeleteGrafanaWorkspaceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteGrafanaWorkspaceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.grafanaWorkspaceId)) {
      query["GrafanaWorkspaceId"] = request.grafanaWorkspaceId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteGrafanaWorkspace",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteGrafanaWorkspaceResponse>(await this.callApi(params, req, runtime), new DeleteGrafanaWorkspaceResponse({}));
    } else {
      return $tea.cast<DeleteGrafanaWorkspaceResponse>(await this.execute(params, req, runtime), new DeleteGrafanaWorkspaceResponse({}));
    }

  }

  /**
   * Deletes a Managed Service for Prometheus workspace.
   * 
   * @remarks
   *   You can delete workspaces only in Managed Service for Prometheus Beta Edition, which is `free of charge`.
   * *   You cannot delete workspaces in Managed Service for Prometheus Developer Edition, Pro Edition, and Advanced Edition. You can go to the [User Center](https://usercenter2.aliyun.com/refund/refund) to unsubscribe from workspaces.
   * 
   * @param request - DeleteGrafanaWorkspaceRequest
   * @returns DeleteGrafanaWorkspaceResponse
   */
  async deleteGrafanaWorkspace(request: DeleteGrafanaWorkspaceRequest): Promise<DeleteGrafanaWorkspaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteGrafanaWorkspaceWithOptions(request, runtime);
  }

  /**
   * Deletes an instant messaging (IM) chatbot.
   * 
   * @param request - DeleteIMRobotRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteIMRobotResponse
   */
  async deleteIMRobotWithOptions(request: DeleteIMRobotRequest, runtime: $Util.RuntimeOptions): Promise<DeleteIMRobotResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.robotId)) {
      query["RobotId"] = request.robotId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteIMRobot",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteIMRobotResponse>(await this.callApi(params, req, runtime), new DeleteIMRobotResponse({}));
    } else {
      return $tea.cast<DeleteIMRobotResponse>(await this.execute(params, req, runtime), new DeleteIMRobotResponse({}));
    }

  }

  /**
   * Deletes an instant messaging (IM) chatbot.
   * 
   * @param request - DeleteIMRobotRequest
   * @returns DeleteIMRobotResponse
   */
  async deleteIMRobot(request: DeleteIMRobotRequest): Promise<DeleteIMRobotResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteIMRobotWithOptions(request, runtime);
  }

  /**
   * Deletes collection rules from an integration.
   * 
   * @deprecated OpenAPI DeleteIntegration is deprecated, please use ARMS::2019-08-08::DeleteAddonRelease instead.
   * 
   * @param request - DeleteIntegrationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteIntegrationResponse
   */
  // Deprecated
  async deleteIntegrationWithOptions(request: DeleteIntegrationRequest, runtime: $Util.RuntimeOptions): Promise<DeleteIntegrationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.integration)) {
      query["Integration"] = request.integration;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteIntegration",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteIntegrationResponse>(await this.callApi(params, req, runtime), new DeleteIntegrationResponse({}));
    } else {
      return $tea.cast<DeleteIntegrationResponse>(await this.execute(params, req, runtime), new DeleteIntegrationResponse({}));
    }

  }

  /**
   * Deletes collection rules from an integration.
   * 
   * @deprecated OpenAPI DeleteIntegration is deprecated, please use ARMS::2019-08-08::DeleteAddonRelease instead.
   * 
   * @param request - DeleteIntegrationRequest
   * @returns DeleteIntegrationResponse
   */
  // Deprecated
  async deleteIntegration(request: DeleteIntegrationRequest): Promise<DeleteIntegrationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteIntegrationWithOptions(request, runtime);
  }

  /**
   * Deletes an alert integration.
   * 
   * @param request - DeleteIntegrationsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteIntegrationsResponse
   */
  async deleteIntegrationsWithOptions(request: DeleteIntegrationsRequest, runtime: $Util.RuntimeOptions): Promise<DeleteIntegrationsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteIntegrations",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteIntegrationsResponse>(await this.callApi(params, req, runtime), new DeleteIntegrationsResponse({}));
    } else {
      return $tea.cast<DeleteIntegrationsResponse>(await this.execute(params, req, runtime), new DeleteIntegrationsResponse({}));
    }

  }

  /**
   * Deletes an alert integration.
   * 
   * @param request - DeleteIntegrationsRequest
   * @returns DeleteIntegrationsResponse
   */
  async deleteIntegrations(request: DeleteIntegrationsRequest): Promise<DeleteIntegrationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteIntegrationsWithOptions(request, runtime);
  }

  /**
   * Deletes a notification policy based on its ID.
   * 
   * @param request - DeleteNotificationPolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteNotificationPolicyResponse
   */
  async deleteNotificationPolicyWithOptions(request: DeleteNotificationPolicyRequest, runtime: $Util.RuntimeOptions): Promise<DeleteNotificationPolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteNotificationPolicy",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteNotificationPolicyResponse>(await this.callApi(params, req, runtime), new DeleteNotificationPolicyResponse({}));
    } else {
      return $tea.cast<DeleteNotificationPolicyResponse>(await this.execute(params, req, runtime), new DeleteNotificationPolicyResponse({}));
    }

  }

  /**
   * Deletes a notification policy based on its ID.
   * 
   * @param request - DeleteNotificationPolicyRequest
   * @returns DeleteNotificationPolicyResponse
   */
  async deleteNotificationPolicy(request: DeleteNotificationPolicyRequest): Promise<DeleteNotificationPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteNotificationPolicyWithOptions(request, runtime);
  }

  /**
   * Deletes an alert rule of Prometheus Service.
   * 
   * @param request - DeletePrometheusAlertRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeletePrometheusAlertRuleResponse
   */
  async deletePrometheusAlertRuleWithOptions(request: DeletePrometheusAlertRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeletePrometheusAlertRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertId)) {
      query["AlertId"] = request.alertId;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeletePrometheusAlertRule",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeletePrometheusAlertRuleResponse>(await this.callApi(params, req, runtime), new DeletePrometheusAlertRuleResponse({}));
    } else {
      return $tea.cast<DeletePrometheusAlertRuleResponse>(await this.execute(params, req, runtime), new DeletePrometheusAlertRuleResponse({}));
    }

  }

  /**
   * Deletes an alert rule of Prometheus Service.
   * 
   * @param request - DeletePrometheusAlertRuleRequest
   * @returns DeletePrometheusAlertRuleResponse
   */
  async deletePrometheusAlertRule(request: DeletePrometheusAlertRuleRequest): Promise<DeletePrometheusAlertRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deletePrometheusAlertRuleWithOptions(request, runtime);
  }

  /**
   * Deletes a global aggregation instance from Prometheus Service.
   * 
   * @param request - DeletePrometheusGlobalViewRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeletePrometheusGlobalViewResponse
   */
  async deletePrometheusGlobalViewWithOptions(request: DeletePrometheusGlobalViewRequest, runtime: $Util.RuntimeOptions): Promise<DeletePrometheusGlobalViewResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.globalViewClusterId)) {
      query["GlobalViewClusterId"] = request.globalViewClusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeletePrometheusGlobalView",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeletePrometheusGlobalViewResponse>(await this.callApi(params, req, runtime), new DeletePrometheusGlobalViewResponse({}));
    } else {
      return $tea.cast<DeletePrometheusGlobalViewResponse>(await this.execute(params, req, runtime), new DeletePrometheusGlobalViewResponse({}));
    }

  }

  /**
   * Deletes a global aggregation instance from Prometheus Service.
   * 
   * @param request - DeletePrometheusGlobalViewRequest
   * @returns DeletePrometheusGlobalViewResponse
   */
  async deletePrometheusGlobalView(request: DeletePrometheusGlobalViewRequest): Promise<DeletePrometheusGlobalViewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deletePrometheusGlobalViewWithOptions(request, runtime);
  }

  /**
   * Deletes an exporter from a Prometheus instance for Container Service or a Prometheus instance for ECS.
   * 
   * @param request - DeletePrometheusIntegrationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeletePrometheusIntegrationResponse
   */
  async deletePrometheusIntegrationWithOptions(request: DeletePrometheusIntegrationRequest, runtime: $Util.RuntimeOptions): Promise<DeletePrometheusIntegrationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.integrationType)) {
      query["IntegrationType"] = request.integrationType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeletePrometheusIntegration",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeletePrometheusIntegrationResponse>(await this.callApi(params, req, runtime), new DeletePrometheusIntegrationResponse({}));
    } else {
      return $tea.cast<DeletePrometheusIntegrationResponse>(await this.execute(params, req, runtime), new DeletePrometheusIntegrationResponse({}));
    }

  }

  /**
   * Deletes an exporter from a Prometheus instance for Container Service or a Prometheus instance for ECS.
   * 
   * @param request - DeletePrometheusIntegrationRequest
   * @returns DeletePrometheusIntegrationResponse
   */
  async deletePrometheusIntegration(request: DeletePrometheusIntegrationRequest): Promise<DeletePrometheusIntegrationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deletePrometheusIntegrationWithOptions(request, runtime);
  }

  /**
   * Deletes the monitoring configuration of a Prometheus instance.
   * 
   * @param request - DeletePrometheusMonitoringRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeletePrometheusMonitoringResponse
   */
  async deletePrometheusMonitoringWithOptions(request: DeletePrometheusMonitoringRequest, runtime: $Util.RuntimeOptions): Promise<DeletePrometheusMonitoringResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.monitoringName)) {
      query["MonitoringName"] = request.monitoringName;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeletePrometheusMonitoring",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeletePrometheusMonitoringResponse>(await this.callApi(params, req, runtime), new DeletePrometheusMonitoringResponse({}));
    } else {
      return $tea.cast<DeletePrometheusMonitoringResponse>(await this.execute(params, req, runtime), new DeletePrometheusMonitoringResponse({}));
    }

  }

  /**
   * Deletes the monitoring configuration of a Prometheus instance.
   * 
   * @param request - DeletePrometheusMonitoringRequest
   * @returns DeletePrometheusMonitoringResponse
   */
  async deletePrometheusMonitoring(request: DeletePrometheusMonitoringRequest): Promise<DeletePrometheusMonitoringResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deletePrometheusMonitoringWithOptions(request, runtime);
  }

  /**
   * Deletes a Browser Monitoring task.
   * 
   * @param request - DeleteRetcodeAppRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRetcodeAppResponse
   */
  async deleteRetcodeAppWithOptions(request: DeleteRetcodeAppRequest, runtime: $Util.RuntimeOptions): Promise<DeleteRetcodeAppResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteRetcodeApp",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteRetcodeAppResponse>(await this.callApi(params, req, runtime), new DeleteRetcodeAppResponse({}));
    } else {
      return $tea.cast<DeleteRetcodeAppResponse>(await this.execute(params, req, runtime), new DeleteRetcodeAppResponse({}));
    }

  }

  /**
   * Deletes a Browser Monitoring task.
   * 
   * @param request - DeleteRetcodeAppRequest
   * @returns DeleteRetcodeAppResponse
   */
  async deleteRetcodeApp(request: DeleteRetcodeAppRequest): Promise<DeleteRetcodeAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteRetcodeAppWithOptions(request, runtime);
  }

  /**
   * Deletes a RUM application.
   * 
   * @param request - DeleteRumAppRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRumAppResponse
   */
  async deleteRumAppWithOptions(request: DeleteRumAppRequest, runtime: $Util.RuntimeOptions): Promise<DeleteRumAppResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appGroup)) {
      query["AppGroup"] = request.appGroup;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.realRegionId)) {
      query["RealRegionId"] = request.realRegionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteRumApp",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteRumAppResponse>(await this.callApi(params, req, runtime), new DeleteRumAppResponse({}));
    } else {
      return $tea.cast<DeleteRumAppResponse>(await this.execute(params, req, runtime), new DeleteRumAppResponse({}));
    }

  }

  /**
   * Deletes a RUM application.
   * 
   * @param request - DeleteRumAppRequest
   * @returns DeleteRumAppResponse
   */
  async deleteRumApp(request: DeleteRumAppRequest): Promise<DeleteRumAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteRumAppWithOptions(request, runtime);
  }

  /**
   * Deletes a file such as a symbol table or SourceMap.
   * 
   * @remarks
   * Real User Monitoring (RUM) is available only in the China (Hangzhou), Singapore, and US (Silicon Valley) regions. Select the correct endpoint.
   * 
   * @param request - DeleteRumUploadFileRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRumUploadFileResponse
   */
  async deleteRumUploadFileWithOptions(request: DeleteRumUploadFileRequest, runtime: $Util.RuntimeOptions): Promise<DeleteRumUploadFileResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.batchItems)) {
      query["BatchItems"] = request.batchItems;
    }

    if (!Util.isUnset(request.fileName)) {
      query["FileName"] = request.fileName;
    }

    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    if (!Util.isUnset(request.versionId)) {
      query["VersionId"] = request.versionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteRumUploadFile",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteRumUploadFileResponse>(await this.callApi(params, req, runtime), new DeleteRumUploadFileResponse({}));
    } else {
      return $tea.cast<DeleteRumUploadFileResponse>(await this.execute(params, req, runtime), new DeleteRumUploadFileResponse({}));
    }

  }

  /**
   * Deletes a file such as a symbol table or SourceMap.
   * 
   * @remarks
   * Real User Monitoring (RUM) is available only in the China (Hangzhou), Singapore, and US (Silicon Valley) regions. Select the correct endpoint.
   * 
   * @param request - DeleteRumUploadFileRequest
   * @returns DeleteRumUploadFileResponse
   */
  async deleteRumUploadFile(request: DeleteRumUploadFileRequest): Promise<DeleteRumUploadFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteRumUploadFileWithOptions(request, runtime);
  }

  /**
   * @param request - DeleteScenarioRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteScenarioResponse
   */
  async deleteScenarioWithOptions(request: DeleteScenarioRequest, runtime: $Util.RuntimeOptions): Promise<DeleteScenarioResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.scenarioId)) {
      query["ScenarioId"] = request.scenarioId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteScenario",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteScenarioResponse>(await this.callApi(params, req, runtime), new DeleteScenarioResponse({}));
    } else {
      return $tea.cast<DeleteScenarioResponse>(await this.execute(params, req, runtime), new DeleteScenarioResponse({}));
    }

  }

  /**
   * @param request - DeleteScenarioRequest
   * @returns DeleteScenarioResponse
   */
  async deleteScenario(request: DeleteScenarioRequest): Promise<DeleteScenarioResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteScenarioWithOptions(request, runtime);
  }

  /**
   * The ID of the silence policy.
   * 
   * @param request - DeleteSilencePolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteSilencePolicyResponse
   */
  async deleteSilencePolicyWithOptions(request: DeleteSilencePolicyRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSilencePolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSilencePolicy",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteSilencePolicyResponse>(await this.callApi(params, req, runtime), new DeleteSilencePolicyResponse({}));
    } else {
      return $tea.cast<DeleteSilencePolicyResponse>(await this.execute(params, req, runtime), new DeleteSilencePolicyResponse({}));
    }

  }

  /**
   * The ID of the silence policy.
   * 
   * @param request - DeleteSilencePolicyRequest
   * @returns DeleteSilencePolicyResponse
   */
  async deleteSilencePolicy(request: DeleteSilencePolicyRequest): Promise<DeleteSilencePolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSilencePolicyWithOptions(request, runtime);
  }

  /**
   * Deletes the SourceMap files uploaded in Browser Monitoring.
   * 
   * @param tmpReq - DeleteSourceMapRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteSourceMapResponse
   */
  async deleteSourceMapWithOptions(tmpReq: DeleteSourceMapRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSourceMapResponse> {
    Util.validateModel(tmpReq);
    let request = new DeleteSourceMapShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.fidList)) {
      request.fidListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.fidList, "FidList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.fidListShrink)) {
      query["FidList"] = request.fidListShrink;
    }

    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSourceMap",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteSourceMapResponse>(await this.callApi(params, req, runtime), new DeleteSourceMapResponse({}));
    } else {
      return $tea.cast<DeleteSourceMapResponse>(await this.execute(params, req, runtime), new DeleteSourceMapResponse({}));
    }

  }

  /**
   * Deletes the SourceMap files uploaded in Browser Monitoring.
   * 
   * @param request - DeleteSourceMapRequest
   * @returns DeleteSourceMapResponse
   */
  async deleteSourceMap(request: DeleteSourceMapRequest): Promise<DeleteSourceMapResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSourceMapWithOptions(request, runtime);
  }

  /**
   * Deletes scheduled synthetic monitoring tasks.
   * 
   * @param request - DeleteSyntheticTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteSyntheticTaskResponse
   */
  async deleteSyntheticTaskWithOptions(request: DeleteSyntheticTaskRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSyntheticTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.taskIds)) {
      query["TaskIds"] = request.taskIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSyntheticTask",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteSyntheticTaskResponse>(await this.callApi(params, req, runtime), new DeleteSyntheticTaskResponse({}));
    } else {
      return $tea.cast<DeleteSyntheticTaskResponse>(await this.execute(params, req, runtime), new DeleteSyntheticTaskResponse({}));
    }

  }

  /**
   * Deletes scheduled synthetic monitoring tasks.
   * 
   * @param request - DeleteSyntheticTaskRequest
   * @returns DeleteSyntheticTaskResponse
   */
  async deleteSyntheticTask(request: DeleteSyntheticTaskRequest): Promise<DeleteSyntheticTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSyntheticTaskWithOptions(request, runtime);
  }

  /**
   * Deletes a scheduled synthetic monitoring task.
   * 
   * @param request - DeleteTimingSyntheticTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteTimingSyntheticTaskResponse
   */
  async deleteTimingSyntheticTaskWithOptions(request: DeleteTimingSyntheticTaskRequest, runtime: $Util.RuntimeOptions): Promise<DeleteTimingSyntheticTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTimingSyntheticTask",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteTimingSyntheticTaskResponse>(await this.callApi(params, req, runtime), new DeleteTimingSyntheticTaskResponse({}));
    } else {
      return $tea.cast<DeleteTimingSyntheticTaskResponse>(await this.execute(params, req, runtime), new DeleteTimingSyntheticTaskResponse({}));
    }

  }

  /**
   * Deletes a scheduled synthetic monitoring task.
   * 
   * @param request - DeleteTimingSyntheticTaskRequest
   * @returns DeleteTimingSyntheticTaskResponse
   */
  async deleteTimingSyntheticTask(request: DeleteTimingSyntheticTaskRequest): Promise<DeleteTimingSyntheticTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteTimingSyntheticTaskWithOptions(request, runtime);
  }

  /**
   * Deletes an application based on a specified process identifier (PID) and application type.
   * 
   * @param tmpReq - DeleteTraceAppRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteTraceAppResponse
   */
  async deleteTraceAppWithOptions(tmpReq: DeleteTraceAppRequest, runtime: $Util.RuntimeOptions): Promise<DeleteTraceAppResponse> {
    Util.validateModel(tmpReq);
    let request = new DeleteTraceAppShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.deleteReason)) {
      request.deleteReasonShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.deleteReason, "DeleteReason", "json");
    }

    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.deleteReasonShrink)) {
      query["DeleteReason"] = request.deleteReasonShrink;
    }

    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTraceApp",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteTraceAppResponse>(await this.callApi(params, req, runtime), new DeleteTraceAppResponse({}));
    } else {
      return $tea.cast<DeleteTraceAppResponse>(await this.execute(params, req, runtime), new DeleteTraceAppResponse({}));
    }

  }

  /**
   * Deletes an application based on a specified process identifier (PID) and application type.
   * 
   * @param request - DeleteTraceAppRequest
   * @returns DeleteTraceAppResponse
   */
  async deleteTraceApp(request: DeleteTraceAppRequest): Promise<DeleteTraceAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteTraceAppWithOptions(request, runtime);
  }

  /**
   * Deletes a webhook alert contact.
   * 
   * @param request - DeleteWebhookContactRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteWebhookContactResponse
   */
  async deleteWebhookContactWithOptions(request: DeleteWebhookContactRequest, runtime: $Util.RuntimeOptions): Promise<DeleteWebhookContactResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.webhookId)) {
      query["WebhookId"] = request.webhookId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteWebhookContact",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DeleteWebhookContactResponse>(await this.callApi(params, req, runtime), new DeleteWebhookContactResponse({}));
    } else {
      return $tea.cast<DeleteWebhookContactResponse>(await this.execute(params, req, runtime), new DeleteWebhookContactResponse({}));
    }

  }

  /**
   * Deletes a webhook alert contact.
   * 
   * @param request - DeleteWebhookContactRequest
   * @returns DeleteWebhookContactResponse
   */
  async deleteWebhookContact(request: DeleteWebhookContactRequest): Promise<DeleteWebhookContactResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteWebhookContactWithOptions(request, runtime);
  }

  /**
   * Queries the release information of an add-on by name.
   * 
   * @param request - DescribeAddonReleaseRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeAddonReleaseResponse
   */
  async describeAddonReleaseWithOptions(request: DescribeAddonReleaseRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAddonReleaseResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.releaseName)) {
      query["ReleaseName"] = request.releaseName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAddonRelease",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DescribeAddonReleaseResponse>(await this.callApi(params, req, runtime), new DescribeAddonReleaseResponse({}));
    } else {
      return $tea.cast<DescribeAddonReleaseResponse>(await this.execute(params, req, runtime), new DescribeAddonReleaseResponse({}));
    }

  }

  /**
   * Queries the release information of an add-on by name.
   * 
   * @param request - DescribeAddonReleaseRequest
   * @returns DescribeAddonReleaseResponse
   */
  async describeAddonRelease(request: DescribeAddonReleaseRequest): Promise<DescribeAddonReleaseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAddonReleaseWithOptions(request, runtime);
  }

  /**
   * Queries an alert contact group.
   * 
   * @param request - DescribeContactGroupsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeContactGroupsResponse
   */
  async describeContactGroupsWithOptions(request: DescribeContactGroupsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeContactGroupsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contactGroupName)) {
      query["ContactGroupName"] = request.contactGroupName;
    }

    if (!Util.isUnset(request.groupIds)) {
      query["GroupIds"] = request.groupIds;
    }

    if (!Util.isUnset(request.isDetail)) {
      query["IsDetail"] = request.isDetail;
    }

    if (!Util.isUnset(request.page)) {
      query["Page"] = request.page;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.size)) {
      query["Size"] = request.size;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeContactGroups",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DescribeContactGroupsResponse>(await this.callApi(params, req, runtime), new DescribeContactGroupsResponse({}));
    } else {
      return $tea.cast<DescribeContactGroupsResponse>(await this.execute(params, req, runtime), new DescribeContactGroupsResponse({}));
    }

  }

  /**
   * Queries an alert contact group.
   * 
   * @param request - DescribeContactGroupsRequest
   * @returns DescribeContactGroupsResponse
   */
  async describeContactGroups(request: DescribeContactGroupsRequest): Promise<DescribeContactGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeContactGroupsWithOptions(request, runtime);
  }

  /**
   * Queries alert contacts.
   * 
   * @param request - DescribeContactsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeContactsResponse
   */
  async describeContactsWithOptions(request: DescribeContactsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeContactsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contactIds)) {
      query["ContactIds"] = request.contactIds;
    }

    if (!Util.isUnset(request.contactName)) {
      query["ContactName"] = request.contactName;
    }

    if (!Util.isUnset(request.email)) {
      query["Email"] = request.email;
    }

    if (!Util.isUnset(request.page)) {
      query["Page"] = request.page;
    }

    if (!Util.isUnset(request.phone)) {
      query["Phone"] = request.phone;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.size)) {
      query["Size"] = request.size;
    }

    if (!Util.isUnset(request.verbose)) {
      query["Verbose"] = request.verbose;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeContacts",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DescribeContactsResponse>(await this.callApi(params, req, runtime), new DescribeContactsResponse({}));
    } else {
      return $tea.cast<DescribeContactsResponse>(await this.execute(params, req, runtime), new DescribeContactsResponse({}));
    }

  }

  /**
   * Queries alert contacts.
   * 
   * @param request - DescribeContactsRequest
   * @returns DescribeContactsResponse
   */
  async describeContacts(request: DescribeContactsRequest): Promise<DescribeContactsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeContactsWithOptions(request, runtime);
  }

  /**
   * Queries the information about a dispatch policy.
   * 
   * @param request - DescribeDispatchRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDispatchRuleResponse
   */
  async describeDispatchRuleWithOptions(request: DescribeDispatchRuleRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDispatchRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDispatchRule",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DescribeDispatchRuleResponse>(await this.callApi(params, req, runtime), new DescribeDispatchRuleResponse({}));
    } else {
      return $tea.cast<DescribeDispatchRuleResponse>(await this.execute(params, req, runtime), new DescribeDispatchRuleResponse({}));
    }

  }

  /**
   * Queries the information about a dispatch policy.
   * 
   * @param request - DescribeDispatchRuleRequest
   * @returns DescribeDispatchRuleResponse
   */
  async describeDispatchRule(request: DescribeDispatchRuleRequest): Promise<DescribeDispatchRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDispatchRuleWithOptions(request, runtime);
  }

  /**
   * Queries the details of a custom job for an environment.
   * 
   * @param request - DescribeEnvCustomJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeEnvCustomJobResponse
   */
  async describeEnvCustomJobWithOptions(request: DescribeEnvCustomJobRequest, runtime: $Util.RuntimeOptions): Promise<DescribeEnvCustomJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.customJobName)) {
      query["CustomJobName"] = request.customJobName;
    }

    if (!Util.isUnset(request.encryptYaml)) {
      query["EncryptYaml"] = request.encryptYaml;
    }

    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeEnvCustomJob",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DescribeEnvCustomJobResponse>(await this.callApi(params, req, runtime), new DescribeEnvCustomJobResponse({}));
    } else {
      return $tea.cast<DescribeEnvCustomJobResponse>(await this.execute(params, req, runtime), new DescribeEnvCustomJobResponse({}));
    }

  }

  /**
   * Queries the details of a custom job for an environment.
   * 
   * @param request - DescribeEnvCustomJobRequest
   * @returns DescribeEnvCustomJobResponse
   */
  async describeEnvCustomJob(request: DescribeEnvCustomJobRequest): Promise<DescribeEnvCustomJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEnvCustomJobWithOptions(request, runtime);
  }

  /**
   * Queries the PodMonitor details of an environment.
   * 
   * @param request - DescribeEnvPodMonitorRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeEnvPodMonitorResponse
   */
  async describeEnvPodMonitorWithOptions(request: DescribeEnvPodMonitorRequest, runtime: $Util.RuntimeOptions): Promise<DescribeEnvPodMonitorResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.podMonitorName)) {
      query["PodMonitorName"] = request.podMonitorName;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeEnvPodMonitor",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DescribeEnvPodMonitorResponse>(await this.callApi(params, req, runtime), new DescribeEnvPodMonitorResponse({}));
    } else {
      return $tea.cast<DescribeEnvPodMonitorResponse>(await this.execute(params, req, runtime), new DescribeEnvPodMonitorResponse({}));
    }

  }

  /**
   * Queries the PodMonitor details of an environment.
   * 
   * @param request - DescribeEnvPodMonitorRequest
   * @returns DescribeEnvPodMonitorResponse
   */
  async describeEnvPodMonitor(request: DescribeEnvPodMonitorRequest): Promise<DescribeEnvPodMonitorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEnvPodMonitorWithOptions(request, runtime);
  }

  /**
   * Queries the ServiceMonitor details of an environment.
   * 
   * @param request - DescribeEnvServiceMonitorRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeEnvServiceMonitorResponse
   */
  async describeEnvServiceMonitorWithOptions(request: DescribeEnvServiceMonitorRequest, runtime: $Util.RuntimeOptions): Promise<DescribeEnvServiceMonitorResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.serviceMonitorName)) {
      query["ServiceMonitorName"] = request.serviceMonitorName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeEnvServiceMonitor",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DescribeEnvServiceMonitorResponse>(await this.callApi(params, req, runtime), new DescribeEnvServiceMonitorResponse({}));
    } else {
      return $tea.cast<DescribeEnvServiceMonitorResponse>(await this.execute(params, req, runtime), new DescribeEnvServiceMonitorResponse({}));
    }

  }

  /**
   * Queries the ServiceMonitor details of an environment.
   * 
   * @param request - DescribeEnvServiceMonitorRequest
   * @returns DescribeEnvServiceMonitorResponse
   */
  async describeEnvServiceMonitor(request: DescribeEnvServiceMonitorRequest): Promise<DescribeEnvServiceMonitorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEnvServiceMonitorWithOptions(request, runtime);
  }

  /**
   * Queries the details of an environment.
   * 
   * @param request - DescribeEnvironmentRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeEnvironmentResponse
   */
  async describeEnvironmentWithOptions(request: DescribeEnvironmentRequest, runtime: $Util.RuntimeOptions): Promise<DescribeEnvironmentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeEnvironment",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DescribeEnvironmentResponse>(await this.callApi(params, req, runtime), new DescribeEnvironmentResponse({}));
    } else {
      return $tea.cast<DescribeEnvironmentResponse>(await this.execute(params, req, runtime), new DescribeEnvironmentResponse({}));
    }

  }

  /**
   * Queries the details of an environment.
   * 
   * @param request - DescribeEnvironmentRequest
   * @returns DescribeEnvironmentResponse
   */
  async describeEnvironment(request: DescribeEnvironmentRequest): Promise<DescribeEnvironmentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEnvironmentWithOptions(request, runtime);
  }

  /**
   * Queries the details of a feature.
   * 
   * @param request - DescribeEnvironmentFeatureRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeEnvironmentFeatureResponse
   */
  async describeEnvironmentFeatureWithOptions(request: DescribeEnvironmentFeatureRequest, runtime: $Util.RuntimeOptions): Promise<DescribeEnvironmentFeatureResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliyunLang)) {
      query["AliyunLang"] = request.aliyunLang;
    }

    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.featureName)) {
      query["FeatureName"] = request.featureName;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeEnvironmentFeature",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DescribeEnvironmentFeatureResponse>(await this.callApi(params, req, runtime), new DescribeEnvironmentFeatureResponse({}));
    } else {
      return $tea.cast<DescribeEnvironmentFeatureResponse>(await this.execute(params, req, runtime), new DescribeEnvironmentFeatureResponse({}));
    }

  }

  /**
   * Queries the details of a feature.
   * 
   * @param request - DescribeEnvironmentFeatureRequest
   * @returns DescribeEnvironmentFeatureResponse
   */
  async describeEnvironmentFeature(request: DescribeEnvironmentFeatureRequest): Promise<DescribeEnvironmentFeatureResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEnvironmentFeatureWithOptions(request, runtime);
  }

  /**
   * Queries instant messaging (IM) chatbots.
   * 
   * @param request - DescribeIMRobotsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeIMRobotsResponse
   */
  async describeIMRobotsWithOptions(request: DescribeIMRobotsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeIMRobotsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.page)) {
      query["Page"] = request.page;
    }

    if (!Util.isUnset(request.robotIds)) {
      query["RobotIds"] = request.robotIds;
    }

    if (!Util.isUnset(request.robotName)) {
      query["RobotName"] = request.robotName;
    }

    if (!Util.isUnset(request.size)) {
      query["Size"] = request.size;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeIMRobots",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DescribeIMRobotsResponse>(await this.callApi(params, req, runtime), new DescribeIMRobotsResponse({}));
    } else {
      return $tea.cast<DescribeIMRobotsResponse>(await this.execute(params, req, runtime), new DescribeIMRobotsResponse({}));
    }

  }

  /**
   * Queries instant messaging (IM) chatbots.
   * 
   * @param request - DescribeIMRobotsRequest
   * @returns DescribeIMRobotsResponse
   */
  async describeIMRobots(request: DescribeIMRobotsRequest): Promise<DescribeIMRobotsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeIMRobotsWithOptions(request, runtime);
  }

  /**
   * Queries the details about an alert rule for a Prometheus instance.
   * 
   * @param request - DescribePrometheusAlertRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePrometheusAlertRuleResponse
   */
  async describePrometheusAlertRuleWithOptions(request: DescribePrometheusAlertRuleRequest, runtime: $Util.RuntimeOptions): Promise<DescribePrometheusAlertRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertId)) {
      query["AlertId"] = request.alertId;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePrometheusAlertRule",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DescribePrometheusAlertRuleResponse>(await this.callApi(params, req, runtime), new DescribePrometheusAlertRuleResponse({}));
    } else {
      return $tea.cast<DescribePrometheusAlertRuleResponse>(await this.execute(params, req, runtime), new DescribePrometheusAlertRuleResponse({}));
    }

  }

  /**
   * Queries the details about an alert rule for a Prometheus instance.
   * 
   * @param request - DescribePrometheusAlertRuleRequest
   * @returns DescribePrometheusAlertRuleResponse
   */
  async describePrometheusAlertRule(request: DescribePrometheusAlertRuleRequest): Promise<DescribePrometheusAlertRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePrometheusAlertRuleWithOptions(request, runtime);
  }

  /**
   * Queries the license key.
   * 
   * @param request - DescribeTraceLicenseKeyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeTraceLicenseKeyResponse
   */
  async describeTraceLicenseKeyWithOptions(request: DescribeTraceLicenseKeyRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTraceLicenseKeyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTraceLicenseKey",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DescribeTraceLicenseKeyResponse>(await this.callApi(params, req, runtime), new DescribeTraceLicenseKeyResponse({}));
    } else {
      return $tea.cast<DescribeTraceLicenseKeyResponse>(await this.execute(params, req, runtime), new DescribeTraceLicenseKeyResponse({}));
    }

  }

  /**
   * Queries the license key.
   * 
   * @param request - DescribeTraceLicenseKeyRequest
   * @returns DescribeTraceLicenseKeyResponse
   */
  async describeTraceLicenseKey(request: DescribeTraceLicenseKeyRequest): Promise<DescribeTraceLicenseKeyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTraceLicenseKeyWithOptions(request, runtime);
  }

  /**
   * Queries the list of webhook alert contacts.
   * 
   * @param request - DescribeWebhookContactsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeWebhookContactsResponse
   */
  async describeWebhookContactsWithOptions(request: DescribeWebhookContactsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeWebhookContactsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeWebhookContacts",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DescribeWebhookContactsResponse>(await this.callApi(params, req, runtime), new DescribeWebhookContactsResponse({}));
    } else {
      return $tea.cast<DescribeWebhookContactsResponse>(await this.execute(params, req, runtime), new DescribeWebhookContactsResponse({}));
    }

  }

  /**
   * Queries the list of webhook alert contacts.
   * 
   * @param request - DescribeWebhookContactsRequest
   * @returns DescribeWebhookContactsResponse
   */
  async describeWebhookContacts(request: DescribeWebhookContactsRequest): Promise<DescribeWebhookContactsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWebhookContactsWithOptions(request, runtime);
  }

  /**
   * Performs the corresponding operation based on the specified module type.
   * 
   * @param request - DoInsightsActionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DoInsightsActionResponse
   */
  async doInsightsActionWithOptions(request: DoInsightsActionRequest, runtime: $Util.RuntimeOptions): Promise<DoInsightsActionResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.data)) {
      body["Data"] = request.data;
    }

    if (!Util.isUnset(request.module)) {
      body["Module"] = request.module;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DoInsightsAction",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<DoInsightsActionResponse>(await this.callApi(params, req, runtime), new DoInsightsActionResponse({}));
    } else {
      return $tea.cast<DoInsightsActionResponse>(await this.execute(params, req, runtime), new DoInsightsActionResponse({}));
    }

  }

  /**
   * Performs the corresponding operation based on the specified module type.
   * 
   * @param request - DoInsightsActionRequest
   * @returns DoInsightsActionResponse
   */
  async doInsightsAction(request: DoInsightsActionRequest): Promise<DoInsightsActionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.doInsightsActionWithOptions(request, runtime);
  }

  /**
   * Enables a discarded metric.
   * 
   * @param request - EnableMetricRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EnableMetricResponse
   */
  async enableMetricWithOptions(request: EnableMetricRequest, runtime: $Util.RuntimeOptions): Promise<EnableMetricResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dropMetric)) {
      query["DropMetric"] = request.dropMetric;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableMetric",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<EnableMetricResponse>(await this.callApi(params, req, runtime), new EnableMetricResponse({}));
    } else {
      return $tea.cast<EnableMetricResponse>(await this.execute(params, req, runtime), new EnableMetricResponse({}));
    }

  }

  /**
   * Enables a discarded metric.
   * 
   * @param request - EnableMetricRequest
   * @returns EnableMetricResponse
   */
  async enableMetric(request: EnableMetricRequest): Promise<EnableMetricResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableMetricWithOptions(request, runtime);
  }

  /**
   * Obtains the download URL of the Application Real-Time Monitoring Service (ARMS) agent.
   * 
   * @param request - GetAgentDownloadUrlRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetAgentDownloadUrlResponse
   */
  async getAgentDownloadUrlWithOptions(request: GetAgentDownloadUrlRequest, runtime: $Util.RuntimeOptions): Promise<GetAgentDownloadUrlResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetAgentDownloadUrl",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetAgentDownloadUrlResponse>(await this.callApi(params, req, runtime), new GetAgentDownloadUrlResponse({}));
    } else {
      return $tea.cast<GetAgentDownloadUrlResponse>(await this.execute(params, req, runtime), new GetAgentDownloadUrlResponse({}));
    }

  }

  /**
   * Obtains the download URL of the Application Real-Time Monitoring Service (ARMS) agent.
   * 
   * @param request - GetAgentDownloadUrlRequest
   * @returns GetAgentDownloadUrlResponse
   */
  async getAgentDownloadUrl(request: GetAgentDownloadUrlRequest): Promise<GetAgentDownloadUrlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getAgentDownloadUrlWithOptions(request, runtime);
  }

  /**
   * Obtains the download URL of the Application Real-Time Monitoring Service (ARMS) agent.
   * 
   * @param request - GetAgentDownloadUrlV2Request
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetAgentDownloadUrlV2Response
   */
  async getAgentDownloadUrlV2WithOptions(request: GetAgentDownloadUrlV2Request, runtime: $Util.RuntimeOptions): Promise<GetAgentDownloadUrlV2Response> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.agentType)) {
      query["AgentType"] = request.agentType;
    }

    if (!Util.isUnset(request.archType)) {
      query["ArchType"] = request.archType;
    }

    if (!Util.isUnset(request.osType)) {
      query["OsType"] = request.osType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetAgentDownloadUrlV2",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetAgentDownloadUrlV2Response>(await this.callApi(params, req, runtime), new GetAgentDownloadUrlV2Response({}));
    } else {
      return $tea.cast<GetAgentDownloadUrlV2Response>(await this.execute(params, req, runtime), new GetAgentDownloadUrlV2Response({}));
    }

  }

  /**
   * Obtains the download URL of the Application Real-Time Monitoring Service (ARMS) agent.
   * 
   * @param request - GetAgentDownloadUrlV2Request
   * @returns GetAgentDownloadUrlV2Response
   */
  async getAgentDownloadUrlV2(request: GetAgentDownloadUrlV2Request): Promise<GetAgentDownloadUrlV2Response> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getAgentDownloadUrlV2WithOptions(request, runtime);
  }

  /**
   * Queries alert rules.
   * 
   * @param request - GetAlertRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetAlertRulesResponse
   */
  async getAlertRulesWithOptions(request: GetAlertRulesRequest, runtime: $Util.RuntimeOptions): Promise<GetAlertRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertIds)) {
      query["AlertIds"] = request.alertIds;
    }

    if (!Util.isUnset(request.alertNames)) {
      query["AlertNames"] = request.alertNames;
    }

    if (!Util.isUnset(request.alertStatus)) {
      query["AlertStatus"] = request.alertStatus;
    }

    if (!Util.isUnset(request.alertType)) {
      query["AlertType"] = request.alertType;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.page)) {
      query["Page"] = request.page;
    }

    if (!Util.isUnset(request.productCode)) {
      query["ProductCode"] = request.productCode;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.size)) {
      query["Size"] = request.size;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetAlertRules",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetAlertRulesResponse>(await this.callApi(params, req, runtime), new GetAlertRulesResponse({}));
    } else {
      return $tea.cast<GetAlertRulesResponse>(await this.execute(params, req, runtime), new GetAlertRulesResponse({}));
    }

  }

  /**
   * Queries alert rules.
   * 
   * @param request - GetAlertRulesRequest
   * @returns GetAlertRulesResponse
   */
  async getAlertRules(request: GetAlertRulesRequest): Promise<GetAlertRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getAlertRulesWithOptions(request, runtime);
  }

  /**
   * Queries the API operations of application monitoring by page.
   * 
   * @param request - GetAppApiByPageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetAppApiByPageResponse
   */
  async getAppApiByPageWithOptions(request: GetAppApiByPageRequest, runtime: $Util.RuntimeOptions): Promise<GetAppApiByPageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.intervalMills)) {
      query["IntervalMills"] = request.intervalMills;
    }

    if (!Util.isUnset(request.PId)) {
      query["PId"] = request.PId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetAppApiByPage",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetAppApiByPageResponse>(await this.callApi(params, req, runtime), new GetAppApiByPageResponse({}));
    } else {
      return $tea.cast<GetAppApiByPageResponse>(await this.execute(params, req, runtime), new GetAppApiByPageResponse({}));
    }

  }

  /**
   * Queries the API operations of application monitoring by page.
   * 
   * @param request - GetAppApiByPageRequest
   * @returns GetAppApiByPageResponse
   */
  async getAppApiByPage(request: GetAppApiByPageRequest): Promise<GetAppApiByPageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getAppApiByPageWithOptions(request, runtime);
  }

  /**
   * Obtain the JVM configuration information of each instance of the application
   * 
   * @param request - GetAppJVMConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetAppJVMConfigResponse
   */
  async getAppJVMConfigWithOptions(request: GetAppJVMConfigRequest, runtime: $Util.RuntimeOptions): Promise<GetAppJVMConfigResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetAppJVMConfig",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetAppJVMConfigResponse>(await this.callApi(params, req, runtime), new GetAppJVMConfigResponse({}));
    } else {
      return $tea.cast<GetAppJVMConfigResponse>(await this.execute(params, req, runtime), new GetAppJVMConfigResponse({}));
    }

  }

  /**
   * Obtain the JVM configuration information of each instance of the application
   * 
   * @param request - GetAppJVMConfigRequest
   * @returns GetAppJVMConfigResponse
   */
  async getAppJVMConfig(request: GetAppJVMConfigRequest): Promise<GetAppJVMConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getAppJVMConfigWithOptions(request, runtime);
  }

  /**
   * Obtains an authentication token. When you connect a Container Service for Kubernetes (ACK) cluster to Prometheus Service over the Internet, you must use a token for authentication.
   * 
   * @param request - GetAuthTokenRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetAuthTokenResponse
   */
  async getAuthTokenWithOptions(request: GetAuthTokenRequest, runtime: $Util.RuntimeOptions): Promise<GetAuthTokenResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetAuthToken",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetAuthTokenResponse>(await this.callApi(params, req, runtime), new GetAuthTokenResponse({}));
    } else {
      return $tea.cast<GetAuthTokenResponse>(await this.execute(params, req, runtime), new GetAuthTokenResponse({}));
    }

  }

  /**
   * Obtains an authentication token. When you connect a Container Service for Kubernetes (ACK) cluster to Prometheus Service over the Internet, you must use a token for authentication.
   * 
   * @param request - GetAuthTokenRequest
   * @returns GetAuthTokenResponse
   */
  async getAuthToken(request: GetAuthTokenRequest): Promise<GetAuthTokenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getAuthTokenWithOptions(request, runtime);
  }

  /**
   * Queries the read and write URLs of a CloudMonitor instance, such as Pushgateway and Grafana URLs.
   * 
   * @deprecated OpenAPI GetCloudClusterAllUrl is deprecated, please use ARMS::2019-08-08::GetRemoteWriteUrl instead.
   * 
   * @param request - GetCloudClusterAllUrlRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetCloudClusterAllUrlResponse
   */
  // Deprecated
  async getCloudClusterAllUrlWithOptions(request: GetCloudClusterAllUrlRequest, runtime: $Util.RuntimeOptions): Promise<GetCloudClusterAllUrlResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetCloudClusterAllUrl",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetCloudClusterAllUrlResponse>(await this.callApi(params, req, runtime), new GetCloudClusterAllUrlResponse({}));
    } else {
      return $tea.cast<GetCloudClusterAllUrlResponse>(await this.execute(params, req, runtime), new GetCloudClusterAllUrlResponse({}));
    }

  }

  /**
   * Queries the read and write URLs of a CloudMonitor instance, such as Pushgateway and Grafana URLs.
   * 
   * @deprecated OpenAPI GetCloudClusterAllUrl is deprecated, please use ARMS::2019-08-08::GetRemoteWriteUrl instead.
   * 
   * @param request - GetCloudClusterAllUrlRequest
   * @returns GetCloudClusterAllUrlResponse
   */
  // Deprecated
  async getCloudClusterAllUrl(request: GetCloudClusterAllUrlRequest): Promise<GetCloudClusterAllUrlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getCloudClusterAllUrlWithOptions(request, runtime);
  }

  /**
   * Obtains all the URLs of a cluster, including remote read and write URLs, Pushgateway URLs, and Grafana URLs.
   * 
   * @deprecated OpenAPI GetClusterAllUrl is deprecated, please use ARMS::2019-08-08::GetPrometheusInstance instead.
   * 
   * @param request - GetClusterAllUrlRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetClusterAllUrlResponse
   */
  // Deprecated
  async getClusterAllUrlWithOptions(request: GetClusterAllUrlRequest, runtime: $Util.RuntimeOptions): Promise<GetClusterAllUrlResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetClusterAllUrl",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetClusterAllUrlResponse>(await this.callApi(params, req, runtime), new GetClusterAllUrlResponse({}));
    } else {
      return $tea.cast<GetClusterAllUrlResponse>(await this.execute(params, req, runtime), new GetClusterAllUrlResponse({}));
    }

  }

  /**
   * Obtains all the URLs of a cluster, including remote read and write URLs, Pushgateway URLs, and Grafana URLs.
   * 
   * @deprecated OpenAPI GetClusterAllUrl is deprecated, please use ARMS::2019-08-08::GetPrometheusInstance instead.
   * 
   * @param request - GetClusterAllUrlRequest
   * @returns GetClusterAllUrlResponse
   */
  // Deprecated
  async getClusterAllUrl(request: GetClusterAllUrlRequest): Promise<GetClusterAllUrlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getClusterAllUrlWithOptions(request, runtime);
  }

  /**
   * Queries whether the current account has activated the commercial edition of a service.
   * 
   * @param request - GetCommercialStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetCommercialStatusResponse
   */
  async getCommercialStatusWithOptions(request: GetCommercialStatusRequest, runtime: $Util.RuntimeOptions): Promise<GetCommercialStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.commodityCode)) {
      query["CommodityCode"] = request.commodityCode;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetCommercialStatus",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetCommercialStatusResponse>(await this.callApi(params, req, runtime), new GetCommercialStatusResponse({}));
    } else {
      return $tea.cast<GetCommercialStatusResponse>(await this.execute(params, req, runtime), new GetCommercialStatusResponse({}));
    }

  }

  /**
   * Queries whether the current account has activated the commercial edition of a service.
   * 
   * @param request - GetCommercialStatusRequest
   * @returns GetCommercialStatusResponse
   */
  async getCommercialStatus(request: GetCommercialStatusRequest): Promise<GetCommercialStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getCommercialStatusWithOptions(request, runtime);
  }

  /**
   * Enables the Explore feature of Grafana.
   * 
   * @param request - GetExploreUrlRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetExploreUrlResponse
   */
  async getExploreUrlWithOptions(request: GetExploreUrlRequest, runtime: $Util.RuntimeOptions): Promise<GetExploreUrlResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.expression)) {
      query["Expression"] = request.expression;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetExploreUrl",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetExploreUrlResponse>(await this.callApi(params, req, runtime), new GetExploreUrlResponse({}));
    } else {
      return $tea.cast<GetExploreUrlResponse>(await this.execute(params, req, runtime), new GetExploreUrlResponse({}));
    }

  }

  /**
   * Enables the Explore feature of Grafana.
   * 
   * @param request - GetExploreUrlRequest
   * @returns GetExploreUrlResponse
   */
  async getExploreUrl(request: GetExploreUrlRequest): Promise<GetExploreUrlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getExploreUrlWithOptions(request, runtime);
  }

  /**
   * Queries the information about a Grafana workspace.
   * 
   * @remarks
   * Note: The list returned by this operation includes the workspaces of Developer Edition, Expert Edition, and Advanced Edition. The list does not include the workspaces of Shared Edition.
   * 
   * @param request - GetGrafanaWorkspaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetGrafanaWorkspaceResponse
   */
  async getGrafanaWorkspaceWithOptions(request: GetGrafanaWorkspaceRequest, runtime: $Util.RuntimeOptions): Promise<GetGrafanaWorkspaceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliyunLang)) {
      query["AliyunLang"] = request.aliyunLang;
    }

    if (!Util.isUnset(request.grafanaWorkspaceId)) {
      query["GrafanaWorkspaceId"] = request.grafanaWorkspaceId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetGrafanaWorkspace",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetGrafanaWorkspaceResponse>(await this.callApi(params, req, runtime), new GetGrafanaWorkspaceResponse({}));
    } else {
      return $tea.cast<GetGrafanaWorkspaceResponse>(await this.execute(params, req, runtime), new GetGrafanaWorkspaceResponse({}));
    }

  }

  /**
   * Queries the information about a Grafana workspace.
   * 
   * @remarks
   * Note: The list returned by this operation includes the workspaces of Developer Edition, Expert Edition, and Advanced Edition. The list does not include the workspaces of Shared Edition.
   * 
   * @param request - GetGrafanaWorkspaceRequest
   * @returns GetGrafanaWorkspaceResponse
   */
  async getGrafanaWorkspace(request: GetGrafanaWorkspaceRequest): Promise<GetGrafanaWorkspaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getGrafanaWorkspaceWithOptions(request, runtime);
  }

  /**
   * Queries the integration state of the dashboards and collection rules of Application Real-Time Monitoring Service (ARMS) Prometheus.
   * 
   * @deprecated OpenAPI GetIntegrationState is deprecated, please use ARMS::2019-08-08::DescribeAddonRelease instead.
   * 
   * @param request - GetIntegrationStateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetIntegrationStateResponse
   */
  // Deprecated
  async getIntegrationStateWithOptions(request: GetIntegrationStateRequest, runtime: $Util.RuntimeOptions): Promise<GetIntegrationStateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.integration)) {
      query["Integration"] = request.integration;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetIntegrationState",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetIntegrationStateResponse>(await this.callApi(params, req, runtime), new GetIntegrationStateResponse({}));
    } else {
      return $tea.cast<GetIntegrationStateResponse>(await this.execute(params, req, runtime), new GetIntegrationStateResponse({}));
    }

  }

  /**
   * Queries the integration state of the dashboards and collection rules of Application Real-Time Monitoring Service (ARMS) Prometheus.
   * 
   * @deprecated OpenAPI GetIntegrationState is deprecated, please use ARMS::2019-08-08::DescribeAddonRelease instead.
   * 
   * @param request - GetIntegrationStateRequest
   * @returns GetIntegrationStateResponse
   */
  // Deprecated
  async getIntegrationState(request: GetIntegrationStateRequest): Promise<GetIntegrationStateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getIntegrationStateWithOptions(request, runtime);
  }

  /**
   * Queries the installation status of a Prometheus agent in a serverless Kubernetes (ASK) cluster or an Elastic Compute Service (ECS) cluster.
   * 
   * @deprecated OpenAPI GetManagedPrometheusStatus is deprecated
   * 
   * @param request - GetManagedPrometheusStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetManagedPrometheusStatusResponse
   */
  // Deprecated
  async getManagedPrometheusStatusWithOptions(request: GetManagedPrometheusStatusRequest, runtime: $Util.RuntimeOptions): Promise<GetManagedPrometheusStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.clusterType)) {
      query["ClusterType"] = request.clusterType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetManagedPrometheusStatus",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetManagedPrometheusStatusResponse>(await this.callApi(params, req, runtime), new GetManagedPrometheusStatusResponse({}));
    } else {
      return $tea.cast<GetManagedPrometheusStatusResponse>(await this.execute(params, req, runtime), new GetManagedPrometheusStatusResponse({}));
    }

  }

  /**
   * Queries the installation status of a Prometheus agent in a serverless Kubernetes (ASK) cluster or an Elastic Compute Service (ECS) cluster.
   * 
   * @deprecated OpenAPI GetManagedPrometheusStatus is deprecated
   * 
   * @param request - GetManagedPrometheusStatusRequest
   * @returns GetManagedPrometheusStatusResponse
   */
  // Deprecated
  async getManagedPrometheusStatus(request: GetManagedPrometheusStatusRequest): Promise<GetManagedPrometheusStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getManagedPrometheusStatusWithOptions(request, runtime);
  }

  /**
   * Queries the details of one or more traces.
   * 
   * @param request - GetMultipleTraceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetMultipleTraceResponse
   */
  async getMultipleTraceWithOptions(request: GetMultipleTraceRequest, runtime: $Util.RuntimeOptions): Promise<GetMultipleTraceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.traceIDs)) {
      query["TraceIDs"] = request.traceIDs;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMultipleTrace",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetMultipleTraceResponse>(await this.callApi(params, req, runtime), new GetMultipleTraceResponse({}));
    } else {
      return $tea.cast<GetMultipleTraceResponse>(await this.execute(params, req, runtime), new GetMultipleTraceResponse({}));
    }

  }

  /**
   * Queries the details of one or more traces.
   * 
   * @param request - GetMultipleTraceRequest
   * @returns GetMultipleTraceResponse
   */
  async getMultipleTrace(request: GetMultipleTraceRequest): Promise<GetMultipleTraceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMultipleTraceWithOptions(request, runtime);
  }

  /**
   * Queries the information about a scheduling policy.
   * 
   * @param request - GetOnCallSchedulesDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetOnCallSchedulesDetailResponse
   */
  async getOnCallSchedulesDetailWithOptions(request: GetOnCallSchedulesDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetOnCallSchedulesDetailResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetOnCallSchedulesDetail",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetOnCallSchedulesDetailResponse>(await this.callApi(params, req, runtime), new GetOnCallSchedulesDetailResponse({}));
    } else {
      return $tea.cast<GetOnCallSchedulesDetailResponse>(await this.execute(params, req, runtime), new GetOnCallSchedulesDetailResponse({}));
    }

  }

  /**
   * Queries the information about a scheduling policy.
   * 
   * @param request - GetOnCallSchedulesDetailRequest
   * @returns GetOnCallSchedulesDetailResponse
   */
  async getOnCallSchedulesDetail(request: GetOnCallSchedulesDetailRequest): Promise<GetOnCallSchedulesDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getOnCallSchedulesDetailWithOptions(request, runtime);
  }

  /**
   * Queries the token required for integrating Prometheus Service.
   * 
   * @remarks
   * None.
   * 
   * @param request - GetPrometheusApiTokenRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetPrometheusApiTokenResponse
   */
  async getPrometheusApiTokenWithOptions(request: GetPrometheusApiTokenRequest, runtime: $Util.RuntimeOptions): Promise<GetPrometheusApiTokenResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetPrometheusApiToken",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetPrometheusApiTokenResponse>(await this.callApi(params, req, runtime), new GetPrometheusApiTokenResponse({}));
    } else {
      return $tea.cast<GetPrometheusApiTokenResponse>(await this.execute(params, req, runtime), new GetPrometheusApiTokenResponse({}));
    }

  }

  /**
   * Queries the token required for integrating Prometheus Service.
   * 
   * @remarks
   * None.
   * 
   * @param request - GetPrometheusApiTokenRequest
   * @returns GetPrometheusApiTokenResponse
   */
  async getPrometheusApiToken(request: GetPrometheusApiTokenRequest): Promise<GetPrometheusApiTokenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getPrometheusApiTokenWithOptions(request, runtime);
  }

  /**
   * Queries the information about a global aggregation instance.
   * 
   * @param request - GetPrometheusGlobalViewRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetPrometheusGlobalViewResponse
   */
  async getPrometheusGlobalViewWithOptions(request: GetPrometheusGlobalViewRequest, runtime: $Util.RuntimeOptions): Promise<GetPrometheusGlobalViewResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.globalViewClusterId)) {
      query["GlobalViewClusterId"] = request.globalViewClusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetPrometheusGlobalView",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetPrometheusGlobalViewResponse>(await this.callApi(params, req, runtime), new GetPrometheusGlobalViewResponse({}));
    } else {
      return $tea.cast<GetPrometheusGlobalViewResponse>(await this.execute(params, req, runtime), new GetPrometheusGlobalViewResponse({}));
    }

  }

  /**
   * Queries the information about a global aggregation instance.
   * 
   * @param request - GetPrometheusGlobalViewRequest
   * @returns GetPrometheusGlobalViewResponse
   */
  async getPrometheusGlobalView(request: GetPrometheusGlobalViewRequest): Promise<GetPrometheusGlobalViewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getPrometheusGlobalViewWithOptions(request, runtime);
  }

  /**
   * Queries the information about a Prometheus instance.
   * 
   * @param request - GetPrometheusInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetPrometheusInstanceResponse
   */
  async getPrometheusInstanceWithOptions(request: GetPrometheusInstanceRequest, runtime: $Util.RuntimeOptions): Promise<GetPrometheusInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetPrometheusInstance",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetPrometheusInstanceResponse>(await this.callApi(params, req, runtime), new GetPrometheusInstanceResponse({}));
    } else {
      return $tea.cast<GetPrometheusInstanceResponse>(await this.execute(params, req, runtime), new GetPrometheusInstanceResponse({}));
    }

  }

  /**
   * Queries the information about a Prometheus instance.
   * 
   * @param request - GetPrometheusInstanceRequest
   * @returns GetPrometheusInstanceResponse
   */
  async getPrometheusInstance(request: GetPrometheusInstanceRequest): Promise<GetPrometheusInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getPrometheusInstanceWithOptions(request, runtime);
  }

  /**
   * Queries the information about an exporter that is integrated into a Prometheus instance for Container Service or a Prometheus instance for ECS.
   * 
   * @param request - GetPrometheusIntegrationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetPrometheusIntegrationResponse
   */
  async getPrometheusIntegrationWithOptions(request: GetPrometheusIntegrationRequest, runtime: $Util.RuntimeOptions): Promise<GetPrometheusIntegrationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.integrationType)) {
      query["IntegrationType"] = request.integrationType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetPrometheusIntegration",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetPrometheusIntegrationResponse>(await this.callApi(params, req, runtime), new GetPrometheusIntegrationResponse({}));
    } else {
      return $tea.cast<GetPrometheusIntegrationResponse>(await this.execute(params, req, runtime), new GetPrometheusIntegrationResponse({}));
    }

  }

  /**
   * Queries the information about an exporter that is integrated into a Prometheus instance for Container Service or a Prometheus instance for ECS.
   * 
   * @param request - GetPrometheusIntegrationRequest
   * @returns GetPrometheusIntegrationResponse
   */
  async getPrometheusIntegration(request: GetPrometheusIntegrationRequest): Promise<GetPrometheusIntegrationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getPrometheusIntegrationWithOptions(request, runtime);
  }

  /**
   * Queries the monitoring configuration of a Prometheus instance.
   * 
   * @param request - GetPrometheusMonitoringRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetPrometheusMonitoringResponse
   */
  async getPrometheusMonitoringWithOptions(request: GetPrometheusMonitoringRequest, runtime: $Util.RuntimeOptions): Promise<GetPrometheusMonitoringResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.monitoringName)) {
      query["MonitoringName"] = request.monitoringName;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetPrometheusMonitoring",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetPrometheusMonitoringResponse>(await this.callApi(params, req, runtime), new GetPrometheusMonitoringResponse({}));
    } else {
      return $tea.cast<GetPrometheusMonitoringResponse>(await this.execute(params, req, runtime), new GetPrometheusMonitoringResponse({}));
    }

  }

  /**
   * Queries the monitoring configuration of a Prometheus instance.
   * 
   * @param request - GetPrometheusMonitoringRequest
   * @returns GetPrometheusMonitoringResponse
   */
  async getPrometheusMonitoring(request: GetPrometheusMonitoringRequest): Promise<GetPrometheusMonitoringResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getPrometheusMonitoringWithOptions(request, runtime);
  }

  /**
   * Obtains the recording rule of a cluster.
   * 
   * @param request - GetRecordingRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRecordingRuleResponse
   */
  async getRecordingRuleWithOptions(request: GetRecordingRuleRequest, runtime: $Util.RuntimeOptions): Promise<GetRecordingRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetRecordingRule",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetRecordingRuleResponse>(await this.callApi(params, req, runtime), new GetRecordingRuleResponse({}));
    } else {
      return $tea.cast<GetRecordingRuleResponse>(await this.execute(params, req, runtime), new GetRecordingRuleResponse({}));
    }

  }

  /**
   * Obtains the recording rule of a cluster.
   * 
   * @param request - GetRecordingRuleRequest
   * @returns GetRecordingRuleResponse
   */
  async getRecordingRule(request: GetRecordingRuleRequest): Promise<GetRecordingRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getRecordingRuleWithOptions(request, runtime);
  }

  /**
   * Queries the objects of a Browser Monitoring application by process identifier (PID).
   * 
   * @param request - GetRetcodeAppByPidRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRetcodeAppByPidResponse
   */
  async getRetcodeAppByPidWithOptions(request: GetRetcodeAppByPidRequest, runtime: $Util.RuntimeOptions): Promise<GetRetcodeAppByPidResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetRetcodeAppByPid",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetRetcodeAppByPidResponse>(await this.callApi(params, req, runtime), new GetRetcodeAppByPidResponse({}));
    } else {
      return $tea.cast<GetRetcodeAppByPidResponse>(await this.execute(params, req, runtime), new GetRetcodeAppByPidResponse({}));
    }

  }

  /**
   * Queries the objects of a Browser Monitoring application by process identifier (PID).
   * 
   * @param request - GetRetcodeAppByPidRequest
   * @returns GetRetcodeAppByPidResponse
   */
  async getRetcodeAppByPid(request: GetRetcodeAppByPidRequest): Promise<GetRetcodeAppByPidResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getRetcodeAppByPidWithOptions(request, runtime);
  }

  /**
   * Queries the Browser Monitoring data based on a query statement of Log Service.
   * 
   * @param request - GetRetcodeDataByQueryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRetcodeDataByQueryResponse
   */
  async getRetcodeDataByQueryWithOptions(request: GetRetcodeDataByQueryRequest, runtime: $Util.RuntimeOptions): Promise<GetRetcodeDataByQueryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    if (!Util.isUnset(request.query)) {
      query["Query"] = request.query;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.to)) {
      query["To"] = request.to;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetRetcodeDataByQuery",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetRetcodeDataByQueryResponse>(await this.callApi(params, req, runtime), new GetRetcodeDataByQueryResponse({}));
    } else {
      return $tea.cast<GetRetcodeDataByQueryResponse>(await this.execute(params, req, runtime), new GetRetcodeDataByQueryResponse({}));
    }

  }

  /**
   * Queries the Browser Monitoring data based on a query statement of Log Service.
   * 
   * @param request - GetRetcodeDataByQueryRequest
   * @returns GetRetcodeDataByQueryResponse
   */
  async getRetcodeDataByQuery(request: GetRetcodeDataByQueryRequest): Promise<GetRetcodeDataByQueryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getRetcodeDataByQueryWithOptions(request, runtime);
  }

  /**
   * Queries the Log Service project and Logstore that correspond to an application of browser monitoring.
   * 
   * @param request - GetRetcodeLogstoreRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRetcodeLogstoreResponse
   */
  async getRetcodeLogstoreWithOptions(request: GetRetcodeLogstoreRequest, runtime: $Util.RuntimeOptions): Promise<GetRetcodeLogstoreResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetRetcodeLogstore",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetRetcodeLogstoreResponse>(await this.callApi(params, req, runtime), new GetRetcodeLogstoreResponse({}));
    } else {
      return $tea.cast<GetRetcodeLogstoreResponse>(await this.execute(params, req, runtime), new GetRetcodeLogstoreResponse({}));
    }

  }

  /**
   * Queries the Log Service project and Logstore that correspond to an application of browser monitoring.
   * 
   * @param request - GetRetcodeLogstoreRequest
   * @returns GetRetcodeLogstoreResponse
   */
  async getRetcodeLogstore(request: GetRetcodeLogstoreRequest): Promise<GetRetcodeLogstoreResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getRetcodeLogstoreWithOptions(request, runtime);
  }

  /**
   * Queries the logon-free URL of a Browser Monitoring application.
   * 
   * @param request - GetRetcodeShareUrlRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRetcodeShareUrlResponse
   */
  async getRetcodeShareUrlWithOptions(request: GetRetcodeShareUrlRequest, runtime: $Util.RuntimeOptions): Promise<GetRetcodeShareUrlResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetRetcodeShareUrl",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetRetcodeShareUrlResponse>(await this.callApi(params, req, runtime), new GetRetcodeShareUrlResponse({}));
    } else {
      return $tea.cast<GetRetcodeShareUrlResponse>(await this.execute(params, req, runtime), new GetRetcodeShareUrlResponse({}));
    }

  }

  /**
   * Queries the logon-free URL of a Browser Monitoring application.
   * 
   * @param request - GetRetcodeShareUrlRequest
   * @returns GetRetcodeShareUrlResponse
   */
  async getRetcodeShareUrl(request: GetRetcodeShareUrlRequest): Promise<GetRetcodeShareUrlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getRetcodeShareUrlWithOptions(request, runtime);
  }

  /**
   * Queries the information about a Real User Monitoring (RUM) application.
   * 
   * @remarks
   * Real User Monitoring (RUM) is available only in the China (Hangzhou), Singapore, and US (Silicon Valley) regions. Select the correct endpoint.
   * 
   * @param request - GetRumAppInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRumAppInfoResponse
   */
  async getRumAppInfoWithOptions(request: GetRumAppInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetRumAppInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appGroup)) {
      query["AppGroup"] = request.appGroup;
    }

    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetRumAppInfo",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetRumAppInfoResponse>(await this.callApi(params, req, runtime), new GetRumAppInfoResponse({}));
    } else {
      return $tea.cast<GetRumAppInfoResponse>(await this.execute(params, req, runtime), new GetRumAppInfoResponse({}));
    }

  }

  /**
   * Queries the information about a Real User Monitoring (RUM) application.
   * 
   * @remarks
   * Real User Monitoring (RUM) is available only in the China (Hangzhou), Singapore, and US (Silicon Valley) regions. Select the correct endpoint.
   * 
   * @param request - GetRumAppInfoRequest
   * @returns GetRumAppInfoResponse
   */
  async getRumAppInfo(request: GetRumAppInfoRequest): Promise<GetRumAppInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getRumAppInfoWithOptions(request, runtime);
  }

  /**
   * Queries a list of Real User Monitoring (RUM) applications.
   * 
   * @remarks
   * Real User Monitoring (RUM) is available only in the China (Hangzhou), Singapore, and US (Silicon Valley) regions. Select the correct endpoint.
   * 
   * @param tmpReq - GetRumAppsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRumAppsResponse
   */
  async getRumAppsWithOptions(tmpReq: GetRumAppsRequest, runtime: $Util.RuntimeOptions): Promise<GetRumAppsResponse> {
    Util.validateModel(tmpReq);
    let request = new GetRumAppsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.tags)) {
      request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, "Tags", "json");
    }

    let query = { };
    if (!Util.isUnset(request.appGroup)) {
      query["AppGroup"] = request.appGroup;
    }

    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.tagsShrink)) {
      query["Tags"] = request.tagsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetRumApps",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetRumAppsResponse>(await this.callApi(params, req, runtime), new GetRumAppsResponse({}));
    } else {
      return $tea.cast<GetRumAppsResponse>(await this.execute(params, req, runtime), new GetRumAppsResponse({}));
    }

  }

  /**
   * Queries a list of Real User Monitoring (RUM) applications.
   * 
   * @remarks
   * Real User Monitoring (RUM) is available only in the China (Hangzhou), Singapore, and US (Silicon Valley) regions. Select the correct endpoint.
   * 
   * @param request - GetRumAppsRequest
   * @returns GetRumAppsResponse
   */
  async getRumApps(request: GetRumAppsRequest): Promise<GetRumAppsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getRumAppsWithOptions(request, runtime);
  }

  /**
   * Queries Real User Monitoring (RUM) data by page.
   * 
   * @remarks
   * Real User Monitoring (RUM) is available only in the China (Hangzhou), Singapore, and US (Silicon Valley) regions. Select the correct endpoint.
   * 
   * @param request - GetRumDataForPageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRumDataForPageResponse
   */
  async getRumDataForPageWithOptions(request: GetRumDataForPageRequest, runtime: $Util.RuntimeOptions): Promise<GetRumDataForPageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appGroup)) {
      query["AppGroup"] = request.appGroup;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    if (!Util.isUnset(request.query)) {
      query["Query"] = request.query;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetRumDataForPage",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetRumDataForPageResponse>(await this.callApi(params, req, runtime), new GetRumDataForPageResponse({}));
    } else {
      return $tea.cast<GetRumDataForPageResponse>(await this.execute(params, req, runtime), new GetRumDataForPageResponse({}));
    }

  }

  /**
   * Queries Real User Monitoring (RUM) data by page.
   * 
   * @remarks
   * Real User Monitoring (RUM) is available only in the China (Hangzhou), Singapore, and US (Silicon Valley) regions. Select the correct endpoint.
   * 
   * @param request - GetRumDataForPageRequest
   * @returns GetRumDataForPageResponse
   */
  async getRumDataForPage(request: GetRumDataForPageRequest): Promise<GetRumDataForPageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getRumDataForPageWithOptions(request, runtime);
  }

  /**
   * Queries the exception stack information of a Real User Monitoring (RUM) application.
   * 
   * @remarks
   * Real User Monitoring (RUM) is available only in the China (Hangzhou), Singapore, and US (Silicon Valley) regions. Select the correct endpoint.
   * 
   * @param request - GetRumExceptionStackRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRumExceptionStackResponse
   */
  async getRumExceptionStackWithOptions(request: GetRumExceptionStackRequest, runtime: $Util.RuntimeOptions): Promise<GetRumExceptionStackResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.exceptionBinaryImages)) {
      query["ExceptionBinaryImages"] = request.exceptionBinaryImages;
    }

    if (!Util.isUnset(request.exceptionStack)) {
      query["ExceptionStack"] = request.exceptionStack;
    }

    if (!Util.isUnset(request.exceptionThreadId)) {
      query["ExceptionThreadId"] = request.exceptionThreadId;
    }

    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.sourcemapType)) {
      query["SourcemapType"] = request.sourcemapType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetRumExceptionStack",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetRumExceptionStackResponse>(await this.callApi(params, req, runtime), new GetRumExceptionStackResponse({}));
    } else {
      return $tea.cast<GetRumExceptionStackResponse>(await this.execute(params, req, runtime), new GetRumExceptionStackResponse({}));
    }

  }

  /**
   * Queries the exception stack information of a Real User Monitoring (RUM) application.
   * 
   * @remarks
   * Real User Monitoring (RUM) is available only in the China (Hangzhou), Singapore, and US (Silicon Valley) regions. Select the correct endpoint.
   * 
   * @param request - GetRumExceptionStackRequest
   * @returns GetRumExceptionStackResponse
   */
  async getRumExceptionStack(request: GetRumExceptionStackRequest): Promise<GetRumExceptionStackResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getRumExceptionStackWithOptions(request, runtime);
  }

  /**
   * Queries the observability capacity unit (OCU) usage data of Real User Monitoring (RUM).
   * 
   * @remarks
   * You can query the usage data for the current day at any time. You can query the usage data for the previous day only after 8:00 today.
   * 
   * @param tmpReq - GetRumOcuStatisticDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRumOcuStatisticDataResponse
   */
  async getRumOcuStatisticDataWithOptions(tmpReq: GetRumOcuStatisticDataRequest, runtime: $Util.RuntimeOptions): Promise<GetRumOcuStatisticDataResponse> {
    Util.validateModel(tmpReq);
    let request = new GetRumOcuStatisticDataShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.filter)) {
      request.filterShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filter, "Filter", "json");
    }

    if (!Util.isUnset(tmpReq.group)) {
      request.groupShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.group, "Group", "json");
    }

    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetRumOcuStatisticData",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetRumOcuStatisticDataResponse>(await this.callApi(params, req, runtime), new GetRumOcuStatisticDataResponse({}));
    } else {
      return $tea.cast<GetRumOcuStatisticDataResponse>(await this.execute(params, req, runtime), new GetRumOcuStatisticDataResponse({}));
    }

  }

  /**
   * Queries the observability capacity unit (OCU) usage data of Real User Monitoring (RUM).
   * 
   * @remarks
   * You can query the usage data for the current day at any time. You can query the usage data for the previous day only after 8:00 today.
   * 
   * @param request - GetRumOcuStatisticDataRequest
   * @returns GetRumOcuStatisticDataResponse
   */
  async getRumOcuStatisticData(request: GetRumOcuStatisticDataRequest): Promise<GetRumOcuStatisticDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getRumOcuStatisticDataWithOptions(request, runtime);
  }

  /**
   * Queries Real User Monitoring (RUM)-related files, such as symbol tables and SourceMap.
   * 
   * @remarks
   * Real User Monitoring (RUM) is available only in the China (Hangzhou), Singapore, and US (Silicon Valley) regions. Select the correct endpoint.
   * 
   * @param request - GetRumUploadFilesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRumUploadFilesResponse
   */
  async getRumUploadFilesWithOptions(request: GetRumUploadFilesRequest, runtime: $Util.RuntimeOptions): Promise<GetRumUploadFilesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appType)) {
      query["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.versionId)) {
      query["VersionId"] = request.versionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetRumUploadFiles",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetRumUploadFilesResponse>(await this.callApi(params, req, runtime), new GetRumUploadFilesResponse({}));
    } else {
      return $tea.cast<GetRumUploadFilesResponse>(await this.execute(params, req, runtime), new GetRumUploadFilesResponse({}));
    }

  }

  /**
   * Queries Real User Monitoring (RUM)-related files, such as symbol tables and SourceMap.
   * 
   * @remarks
   * Real User Monitoring (RUM) is available only in the China (Hangzhou), Singapore, and US (Silicon Valley) regions. Select the correct endpoint.
   * 
   * @param request - GetRumUploadFilesRequest
   * @returns GetRumUploadFilesResponse
   */
  async getRumUploadFiles(request: GetRumUploadFilesRequest): Promise<GetRumUploadFilesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getRumUploadFilesWithOptions(request, runtime);
  }

  /**
   * Obtains the details of the SourceMap file uploaded in Browser Monitoring.
   * 
   * @param request - GetSourceMapInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetSourceMapInfoResponse
   */
  async getSourceMapInfoWithOptions(request: GetSourceMapInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetSourceMapInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ascendingSequence)) {
      query["AscendingSequence"] = request.ascendingSequence;
    }

    if (!Util.isUnset(request.edition)) {
      query["Edition"] = request.edition;
    }

    if (!Util.isUnset(request.ID)) {
      query["ID"] = request.ID;
    }

    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.orderField)) {
      query["OrderField"] = request.orderField;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetSourceMapInfo",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetSourceMapInfoResponse>(await this.callApi(params, req, runtime), new GetSourceMapInfoResponse({}));
    } else {
      return $tea.cast<GetSourceMapInfoResponse>(await this.execute(params, req, runtime), new GetSourceMapInfoResponse({}));
    }

  }

  /**
   * Obtains the details of the SourceMap file uploaded in Browser Monitoring.
   * 
   * @param request - GetSourceMapInfoRequest
   * @returns GetSourceMapInfoResponse
   */
  async getSourceMapInfo(request: GetSourceMapInfoRequest): Promise<GetSourceMapInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSourceMapInfoWithOptions(request, runtime);
  }

  /**
   * Queries the information of a method stack.
   * 
   * @param request - GetStackRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetStackResponse
   */
  async getStackWithOptions(request: GetStackRequest, runtime: $Util.RuntimeOptions): Promise<GetStackResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.rpcID)) {
      query["RpcID"] = request.rpcID;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.traceID)) {
      query["TraceID"] = request.traceID;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetStack",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetStackResponse>(await this.callApi(params, req, runtime), new GetStackResponse({}));
    } else {
      return $tea.cast<GetStackResponse>(await this.execute(params, req, runtime), new GetStackResponse({}));
    }

  }

  /**
   * Queries the information of a method stack.
   * 
   * @param request - GetStackRequest
   * @returns GetStackResponse
   */
  async getStack(request: GetStackRequest): Promise<GetStackResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getStackWithOptions(request, runtime);
  }

  /**
   * Obtains detection points.
   * 
   * @param tmpReq - GetSyntheticMonitorsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetSyntheticMonitorsResponse
   */
  async getSyntheticMonitorsWithOptions(tmpReq: GetSyntheticMonitorsRequest, runtime: $Util.RuntimeOptions): Promise<GetSyntheticMonitorsResponse> {
    Util.validateModel(tmpReq);
    let request = new GetSyntheticMonitorsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.filter)) {
      request.filterShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filter, "Filter", "json");
    }

    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetSyntheticMonitors",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetSyntheticMonitorsResponse>(await this.callApi(params, req, runtime), new GetSyntheticMonitorsResponse({}));
    } else {
      return $tea.cast<GetSyntheticMonitorsResponse>(await this.execute(params, req, runtime), new GetSyntheticMonitorsResponse({}));
    }

  }

  /**
   * Obtains detection points.
   * 
   * @param request - GetSyntheticMonitorsRequest
   * @returns GetSyntheticMonitorsResponse
   */
  async getSyntheticMonitors(request: GetSyntheticMonitorsRequest): Promise<GetSyntheticMonitorsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSyntheticMonitorsWithOptions(request, runtime);
  }

  /**
   * Queries the details of a scheduled synthetic monitoring task.
   * 
   * @param request - GetSyntheticTaskDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetSyntheticTaskDetailResponse
   */
  async getSyntheticTaskDetailWithOptions(request: GetSyntheticTaskDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetSyntheticTaskDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetSyntheticTaskDetail",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetSyntheticTaskDetailResponse>(await this.callApi(params, req, runtime), new GetSyntheticTaskDetailResponse({}));
    } else {
      return $tea.cast<GetSyntheticTaskDetailResponse>(await this.execute(params, req, runtime), new GetSyntheticTaskDetailResponse({}));
    }

  }

  /**
   * Queries the details of a scheduled synthetic monitoring task.
   * 
   * @param request - GetSyntheticTaskDetailRequest
   * @returns GetSyntheticTaskDetailResponse
   */
  async getSyntheticTaskDetail(request: GetSyntheticTaskDetailRequest): Promise<GetSyntheticTaskDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSyntheticTaskDetailWithOptions(request, runtime);
  }

  /**
   * Queries a list of scheduled synthetic monitoring tasks.
   * 
   * @param request - GetSyntheticTaskListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetSyntheticTaskListResponse
   */
  async getSyntheticTaskListWithOptions(request: GetSyntheticTaskListRequest, runtime: $Util.RuntimeOptions): Promise<GetSyntheticTaskListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.direction)) {
      query["Direction"] = request.direction;
    }

    if (!Util.isUnset(request.order)) {
      query["Order"] = request.order;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.taskName)) {
      query["TaskName"] = request.taskName;
    }

    if (!Util.isUnset(request.taskStatus)) {
      query["TaskStatus"] = request.taskStatus;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    if (!Util.isUnset(request.url)) {
      query["Url"] = request.url;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetSyntheticTaskList",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetSyntheticTaskListResponse>(await this.callApi(params, req, runtime), new GetSyntheticTaskListResponse({}));
    } else {
      return $tea.cast<GetSyntheticTaskListResponse>(await this.execute(params, req, runtime), new GetSyntheticTaskListResponse({}));
    }

  }

  /**
   * Queries a list of scheduled synthetic monitoring tasks.
   * 
   * @param request - GetSyntheticTaskListRequest
   * @returns GetSyntheticTaskListResponse
   */
  async getSyntheticTaskList(request: GetSyntheticTaskListRequest): Promise<GetSyntheticTaskListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSyntheticTaskListWithOptions(request, runtime);
  }

  /**
   * Obtains the information about synthetic monitoring points.
   * 
   * @param request - GetSyntheticTaskMonitorsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetSyntheticTaskMonitorsResponse
   */
  async getSyntheticTaskMonitorsWithOptions(request: GetSyntheticTaskMonitorsRequest, runtime: $Util.RuntimeOptions): Promise<GetSyntheticTaskMonitorsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetSyntheticTaskMonitors",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetSyntheticTaskMonitorsResponse>(await this.callApi(params, req, runtime), new GetSyntheticTaskMonitorsResponse({}));
    } else {
      return $tea.cast<GetSyntheticTaskMonitorsResponse>(await this.execute(params, req, runtime), new GetSyntheticTaskMonitorsResponse({}));
    }

  }

  /**
   * Obtains the information about synthetic monitoring points.
   * 
   * @param request - GetSyntheticTaskMonitorsRequest
   * @returns GetSyntheticTaskMonitorsResponse
   */
  async getSyntheticTaskMonitors(request: GetSyntheticTaskMonitorsRequest): Promise<GetSyntheticTaskMonitorsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSyntheticTaskMonitorsWithOptions(request, runtime);
  }

  /**
   * Obtains the details of a synthetic monitoring task.
   * 
   * @param request - GetTimingSyntheticTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetTimingSyntheticTaskResponse
   */
  async getTimingSyntheticTaskWithOptions(request: GetTimingSyntheticTaskRequest, runtime: $Util.RuntimeOptions): Promise<GetTimingSyntheticTaskResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetTimingSyntheticTask",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetTimingSyntheticTaskResponse>(await this.callApi(params, req, runtime), new GetTimingSyntheticTaskResponse({}));
    } else {
      return $tea.cast<GetTimingSyntheticTaskResponse>(await this.execute(params, req, runtime), new GetTimingSyntheticTaskResponse({}));
    }

  }

  /**
   * Obtains the details of a synthetic monitoring task.
   * 
   * @param request - GetTimingSyntheticTaskRequest
   * @returns GetTimingSyntheticTaskResponse
   */
  async getTimingSyntheticTask(request: GetTimingSyntheticTaskRequest): Promise<GetTimingSyntheticTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getTimingSyntheticTaskWithOptions(request, runtime);
  }

  /**
   * Queries the details of a trace.
   * 
   * @remarks
   * > You must use Application Real-Time Monitoring Service (ARMS) SDK for Java V2.7.24.
   * 
   * @param request - GetTraceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetTraceResponse
   */
  async getTraceWithOptions(request: GetTraceRequest, runtime: $Util.RuntimeOptions): Promise<GetTraceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.traceID)) {
      query["TraceID"] = request.traceID;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetTrace",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetTraceResponse>(await this.callApi(params, req, runtime), new GetTraceResponse({}));
    } else {
      return $tea.cast<GetTraceResponse>(await this.execute(params, req, runtime), new GetTraceResponse({}));
    }

  }

  /**
   * Queries the details of a trace.
   * 
   * @remarks
   * > You must use Application Real-Time Monitoring Service (ARMS) SDK for Java V2.7.24.
   * 
   * @param request - GetTraceRequest
   * @returns GetTraceResponse
   */
  async getTrace(request: GetTraceRequest): Promise<GetTraceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getTraceWithOptions(request, runtime);
  }

  /**
   * Queries the details of an application monitoring task.
   * 
   * @param request - GetTraceAppRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetTraceAppResponse
   */
  async getTraceAppWithOptions(request: GetTraceAppRequest, runtime: $Util.RuntimeOptions): Promise<GetTraceAppResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetTraceApp",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetTraceAppResponse>(await this.callApi(params, req, runtime), new GetTraceAppResponse({}));
    } else {
      return $tea.cast<GetTraceAppResponse>(await this.execute(params, req, runtime), new GetTraceAppResponse({}));
    }

  }

  /**
   * Queries the details of an application monitoring task.
   * 
   * @param request - GetTraceAppRequest
   * @returns GetTraceAppResponse
   */
  async getTraceApp(request: GetTraceAppRequest): Promise<GetTraceAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getTraceAppWithOptions(request, runtime);
  }

  /**
   * Queries all custom settings of an application monitored by Application Monitoring, such as trace sampling settings and agent switches. This operation is applicable only to applications that are monitored by Application Monitoring. It is not applicable to applications that are monitored by Managed Service for OpenTelemetry.
   * 
   * @param request - GetTraceAppConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetTraceAppConfigResponse
   */
  async getTraceAppConfigWithOptions(request: GetTraceAppConfigRequest, runtime: $Util.RuntimeOptions): Promise<GetTraceAppConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetTraceAppConfig",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<GetTraceAppConfigResponse>(await this.callApi(params, req, runtime), new GetTraceAppConfigResponse({}));
    } else {
      return $tea.cast<GetTraceAppConfigResponse>(await this.execute(params, req, runtime), new GetTraceAppConfigResponse({}));
    }

  }

  /**
   * Queries all custom settings of an application monitored by Application Monitoring, such as trace sampling settings and agent switches. This operation is applicable only to applications that are monitored by Application Monitoring. It is not applicable to applications that are monitored by Managed Service for OpenTelemetry.
   * 
   * @param request - GetTraceAppConfigRequest
   * @returns GetTraceAppConfigResponse
   */
  async getTraceAppConfig(request: GetTraceAppConfigRequest): Promise<GetTraceAppConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getTraceAppConfigWithOptions(request, runtime);
  }

  /**
   * Creates an alert rule based on an alert template.
   * 
   * @remarks
   * >  You can call the **ImportAppAlertRules** operation to import only the alert rules that are generated by Application Real-Time Monitoring Service (ARMS) for application monitoring and browser monitoring. This operation cannot be used to import custom alert rules, alert rules for Prometheus monitoring, or default emergency alert rules.
   * 
   * @param request - ImportAppAlertRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ImportAppAlertRulesResponse
   */
  async importAppAlertRulesWithOptions(request: ImportAppAlertRulesRequest, runtime: $Util.RuntimeOptions): Promise<ImportAppAlertRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contactGroupIds)) {
      query["ContactGroupIds"] = request.contactGroupIds;
    }

    if (!Util.isUnset(request.isAutoStart)) {
      query["IsAutoStart"] = request.isAutoStart;
    }

    if (!Util.isUnset(request.pids)) {
      query["Pids"] = request.pids;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    if (!Util.isUnset(request.templageAlertConfig)) {
      query["TemplageAlertConfig"] = request.templageAlertConfig;
    }

    if (!Util.isUnset(request.templateAlertId)) {
      query["TemplateAlertId"] = request.templateAlertId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ImportAppAlertRules",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ImportAppAlertRulesResponse>(await this.callApi(params, req, runtime), new ImportAppAlertRulesResponse({}));
    } else {
      return $tea.cast<ImportAppAlertRulesResponse>(await this.execute(params, req, runtime), new ImportAppAlertRulesResponse({}));
    }

  }

  /**
   * Creates an alert rule based on an alert template.
   * 
   * @remarks
   * >  You can call the **ImportAppAlertRules** operation to import only the alert rules that are generated by Application Real-Time Monitoring Service (ARMS) for application monitoring and browser monitoring. This operation cannot be used to import custom alert rules, alert rules for Prometheus monitoring, or default emergency alert rules.
   * 
   * @param request - ImportAppAlertRulesRequest
   * @returns ImportAppAlertRulesResponse
   */
  async importAppAlertRules(request: ImportAppAlertRulesRequest): Promise<ImportAppAlertRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.importAppAlertRulesWithOptions(request, runtime);
  }

  /**
   * Initializes an environment instance.
   * 
   * @param request - InitEnvironmentRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns InitEnvironmentResponse
   */
  async initEnvironmentWithOptions(request: InitEnvironmentRequest, runtime: $Util.RuntimeOptions): Promise<InitEnvironmentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliyunLang)) {
      query["AliyunLang"] = request.aliyunLang;
    }

    if (!Util.isUnset(request.createAuthToken)) {
      query["CreateAuthToken"] = request.createAuthToken;
    }

    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.managedType)) {
      query["ManagedType"] = request.managedType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "InitEnvironment",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<InitEnvironmentResponse>(await this.callApi(params, req, runtime), new InitEnvironmentResponse({}));
    } else {
      return $tea.cast<InitEnvironmentResponse>(await this.execute(params, req, runtime), new InitEnvironmentResponse({}));
    }

  }

  /**
   * Initializes an environment instance.
   * 
   * @param request - InitEnvironmentRequest
   * @returns InitEnvironmentResponse
   */
  async initEnvironment(request: InitEnvironmentRequest): Promise<InitEnvironmentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.initEnvironmentWithOptions(request, runtime);
  }

  /**
   * Installs an add-on.
   * 
   * @param request - InstallAddonRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns InstallAddonResponse
   */
  async installAddonWithOptions(request: InstallAddonRequest, runtime: $Util.RuntimeOptions): Promise<InstallAddonResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.addonVersion)) {
      query["AddonVersion"] = request.addonVersion;
    }

    if (!Util.isUnset(request.aliyunLang)) {
      query["AliyunLang"] = request.aliyunLang;
    }

    if (!Util.isUnset(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.releaseName)) {
      query["ReleaseName"] = request.releaseName;
    }

    if (!Util.isUnset(request.values)) {
      query["Values"] = request.values;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "InstallAddon",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<InstallAddonResponse>(await this.callApi(params, req, runtime), new InstallAddonResponse({}));
    } else {
      return $tea.cast<InstallAddonResponse>(await this.execute(params, req, runtime), new InstallAddonResponse({}));
    }

  }

  /**
   * Installs an add-on.
   * 
   * @param request - InstallAddonRequest
   * @returns InstallAddonResponse
   */
  async installAddon(request: InstallAddonRequest): Promise<InstallAddonResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.installAddonWithOptions(request, runtime);
  }

  /**
   * Installs the cms-exporter collector.
   * 
   * @deprecated OpenAPI InstallCmsExporter is deprecated, please use ARMS::2019-08-08::InstallAddon instead.
   * 
   * @param request - InstallCmsExporterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns InstallCmsExporterResponse
   */
  // Deprecated
  async installCmsExporterWithOptions(request: InstallCmsExporterRequest, runtime: $Util.RuntimeOptions): Promise<InstallCmsExporterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.cmsArgs)) {
      query["CmsArgs"] = request.cmsArgs;
    }

    if (!Util.isUnset(request.directArgs)) {
      query["DirectArgs"] = request.directArgs;
    }

    if (!Util.isUnset(request.enableTag)) {
      query["EnableTag"] = request.enableTag;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "InstallCmsExporter",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<InstallCmsExporterResponse>(await this.callApi(params, req, runtime), new InstallCmsExporterResponse({}));
    } else {
      return $tea.cast<InstallCmsExporterResponse>(await this.execute(params, req, runtime), new InstallCmsExporterResponse({}));
    }

  }

  /**
   * Installs the cms-exporter collector.
   * 
   * @deprecated OpenAPI InstallCmsExporter is deprecated, please use ARMS::2019-08-08::InstallAddon instead.
   * 
   * @param request - InstallCmsExporterRequest
   * @returns InstallCmsExporterResponse
   */
  // Deprecated
  async installCmsExporter(request: InstallCmsExporterRequest): Promise<InstallCmsExporterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.installCmsExporterWithOptions(request, runtime);
  }

  /**
   * Installs a feature.
   * 
   * @param request - InstallEnvironmentFeatureRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns InstallEnvironmentFeatureResponse
   */
  async installEnvironmentFeatureWithOptions(request: InstallEnvironmentFeatureRequest, runtime: $Util.RuntimeOptions): Promise<InstallEnvironmentFeatureResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliyunLang)) {
      query["AliyunLang"] = request.aliyunLang;
    }

    if (!Util.isUnset(request.config)) {
      query["Config"] = request.config;
    }

    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.featureName)) {
      query["FeatureName"] = request.featureName;
    }

    if (!Util.isUnset(request.featureVersion)) {
      query["FeatureVersion"] = request.featureVersion;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "InstallEnvironmentFeature",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<InstallEnvironmentFeatureResponse>(await this.callApi(params, req, runtime), new InstallEnvironmentFeatureResponse({}));
    } else {
      return $tea.cast<InstallEnvironmentFeatureResponse>(await this.execute(params, req, runtime), new InstallEnvironmentFeatureResponse({}));
    }

  }

  /**
   * Installs a feature.
   * 
   * @param request - InstallEnvironmentFeatureRequest
   * @returns InstallEnvironmentFeatureResponse
   */
  async installEnvironmentFeature(request: InstallEnvironmentFeatureRequest): Promise<InstallEnvironmentFeatureResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.installEnvironmentFeatureWithOptions(request, runtime);
  }

  /**
   * Installs a Prometheus agent for serverless Kubernetes (ASK) clusters or Elastic Compute Service (ECS) clusters.
   * 
   * @remarks
   * You can call this operation only if the following conditions are met: The resources that you want to monitor are ASK clusters or ECS clusters. No Prometheus agents are installed in the ASK or ECS clusters. Take note that Prometheus agents can be installed only on the cloud service side, not in user clusters.
   * 
   * @deprecated OpenAPI InstallManagedPrometheus is deprecated
   * 
   * @param request - InstallManagedPrometheusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns InstallManagedPrometheusResponse
   */
  // Deprecated
  async installManagedPrometheusWithOptions(request: InstallManagedPrometheusRequest, runtime: $Util.RuntimeOptions): Promise<InstallManagedPrometheusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.clusterName)) {
      query["ClusterName"] = request.clusterName;
    }

    if (!Util.isUnset(request.clusterType)) {
      query["ClusterType"] = request.clusterType;
    }

    if (!Util.isUnset(request.grafanaInstanceId)) {
      query["GrafanaInstanceId"] = request.grafanaInstanceId;
    }

    if (!Util.isUnset(request.kubeConfig)) {
      query["KubeConfig"] = request.kubeConfig;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.securityGroupId)) {
      query["SecurityGroupId"] = request.securityGroupId;
    }

    if (!Util.isUnset(request.vSwitchId)) {
      query["VSwitchId"] = request.vSwitchId;
    }

    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "InstallManagedPrometheus",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<InstallManagedPrometheusResponse>(await this.callApi(params, req, runtime), new InstallManagedPrometheusResponse({}));
    } else {
      return $tea.cast<InstallManagedPrometheusResponse>(await this.execute(params, req, runtime), new InstallManagedPrometheusResponse({}));
    }

  }

  /**
   * Installs a Prometheus agent for serverless Kubernetes (ASK) clusters or Elastic Compute Service (ECS) clusters.
   * 
   * @remarks
   * You can call this operation only if the following conditions are met: The resources that you want to monitor are ASK clusters or ECS clusters. No Prometheus agents are installed in the ASK or ECS clusters. Take note that Prometheus agents can be installed only on the cloud service side, not in user clusters.
   * 
   * @deprecated OpenAPI InstallManagedPrometheus is deprecated
   * 
   * @param request - InstallManagedPrometheusRequest
   * @returns InstallManagedPrometheusResponse
   */
  // Deprecated
  async installManagedPrometheus(request: InstallManagedPrometheusRequest): Promise<InstallManagedPrometheusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.installManagedPrometheusWithOptions(request, runtime);
  }

  /**
   * Queries the alerts that have been triggered.
   * 
   * @param request - ListActivatedAlertsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListActivatedAlertsResponse
   */
  async listActivatedAlertsWithOptions(request: ListActivatedAlertsRequest, runtime: $Util.RuntimeOptions): Promise<ListActivatedAlertsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.filter)) {
      query["Filter"] = request.filter;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListActivatedAlerts",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListActivatedAlertsResponse>(await this.callApi(params, req, runtime), new ListActivatedAlertsResponse({}));
    } else {
      return $tea.cast<ListActivatedAlertsResponse>(await this.execute(params, req, runtime), new ListActivatedAlertsResponse({}));
    }

  }

  /**
   * Queries the alerts that have been triggered.
   * 
   * @param request - ListActivatedAlertsRequest
   * @returns ListActivatedAlertsResponse
   */
  async listActivatedAlerts(request: ListActivatedAlertsRequest): Promise<ListActivatedAlertsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listActivatedAlertsWithOptions(request, runtime);
  }

  /**
   * Queries the add-ons installed in an environment.
   * 
   * @param request - ListAddonReleasesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListAddonReleasesResponse
   */
  async listAddonReleasesWithOptions(request: ListAddonReleasesRequest, runtime: $Util.RuntimeOptions): Promise<ListAddonReleasesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.addonName)) {
      query["AddonName"] = request.addonName;
    }

    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListAddonReleases",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListAddonReleasesResponse>(await this.callApi(params, req, runtime), new ListAddonReleasesResponse({}));
    } else {
      return $tea.cast<ListAddonReleasesResponse>(await this.execute(params, req, runtime), new ListAddonReleasesResponse({}));
    }

  }

  /**
   * Queries the add-ons installed in an environment.
   * 
   * @param request - ListAddonReleasesRequest
   * @returns ListAddonReleasesResponse
   */
  async listAddonReleases(request: ListAddonReleasesRequest): Promise<ListAddonReleasesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAddonReleasesWithOptions(request, runtime);
  }

  /**
   * List of access center products.
   * 
   * @param request - ListAddonsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListAddonsResponse
   */
  async listAddonsWithOptions(request: ListAddonsRequest, runtime: $Util.RuntimeOptions): Promise<ListAddonsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliyunLang)) {
      query["AliyunLang"] = request.aliyunLang;
    }

    if (!Util.isUnset(request.category)) {
      query["Category"] = request.category;
    }

    if (!Util.isUnset(request.regexp)) {
      query["Regexp"] = request.regexp;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.search)) {
      query["Search"] = request.search;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListAddons",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListAddonsResponse>(await this.callApi(params, req, runtime), new ListAddonsResponse({}));
    } else {
      return $tea.cast<ListAddonsResponse>(await this.execute(params, req, runtime), new ListAddonsResponse({}));
    }

  }

  /**
   * List of access center products.
   * 
   * @param request - ListAddonsRequest
   * @returns ListAddonsResponse
   */
  async listAddons(request: ListAddonsRequest): Promise<ListAddonsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAddonsWithOptions(request, runtime);
  }

  /**
   * Queries historical alert events.
   * 
   * @param request - ListAlertEventsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListAlertEventsResponse
   */
  async listAlertEventsWithOptions(request: ListAlertEventsRequest, runtime: $Util.RuntimeOptions): Promise<ListAlertEventsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertName)) {
      query["AlertName"] = request.alertName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.matchingConditions)) {
      query["MatchingConditions"] = request.matchingConditions;
    }

    if (!Util.isUnset(request.page)) {
      query["Page"] = request.page;
    }

    if (!Util.isUnset(request.showNotificationPolicies)) {
      query["ShowNotificationPolicies"] = request.showNotificationPolicies;
    }

    if (!Util.isUnset(request.size)) {
      query["Size"] = request.size;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListAlertEvents",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListAlertEventsResponse>(await this.callApi(params, req, runtime), new ListAlertEventsResponse({}));
    } else {
      return $tea.cast<ListAlertEventsResponse>(await this.execute(params, req, runtime), new ListAlertEventsResponse({}));
    }

  }

  /**
   * Queries historical alert events.
   * 
   * @param request - ListAlertEventsRequest
   * @returns ListAlertEventsResponse
   */
  async listAlertEvents(request: ListAlertEventsRequest): Promise<ListAlertEventsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAlertEventsWithOptions(request, runtime);
  }

  /**
   * Queries the alert sending history.
   * 
   * @param request - ListAlertsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListAlertsResponse
   */
  async listAlertsWithOptions(request: ListAlertsRequest, runtime: $Util.RuntimeOptions): Promise<ListAlertsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertName)) {
      query["AlertName"] = request.alertName;
    }

    if (!Util.isUnset(request.dispatchRuleId)) {
      query["DispatchRuleId"] = request.dispatchRuleId;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.integrationType)) {
      query["IntegrationType"] = request.integrationType;
    }

    if (!Util.isUnset(request.owner)) {
      query["Owner"] = request.owner;
    }

    if (!Util.isUnset(request.page)) {
      query["Page"] = request.page;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.severity)) {
      query["Severity"] = request.severity;
    }

    if (!Util.isUnset(request.showActivities)) {
      query["ShowActivities"] = request.showActivities;
    }

    if (!Util.isUnset(request.showEvents)) {
      query["ShowEvents"] = request.showEvents;
    }

    if (!Util.isUnset(request.size)) {
      query["Size"] = request.size;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.state)) {
      query["State"] = request.state;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListAlerts",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListAlertsResponse>(await this.callApi(params, req, runtime), new ListAlertsResponse({}));
    } else {
      return $tea.cast<ListAlertsResponse>(await this.execute(params, req, runtime), new ListAlertsResponse({}));
    }

  }

  /**
   * Queries the alert sending history.
   * 
   * @param request - ListAlertsRequest
   * @returns ListAlertsResponse
   */
  async listAlerts(request: ListAlertsRequest): Promise<ListAlertsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAlertsWithOptions(request, runtime);
  }

  /**
   * Queries all Grafana dashboards in a specified region.
   * 
   * @param request - ListClusterFromGrafanaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListClusterFromGrafanaResponse
   */
  async listClusterFromGrafanaWithOptions(request: ListClusterFromGrafanaRequest, runtime: $Util.RuntimeOptions): Promise<ListClusterFromGrafanaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListClusterFromGrafana",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListClusterFromGrafanaResponse>(await this.callApi(params, req, runtime), new ListClusterFromGrafanaResponse({}));
    } else {
      return $tea.cast<ListClusterFromGrafanaResponse>(await this.execute(params, req, runtime), new ListClusterFromGrafanaResponse({}));
    }

  }

  /**
   * Queries all Grafana dashboards in a specified region.
   * 
   * @param request - ListClusterFromGrafanaRequest
   * @returns ListClusterFromGrafanaResponse
   */
  async listClusterFromGrafana(request: ListClusterFromGrafanaRequest): Promise<ListClusterFromGrafanaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClusterFromGrafanaWithOptions(request, runtime);
  }

  /**
   * 查询Cms安装信息
   * 
   * @deprecated OpenAPI ListCmsInstances is deprecated, please use ARMS::2019-08-08::ListEnvironmentAddons instead.
   * 
   * @param request - ListCmsInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListCmsInstancesResponse
   */
  // Deprecated
  async listCmsInstancesWithOptions(request: ListCmsInstancesRequest, runtime: $Util.RuntimeOptions): Promise<ListCmsInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.typeFilter)) {
      query["TypeFilter"] = request.typeFilter;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListCmsInstances",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListCmsInstancesResponse>(await this.callApi(params, req, runtime), new ListCmsInstancesResponse({}));
    } else {
      return $tea.cast<ListCmsInstancesResponse>(await this.execute(params, req, runtime), new ListCmsInstancesResponse({}));
    }

  }

  /**
   * 查询Cms安装信息
   * 
   * @deprecated OpenAPI ListCmsInstances is deprecated, please use ARMS::2019-08-08::ListEnvironmentAddons instead.
   * 
   * @param request - ListCmsInstancesRequest
   * @returns ListCmsInstancesResponse
   */
  // Deprecated
  async listCmsInstances(request: ListCmsInstancesRequest): Promise<ListCmsInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listCmsInstancesWithOptions(request, runtime);
  }

  /**
   * Queries the Grafana dashboards of a Container Service for Kubernetes (ACK) cluster.
   * 
   * @remarks
   * None.
   * 
   * @param request - ListDashboardsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDashboardsResponse
   */
  async listDashboardsWithOptions(request: ListDashboardsRequest, runtime: $Util.RuntimeOptions): Promise<ListDashboardsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.clusterType)) {
      query["ClusterType"] = request.clusterType;
    }

    if (!Util.isUnset(request.dashboardName)) {
      query["DashboardName"] = request.dashboardName;
    }

    if (!Util.isUnset(request.language)) {
      query["Language"] = request.language;
    }

    if (!Util.isUnset(request.product)) {
      query["Product"] = request.product;
    }

    if (!Util.isUnset(request.recreateSwitch)) {
      query["RecreateSwitch"] = request.recreateSwitch;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.title)) {
      query["Title"] = request.title;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDashboards",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListDashboardsResponse>(await this.callApi(params, req, runtime), new ListDashboardsResponse({}));
    } else {
      return $tea.cast<ListDashboardsResponse>(await this.execute(params, req, runtime), new ListDashboardsResponse({}));
    }

  }

  /**
   * Queries the Grafana dashboards of a Container Service for Kubernetes (ACK) cluster.
   * 
   * @remarks
   * None.
   * 
   * @param request - ListDashboardsRequest
   * @returns ListDashboardsResponse
   */
  async listDashboards(request: ListDashboardsRequest): Promise<ListDashboardsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDashboardsWithOptions(request, runtime);
  }

  /**
   * Uses Loki data sources and other data sources to create a dashboard in Prometheus Service.
   * 
   * @param request - ListDashboardsByNameRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDashboardsByNameResponse
   */
  async listDashboardsByNameWithOptions(request: ListDashboardsByNameRequest, runtime: $Util.RuntimeOptions): Promise<ListDashboardsByNameResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.clusterType)) {
      query["ClusterType"] = request.clusterType;
    }

    if (!Util.isUnset(request.dashBoardName)) {
      query["DashBoardName"] = request.dashBoardName;
    }

    if (!Util.isUnset(request.dashBoardVersion)) {
      query["DashBoardVersion"] = request.dashBoardVersion;
    }

    if (!Util.isUnset(request.dataSourceType)) {
      query["DataSourceType"] = request.dataSourceType;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.onlyQuery)) {
      query["OnlyQuery"] = request.onlyQuery;
    }

    if (!Util.isUnset(request.productCode)) {
      query["ProductCode"] = request.productCode;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDashboardsByName",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListDashboardsByNameResponse>(await this.callApi(params, req, runtime), new ListDashboardsByNameResponse({}));
    } else {
      return $tea.cast<ListDashboardsByNameResponse>(await this.execute(params, req, runtime), new ListDashboardsByNameResponse({}));
    }

  }

  /**
   * Uses Loki data sources and other data sources to create a dashboard in Prometheus Service.
   * 
   * @param request - ListDashboardsByNameRequest
   * @returns ListDashboardsByNameResponse
   */
  async listDashboardsByName(request: ListDashboardsByNameRequest): Promise<ListDashboardsByNameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDashboardsByNameWithOptions(request, runtime);
  }

  /**
   * Queries notification policies.
   * 
   * @remarks
   * The current API operation is no longer maintained. To query the notification policy information, call the ListNotificationPolicies operation instead.
   * 
   * @param request - ListDispatchRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDispatchRuleResponse
   */
  async listDispatchRuleWithOptions(request: ListDispatchRuleRequest, runtime: $Util.RuntimeOptions): Promise<ListDispatchRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.system)) {
      query["System"] = request.system;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDispatchRule",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListDispatchRuleResponse>(await this.callApi(params, req, runtime), new ListDispatchRuleResponse({}));
    } else {
      return $tea.cast<ListDispatchRuleResponse>(await this.execute(params, req, runtime), new ListDispatchRuleResponse({}));
    }

  }

  /**
   * Queries notification policies.
   * 
   * @remarks
   * The current API operation is no longer maintained. To query the notification policy information, call the ListNotificationPolicies operation instead.
   * 
   * @param request - ListDispatchRuleRequest
   * @returns ListDispatchRuleResponse
   */
  async listDispatchRule(request: ListDispatchRuleRequest): Promise<ListDispatchRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDispatchRuleWithOptions(request, runtime);
  }

  /**
   * Queries the custom jobs of an environment.
   * 
   * @param request - ListEnvCustomJobsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEnvCustomJobsResponse
   */
  async listEnvCustomJobsWithOptions(request: ListEnvCustomJobsRequest, runtime: $Util.RuntimeOptions): Promise<ListEnvCustomJobsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.encryptYaml)) {
      query["EncryptYaml"] = request.encryptYaml;
    }

    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListEnvCustomJobs",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListEnvCustomJobsResponse>(await this.callApi(params, req, runtime), new ListEnvCustomJobsResponse({}));
    } else {
      return $tea.cast<ListEnvCustomJobsResponse>(await this.execute(params, req, runtime), new ListEnvCustomJobsResponse({}));
    }

  }

  /**
   * Queries the custom jobs of an environment.
   * 
   * @param request - ListEnvCustomJobsRequest
   * @returns ListEnvCustomJobsResponse
   */
  async listEnvCustomJobs(request: ListEnvCustomJobsRequest): Promise<ListEnvCustomJobsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listEnvCustomJobsWithOptions(request, runtime);
  }

  /**
   * Queries the PodMonitors of an environment.
   * 
   * @param request - ListEnvPodMonitorsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEnvPodMonitorsResponse
   */
  async listEnvPodMonitorsWithOptions(request: ListEnvPodMonitorsRequest, runtime: $Util.RuntimeOptions): Promise<ListEnvPodMonitorsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListEnvPodMonitors",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListEnvPodMonitorsResponse>(await this.callApi(params, req, runtime), new ListEnvPodMonitorsResponse({}));
    } else {
      return $tea.cast<ListEnvPodMonitorsResponse>(await this.execute(params, req, runtime), new ListEnvPodMonitorsResponse({}));
    }

  }

  /**
   * Queries the PodMonitors of an environment.
   * 
   * @param request - ListEnvPodMonitorsRequest
   * @returns ListEnvPodMonitorsResponse
   */
  async listEnvPodMonitors(request: ListEnvPodMonitorsRequest): Promise<ListEnvPodMonitorsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listEnvPodMonitorsWithOptions(request, runtime);
  }

  /**
   * Queries the ServiceMonitors of an environment.
   * 
   * @param request - ListEnvServiceMonitorsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEnvServiceMonitorsResponse
   */
  async listEnvServiceMonitorsWithOptions(request: ListEnvServiceMonitorsRequest, runtime: $Util.RuntimeOptions): Promise<ListEnvServiceMonitorsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListEnvServiceMonitors",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListEnvServiceMonitorsResponse>(await this.callApi(params, req, runtime), new ListEnvServiceMonitorsResponse({}));
    } else {
      return $tea.cast<ListEnvServiceMonitorsResponse>(await this.execute(params, req, runtime), new ListEnvServiceMonitorsResponse({}));
    }

  }

  /**
   * Queries the ServiceMonitors of an environment.
   * 
   * @param request - ListEnvServiceMonitorsRequest
   * @returns ListEnvServiceMonitorsResponse
   */
  async listEnvServiceMonitors(request: ListEnvServiceMonitorsRequest): Promise<ListEnvServiceMonitorsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listEnvServiceMonitorsWithOptions(request, runtime);
  }

  /**
   * Queries information about a dashboard of an environment instance.
   * 
   * @param request - ListEnvironmentDashboardsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEnvironmentDashboardsResponse
   */
  async listEnvironmentDashboardsWithOptions(request: ListEnvironmentDashboardsRequest, runtime: $Util.RuntimeOptions): Promise<ListEnvironmentDashboardsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.addonName)) {
      query["AddonName"] = request.addonName;
    }

    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.scene)) {
      query["Scene"] = request.scene;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListEnvironmentDashboards",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListEnvironmentDashboardsResponse>(await this.callApi(params, req, runtime), new ListEnvironmentDashboardsResponse({}));
    } else {
      return $tea.cast<ListEnvironmentDashboardsResponse>(await this.execute(params, req, runtime), new ListEnvironmentDashboardsResponse({}));
    }

  }

  /**
   * Queries information about a dashboard of an environment instance.
   * 
   * @param request - ListEnvironmentDashboardsRequest
   * @returns ListEnvironmentDashboardsResponse
   */
  async listEnvironmentDashboards(request: ListEnvironmentDashboardsRequest): Promise<ListEnvironmentDashboardsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listEnvironmentDashboardsWithOptions(request, runtime);
  }

  /**
   * Queries the features in an environment.
   * 
   * @param request - ListEnvironmentFeaturesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEnvironmentFeaturesResponse
   */
  async listEnvironmentFeaturesWithOptions(request: ListEnvironmentFeaturesRequest, runtime: $Util.RuntimeOptions): Promise<ListEnvironmentFeaturesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliyunLang)) {
      query["AliyunLang"] = request.aliyunLang;
    }

    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListEnvironmentFeatures",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListEnvironmentFeaturesResponse>(await this.callApi(params, req, runtime), new ListEnvironmentFeaturesResponse({}));
    } else {
      return $tea.cast<ListEnvironmentFeaturesResponse>(await this.execute(params, req, runtime), new ListEnvironmentFeaturesResponse({}));
    }

  }

  /**
   * Queries the features in an environment.
   * 
   * @param request - ListEnvironmentFeaturesRequest
   * @returns ListEnvironmentFeaturesResponse
   */
  async listEnvironmentFeatures(request: ListEnvironmentFeaturesRequest): Promise<ListEnvironmentFeaturesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listEnvironmentFeaturesWithOptions(request, runtime);
  }

  /**
   * Queries environments.
   * 
   * @param tmpReq - ListEnvironmentsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEnvironmentsResponse
   */
  async listEnvironmentsWithOptions(tmpReq: ListEnvironmentsRequest, runtime: $Util.RuntimeOptions): Promise<ListEnvironmentsResponse> {
    Util.validateModel(tmpReq);
    let request = new ListEnvironmentsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.tag)) {
      request.tagShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tag, "Tag", "json");
    }

    let query = { };
    if (!Util.isUnset(request.addonName)) {
      query["AddonName"] = request.addonName;
    }

    if (!Util.isUnset(request.bindResourceId)) {
      query["BindResourceId"] = request.bindResourceId;
    }

    if (!Util.isUnset(request.environmentType)) {
      query["EnvironmentType"] = request.environmentType;
    }

    if (!Util.isUnset(request.feePackage)) {
      query["FeePackage"] = request.feePackage;
    }

    if (!Util.isUnset(request.filterRegionIds)) {
      query["FilterRegionIds"] = request.filterRegionIds;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.tagShrink)) {
      query["Tag"] = request.tagShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListEnvironments",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListEnvironmentsResponse>(await this.callApi(params, req, runtime), new ListEnvironmentsResponse({}));
    } else {
      return $tea.cast<ListEnvironmentsResponse>(await this.execute(params, req, runtime), new ListEnvironmentsResponse({}));
    }

  }

  /**
   * Queries environments.
   * 
   * @param request - ListEnvironmentsRequest
   * @returns ListEnvironmentsResponse
   */
  async listEnvironments(request: ListEnvironmentsRequest): Promise<ListEnvironmentsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listEnvironmentsWithOptions(request, runtime);
  }

  /**
   * Queries the information about an escalation policy.
   * 
   * @param request - ListEscalationPoliciesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEscalationPoliciesResponse
   */
  async listEscalationPoliciesWithOptions(request: ListEscalationPoliciesRequest, runtime: $Util.RuntimeOptions): Promise<ListEscalationPoliciesResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListEscalationPolicies",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListEscalationPoliciesResponse>(await this.callApi(params, req, runtime), new ListEscalationPoliciesResponse({}));
    } else {
      return $tea.cast<ListEscalationPoliciesResponse>(await this.execute(params, req, runtime), new ListEscalationPoliciesResponse({}));
    }

  }

  /**
   * Queries the information about an escalation policy.
   * 
   * @param request - ListEscalationPoliciesRequest
   * @returns ListEscalationPoliciesResponse
   */
  async listEscalationPolicies(request: ListEscalationPoliciesRequest): Promise<ListEscalationPoliciesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listEscalationPoliciesWithOptions(request, runtime);
  }

  /**
   * Queries an EventBridge integration.
   * 
   * @param request - ListEventBridgeIntegrationsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEventBridgeIntegrationsResponse
   */
  async listEventBridgeIntegrationsWithOptions(request: ListEventBridgeIntegrationsRequest, runtime: $Util.RuntimeOptions): Promise<ListEventBridgeIntegrationsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListEventBridgeIntegrations",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListEventBridgeIntegrationsResponse>(await this.callApi(params, req, runtime), new ListEventBridgeIntegrationsResponse({}));
    } else {
      return $tea.cast<ListEventBridgeIntegrationsResponse>(await this.execute(params, req, runtime), new ListEventBridgeIntegrationsResponse({}));
    }

  }

  /**
   * Queries an EventBridge integration.
   * 
   * @param request - ListEventBridgeIntegrationsRequest
   * @returns ListEventBridgeIntegrationsResponse
   */
  async listEventBridgeIntegrations(request: ListEventBridgeIntegrationsRequest): Promise<ListEventBridgeIntegrationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listEventBridgeIntegrationsWithOptions(request, runtime);
  }

  /**
   * Obtain Specified Workspace List
   * 
   * @remarks
   * >The list returned by this operation includes the workspaces of Developer Edition, Expert Edition, and Advanced Edition. The list does not include the workspaces of Shared Edition.
   * 
   * @param tmpReq - ListGrafanaWorkspaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListGrafanaWorkspaceResponse
   */
  async listGrafanaWorkspaceWithOptions(tmpReq: ListGrafanaWorkspaceRequest, runtime: $Util.RuntimeOptions): Promise<ListGrafanaWorkspaceResponse> {
    Util.validateModel(tmpReq);
    let request = new ListGrafanaWorkspaceShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.tags)) {
      request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, "Tags", "json");
    }

    let query = { };
    if (!Util.isUnset(request.aliyunLang)) {
      query["AliyunLang"] = request.aliyunLang;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.tagsShrink)) {
      query["Tags"] = request.tagsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListGrafanaWorkspace",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListGrafanaWorkspaceResponse>(await this.callApi(params, req, runtime), new ListGrafanaWorkspaceResponse({}));
    } else {
      return $tea.cast<ListGrafanaWorkspaceResponse>(await this.execute(params, req, runtime), new ListGrafanaWorkspaceResponse({}));
    }

  }

  /**
   * Obtain Specified Workspace List
   * 
   * @remarks
   * >The list returned by this operation includes the workspaces of Developer Edition, Expert Edition, and Advanced Edition. The list does not include the workspaces of Shared Edition.
   * 
   * @param request - ListGrafanaWorkspaceRequest
   * @returns ListGrafanaWorkspaceResponse
   */
  async listGrafanaWorkspace(request: ListGrafanaWorkspaceRequest): Promise<ListGrafanaWorkspaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listGrafanaWorkspaceWithOptions(request, runtime);
  }

  /**
   * Queries the abnormal Insights events within a specified period of time.
   * 
   * @param request - ListInsightsEventsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListInsightsEventsResponse
   */
  async listInsightsEventsWithOptions(request: ListInsightsEventsRequest, runtime: $Util.RuntimeOptions): Promise<ListInsightsEventsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.insightsTypes)) {
      query["InsightsTypes"] = request.insightsTypes;
    }

    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListInsightsEvents",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListInsightsEventsResponse>(await this.callApi(params, req, runtime), new ListInsightsEventsResponse({}));
    } else {
      return $tea.cast<ListInsightsEventsResponse>(await this.execute(params, req, runtime), new ListInsightsEventsResponse({}));
    }

  }

  /**
   * Queries the abnormal Insights events within a specified period of time.
   * 
   * @param request - ListInsightsEventsRequest
   * @returns ListInsightsEventsResponse
   */
  async listInsightsEvents(request: ListInsightsEventsRequest): Promise<ListInsightsEventsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listInsightsEventsWithOptions(request, runtime);
  }

  /**
   * Views a list of alert integrations.
   * 
   * @param request - ListIntegrationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListIntegrationResponse
   */
  async listIntegrationWithOptions(request: ListIntegrationRequest, runtime: $Util.RuntimeOptions): Promise<ListIntegrationResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListIntegration",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListIntegrationResponse>(await this.callApi(params, req, runtime), new ListIntegrationResponse({}));
    } else {
      return $tea.cast<ListIntegrationResponse>(await this.execute(params, req, runtime), new ListIntegrationResponse({}));
    }

  }

  /**
   * Views a list of alert integrations.
   * 
   * @param request - ListIntegrationRequest
   * @returns ListIntegrationResponse
   */
  async listIntegration(request: ListIntegrationRequest): Promise<ListIntegrationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listIntegrationWithOptions(request, runtime);
  }

  /**
   * Queries notification policies based on specified conditions.
   * 
   * @param request - ListNotificationPoliciesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListNotificationPoliciesResponse
   */
  async listNotificationPoliciesWithOptions(request: ListNotificationPoliciesRequest, runtime: $Util.RuntimeOptions): Promise<ListNotificationPoliciesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.directedMode)) {
      query["DirectedMode"] = request.directedMode;
    }

    if (!Util.isUnset(request.ids)) {
      query["Ids"] = request.ids;
    }

    if (!Util.isUnset(request.isDetail)) {
      query["IsDetail"] = request.isDetail;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.page)) {
      query["Page"] = request.page;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.size)) {
      query["Size"] = request.size;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListNotificationPolicies",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListNotificationPoliciesResponse>(await this.callApi(params, req, runtime), new ListNotificationPoliciesResponse({}));
    } else {
      return $tea.cast<ListNotificationPoliciesResponse>(await this.execute(params, req, runtime), new ListNotificationPoliciesResponse({}));
    }

  }

  /**
   * Queries notification policies based on specified conditions.
   * 
   * @param request - ListNotificationPoliciesRequest
   * @returns ListNotificationPoliciesResponse
   */
  async listNotificationPolicies(request: ListNotificationPoliciesRequest): Promise<ListNotificationPoliciesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listNotificationPoliciesWithOptions(request, runtime);
  }

  /**
   * Queries the information about a scheduling policy.
   * 
   * @param request - ListOnCallSchedulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListOnCallSchedulesResponse
   */
  async listOnCallSchedulesWithOptions(request: ListOnCallSchedulesRequest, runtime: $Util.RuntimeOptions): Promise<ListOnCallSchedulesResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListOnCallSchedules",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListOnCallSchedulesResponse>(await this.callApi(params, req, runtime), new ListOnCallSchedulesResponse({}));
    } else {
      return $tea.cast<ListOnCallSchedulesResponse>(await this.execute(params, req, runtime), new ListOnCallSchedulesResponse({}));
    }

  }

  /**
   * Queries the information about a scheduling policy.
   * 
   * @param request - ListOnCallSchedulesRequest
   * @returns ListOnCallSchedulesResponse
   */
  async listOnCallSchedules(request: ListOnCallSchedulesRequest): Promise<ListOnCallSchedulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listOnCallSchedulesWithOptions(request, runtime);
  }

  /**
   * Queries the alert rules created for a Prometheus instance.
   * 
   * @param request - ListPrometheusAlertRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListPrometheusAlertRulesResponse
   */
  async listPrometheusAlertRulesWithOptions(request: ListPrometheusAlertRulesRequest, runtime: $Util.RuntimeOptions): Promise<ListPrometheusAlertRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.matchExpressions)) {
      query["MatchExpressions"] = request.matchExpressions;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPrometheusAlertRules",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListPrometheusAlertRulesResponse>(await this.callApi(params, req, runtime), new ListPrometheusAlertRulesResponse({}));
    } else {
      return $tea.cast<ListPrometheusAlertRulesResponse>(await this.execute(params, req, runtime), new ListPrometheusAlertRulesResponse({}));
    }

  }

  /**
   * Queries the alert rules created for a Prometheus instance.
   * 
   * @param request - ListPrometheusAlertRulesRequest
   * @returns ListPrometheusAlertRulesResponse
   */
  async listPrometheusAlertRules(request: ListPrometheusAlertRulesRequest): Promise<ListPrometheusAlertRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listPrometheusAlertRulesWithOptions(request, runtime);
  }

  /**
   * Queries the alert templates of Prometheus Service.
   * 
   * @param request - ListPrometheusAlertTemplatesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListPrometheusAlertTemplatesResponse
   */
  async listPrometheusAlertTemplatesWithOptions(request: ListPrometheusAlertTemplatesRequest, runtime: $Util.RuntimeOptions): Promise<ListPrometheusAlertTemplatesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPrometheusAlertTemplates",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListPrometheusAlertTemplatesResponse>(await this.callApi(params, req, runtime), new ListPrometheusAlertTemplatesResponse({}));
    } else {
      return $tea.cast<ListPrometheusAlertTemplatesResponse>(await this.execute(params, req, runtime), new ListPrometheusAlertTemplatesResponse({}));
    }

  }

  /**
   * Queries the alert templates of Prometheus Service.
   * 
   * @param request - ListPrometheusAlertTemplatesRequest
   * @returns ListPrometheusAlertTemplatesResponse
   */
  async listPrometheusAlertTemplates(request: ListPrometheusAlertTemplatesRequest): Promise<ListPrometheusAlertTemplatesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listPrometheusAlertTemplatesWithOptions(request, runtime);
  }

  /**
   * Creates a global aggregation instance in Prometheus Service and obtains the list of global aggregation instances.
   * 
   * @param request - ListPrometheusGlobalViewRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListPrometheusGlobalViewResponse
   */
  async listPrometheusGlobalViewWithOptions(request: ListPrometheusGlobalViewRequest, runtime: $Util.RuntimeOptions): Promise<ListPrometheusGlobalViewResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPrometheusGlobalView",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListPrometheusGlobalViewResponse>(await this.callApi(params, req, runtime), new ListPrometheusGlobalViewResponse({}));
    } else {
      return $tea.cast<ListPrometheusGlobalViewResponse>(await this.execute(params, req, runtime), new ListPrometheusGlobalViewResponse({}));
    }

  }

  /**
   * Creates a global aggregation instance in Prometheus Service and obtains the list of global aggregation instances.
   * 
   * @param request - ListPrometheusGlobalViewRequest
   * @returns ListPrometheusGlobalViewResponse
   */
  async listPrometheusGlobalView(request: ListPrometheusGlobalViewRequest): Promise<ListPrometheusGlobalViewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listPrometheusGlobalViewWithOptions(request, runtime);
  }

  /**
   * Queries Prometheus instances by tag and resource group.
   * 
   * @param request - ListPrometheusInstanceByTagAndResourceGroupIdRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListPrometheusInstanceByTagAndResourceGroupIdResponse
   */
  async listPrometheusInstanceByTagAndResourceGroupIdWithOptions(request: ListPrometheusInstanceByTagAndResourceGroupIdRequest, runtime: $Util.RuntimeOptions): Promise<ListPrometheusInstanceByTagAndResourceGroupIdResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPrometheusInstanceByTagAndResourceGroupId",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListPrometheusInstanceByTagAndResourceGroupIdResponse>(await this.callApi(params, req, runtime), new ListPrometheusInstanceByTagAndResourceGroupIdResponse({}));
    } else {
      return $tea.cast<ListPrometheusInstanceByTagAndResourceGroupIdResponse>(await this.execute(params, req, runtime), new ListPrometheusInstanceByTagAndResourceGroupIdResponse({}));
    }

  }

  /**
   * Queries Prometheus instances by tag and resource group.
   * 
   * @param request - ListPrometheusInstanceByTagAndResourceGroupIdRequest
   * @returns ListPrometheusInstanceByTagAndResourceGroupIdResponse
   */
  async listPrometheusInstanceByTagAndResourceGroupId(request: ListPrometheusInstanceByTagAndResourceGroupIdRequest): Promise<ListPrometheusInstanceByTagAndResourceGroupIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listPrometheusInstanceByTagAndResourceGroupIdWithOptions(request, runtime);
  }

  /**
   * Obtains all Prometheus instances in a region.
   * 
   * @param request - ListPrometheusInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListPrometheusInstancesResponse
   */
  async listPrometheusInstancesWithOptions(request: ListPrometheusInstancesRequest, runtime: $Util.RuntimeOptions): Promise<ListPrometheusInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterType)) {
      query["ClusterType"] = request.clusterType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.showGlobalView)) {
      query["ShowGlobalView"] = request.showGlobalView;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPrometheusInstances",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListPrometheusInstancesResponse>(await this.callApi(params, req, runtime), new ListPrometheusInstancesResponse({}));
    } else {
      return $tea.cast<ListPrometheusInstancesResponse>(await this.execute(params, req, runtime), new ListPrometheusInstancesResponse({}));
    }

  }

  /**
   * Obtains all Prometheus instances in a region.
   * 
   * @param request - ListPrometheusInstancesRequest
   * @returns ListPrometheusInstancesResponse
   */
  async listPrometheusInstances(request: ListPrometheusInstancesRequest): Promise<ListPrometheusInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listPrometheusInstancesWithOptions(request, runtime);
  }

  /**
   * Queries a list of exporters that are integrated into a Prometheus instance. Only aliyun-cs and ecs instances are supported.
   * 
   * @param request - ListPrometheusIntegrationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListPrometheusIntegrationResponse
   */
  async listPrometheusIntegrationWithOptions(request: ListPrometheusIntegrationRequest, runtime: $Util.RuntimeOptions): Promise<ListPrometheusIntegrationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.integrationType)) {
      query["IntegrationType"] = request.integrationType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPrometheusIntegration",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListPrometheusIntegrationResponse>(await this.callApi(params, req, runtime), new ListPrometheusIntegrationResponse({}));
    } else {
      return $tea.cast<ListPrometheusIntegrationResponse>(await this.execute(params, req, runtime), new ListPrometheusIntegrationResponse({}));
    }

  }

  /**
   * Queries a list of exporters that are integrated into a Prometheus instance. Only aliyun-cs and ecs instances are supported.
   * 
   * @param request - ListPrometheusIntegrationRequest
   * @returns ListPrometheusIntegrationResponse
   */
  async listPrometheusIntegration(request: ListPrometheusIntegrationRequest): Promise<ListPrometheusIntegrationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listPrometheusIntegrationWithOptions(request, runtime);
  }

  /**
   * Queries the monitoring configuration of a Prometheus instance.
   * 
   * @param request - ListPrometheusMonitoringRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListPrometheusMonitoringResponse
   */
  async listPrometheusMonitoringWithOptions(request: ListPrometheusMonitoringRequest, runtime: $Util.RuntimeOptions): Promise<ListPrometheusMonitoringResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPrometheusMonitoring",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListPrometheusMonitoringResponse>(await this.callApi(params, req, runtime), new ListPrometheusMonitoringResponse({}));
    } else {
      return $tea.cast<ListPrometheusMonitoringResponse>(await this.execute(params, req, runtime), new ListPrometheusMonitoringResponse({}));
    }

  }

  /**
   * Queries the monitoring configuration of a Prometheus instance.
   * 
   * @param request - ListPrometheusMonitoringRequest
   * @returns ListPrometheusMonitoringResponse
   */
  async listPrometheusMonitoring(request: ListPrometheusMonitoringRequest): Promise<ListPrometheusMonitoringResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listPrometheusMonitoringWithOptions(request, runtime);
  }

  /**
   * Queries the Browser Monitoring tasks in a region.
   * 
   * @remarks
   * ***
   * 
   * @param request - ListRetcodeAppsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListRetcodeAppsResponse
   */
  async listRetcodeAppsWithOptions(request: ListRetcodeAppsRequest, runtime: $Util.RuntimeOptions): Promise<ListRetcodeAppsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListRetcodeApps",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListRetcodeAppsResponse>(await this.callApi(params, req, runtime), new ListRetcodeAppsResponse({}));
    } else {
      return $tea.cast<ListRetcodeAppsResponse>(await this.execute(params, req, runtime), new ListRetcodeAppsResponse({}));
    }

  }

  /**
   * Queries the Browser Monitoring tasks in a region.
   * 
   * @remarks
   * ***
   * 
   * @param request - ListRetcodeAppsRequest
   * @returns ListRetcodeAppsResponse
   */
  async listRetcodeApps(request: ListRetcodeAppsRequest): Promise<ListRetcodeAppsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listRetcodeAppsWithOptions(request, runtime);
  }

  /**
   * @param request - ListScenarioRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListScenarioResponse
   */
  async listScenarioWithOptions(request: ListScenarioRequest, runtime: $Util.RuntimeOptions): Promise<ListScenarioResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.scenario)) {
      query["Scenario"] = request.scenario;
    }

    if (!Util.isUnset(request.sign)) {
      query["Sign"] = request.sign;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListScenario",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListScenarioResponse>(await this.callApi(params, req, runtime), new ListScenarioResponse({}));
    } else {
      return $tea.cast<ListScenarioResponse>(await this.execute(params, req, runtime), new ListScenarioResponse({}));
    }

  }

  /**
   * @param request - ListScenarioRequest
   * @returns ListScenarioResponse
   */
  async listScenario(request: ListScenarioRequest): Promise<ListScenarioResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listScenarioWithOptions(request, runtime);
  }

  /**
   * Queries the information of a silence policy list.
   * 
   * @param request - ListSilencePoliciesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListSilencePoliciesResponse
   */
  async listSilencePoliciesWithOptions(request: ListSilencePoliciesRequest, runtime: $Util.RuntimeOptions): Promise<ListSilencePoliciesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.isDetail)) {
      query["IsDetail"] = request.isDetail;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.page)) {
      query["Page"] = request.page;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.size)) {
      query["Size"] = request.size;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSilencePolicies",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListSilencePoliciesResponse>(await this.callApi(params, req, runtime), new ListSilencePoliciesResponse({}));
    } else {
      return $tea.cast<ListSilencePoliciesResponse>(await this.execute(params, req, runtime), new ListSilencePoliciesResponse({}));
    }

  }

  /**
   * Queries the information of a silence policy list.
   * 
   * @param request - ListSilencePoliciesRequest
   * @returns ListSilencePoliciesResponse
   */
  async listSilencePolicies(request: ListSilencePoliciesRequest): Promise<ListSilencePoliciesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSilencePoliciesWithOptions(request, runtime);
  }

  /**
   * Obtains the results of one or more synthetic tests.
   * 
   * @param tmpReq - ListSyntheticDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListSyntheticDetailResponse
   */
  async listSyntheticDetailWithOptions(tmpReq: ListSyntheticDetailRequest, runtime: $Util.RuntimeOptions): Promise<ListSyntheticDetailResponse> {
    Util.validateModel(tmpReq);
    let request = new ListSyntheticDetailShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.advancedFilters)) {
      request.advancedFiltersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.advancedFilters, "AdvancedFilters", "json");
    }

    if (!Util.isUnset(tmpReq.exactFilters)) {
      request.exactFiltersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.exactFilters, "ExactFilters", "json");
    }

    if (!Util.isUnset(tmpReq.filters)) {
      request.filtersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filters, "Filters", "json");
    }

    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSyntheticDetail",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListSyntheticDetailResponse>(await this.callApi(params, req, runtime), new ListSyntheticDetailResponse({}));
    } else {
      return $tea.cast<ListSyntheticDetailResponse>(await this.execute(params, req, runtime), new ListSyntheticDetailResponse({}));
    }

  }

  /**
   * Obtains the results of one or more synthetic tests.
   * 
   * @param request - ListSyntheticDetailRequest
   * @returns ListSyntheticDetailResponse
   */
  async listSyntheticDetail(request: ListSyntheticDetailRequest): Promise<ListSyntheticDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSyntheticDetailWithOptions(request, runtime);
  }

  /**
   * Queries scheduled synthetic monitoring tasks.
   * 
   * @param tmpReq - ListTimingSyntheticTasksRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListTimingSyntheticTasksResponse
   */
  async listTimingSyntheticTasksWithOptions(tmpReq: ListTimingSyntheticTasksRequest, runtime: $Util.RuntimeOptions): Promise<ListTimingSyntheticTasksResponse> {
    Util.validateModel(tmpReq);
    let request = new ListTimingSyntheticTasksShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.search)) {
      request.searchShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.search, "Search", "json");
    }

    if (!Util.isUnset(tmpReq.tags)) {
      request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, "Tags", "json");
    }

    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTimingSyntheticTasks",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListTimingSyntheticTasksResponse>(await this.callApi(params, req, runtime), new ListTimingSyntheticTasksResponse({}));
    } else {
      return $tea.cast<ListTimingSyntheticTasksResponse>(await this.execute(params, req, runtime), new ListTimingSyntheticTasksResponse({}));
    }

  }

  /**
   * Queries scheduled synthetic monitoring tasks.
   * 
   * @param request - ListTimingSyntheticTasksRequest
   * @returns ListTimingSyntheticTasksResponse
   */
  async listTimingSyntheticTasks(request: ListTimingSyntheticTasksRequest): Promise<ListTimingSyntheticTasksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTimingSyntheticTasksWithOptions(request, runtime);
  }

  /**
   * Queries all Application Monitoring tasks in a specified region.
   * 
   * @param request - ListTraceAppsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListTraceAppsResponse
   */
  async listTraceAppsWithOptions(request: ListTraceAppsRequest, runtime: $Util.RuntimeOptions): Promise<ListTraceAppsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appType)) {
      query["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTraceApps",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ListTraceAppsResponse>(await this.callApi(params, req, runtime), new ListTraceAppsResponse({}));
    } else {
      return $tea.cast<ListTraceAppsResponse>(await this.execute(params, req, runtime), new ListTraceAppsResponse({}));
    }

  }

  /**
   * Queries all Application Monitoring tasks in a specified region.
   * 
   * @param request - ListTraceAppsRequest
   * @returns ListTraceAppsResponse
   */
  async listTraceApps(request: ListTraceAppsRequest): Promise<ListTraceAppsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTraceAppsWithOptions(request, runtime);
  }

  /**
   * Obtains the recording rule of a cluster monitored by Prometheus Service.
   * 
   * @param request - ManageGetRecordingRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ManageGetRecordingRuleResponse
   */
  async manageGetRecordingRuleWithOptions(request: ManageGetRecordingRuleRequest, runtime: $Util.RuntimeOptions): Promise<ManageGetRecordingRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.queryUserId)) {
      query["QueryUserId"] = request.queryUserId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ManageGetRecordingRule",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ManageGetRecordingRuleResponse>(await this.callApi(params, req, runtime), new ManageGetRecordingRuleResponse({}));
    } else {
      return $tea.cast<ManageGetRecordingRuleResponse>(await this.execute(params, req, runtime), new ManageGetRecordingRuleResponse({}));
    }

  }

  /**
   * Obtains the recording rule of a cluster monitored by Prometheus Service.
   * 
   * @param request - ManageGetRecordingRuleRequest
   * @returns ManageGetRecordingRuleResponse
   */
  async manageGetRecordingRule(request: ManageGetRecordingRuleRequest): Promise<ManageGetRecordingRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.manageGetRecordingRuleWithOptions(request, runtime);
  }

  /**
   * Edits the recording rule of a cluster monitored by Prometheus Service.
   * 
   * @param request - ManageRecordingRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ManageRecordingRuleResponse
   */
  async manageRecordingRuleWithOptions(request: ManageRecordingRuleRequest, runtime: $Util.RuntimeOptions): Promise<ManageRecordingRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.queryUserId)) {
      query["QueryUserId"] = request.queryUserId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.ruleYaml)) {
      query["RuleYaml"] = request.ruleYaml;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ManageRecordingRule",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<ManageRecordingRuleResponse>(await this.callApi(params, req, runtime), new ManageRecordingRuleResponse({}));
    } else {
      return $tea.cast<ManageRecordingRuleResponse>(await this.execute(params, req, runtime), new ManageRecordingRuleResponse({}));
    }

  }

  /**
   * Edits the recording rule of a cluster monitored by Prometheus Service.
   * 
   * @param request - ManageRecordingRuleRequest
   * @returns ManageRecordingRuleResponse
   */
  async manageRecordingRule(request: ManageRecordingRuleRequest): Promise<ManageRecordingRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.manageRecordingRuleWithOptions(request, runtime);
  }

  /**
   * Activates the service-linked role AliyunServiceRoleForARMS for Application Real-Time Monitoring Service (ARMS).
   * 
   * @param request - OpenArmsDefaultSLRRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns OpenArmsDefaultSLRResponse
   */
  async openArmsDefaultSLRWithOptions(request: OpenArmsDefaultSLRRequest, runtime: $Util.RuntimeOptions): Promise<OpenArmsDefaultSLRResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "OpenArmsDefaultSLR",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<OpenArmsDefaultSLRResponse>(await this.callApi(params, req, runtime), new OpenArmsDefaultSLRResponse({}));
    } else {
      return $tea.cast<OpenArmsDefaultSLRResponse>(await this.execute(params, req, runtime), new OpenArmsDefaultSLRResponse({}));
    }

  }

  /**
   * Activates the service-linked role AliyunServiceRoleForARMS for Application Real-Time Monitoring Service (ARMS).
   * 
   * @param request - OpenArmsDefaultSLRRequest
   * @returns OpenArmsDefaultSLRResponse
   */
  async openArmsDefaultSLR(request: OpenArmsDefaultSLRRequest): Promise<OpenArmsDefaultSLRResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.openArmsDefaultSLRWithOptions(request, runtime);
  }

  /**
   * Activates a specified pay-as-you-go sub-service of Application Real-Time Monitoring Service (ARMS).
   * 
   * @remarks
   * The **OpenArmsServiceSecondVersion** operation supports the following sub-service editions:
   * *   Application Monitoring: Basic Edition
   * *   Browser Monitoring: Basic Edition
   * *   Synthetic Monitoring: Pro Edition (pay-as-you-go)
   * *   Prometheus Service: Pro Edition
   * 
   * @param request - OpenArmsServiceSecondVersionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns OpenArmsServiceSecondVersionResponse
   */
  async openArmsServiceSecondVersionWithOptions(request: OpenArmsServiceSecondVersionRequest, runtime: $Util.RuntimeOptions): Promise<OpenArmsServiceSecondVersionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "OpenArmsServiceSecondVersion",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<OpenArmsServiceSecondVersionResponse>(await this.callApi(params, req, runtime), new OpenArmsServiceSecondVersionResponse({}));
    } else {
      return $tea.cast<OpenArmsServiceSecondVersionResponse>(await this.execute(params, req, runtime), new OpenArmsServiceSecondVersionResponse({}));
    }

  }

  /**
   * Activates a specified pay-as-you-go sub-service of Application Real-Time Monitoring Service (ARMS).
   * 
   * @remarks
   * The **OpenArmsServiceSecondVersion** operation supports the following sub-service editions:
   * *   Application Monitoring: Basic Edition
   * *   Browser Monitoring: Basic Edition
   * *   Synthetic Monitoring: Pro Edition (pay-as-you-go)
   * *   Prometheus Service: Pro Edition
   * 
   * @param request - OpenArmsServiceSecondVersionRequest
   * @returns OpenArmsServiceSecondVersionResponse
   */
  async openArmsServiceSecondVersion(request: OpenArmsServiceSecondVersionRequest): Promise<OpenArmsServiceSecondVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.openArmsServiceSecondVersionWithOptions(request, runtime);
  }

  /**
   * Activates a virtual cluster.
   * 
   * @param request - OpenVClusterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns OpenVClusterResponse
   */
  async openVClusterWithOptions(request: OpenVClusterRequest, runtime: $Util.RuntimeOptions): Promise<OpenVClusterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterType)) {
      query["ClusterType"] = request.clusterType;
    }

    if (!Util.isUnset(request.length)) {
      query["Length"] = request.length;
    }

    if (!Util.isUnset(request.product)) {
      query["Product"] = request.product;
    }

    if (!Util.isUnset(request.recreateSwitch)) {
      query["RecreateSwitch"] = request.recreateSwitch;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "OpenVCluster",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<OpenVClusterResponse>(await this.callApi(params, req, runtime), new OpenVClusterResponse({}));
    } else {
      return $tea.cast<OpenVClusterResponse>(await this.execute(params, req, runtime), new OpenVClusterResponse({}));
    }

  }

  /**
   * Activates a virtual cluster.
   * 
   * @param request - OpenVClusterRequest
   * @returns OpenVClusterResponse
   */
  async openVCluster(request: OpenVClusterRequest): Promise<OpenVClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.openVClusterWithOptions(request, runtime);
  }

  /**
   * Activates the service-linked role AliyunServiceRoleForXtrace for Tracing Analysis.
   * 
   * @param request - OpenXtraceDefaultSLRRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns OpenXtraceDefaultSLRResponse
   */
  async openXtraceDefaultSLRWithOptions(request: OpenXtraceDefaultSLRRequest, runtime: $Util.RuntimeOptions): Promise<OpenXtraceDefaultSLRResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "OpenXtraceDefaultSLR",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<OpenXtraceDefaultSLRResponse>(await this.callApi(params, req, runtime), new OpenXtraceDefaultSLRResponse({}));
    } else {
      return $tea.cast<OpenXtraceDefaultSLRResponse>(await this.execute(params, req, runtime), new OpenXtraceDefaultSLRResponse({}));
    }

  }

  /**
   * Activates the service-linked role AliyunServiceRoleForXtrace for Tracing Analysis.
   * 
   * @param request - OpenXtraceDefaultSLRRequest
   * @returns OpenXtraceDefaultSLRResponse
   */
  async openXtraceDefaultSLR(request: OpenXtraceDefaultSLRRequest): Promise<OpenXtraceDefaultSLRResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.openXtraceDefaultSLRWithOptions(request, runtime);
  }

  /**
   * Queries the encoding mapping content based on the metadata IDs and metadata type.
   * 
   * @param request - QueryAppMetadataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryAppMetadataResponse
   */
  async queryAppMetadataWithOptions(request: QueryAppMetadataRequest, runtime: $Util.RuntimeOptions): Promise<QueryAppMetadataResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryAppMetadata",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<QueryAppMetadataResponse>(await this.callApi(params, req, runtime), new QueryAppMetadataResponse({}));
    } else {
      return $tea.cast<QueryAppMetadataResponse>(await this.execute(params, req, runtime), new QueryAppMetadataResponse({}));
    }

  }

  /**
   * Queries the encoding mapping content based on the metadata IDs and metadata type.
   * 
   * @param request - QueryAppMetadataRequest
   * @returns QueryAppMetadataResponse
   */
  async queryAppMetadata(request: QueryAppMetadataRequest): Promise<QueryAppMetadataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryAppMetadataWithOptions(request, runtime);
  }

  /**
   * 查询应用拓扑
   * 
   * @param tmpReq - QueryAppTopologyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryAppTopologyResponse
   */
  async queryAppTopologyWithOptions(tmpReq: QueryAppTopologyRequest, runtime: $Util.RuntimeOptions): Promise<QueryAppTopologyResponse> {
    Util.validateModel(tmpReq);
    let request = new QueryAppTopologyShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.filters)) {
      request.filtersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filters, "Filters", "json");
    }

    let query = { };
    if (!Util.isUnset(request.appType)) {
      query["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.db)) {
      query["Db"] = request.db;
    }

    if (!Util.isUnset(request.dbName)) {
      query["DbName"] = request.dbName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.filtersShrink)) {
      query["Filters"] = request.filtersShrink;
    }

    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.rpc)) {
      query["Rpc"] = request.rpc;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryAppTopology",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<QueryAppTopologyResponse>(await this.callApi(params, req, runtime), new QueryAppTopologyResponse({}));
    } else {
      return $tea.cast<QueryAppTopologyResponse>(await this.execute(params, req, runtime), new QueryAppTopologyResponse({}));
    }

  }

  /**
   * 查询应用拓扑
   * 
   * @param request - QueryAppTopologyRequest
   * @returns QueryAppTopologyResponse
   */
  async queryAppTopology(request: QueryAppTopologyRequest): Promise<QueryAppTopologyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryAppTopologyWithOptions(request, runtime);
  }

  /**
   * Queries the amount of data written to Application Monitoring, Managed Service for OpenTelemetry, Managed Service for Prometheus, and Real User Monitoring (RUM).
   * 
   * @param request - QueryCommercialUsageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryCommercialUsageResponse
   */
  async queryCommercialUsageWithOptions(request: QueryCommercialUsageRequest, runtime: $Util.RuntimeOptions): Promise<QueryCommercialUsageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.advancedFilters)) {
      query["AdvancedFilters"] = request.advancedFilters;
    }

    if (!Util.isUnset(request.dimensions)) {
      query["Dimensions"] = request.dimensions;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.intervalInSec)) {
      query["IntervalInSec"] = request.intervalInSec;
    }

    if (!Util.isUnset(request.measures)) {
      query["Measures"] = request.measures;
    }

    if (!Util.isUnset(request.metric)) {
      query["Metric"] = request.metric;
    }

    if (!Util.isUnset(request.order)) {
      query["Order"] = request.order;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["OrderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.queryType)) {
      query["QueryType"] = request.queryType;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryCommercialUsage",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<QueryCommercialUsageResponse>(await this.callApi(params, req, runtime), new QueryCommercialUsageResponse({}));
    } else {
      return $tea.cast<QueryCommercialUsageResponse>(await this.execute(params, req, runtime), new QueryCommercialUsageResponse({}));
    }

  }

  /**
   * Queries the amount of data written to Application Monitoring, Managed Service for OpenTelemetry, Managed Service for Prometheus, and Real User Monitoring (RUM).
   * 
   * @param request - QueryCommercialUsageRequest
   * @returns QueryCommercialUsageResponse
   */
  async queryCommercialUsage(request: QueryCommercialUsageRequest): Promise<QueryCommercialUsageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryCommercialUsageWithOptions(request, runtime);
  }

  /**
   * Queries an Application Monitoring metric or a Browser Monitoring metric.
   * 
   * @param request - QueryMetricByPageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryMetricByPageResponse
   */
  async queryMetricByPageWithOptions(request: QueryMetricByPageRequest, runtime: $Util.RuntimeOptions): Promise<QueryMetricByPageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.customFilters)) {
      query["CustomFilters"] = request.customFilters;
    }

    if (!Util.isUnset(request.dimensions)) {
      query["Dimensions"] = request.dimensions;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.filters)) {
      query["Filters"] = request.filters;
    }

    if (!Util.isUnset(request.intervalInSec)) {
      query["IntervalInSec"] = request.intervalInSec;
    }

    if (!Util.isUnset(request.measures)) {
      query["Measures"] = request.measures;
    }

    if (!Util.isUnset(request.metric)) {
      query["Metric"] = request.metric;
    }

    if (!Util.isUnset(request.order)) {
      query["Order"] = request.order;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["OrderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryMetricByPage",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<QueryMetricByPageResponse>(await this.callApi(params, req, runtime), new QueryMetricByPageResponse({}));
    } else {
      return $tea.cast<QueryMetricByPageResponse>(await this.execute(params, req, runtime), new QueryMetricByPageResponse({}));
    }

  }

  /**
   * Queries an Application Monitoring metric or a Browser Monitoring metric.
   * 
   * @param request - QueryMetricByPageRequest
   * @returns QueryMetricByPageResponse
   */
  async queryMetricByPage(request: QueryMetricByPageRequest): Promise<QueryMetricByPageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryMetricByPageWithOptions(request, runtime);
  }

  /**
   * Queries whether the Prometheus agent is installed on a cluster.
   * 
   * @param request - QueryPromInstallStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryPromInstallStatusResponse
   */
  async queryPromInstallStatusWithOptions(request: QueryPromInstallStatusRequest, runtime: $Util.RuntimeOptions): Promise<QueryPromInstallStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryPromInstallStatus",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<QueryPromInstallStatusResponse>(await this.callApi(params, req, runtime), new QueryPromInstallStatusResponse({}));
    } else {
      return $tea.cast<QueryPromInstallStatusResponse>(await this.execute(params, req, runtime), new QueryPromInstallStatusResponse({}));
    }

  }

  /**
   * Queries whether the Prometheus agent is installed on a cluster.
   * 
   * @param request - QueryPromInstallStatusRequest
   * @returns QueryPromInstallStatusResponse
   */
  async queryPromInstallStatus(request: QueryPromInstallStatusRequest): Promise<QueryPromInstallStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryPromInstallStatusWithOptions(request, runtime);
  }

  /**
   * Queries the metrics that are provided for different versions of a specified Enterprise Distributed Application Service (EDAS) or Kubernetes application.
   * 
   * @param request - QueryReleaseMetricRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryReleaseMetricResponse
   */
  async queryReleaseMetricWithOptions(request: QueryReleaseMetricRequest, runtime: $Util.RuntimeOptions): Promise<QueryReleaseMetricResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.changeOrderId)) {
      query["ChangeOrderId"] = request.changeOrderId;
    }

    if (!Util.isUnset(request.createTime)) {
      query["CreateTime"] = request.createTime;
    }

    if (!Util.isUnset(request.metricType)) {
      query["MetricType"] = request.metricType;
    }

    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    if (!Util.isUnset(request.proxyUserId)) {
      query["ProxyUserId"] = request.proxyUserId;
    }

    if (!Util.isUnset(request.releaseEndTime)) {
      query["ReleaseEndTime"] = request.releaseEndTime;
    }

    if (!Util.isUnset(request.releaseStartTime)) {
      query["ReleaseStartTime"] = request.releaseStartTime;
    }

    if (!Util.isUnset(request.service)) {
      query["Service"] = request.service;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryReleaseMetric",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<QueryReleaseMetricResponse>(await this.callApi(params, req, runtime), new QueryReleaseMetricResponse({}));
    } else {
      return $tea.cast<QueryReleaseMetricResponse>(await this.execute(params, req, runtime), new QueryReleaseMetricResponse({}));
    }

  }

  /**
   * Queries the metrics that are provided for different versions of a specified Enterprise Distributed Application Service (EDAS) or Kubernetes application.
   * 
   * @param request - QueryReleaseMetricRequest
   * @returns QueryReleaseMetricResponse
   */
  async queryReleaseMetric(request: QueryReleaseMetricRequest): Promise<QueryReleaseMetricResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryReleaseMetricWithOptions(request, runtime);
  }

  /**
   * Removes data sources from a global aggregation instance.
   * 
   * @param request - RemoveAliClusterIdsFromPrometheusGlobalViewRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RemoveAliClusterIdsFromPrometheusGlobalViewResponse
   */
  async removeAliClusterIdsFromPrometheusGlobalViewWithOptions(request: RemoveAliClusterIdsFromPrometheusGlobalViewRequest, runtime: $Util.RuntimeOptions): Promise<RemoveAliClusterIdsFromPrometheusGlobalViewResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterIds)) {
      query["ClusterIds"] = request.clusterIds;
    }

    if (!Util.isUnset(request.globalViewClusterId)) {
      query["GlobalViewClusterId"] = request.globalViewClusterId;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RemoveAliClusterIdsFromPrometheusGlobalView",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<RemoveAliClusterIdsFromPrometheusGlobalViewResponse>(await this.callApi(params, req, runtime), new RemoveAliClusterIdsFromPrometheusGlobalViewResponse({}));
    } else {
      return $tea.cast<RemoveAliClusterIdsFromPrometheusGlobalViewResponse>(await this.execute(params, req, runtime), new RemoveAliClusterIdsFromPrometheusGlobalViewResponse({}));
    }

  }

  /**
   * Removes data sources from a global aggregation instance.
   * 
   * @param request - RemoveAliClusterIdsFromPrometheusGlobalViewRequest
   * @returns RemoveAliClusterIdsFromPrometheusGlobalViewResponse
   */
  async removeAliClusterIdsFromPrometheusGlobalView(request: RemoveAliClusterIdsFromPrometheusGlobalViewRequest): Promise<RemoveAliClusterIdsFromPrometheusGlobalViewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removeAliClusterIdsFromPrometheusGlobalViewWithOptions(request, runtime);
  }

  /**
   * Removes custom data sources from a global aggregation instance in Prometheus Service.
   * 
   * @param request - RemoveSourcesFromPrometheusGlobalViewRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RemoveSourcesFromPrometheusGlobalViewResponse
   */
  async removeSourcesFromPrometheusGlobalViewWithOptions(request: RemoveSourcesFromPrometheusGlobalViewRequest, runtime: $Util.RuntimeOptions): Promise<RemoveSourcesFromPrometheusGlobalViewResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.globalViewClusterId)) {
      query["GlobalViewClusterId"] = request.globalViewClusterId;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.sourceNames)) {
      query["SourceNames"] = request.sourceNames;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RemoveSourcesFromPrometheusGlobalView",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<RemoveSourcesFromPrometheusGlobalViewResponse>(await this.callApi(params, req, runtime), new RemoveSourcesFromPrometheusGlobalViewResponse({}));
    } else {
      return $tea.cast<RemoveSourcesFromPrometheusGlobalViewResponse>(await this.execute(params, req, runtime), new RemoveSourcesFromPrometheusGlobalViewResponse({}));
    }

  }

  /**
   * Removes custom data sources from a global aggregation instance in Prometheus Service.
   * 
   * @param request - RemoveSourcesFromPrometheusGlobalViewRequest
   * @returns RemoveSourcesFromPrometheusGlobalViewResponse
   */
  async removeSourcesFromPrometheusGlobalView(request: RemoveSourcesFromPrometheusGlobalViewRequest): Promise<RemoveSourcesFromPrometheusGlobalViewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removeSourcesFromPrometheusGlobalViewWithOptions(request, runtime);
  }

  /**
   * Restarts a feature.
   * 
   * @param request - RestartEnvironmentFeatureRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RestartEnvironmentFeatureResponse
   */
  async restartEnvironmentFeatureWithOptions(request: RestartEnvironmentFeatureRequest, runtime: $Util.RuntimeOptions): Promise<RestartEnvironmentFeatureResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.featureName)) {
      query["FeatureName"] = request.featureName;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RestartEnvironmentFeature",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<RestartEnvironmentFeatureResponse>(await this.callApi(params, req, runtime), new RestartEnvironmentFeatureResponse({}));
    } else {
      return $tea.cast<RestartEnvironmentFeatureResponse>(await this.execute(params, req, runtime), new RestartEnvironmentFeatureResponse({}));
    }

  }

  /**
   * Restarts a feature.
   * 
   * @param request - RestartEnvironmentFeatureRequest
   * @returns RestartEnvironmentFeatureResponse
   */
  async restartEnvironmentFeature(request: RestartEnvironmentFeatureRequest): Promise<RestartEnvironmentFeatureResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.restartEnvironmentFeatureWithOptions(request, runtime);
  }

  /**
   * Modifies the settings of Application Monitoring, such as trace sampling and agent switch settings.
   * 
   * @param request - SaveTraceAppConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SaveTraceAppConfigResponse
   */
  async saveTraceAppConfigWithOptions(request: SaveTraceAppConfigRequest, runtime: $Util.RuntimeOptions): Promise<SaveTraceAppConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    if (!Util.isUnset(request.settings)) {
      query["Settings"] = request.settings;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SaveTraceAppConfig",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<SaveTraceAppConfigResponse>(await this.callApi(params, req, runtime), new SaveTraceAppConfigResponse({}));
    } else {
      return $tea.cast<SaveTraceAppConfigResponse>(await this.execute(params, req, runtime), new SaveTraceAppConfigResponse({}));
    }

  }

  /**
   * Modifies the settings of Application Monitoring, such as trace sampling and agent switch settings.
   * 
   * @param request - SaveTraceAppConfigRequest
   * @returns SaveTraceAppConfigResponse
   */
  async saveTraceAppConfig(request: SaveTraceAppConfigRequest): Promise<SaveTraceAppConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.saveTraceAppConfigWithOptions(request, runtime);
  }

  /**
   * Queries alert contacts.
   * 
   * @remarks
   * This operation is no longer maintained. To query alert contacts, call the DescribeContacts operation provided by the new version of Alert Management.
   * 
   * @param request - SearchAlertContactRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SearchAlertContactResponse
   */
  async searchAlertContactWithOptions(request: SearchAlertContactRequest, runtime: $Util.RuntimeOptions): Promise<SearchAlertContactResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contactIds)) {
      query["ContactIds"] = request.contactIds;
    }

    if (!Util.isUnset(request.contactName)) {
      query["ContactName"] = request.contactName;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.email)) {
      query["Email"] = request.email;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.phone)) {
      query["Phone"] = request.phone;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SearchAlertContact",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<SearchAlertContactResponse>(await this.callApi(params, req, runtime), new SearchAlertContactResponse({}));
    } else {
      return $tea.cast<SearchAlertContactResponse>(await this.execute(params, req, runtime), new SearchAlertContactResponse({}));
    }

  }

  /**
   * Queries alert contacts.
   * 
   * @remarks
   * This operation is no longer maintained. To query alert contacts, call the DescribeContacts operation provided by the new version of Alert Management.
   * 
   * @param request - SearchAlertContactRequest
   * @returns SearchAlertContactResponse
   */
  async searchAlertContact(request: SearchAlertContactRequest): Promise<SearchAlertContactResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchAlertContactWithOptions(request, runtime);
  }

  /**
   * Queries alert contact groups.
   * 
   * @remarks
   * The operation is no longer maintained. Call the DescribeContactGroups operation in the alert management module to query alert contact groups.
   * 
   * @param request - SearchAlertContactGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SearchAlertContactGroupResponse
   */
  async searchAlertContactGroupWithOptions(request: SearchAlertContactGroupRequest, runtime: $Util.RuntimeOptions): Promise<SearchAlertContactGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contactGroupIds)) {
      query["ContactGroupIds"] = request.contactGroupIds;
    }

    if (!Util.isUnset(request.contactGroupName)) {
      query["ContactGroupName"] = request.contactGroupName;
    }

    if (!Util.isUnset(request.contactId)) {
      query["ContactId"] = request.contactId;
    }

    if (!Util.isUnset(request.contactName)) {
      query["ContactName"] = request.contactName;
    }

    if (!Util.isUnset(request.isDetail)) {
      query["IsDetail"] = request.isDetail;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SearchAlertContactGroup",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<SearchAlertContactGroupResponse>(await this.callApi(params, req, runtime), new SearchAlertContactGroupResponse({}));
    } else {
      return $tea.cast<SearchAlertContactGroupResponse>(await this.execute(params, req, runtime), new SearchAlertContactGroupResponse({}));
    }

  }

  /**
   * Queries alert contact groups.
   * 
   * @remarks
   * The operation is no longer maintained. Call the DescribeContactGroups operation in the alert management module to query alert contact groups.
   * 
   * @param request - SearchAlertContactGroupRequest
   * @returns SearchAlertContactGroupResponse
   */
  async searchAlertContactGroup(request: SearchAlertContactGroupRequest): Promise<SearchAlertContactGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchAlertContactGroupWithOptions(request, runtime);
  }

  /**
   * Queries the alert records of an alert rule.
   * 
   * @remarks
   * This operation is no longer maintained. To query alert records, call the ListAlerts operation provided by the new version of Alert Management.
   * 
   * @param request - SearchAlertHistoriesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SearchAlertHistoriesResponse
   */
  async searchAlertHistoriesWithOptions(request: SearchAlertHistoriesRequest, runtime: $Util.RuntimeOptions): Promise<SearchAlertHistoriesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertId)) {
      query["AlertId"] = request.alertId;
    }

    if (!Util.isUnset(request.alertType)) {
      query["AlertType"] = request.alertType;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SearchAlertHistories",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<SearchAlertHistoriesResponse>(await this.callApi(params, req, runtime), new SearchAlertHistoriesResponse({}));
    } else {
      return $tea.cast<SearchAlertHistoriesResponse>(await this.execute(params, req, runtime), new SearchAlertHistoriesResponse({}));
    }

  }

  /**
   * Queries the alert records of an alert rule.
   * 
   * @remarks
   * This operation is no longer maintained. To query alert records, call the ListAlerts operation provided by the new version of Alert Management.
   * 
   * @param request - SearchAlertHistoriesRequest
   * @returns SearchAlertHistoriesResponse
   */
  async searchAlertHistories(request: SearchAlertHistoriesRequest): Promise<SearchAlertHistoriesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchAlertHistoriesWithOptions(request, runtime);
  }

  /**
   * Queries alert rules.
   * 
   * @remarks
   * The current operation is no longer maintained. You can call the GetAlertRules operation of Alert Management (New) to query existing alert rules.
   * 
   * @param request - SearchAlertRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SearchAlertRulesResponse
   */
  async searchAlertRulesWithOptions(request: SearchAlertRulesRequest, runtime: $Util.RuntimeOptions): Promise<SearchAlertRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertRuleId)) {
      query["AlertRuleId"] = request.alertRuleId;
    }

    if (!Util.isUnset(request.appType)) {
      query["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.systemRegionId)) {
      query["SystemRegionId"] = request.systemRegionId;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    if (!Util.isUnset(request.title)) {
      query["Title"] = request.title;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SearchAlertRules",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<SearchAlertRulesResponse>(await this.callApi(params, req, runtime), new SearchAlertRulesResponse({}));
    } else {
      return $tea.cast<SearchAlertRulesResponse>(await this.execute(params, req, runtime), new SearchAlertRulesResponse({}));
    }

  }

  /**
   * Queries alert rules.
   * 
   * @remarks
   * The current operation is no longer maintained. You can call the GetAlertRules operation of Alert Management (New) to query existing alert rules.
   * 
   * @param request - SearchAlertRulesRequest
   * @returns SearchAlertRulesResponse
   */
  async searchAlertRules(request: SearchAlertRulesRequest): Promise<SearchAlertRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchAlertRulesWithOptions(request, runtime);
  }

  /**
   * Queries alert event records.
   * 
   * @remarks
   * Alert event records are different from alert notification records. Alert events are recorded every minute after an alert rule filters data. Alert events can be classified based on whether they are triggered or not. If a triggered event is not in the silence period, an alert notification is sent.
   * 
   * @param request - SearchEventsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SearchEventsResponse
   */
  async searchEventsWithOptions(request: SearchEventsRequest, runtime: $Util.RuntimeOptions): Promise<SearchEventsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertId)) {
      query["AlertId"] = request.alertId;
    }

    if (!Util.isUnset(request.alertType)) {
      query["AlertType"] = request.alertType;
    }

    if (!Util.isUnset(request.appType)) {
      query["AppType"] = request.appType;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.isTrigger)) {
      query["IsTrigger"] = request.isTrigger;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SearchEvents",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<SearchEventsResponse>(await this.callApi(params, req, runtime), new SearchEventsResponse({}));
    } else {
      return $tea.cast<SearchEventsResponse>(await this.execute(params, req, runtime), new SearchEventsResponse({}));
    }

  }

  /**
   * Queries alert event records.
   * 
   * @remarks
   * Alert event records are different from alert notification records. Alert events are recorded every minute after an alert rule filters data. Alert events can be classified based on whether they are triggered or not. If a triggered event is not in the silence period, an alert notification is sent.
   * 
   * @param request - SearchEventsRequest
   * @returns SearchEventsResponse
   */
  async searchEvents(request: SearchEventsRequest): Promise<SearchEventsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchEventsWithOptions(request, runtime);
  }

  /**
   * Queries Browser Monitoring tasks by page.
   * 
   * @param request - SearchRetcodeAppByPageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SearchRetcodeAppByPageResponse
   */
  async searchRetcodeAppByPageWithOptions(request: SearchRetcodeAppByPageRequest, runtime: $Util.RuntimeOptions): Promise<SearchRetcodeAppByPageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.retcodeAppId)) {
      query["RetcodeAppId"] = request.retcodeAppId;
    }

    if (!Util.isUnset(request.retcodeAppName)) {
      query["RetcodeAppName"] = request.retcodeAppName;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SearchRetcodeAppByPage",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<SearchRetcodeAppByPageResponse>(await this.callApi(params, req, runtime), new SearchRetcodeAppByPageResponse({}));
    } else {
      return $tea.cast<SearchRetcodeAppByPageResponse>(await this.execute(params, req, runtime), new SearchRetcodeAppByPageResponse({}));
    }

  }

  /**
   * Queries Browser Monitoring tasks by page.
   * 
   * @param request - SearchRetcodeAppByPageRequest
   * @returns SearchRetcodeAppByPageResponse
   */
  async searchRetcodeAppByPage(request: SearchRetcodeAppByPageRequest): Promise<SearchRetcodeAppByPageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchRetcodeAppByPageWithOptions(request, runtime);
  }

  /**
   * Queries Application Monitoring tasks by application name.
   * 
   * @param request - SearchTraceAppByNameRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SearchTraceAppByNameResponse
   */
  async searchTraceAppByNameWithOptions(request: SearchTraceAppByNameRequest, runtime: $Util.RuntimeOptions): Promise<SearchTraceAppByNameResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    if (!Util.isUnset(request.traceAppName)) {
      query["TraceAppName"] = request.traceAppName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SearchTraceAppByName",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<SearchTraceAppByNameResponse>(await this.callApi(params, req, runtime), new SearchTraceAppByNameResponse({}));
    } else {
      return $tea.cast<SearchTraceAppByNameResponse>(await this.execute(params, req, runtime), new SearchTraceAppByNameResponse({}));
    }

  }

  /**
   * Queries Application Monitoring tasks by application name.
   * 
   * @param request - SearchTraceAppByNameRequest
   * @returns SearchTraceAppByNameResponse
   */
  async searchTraceAppByName(request: SearchTraceAppByNameRequest): Promise<SearchTraceAppByNameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchTraceAppByNameWithOptions(request, runtime);
  }

  /**
   * Queries application monitoring tasks by page.
   * 
   * @param request - SearchTraceAppByPageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SearchTraceAppByPageResponse
   */
  async searchTraceAppByPageWithOptions(request: SearchTraceAppByPageRequest, runtime: $Util.RuntimeOptions): Promise<SearchTraceAppByPageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    if (!Util.isUnset(request.traceAppName)) {
      query["TraceAppName"] = request.traceAppName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SearchTraceAppByPage",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<SearchTraceAppByPageResponse>(await this.callApi(params, req, runtime), new SearchTraceAppByPageResponse({}));
    } else {
      return $tea.cast<SearchTraceAppByPageResponse>(await this.execute(params, req, runtime), new SearchTraceAppByPageResponse({}));
    }

  }

  /**
   * Queries application monitoring tasks by page.
   * 
   * @param request - SearchTraceAppByPageRequest
   * @returns SearchTraceAppByPageResponse
   */
  async searchTraceAppByPage(request: SearchTraceAppByPageRequest): Promise<SearchTraceAppByPageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchTraceAppByPageWithOptions(request, runtime);
  }

  /**
   * Queries traces by time, application name, IP address, span name, and tag.
   * 
   * @remarks
   * > A maximum of 100 data entries can be returned each time this operation is called. If you want to query all existing traces, we recommend that you call the SearchTracesByPage operation. For more information, see [SearchTracesByPage](https://help.aliyun.com/document_detail/175866.html).
   * 
   * @param request - SearchTracesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SearchTracesResponse
   */
  async searchTracesWithOptions(request: SearchTracesRequest, runtime: $Util.RuntimeOptions): Promise<SearchTracesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.exclusionFilters)) {
      query["ExclusionFilters"] = request.exclusionFilters;
    }

    if (!Util.isUnset(request.minDuration)) {
      query["MinDuration"] = request.minDuration;
    }

    if (!Util.isUnset(request.operationName)) {
      query["OperationName"] = request.operationName;
    }

    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.reverse)) {
      query["Reverse"] = request.reverse;
    }

    if (!Util.isUnset(request.serviceIp)) {
      query["ServiceIp"] = request.serviceIp;
    }

    if (!Util.isUnset(request.serviceName)) {
      query["ServiceName"] = request.serviceName;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SearchTraces",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<SearchTracesResponse>(await this.callApi(params, req, runtime), new SearchTracesResponse({}));
    } else {
      return $tea.cast<SearchTracesResponse>(await this.execute(params, req, runtime), new SearchTracesResponse({}));
    }

  }

  /**
   * Queries traces by time, application name, IP address, span name, and tag.
   * 
   * @remarks
   * > A maximum of 100 data entries can be returned each time this operation is called. If you want to query all existing traces, we recommend that you call the SearchTracesByPage operation. For more information, see [SearchTracesByPage](https://help.aliyun.com/document_detail/175866.html).
   * 
   * @param request - SearchTracesRequest
   * @returns SearchTracesResponse
   */
  async searchTraces(request: SearchTracesRequest): Promise<SearchTracesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchTracesWithOptions(request, runtime);
  }

  /**
   * Queries traces by page. You can query traces by time range, application name, IP address, span name, or tag.
   * 
   * @param request - SearchTracesByPageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SearchTracesByPageResponse
   */
  async searchTracesByPageWithOptions(request: SearchTracesByPageRequest, runtime: $Util.RuntimeOptions): Promise<SearchTracesByPageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.exclusionFilters)) {
      query["ExclusionFilters"] = request.exclusionFilters;
    }

    if (!Util.isUnset(request.isError)) {
      query["IsError"] = request.isError;
    }

    if (!Util.isUnset(request.minDuration)) {
      query["MinDuration"] = request.minDuration;
    }

    if (!Util.isUnset(request.operationName)) {
      query["OperationName"] = request.operationName;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.reverse)) {
      query["Reverse"] = request.reverse;
    }

    if (!Util.isUnset(request.serviceIp)) {
      query["ServiceIp"] = request.serviceIp;
    }

    if (!Util.isUnset(request.serviceName)) {
      query["ServiceName"] = request.serviceName;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SearchTracesByPage",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<SearchTracesByPageResponse>(await this.callApi(params, req, runtime), new SearchTracesByPageResponse({}));
    } else {
      return $tea.cast<SearchTracesByPageResponse>(await this.execute(params, req, runtime), new SearchTracesByPageResponse({}));
    }

  }

  /**
   * Queries traces by page. You can query traces by time range, application name, IP address, span name, or tag.
   * 
   * @param request - SearchTracesByPageRequest
   * @returns SearchTracesByPageResponse
   */
  async searchTracesByPage(request: SearchTracesByPageRequest): Promise<SearchTracesByPageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchTracesByPageWithOptions(request, runtime);
  }

  /**
   * Sends a text message to an alert contact to verify the mobile number of the alert contact.
   * 
   * @remarks
   * After you receive the text message, verify the mobile number as prompted. Before you can specify a mobile phone number in a notification policy, you must verify the mobile phone number.
   * 
   * @param request - SendTTSVerifyLinkRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SendTTSVerifyLinkResponse
   */
  async sendTTSVerifyLinkWithOptions(request: SendTTSVerifyLinkRequest, runtime: $Util.RuntimeOptions): Promise<SendTTSVerifyLinkResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.contactId)) {
      body["ContactId"] = request.contactId;
    }

    if (!Util.isUnset(request.phone)) {
      body["Phone"] = request.phone;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SendTTSVerifyLink",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<SendTTSVerifyLinkResponse>(await this.callApi(params, req, runtime), new SendTTSVerifyLinkResponse({}));
    } else {
      return $tea.cast<SendTTSVerifyLinkResponse>(await this.execute(params, req, runtime), new SendTTSVerifyLinkResponse({}));
    }

  }

  /**
   * Sends a text message to an alert contact to verify the mobile number of the alert contact.
   * 
   * @remarks
   * After you receive the text message, verify the mobile number as prompted. Before you can specify a mobile phone number in a notification policy, you must verify the mobile phone number.
   * 
   * @param request - SendTTSVerifyLinkRequest
   * @returns SendTTSVerifyLinkResponse
   */
  async sendTTSVerifyLink(request: SendTTSVerifyLinkRequest): Promise<SendTTSVerifyLinkResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.sendTTSVerifyLinkWithOptions(request, runtime);
  }

  /**
   * Turns on or turns off logon-free sharing for an application monitored by Browser Monitoring.
   * 
   * @param request - SetRetcodeShareStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetRetcodeShareStatusResponse
   */
  async setRetcodeShareStatusWithOptions(request: SetRetcodeShareStatusRequest, runtime: $Util.RuntimeOptions): Promise<SetRetcodeShareStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetRetcodeShareStatus",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<SetRetcodeShareStatusResponse>(await this.callApi(params, req, runtime), new SetRetcodeShareStatusResponse({}));
    } else {
      return $tea.cast<SetRetcodeShareStatusResponse>(await this.execute(params, req, runtime), new SetRetcodeShareStatusResponse({}));
    }

  }

  /**
   * Turns on or turns off logon-free sharing for an application monitored by Browser Monitoring.
   * 
   * @param request - SetRetcodeShareStatusRequest
   * @returns SetRetcodeShareStatusResponse
   */
  async setRetcodeShareStatus(request: SetRetcodeShareStatusRequest): Promise<SetRetcodeShareStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setRetcodeShareStatusWithOptions(request, runtime);
  }

  /**
   * @param request - StartAlertRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StartAlertResponse
   */
  async startAlertWithOptions(request: StartAlertRequest, runtime: $Util.RuntimeOptions): Promise<StartAlertResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertId)) {
      query["AlertId"] = request.alertId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StartAlert",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<StartAlertResponse>(await this.callApi(params, req, runtime), new StartAlertResponse({}));
    } else {
      return $tea.cast<StartAlertResponse>(await this.execute(params, req, runtime), new StartAlertResponse({}));
    }

  }

  /**
   * @param request - StartAlertRequest
   * @returns StartAlertResponse
   */
  async startAlert(request: StartAlertRequest): Promise<StartAlertResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startAlertWithOptions(request, runtime);
  }

  /**
   * Starts scheduled synthetic monitoring tasks.
   * 
   * @param tmpReq - StartTimingSyntheticTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StartTimingSyntheticTaskResponse
   */
  async startTimingSyntheticTaskWithOptions(tmpReq: StartTimingSyntheticTaskRequest, runtime: $Util.RuntimeOptions): Promise<StartTimingSyntheticTaskResponse> {
    Util.validateModel(tmpReq);
    let request = new StartTimingSyntheticTaskShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.taskIds)) {
      request.taskIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.taskIds, "TaskIds", "json");
    }

    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.taskIdsShrink)) {
      query["TaskIds"] = request.taskIdsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StartTimingSyntheticTask",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<StartTimingSyntheticTaskResponse>(await this.callApi(params, req, runtime), new StartTimingSyntheticTaskResponse({}));
    } else {
      return $tea.cast<StartTimingSyntheticTaskResponse>(await this.execute(params, req, runtime), new StartTimingSyntheticTaskResponse({}));
    }

  }

  /**
   * Starts scheduled synthetic monitoring tasks.
   * 
   * @param request - StartTimingSyntheticTaskRequest
   * @returns StartTimingSyntheticTaskResponse
   */
  async startTimingSyntheticTask(request: StartTimingSyntheticTaskRequest): Promise<StartTimingSyntheticTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startTimingSyntheticTaskWithOptions(request, runtime);
  }

  /**
   * Call StartAlert to stop an alert rule.
   * 
   * @param request - StopAlertRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StopAlertResponse
   */
  async stopAlertWithOptions(request: StopAlertRequest, runtime: $Util.RuntimeOptions): Promise<StopAlertResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertId)) {
      query["AlertId"] = request.alertId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StopAlert",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<StopAlertResponse>(await this.callApi(params, req, runtime), new StopAlertResponse({}));
    } else {
      return $tea.cast<StopAlertResponse>(await this.execute(params, req, runtime), new StopAlertResponse({}));
    }

  }

  /**
   * Call StartAlert to stop an alert rule.
   * 
   * @param request - StopAlertRequest
   * @returns StopAlertResponse
   */
  async stopAlert(request: StopAlertRequest): Promise<StopAlertResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopAlertWithOptions(request, runtime);
  }

  /**
   * Stops scheduled synthetic monitoring tasks.
   * 
   * @param tmpReq - StopTimingSyntheticTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StopTimingSyntheticTaskResponse
   */
  async stopTimingSyntheticTaskWithOptions(tmpReq: StopTimingSyntheticTaskRequest, runtime: $Util.RuntimeOptions): Promise<StopTimingSyntheticTaskResponse> {
    Util.validateModel(tmpReq);
    let request = new StopTimingSyntheticTaskShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.taskIds)) {
      request.taskIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.taskIds, "TaskIds", "json");
    }

    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.taskIdsShrink)) {
      query["TaskIds"] = request.taskIdsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StopTimingSyntheticTask",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<StopTimingSyntheticTaskResponse>(await this.callApi(params, req, runtime), new StopTimingSyntheticTaskResponse({}));
    } else {
      return $tea.cast<StopTimingSyntheticTaskResponse>(await this.execute(params, req, runtime), new StopTimingSyntheticTaskResponse({}));
    }

  }

  /**
   * Stops scheduled synthetic monitoring tasks.
   * 
   * @param request - StopTimingSyntheticTaskRequest
   * @returns StopTimingSyntheticTaskResponse
   */
  async stopTimingSyntheticTask(request: StopTimingSyntheticTaskRequest): Promise<StopTimingSyntheticTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopTimingSyntheticTaskWithOptions(request, runtime);
  }

  /**
   * Starts or stops a scheduled synthetic monitoring task.
   * 
   * @param request - SwitchSyntheticTaskStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SwitchSyntheticTaskStatusResponse
   */
  async switchSyntheticTaskStatusWithOptions(request: SwitchSyntheticTaskStatusRequest, runtime: $Util.RuntimeOptions): Promise<SwitchSyntheticTaskStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.switchStatus)) {
      query["SwitchStatus"] = request.switchStatus;
    }

    if (!Util.isUnset(request.taskIds)) {
      query["TaskIds"] = request.taskIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SwitchSyntheticTaskStatus",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<SwitchSyntheticTaskStatusResponse>(await this.callApi(params, req, runtime), new SwitchSyntheticTaskStatusResponse({}));
    } else {
      return $tea.cast<SwitchSyntheticTaskStatusResponse>(await this.execute(params, req, runtime), new SwitchSyntheticTaskStatusResponse({}));
    }

  }

  /**
   * Starts or stops a scheduled synthetic monitoring task.
   * 
   * @param request - SwitchSyntheticTaskStatusRequest
   * @returns SwitchSyntheticTaskStatusResponse
   */
  async switchSyntheticTaskStatus(request: SwitchSyntheticTaskStatusRequest): Promise<SwitchSyntheticTaskStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.switchSyntheticTaskStatusWithOptions(request, runtime);
  }

  /**
   * Synchronizes the aggregation rule of a cluster to other clusters in a region.
   * 
   * @param request - SyncRecordingRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SyncRecordingRulesResponse
   */
  async syncRecordingRulesWithOptions(request: SyncRecordingRulesRequest, runtime: $Util.RuntimeOptions): Promise<SyncRecordingRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.targetClusters)) {
      query["TargetClusters"] = request.targetClusters;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SyncRecordingRules",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<SyncRecordingRulesResponse>(await this.callApi(params, req, runtime), new SyncRecordingRulesResponse({}));
    } else {
      return $tea.cast<SyncRecordingRulesResponse>(await this.execute(params, req, runtime), new SyncRecordingRulesResponse({}));
    }

  }

  /**
   * Synchronizes the aggregation rule of a cluster to other clusters in a region.
   * 
   * @param request - SyncRecordingRulesRequest
   * @returns SyncRecordingRulesResponse
   */
  async syncRecordingRules(request: SyncRecordingRulesRequest): Promise<SyncRecordingRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.syncRecordingRulesWithOptions(request, runtime);
  }

  /**
   * Adds tags to ARMS resources.
   * 
   * @param request - TagResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns TagResourcesResponse
   */
  async tagResourcesWithOptions(request: TagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<TagResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "TagResources",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<TagResourcesResponse>(await this.callApi(params, req, runtime), new TagResourcesResponse({}));
    } else {
      return $tea.cast<TagResourcesResponse>(await this.execute(params, req, runtime), new TagResourcesResponse({}));
    }

  }

  /**
   * Adds tags to ARMS resources.
   * 
   * @param request - TagResourcesRequest
   * @returns TagResourcesResponse
   */
  async tagResources(request: TagResourcesRequest): Promise<TagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.tagResourcesWithOptions(request, runtime);
  }

  /**
   * Uninstalls a managed Prometheus agent for a serverless Kubernetes (ASK) cluster, Distributed Cloud Container Platform for Kubernetes (ACK One) cluster, or Elastic Compute Service (ECS) cluster.
   * 
   * @remarks
   * This operation is available only for ASK, ECS, and ACK One clusters. Before you call this operation, make sure that a managed Prometheus agent is installed for your cluster.
   * 
   * @deprecated OpenAPI UninstallManagedPrometheus is deprecated
   * 
   * @param request - UninstallManagedPrometheusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UninstallManagedPrometheusResponse
   */
  // Deprecated
  async uninstallManagedPrometheusWithOptions(request: UninstallManagedPrometheusRequest, runtime: $Util.RuntimeOptions): Promise<UninstallManagedPrometheusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.clusterType)) {
      query["ClusterType"] = request.clusterType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UninstallManagedPrometheus",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UninstallManagedPrometheusResponse>(await this.callApi(params, req, runtime), new UninstallManagedPrometheusResponse({}));
    } else {
      return $tea.cast<UninstallManagedPrometheusResponse>(await this.execute(params, req, runtime), new UninstallManagedPrometheusResponse({}));
    }

  }

  /**
   * Uninstalls a managed Prometheus agent for a serverless Kubernetes (ASK) cluster, Distributed Cloud Container Platform for Kubernetes (ACK One) cluster, or Elastic Compute Service (ECS) cluster.
   * 
   * @remarks
   * This operation is available only for ASK, ECS, and ACK One clusters. Before you call this operation, make sure that a managed Prometheus agent is installed for your cluster.
   * 
   * @deprecated OpenAPI UninstallManagedPrometheus is deprecated
   * 
   * @param request - UninstallManagedPrometheusRequest
   * @returns UninstallManagedPrometheusResponse
   */
  // Deprecated
  async uninstallManagedPrometheus(request: UninstallManagedPrometheusRequest): Promise<UninstallManagedPrometheusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.uninstallManagedPrometheusWithOptions(request, runtime);
  }

  /**
   * Releases a Prometheus instance.
   * 
   * @param request - UninstallPromClusterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UninstallPromClusterResponse
   */
  async uninstallPromClusterWithOptions(request: UninstallPromClusterRequest, runtime: $Util.RuntimeOptions): Promise<UninstallPromClusterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliyunLang)) {
      query["AliyunLang"] = request.aliyunLang;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UninstallPromCluster",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UninstallPromClusterResponse>(await this.callApi(params, req, runtime), new UninstallPromClusterResponse({}));
    } else {
      return $tea.cast<UninstallPromClusterResponse>(await this.execute(params, req, runtime), new UninstallPromClusterResponse({}));
    }

  }

  /**
   * Releases a Prometheus instance.
   * 
   * @param request - UninstallPromClusterRequest
   * @returns UninstallPromClusterResponse
   */
  async uninstallPromCluster(request: UninstallPromClusterRequest): Promise<UninstallPromClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.uninstallPromClusterWithOptions(request, runtime);
  }

  /**
   * Removes tags from ARMS resources.
   * 
   * @param request - UntagResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UntagResourcesResponse
   */
  async untagResourcesWithOptions(request: UntagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<UntagResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.all)) {
      query["All"] = request.all;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.tagKey)) {
      query["TagKey"] = request.tagKey;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UntagResources",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UntagResourcesResponse>(await this.callApi(params, req, runtime), new UntagResourcesResponse({}));
    } else {
      return $tea.cast<UntagResourcesResponse>(await this.execute(params, req, runtime), new UntagResourcesResponse({}));
    }

  }

  /**
   * Removes tags from ARMS resources.
   * 
   * @param request - UntagResourcesRequest
   * @returns UntagResourcesResponse
   */
  async untagResources(request: UntagResourcesRequest): Promise<UntagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.untagResourcesWithOptions(request, runtime);
  }

  /**
   * Updates an alert contact.
   * 
   * @remarks
   * This operation is no longer maintained. To create or modify an alert contact, call the CreateOrUpdateContact operation provided by the new version of Alert Management.
   * 
   * @param request - UpdateAlertContactRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateAlertContactResponse
   */
  async updateAlertContactWithOptions(request: UpdateAlertContactRequest, runtime: $Util.RuntimeOptions): Promise<UpdateAlertContactResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contactId)) {
      query["ContactId"] = request.contactId;
    }

    if (!Util.isUnset(request.contactName)) {
      query["ContactName"] = request.contactName;
    }

    if (!Util.isUnset(request.dingRobotWebhookUrl)) {
      query["DingRobotWebhookUrl"] = request.dingRobotWebhookUrl;
    }

    if (!Util.isUnset(request.email)) {
      query["Email"] = request.email;
    }

    if (!Util.isUnset(request.phoneNum)) {
      query["PhoneNum"] = request.phoneNum;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.systemNoc)) {
      query["SystemNoc"] = request.systemNoc;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateAlertContact",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UpdateAlertContactResponse>(await this.callApi(params, req, runtime), new UpdateAlertContactResponse({}));
    } else {
      return $tea.cast<UpdateAlertContactResponse>(await this.execute(params, req, runtime), new UpdateAlertContactResponse({}));
    }

  }

  /**
   * Updates an alert contact.
   * 
   * @remarks
   * This operation is no longer maintained. To create or modify an alert contact, call the CreateOrUpdateContact operation provided by the new version of Alert Management.
   * 
   * @param request - UpdateAlertContactRequest
   * @returns UpdateAlertContactResponse
   */
  async updateAlertContact(request: UpdateAlertContactRequest): Promise<UpdateAlertContactResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateAlertContactWithOptions(request, runtime);
  }

  /**
   * Updates UpdateAlertContactGroup alarm contact group.
   * 
   * @param request - UpdateAlertContactGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateAlertContactGroupResponse
   */
  async updateAlertContactGroupWithOptions(request: UpdateAlertContactGroupRequest, runtime: $Util.RuntimeOptions): Promise<UpdateAlertContactGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.contactGroupId)) {
      query["ContactGroupId"] = request.contactGroupId;
    }

    if (!Util.isUnset(request.contactGroupName)) {
      query["ContactGroupName"] = request.contactGroupName;
    }

    if (!Util.isUnset(request.contactIds)) {
      query["ContactIds"] = request.contactIds;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateAlertContactGroup",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UpdateAlertContactGroupResponse>(await this.callApi(params, req, runtime), new UpdateAlertContactGroupResponse({}));
    } else {
      return $tea.cast<UpdateAlertContactGroupResponse>(await this.execute(params, req, runtime), new UpdateAlertContactGroupResponse({}));
    }

  }

  /**
   * Updates UpdateAlertContactGroup alarm contact group.
   * 
   * @param request - UpdateAlertContactGroupRequest
   * @returns UpdateAlertContactGroupResponse
   */
  async updateAlertContactGroup(request: UpdateAlertContactGroupRequest): Promise<UpdateAlertContactGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateAlertContactGroupWithOptions(request, runtime);
  }

  /**
   * @param request - UpdateAlertRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateAlertRuleResponse
   */
  async updateAlertRuleWithOptions(request: UpdateAlertRuleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateAlertRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertId)) {
      query["AlertId"] = request.alertId;
    }

    if (!Util.isUnset(request.contactGroupIds)) {
      query["ContactGroupIds"] = request.contactGroupIds;
    }

    if (!Util.isUnset(request.isAutoStart)) {
      query["IsAutoStart"] = request.isAutoStart;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.templageAlertConfig)) {
      query["TemplageAlertConfig"] = request.templageAlertConfig;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateAlertRule",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UpdateAlertRuleResponse>(await this.callApi(params, req, runtime), new UpdateAlertRuleResponse({}));
    } else {
      return $tea.cast<UpdateAlertRuleResponse>(await this.execute(params, req, runtime), new UpdateAlertRuleResponse({}));
    }

  }

  /**
   * @param request - UpdateAlertRuleRequest
   * @returns UpdateAlertRuleResponse
   */
  async updateAlertRule(request: UpdateAlertRuleRequest): Promise<UpdateAlertRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateAlertRuleWithOptions(request, runtime);
  }

  /**
   * Modifies a dispatch policy.
   * 
   * @param request - UpdateDispatchRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateDispatchRuleResponse
   */
  async updateDispatchRuleWithOptions(request: UpdateDispatchRuleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDispatchRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dispatchRule)) {
      query["DispatchRule"] = request.dispatchRule;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDispatchRule",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UpdateDispatchRuleResponse>(await this.callApi(params, req, runtime), new UpdateDispatchRuleResponse({}));
    } else {
      return $tea.cast<UpdateDispatchRuleResponse>(await this.execute(params, req, runtime), new UpdateDispatchRuleResponse({}));
    }

  }

  /**
   * Modifies a dispatch policy.
   * 
   * @param request - UpdateDispatchRuleRequest
   * @returns UpdateDispatchRuleResponse
   */
  async updateDispatchRule(request: UpdateDispatchRuleRequest): Promise<UpdateDispatchRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDispatchRuleWithOptions(request, runtime);
  }

  /**
   * Updates a custom job for an environment.
   * 
   * @param request - UpdateEnvCustomJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateEnvCustomJobResponse
   */
  async updateEnvCustomJobWithOptions(request: UpdateEnvCustomJobRequest, runtime: $Util.RuntimeOptions): Promise<UpdateEnvCustomJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliyunLang)) {
      query["AliyunLang"] = request.aliyunLang;
    }

    if (!Util.isUnset(request.customJobName)) {
      query["CustomJobName"] = request.customJobName;
    }

    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.configYaml)) {
      body["ConfigYaml"] = request.configYaml;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateEnvCustomJob",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UpdateEnvCustomJobResponse>(await this.callApi(params, req, runtime), new UpdateEnvCustomJobResponse({}));
    } else {
      return $tea.cast<UpdateEnvCustomJobResponse>(await this.execute(params, req, runtime), new UpdateEnvCustomJobResponse({}));
    }

  }

  /**
   * Updates a custom job for an environment.
   * 
   * @param request - UpdateEnvCustomJobRequest
   * @returns UpdateEnvCustomJobResponse
   */
  async updateEnvCustomJob(request: UpdateEnvCustomJobRequest): Promise<UpdateEnvCustomJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateEnvCustomJobWithOptions(request, runtime);
  }

  /**
   * Updates the PodMonitor of an environment.
   * 
   * @param request - UpdateEnvPodMonitorRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateEnvPodMonitorResponse
   */
  async updateEnvPodMonitorWithOptions(request: UpdateEnvPodMonitorRequest, runtime: $Util.RuntimeOptions): Promise<UpdateEnvPodMonitorResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliyunLang)) {
      query["AliyunLang"] = request.aliyunLang;
    }

    if (!Util.isUnset(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.podMonitorName)) {
      query["PodMonitorName"] = request.podMonitorName;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.configYaml)) {
      body["ConfigYaml"] = request.configYaml;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateEnvPodMonitor",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UpdateEnvPodMonitorResponse>(await this.callApi(params, req, runtime), new UpdateEnvPodMonitorResponse({}));
    } else {
      return $tea.cast<UpdateEnvPodMonitorResponse>(await this.execute(params, req, runtime), new UpdateEnvPodMonitorResponse({}));
    }

  }

  /**
   * Updates the PodMonitor of an environment.
   * 
   * @param request - UpdateEnvPodMonitorRequest
   * @returns UpdateEnvPodMonitorResponse
   */
  async updateEnvPodMonitor(request: UpdateEnvPodMonitorRequest): Promise<UpdateEnvPodMonitorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateEnvPodMonitorWithOptions(request, runtime);
  }

  /**
   * Updates the ServiceMonitor of an environment.
   * 
   * @param request - UpdateEnvServiceMonitorRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateEnvServiceMonitorResponse
   */
  async updateEnvServiceMonitorWithOptions(request: UpdateEnvServiceMonitorRequest, runtime: $Util.RuntimeOptions): Promise<UpdateEnvServiceMonitorResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliyunLang)) {
      query["AliyunLang"] = request.aliyunLang;
    }

    if (!Util.isUnset(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.serviceMonitorName)) {
      query["ServiceMonitorName"] = request.serviceMonitorName;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.configYaml)) {
      body["ConfigYaml"] = request.configYaml;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateEnvServiceMonitor",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UpdateEnvServiceMonitorResponse>(await this.callApi(params, req, runtime), new UpdateEnvServiceMonitorResponse({}));
    } else {
      return $tea.cast<UpdateEnvServiceMonitorResponse>(await this.execute(params, req, runtime), new UpdateEnvServiceMonitorResponse({}));
    }

  }

  /**
   * Updates the ServiceMonitor of an environment.
   * 
   * @param request - UpdateEnvServiceMonitorRequest
   * @returns UpdateEnvServiceMonitorResponse
   */
  async updateEnvServiceMonitor(request: UpdateEnvServiceMonitorRequest): Promise<UpdateEnvServiceMonitorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateEnvServiceMonitorWithOptions(request, runtime);
  }

  /**
   * Updates the configuration of an environment.
   * 
   * @param request - UpdateEnvironmentRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateEnvironmentResponse
   */
  async updateEnvironmentWithOptions(request: UpdateEnvironmentRequest, runtime: $Util.RuntimeOptions): Promise<UpdateEnvironmentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliyunLang)) {
      query["AliyunLang"] = request.aliyunLang;
    }

    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.environmentName)) {
      query["EnvironmentName"] = request.environmentName;
    }

    if (!Util.isUnset(request.feePackage)) {
      query["FeePackage"] = request.feePackage;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateEnvironment",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UpdateEnvironmentResponse>(await this.callApi(params, req, runtime), new UpdateEnvironmentResponse({}));
    } else {
      return $tea.cast<UpdateEnvironmentResponse>(await this.execute(params, req, runtime), new UpdateEnvironmentResponse({}));
    }

  }

  /**
   * Updates the configuration of an environment.
   * 
   * @param request - UpdateEnvironmentRequest
   * @returns UpdateEnvironmentResponse
   */
  async updateEnvironment(request: UpdateEnvironmentRequest): Promise<UpdateEnvironmentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateEnvironmentWithOptions(request, runtime);
  }

  /**
   * Updates the information about a Grafana workspace.
   * 
   * @param request - UpdateGrafanaWorkspaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGrafanaWorkspaceResponse
   */
  async updateGrafanaWorkspaceWithOptions(request: UpdateGrafanaWorkspaceRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGrafanaWorkspaceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliyunLang)) {
      query["AliyunLang"] = request.aliyunLang;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.grafanaWorkspaceId)) {
      query["GrafanaWorkspaceId"] = request.grafanaWorkspaceId;
    }

    if (!Util.isUnset(request.grafanaWorkspaceName)) {
      query["GrafanaWorkspaceName"] = request.grafanaWorkspaceName;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGrafanaWorkspace",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UpdateGrafanaWorkspaceResponse>(await this.callApi(params, req, runtime), new UpdateGrafanaWorkspaceResponse({}));
    } else {
      return $tea.cast<UpdateGrafanaWorkspaceResponse>(await this.execute(params, req, runtime), new UpdateGrafanaWorkspaceResponse({}));
    }

  }

  /**
   * Updates the information about a Grafana workspace.
   * 
   * @param request - UpdateGrafanaWorkspaceRequest
   * @returns UpdateGrafanaWorkspaceResponse
   */
  async updateGrafanaWorkspace(request: UpdateGrafanaWorkspaceRequest): Promise<UpdateGrafanaWorkspaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGrafanaWorkspaceWithOptions(request, runtime);
  }

  /**
   * Updates the version of a Grafana workspace.
   * 
   * @remarks
   * Note: The list returned by this operation includes the workspaces of Developer Edition, Expert Edition, and Advanced Edition. The list does not include the workspaces of Shared Edition.
   * 
   * @param request - UpdateGrafanaWorkspaceVersionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateGrafanaWorkspaceVersionResponse
   */
  async updateGrafanaWorkspaceVersionWithOptions(request: UpdateGrafanaWorkspaceVersionRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGrafanaWorkspaceVersionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliyunLang)) {
      query["AliyunLang"] = request.aliyunLang;
    }

    if (!Util.isUnset(request.grafanaVersion)) {
      query["GrafanaVersion"] = request.grafanaVersion;
    }

    if (!Util.isUnset(request.grafanaWorkspaceId)) {
      query["GrafanaWorkspaceId"] = request.grafanaWorkspaceId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGrafanaWorkspaceVersion",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UpdateGrafanaWorkspaceVersionResponse>(await this.callApi(params, req, runtime), new UpdateGrafanaWorkspaceVersionResponse({}));
    } else {
      return $tea.cast<UpdateGrafanaWorkspaceVersionResponse>(await this.execute(params, req, runtime), new UpdateGrafanaWorkspaceVersionResponse({}));
    }

  }

  /**
   * Updates the version of a Grafana workspace.
   * 
   * @remarks
   * Note: The list returned by this operation includes the workspaces of Developer Edition, Expert Edition, and Advanced Edition. The list does not include the workspaces of Shared Edition.
   * 
   * @param request - UpdateGrafanaWorkspaceVersionRequest
   * @returns UpdateGrafanaWorkspaceVersionResponse
   */
  async updateGrafanaWorkspaceVersion(request: UpdateGrafanaWorkspaceVersionRequest): Promise<UpdateGrafanaWorkspaceVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGrafanaWorkspaceVersionWithOptions(request, runtime);
  }

  /**
   * Modifies the information about an integration.
   * 
   * @param request - UpdateIntegrationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateIntegrationResponse
   */
  async updateIntegrationWithOptions(request: UpdateIntegrationRequest, runtime: $Util.RuntimeOptions): Promise<UpdateIntegrationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.autoRecover)) {
      body["AutoRecover"] = request.autoRecover;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.duplicateKey)) {
      body["DuplicateKey"] = request.duplicateKey;
    }

    if (!Util.isUnset(request.extendedFieldRedefineRules)) {
      body["ExtendedFieldRedefineRules"] = request.extendedFieldRedefineRules;
    }

    if (!Util.isUnset(request.fieldRedefineRules)) {
      body["FieldRedefineRules"] = request.fieldRedefineRules;
    }

    if (!Util.isUnset(request.initiativeRecoverField)) {
      body["InitiativeRecoverField"] = request.initiativeRecoverField;
    }

    if (!Util.isUnset(request.initiativeRecoverValue)) {
      body["InitiativeRecoverValue"] = request.initiativeRecoverValue;
    }

    if (!Util.isUnset(request.integrationId)) {
      body["IntegrationId"] = request.integrationId;
    }

    if (!Util.isUnset(request.integrationName)) {
      body["IntegrationName"] = request.integrationName;
    }

    if (!Util.isUnset(request.integrationProductType)) {
      body["IntegrationProductType"] = request.integrationProductType;
    }

    if (!Util.isUnset(request.liveness)) {
      body["Liveness"] = request.liveness;
    }

    if (!Util.isUnset(request.recoverTime)) {
      body["RecoverTime"] = request.recoverTime;
    }

    if (!Util.isUnset(request.stat)) {
      body["Stat"] = request.stat;
    }

    if (!Util.isUnset(request.state)) {
      body["State"] = request.state;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateIntegration",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UpdateIntegrationResponse>(await this.callApi(params, req, runtime), new UpdateIntegrationResponse({}));
    } else {
      return $tea.cast<UpdateIntegrationResponse>(await this.execute(params, req, runtime), new UpdateIntegrationResponse({}));
    }

  }

  /**
   * Modifies the information about an integration.
   * 
   * @param request - UpdateIntegrationRequest
   * @returns UpdateIntegrationResponse
   */
  async updateIntegration(request: UpdateIntegrationRequest): Promise<UpdateIntegrationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateIntegrationWithOptions(request, runtime);
  }

  /**
   * Updates the list of discarded metrics.
   * 
   * @param request - UpdateMetricDropRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateMetricDropResponse
   */
  async updateMetricDropWithOptions(request: UpdateMetricDropRequest, runtime: $Util.RuntimeOptions): Promise<UpdateMetricDropResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.metricDrop)) {
      query["MetricDrop"] = request.metricDrop;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateMetricDrop",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UpdateMetricDropResponse>(await this.callApi(params, req, runtime), new UpdateMetricDropResponse({}));
    } else {
      return $tea.cast<UpdateMetricDropResponse>(await this.execute(params, req, runtime), new UpdateMetricDropResponse({}));
    }

  }

  /**
   * Updates the list of discarded metrics.
   * 
   * @param request - UpdateMetricDropRequest
   * @returns UpdateMetricDropResponse
   */
  async updateMetricDrop(request: UpdateMetricDropRequest): Promise<UpdateMetricDropResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateMetricDropWithOptions(request, runtime);
  }

  /**
   * 更新Prometheus告警规则
   * 
   * @param request - UpdatePrometheusAlertRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdatePrometheusAlertRuleResponse
   */
  async updatePrometheusAlertRuleWithOptions(request: UpdatePrometheusAlertRuleRequest, runtime: $Util.RuntimeOptions): Promise<UpdatePrometheusAlertRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertId)) {
      query["AlertId"] = request.alertId;
    }

    if (!Util.isUnset(request.alertName)) {
      query["AlertName"] = request.alertName;
    }

    if (!Util.isUnset(request.annotations)) {
      query["Annotations"] = request.annotations;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dispatchRuleId)) {
      query["DispatchRuleId"] = request.dispatchRuleId;
    }

    if (!Util.isUnset(request.duration)) {
      query["Duration"] = request.duration;
    }

    if (!Util.isUnset(request.expression)) {
      query["Expression"] = request.expression;
    }

    if (!Util.isUnset(request.labels)) {
      query["Labels"] = request.labels;
    }

    if (!Util.isUnset(request.message)) {
      query["Message"] = request.message;
    }

    if (!Util.isUnset(request.notifyType)) {
      query["NotifyType"] = request.notifyType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdatePrometheusAlertRule",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UpdatePrometheusAlertRuleResponse>(await this.callApi(params, req, runtime), new UpdatePrometheusAlertRuleResponse({}));
    } else {
      return $tea.cast<UpdatePrometheusAlertRuleResponse>(await this.execute(params, req, runtime), new UpdatePrometheusAlertRuleResponse({}));
    }

  }

  /**
   * 更新Prometheus告警规则
   * 
   * @param request - UpdatePrometheusAlertRuleRequest
   * @returns UpdatePrometheusAlertRuleResponse
   */
  async updatePrometheusAlertRule(request: UpdatePrometheusAlertRuleRequest): Promise<UpdatePrometheusAlertRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updatePrometheusAlertRuleWithOptions(request, runtime);
  }

  /**
   * Updates the data sources of Prometheus instance for GlobalView.
   * 
   * @param request - UpdatePrometheusGlobalViewRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdatePrometheusGlobalViewResponse
   */
  async updatePrometheusGlobalViewWithOptions(request: UpdatePrometheusGlobalViewRequest, runtime: $Util.RuntimeOptions): Promise<UpdatePrometheusGlobalViewResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.allSubClustersSuccess)) {
      query["AllSubClustersSuccess"] = request.allSubClustersSuccess;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.mostRegionId)) {
      query["MostRegionId"] = request.mostRegionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.subClustersJson)) {
      query["SubClustersJson"] = request.subClustersJson;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdatePrometheusGlobalView",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UpdatePrometheusGlobalViewResponse>(await this.callApi(params, req, runtime), new UpdatePrometheusGlobalViewResponse({}));
    } else {
      return $tea.cast<UpdatePrometheusGlobalViewResponse>(await this.execute(params, req, runtime), new UpdatePrometheusGlobalViewResponse({}));
    }

  }

  /**
   * Updates the data sources of Prometheus instance for GlobalView.
   * 
   * @param request - UpdatePrometheusGlobalViewRequest
   * @returns UpdatePrometheusGlobalViewResponse
   */
  async updatePrometheusGlobalView(request: UpdatePrometheusGlobalViewRequest): Promise<UpdatePrometheusGlobalViewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updatePrometheusGlobalViewWithOptions(request, runtime);
  }

  /**
   * Updates the information about a Prometheus instance.
   * 
   * @param request - UpdatePrometheusInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdatePrometheusInstanceResponse
   */
  async updatePrometheusInstanceWithOptions(request: UpdatePrometheusInstanceRequest, runtime: $Util.RuntimeOptions): Promise<UpdatePrometheusInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.archiveDuration)) {
      query["ArchiveDuration"] = request.archiveDuration;
    }

    if (!Util.isUnset(request.authFreeReadPolicy)) {
      query["AuthFreeReadPolicy"] = request.authFreeReadPolicy;
    }

    if (!Util.isUnset(request.authFreeWritePolicy)) {
      query["AuthFreeWritePolicy"] = request.authFreeWritePolicy;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.enableAuthFreeRead)) {
      query["EnableAuthFreeRead"] = request.enableAuthFreeRead;
    }

    if (!Util.isUnset(request.enableAuthFreeWrite)) {
      query["EnableAuthFreeWrite"] = request.enableAuthFreeWrite;
    }

    if (!Util.isUnset(request.enableAuthToken)) {
      query["EnableAuthToken"] = request.enableAuthToken;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.storageDuration)) {
      query["StorageDuration"] = request.storageDuration;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdatePrometheusInstance",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UpdatePrometheusInstanceResponse>(await this.callApi(params, req, runtime), new UpdatePrometheusInstanceResponse({}));
    } else {
      return $tea.cast<UpdatePrometheusInstanceResponse>(await this.execute(params, req, runtime), new UpdatePrometheusInstanceResponse({}));
    }

  }

  /**
   * Updates the information about a Prometheus instance.
   * 
   * @param request - UpdatePrometheusInstanceRequest
   * @returns UpdatePrometheusInstanceResponse
   */
  async updatePrometheusInstance(request: UpdatePrometheusInstanceRequest): Promise<UpdatePrometheusInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updatePrometheusInstanceWithOptions(request, runtime);
  }

  /**
   * Modifies the configurations of an exporter that is integrated into a Prometheus instance for Container Service or a Prometheus instance for ECS.
   * 
   * @param request - UpdatePrometheusIntegrationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdatePrometheusIntegrationResponse
   */
  async updatePrometheusIntegrationWithOptions(request: UpdatePrometheusIntegrationRequest, runtime: $Util.RuntimeOptions): Promise<UpdatePrometheusIntegrationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.integrationType)) {
      query["IntegrationType"] = request.integrationType;
    }

    if (!Util.isUnset(request.param)) {
      query["Param"] = request.param;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdatePrometheusIntegration",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UpdatePrometheusIntegrationResponse>(await this.callApi(params, req, runtime), new UpdatePrometheusIntegrationResponse({}));
    } else {
      return $tea.cast<UpdatePrometheusIntegrationResponse>(await this.execute(params, req, runtime), new UpdatePrometheusIntegrationResponse({}));
    }

  }

  /**
   * Modifies the configurations of an exporter that is integrated into a Prometheus instance for Container Service or a Prometheus instance for ECS.
   * 
   * @param request - UpdatePrometheusIntegrationRequest
   * @returns UpdatePrometheusIntegrationResponse
   */
  async updatePrometheusIntegration(request: UpdatePrometheusIntegrationRequest): Promise<UpdatePrometheusIntegrationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updatePrometheusIntegrationWithOptions(request, runtime);
  }

  /**
   * Updates the monitoring configuration of a Prometheus instance.
   * 
   * @param request - UpdatePrometheusMonitoringRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdatePrometheusMonitoringResponse
   */
  async updatePrometheusMonitoringWithOptions(request: UpdatePrometheusMonitoringRequest, runtime: $Util.RuntimeOptions): Promise<UpdatePrometheusMonitoringResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.monitoringName)) {
      query["MonitoringName"] = request.monitoringName;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.configYaml)) {
      body["ConfigYaml"] = request.configYaml;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdatePrometheusMonitoring",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UpdatePrometheusMonitoringResponse>(await this.callApi(params, req, runtime), new UpdatePrometheusMonitoringResponse({}));
    } else {
      return $tea.cast<UpdatePrometheusMonitoringResponse>(await this.execute(params, req, runtime), new UpdatePrometheusMonitoringResponse({}));
    }

  }

  /**
   * Updates the monitoring configuration of a Prometheus instance.
   * 
   * @param request - UpdatePrometheusMonitoringRequest
   * @returns UpdatePrometheusMonitoringResponse
   */
  async updatePrometheusMonitoring(request: UpdatePrometheusMonitoringRequest): Promise<UpdatePrometheusMonitoringResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updatePrometheusMonitoringWithOptions(request, runtime);
  }

  /**
   * Updates the status of the monitoring configuration of a Prometheus instance.
   * 
   * @param request - UpdatePrometheusMonitoringStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdatePrometheusMonitoringStatusResponse
   */
  async updatePrometheusMonitoringStatusWithOptions(request: UpdatePrometheusMonitoringStatusRequest, runtime: $Util.RuntimeOptions): Promise<UpdatePrometheusMonitoringStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.monitoringName)) {
      query["MonitoringName"] = request.monitoringName;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdatePrometheusMonitoringStatus",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UpdatePrometheusMonitoringStatusResponse>(await this.callApi(params, req, runtime), new UpdatePrometheusMonitoringStatusResponse({}));
    } else {
      return $tea.cast<UpdatePrometheusMonitoringStatusResponse>(await this.execute(params, req, runtime), new UpdatePrometheusMonitoringStatusResponse({}));
    }

  }

  /**
   * Updates the status of the monitoring configuration of a Prometheus instance.
   * 
   * @param request - UpdatePrometheusMonitoringStatusRequest
   * @returns UpdatePrometheusMonitoringStatusResponse
   */
  async updatePrometheusMonitoringStatus(request: UpdatePrometheusMonitoringStatusRequest): Promise<UpdatePrometheusMonitoringStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updatePrometheusMonitoringStatusWithOptions(request, runtime);
  }

  /**
   * Updates a Real User Monitoring (RUM) application.
   * 
   * @remarks
   * Real User Monitoring (RUM) is available only in the China (Hangzhou), Singapore, and US (Silicon Valley) regions. Select the correct endpoint.
   * 
   * @param request - UpdateRumAppRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateRumAppResponse
   */
  async updateRumAppWithOptions(request: UpdateRumAppRequest, runtime: $Util.RuntimeOptions): Promise<UpdateRumAppResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.autoRestart)) {
      query["AutoRestart"] = request.autoRestart;
    }

    if (!Util.isUnset(request.backendServiceTraceRegion)) {
      query["BackendServiceTraceRegion"] = request.backendServiceTraceRegion;
    }

    if (!Util.isUnset(request.bonreeSDKConfigJson)) {
      query["BonreeSDKConfigJson"] = request.bonreeSDKConfigJson;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.isSubscribe)) {
      query["IsSubscribe"] = request.isSubscribe;
    }

    if (!Util.isUnset(request.nickname)) {
      query["Nickname"] = request.nickname;
    }

    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    if (!Util.isUnset(request.realRegionId)) {
      query["RealRegionId"] = request.realRegionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.restart)) {
      query["Restart"] = request.restart;
    }

    if (!Util.isUnset(request.serviceDomainOperationJson)) {
      query["ServiceDomainOperationJson"] = request.serviceDomainOperationJson;
    }

    if (!Util.isUnset(request.stop)) {
      query["Stop"] = request.stop;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateRumApp",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UpdateRumAppResponse>(await this.callApi(params, req, runtime), new UpdateRumAppResponse({}));
    } else {
      return $tea.cast<UpdateRumAppResponse>(await this.execute(params, req, runtime), new UpdateRumAppResponse({}));
    }

  }

  /**
   * Updates a Real User Monitoring (RUM) application.
   * 
   * @remarks
   * Real User Monitoring (RUM) is available only in the China (Hangzhou), Singapore, and US (Silicon Valley) regions. Select the correct endpoint.
   * 
   * @param request - UpdateRumAppRequest
   * @returns UpdateRumAppResponse
   */
  async updateRumApp(request: UpdateRumAppRequest): Promise<UpdateRumAppResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateRumAppWithOptions(request, runtime);
  }

  /**
   * Updates the status of a Real User Monitoring (RUM) file. You can call this operation after the RUM file is uploaded.
   * 
   * @remarks
   * Real User Monitoring (RUM) is available only in the China (Hangzhou), Singapore, and US (Silicon Valley) regions. Select the correct endpoint.
   * 
   * @param request - UpdateRumFileStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateRumFileStatusResponse
   */
  async updateRumFileStatusWithOptions(request: UpdateRumFileStatusRequest, runtime: $Util.RuntimeOptions): Promise<UpdateRumFileStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.fileName)) {
      query["FileName"] = request.fileName;
    }

    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.size)) {
      query["Size"] = request.size;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    if (!Util.isUnset(request.versionId)) {
      query["VersionId"] = request.versionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateRumFileStatus",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UpdateRumFileStatusResponse>(await this.callApi(params, req, runtime), new UpdateRumFileStatusResponse({}));
    } else {
      return $tea.cast<UpdateRumFileStatusResponse>(await this.execute(params, req, runtime), new UpdateRumFileStatusResponse({}));
    }

  }

  /**
   * Updates the status of a Real User Monitoring (RUM) file. You can call this operation after the RUM file is uploaded.
   * 
   * @remarks
   * Real User Monitoring (RUM) is available only in the China (Hangzhou), Singapore, and US (Silicon Valley) regions. Select the correct endpoint.
   * 
   * @param request - UpdateRumFileStatusRequest
   * @returns UpdateRumFileStatusResponse
   */
  async updateRumFileStatus(request: UpdateRumFileStatusRequest): Promise<UpdateRumFileStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateRumFileStatusWithOptions(request, runtime);
  }

  /**
   * 更新定时拨测任务
   * 
   * @param tmpReq - UpdateTimingSyntheticTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateTimingSyntheticTaskResponse
   */
  async updateTimingSyntheticTaskWithOptions(tmpReq: UpdateTimingSyntheticTaskRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTimingSyntheticTaskResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateTimingSyntheticTaskShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.availableAssertions)) {
      request.availableAssertionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.availableAssertions, "AvailableAssertions", "json");
    }

    if (!Util.isUnset(tmpReq.commonSetting)) {
      request.commonSettingShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.commonSetting, "CommonSetting", "json");
    }

    if (!Util.isUnset(tmpReq.customPeriod)) {
      request.customPeriodShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.customPeriod, "CustomPeriod", "json");
    }

    if (!Util.isUnset(tmpReq.monitorConf)) {
      request.monitorConfShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.monitorConf, "MonitorConf", "json");
    }

    if (!Util.isUnset(tmpReq.monitors)) {
      request.monitorsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.monitors, "Monitors", "json");
    }

    if (!Util.isUnset(tmpReq.tags)) {
      request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, "Tags", "json");
    }

    let query = { };
    if (!Util.isUnset(request.availableAssertionsShrink)) {
      query["AvailableAssertions"] = request.availableAssertionsShrink;
    }

    if (!Util.isUnset(request.commonSettingShrink)) {
      query["CommonSetting"] = request.commonSettingShrink;
    }

    if (!Util.isUnset(request.customPeriodShrink)) {
      query["CustomPeriod"] = request.customPeriodShrink;
    }

    if (!Util.isUnset(request.frequency)) {
      query["Frequency"] = request.frequency;
    }

    if (!Util.isUnset(request.monitorConfShrink)) {
      query["MonitorConf"] = request.monitorConfShrink;
    }

    if (!Util.isUnset(request.monitorsShrink)) {
      query["Monitors"] = request.monitorsShrink;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.tagsShrink)) {
      query["Tags"] = request.tagsShrink;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTimingSyntheticTask",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UpdateTimingSyntheticTaskResponse>(await this.callApi(params, req, runtime), new UpdateTimingSyntheticTaskResponse({}));
    } else {
      return $tea.cast<UpdateTimingSyntheticTaskResponse>(await this.execute(params, req, runtime), new UpdateTimingSyntheticTaskResponse({}));
    }

  }

  /**
   * 更新定时拨测任务
   * 
   * @param request - UpdateTimingSyntheticTaskRequest
   * @returns UpdateTimingSyntheticTaskResponse
   */
  async updateTimingSyntheticTask(request: UpdateTimingSyntheticTaskRequest): Promise<UpdateTimingSyntheticTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTimingSyntheticTaskWithOptions(request, runtime);
  }

  /**
   * Modifies the information about a webhook alert contact.
   * 
   * @remarks
   * This operation is no longer maintained. Call the CreateOrUpdateWebhookContact operation in the new alter management module to create or modify a webhook alert contact.
   * 
   * @param request - UpdateWebhookRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateWebhookResponse
   */
  async updateWebhookWithOptions(request: UpdateWebhookRequest, runtime: $Util.RuntimeOptions): Promise<UpdateWebhookResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.body)) {
      query["Body"] = request.body;
    }

    if (!Util.isUnset(request.contactId)) {
      query["ContactId"] = request.contactId;
    }

    if (!Util.isUnset(request.contactName)) {
      query["ContactName"] = request.contactName;
    }

    if (!Util.isUnset(request.httpHeaders)) {
      query["HttpHeaders"] = request.httpHeaders;
    }

    if (!Util.isUnset(request.httpParams)) {
      query["HttpParams"] = request.httpParams;
    }

    if (!Util.isUnset(request.method)) {
      query["Method"] = request.method;
    }

    if (!Util.isUnset(request.recoverBody)) {
      query["RecoverBody"] = request.recoverBody;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.url)) {
      query["Url"] = request.url;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateWebhook",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UpdateWebhookResponse>(await this.callApi(params, req, runtime), new UpdateWebhookResponse({}));
    } else {
      return $tea.cast<UpdateWebhookResponse>(await this.execute(params, req, runtime), new UpdateWebhookResponse({}));
    }

  }

  /**
   * Modifies the information about a webhook alert contact.
   * 
   * @remarks
   * This operation is no longer maintained. Call the CreateOrUpdateWebhookContact operation in the new alter management module to create or modify a webhook alert contact.
   * 
   * @param request - UpdateWebhookRequest
   * @returns UpdateWebhookResponse
   */
  async updateWebhook(request: UpdateWebhookRequest): Promise<UpdateWebhookResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateWebhookWithOptions(request, runtime);
  }

  /**
   * Updates the release information of an add-on.
   * 
   * @param request - UpgradeAddonReleaseRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpgradeAddonReleaseResponse
   */
  async upgradeAddonReleaseWithOptions(request: UpgradeAddonReleaseRequest, runtime: $Util.RuntimeOptions): Promise<UpgradeAddonReleaseResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.addonVersion)) {
      query["AddonVersion"] = request.addonVersion;
    }

    if (!Util.isUnset(request.dryRun)) {
      query["DryRun"] = request.dryRun;
    }

    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.releaseName)) {
      query["ReleaseName"] = request.releaseName;
    }

    if (!Util.isUnset(request.values)) {
      query["Values"] = request.values;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpgradeAddonRelease",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UpgradeAddonReleaseResponse>(await this.callApi(params, req, runtime), new UpgradeAddonReleaseResponse({}));
    } else {
      return $tea.cast<UpgradeAddonReleaseResponse>(await this.execute(params, req, runtime), new UpgradeAddonReleaseResponse({}));
    }

  }

  /**
   * Updates the release information of an add-on.
   * 
   * @param request - UpgradeAddonReleaseRequest
   * @returns UpgradeAddonReleaseResponse
   */
  async upgradeAddonRelease(request: UpgradeAddonReleaseRequest): Promise<UpgradeAddonReleaseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.upgradeAddonReleaseWithOptions(request, runtime);
  }

  /**
   * Updates the feature information of an environment.
   * 
   * @param request - UpgradeEnvironmentFeatureRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpgradeEnvironmentFeatureResponse
   */
  async upgradeEnvironmentFeatureWithOptions(request: UpgradeEnvironmentFeatureRequest, runtime: $Util.RuntimeOptions): Promise<UpgradeEnvironmentFeatureResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliyunLang)) {
      query["AliyunLang"] = request.aliyunLang;
    }

    if (!Util.isUnset(request.environmentId)) {
      query["EnvironmentId"] = request.environmentId;
    }

    if (!Util.isUnset(request.featureName)) {
      query["FeatureName"] = request.featureName;
    }

    if (!Util.isUnset(request.featureVersion)) {
      query["FeatureVersion"] = request.featureVersion;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.values)) {
      query["Values"] = request.values;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpgradeEnvironmentFeature",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UpgradeEnvironmentFeatureResponse>(await this.callApi(params, req, runtime), new UpgradeEnvironmentFeatureResponse({}));
    } else {
      return $tea.cast<UpgradeEnvironmentFeatureResponse>(await this.execute(params, req, runtime), new UpgradeEnvironmentFeatureResponse({}));
    }

  }

  /**
   * Updates the feature information of an environment.
   * 
   * @param request - UpgradeEnvironmentFeatureRequest
   * @returns UpgradeEnvironmentFeatureResponse
   */
  async upgradeEnvironmentFeature(request: UpgradeEnvironmentFeatureRequest): Promise<UpgradeEnvironmentFeatureResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.upgradeEnvironmentFeatureWithOptions(request, runtime);
  }

  /**
   * Uploads a SourceMap file to ARMS Browser Monitoring.
   * 
   * @param request - UploadRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UploadResponse
   */
  async uploadWithOptions(request: UploadRequest, runtime: $Util.RuntimeOptions): Promise<UploadResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.edition)) {
      query["Edition"] = request.edition;
    }

    if (!Util.isUnset(request.fileName)) {
      query["FileName"] = request.fileName;
    }

    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.version)) {
      query["Version"] = request.version;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.file)) {
      body["File"] = request.file;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "Upload",
      version: "2019-08-08",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if (Util.isUnset(this._signatureVersion) || !Util.equalString(this._signatureVersion, "v4")) {
      return $tea.cast<UploadResponse>(await this.callApi(params, req, runtime), new UploadResponse({}));
    } else {
      return $tea.cast<UploadResponse>(await this.execute(params, req, runtime), new UploadResponse({}));
    }

  }

  /**
   * Uploads a SourceMap file to ARMS Browser Monitoring.
   * 
   * @param request - UploadRequest
   * @returns UploadResponse
   */
  async upload(request: UploadRequest): Promise<UploadResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.uploadWithOptions(request, runtime);
  }

}
