// This file is auto-generated, don't edit it
/**
 *
 */
import Util, * as $Util from '@alicloud/tea-util';
import OpenApi, * as $OpenApi from '@alicloud/openapi-client';
import OpenApiUtil from '@alicloud/openapi-util';
import EndpointUtil from '@alicloud/endpoint-util';
import * as $tea from '@alicloud/tea-typescript';

export class AsyncTaskVO extends $tea.Model {
  datasetId?: string;
  id?: number;
  remark?: string;
  taskName?: string;
  taskStatus?: number;
  taskType?: number;
  userId?: number;
  static names(): { [key: string]: string } {
    return {
      datasetId: 'DatasetId',
      id: 'Id',
      remark: 'Remark',
      taskName: 'TaskName',
      taskStatus: 'TaskStatus',
      taskType: 'TaskType',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      datasetId: 'string',
      id: 'number',
      remark: 'string',
      taskName: 'string',
      taskStatus: 'number',
      taskType: 'number',
      userId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DatasetItemVO extends $tea.Model {
  asyncTaskList?: AsyncTaskVO[];
  datasetStatus?: number;
  datasetType?: number;
  digest?: string;
  fileSystem?: string;
  id?: string;
  keyName?: string;
  moreInfo?: string;
  path?: string;
  projectsLinked?: ProjectDetailsLiteVO[];
  recentTaskStatus?: number;
  remark?: string;
  schema?: string;
  tableName?: string;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      asyncTaskList: 'AsyncTaskList',
      datasetStatus: 'DatasetStatus',
      datasetType: 'DatasetType',
      digest: 'Digest',
      fileSystem: 'FileSystem',
      id: 'Id',
      keyName: 'KeyName',
      moreInfo: 'MoreInfo',
      path: 'Path',
      projectsLinked: 'ProjectsLinked',
      recentTaskStatus: 'RecentTaskStatus',
      remark: 'Remark',
      schema: 'Schema',
      tableName: 'TableName',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asyncTaskList: { 'type': 'array', 'itemType': AsyncTaskVO },
      datasetStatus: 'number',
      datasetType: 'number',
      digest: 'string',
      fileSystem: 'string',
      id: 'string',
      keyName: 'string',
      moreInfo: 'string',
      path: 'string',
      projectsLinked: { 'type': 'array', 'itemType': ProjectDetailsLiteVO },
      recentTaskStatus: 'number',
      remark: 'string',
      schema: 'string',
      tableName: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDataKeyVO extends $tea.Model {
  colName?: string;
  dbName?: string;
  mekId?: number;
  schemaName?: string;
  tblName?: string;
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      colName: 'ColName',
      dbName: 'DbName',
      mekId: 'MekId',
      schemaName: 'SchemaName',
      tblName: 'TblName',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      colName: 'string',
      dbName: 'string',
      mekId: 'number',
      schemaName: 'string',
      tblName: 'string',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportMasterKeyVO extends $tea.Model {
  encryptMekDataBase64?: string;
  mekId?: number;
  projectId?: number[];
  static names(): { [key: string]: string } {
    return {
      encryptMekDataBase64: 'EncryptMekDataBase64',
      mekId: 'MekId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      encryptMekDataBase64: 'string',
      mekId: 'number',
      projectId: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ProjectDetailsLiteVO extends $tea.Model {
  id?: number;
  projectName?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      projectName: 'ProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      projectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StsApplyVO extends $tea.Model {
  aliyunId?: string;
  duration?: number;
  static names(): { [key: string]: string } {
    return {
      aliyunId: 'AliyunId',
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunId: 'string',
      duration: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StsTokenVO extends $tea.Model {
  accessKeyId?: string;
  accessKeySecret?: string;
  expiration?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      accessKeyId: 'AccessKeyId',
      accessKeySecret: 'AccessKeySecret',
      expiration: 'Expiration',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKeyId: 'string',
      accessKeySecret: 'string',
      expiration: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TeeEvidenceVO extends $tea.Model {
  cipherSuite?: string;
  enclaveData?: string;
  encryptPublicKeyPem?: string;
  encryptPublicKeyType?: string;
  modifiedDate?: string;
  publicKey?: string;
  publicKeyRaBase64?: string;
  publicKeyRaType?: string;
  quoteReport?: string;
  signPublicKeyPem?: string;
  signPublicKeyType?: string;
  trustedMrEnclave?: string[];
  static names(): { [key: string]: string } {
    return {
      cipherSuite: 'CipherSuite',
      enclaveData: 'EnclaveData',
      encryptPublicKeyPem: 'EncryptPublicKeyPem',
      encryptPublicKeyType: 'EncryptPublicKeyType',
      modifiedDate: 'ModifiedDate',
      publicKey: 'PublicKey',
      publicKeyRaBase64: 'PublicKeyRaBase64',
      publicKeyRaType: 'PublicKeyRaType',
      quoteReport: 'QuoteReport',
      signPublicKeyPem: 'SignPublicKeyPem',
      signPublicKeyType: 'SignPublicKeyType',
      trustedMrEnclave: 'TrustedMrEnclave',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cipherSuite: 'string',
      enclaveData: 'string',
      encryptPublicKeyPem: 'string',
      encryptPublicKeyType: 'string',
      modifiedDate: 'string',
      publicKey: 'string',
      publicKeyRaBase64: 'string',
      publicKeyRaType: 'string',
      quoteReport: 'string',
      signPublicKeyPem: 'string',
      signPublicKeyType: 'string',
      trustedMrEnclave: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UsersDetailsVO extends $tea.Model {
  approvalSignatureBase64?: string;
  approvalSqlTemplate?: string;
  approvalStatus?: string;
  creator?: number;
  dataReady?: number;
  id?: number;
  mekid?: number;
  pathPrefix?: string;
  resultParty?: number;
  uid?: string;
  userConfirmed?: number;
  userName?: string;
  userPublicKeyPem?: string;
  static names(): { [key: string]: string } {
    return {
      approvalSignatureBase64: 'ApprovalSignatureBase64',
      approvalSqlTemplate: 'ApprovalSqlTemplate',
      approvalStatus: 'ApprovalStatus',
      creator: 'Creator',
      dataReady: 'DataReady',
      id: 'Id',
      mekid: 'Mekid',
      pathPrefix: 'PathPrefix',
      resultParty: 'ResultParty',
      uid: 'Uid',
      userConfirmed: 'UserConfirmed',
      userName: 'UserName',
      userPublicKeyPem: 'UserPublicKeyPem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      approvalSignatureBase64: 'string',
      approvalSqlTemplate: 'string',
      approvalStatus: 'string',
      creator: 'number',
      dataReady: 'number',
      id: 'number',
      mekid: 'number',
      pathPrefix: 'string',
      resultParty: 'number',
      uid: 'string',
      userConfirmed: 'number',
      userName: 'string',
      userPublicKeyPem: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDesensitizationRuleRequest extends $tea.Model {
  functionParams?: { [key: string]: string }[];
  functionType?: string;
  ruleDescription?: string;
  ruleName?: string;
  ruleType?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      functionParams: 'FunctionParams',
      functionType: 'FunctionType',
      ruleDescription: 'RuleDescription',
      ruleName: 'RuleName',
      ruleType: 'RuleType',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionParams: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'string' } },
      functionType: 'string',
      ruleDescription: 'string',
      ruleName: 'string',
      ruleType: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDesensitizationRuleResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  ruleId?: number;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      ruleId: 'RuleId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      ruleId: 'number',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDesensitizationRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddDesensitizationRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddDesensitizationRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddInstanceRequest extends $tea.Model {
  dataLinkName?: string;
  databasePassword?: string;
  databaseUser?: string;
  dbaId?: number;
  ddlOnline?: number;
  ecsInstanceId?: string;
  ecsRegion?: string;
  enableSellCommon?: string;
  enableSellSitd?: string;
  enableSellStable?: string;
  enableSellTrust?: string;
  envType?: string;
  exportTimeout?: number;
  host?: string;
  instanceAlias?: string;
  instanceSource?: string;
  instanceType?: string;
  networkType?: string;
  port?: number;
  queryTimeout?: number;
  safeRule?: string;
  sid?: string;
  skipTest?: boolean;
  templateId?: number;
  templateType?: string;
  tid?: number;
  useDsql?: number;
  useSsl?: number;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      dataLinkName: 'DataLinkName',
      databasePassword: 'DatabasePassword',
      databaseUser: 'DatabaseUser',
      dbaId: 'DbaId',
      ddlOnline: 'DdlOnline',
      ecsInstanceId: 'EcsInstanceId',
      ecsRegion: 'EcsRegion',
      enableSellCommon: 'EnableSellCommon',
      enableSellSitd: 'EnableSellSitd',
      enableSellStable: 'EnableSellStable',
      enableSellTrust: 'EnableSellTrust',
      envType: 'EnvType',
      exportTimeout: 'ExportTimeout',
      host: 'Host',
      instanceAlias: 'InstanceAlias',
      instanceSource: 'InstanceSource',
      instanceType: 'InstanceType',
      networkType: 'NetworkType',
      port: 'Port',
      queryTimeout: 'QueryTimeout',
      safeRule: 'SafeRule',
      sid: 'Sid',
      skipTest: 'SkipTest',
      templateId: 'TemplateId',
      templateType: 'TemplateType',
      tid: 'Tid',
      useDsql: 'UseDsql',
      useSsl: 'UseSsl',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataLinkName: 'string',
      databasePassword: 'string',
      databaseUser: 'string',
      dbaId: 'number',
      ddlOnline: 'number',
      ecsInstanceId: 'string',
      ecsRegion: 'string',
      enableSellCommon: 'string',
      enableSellSitd: 'string',
      enableSellStable: 'string',
      enableSellTrust: 'string',
      envType: 'string',
      exportTimeout: 'number',
      host: 'string',
      instanceAlias: 'string',
      instanceSource: 'string',
      instanceType: 'string',
      networkType: 'string',
      port: 'number',
      queryTimeout: 'number',
      safeRule: 'string',
      sid: 'string',
      skipTest: 'boolean',
      templateId: 'number',
      templateType: 'string',
      tid: 'number',
      useDsql: 'number',
      useSsl: 'number',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddInstanceResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLhMembersRequest extends $tea.Model {
  members?: AddLhMembersRequestMembers[];
  objectId?: number;
  objectType?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      members: 'Members',
      objectId: 'ObjectId',
      objectType: 'ObjectType',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      members: { 'type': 'array', 'itemType': AddLhMembersRequestMembers },
      objectId: 'number',
      objectType: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLhMembersShrinkRequest extends $tea.Model {
  membersShrink?: string;
  objectId?: number;
  objectType?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      membersShrink: 'Members',
      objectId: 'ObjectId',
      objectType: 'ObjectType',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      membersShrink: 'string',
      objectId: 'number',
      objectType: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLhMembersResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLhMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddLhMembersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddLhMembersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLogicTableRouteConfigRequest extends $tea.Model {
  routeExpr?: string;
  routeKey?: string;
  tableId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      routeExpr: 'RouteExpr',
      routeKey: 'RouteKey',
      tableId: 'TableId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      routeExpr: 'string',
      routeKey: 'string',
      tableId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLogicTableRouteConfigResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLogicTableRouteConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddLogicTableRouteConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddLogicTableRouteConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTaskFlowEdgesRequest extends $tea.Model {
  dagId?: number;
  edges?: AddTaskFlowEdgesRequestEdges[];
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      edges: 'Edges',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      edges: { 'type': 'array', 'itemType': AddTaskFlowEdgesRequestEdges },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTaskFlowEdgesShrinkRequest extends $tea.Model {
  dagId?: number;
  edgesShrink?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      edgesShrink: 'Edges',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      edgesShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTaskFlowEdgesResponseBody extends $tea.Model {
  edgeIds?: AddTaskFlowEdgesResponseBodyEdgeIds;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      edgeIds: 'EdgeIds',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      edgeIds: AddTaskFlowEdgesResponseBodyEdgeIds,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTaskFlowEdgesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddTaskFlowEdgesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddTaskFlowEdgesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AnalyzeSQLLineageRequest extends $tea.Model {
  dbId?: number;
  sqlContent?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      sqlContent: 'SqlContent',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      sqlContent: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AnalyzeSQLLineageResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  lineageResult?: AnalyzeSQLLineageResponseBodyLineageResult;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      lineageResult: 'LineageResult',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      lineageResult: AnalyzeSQLLineageResponseBodyLineageResult,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AnalyzeSQLLineageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AnalyzeSQLLineageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AnalyzeSQLLineageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApproveOrderRequest extends $tea.Model {
  approvalNodeId?: number;
  approvalNodePos?: string;
  approvalType?: string;
  comment?: string;
  newApprover?: number;
  newApproverList?: string;
  oldApprover?: number;
  tid?: number;
  workflowInstanceId?: number;
  static names(): { [key: string]: string } {
    return {
      approvalNodeId: 'ApprovalNodeId',
      approvalNodePos: 'ApprovalNodePos',
      approvalType: 'ApprovalType',
      comment: 'Comment',
      newApprover: 'NewApprover',
      newApproverList: 'NewApproverList',
      oldApprover: 'OldApprover',
      tid: 'Tid',
      workflowInstanceId: 'WorkflowInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      approvalNodeId: 'number',
      approvalNodePos: 'string',
      approvalType: 'string',
      comment: 'string',
      newApprover: 'number',
      newApproverList: 'string',
      oldApprover: 'number',
      tid: 'number',
      workflowInstanceId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApproveOrderResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApproveOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ApproveOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ApproveOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BackFillRequest extends $tea.Model {
  asc?: boolean;
  backFillDate?: string;
  backFillDateBegin?: string;
  backFillDateEnd?: string;
  dagId?: number;
  filterNodeIds?: number[];
  historyDagId?: number;
  interval?: number;
  isTriggerSubTree?: boolean;
  startNodeIds?: number[];
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      backFillDate: 'BackFillDate',
      backFillDateBegin: 'BackFillDateBegin',
      backFillDateEnd: 'BackFillDateEnd',
      dagId: 'DagId',
      filterNodeIds: 'FilterNodeIds',
      historyDagId: 'HistoryDagId',
      interval: 'Interval',
      isTriggerSubTree: 'IsTriggerSubTree',
      startNodeIds: 'StartNodeIds',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'boolean',
      backFillDate: 'string',
      backFillDateBegin: 'string',
      backFillDateEnd: 'string',
      dagId: 'number',
      filterNodeIds: { 'type': 'array', 'itemType': 'number' },
      historyDagId: 'number',
      interval: 'number',
      isTriggerSubTree: 'boolean',
      startNodeIds: { 'type': 'array', 'itemType': 'number' },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BackFillShrinkRequest extends $tea.Model {
  asc?: boolean;
  backFillDate?: string;
  backFillDateBegin?: string;
  backFillDateEnd?: string;
  dagId?: number;
  filterNodeIdsShrink?: string;
  historyDagId?: number;
  interval?: number;
  isTriggerSubTree?: boolean;
  startNodeIdsShrink?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      backFillDate: 'BackFillDate',
      backFillDateBegin: 'BackFillDateBegin',
      backFillDateEnd: 'BackFillDateEnd',
      dagId: 'DagId',
      filterNodeIdsShrink: 'FilterNodeIds',
      historyDagId: 'HistoryDagId',
      interval: 'Interval',
      isTriggerSubTree: 'IsTriggerSubTree',
      startNodeIdsShrink: 'StartNodeIds',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'boolean',
      backFillDate: 'string',
      backFillDateBegin: 'string',
      backFillDateEnd: 'string',
      dagId: 'number',
      filterNodeIdsShrink: 'string',
      historyDagId: 'number',
      interval: 'number',
      isTriggerSubTree: 'boolean',
      startNodeIdsShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BackFillResponseBody extends $tea.Model {
  dagInstanceId?: number;
  errorCode?: string;
  errorMessage?: string;
  nodeId?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      dagInstanceId: 'DagInstanceId',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      nodeId: 'NodeId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagInstanceId: 'number',
      errorCode: 'string',
      errorMessage: 'string',
      nodeId: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BackFillResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BackFillResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BackFillResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BuyPayAsYouGoOrderRequest extends $tea.Model {
  commodityType?: string;
  insNum?: number;
  tid?: number;
  versionType?: string;
  static names(): { [key: string]: string } {
    return {
      commodityType: 'CommodityType',
      insNum: 'InsNum',
      tid: 'Tid',
      versionType: 'VersionType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commodityType: 'string',
      insNum: 'number',
      tid: 'number',
      versionType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BuyPayAsYouGoOrderResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  instanceId?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      instanceId: 'InstanceId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      instanceId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BuyPayAsYouGoOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BuyPayAsYouGoOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BuyPayAsYouGoOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeColumnSecLevelRequest extends $tea.Model {
  columnName?: string;
  dbId?: number;
  isLogic?: boolean;
  newLevel?: string;
  schemaName?: string;
  tableName?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      dbId: 'DbId',
      isLogic: 'IsLogic',
      newLevel: 'NewLevel',
      schemaName: 'SchemaName',
      tableName: 'TableName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      dbId: 'number',
      isLogic: 'boolean',
      newLevel: 'string',
      schemaName: 'string',
      tableName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeColumnSecLevelResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeColumnSecLevelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ChangeColumnSecLevelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ChangeColumnSecLevelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeColumnSecurityLevelRequest extends $tea.Model {
  columnName?: string;
  dbId?: number;
  isLogic?: boolean;
  newSensitivityLevel?: string;
  schemaName?: string;
  tableName?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      dbId: 'DbId',
      isLogic: 'IsLogic',
      newSensitivityLevel: 'NewSensitivityLevel',
      schemaName: 'SchemaName',
      tableName: 'TableName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      dbId: 'number',
      isLogic: 'boolean',
      newSensitivityLevel: 'string',
      schemaName: 'string',
      tableName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeColumnSecurityLevelResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeColumnSecurityLevelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ChangeColumnSecurityLevelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ChangeColumnSecurityLevelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeLhDagOwnerRequest extends $tea.Model {
  dagId?: number;
  ownerUserId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      ownerUserId: 'OwnerUserId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      ownerUserId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeLhDagOwnerResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeLhDagOwnerResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ChangeLhDagOwnerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ChangeLhDagOwnerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseOrderRequest extends $tea.Model {
  closeReason?: string;
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      closeReason: 'CloseReason',
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      closeReason: 'string',
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseOrderResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CloseOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CloseOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAuthorityTemplateRequest extends $tea.Model {
  description?: string;
  name?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAuthorityTemplateResponseBody extends $tea.Model {
  authorityTemplateView?: CreateAuthorityTemplateResponseBodyAuthorityTemplateView;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      authorityTemplateView: 'AuthorityTemplateView',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorityTemplateView: CreateAuthorityTemplateResponseBodyAuthorityTemplateView,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAuthorityTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateAuthorityTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateAuthorityTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataArchiveOrderRequest extends $tea.Model {
  comment?: string;
  param?: CreateDataArchiveOrderRequestParam;
  parentId?: number;
  pluginType?: string;
  relatedUserList?: string[];
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      param: 'Param',
      parentId: 'ParentId',
      pluginType: 'PluginType',
      relatedUserList: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      param: CreateDataArchiveOrderRequestParam,
      parentId: 'number',
      pluginType: 'string',
      relatedUserList: { 'type': 'array', 'itemType': 'string' },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataArchiveOrderShrinkRequest extends $tea.Model {
  comment?: string;
  paramShrink?: string;
  parentId?: number;
  pluginType?: string;
  relatedUserListShrink?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      paramShrink: 'Param',
      parentId: 'ParentId',
      pluginType: 'PluginType',
      relatedUserListShrink: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      paramShrink: 'string',
      parentId: 'number',
      pluginType: 'string',
      relatedUserListShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataArchiveOrderResponseBody extends $tea.Model {
  createOrderResult?: number[];
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: { 'type': 'array', 'itemType': 'number' },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataArchiveOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDataArchiveOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDataArchiveOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataCorrectOrderRequest extends $tea.Model {
  attachmentKey?: string;
  comment?: string;
  param?: CreateDataCorrectOrderRequestParam;
  relatedUserList?: number[];
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      param: 'Param',
      relatedUserList: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      param: CreateDataCorrectOrderRequestParam,
      relatedUserList: { 'type': 'array', 'itemType': 'number' },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataCorrectOrderShrinkRequest extends $tea.Model {
  attachmentKey?: string;
  comment?: string;
  paramShrink?: string;
  relatedUserListShrink?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      paramShrink: 'Param',
      relatedUserListShrink: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      paramShrink: 'string',
      relatedUserListShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataCorrectOrderResponseBody extends $tea.Model {
  createOrderResult?: number[];
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: { 'type': 'array', 'itemType': 'number' },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataCorrectOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDataCorrectOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDataCorrectOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataCronClearOrderRequest extends $tea.Model {
  attachmentKey?: string;
  comment?: string;
  param?: CreateDataCronClearOrderRequestParam;
  relatedUserList?: number[];
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      param: 'Param',
      relatedUserList: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      param: CreateDataCronClearOrderRequestParam,
      relatedUserList: { 'type': 'array', 'itemType': 'number' },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataCronClearOrderShrinkRequest extends $tea.Model {
  attachmentKey?: string;
  comment?: string;
  paramShrink?: string;
  relatedUserListShrink?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      paramShrink: 'Param',
      relatedUserListShrink: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      paramShrink: 'string',
      relatedUserListShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataCronClearOrderResponseBody extends $tea.Model {
  createOrderResult?: number[];
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: { 'type': 'array', 'itemType': 'number' },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataCronClearOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDataCronClearOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDataCronClearOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataExportOrderRequest extends $tea.Model {
  attachmentKey?: string;
  comment?: string;
  parentId?: number;
  pluginParam?: CreateDataExportOrderRequestPluginParam;
  relatedUserList?: number[];
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      parentId: 'ParentId',
      pluginParam: 'PluginParam',
      relatedUserList: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      parentId: 'number',
      pluginParam: CreateDataExportOrderRequestPluginParam,
      relatedUserList: { 'type': 'array', 'itemType': 'number' },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataExportOrderShrinkRequest extends $tea.Model {
  attachmentKey?: string;
  comment?: string;
  parentId?: number;
  pluginParamShrink?: string;
  relatedUserListShrink?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      parentId: 'ParentId',
      pluginParamShrink: 'PluginParam',
      relatedUserListShrink: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      parentId: 'number',
      pluginParamShrink: 'string',
      relatedUserListShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataExportOrderResponseBody extends $tea.Model {
  createOrderResult?: CreateDataExportOrderResponseBodyCreateOrderResult;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: CreateDataExportOrderResponseBodyCreateOrderResult,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataExportOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDataExportOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDataExportOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataImportOrderRequest extends $tea.Model {
  attachmentKey?: string;
  comment?: string;
  param?: CreateDataImportOrderRequestParam;
  relatedUserList?: number[];
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      param: 'Param',
      relatedUserList: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      param: CreateDataImportOrderRequestParam,
      relatedUserList: { 'type': 'array', 'itemType': 'number' },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataImportOrderShrinkRequest extends $tea.Model {
  attachmentKey?: string;
  comment?: string;
  paramShrink?: string;
  relatedUserListShrink?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      paramShrink: 'Param',
      relatedUserListShrink: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      paramShrink: 'string',
      relatedUserListShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataImportOrderResponseBody extends $tea.Model {
  createOrderResult?: number[];
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: { 'type': 'array', 'itemType': 'number' },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataImportOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDataImportOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDataImportOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataTrackOrderRequest extends $tea.Model {
  comment?: string;
  param?: CreateDataTrackOrderRequestParam;
  relatedUserList?: string[];
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      param: 'Param',
      relatedUserList: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      param: CreateDataTrackOrderRequestParam,
      relatedUserList: { 'type': 'array', 'itemType': 'string' },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataTrackOrderShrinkRequest extends $tea.Model {
  comment?: string;
  paramShrink?: string;
  relatedUserListShrink?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      paramShrink: 'Param',
      relatedUserListShrink: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      paramShrink: 'string',
      relatedUserListShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataTrackOrderResponseBody extends $tea.Model {
  createOrderResult?: number[];
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: { 'type': 'array', 'itemType': 'number' },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataTrackOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDataTrackOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDataTrackOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDatabaseExportOrderRequest extends $tea.Model {
  attachmentKey?: string;
  comment?: string;
  parentId?: number;
  pluginParam?: CreateDatabaseExportOrderRequestPluginParam;
  relatedUserList?: number[];
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      parentId: 'ParentId',
      pluginParam: 'PluginParam',
      relatedUserList: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      parentId: 'number',
      pluginParam: CreateDatabaseExportOrderRequestPluginParam,
      relatedUserList: { 'type': 'array', 'itemType': 'number' },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDatabaseExportOrderShrinkRequest extends $tea.Model {
  attachmentKey?: string;
  comment?: string;
  parentId?: number;
  pluginParamShrink?: string;
  relatedUserListShrink?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      parentId: 'ParentId',
      pluginParamShrink: 'PluginParam',
      relatedUserListShrink: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      parentId: 'number',
      pluginParamShrink: 'string',
      relatedUserListShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDatabaseExportOrderResponseBody extends $tea.Model {
  createOrderResult?: CreateDatabaseExportOrderResponseBodyCreateOrderResult;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: CreateDatabaseExportOrderResponseBodyCreateOrderResult,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDatabaseExportOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDatabaseExportOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDatabaseExportOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFreeLockCorrectOrderRequest extends $tea.Model {
  attachmentKey?: string;
  comment?: string;
  param?: CreateFreeLockCorrectOrderRequestParam;
  relatedUserList?: number[];
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      param: 'Param',
      relatedUserList: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      param: CreateFreeLockCorrectOrderRequestParam,
      relatedUserList: { 'type': 'array', 'itemType': 'number' },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFreeLockCorrectOrderShrinkRequest extends $tea.Model {
  attachmentKey?: string;
  comment?: string;
  paramShrink?: string;
  relatedUserListShrink?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      paramShrink: 'Param',
      relatedUserListShrink: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      paramShrink: 'string',
      relatedUserListShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFreeLockCorrectOrderResponseBody extends $tea.Model {
  createOrderResult?: number[];
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: { 'type': 'array', 'itemType': 'number' },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFreeLockCorrectOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateFreeLockCorrectOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateFreeLockCorrectOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLakeHouseSpaceRequest extends $tea.Model {
  description?: string;
  devDbId?: string;
  dwDbType?: string;
  mode?: string;
  prodDbId?: string;
  spaceConfig?: string;
  spaceName?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      devDbId: 'DevDbId',
      dwDbType: 'DwDbType',
      mode: 'Mode',
      prodDbId: 'ProdDbId',
      spaceConfig: 'SpaceConfig',
      spaceName: 'SpaceName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      devDbId: 'string',
      dwDbType: 'string',
      mode: 'string',
      prodDbId: 'string',
      spaceConfig: 'string',
      spaceName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLakeHouseSpaceResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  spaceId?: number;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      spaceId: 'SpaceId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      spaceId: 'number',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLakeHouseSpaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateLakeHouseSpaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateLakeHouseSpaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLogicDatabaseRequest extends $tea.Model {
  alias?: string;
  databaseIds?: number[];
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      databaseIds: 'DatabaseIds',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      databaseIds: { 'type': 'array', 'itemType': 'number' },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLogicDatabaseShrinkRequest extends $tea.Model {
  alias?: string;
  databaseIdsShrink?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      databaseIdsShrink: 'DatabaseIds',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      databaseIdsShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLogicDatabaseResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  logicDbId?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      logicDbId: 'LogicDbId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      logicDbId: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLogicDatabaseResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateLogicDatabaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateLogicDatabaseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrderRequest extends $tea.Model {
  attachmentKey?: string;
  comment?: string;
  pluginParam?: { [key: string]: any };
  pluginType?: string;
  relatedUserList?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      pluginParam: 'PluginParam',
      pluginType: 'PluginType',
      relatedUserList: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      pluginParam: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      pluginType: 'string',
      relatedUserList: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrderShrinkRequest extends $tea.Model {
  attachmentKey?: string;
  comment?: string;
  pluginParamShrink?: string;
  pluginType?: string;
  relatedUserList?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      pluginParamShrink: 'PluginParam',
      pluginType: 'PluginType',
      relatedUserList: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      pluginParamShrink: 'string',
      pluginType: 'string',
      relatedUserList: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrderResponseBody extends $tea.Model {
  createOrderResult?: CreateOrderResponseBodyCreateOrderResult;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: CreateOrderResponseBodyCreateOrderResult,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProcCorrectOrderRequest extends $tea.Model {
  attachmentKey?: string;
  comment?: string;
  param?: CreateProcCorrectOrderRequestParam;
  relatedUserList?: number[];
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      param: 'Param',
      relatedUserList: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      param: CreateProcCorrectOrderRequestParam,
      relatedUserList: { 'type': 'array', 'itemType': 'number' },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProcCorrectOrderShrinkRequest extends $tea.Model {
  attachmentKey?: string;
  comment?: string;
  paramShrink?: string;
  relatedUserListShrink?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      paramShrink: 'Param',
      relatedUserListShrink: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      paramShrink: 'string',
      relatedUserListShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProcCorrectOrderResponseBody extends $tea.Model {
  createOrderResult?: number[];
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: { 'type': 'array', 'itemType': 'number' },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProcCorrectOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateProcCorrectOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateProcCorrectOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProxyRequest extends $tea.Model {
  instanceId?: number;
  password?: string;
  tid?: number;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      password: 'Password',
      tid: 'Tid',
      username: 'Username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'number',
      password: 'string',
      tid: 'number',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProxyResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  proxyId?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      proxyId: 'ProxyId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      proxyId: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProxyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateProxyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateProxyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProxyAccessRequest extends $tea.Model {
  indepAccount?: string;
  indepPassword?: string;
  proxyId?: number;
  tid?: number;
  userId?: number;
  static names(): { [key: string]: string } {
    return {
      indepAccount: 'IndepAccount',
      indepPassword: 'IndepPassword',
      proxyId: 'ProxyId',
      tid: 'Tid',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      indepAccount: 'string',
      indepPassword: 'string',
      proxyId: 'number',
      tid: 'number',
      userId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProxyAccessResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  proxyAccessId?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      proxyAccessId: 'ProxyAccessId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      proxyAccessId: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProxyAccessResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateProxyAccessResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateProxyAccessResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePublishGroupTaskRequest extends $tea.Model {
  dbId?: number;
  logic?: boolean;
  orderId?: number;
  planTime?: string;
  publishStrategy?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      logic: 'Logic',
      orderId: 'OrderId',
      planTime: 'PlanTime',
      publishStrategy: 'PublishStrategy',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      logic: 'boolean',
      orderId: 'number',
      planTime: 'string',
      publishStrategy: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePublishGroupTaskResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  taskId?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      taskId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePublishGroupTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreatePublishGroupTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreatePublishGroupTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSQLReviewOrderRequest extends $tea.Model {
  comment?: string;
  param?: CreateSQLReviewOrderRequestParam;
  relatedUserList?: number[];
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      param: 'Param',
      relatedUserList: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      param: CreateSQLReviewOrderRequestParam,
      relatedUserList: { 'type': 'array', 'itemType': 'number' },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSQLReviewOrderShrinkRequest extends $tea.Model {
  comment?: string;
  paramShrink?: string;
  relatedUserListShrink?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      paramShrink: 'Param',
      relatedUserListShrink: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      paramShrink: 'string',
      relatedUserListShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSQLReviewOrderResponseBody extends $tea.Model {
  createOrderResult?: number[];
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: { 'type': 'array', 'itemType': 'number' },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSQLReviewOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateSQLReviewOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSQLReviewOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScenarioRequest extends $tea.Model {
  description?: string;
  scenarioName?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      scenarioName: 'ScenarioName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      scenarioName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScenarioResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  scenarioId?: number;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      scenarioId: 'ScenarioId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      scenarioId: 'number',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScenarioResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateScenarioResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateScenarioResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStandardGroupRequest extends $tea.Model {
  dbType?: string;
  description?: string;
  groupName?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dbType: 'DbType',
      description: 'Description',
      groupName: 'GroupName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbType: 'string',
      description: 'string',
      groupName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStandardGroupResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  standardGroup?: CreateStandardGroupResponseBodyStandardGroup;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      standardGroup: 'StandardGroup',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      standardGroup: CreateStandardGroupResponseBodyStandardGroup,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStandardGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateStandardGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateStandardGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStructSyncOrderRequest extends $tea.Model {
  attachmentKey?: string;
  comment?: string;
  param?: CreateStructSyncOrderRequestParam;
  relatedUserList?: number[];
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      param: 'Param',
      relatedUserList: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      param: CreateStructSyncOrderRequestParam,
      relatedUserList: { 'type': 'array', 'itemType': 'number' },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStructSyncOrderShrinkRequest extends $tea.Model {
  attachmentKey?: string;
  comment?: string;
  paramShrink?: string;
  relatedUserListShrink?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      paramShrink: 'Param',
      relatedUserListShrink: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      paramShrink: 'string',
      relatedUserListShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStructSyncOrderResponseBody extends $tea.Model {
  createOrderResult?: number[];
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: { 'type': 'array', 'itemType': 'number' },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStructSyncOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateStructSyncOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateStructSyncOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTaskRequest extends $tea.Model {
  dagId?: number;
  graphParam?: string;
  nodeContent?: string;
  nodeName?: string;
  nodeOutput?: string;
  nodeType?: string;
  tid?: number;
  timeVariables?: string;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      graphParam: 'GraphParam',
      nodeContent: 'NodeContent',
      nodeName: 'NodeName',
      nodeOutput: 'NodeOutput',
      nodeType: 'NodeType',
      tid: 'Tid',
      timeVariables: 'TimeVariables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      graphParam: 'string',
      nodeContent: 'string',
      nodeName: 'string',
      nodeOutput: 'string',
      nodeType: 'string',
      tid: 'number',
      timeVariables: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTaskResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  nodeId?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      nodeId: 'NodeId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      nodeId: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTaskFlowRequest extends $tea.Model {
  dagName?: string;
  description?: string;
  scenarioId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagName: 'DagName',
      description: 'Description',
      scenarioId: 'ScenarioId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagName: 'string',
      description: 'string',
      scenarioId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTaskFlowResponseBody extends $tea.Model {
  dagId?: number;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTaskFlowResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTaskFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTaskFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUploadFileJobRequest extends $tea.Model {
  fileName?: string;
  fileSource?: string;
  tid?: number;
  uploadURL?: string;
  static names(): { [key: string]: string } {
    return {
      fileName: 'FileName',
      fileSource: 'FileSource',
      tid: 'Tid',
      uploadURL: 'UploadURL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileName: 'string',
      fileSource: 'string',
      tid: 'number',
      uploadURL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUploadFileJobResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  jobKey?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      jobKey: 'JobKey',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      jobKey: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUploadFileJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateUploadFileJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateUploadFileJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUploadOSSFileJobRequest extends $tea.Model {
  fileName?: string;
  fileSource?: string;
  tid?: number;
  uploadTarget?: CreateUploadOSSFileJobRequestUploadTarget;
  static names(): { [key: string]: string } {
    return {
      fileName: 'FileName',
      fileSource: 'FileSource',
      tid: 'Tid',
      uploadTarget: 'UploadTarget',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileName: 'string',
      fileSource: 'string',
      tid: 'number',
      uploadTarget: CreateUploadOSSFileJobRequestUploadTarget,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUploadOSSFileJobShrinkRequest extends $tea.Model {
  fileName?: string;
  fileSource?: string;
  tid?: number;
  uploadTargetShrink?: string;
  static names(): { [key: string]: string } {
    return {
      fileName: 'FileName',
      fileSource: 'FileSource',
      tid: 'Tid',
      uploadTargetShrink: 'UploadTarget',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileName: 'string',
      fileSource: 'string',
      tid: 'number',
      uploadTargetShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUploadOSSFileJobResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  jobKey?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      jobKey: 'JobKey',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      jobKey: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUploadOSSFileJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateUploadOSSFileJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateUploadOSSFileJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAuthorityTemplateRequest extends $tea.Model {
  templateId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      templateId: 'TemplateId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      templateId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAuthorityTemplateResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAuthorityTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteAuthorityTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteAuthorityTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstanceRequest extends $tea.Model {
  host?: string;
  port?: number;
  sid?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
      port: 'Port',
      sid: 'Sid',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: 'string',
      port: 'number',
      sid: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstanceResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLakeHouseSpaceRequest extends $tea.Model {
  spaceId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      spaceId: 'SpaceId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      spaceId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLakeHouseSpaceResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLakeHouseSpaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteLakeHouseSpaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLakeHouseSpaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLhMembersRequest extends $tea.Model {
  memberIds?: number[];
  objectId?: number;
  objectType?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      memberIds: 'MemberIds',
      objectId: 'ObjectId',
      objectType: 'ObjectType',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      memberIds: { 'type': 'array', 'itemType': 'number' },
      objectId: 'number',
      objectType: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLhMembersShrinkRequest extends $tea.Model {
  memberIdsShrink?: string;
  objectId?: number;
  objectType?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      memberIdsShrink: 'MemberIds',
      objectId: 'ObjectId',
      objectType: 'ObjectType',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      memberIdsShrink: 'string',
      objectId: 'number',
      objectType: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLhMembersResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLhMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteLhMembersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLhMembersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLogicDatabaseRequest extends $tea.Model {
  logicDbId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      logicDbId: 'LogicDbId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logicDbId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLogicDatabaseResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLogicDatabaseResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteLogicDatabaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLogicDatabaseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLogicTableRouteConfigRequest extends $tea.Model {
  routeKey?: string;
  tableId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      routeKey: 'RouteKey',
      tableId: 'TableId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      routeKey: 'string',
      tableId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLogicTableRouteConfigResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLogicTableRouteConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteLogicTableRouteConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLogicTableRouteConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProxyRequest extends $tea.Model {
  proxyId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      proxyId: 'ProxyId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      proxyId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProxyResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProxyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteProxyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteProxyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProxyAccessRequest extends $tea.Model {
  proxyAccessId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      proxyAccessId: 'ProxyAccessId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      proxyAccessId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProxyAccessResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProxyAccessResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteProxyAccessResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteProxyAccessResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScenarioRequest extends $tea.Model {
  scenarioId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      scenarioId: 'ScenarioId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      scenarioId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScenarioResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScenarioResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteScenarioResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteScenarioResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteStandardGroupRequest extends $tea.Model {
  groupId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteStandardGroupResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteStandardGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteStandardGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteStandardGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTaskRequest extends $tea.Model {
  nodeId?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTaskResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTaskFlowRequest extends $tea.Model {
  dagId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTaskFlowResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTaskFlowResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTaskFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTaskFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTaskFlowEdgesByConditionRequest extends $tea.Model {
  dagId?: number;
  id?: number;
  nodeEnd?: number;
  nodeFrom?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      id: 'Id',
      nodeEnd: 'NodeEnd',
      nodeFrom: 'NodeFrom',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      id: 'number',
      nodeEnd: 'number',
      nodeFrom: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTaskFlowEdgesByConditionResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTaskFlowEdgesByConditionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTaskFlowEdgesByConditionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTaskFlowEdgesByConditionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUserRequest extends $tea.Model {
  tid?: number;
  uid?: string;
  static names(): { [key: string]: string } {
    return {
      tid: 'Tid',
      uid: 'Uid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tid: 'number',
      uid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUserResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUserResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableUserRequest extends $tea.Model {
  tid?: number;
  uid?: string;
  static names(): { [key: string]: string } {
    return {
      tid: 'Tid',
      uid: 'Uid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tid: 'number',
      uid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableUserResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableUserResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DisableUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DisableUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadDataTrackResultRequest extends $tea.Model {
  columnFilter?: DownloadDataTrackResultRequestColumnFilter;
  eventIdList?: number[];
  filterEndTime?: string;
  filterStartTime?: string;
  filterTableList?: string[];
  filterTypeList?: string[];
  orderId?: number;
  rollbackSQLType?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      columnFilter: 'ColumnFilter',
      eventIdList: 'EventIdList',
      filterEndTime: 'FilterEndTime',
      filterStartTime: 'FilterStartTime',
      filterTableList: 'FilterTableList',
      filterTypeList: 'FilterTypeList',
      orderId: 'OrderId',
      rollbackSQLType: 'RollbackSQLType',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnFilter: DownloadDataTrackResultRequestColumnFilter,
      eventIdList: { 'type': 'array', 'itemType': 'number' },
      filterEndTime: 'string',
      filterStartTime: 'string',
      filterTableList: { 'type': 'array', 'itemType': 'string' },
      filterTypeList: { 'type': 'array', 'itemType': 'string' },
      orderId: 'number',
      rollbackSQLType: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadDataTrackResultShrinkRequest extends $tea.Model {
  columnFilterShrink?: string;
  eventIdListShrink?: string;
  filterEndTime?: string;
  filterStartTime?: string;
  filterTableListShrink?: string;
  filterTypeListShrink?: string;
  orderId?: number;
  rollbackSQLType?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      columnFilterShrink: 'ColumnFilter',
      eventIdListShrink: 'EventIdList',
      filterEndTime: 'FilterEndTime',
      filterStartTime: 'FilterStartTime',
      filterTableListShrink: 'FilterTableList',
      filterTypeListShrink: 'FilterTypeList',
      orderId: 'OrderId',
      rollbackSQLType: 'RollbackSQLType',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnFilterShrink: 'string',
      eventIdListShrink: 'string',
      filterEndTime: 'string',
      filterStartTime: 'string',
      filterTableListShrink: 'string',
      filterTypeListShrink: 'string',
      orderId: 'number',
      rollbackSQLType: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadDataTrackResultResponseBody extends $tea.Model {
  downloadKeyId?: string;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      downloadKeyId: 'DownloadKeyId',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadKeyId: 'string',
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadDataTrackResultResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DownloadDataTrackResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DownloadDataTrackResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditLogicDatabaseRequest extends $tea.Model {
  alias?: string;
  databaseIds?: number[];
  logicDbId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      databaseIds: 'DatabaseIds',
      logicDbId: 'LogicDbId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      databaseIds: { 'type': 'array', 'itemType': 'number' },
      logicDbId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditLogicDatabaseShrinkRequest extends $tea.Model {
  alias?: string;
  databaseIdsShrink?: string;
  logicDbId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      databaseIdsShrink: 'DatabaseIds',
      logicDbId: 'LogicDbId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      databaseIdsShrink: 'string',
      logicDbId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditLogicDatabaseResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditLogicDatabaseResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EditLogicDatabaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EditLogicDatabaseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableUserRequest extends $tea.Model {
  tid?: number;
  uid?: string;
  static names(): { [key: string]: string } {
    return {
      tid: 'Tid',
      uid: 'Uid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tid: 'number',
      uid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableUserResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableUserResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EnableUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EnableUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteDataCorrectRequest extends $tea.Model {
  actionDetail?: { [key: string]: any };
  orderId?: number;
  tid?: string;
  static names(): { [key: string]: string } {
    return {
      actionDetail: 'ActionDetail',
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionDetail: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      orderId: 'number',
      tid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteDataCorrectShrinkRequest extends $tea.Model {
  actionDetailShrink?: string;
  orderId?: number;
  tid?: string;
  static names(): { [key: string]: string } {
    return {
      actionDetailShrink: 'ActionDetail',
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionDetailShrink: 'string',
      orderId: 'number',
      tid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteDataCorrectResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteDataCorrectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExecuteDataCorrectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExecuteDataCorrectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteDataExportRequest extends $tea.Model {
  actionDetail?: { [key: string]: any };
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      actionDetail: 'ActionDetail',
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionDetail: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteDataExportShrinkRequest extends $tea.Model {
  actionDetailShrink?: string;
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      actionDetailShrink: 'ActionDetail',
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionDetailShrink: 'string',
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteDataExportResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteDataExportResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExecuteDataExportResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExecuteDataExportResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteScriptRequest extends $tea.Model {
  dbId?: number;
  logic?: boolean;
  script?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      logic: 'Logic',
      script: 'Script',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      logic: 'boolean',
      script: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteScriptResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  results?: ExecuteScriptResponseBodyResults[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      results: 'Results',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      results: { 'type': 'array', 'itemType': ExecuteScriptResponseBodyResults },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteScriptResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExecuteScriptResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExecuteScriptResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteStructSyncRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteStructSyncResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteStructSyncResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExecuteStructSyncResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExecuteStructSyncResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApprovalDetailRequest extends $tea.Model {
  tid?: number;
  workflowInstanceId?: number;
  static names(): { [key: string]: string } {
    return {
      tid: 'Tid',
      workflowInstanceId: 'WorkflowInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tid: 'number',
      workflowInstanceId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApprovalDetailResponseBody extends $tea.Model {
  approvalDetail?: GetApprovalDetailResponseBodyApprovalDetail;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      approvalDetail: 'ApprovalDetail',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      approvalDetail: GetApprovalDetailResponseBodyApprovalDetail,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApprovalDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetApprovalDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetApprovalDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthorityTemplateRequest extends $tea.Model {
  templateId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      templateId: 'TemplateId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      templateId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthorityTemplateResponseBody extends $tea.Model {
  authorityTemplateView?: GetAuthorityTemplateResponseBodyAuthorityTemplateView;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      authorityTemplateView: 'AuthorityTemplateView',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorityTemplateView: GetAuthorityTemplateResponseBodyAuthorityTemplateView,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthorityTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetAuthorityTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetAuthorityTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthorityTemplateItemRequest extends $tea.Model {
  templateId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      templateId: 'TemplateId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      templateId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthorityTemplateItemResponseBody extends $tea.Model {
  authorityTemplateItemList?: GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemList;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      authorityTemplateItemList: 'AuthorityTemplateItemList',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorityTemplateItemList: GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemList,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthorityTemplateItemResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetAuthorityTemplateItemResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetAuthorityTemplateItemResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClassificationTemplateRequest extends $tea.Model {
  instanceId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClassificationTemplateResponseBody extends $tea.Model {
  classificationResourceTemplateMap?: GetClassificationTemplateResponseBodyClassificationResourceTemplateMap;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      classificationResourceTemplateMap: 'ClassificationResourceTemplateMap',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      classificationResourceTemplateMap: GetClassificationTemplateResponseBodyClassificationResourceTemplateMap,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClassificationTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetClassificationTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetClassificationTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDBTaskSQLJobLogRequest extends $tea.Model {
  jobId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDBTaskSQLJobLogResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  log?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      log: 'Log',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      log: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDBTaskSQLJobLogResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDBTaskSQLJobLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDBTaskSQLJobLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDBTopologyRequest extends $tea.Model {
  logicDbId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      logicDbId: 'LogicDbId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logicDbId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDBTopologyResponseBody extends $tea.Model {
  DBTopology?: GetDBTopologyResponseBodyDBTopology;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      DBTopology: 'DBTopology',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DBTopology: GetDBTopologyResponseBodyDBTopology,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDBTopologyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDBTopologyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDBTopologyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveCountRequest extends $tea.Model {
  orderResultType?: string;
  pluginType?: string;
  searchDateType?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderResultType: 'OrderResultType',
      pluginType: 'PluginType',
      searchDateType: 'SearchDateType',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderResultType: 'string',
      pluginType: 'string',
      searchDateType: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveCountResponseBody extends $tea.Model {
  data?: GetDataArchiveCountResponseBodyData;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetDataArchiveCountResponseBodyData,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveCountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataArchiveCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataArchiveCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveOrderDetailRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveOrderDetailResponseBody extends $tea.Model {
  dataArchiveOrderDetail?: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  traceId?: string;
  static names(): { [key: string]: string } {
    return {
      dataArchiveOrderDetail: 'DataArchiveOrderDetail',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      traceId: 'TraceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataArchiveOrderDetail: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      traceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveOrderDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataArchiveOrderDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataArchiveOrderDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectBackupFilesRequest extends $tea.Model {
  actionDetail?: { [key: string]: any };
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      actionDetail: 'ActionDetail',
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionDetail: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectBackupFilesShrinkRequest extends $tea.Model {
  actionDetailShrink?: string;
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      actionDetailShrink: 'ActionDetail',
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionDetailShrink: 'string',
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectBackupFilesResponseBody extends $tea.Model {
  dataCorrectBackupFiles?: GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      dataCorrectBackupFiles: 'DataCorrectBackupFiles',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataCorrectBackupFiles: GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectBackupFilesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataCorrectBackupFilesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataCorrectBackupFilesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectOrderDetailRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectOrderDetailResponseBody extends $tea.Model {
  dataCorrectOrderDetail?: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      dataCorrectOrderDetail: 'DataCorrectOrderDetail',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataCorrectOrderDetail: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectOrderDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataCorrectOrderDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataCorrectOrderDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectRollbackFileRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectRollbackFileResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  fileUrl?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      fileUrl: 'FileUrl',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      fileUrl: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectRollbackFileResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataCorrectRollbackFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataCorrectRollbackFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectSQLFileRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectSQLFileResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  fileUrl?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      fileUrl: 'FileUrl',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      fileUrl: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectSQLFileResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataCorrectSQLFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataCorrectSQLFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectTaskDetailRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectTaskDetailResponseBody extends $tea.Model {
  dataCorrectTaskDetail?: GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      dataCorrectTaskDetail: 'DataCorrectTaskDetail',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataCorrectTaskDetail: GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectTaskDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataCorrectTaskDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataCorrectTaskDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCronClearConfigRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCronClearConfigResponseBody extends $tea.Model {
  dataCronClearConfig?: GetDataCronClearConfigResponseBodyDataCronClearConfig;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      dataCronClearConfig: 'DataCronClearConfig',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataCronClearConfig: GetDataCronClearConfigResponseBodyDataCronClearConfig,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCronClearConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataCronClearConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataCronClearConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCronClearTaskDetailListRequest extends $tea.Model {
  orderId?: number;
  pageNumber?: number;
  pageSize?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCronClearTaskDetailListResponseBody extends $tea.Model {
  dataCronClearTaskDetailList?: GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList[];
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      dataCronClearTaskDetailList: 'DataCronClearTaskDetailList',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataCronClearTaskDetailList: { 'type': 'array', 'itemType': GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCronClearTaskDetailListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataCronClearTaskDetailListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataCronClearTaskDetailListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportDownloadURLRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportDownloadURLResponseBody extends $tea.Model {
  downloadURLResult?: GetDataExportDownloadURLResponseBodyDownloadURLResult;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      downloadURLResult: 'DownloadURLResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadURLResult: GetDataExportDownloadURLResponseBodyDownloadURLResult,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportDownloadURLResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataExportDownloadURLResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataExportDownloadURLResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportOrderDetailRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportOrderDetailResponseBody extends $tea.Model {
  dataExportOrderDetail?: GetDataExportOrderDetailResponseBodyDataExportOrderDetail;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      dataExportOrderDetail: 'DataExportOrderDetail',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataExportOrderDetail: GetDataExportOrderDetailResponseBodyDataExportOrderDetail,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportOrderDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataExportOrderDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataExportOrderDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportPreCheckDetailRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportPreCheckDetailResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  preCheckResult?: GetDataExportPreCheckDetailResponseBodyPreCheckResult;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      preCheckResult: 'PreCheckResult',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      preCheckResult: GetDataExportPreCheckDetailResponseBodyPreCheckResult,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportPreCheckDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataExportPreCheckDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataExportPreCheckDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataImportSQLRequest extends $tea.Model {
  orderId?: number;
  sqlId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      sqlId: 'SqlId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      sqlId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataImportSQLResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  SQLDetail?: GetDataImportSQLResponseBodySQLDetail;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      SQLDetail: 'SQLDetail',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      SQLDetail: GetDataImportSQLResponseBodySQLDetail,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataImportSQLResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataImportSQLResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataImportSQLResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataTrackJobDegreeRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataTrackJobDegreeResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  jobDegree?: GetDataTrackJobDegreeResponseBodyJobDegree;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      jobDegree: 'JobDegree',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      jobDegree: GetDataTrackJobDegreeResponseBodyJobDegree,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataTrackJobDegreeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataTrackJobDegreeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataTrackJobDegreeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataTrackJobTableMetaRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataTrackJobTableMetaResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  tableMetaList?: GetDataTrackJobTableMetaResponseBodyTableMetaList[];
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      tableMetaList: 'TableMetaList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      tableMetaList: { 'type': 'array', 'itemType': GetDataTrackJobTableMetaResponseBodyTableMetaList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataTrackJobTableMetaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataTrackJobTableMetaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataTrackJobTableMetaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataTrackOrderDetailRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataTrackOrderDetailResponseBody extends $tea.Model {
  dataTrackOrderDetail?: GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      dataTrackOrderDetail: 'DataTrackOrderDetail',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataTrackOrderDetail: GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataTrackOrderDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataTrackOrderDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataTrackOrderDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseRequest extends $tea.Model {
  host?: string;
  port?: number;
  schemaName?: string;
  sid?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
      port: 'Port',
      schemaName: 'SchemaName',
      sid: 'Sid',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: 'string',
      port: 'number',
      schemaName: 'string',
      sid: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseResponseBody extends $tea.Model {
  database?: GetDatabaseResponseBodyDatabase;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      database: 'Database',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      database: GetDatabaseResponseBodyDatabase,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDatabaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDatabaseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseExportOrderDetailRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseExportOrderDetailResponseBody extends $tea.Model {
  databaseExportOrderDetail?: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      databaseExportOrderDetail: 'DatabaseExportOrderDetail',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseExportOrderDetail: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseExportOrderDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDatabaseExportOrderDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDatabaseExportOrderDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDbExportDownloadURLRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDbExportDownloadURLResponseBody extends $tea.Model {
  downloadURLResult?: GetDbExportDownloadURLResponseBodyDownloadURLResult;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      downloadURLResult: 'DownloadURLResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadURLResult: GetDbExportDownloadURLResponseBodyDownloadURLResult,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDbExportDownloadURLResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDbExportDownloadURLResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDbExportDownloadURLResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceRequest extends $tea.Model {
  host?: string;
  port?: number;
  sid?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
      port: 'Port',
      sid: 'Sid',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: 'string',
      port: 'number',
      sid: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  instance?: GetInstanceResponseBodyInstance;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      instance: 'Instance',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      instance: GetInstanceResponseBodyInstance,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetIntervalLimitOfSLARequest extends $tea.Model {
  dagId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetIntervalLimitOfSLAResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  intervalLimit?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      intervalLimit: 'IntervalLimit',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      intervalLimit: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetIntervalLimitOfSLAResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetIntervalLimitOfSLAResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetIntervalLimitOfSLAResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLhSpaceByNameRequest extends $tea.Model {
  spaceName?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      spaceName: 'SpaceName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      spaceName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLhSpaceByNameResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  lakehouseSpace?: GetLhSpaceByNameResponseBodyLakehouseSpace;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      lakehouseSpace: 'LakehouseSpace',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      lakehouseSpace: GetLhSpaceByNameResponseBodyLakehouseSpace,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLhSpaceByNameResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetLhSpaceByNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetLhSpaceByNameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLogicDatabaseRequest extends $tea.Model {
  dbId?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLogicDatabaseResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  logicDatabase?: GetLogicDatabaseResponseBodyLogicDatabase;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      logicDatabase: 'LogicDatabase',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      logicDatabase: GetLogicDatabaseResponseBodyLogicDatabase,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLogicDatabaseResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetLogicDatabaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetLogicDatabaseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableColumnRequest extends $tea.Model {
  tableGuid?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      tableGuid: 'TableGuid',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tableGuid: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableColumnResponseBody extends $tea.Model {
  columnList?: GetMetaTableColumnResponseBodyColumnList[];
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      columnList: 'ColumnList',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnList: { 'type': 'array', 'itemType': GetMetaTableColumnResponseBodyColumnList },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableColumnResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMetaTableColumnResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMetaTableColumnResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableDetailInfoRequest extends $tea.Model {
  tableGuid?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      tableGuid: 'TableGuid',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tableGuid: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableDetailInfoResponseBody extends $tea.Model {
  detailInfo?: GetMetaTableDetailInfoResponseBodyDetailInfo;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      detailInfo: 'DetailInfo',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      detailInfo: GetMetaTableDetailInfoResponseBodyDetailInfo,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableDetailInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMetaTableDetailInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMetaTableDetailInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOnlineDDLProgressRequest extends $tea.Model {
  jobDetailId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      jobDetailId: 'JobDetailId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobDetailId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOnlineDDLProgressResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  onlineDDLTaskDetail?: GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      onlineDDLTaskDetail: 'OnlineDDLTaskDetail',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      onlineDDLTaskDetail: GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOnlineDDLProgressResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetOnlineDDLProgressResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOnlineDDLProgressResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpLogRequest extends $tea.Model {
  databaseName?: string;
  endTime?: string;
  module?: string;
  pageNumber?: number;
  pageSize?: number;
  startTime?: string;
  tid?: number;
  userNick?: string;
  static names(): { [key: string]: string } {
    return {
      databaseName: 'DatabaseName',
      endTime: 'EndTime',
      module: 'Module',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startTime: 'StartTime',
      tid: 'Tid',
      userNick: 'UserNick',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseName: 'string',
      endTime: 'string',
      module: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startTime: 'string',
      tid: 'number',
      userNick: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpLogResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  opLogDetails?: GetOpLogResponseBodyOpLogDetails;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      opLogDetails: 'OpLogDetails',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      opLogDetails: GetOpLogResponseBodyOpLogDetails,
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpLogResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetOpLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOpLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOrderAttachmentFileRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOrderAttachmentFileResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  fileUrl?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      fileUrl: 'FileUrl',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      fileUrl: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOrderAttachmentFileResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetOrderAttachmentFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOrderAttachmentFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOrderBaseInfoRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOrderBaseInfoResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  orderBaseInfo?: GetOrderBaseInfoResponseBodyOrderBaseInfo;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      orderBaseInfo: 'OrderBaseInfo',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      orderBaseInfo: GetOrderBaseInfoResponseBodyOrderBaseInfo,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOrderBaseInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetOrderBaseInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOrderBaseInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOwnerApplyOrderDetailRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOwnerApplyOrderDetailResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  ownerApplyOrderDetail?: GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      ownerApplyOrderDetail: 'OwnerApplyOrderDetail',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      ownerApplyOrderDetail: GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOwnerApplyOrderDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetOwnerApplyOrderDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOwnerApplyOrderDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPagedInstanceRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPagedInstanceResponseBody extends $tea.Model {
  data?: GetPagedInstanceResponseBodyData;
  errorCode?: string;
  errorMessage?: string;
  pageIndex?: number;
  pageSize?: number;
  requestId?: string;
  success?: boolean;
  total?: number;
  traceId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      pageIndex: 'PageIndex',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
      traceId: 'TraceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetPagedInstanceResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      pageIndex: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
      traceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPagedInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPagedInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPagedInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermApplyOrderDetailRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermApplyOrderDetailResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  permApplyOrderDetail?: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      permApplyOrderDetail: 'PermApplyOrderDetail',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      permApplyOrderDetail: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermApplyOrderDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPermApplyOrderDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPermApplyOrderDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPhysicalDatabaseRequest extends $tea.Model {
  dbId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPhysicalDatabaseResponseBody extends $tea.Model {
  database?: GetPhysicalDatabaseResponseBodyDatabase;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      database: 'Database',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      database: GetPhysicalDatabaseResponseBodyDatabase,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPhysicalDatabaseResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPhysicalDatabaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPhysicalDatabaseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProxyRequest extends $tea.Model {
  proxyId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      proxyId: 'ProxyId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      proxyId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProxyResponseBody extends $tea.Model {
  creatorId?: number;
  creatorName?: string;
  errorCode?: string;
  errorMessage?: string;
  httpsPort?: number;
  instanceId?: number;
  privateEnable?: boolean;
  privateHost?: string;
  protocolPort?: number;
  protocolType?: string;
  proxyId?: number;
  publicEnable?: boolean;
  publicHost?: string;
  regionId?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      creatorId: 'CreatorId',
      creatorName: 'CreatorName',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpsPort: 'HttpsPort',
      instanceId: 'InstanceId',
      privateEnable: 'PrivateEnable',
      privateHost: 'PrivateHost',
      protocolPort: 'ProtocolPort',
      protocolType: 'ProtocolType',
      proxyId: 'ProxyId',
      publicEnable: 'PublicEnable',
      publicHost: 'PublicHost',
      regionId: 'RegionId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorId: 'number',
      creatorName: 'string',
      errorCode: 'string',
      errorMessage: 'string',
      httpsPort: 'number',
      instanceId: 'number',
      privateEnable: 'boolean',
      privateHost: 'string',
      protocolPort: 'number',
      protocolType: 'string',
      proxyId: 'number',
      publicEnable: 'boolean',
      publicHost: 'string',
      regionId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProxyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetProxyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetProxyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProxyAccessRequest extends $tea.Model {
  proxyAccessId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      proxyAccessId: 'ProxyAccessId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      proxyAccessId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProxyAccessResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  proxyAccess?: GetProxyAccessResponseBodyProxyAccess;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      proxyAccess: 'ProxyAccess',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      proxyAccess: GetProxyAccessResponseBodyProxyAccess,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProxyAccessResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetProxyAccessResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetProxyAccessResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleNumLimitOfSLARequest extends $tea.Model {
  dagId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleNumLimitOfSLAResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  ruleNumLimit?: number;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      ruleNumLimit: 'RuleNumLimit',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      ruleNumLimit: 'number',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleNumLimitOfSLAResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRuleNumLimitOfSLAResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRuleNumLimitOfSLAResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSQLReviewCheckResultStatusRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSQLReviewCheckResultStatusResponseBody extends $tea.Model {
  checkResultStatus?: GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      checkResultStatus: 'CheckResultStatus',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkResultStatus: GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSQLReviewCheckResultStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSQLReviewCheckResultStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSQLReviewCheckResultStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSQLReviewOptimizeDetailRequest extends $tea.Model {
  SQLReviewQueryKey?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      SQLReviewQueryKey: 'SQLReviewQueryKey',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      SQLReviewQueryKey: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSQLReviewOptimizeDetailResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  optimizeDetail?: GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      optimizeDetail: 'OptimizeDetail',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      optimizeDetail: GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSQLReviewOptimizeDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSQLReviewOptimizeDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSQLReviewOptimizeDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStandardGroupRequest extends $tea.Model {
  groupId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStandardGroupResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  standardGroup?: GetStandardGroupResponseBodyStandardGroup;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      standardGroup: 'StandardGroup',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      standardGroup: GetStandardGroupResponseBodyStandardGroup,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStandardGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetStandardGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetStandardGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncExecSqlDetailRequest extends $tea.Model {
  orderId?: number;
  pageNumber?: number;
  pageSize?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncExecSqlDetailResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  structSyncExecSqlDetail?: GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      structSyncExecSqlDetail: 'StructSyncExecSqlDetail',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      structSyncExecSqlDetail: GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncExecSqlDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetStructSyncExecSqlDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetStructSyncExecSqlDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncJobAnalyzeResultRequest extends $tea.Model {
  compareType?: string;
  orderId?: number;
  pageNumber?: number;
  pageSize?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      compareType: 'CompareType',
      orderId: 'OrderId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      compareType: 'string',
      orderId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncJobAnalyzeResultResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  structSyncJobAnalyzeResult?: GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      structSyncJobAnalyzeResult: 'StructSyncJobAnalyzeResult',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      structSyncJobAnalyzeResult: GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncJobAnalyzeResultResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetStructSyncJobAnalyzeResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetStructSyncJobAnalyzeResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncJobDetailRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncJobDetailResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  structSyncJobDetail?: GetStructSyncJobDetailResponseBodyStructSyncJobDetail;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      structSyncJobDetail: 'StructSyncJobDetail',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      structSyncJobDetail: GetStructSyncJobDetailResponseBodyStructSyncJobDetail,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncJobDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetStructSyncJobDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetStructSyncJobDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncOrderDetailRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncOrderDetailResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  structSyncOrderDetail?: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      structSyncOrderDetail: 'StructSyncOrderDetail',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      structSyncOrderDetail: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncOrderDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetStructSyncOrderDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetStructSyncOrderDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDBTopologyRequest extends $tea.Model {
  tableGuid?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      tableGuid: 'TableGuid',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tableGuid: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDBTopologyResponseBody extends $tea.Model {
  DBTopology?: GetTableDBTopologyResponseBodyDBTopology;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      DBTopology: 'DBTopology',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DBTopology: GetTableDBTopologyResponseBodyDBTopology,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDBTopologyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTableDBTopologyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTableDBTopologyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDesignProjectFlowRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDesignProjectFlowResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  projectFlow?: GetTableDesignProjectFlowResponseBodyProjectFlow;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      projectFlow: 'ProjectFlow',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      projectFlow: GetTableDesignProjectFlowResponseBodyProjectFlow,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDesignProjectFlowResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTableDesignProjectFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTableDesignProjectFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDesignProjectInfoRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDesignProjectInfoResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  projectInfo?: GetTableDesignProjectInfoResponseBodyProjectInfo;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      projectInfo: 'ProjectInfo',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      projectInfo: GetTableDesignProjectInfoResponseBodyProjectInfo,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDesignProjectInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTableDesignProjectInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTableDesignProjectInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableTopologyRequest extends $tea.Model {
  tableGuid?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      tableGuid: 'TableGuid',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tableGuid: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableTopologyResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  tableTopology?: GetTableTopologyResponseBodyTableTopology;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      tableTopology: 'TableTopology',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      tableTopology: GetTableTopologyResponseBodyTableTopology,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableTopologyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTableTopologyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTableTopologyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskRequest extends $tea.Model {
  nodeId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  task?: GetTaskResponseBodyTask;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      task: 'Task',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      task: GetTaskResponseBodyTask,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskFlowGraphRequest extends $tea.Model {
  dagId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskFlowGraphResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  taskFlowGraph?: GetTaskFlowGraphResponseBodyTaskFlowGraph;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      taskFlowGraph: 'TaskFlowGraph',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      taskFlowGraph: GetTaskFlowGraphResponseBodyTaskFlowGraph,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskFlowGraphResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTaskFlowGraphResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTaskFlowGraphResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskFlowNotificationRequest extends $tea.Model {
  dagId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskFlowNotificationResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  notification?: GetTaskFlowNotificationResponseBodyNotification;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      notification: 'Notification',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      notification: GetTaskFlowNotificationResponseBodyNotification,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskFlowNotificationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTaskFlowNotificationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTaskFlowNotificationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskInstanceRelationRequest extends $tea.Model {
  dagId?: number;
  dagInstanceId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      dagInstanceId: 'DagInstanceId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      dagInstanceId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskInstanceRelationResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  nodeList?: GetTaskInstanceRelationResponseBodyNodeList;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      nodeList: 'NodeList',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      nodeList: GetTaskInstanceRelationResponseBodyNodeList,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskInstanceRelationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTaskInstanceRelationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTaskInstanceRelationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserRequest extends $tea.Model {
  tid?: number;
  uid?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      tid: 'Tid',
      uid: 'Uid',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tid: 'number',
      uid: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  user?: GetUserResponseBodyUser;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      user: GetUserResponseBodyUser,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserActiveTenantRequest extends $tea.Model {
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserActiveTenantResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  tenant?: GetUserActiveTenantResponseBodyTenant;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      tenant: 'Tenant',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      tenant: GetUserActiveTenantResponseBodyTenant,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserActiveTenantResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetUserActiveTenantResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetUserActiveTenantResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserUploadFileJobRequest extends $tea.Model {
  jobKey?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      jobKey: 'JobKey',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobKey: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserUploadFileJobResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  uploadFileJobDetail?: GetUserUploadFileJobResponseBodyUploadFileJobDetail;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      uploadFileJobDetail: 'UploadFileJobDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      uploadFileJobDetail: GetUserUploadFileJobResponseBodyUploadFileJobDetail,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserUploadFileJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetUserUploadFileJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetUserUploadFileJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrantTemplateAuthorityRequest extends $tea.Model {
  comment?: string;
  expireDate?: string;
  templateId?: number;
  tid?: number;
  userIds?: string;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      expireDate: 'ExpireDate',
      templateId: 'TemplateId',
      tid: 'Tid',
      userIds: 'UserIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      expireDate: 'string',
      templateId: 'number',
      tid: 'number',
      userIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrantTemplateAuthorityResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: boolean;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: 'boolean',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrantTemplateAuthorityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GrantTemplateAuthorityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GrantTemplateAuthorityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrantUserPermissionRequest extends $tea.Model {
  dbId?: string;
  dsType?: string;
  expireDate?: string;
  instanceId?: number;
  logic?: boolean;
  permTypes?: string;
  tableId?: string;
  tableName?: string;
  tid?: number;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      dsType: 'DsType',
      expireDate: 'ExpireDate',
      instanceId: 'InstanceId',
      logic: 'Logic',
      permTypes: 'PermTypes',
      tableId: 'TableId',
      tableName: 'TableName',
      tid: 'Tid',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'string',
      dsType: 'string',
      expireDate: 'string',
      instanceId: 'number',
      logic: 'boolean',
      permTypes: 'string',
      tableId: 'string',
      tableName: 'string',
      tid: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrantUserPermissionResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrantUserPermissionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GrantUserPermissionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GrantUserPermissionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InspectProxyAccessSecretRequest extends $tea.Model {
  proxyAccessId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      proxyAccessId: 'ProxyAccessId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      proxyAccessId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InspectProxyAccessSecretResponseBody extends $tea.Model {
  accessSecret?: string;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      accessSecret: 'AccessSecret',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessSecret: 'string',
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InspectProxyAccessSecretResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: InspectProxyAccessSecretResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: InspectProxyAccessSecretResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAuthorityTemplateRequest extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  searchKey?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchKey: 'SearchKey',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      searchKey: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAuthorityTemplateResponseBody extends $tea.Model {
  authorityTemplateViewList?: ListAuthorityTemplateResponseBodyAuthorityTemplateViewList;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  tid?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      authorityTemplateViewList: 'AuthorityTemplateViewList',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      tid: 'Tid',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorityTemplateViewList: ListAuthorityTemplateResponseBodyAuthorityTemplateViewList,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      tid: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAuthorityTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListAuthorityTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAuthorityTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClassificationTemplatesRequest extends $tea.Model {
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClassificationTemplatesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  templateList?: ListClassificationTemplatesResponseBodyTemplateList[];
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      templateList: 'TemplateList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      templateList: { 'type': 'array', 'itemType': ListClassificationTemplatesResponseBodyTemplateList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClassificationTemplatesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListClassificationTemplatesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListClassificationTemplatesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListColumnsRequest extends $tea.Model {
  logic?: boolean;
  tableId?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      logic: 'Logic',
      tableId: 'TableId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logic: 'boolean',
      tableId: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListColumnsResponseBody extends $tea.Model {
  columnList?: ListColumnsResponseBodyColumnList;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      columnList: 'ColumnList',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnList: ListColumnsResponseBodyColumnList,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListColumnsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListColumnsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListColumnsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDAGVersionsRequest extends $tea.Model {
  dagId?: number;
  pageIndex?: number;
  pageSize?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      pageIndex: 'PageIndex',
      pageSize: 'PageSize',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      pageIndex: 'number',
      pageSize: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDAGVersionsResponseBody extends $tea.Model {
  dagVersionList?: ListDAGVersionsResponseBodyDagVersionList;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      dagVersionList: 'DagVersionList',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagVersionList: ListDAGVersionsResponseBodyDagVersionList,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDAGVersionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDAGVersionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDAGVersionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDBTaskSQLJobRequest extends $tea.Model {
  DBTaskGroupId?: number;
  pageNumber?: number;
  pageSize?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      DBTaskGroupId: 'DBTaskGroupId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DBTaskGroupId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDBTaskSQLJobResponseBody extends $tea.Model {
  DBTaskSQLJobList?: ListDBTaskSQLJobResponseBodyDBTaskSQLJobList[];
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      DBTaskSQLJobList: 'DBTaskSQLJobList',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DBTaskSQLJobList: { 'type': 'array', 'itemType': ListDBTaskSQLJobResponseBodyDBTaskSQLJobList },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDBTaskSQLJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDBTaskSQLJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDBTaskSQLJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDBTaskSQLJobDetailRequest extends $tea.Model {
  jobId?: number;
  pageNumber?: number;
  pageSize?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDBTaskSQLJobDetailResponseBody extends $tea.Model {
  DBTaskSQLJobDetailList?: ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList[];
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      DBTaskSQLJobDetailList: 'DBTaskSQLJobDetailList',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DBTaskSQLJobDetailList: { 'type': 'array', 'itemType': ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDBTaskSQLJobDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDBTaskSQLJobDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDBTaskSQLJobDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDDLPublishRecordsRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDDLPublishRecordsResponseBody extends $tea.Model {
  DDLPublishRecordList?: ListDDLPublishRecordsResponseBodyDDLPublishRecordList[];
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      DDLPublishRecordList: 'DDLPublishRecordList',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DDLPublishRecordList: { 'type': 'array', 'itemType': ListDDLPublishRecordsResponseBodyDDLPublishRecordList },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDDLPublishRecordsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDDLPublishRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDDLPublishRecordsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataCorrectPreCheckDBRequest extends $tea.Model {
  orderId?: number;
  pageNumber?: number;
  pageSize?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataCorrectPreCheckDBResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  preCheckDBList?: ListDataCorrectPreCheckDBResponseBodyPreCheckDBList[];
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      preCheckDBList: 'PreCheckDBList',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      preCheckDBList: { 'type': 'array', 'itemType': ListDataCorrectPreCheckDBResponseBodyPreCheckDBList },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataCorrectPreCheckDBResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDataCorrectPreCheckDBResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDataCorrectPreCheckDBResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataCorrectPreCheckSQLRequest extends $tea.Model {
  dbId?: number;
  orderId?: number;
  pageNumber?: number;
  pageSize?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      orderId: 'OrderId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      orderId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataCorrectPreCheckSQLResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  preCheckSQLList?: ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList[];
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      preCheckSQLList: 'PreCheckSQLList',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      preCheckSQLList: { 'type': 'array', 'itemType': ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataCorrectPreCheckSQLResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDataCorrectPreCheckSQLResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDataCorrectPreCheckSQLResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataImportSQLPreCheckDetailRequest extends $tea.Model {
  orderId?: number;
  pageNumer?: number;
  pageSize?: number;
  sqlType?: string;
  statusCode?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      pageNumer: 'PageNumer',
      pageSize: 'PageSize',
      sqlType: 'SqlType',
      statusCode: 'StatusCode',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      pageNumer: 'number',
      pageSize: 'number',
      sqlType: 'string',
      statusCode: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataImportSQLPreCheckDetailResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  preCheckSQLDetailList?: ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList[];
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      preCheckSQLDetailList: 'PreCheckSQLDetailList',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      preCheckSQLDetailList: { 'type': 'array', 'itemType': ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList },
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataImportSQLPreCheckDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDataImportSQLPreCheckDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDataImportSQLPreCheckDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataImportSQLTypeRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataImportSQLTypeResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  sqlTypeResult?: string[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      sqlTypeResult: 'SqlTypeResult',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      sqlTypeResult: { 'type': 'array', 'itemType': 'string' },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataImportSQLTypeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDataImportSQLTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDataImportSQLTypeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabaseUserPermssionsRequest extends $tea.Model {
  dbId?: string;
  logic?: boolean;
  pageNumber?: number;
  pageSize?: number;
  permType?: string;
  tid?: number;
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      logic: 'Logic',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      permType: 'PermType',
      tid: 'Tid',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'string',
      logic: 'boolean',
      pageNumber: 'number',
      pageSize: 'number',
      permType: 'string',
      tid: 'number',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabaseUserPermssionsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  userPermissions?: ListDatabaseUserPermssionsResponseBodyUserPermissions;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
      userPermissions: 'UserPermissions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
      userPermissions: ListDatabaseUserPermssionsResponseBodyUserPermissions,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabaseUserPermssionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDatabaseUserPermssionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDatabaseUserPermssionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabasesRequest extends $tea.Model {
  instanceId?: string;
  pageNumber?: number;
  pageSize?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabasesResponseBody extends $tea.Model {
  databaseList?: ListDatabasesResponseBodyDatabaseList;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      databaseList: 'DatabaseList',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseList: ListDatabasesResponseBodyDatabaseList,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabasesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDatabasesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDatabasesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDefaultSLARulesRequest extends $tea.Model {
  dagId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDefaultSLARulesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  SLARuleList?: ListDefaultSLARulesResponseBodySLARuleList;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      SLARuleList: 'SLARuleList',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      SLARuleList: ListDefaultSLARulesResponseBodySLARuleList,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDefaultSLARulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDefaultSLARulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDefaultSLARulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDesensitizationRuleRequest extends $tea.Model {
  funcType?: string;
  pageNumber?: number;
  pageSize?: number;
  ruleId?: number;
  ruleName?: string;
  ruleType?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      funcType: 'FuncType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      ruleType: 'RuleType',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      funcType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      ruleId: 'number',
      ruleName: 'string',
      ruleType: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDesensitizationRuleResponseBody extends $tea.Model {
  desensitizationRuleList?: ListDesensitizationRuleResponseBodyDesensitizationRuleList[];
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      desensitizationRuleList: 'DesensitizationRuleList',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desensitizationRuleList: { 'type': 'array', 'itemType': ListDesensitizationRuleResponseBodyDesensitizationRuleList },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDesensitizationRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDesensitizationRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDesensitizationRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEffectiveOrdersRequest extends $tea.Model {
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEffectiveOrdersResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  orderSummary?: ListEffectiveOrdersResponseBodyOrderSummary[];
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      orderSummary: 'OrderSummary',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      orderSummary: { 'type': 'array', 'itemType': ListEffectiveOrdersResponseBodyOrderSummary },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEffectiveOrdersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEffectiveOrdersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEffectiveOrdersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListIndexesRequest extends $tea.Model {
  logic?: boolean;
  tableId?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      logic: 'Logic',
      tableId: 'TableId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logic: 'boolean',
      tableId: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListIndexesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  indexList?: ListIndexesResponseBodyIndexList;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      indexList: 'IndexList',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      indexList: ListIndexesResponseBodyIndexList,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListIndexesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListIndexesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListIndexesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceLoginAuditLogRequest extends $tea.Model {
  endTime?: string;
  opUserName?: string;
  pageNumber?: number;
  pageSize?: number;
  searchName?: string;
  startTime?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      opUserName: 'OpUserName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchName: 'SearchName',
      startTime: 'StartTime',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      opUserName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchName: 'string',
      startTime: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceLoginAuditLogResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  instanceLoginAuditLogList?: ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      instanceLoginAuditLogList: 'InstanceLoginAuditLogList',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      instanceLoginAuditLogList: ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList,
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceLoginAuditLogResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListInstanceLoginAuditLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListInstanceLoginAuditLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceUserPermissionsRequest extends $tea.Model {
  instanceId?: string;
  pageNumber?: number;
  pageSize?: number;
  tid?: number;
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tid: 'Tid',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      tid: 'number',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceUserPermissionsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  userPermissions?: ListInstanceUserPermissionsResponseBodyUserPermissions;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
      userPermissions: 'UserPermissions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
      userPermissions: ListInstanceUserPermissionsResponseBodyUserPermissions,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceUserPermissionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListInstanceUserPermissionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListInstanceUserPermissionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstancesRequest extends $tea.Model {
  dbType?: string;
  envType?: string;
  instanceSource?: string;
  instanceState?: string;
  netType?: string;
  pageNumber?: number;
  pageSize?: number;
  searchKey?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dbType: 'DbType',
      envType: 'EnvType',
      instanceSource: 'InstanceSource',
      instanceState: 'InstanceState',
      netType: 'NetType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchKey: 'SearchKey',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbType: 'string',
      envType: 'string',
      instanceSource: 'string',
      instanceState: 'string',
      netType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchKey: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstancesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  instanceList?: ListInstancesResponseBodyInstanceList;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      instanceList: 'InstanceList',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      instanceList: ListInstancesResponseBodyInstanceList,
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLhTaskFlowAndScenarioRequest extends $tea.Model {
  spaceId?: number;
  tid?: number;
  userId?: number;
  static names(): { [key: string]: string } {
    return {
      spaceId: 'SpaceId',
      tid: 'Tid',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      spaceId: 'number',
      tid: 'number',
      userId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLhTaskFlowAndScenarioResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  rawDAGList?: ListLhTaskFlowAndScenarioResponseBodyRawDAGList;
  requestId?: string;
  scenarioDAGList?: ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      rawDAGList: 'RawDAGList',
      requestId: 'RequestId',
      scenarioDAGList: 'ScenarioDAGList',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      rawDAGList: ListLhTaskFlowAndScenarioResponseBodyRawDAGList,
      requestId: 'string',
      scenarioDAGList: ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLhTaskFlowAndScenarioResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListLhTaskFlowAndScenarioResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListLhTaskFlowAndScenarioResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicDatabasesRequest extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicDatabasesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  logicDatabaseList?: ListLogicDatabasesResponseBodyLogicDatabaseList;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      logicDatabaseList: 'LogicDatabaseList',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      logicDatabaseList: ListLogicDatabasesResponseBodyLogicDatabaseList,
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicDatabasesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListLogicDatabasesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListLogicDatabasesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicTableRouteConfigRequest extends $tea.Model {
  tableId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      tableId: 'TableId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tableId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicTableRouteConfigResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  logicTableRouteConfigList?: ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      logicTableRouteConfigList: 'LogicTableRouteConfigList',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      logicTableRouteConfigList: ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicTableRouteConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListLogicTableRouteConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListLogicTableRouteConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicTablesRequest extends $tea.Model {
  databaseId?: string;
  pageNumber?: number;
  pageSize?: number;
  returnGuid?: boolean;
  searchName?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      databaseId: 'DatabaseId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      returnGuid: 'ReturnGuid',
      searchName: 'SearchName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      returnGuid: 'boolean',
      searchName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicTablesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  logicTableList?: ListLogicTablesResponseBodyLogicTableList;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      logicTableList: 'LogicTableList',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      logicTableList: ListLogicTablesResponseBodyLogicTableList,
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicTablesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListLogicTablesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListLogicTablesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrdersRequest extends $tea.Model {
  endTime?: string;
  orderResultType?: string;
  orderStatus?: string;
  pageNumber?: number;
  pageSize?: number;
  pluginType?: string;
  searchContent?: string;
  searchDateType?: string;
  startTime?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      orderResultType: 'OrderResultType',
      orderStatus: 'OrderStatus',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      pluginType: 'PluginType',
      searchContent: 'SearchContent',
      searchDateType: 'SearchDateType',
      startTime: 'StartTime',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      orderResultType: 'string',
      orderStatus: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      pluginType: 'string',
      searchContent: 'string',
      searchDateType: 'string',
      startTime: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrdersResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  orders?: ListOrdersResponseBodyOrders;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      orders: 'Orders',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      orders: ListOrdersResponseBodyOrders,
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrdersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListOrdersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListOrdersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProxiesRequest extends $tea.Model {
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProxiesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  proxyList?: ListProxiesResponseBodyProxyList[];
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      proxyList: 'ProxyList',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      proxyList: { 'type': 'array', 'itemType': ListProxiesResponseBodyProxyList },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProxiesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProxiesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProxiesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProxyAccessesRequest extends $tea.Model {
  proxyId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      proxyId: 'ProxyId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      proxyId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProxyAccessesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  proxyAccessList?: ListProxyAccessesResponseBodyProxyAccessList[];
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      proxyAccessList: 'ProxyAccessList',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      proxyAccessList: { 'type': 'array', 'itemType': ListProxyAccessesResponseBodyProxyAccessList },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProxyAccessesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProxyAccessesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProxyAccessesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProxySQLExecAuditLogRequest extends $tea.Model {
  endTime?: number;
  execState?: string;
  opUserName?: string;
  pageNumber?: number;
  pageSize?: number;
  SQLType?: string;
  searchName?: string;
  startTime?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      execState: 'ExecState',
      opUserName: 'OpUserName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      SQLType: 'SQLType',
      searchName: 'SearchName',
      startTime: 'StartTime',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      execState: 'string',
      opUserName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      SQLType: 'string',
      searchName: 'string',
      startTime: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProxySQLExecAuditLogResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  proxySQLExecAuditLogList?: ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      proxySQLExecAuditLogList: 'ProxySQLExecAuditLogList',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      proxySQLExecAuditLogList: ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList,
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProxySQLExecAuditLogResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProxySQLExecAuditLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProxySQLExecAuditLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSLARulesRequest extends $tea.Model {
  dagId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSLARulesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  SLARuleList?: ListSLARulesResponseBodySLARuleList;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      SLARuleList: 'SLARuleList',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      SLARuleList: ListSLARulesResponseBodySLARuleList,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSLARulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSLARulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSLARulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSQLExecAuditLogRequest extends $tea.Model {
  endTime?: string;
  execState?: string;
  opUserName?: string;
  pageNumber?: number;
  pageSize?: number;
  searchName?: string;
  sqlType?: string;
  startTime?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      execState: 'ExecState',
      opUserName: 'OpUserName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchName: 'SearchName',
      sqlType: 'SqlType',
      startTime: 'StartTime',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      execState: 'string',
      opUserName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchName: 'string',
      sqlType: 'string',
      startTime: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSQLExecAuditLogResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  SQLExecAuditLogList?: ListSQLExecAuditLogResponseBodySQLExecAuditLogList;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      SQLExecAuditLogList: 'SQLExecAuditLogList',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      SQLExecAuditLogList: ListSQLExecAuditLogResponseBodySQLExecAuditLogList,
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSQLExecAuditLogResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSQLExecAuditLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSQLExecAuditLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSQLReviewOriginSQLRequest extends $tea.Model {
  orderActionDetail?: ListSQLReviewOriginSQLRequestOrderActionDetail;
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderActionDetail: 'OrderActionDetail',
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderActionDetail: ListSQLReviewOriginSQLRequestOrderActionDetail,
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSQLReviewOriginSQLShrinkRequest extends $tea.Model {
  orderActionDetailShrink?: string;
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderActionDetailShrink: 'OrderActionDetail',
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderActionDetailShrink: 'string',
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSQLReviewOriginSQLResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  originSQLList?: ListSQLReviewOriginSQLResponseBodyOriginSQLList[];
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      originSQLList: 'OriginSQLList',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      originSQLList: { 'type': 'array', 'itemType': ListSQLReviewOriginSQLResponseBodyOriginSQLList },
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSQLReviewOriginSQLResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSQLReviewOriginSQLResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSQLReviewOriginSQLResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScenariosRequest extends $tea.Model {
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScenariosResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  scenarioList?: ListScenariosResponseBodyScenarioList[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      scenarioList: 'ScenarioList',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      scenarioList: { 'type': 'array', 'itemType': ListScenariosResponseBodyScenarioList },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScenariosResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListScenariosResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListScenariosResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnInfoRequest extends $tea.Model {
  columnName?: string;
  instanceId?: number;
  pageNumber?: number;
  pageSize?: number;
  schemaName?: string;
  tableName?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      schemaName: 'SchemaName',
      tableName: 'TableName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      instanceId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      schemaName: 'string',
      tableName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnInfoResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  sensitiveColumnList?: ListSensitiveColumnInfoResponseBodySensitiveColumnList;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      sensitiveColumnList: 'SensitiveColumnList',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      sensitiveColumnList: ListSensitiveColumnInfoResponseBodySensitiveColumnList,
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSensitiveColumnInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSensitiveColumnInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnsRequest extends $tea.Model {
  columnName?: string;
  dbId?: number;
  logic?: boolean;
  pageNumber?: number;
  pageSize?: number;
  schemaName?: string;
  securityLevel?: string;
  tableName?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      dbId: 'DbId',
      logic: 'Logic',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      schemaName: 'SchemaName',
      securityLevel: 'SecurityLevel',
      tableName: 'TableName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      dbId: 'number',
      logic: 'boolean',
      pageNumber: 'number',
      pageSize: 'number',
      schemaName: 'string',
      securityLevel: 'string',
      tableName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  sensitiveColumnList?: ListSensitiveColumnsResponseBodySensitiveColumnList;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      sensitiveColumnList: 'SensitiveColumnList',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      sensitiveColumnList: ListSensitiveColumnsResponseBodySensitiveColumnList,
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSensitiveColumnsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSensitiveColumnsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnsDetailRequest extends $tea.Model {
  columnName?: string;
  dbId?: number;
  logic?: boolean;
  schemaName?: string;
  tableName?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      dbId: 'DbId',
      logic: 'Logic',
      schemaName: 'SchemaName',
      tableName: 'TableName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      dbId: 'number',
      logic: 'boolean',
      schemaName: 'string',
      tableName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnsDetailResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  sensitiveColumnsDetailList?: ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      sensitiveColumnsDetailList: 'SensitiveColumnsDetailList',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      sensitiveColumnsDetailList: ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnsDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSensitiveColumnsDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSensitiveColumnsDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveDataAuditLogRequest extends $tea.Model {
  columnName?: string;
  dbName?: string;
  endTime?: string;
  moduleName?: string;
  opUserName?: string;
  pageNumber?: number;
  pageSize?: number;
  startTime?: string;
  tableName?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      dbName: 'DbName',
      endTime: 'EndTime',
      moduleName: 'ModuleName',
      opUserName: 'OpUserName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startTime: 'StartTime',
      tableName: 'TableName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      dbName: 'string',
      endTime: 'string',
      moduleName: 'string',
      opUserName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startTime: 'string',
      tableName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveDataAuditLogResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  sensitiveDataAuditLogList?: ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList[];
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      sensitiveDataAuditLogList: 'SensitiveDataAuditLogList',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      sensitiveDataAuditLogList: { 'type': 'array', 'itemType': ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList },
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveDataAuditLogResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSensitiveDataAuditLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSensitiveDataAuditLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitivityLevelRequest extends $tea.Model {
  templateId?: number;
  templateType?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      templateId: 'TemplateId',
      templateType: 'TemplateType',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      templateId: 'number',
      templateType: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitivityLevelResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  sensitivityLevelList?: ListSensitivityLevelResponseBodySensitivityLevelList[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      sensitivityLevelList: 'SensitivityLevelList',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      sensitivityLevelList: { 'type': 'array', 'itemType': ListSensitivityLevelResponseBodySensitivityLevelList },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitivityLevelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSensitivityLevelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSensitivityLevelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListStandardGroupsRequest extends $tea.Model {
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListStandardGroupsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  standardGroupList?: ListStandardGroupsResponseBodyStandardGroupList[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      standardGroupList: 'StandardGroupList',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      standardGroupList: { 'type': 'array', 'itemType': ListStandardGroupsResponseBodyStandardGroupList },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListStandardGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListStandardGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListStandardGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTablesRequest extends $tea.Model {
  databaseId?: string;
  pageNumber?: number;
  pageSize?: number;
  returnGuid?: boolean;
  searchName?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      databaseId: 'DatabaseId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      returnGuid: 'ReturnGuid',
      searchName: 'SearchName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      returnGuid: 'boolean',
      searchName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTablesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  tableList?: ListTablesResponseBodyTableList;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      tableList: 'TableList',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      tableList: ListTablesResponseBodyTableList,
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTablesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTablesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTablesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowRequest extends $tea.Model {
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  taskFlowList?: ListTaskFlowResponseBodyTaskFlowList;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      taskFlowList: 'TaskFlowList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      taskFlowList: ListTaskFlowResponseBodyTaskFlowList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTaskFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTaskFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowConstantsRequest extends $tea.Model {
  dagId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowConstantsResponseBody extends $tea.Model {
  dagConstants?: ListTaskFlowConstantsResponseBodyDagConstants;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      dagConstants: 'DagConstants',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagConstants: ListTaskFlowConstantsResponseBodyDagConstants,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowConstantsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTaskFlowConstantsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTaskFlowConstantsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowCooperatorsRequest extends $tea.Model {
  dagId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowCooperatorsResponseBody extends $tea.Model {
  cooperatorList?: ListTaskFlowCooperatorsResponseBodyCooperatorList;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      cooperatorList: 'CooperatorList',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cooperatorList: ListTaskFlowCooperatorsResponseBodyCooperatorList,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowCooperatorsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTaskFlowCooperatorsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTaskFlowCooperatorsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowEdgesByConditionRequest extends $tea.Model {
  dagId?: number;
  id?: number;
  nodeEnd?: number;
  nodeFrom?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      id: 'Id',
      nodeEnd: 'NodeEnd',
      nodeFrom: 'NodeFrom',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      id: 'number',
      nodeEnd: 'number',
      nodeFrom: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowEdgesByConditionResponseBody extends $tea.Model {
  edges?: ListTaskFlowEdgesByConditionResponseBodyEdges;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      edges: 'Edges',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      edges: ListTaskFlowEdgesByConditionResponseBodyEdges,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowEdgesByConditionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTaskFlowEdgesByConditionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTaskFlowEdgesByConditionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowInstanceRequest extends $tea.Model {
  dagId?: number;
  pageIndex?: number;
  pageSize?: number;
  startTimeBegin?: string;
  startTimeEnd?: string;
  status?: number;
  tid?: number;
  triggerType?: number;
  useBizDate?: boolean;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      pageIndex: 'PageIndex',
      pageSize: 'PageSize',
      startTimeBegin: 'StartTimeBegin',
      startTimeEnd: 'StartTimeEnd',
      status: 'Status',
      tid: 'Tid',
      triggerType: 'TriggerType',
      useBizDate: 'UseBizDate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      pageIndex: 'number',
      pageSize: 'number',
      startTimeBegin: 'string',
      startTimeEnd: 'string',
      status: 'number',
      tid: 'number',
      triggerType: 'number',
      useBizDate: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowInstanceResponseBody extends $tea.Model {
  DAGInstanceList?: ListTaskFlowInstanceResponseBodyDAGInstanceList;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      DAGInstanceList: 'DAGInstanceList',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DAGInstanceList: ListTaskFlowInstanceResponseBodyDAGInstanceList,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTaskFlowInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTaskFlowInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowTimeVariablesRequest extends $tea.Model {
  dagId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowTimeVariablesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  timeVariables?: ListTaskFlowTimeVariablesResponseBodyTimeVariables;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      timeVariables: 'TimeVariables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      timeVariables: ListTaskFlowTimeVariablesResponseBodyTimeVariables,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowTimeVariablesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTaskFlowTimeVariablesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTaskFlowTimeVariablesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowsByPageRequest extends $tea.Model {
  dagIdList?: number[];
  pageIndex?: number;
  pageSize?: number;
  scenarioId?: number;
  searchKey?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagIdList: 'DagIdList',
      pageIndex: 'PageIndex',
      pageSize: 'PageSize',
      scenarioId: 'ScenarioId',
      searchKey: 'SearchKey',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagIdList: { 'type': 'array', 'itemType': 'number' },
      pageIndex: 'number',
      pageSize: 'number',
      scenarioId: 'number',
      searchKey: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowsByPageShrinkRequest extends $tea.Model {
  dagIdListShrink?: string;
  pageIndex?: number;
  pageSize?: number;
  scenarioId?: number;
  searchKey?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagIdListShrink: 'DagIdList',
      pageIndex: 'PageIndex',
      pageSize: 'PageSize',
      scenarioId: 'ScenarioId',
      searchKey: 'SearchKey',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagIdListShrink: 'string',
      pageIndex: 'number',
      pageSize: 'number',
      scenarioId: 'number',
      searchKey: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowsByPageResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  taskFlowList?: ListTaskFlowsByPageResponseBodyTaskFlowList;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      taskFlowList: 'TaskFlowList',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      taskFlowList: ListTaskFlowsByPageResponseBodyTaskFlowList,
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowsByPageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTaskFlowsByPageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTaskFlowsByPageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTasksInTaskFlowRequest extends $tea.Model {
  dagId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTasksInTaskFlowResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  tasks?: ListTasksInTaskFlowResponseBodyTasks;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      tasks: 'Tasks',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      tasks: ListTasksInTaskFlowResponseBodyTasks,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTasksInTaskFlowResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTasksInTaskFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTasksInTaskFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserPermissionsRequest extends $tea.Model {
  databaseName?: string;
  dbType?: string;
  envType?: string;
  logic?: boolean;
  pageNumber?: number;
  pageSize?: number;
  permType?: string;
  searchKey?: string;
  tid?: number;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      databaseName: 'DatabaseName',
      dbType: 'DbType',
      envType: 'EnvType',
      logic: 'Logic',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      permType: 'PermType',
      searchKey: 'SearchKey',
      tid: 'Tid',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseName: 'string',
      dbType: 'string',
      envType: 'string',
      logic: 'boolean',
      pageNumber: 'number',
      pageSize: 'number',
      permType: 'string',
      searchKey: 'string',
      tid: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserPermissionsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  userPermissions?: ListUserPermissionsResponseBodyUserPermissions;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
      userPermissions: 'UserPermissions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
      userPermissions: ListUserPermissionsResponseBodyUserPermissions,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserPermissionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListUserPermissionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListUserPermissionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserTenantsRequest extends $tea.Model {
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserTenantsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  tenantList?: ListUserTenantsResponseBodyTenantList[];
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      tenantList: 'TenantList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      tenantList: { 'type': 'array', 'itemType': ListUserTenantsResponseBodyTenantList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserTenantsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListUserTenantsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListUserTenantsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUsersRequest extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  role?: string;
  searchKey?: string;
  tid?: number;
  userState?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      role: 'Role',
      searchKey: 'SearchKey',
      tid: 'Tid',
      userState: 'UserState',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      role: 'string',
      searchKey: 'string',
      tid: 'number',
      userState: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUsersResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  totalCount?: number;
  userList?: ListUsersResponseBodyUserList;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
      userList: 'UserList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
      userList: ListUsersResponseBodyUserList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUsersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListUsersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListUsersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowNodesRequest extends $tea.Model {
  searchName?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      searchName: 'SearchName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      searchName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowNodesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  workflowNodes?: ListWorkFlowNodesResponseBodyWorkflowNodes;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      workflowNodes: 'WorkflowNodes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      workflowNodes: ListWorkFlowNodesResponseBodyWorkflowNodes,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowNodesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWorkFlowNodesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWorkFlowNodesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowTemplatesRequest extends $tea.Model {
  searchName?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      searchName: 'SearchName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      searchName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowTemplatesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  workFlowTemplates?: ListWorkFlowTemplatesResponseBodyWorkFlowTemplates;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      workFlowTemplates: 'WorkFlowTemplates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      workFlowTemplates: ListWorkFlowTemplatesResponseBodyWorkFlowTemplates,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowTemplatesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWorkFlowTemplatesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWorkFlowTemplatesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MakeTaskFlowInstanceSuccessRequest extends $tea.Model {
  dagId?: number;
  dagInstanceId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      dagInstanceId: 'DagInstanceId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      dagInstanceId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MakeTaskFlowInstanceSuccessResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MakeTaskFlowInstanceSuccessResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: MakeTaskFlowInstanceSuccessResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: MakeTaskFlowInstanceSuccessResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDataCorrectExecSQLRequest extends $tea.Model {
  execSQL?: string;
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      execSQL: 'ExecSQL',
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      execSQL: 'string',
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDataCorrectExecSQLResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDataCorrectExecSQLResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyDataCorrectExecSQLResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyDataCorrectExecSQLResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDesensitizationStrategyRequest extends $tea.Model {
  columnName?: string;
  dbId?: number;
  isDefault?: boolean;
  isLogic?: boolean;
  isReset?: boolean;
  ruleId?: number;
  schemaName?: string;
  tableName?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      dbId: 'DbId',
      isDefault: 'IsDefault',
      isLogic: 'IsLogic',
      isReset: 'IsReset',
      ruleId: 'RuleId',
      schemaName: 'SchemaName',
      tableName: 'TableName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      dbId: 'number',
      isDefault: 'boolean',
      isLogic: 'boolean',
      isReset: 'boolean',
      ruleId: 'number',
      schemaName: 'string',
      tableName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDesensitizationStrategyResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: boolean;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: 'boolean',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDesensitizationStrategyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyDesensitizationStrategyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyDesensitizationStrategyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceRequest extends $tea.Model {
  dataLinkName?: string;
  databasePassword?: string;
  databaseUser?: string;
  dbaId?: number;
  ddlOnline?: number;
  ecsInstanceId?: string;
  ecsRegion?: string;
  enableSellCommon?: string;
  enableSellSitd?: string;
  enableSellStable?: string;
  enableSellTrust?: string;
  envType?: string;
  exportTimeout?: number;
  host?: string;
  instanceAlias?: string;
  instanceId?: string;
  instanceSource?: string;
  instanceType?: string;
  networkType?: string;
  port?: number;
  queryTimeout?: number;
  safeRule?: string;
  sid?: string;
  skipTest?: boolean;
  templateId?: number;
  templateType?: string;
  tid?: number;
  useDsql?: number;
  useSsl?: number;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      dataLinkName: 'DataLinkName',
      databasePassword: 'DatabasePassword',
      databaseUser: 'DatabaseUser',
      dbaId: 'DbaId',
      ddlOnline: 'DdlOnline',
      ecsInstanceId: 'EcsInstanceId',
      ecsRegion: 'EcsRegion',
      enableSellCommon: 'EnableSellCommon',
      enableSellSitd: 'EnableSellSitd',
      enableSellStable: 'EnableSellStable',
      enableSellTrust: 'EnableSellTrust',
      envType: 'EnvType',
      exportTimeout: 'ExportTimeout',
      host: 'Host',
      instanceAlias: 'InstanceAlias',
      instanceId: 'InstanceId',
      instanceSource: 'InstanceSource',
      instanceType: 'InstanceType',
      networkType: 'NetworkType',
      port: 'Port',
      queryTimeout: 'QueryTimeout',
      safeRule: 'SafeRule',
      sid: 'Sid',
      skipTest: 'SkipTest',
      templateId: 'TemplateId',
      templateType: 'TemplateType',
      tid: 'Tid',
      useDsql: 'UseDsql',
      useSsl: 'UseSsl',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataLinkName: 'string',
      databasePassword: 'string',
      databaseUser: 'string',
      dbaId: 'number',
      ddlOnline: 'number',
      ecsInstanceId: 'string',
      ecsRegion: 'string',
      enableSellCommon: 'string',
      enableSellSitd: 'string',
      enableSellStable: 'string',
      enableSellTrust: 'string',
      envType: 'string',
      exportTimeout: 'number',
      host: 'string',
      instanceAlias: 'string',
      instanceId: 'string',
      instanceSource: 'string',
      instanceType: 'string',
      networkType: 'string',
      port: 'number',
      queryTimeout: 'number',
      safeRule: 'string',
      sid: 'string',
      skipTest: 'boolean',
      templateId: 'number',
      templateType: 'string',
      tid: 'number',
      useDsql: 'number',
      useSsl: 'number',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MoveTaskFlowToScenarioRequest extends $tea.Model {
  dagId?: number;
  scenarioId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      scenarioId: 'ScenarioId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      scenarioId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MoveTaskFlowToScenarioResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MoveTaskFlowToScenarioResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: MoveTaskFlowToScenarioResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: MoveTaskFlowToScenarioResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OfflineTaskFlowRequest extends $tea.Model {
  dagId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OfflineTaskFlowResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OfflineTaskFlowResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: OfflineTaskFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OfflineTaskFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PauseDataCorrectSQLJobRequest extends $tea.Model {
  jobId?: number;
  orderId?: number;
  tid?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
      orderId: 'OrderId',
      tid: 'Tid',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'number',
      orderId: 'number',
      tid: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PauseDataCorrectSQLJobResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PauseDataCorrectSQLJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PauseDataCorrectSQLJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PauseDataCorrectSQLJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreviewWorkflowRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreviewWorkflowResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  workflowDetail?: PreviewWorkflowResponseBodyWorkflowDetail;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      workflowDetail: 'WorkflowDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      workflowDetail: PreviewWorkflowResponseBodyWorkflowDetail,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreviewWorkflowResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PreviewWorkflowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PreviewWorkflowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishAndDeployTaskFlowRequest extends $tea.Model {
  dagId?: number;
  tid?: number;
  versionComments?: string;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
      versionComments: 'VersionComments',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
      versionComments: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishAndDeployTaskFlowResponseBody extends $tea.Model {
  deployId?: number;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      deployId: 'DeployId',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deployId: 'number',
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishAndDeployTaskFlowResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PublishAndDeployTaskFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PublishAndDeployTaskFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDataTrackResultDownloadStatusRequest extends $tea.Model {
  downloadKeyId?: string;
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      downloadKeyId: 'DownloadKeyId',
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadKeyId: 'string',
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDataTrackResultDownloadStatusResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  statusResult?: QueryDataTrackResultDownloadStatusResponseBodyStatusResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      statusResult: 'StatusResult',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      statusResult: QueryDataTrackResultDownloadStatusResponseBodyStatusResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDataTrackResultDownloadStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryDataTrackResultDownloadStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDataTrackResultDownloadStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReDeployLhDagVersionRequest extends $tea.Model {
  dagId?: number;
  dagVersion?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      dagVersion: 'DagVersion',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      dagVersion: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReDeployLhDagVersionResponseBody extends $tea.Model {
  deployId?: number;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      deployId: 'DeployId',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deployId: 'number',
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReDeployLhDagVersionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ReDeployLhDagVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReDeployLhDagVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReRunTaskFlowInstanceRequest extends $tea.Model {
  dagId?: number;
  dagInstanceId?: number;
  dagVersion?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      dagInstanceId: 'DagInstanceId',
      dagVersion: 'DagVersion',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      dagInstanceId: 'number',
      dagVersion: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReRunTaskFlowInstanceResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReRunTaskFlowInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ReRunTaskFlowInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReRunTaskFlowInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefundPayAsYouGoOrderRequest extends $tea.Model {
  instanceId?: string;
  orderId?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      orderId: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefundPayAsYouGoOrderResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefundPayAsYouGoOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RefundPayAsYouGoOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RefundPayAsYouGoOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterInstanceRequest extends $tea.Model {
  dataLinkName?: string;
  databasePassword?: string;
  databaseUser?: string;
  dbaUid?: number;
  dbaUidByString?: string;
  ddlOnline?: number;
  ecsInstanceId?: string;
  ecsRegion?: string;
  enableSellSitd?: string;
  envType?: string;
  exportTimeout?: number;
  host?: string;
  instanceAlias?: string;
  instanceSource?: string;
  instanceType?: string;
  networkType?: string;
  port?: number;
  queryTimeout?: number;
  safeRule?: string;
  sid?: string;
  skipTest?: boolean;
  templateId?: number;
  templateType?: string;
  tid?: number;
  useDsql?: number;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      dataLinkName: 'DataLinkName',
      databasePassword: 'DatabasePassword',
      databaseUser: 'DatabaseUser',
      dbaUid: 'DbaUid',
      dbaUidByString: 'DbaUidByString',
      ddlOnline: 'DdlOnline',
      ecsInstanceId: 'EcsInstanceId',
      ecsRegion: 'EcsRegion',
      enableSellSitd: 'EnableSellSitd',
      envType: 'EnvType',
      exportTimeout: 'ExportTimeout',
      host: 'Host',
      instanceAlias: 'InstanceAlias',
      instanceSource: 'InstanceSource',
      instanceType: 'InstanceType',
      networkType: 'NetworkType',
      port: 'Port',
      queryTimeout: 'QueryTimeout',
      safeRule: 'SafeRule',
      sid: 'Sid',
      skipTest: 'SkipTest',
      templateId: 'TemplateId',
      templateType: 'TemplateType',
      tid: 'Tid',
      useDsql: 'UseDsql',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataLinkName: 'string',
      databasePassword: 'string',
      databaseUser: 'string',
      dbaUid: 'number',
      dbaUidByString: 'string',
      ddlOnline: 'number',
      ecsInstanceId: 'string',
      ecsRegion: 'string',
      enableSellSitd: 'string',
      envType: 'string',
      exportTimeout: 'number',
      host: 'string',
      instanceAlias: 'string',
      instanceSource: 'string',
      instanceType: 'string',
      networkType: 'string',
      port: 'number',
      queryTimeout: 'number',
      safeRule: 'string',
      sid: 'string',
      skipTest: 'boolean',
      templateId: 'number',
      templateType: 'string',
      tid: 'number',
      useDsql: 'number',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterInstanceResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RegisterInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RegisterInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterUserRequest extends $tea.Model {
  mobile?: string;
  roleNames?: string;
  tid?: number;
  uid?: string;
  userNick?: string;
  static names(): { [key: string]: string } {
    return {
      mobile: 'Mobile',
      roleNames: 'RoleNames',
      tid: 'Tid',
      uid: 'Uid',
      userNick: 'UserNick',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mobile: 'string',
      roleNames: 'string',
      tid: 'number',
      uid: 'string',
      userNick: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterUserResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterUserResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RegisterUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RegisterUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RestartDataCorrectSQLJobRequest extends $tea.Model {
  jobId?: number;
  orderId?: number;
  tid?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
      orderId: 'OrderId',
      tid: 'Tid',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'number',
      orderId: 'number',
      tid: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RestartDataCorrectSQLJobResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RestartDataCorrectSQLJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RestartDataCorrectSQLJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RestartDataCorrectSQLJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeTaskFlowInstanceRequest extends $tea.Model {
  dagId?: number;
  dagInstanceId?: number;
  dagVersion?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      dagInstanceId: 'DagInstanceId',
      dagVersion: 'DagVersion',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      dagInstanceId: 'number',
      dagVersion: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeTaskFlowInstanceResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeTaskFlowInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ResumeTaskFlowInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ResumeTaskFlowInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryDataCorrectPreCheckRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryDataCorrectPreCheckResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryDataCorrectPreCheckResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RetryDataCorrectPreCheckResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RetryDataCorrectPreCheckResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RevokeTemplateAuthorityRequest extends $tea.Model {
  templateId?: number;
  tid?: number;
  userIds?: string;
  static names(): { [key: string]: string } {
    return {
      templateId: 'TemplateId',
      tid: 'Tid',
      userIds: 'UserIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      templateId: 'number',
      tid: 'number',
      userIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RevokeTemplateAuthorityResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  result?: boolean;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: 'boolean',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RevokeTemplateAuthorityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RevokeTemplateAuthorityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RevokeTemplateAuthorityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RevokeUserPermissionRequest extends $tea.Model {
  dbId?: string;
  dsType?: string;
  instanceId?: number;
  logic?: boolean;
  permTypes?: string;
  tableId?: string;
  tableName?: string;
  tid?: number;
  userAccessId?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      dsType: 'DsType',
      instanceId: 'InstanceId',
      logic: 'Logic',
      permTypes: 'PermTypes',
      tableId: 'TableId',
      tableName: 'TableName',
      tid: 'Tid',
      userAccessId: 'UserAccessId',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'string',
      dsType: 'string',
      instanceId: 'number',
      logic: 'boolean',
      permTypes: 'string',
      tableId: 'string',
      tableName: 'string',
      tid: 'number',
      userAccessId: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RevokeUserPermissionResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RevokeUserPermissionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RevokeUserPermissionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RevokeUserPermissionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDataTrackResultRequest extends $tea.Model {
  columnFilter?: SearchDataTrackResultRequestColumnFilter;
  filterEndTime?: string;
  filterStartTime?: string;
  filterTableList?: string[];
  filterTypeList?: string[];
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      columnFilter: 'ColumnFilter',
      filterEndTime: 'FilterEndTime',
      filterStartTime: 'FilterStartTime',
      filterTableList: 'FilterTableList',
      filterTypeList: 'FilterTypeList',
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnFilter: SearchDataTrackResultRequestColumnFilter,
      filterEndTime: 'string',
      filterStartTime: 'string',
      filterTableList: { 'type': 'array', 'itemType': 'string' },
      filterTypeList: { 'type': 'array', 'itemType': 'string' },
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDataTrackResultShrinkRequest extends $tea.Model {
  columnFilterShrink?: string;
  filterEndTime?: string;
  filterStartTime?: string;
  filterTableListShrink?: string;
  filterTypeListShrink?: string;
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      columnFilterShrink: 'ColumnFilter',
      filterEndTime: 'FilterEndTime',
      filterStartTime: 'FilterStartTime',
      filterTableListShrink: 'FilterTableList',
      filterTypeListShrink: 'FilterTypeList',
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnFilterShrink: 'string',
      filterEndTime: 'string',
      filterStartTime: 'string',
      filterTableListShrink: 'string',
      filterTypeListShrink: 'string',
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDataTrackResultResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  trackResult?: SearchDataTrackResultResponseBodyTrackResult;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      trackResult: 'TrackResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      trackResult: SearchDataTrackResultResponseBodyTrackResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDataTrackResultResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchDataTrackResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchDataTrackResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDatabaseRequest extends $tea.Model {
  dbType?: string;
  envType?: string;
  pageNumber?: number;
  pageSize?: number;
  searchKey?: string;
  searchRange?: string;
  searchTarget?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dbType: 'DbType',
      envType: 'EnvType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchKey: 'SearchKey',
      searchRange: 'SearchRange',
      searchTarget: 'SearchTarget',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbType: 'string',
      envType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchKey: 'string',
      searchRange: 'string',
      searchTarget: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDatabaseResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  searchDatabaseList?: SearchDatabaseResponseBodySearchDatabaseList;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      searchDatabaseList: 'SearchDatabaseList',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      searchDatabaseList: SearchDatabaseResponseBodySearchDatabaseList,
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDatabaseResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchDatabaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchDatabaseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTableRequest extends $tea.Model {
  dbType?: string;
  envType?: string;
  pageNumber?: number;
  pageSize?: number;
  returnGuid?: boolean;
  searchKey?: string;
  searchRange?: string;
  searchTarget?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dbType: 'DbType',
      envType: 'EnvType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      returnGuid: 'ReturnGuid',
      searchKey: 'SearchKey',
      searchRange: 'SearchRange',
      searchTarget: 'SearchTarget',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbType: 'string',
      envType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      returnGuid: 'boolean',
      searchKey: 'string',
      searchRange: 'string',
      searchTarget: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTableResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  searchTableList?: SearchTableResponseBodySearchTableList;
  success?: boolean;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      searchTableList: 'SearchTableList',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      searchTableList: SearchTableResponseBodySearchTableList,
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTableResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchTableResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchTableResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetOwnersRequest extends $tea.Model {
  ownerIds?: string;
  ownerType?: string;
  resourceId?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      ownerIds: 'OwnerIds',
      ownerType: 'OwnerType',
      resourceId: 'ResourceId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerIds: 'string',
      ownerType: 'string',
      resourceId: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetOwnersResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetOwnersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetOwnersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetOwnersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SkipDataCorrectRowCheckRequest extends $tea.Model {
  orderId?: number;
  reason?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      reason: 'Reason',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      reason: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SkipDataCorrectRowCheckResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SkipDataCorrectRowCheckResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SkipDataCorrectRowCheckResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SkipDataCorrectRowCheckResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopTaskFlowInstanceRequest extends $tea.Model {
  dagId?: number;
  dagInstanceId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      dagInstanceId: 'DagInstanceId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      dagInstanceId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopTaskFlowInstanceResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopTaskFlowInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StopTaskFlowInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopTaskFlowInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitOrderApprovalRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitOrderApprovalResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitOrderApprovalResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SubmitOrderApprovalResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SubmitOrderApprovalResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitStructSyncOrderApprovalRequest extends $tea.Model {
  orderId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitStructSyncOrderApprovalResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  workflowInstanceId?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      workflowInstanceId: 'WorkflowInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      workflowInstanceId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitStructSyncOrderApprovalResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SubmitStructSyncOrderApprovalResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SubmitStructSyncOrderApprovalResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SuspendTaskFlowInstanceRequest extends $tea.Model {
  dagId?: number;
  dagInstanceId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      dagInstanceId: 'DagInstanceId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      dagInstanceId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SuspendTaskFlowInstanceResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SuspendTaskFlowInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SuspendTaskFlowInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SuspendTaskFlowInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncDatabaseMetaRequest extends $tea.Model {
  dbId?: string;
  logic?: boolean;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      logic: 'Logic',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'string',
      logic: 'boolean',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncDatabaseMetaResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncDatabaseMetaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SyncDatabaseMetaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SyncDatabaseMetaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncInstanceMetaRequest extends $tea.Model {
  ignoreTable?: boolean;
  instanceId?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      ignoreTable: 'IgnoreTable',
      instanceId: 'InstanceId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ignoreTable: 'boolean',
      instanceId: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncInstanceMetaResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncInstanceMetaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SyncInstanceMetaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SyncInstanceMetaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAuthorityTemplateRequest extends $tea.Model {
  description?: string;
  name?: string;
  templateId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      templateId: 'TemplateId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      templateId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAuthorityTemplateResponseBody extends $tea.Model {
  authorityTemplateView?: UpdateAuthorityTemplateResponseBodyAuthorityTemplateView;
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      authorityTemplateView: 'AuthorityTemplateView',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorityTemplateView: UpdateAuthorityTemplateResponseBodyAuthorityTemplateView,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAuthorityTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateAuthorityTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateAuthorityTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateInstanceRequest extends $tea.Model {
  dataLinkName?: string;
  databasePassword?: string;
  databaseUser?: string;
  dbaId?: string;
  ddlOnline?: number;
  ecsInstanceId?: string;
  ecsRegion?: string;
  enableSellSitd?: string;
  envType?: string;
  exportTimeout?: number;
  host?: string;
  instanceAlias?: string;
  instanceId?: string;
  instanceSource?: string;
  instanceType?: string;
  port?: number;
  queryTimeout?: number;
  safeRuleId?: string;
  sid?: string;
  skipTest?: boolean;
  templateId?: number;
  templateType?: string;
  tid?: number;
  useDsql?: number;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      dataLinkName: 'DataLinkName',
      databasePassword: 'DatabasePassword',
      databaseUser: 'DatabaseUser',
      dbaId: 'DbaId',
      ddlOnline: 'DdlOnline',
      ecsInstanceId: 'EcsInstanceId',
      ecsRegion: 'EcsRegion',
      enableSellSitd: 'EnableSellSitd',
      envType: 'EnvType',
      exportTimeout: 'ExportTimeout',
      host: 'Host',
      instanceAlias: 'InstanceAlias',
      instanceId: 'InstanceId',
      instanceSource: 'InstanceSource',
      instanceType: 'InstanceType',
      port: 'Port',
      queryTimeout: 'QueryTimeout',
      safeRuleId: 'SafeRuleId',
      sid: 'Sid',
      skipTest: 'SkipTest',
      templateId: 'TemplateId',
      templateType: 'TemplateType',
      tid: 'Tid',
      useDsql: 'UseDsql',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataLinkName: 'string',
      databasePassword: 'string',
      databaseUser: 'string',
      dbaId: 'string',
      ddlOnline: 'number',
      ecsInstanceId: 'string',
      ecsRegion: 'string',
      enableSellSitd: 'string',
      envType: 'string',
      exportTimeout: 'number',
      host: 'string',
      instanceAlias: 'string',
      instanceId: 'string',
      instanceSource: 'string',
      instanceType: 'string',
      port: 'number',
      queryTimeout: 'number',
      safeRuleId: 'string',
      sid: 'string',
      skipTest: 'boolean',
      templateId: 'number',
      templateType: 'string',
      tid: 'number',
      useDsql: 'number',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateInstanceResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSLARulesRequest extends $tea.Model {
  dagId?: number;
  slaRuleList?: UpdateSLARulesRequestSlaRuleList[];
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      slaRuleList: 'SlaRuleList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      slaRuleList: { 'type': 'array', 'itemType': UpdateSLARulesRequestSlaRuleList },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSLARulesShrinkRequest extends $tea.Model {
  dagId?: number;
  slaRuleListShrink?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      slaRuleListShrink: 'SlaRuleList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      slaRuleListShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSLARulesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSLARulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateSLARulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSLARulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScenarioRequest extends $tea.Model {
  description?: string;
  scenarioId?: string;
  scenarioName?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      scenarioId: 'ScenarioId',
      scenarioName: 'ScenarioName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      scenarioId: 'string',
      scenarioName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScenarioResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScenarioResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateScenarioResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateScenarioResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateStandardGroupRequest extends $tea.Model {
  description?: string;
  groupId?: number;
  groupName?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      groupId: 'GroupId',
      groupName: 'GroupName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      groupId: 'number',
      groupName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateStandardGroupResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  standardGroup?: UpdateStandardGroupResponseBodyStandardGroup;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      standardGroup: 'StandardGroup',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      standardGroup: UpdateStandardGroupResponseBodyStandardGroup,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateStandardGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateStandardGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateStandardGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskConfigRequest extends $tea.Model {
  nodeConfig?: string;
  nodeId?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      nodeConfig: 'NodeConfig',
      nodeId: 'NodeId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeConfig: 'string',
      nodeId: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskConfigResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskContentRequest extends $tea.Model {
  nodeContent?: string;
  nodeId?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      nodeContent: 'NodeContent',
      nodeId: 'NodeId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeContent: 'string',
      nodeId: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskContentResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskContentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskContentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskContentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowConstantsRequest extends $tea.Model {
  dagConstants?: UpdateTaskFlowConstantsRequestDagConstants[];
  dagId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagConstants: 'DagConstants',
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagConstants: { 'type': 'array', 'itemType': UpdateTaskFlowConstantsRequestDagConstants },
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowConstantsShrinkRequest extends $tea.Model {
  dagConstantsShrink?: string;
  dagId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagConstantsShrink: 'DagConstants',
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagConstantsShrink: 'string',
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowConstantsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowConstantsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskFlowConstantsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskFlowConstantsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowCooperatorsRequest extends $tea.Model {
  cooperatorIds?: string[];
  dagId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      cooperatorIds: 'CooperatorIds',
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cooperatorIds: { 'type': 'array', 'itemType': 'string' },
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowCooperatorsShrinkRequest extends $tea.Model {
  cooperatorIdsShrink?: string;
  dagId?: number;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      cooperatorIdsShrink: 'CooperatorIds',
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cooperatorIdsShrink: 'string',
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowCooperatorsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowCooperatorsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskFlowCooperatorsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskFlowCooperatorsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowEdgesRequest extends $tea.Model {
  dagId?: number;
  edges?: UpdateTaskFlowEdgesRequestEdges[];
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      edges: 'Edges',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      edges: { 'type': 'array', 'itemType': UpdateTaskFlowEdgesRequestEdges },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowEdgesShrinkRequest extends $tea.Model {
  dagId?: number;
  edgesShrink?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      edgesShrink: 'Edges',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      edgesShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowEdgesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowEdgesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskFlowEdgesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskFlowEdgesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowNameAndDescRequest extends $tea.Model {
  dagId?: number;
  dagName?: string;
  description?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      dagName: 'DagName',
      description: 'Description',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      dagName: 'string',
      description: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowNameAndDescResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowNameAndDescResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskFlowNameAndDescResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskFlowNameAndDescResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowNotificationRequest extends $tea.Model {
  dagId?: number;
  dagNotificationFail?: boolean;
  dagNotificationSla?: boolean;
  dagNotificationSuccess?: boolean;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      dagNotificationFail: 'DagNotificationFail',
      dagNotificationSla: 'DagNotificationSla',
      dagNotificationSuccess: 'DagNotificationSuccess',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      dagNotificationFail: 'boolean',
      dagNotificationSla: 'boolean',
      dagNotificationSuccess: 'boolean',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowNotificationResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowNotificationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskFlowNotificationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskFlowNotificationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowOwnerRequest extends $tea.Model {
  dagId?: number;
  newOwnerId?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      newOwnerId: 'NewOwnerId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      newOwnerId: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowOwnerResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowOwnerResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskFlowOwnerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskFlowOwnerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowRelationsRequest extends $tea.Model {
  dagId?: number;
  edges?: UpdateTaskFlowRelationsRequestEdges[];
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      edges: 'Edges',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      edges: { 'type': 'array', 'itemType': UpdateTaskFlowRelationsRequestEdges },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowRelationsShrinkRequest extends $tea.Model {
  dagId?: number;
  edgesShrink?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      edgesShrink: 'Edges',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      edgesShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowRelationsResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowRelationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskFlowRelationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskFlowRelationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowScheduleRequest extends $tea.Model {
  cronBeginDate?: string;
  cronEndDate?: string;
  cronStr?: string;
  cronType?: string;
  dagId?: number;
  scheduleParam?: string;
  scheduleSwitch?: boolean;
  tid?: number;
  timeZoneId?: string;
  triggerType?: string;
  static names(): { [key: string]: string } {
    return {
      cronBeginDate: 'CronBeginDate',
      cronEndDate: 'CronEndDate',
      cronStr: 'CronStr',
      cronType: 'CronType',
      dagId: 'DagId',
      scheduleParam: 'ScheduleParam',
      scheduleSwitch: 'ScheduleSwitch',
      tid: 'Tid',
      timeZoneId: 'TimeZoneId',
      triggerType: 'TriggerType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cronBeginDate: 'string',
      cronEndDate: 'string',
      cronStr: 'string',
      cronType: 'string',
      dagId: 'number',
      scheduleParam: 'string',
      scheduleSwitch: 'boolean',
      tid: 'number',
      timeZoneId: 'string',
      triggerType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowScheduleResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowScheduleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskFlowScheduleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskFlowScheduleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowTimeVariablesRequest extends $tea.Model {
  dagId?: number;
  tid?: number;
  timeVariables?: string;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
      timeVariables: 'TimeVariables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
      timeVariables: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowTimeVariablesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowTimeVariablesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskFlowTimeVariablesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskFlowTimeVariablesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskNameRequest extends $tea.Model {
  nodeId?: string;
  nodeName?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'string',
      nodeName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskNameResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskNameResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskNameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskOutputRequest extends $tea.Model {
  nodeId?: string;
  nodeOutput?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      nodeOutput: 'NodeOutput',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'string',
      nodeOutput: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskOutputResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskOutputResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskOutputResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskOutputResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskTimeVariablesRequest extends $tea.Model {
  nodeId?: string;
  tid?: number;
  timeVariables?: string;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      tid: 'Tid',
      timeVariables: 'TimeVariables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'string',
      tid: 'number',
      timeVariables: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskTimeVariablesResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskTimeVariablesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskTimeVariablesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskTimeVariablesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserRequest extends $tea.Model {
  maxExecuteCount?: number;
  maxResultCount?: number;
  mobile?: string;
  roleNames?: string;
  tid?: number;
  uid?: number;
  userNick?: string;
  static names(): { [key: string]: string } {
    return {
      maxExecuteCount: 'MaxExecuteCount',
      maxResultCount: 'MaxResultCount',
      mobile: 'Mobile',
      roleNames: 'RoleNames',
      tid: 'Tid',
      uid: 'Uid',
      userNick: 'UserNick',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxExecuteCount: 'number',
      maxResultCount: 'number',
      mobile: 'string',
      roleNames: 'string',
      tid: 'number',
      uid: 'number',
      userNick: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserResponseBody extends $tea.Model {
  errorCode?: string;
  errorMessage?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLhMembersRequestMembers extends $tea.Model {
  roles?: string[];
  userId?: number;
  static names(): { [key: string]: string } {
    return {
      roles: 'Roles',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roles: { 'type': 'array', 'itemType': 'string' },
      userId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTaskFlowEdgesRequestEdges extends $tea.Model {
  nodeEnd?: number;
  nodeFrom?: number;
  static names(): { [key: string]: string } {
    return {
      nodeEnd: 'NodeEnd',
      nodeFrom: 'NodeFrom',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeEnd: 'number',
      nodeFrom: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTaskFlowEdgesResponseBodyEdgeIds extends $tea.Model {
  edgeId?: number[];
  static names(): { [key: string]: string } {
    return {
      edgeId: 'EdgeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      edgeId: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail extends $tea.Model {
  calWay?: string;
  code?: string;
  static names(): { [key: string]: string } {
    return {
      calWay: 'CalWay',
      code: 'Code',
    };
  }

  static types(): { [key: string]: any } {
    return {
      calWay: 'string',
      code: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AnalyzeSQLLineageResponseBodyLineageResultLineages extends $tea.Model {
  dst?: string;
  lineageType?: string;
  operType?: string;
  processDetail?: AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail;
  src?: string;
  static names(): { [key: string]: string } {
    return {
      dst: 'Dst',
      lineageType: 'LineageType',
      operType: 'OperType',
      processDetail: 'ProcessDetail',
      src: 'Src',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dst: 'string',
      lineageType: 'string',
      operType: 'string',
      processDetail: AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail,
      src: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields extends $tea.Model {
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata extends $tea.Model {
  fields?: AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields[];
  name?: string;
  source?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      fields: 'Fields',
      name: 'Name',
      source: 'Source',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fields: { 'type': 'array', 'itemType': AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields },
      name: 'string',
      source: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AnalyzeSQLLineageResponseBodyLineageResult extends $tea.Model {
  lineages?: AnalyzeSQLLineageResponseBodyLineageResultLineages[];
  objectMetadata?: AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata[];
  static names(): { [key: string]: string } {
    return {
      lineages: 'Lineages',
      objectMetadata: 'ObjectMetadata',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lineages: { 'type': 'array', 'itemType': AnalyzeSQLLineageResponseBodyLineageResultLineages },
      objectMetadata: { 'type': 'array', 'itemType': AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAuthorityTemplateResponseBodyAuthorityTemplateView extends $tea.Model {
  createTime?: string;
  creatorId?: number;
  description?: string;
  name?: string;
  templateId?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      creatorId: 'CreatorId',
      description: 'Description',
      name: 'Name',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      creatorId: 'number',
      description: 'string',
      name: 'string',
      templateId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataArchiveOrderRequestParamTableIncludes extends $tea.Model {
  tableName?: string;
  tableWhere?: string;
  static names(): { [key: string]: string } {
    return {
      tableName: 'TableName',
      tableWhere: 'TableWhere',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tableName: 'string',
      tableWhere: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataArchiveOrderRequestParamVariables extends $tea.Model {
  name?: string;
  pattern?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      pattern: 'Pattern',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      pattern: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataArchiveOrderRequestParam extends $tea.Model {
  archiveMethod?: string;
  cronStr?: string;
  databaseId?: string;
  logic?: boolean;
  orderAfter?: string[];
  runMethod?: string;
  sourceCatalogName?: string;
  sourceInstanceName?: string;
  sourceSchemaName?: string;
  tableIncludes?: CreateDataArchiveOrderRequestParamTableIncludes[];
  tableMapping?: string[];
  targetInstanceHost?: string;
  variables?: CreateDataArchiveOrderRequestParamVariables[];
  static names(): { [key: string]: string } {
    return {
      archiveMethod: 'ArchiveMethod',
      cronStr: 'CronStr',
      databaseId: 'DatabaseId',
      logic: 'Logic',
      orderAfter: 'OrderAfter',
      runMethod: 'RunMethod',
      sourceCatalogName: 'SourceCatalogName',
      sourceInstanceName: 'SourceInstanceName',
      sourceSchemaName: 'SourceSchemaName',
      tableIncludes: 'TableIncludes',
      tableMapping: 'TableMapping',
      targetInstanceHost: 'TargetInstanceHost',
      variables: 'Variables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      archiveMethod: 'string',
      cronStr: 'string',
      databaseId: 'string',
      logic: 'boolean',
      orderAfter: { 'type': 'array', 'itemType': 'string' },
      runMethod: 'string',
      sourceCatalogName: 'string',
      sourceInstanceName: 'string',
      sourceSchemaName: 'string',
      tableIncludes: { 'type': 'array', 'itemType': CreateDataArchiveOrderRequestParamTableIncludes },
      tableMapping: { 'type': 'array', 'itemType': 'string' },
      targetInstanceHost: 'string',
      variables: { 'type': 'array', 'itemType': CreateDataArchiveOrderRequestParamVariables },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataCorrectOrderRequestParamDbItemList extends $tea.Model {
  dbId?: number;
  logic?: boolean;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      logic: 'Logic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      logic: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataCorrectOrderRequestParam extends $tea.Model {
  attachmentName?: string;
  classify?: string;
  dbItemList?: CreateDataCorrectOrderRequestParamDbItemList[];
  estimateAffectRows?: number;
  execMode?: string;
  execSQL?: string;
  rollbackAttachmentName?: string;
  rollbackSQL?: string;
  rollbackSqlType?: string;
  sqlType?: string;
  static names(): { [key: string]: string } {
    return {
      attachmentName: 'AttachmentName',
      classify: 'Classify',
      dbItemList: 'DbItemList',
      estimateAffectRows: 'EstimateAffectRows',
      execMode: 'ExecMode',
      execSQL: 'ExecSQL',
      rollbackAttachmentName: 'RollbackAttachmentName',
      rollbackSQL: 'RollbackSQL',
      rollbackSqlType: 'RollbackSqlType',
      sqlType: 'SqlType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentName: 'string',
      classify: 'string',
      dbItemList: { 'type': 'array', 'itemType': CreateDataCorrectOrderRequestParamDbItemList },
      estimateAffectRows: 'number',
      execMode: 'string',
      execSQL: 'string',
      rollbackAttachmentName: 'string',
      rollbackSQL: 'string',
      rollbackSqlType: 'string',
      sqlType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataCronClearOrderRequestParamCronClearItemList extends $tea.Model {
  columnName?: string;
  filterSQL?: string;
  remainDays?: number;
  tableName?: string;
  timeUnit?: string;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      filterSQL: 'FilterSQL',
      remainDays: 'RemainDays',
      tableName: 'TableName',
      timeUnit: 'TimeUnit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      filterSQL: 'string',
      remainDays: 'number',
      tableName: 'string',
      timeUnit: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataCronClearOrderRequestParamDbItemList extends $tea.Model {
  dbId?: number;
  logic?: boolean;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      logic: 'Logic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      logic: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataCronClearOrderRequestParam extends $tea.Model {
  classify?: string;
  cronClearItemList?: CreateDataCronClearOrderRequestParamCronClearItemList[];
  cronFormat?: string;
  dbItemList?: CreateDataCronClearOrderRequestParamDbItemList[];
  durationHour?: number;
  specifyDuration?: boolean;
  static names(): { [key: string]: string } {
    return {
      classify: 'Classify',
      cronClearItemList: 'CronClearItemList',
      cronFormat: 'CronFormat',
      dbItemList: 'DbItemList',
      durationHour: 'DurationHour',
      specifyDuration: 'specifyDuration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      classify: 'string',
      cronClearItemList: { 'type': 'array', 'itemType': CreateDataCronClearOrderRequestParamCronClearItemList },
      cronFormat: 'string',
      dbItemList: { 'type': 'array', 'itemType': CreateDataCronClearOrderRequestParamDbItemList },
      durationHour: 'number',
      specifyDuration: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataExportOrderRequestPluginParamWatermark extends $tea.Model {
  columnName?: string;
  dataWatermark?: string;
  fileWatermark?: string;
  keys?: string[];
  watermarkTypes?: string[];
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      dataWatermark: 'DataWatermark',
      fileWatermark: 'FileWatermark',
      keys: 'Keys',
      watermarkTypes: 'WatermarkTypes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      dataWatermark: 'string',
      fileWatermark: 'string',
      keys: { 'type': 'array', 'itemType': 'string' },
      watermarkTypes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataExportOrderRequestPluginParam extends $tea.Model {
  affectRows?: number;
  classify?: string;
  dbId?: number;
  exeSQL?: string;
  ignoreAffectRows?: boolean;
  ignoreAffectRowsReason?: string;
  instanceId?: number;
  logic?: boolean;
  watermark?: CreateDataExportOrderRequestPluginParamWatermark;
  static names(): { [key: string]: string } {
    return {
      affectRows: 'AffectRows',
      classify: 'Classify',
      dbId: 'DbId',
      exeSQL: 'ExeSQL',
      ignoreAffectRows: 'IgnoreAffectRows',
      ignoreAffectRowsReason: 'IgnoreAffectRowsReason',
      instanceId: 'InstanceId',
      logic: 'Logic',
      watermark: 'Watermark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affectRows: 'number',
      classify: 'string',
      dbId: 'number',
      exeSQL: 'string',
      ignoreAffectRows: 'boolean',
      ignoreAffectRowsReason: 'string',
      instanceId: 'number',
      logic: 'boolean',
      watermark: CreateDataExportOrderRequestPluginParamWatermark,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataExportOrderResponseBodyCreateOrderResult extends $tea.Model {
  createOrderResult?: number[];
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataImportOrderRequestParamDbItemList extends $tea.Model {
  dbId?: number;
  logic?: boolean;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      logic: 'Logic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      logic: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataImportOrderRequestParam extends $tea.Model {
  attachmentName?: string;
  classify?: string;
  csvFirstRowIsColumnDef?: boolean;
  dbItemList?: CreateDataImportOrderRequestParamDbItemList[];
  fileEncoding?: string;
  fileType?: string;
  ignoreError?: boolean;
  importMode?: string;
  insertType?: string;
  rollbackAttachmentName?: string;
  rollbackSQL?: string;
  rollbackSqlType?: string;
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      attachmentName: 'AttachmentName',
      classify: 'Classify',
      csvFirstRowIsColumnDef: 'CsvFirstRowIsColumnDef',
      dbItemList: 'DbItemList',
      fileEncoding: 'FileEncoding',
      fileType: 'FileType',
      ignoreError: 'IgnoreError',
      importMode: 'ImportMode',
      insertType: 'InsertType',
      rollbackAttachmentName: 'RollbackAttachmentName',
      rollbackSQL: 'RollbackSQL',
      rollbackSqlType: 'RollbackSqlType',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentName: 'string',
      classify: 'string',
      csvFirstRowIsColumnDef: 'boolean',
      dbItemList: { 'type': 'array', 'itemType': CreateDataImportOrderRequestParamDbItemList },
      fileEncoding: 'string',
      fileType: 'string',
      ignoreError: 'boolean',
      importMode: 'string',
      insertType: 'string',
      rollbackAttachmentName: 'string',
      rollbackSQL: 'string',
      rollbackSqlType: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataTrackOrderRequestParam extends $tea.Model {
  dbId?: string;
  jobEndTime?: string;
  jobStartTime?: string;
  tableNames?: string[];
  trackTypes?: string[];
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      jobEndTime: 'JobEndTime',
      jobStartTime: 'JobStartTime',
      tableNames: 'TableNames',
      trackTypes: 'TrackTypes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'string',
      jobEndTime: 'string',
      jobStartTime: 'string',
      tableNames: { 'type': 'array', 'itemType': 'string' },
      trackTypes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDatabaseExportOrderRequestPluginParamConfig extends $tea.Model {
  dataOption?: string[];
  exportContent?: string;
  exportTypes?: string[];
  SQLExtOption?: string[];
  selectedTables?: string[];
  tables?: { [key: string]: string };
  targetOption?: string;
  static names(): { [key: string]: string } {
    return {
      dataOption: 'DataOption',
      exportContent: 'ExportContent',
      exportTypes: 'ExportTypes',
      SQLExtOption: 'SQLExtOption',
      selectedTables: 'SelectedTables',
      tables: 'Tables',
      targetOption: 'TargetOption',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataOption: { 'type': 'array', 'itemType': 'string' },
      exportContent: 'string',
      exportTypes: { 'type': 'array', 'itemType': 'string' },
      SQLExtOption: { 'type': 'array', 'itemType': 'string' },
      selectedTables: { 'type': 'array', 'itemType': 'string' },
      tables: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      targetOption: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDatabaseExportOrderRequestPluginParam extends $tea.Model {
  classify?: string;
  config?: CreateDatabaseExportOrderRequestPluginParamConfig;
  dbId?: number;
  instanceId?: number;
  logic?: boolean;
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      classify: 'Classify',
      config: 'Config',
      dbId: 'DbId',
      instanceId: 'InstanceId',
      logic: 'Logic',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      classify: 'string',
      config: CreateDatabaseExportOrderRequestPluginParamConfig,
      dbId: 'number',
      instanceId: 'number',
      logic: 'boolean',
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDatabaseExportOrderResponseBodyCreateOrderResult extends $tea.Model {
  createOrderResult?: number[];
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFreeLockCorrectOrderRequestParamDbItemList extends $tea.Model {
  dbId?: number;
  logic?: boolean;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      logic: 'Logic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      logic: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFreeLockCorrectOrderRequestParam extends $tea.Model {
  attachmentName?: string;
  classify?: string;
  dbItemList?: CreateFreeLockCorrectOrderRequestParamDbItemList[];
  execMode?: string;
  execSQL?: string;
  rollbackAttachmentName?: string;
  rollbackSQL?: string;
  rollbackSqlType?: string;
  sqlType?: string;
  static names(): { [key: string]: string } {
    return {
      attachmentName: 'AttachmentName',
      classify: 'Classify',
      dbItemList: 'DbItemList',
      execMode: 'ExecMode',
      execSQL: 'ExecSQL',
      rollbackAttachmentName: 'RollbackAttachmentName',
      rollbackSQL: 'RollbackSQL',
      rollbackSqlType: 'RollbackSqlType',
      sqlType: 'SqlType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentName: 'string',
      classify: 'string',
      dbItemList: { 'type': 'array', 'itemType': CreateFreeLockCorrectOrderRequestParamDbItemList },
      execMode: 'string',
      execSQL: 'string',
      rollbackAttachmentName: 'string',
      rollbackSQL: 'string',
      rollbackSqlType: 'string',
      sqlType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrderResponseBodyCreateOrderResult extends $tea.Model {
  orderIds?: number[];
  static names(): { [key: string]: string } {
    return {
      orderIds: 'OrderIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderIds: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProcCorrectOrderRequestParamDbItemList extends $tea.Model {
  dbId?: number;
  logic?: boolean;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      logic: 'Logic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      logic: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProcCorrectOrderRequestParam extends $tea.Model {
  classify?: string;
  dbItemList?: CreateProcCorrectOrderRequestParamDbItemList[];
  execMode?: string;
  execSQL?: string;
  rollbackAttachmentName?: string;
  rollbackSQL?: string;
  rollbackSqlType?: string;
  static names(): { [key: string]: string } {
    return {
      classify: 'Classify',
      dbItemList: 'DbItemList',
      execMode: 'ExecMode',
      execSQL: 'ExecSQL',
      rollbackAttachmentName: 'RollbackAttachmentName',
      rollbackSQL: 'RollbackSQL',
      rollbackSqlType: 'RollbackSqlType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      classify: 'string',
      dbItemList: { 'type': 'array', 'itemType': CreateProcCorrectOrderRequestParamDbItemList },
      execMode: 'string',
      execSQL: 'string',
      rollbackAttachmentName: 'string',
      rollbackSQL: 'string',
      rollbackSqlType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSQLReviewOrderRequestParam extends $tea.Model {
  attachmentKeyList?: string[];
  dbId?: number;
  projectName?: string;
  static names(): { [key: string]: string } {
    return {
      attachmentKeyList: 'AttachmentKeyList',
      dbId: 'DbId',
      projectName: 'ProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKeyList: { 'type': 'array', 'itemType': 'string' },
      dbId: 'number',
      projectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStandardGroupResponseBodyStandardGroup extends $tea.Model {
  dbType?: string;
  description?: string;
  groupId?: number;
  groupMode?: string;
  groupName?: string;
  lastMenderId?: number;
  static names(): { [key: string]: string } {
    return {
      dbType: 'DbType',
      description: 'Description',
      groupId: 'GroupId',
      groupMode: 'GroupMode',
      groupName: 'GroupName',
      lastMenderId: 'LastMenderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbType: 'string',
      description: 'string',
      groupId: 'number',
      groupMode: 'string',
      groupName: 'string',
      lastMenderId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStructSyncOrderRequestParamSource extends $tea.Model {
  dbId?: number;
  dbSearchName?: string;
  logic?: boolean;
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      dbSearchName: 'DbSearchName',
      logic: 'Logic',
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      dbSearchName: 'string',
      logic: 'boolean',
      versionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStructSyncOrderRequestParamTableInfoList extends $tea.Model {
  sourceTableName?: string;
  targetTableName?: string;
  static names(): { [key: string]: string } {
    return {
      sourceTableName: 'SourceTableName',
      targetTableName: 'TargetTableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sourceTableName: 'string',
      targetTableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStructSyncOrderRequestParamTarget extends $tea.Model {
  dbId?: number;
  dbSearchName?: string;
  logic?: boolean;
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      dbSearchName: 'DbSearchName',
      logic: 'Logic',
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      dbSearchName: 'string',
      logic: 'boolean',
      versionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStructSyncOrderRequestParam extends $tea.Model {
  ignoreError?: boolean;
  source?: CreateStructSyncOrderRequestParamSource;
  tableInfoList?: CreateStructSyncOrderRequestParamTableInfoList[];
  target?: CreateStructSyncOrderRequestParamTarget;
  static names(): { [key: string]: string } {
    return {
      ignoreError: 'IgnoreError',
      source: 'Source',
      tableInfoList: 'TableInfoList',
      target: 'Target',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ignoreError: 'boolean',
      source: CreateStructSyncOrderRequestParamSource,
      tableInfoList: { 'type': 'array', 'itemType': CreateStructSyncOrderRequestParamTableInfoList },
      target: CreateStructSyncOrderRequestParamTarget,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUploadOSSFileJobRequestUploadTarget extends $tea.Model {
  bucketName?: string;
  endpoint?: string;
  objectName?: string;
  static names(): { [key: string]: string } {
    return {
      bucketName: 'BucketName',
      endpoint: 'Endpoint',
      objectName: 'ObjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bucketName: 'string',
      endpoint: 'string',
      objectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadDataTrackResultRequestColumnFilter extends $tea.Model {
  betweenEnd?: string;
  betweenStart?: string;
  columnName?: string;
  inList?: string[];
  operator?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      betweenEnd: 'BetweenEnd',
      betweenStart: 'BetweenStart',
      columnName: 'ColumnName',
      inList: 'InList',
      operator: 'Operator',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      betweenEnd: 'string',
      betweenStart: 'string',
      columnName: 'string',
      inList: { 'type': 'array', 'itemType': 'string' },
      operator: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteScriptResponseBodyResults extends $tea.Model {
  columnNames?: string[];
  message?: string;
  rowCount?: number;
  rows?: { [key: string]: any }[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      columnNames: 'ColumnNames',
      message: 'Message',
      rowCount: 'RowCount',
      rows: 'Rows',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnNames: { 'type': 'array', 'itemType': 'string' },
      message: 'string',
      rowCount: 'number',
      rows: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler extends $tea.Model {
  id?: number;
  nickName?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      nickName: 'NickName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      nickName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers extends $tea.Model {
  currentHandler?: GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler[];
  static names(): { [key: string]: string } {
    return {
      currentHandler: 'CurrentHandler',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentHandler: { 'type': 'array', 'itemType': GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApprovalDetailResponseBodyApprovalDetailReasonList extends $tea.Model {
  reasons?: string[];
  static names(): { [key: string]: string } {
    return {
      reasons: 'Reasons',
    };
  }

  static types(): { [key: string]: any } {
    return {
      reasons: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList extends $tea.Model {
  auditUserIds?: string[];
  static names(): { [key: string]: string } {
    return {
      auditUserIds: 'AuditUserIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      auditUserIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode extends $tea.Model {
  auditUserIdList?: GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList;
  nodeName?: string;
  operateComment?: string;
  operateTime?: string;
  operatorId?: number;
  workflowInsCode?: string;
  static names(): { [key: string]: string } {
    return {
      auditUserIdList: 'AuditUserIdList',
      nodeName: 'NodeName',
      operateComment: 'OperateComment',
      operateTime: 'OperateTime',
      operatorId: 'OperatorId',
      workflowInsCode: 'WorkflowInsCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      auditUserIdList: GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList,
      nodeName: 'string',
      operateComment: 'string',
      operateTime: 'string',
      operatorId: 'number',
      workflowInsCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes extends $tea.Model {
  workflowNode?: GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode[];
  static names(): { [key: string]: string } {
    return {
      workflowNode: 'WorkflowNode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      workflowNode: { 'type': 'array', 'itemType': GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApprovalDetailResponseBodyApprovalDetail extends $tea.Model {
  auditId?: number;
  createTime?: string;
  currentHandlers?: GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers;
  description?: string;
  orderId?: number;
  orderType?: string;
  reasonList?: GetApprovalDetailResponseBodyApprovalDetailReasonList;
  templateId?: number;
  title?: string;
  workflowInsCode?: string;
  workflowNodes?: GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes;
  static names(): { [key: string]: string } {
    return {
      auditId: 'AuditId',
      createTime: 'CreateTime',
      currentHandlers: 'CurrentHandlers',
      description: 'Description',
      orderId: 'OrderId',
      orderType: 'OrderType',
      reasonList: 'ReasonList',
      templateId: 'TemplateId',
      title: 'Title',
      workflowInsCode: 'WorkflowInsCode',
      workflowNodes: 'WorkflowNodes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      auditId: 'number',
      createTime: 'string',
      currentHandlers: GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers,
      description: 'string',
      orderId: 'number',
      orderType: 'string',
      reasonList: GetApprovalDetailResponseBodyApprovalDetailReasonList,
      templateId: 'number',
      title: 'string',
      workflowInsCode: 'string',
      workflowNodes: GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem extends $tea.Model {
  attribute?: string;
  dbId?: number;
  instanceId?: number;
  itemId?: number;
  modifierId?: number;
  resourceType?: string;
  tableName?: string;
  templateId?: number;
  static names(): { [key: string]: string } {
    return {
      attribute: 'Attribute',
      dbId: 'DbId',
      instanceId: 'InstanceId',
      itemId: 'ItemId',
      modifierId: 'ModifierId',
      resourceType: 'ResourceType',
      tableName: 'TableName',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attribute: 'string',
      dbId: 'number',
      instanceId: 'number',
      itemId: 'number',
      modifierId: 'number',
      resourceType: 'string',
      tableName: 'string',
      templateId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemList extends $tea.Model {
  authorityTemplateItem?: GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem[];
  static names(): { [key: string]: string } {
    return {
      authorityTemplateItem: 'AuthorityTemplateItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorityTemplateItem: { 'type': 'array', 'itemType': GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthorityTemplateResponseBodyAuthorityTemplateView extends $tea.Model {
  authorityTemplateItemList?: GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemList;
  createTime?: string;
  creatorId?: number;
  description?: string;
  name?: string;
  templateId?: number;
  static names(): { [key: string]: string } {
    return {
      authorityTemplateItemList: 'AuthorityTemplateItemList',
      createTime: 'CreateTime',
      creatorId: 'CreatorId',
      description: 'Description',
      name: 'Name',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorityTemplateItemList: GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemList,
      createTime: 'string',
      creatorId: 'number',
      description: 'string',
      name: 'string',
      templateId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem extends $tea.Model {
  attribute?: string;
  dbId?: number;
  instanceId?: number;
  itemId?: number;
  modifierId?: number;
  resourceType?: string;
  tableName?: string;
  templateId?: number;
  static names(): { [key: string]: string } {
    return {
      attribute: 'Attribute',
      dbId: 'DbId',
      instanceId: 'InstanceId',
      itemId: 'ItemId',
      modifierId: 'ModifierId',
      resourceType: 'ResourceType',
      tableName: 'TableName',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attribute: 'string',
      dbId: 'number',
      instanceId: 'number',
      itemId: 'number',
      modifierId: 'number',
      resourceType: 'string',
      tableName: 'string',
      templateId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemList extends $tea.Model {
  authorityTemplateItem?: GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem[];
  static names(): { [key: string]: string } {
    return {
      authorityTemplateItem: 'AuthorityTemplateItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorityTemplateItem: { 'type': 'array', 'itemType': GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClassificationTemplateResponseBodyClassificationResourceTemplateMap extends $tea.Model {
  resourceId?: number;
  resourceType?: string;
  templateId?: number;
  templateType?: string;
  static names(): { [key: string]: string } {
    return {
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      templateId: 'TemplateId',
      templateType: 'TemplateType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceId: 'number',
      resourceType: 'string',
      templateId: 'number',
      templateType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList extends $tea.Model {
  catalogName?: string;
  dbId?: number;
  dbType?: string;
  envType?: string;
  instanceId?: number;
  instanceResourceId?: string;
  instanceSource?: string;
  regionId?: string;
  schemaName?: string;
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      catalogName: 'CatalogName',
      dbId: 'DbId',
      dbType: 'DbType',
      envType: 'EnvType',
      instanceId: 'InstanceId',
      instanceResourceId: 'InstanceResourceId',
      instanceSource: 'InstanceSource',
      regionId: 'RegionId',
      schemaName: 'SchemaName',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      catalogName: 'string',
      dbId: 'number',
      dbType: 'string',
      envType: 'string',
      instanceId: 'number',
      instanceResourceId: 'string',
      instanceSource: 'string',
      regionId: 'string',
      schemaName: 'string',
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDBTopologyResponseBodyDBTopology extends $tea.Model {
  alias?: string;
  DBTopologyInfoList?: GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList[];
  dbType?: string;
  envType?: string;
  logicDbId?: number;
  logicDbName?: string;
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      DBTopologyInfoList: 'DBTopologyInfoList',
      dbType: 'DbType',
      envType: 'EnvType',
      logicDbId: 'LogicDbId',
      logicDbName: 'LogicDbName',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      DBTopologyInfoList: { 'type': 'array', 'itemType': GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList },
      dbType: 'string',
      envType: 'string',
      logicDbId: 'number',
      logicDbName: 'string',
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveCountResponseBodyData extends $tea.Model {
  failCount?: number;
  processingCount?: number;
  successCount?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      failCount: 'FailCount',
      processingCount: 'ProcessingCount',
      successCount: 'SuccessCount',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failCount: 'number',
      processingCount: 'number',
      successCount: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo extends $tea.Model {
  creatorId?: string;
  cronBeginDate?: string;
  cronEndDate?: string;
  cronTrigger?: boolean;
  DWDevelop?: boolean;
  dagName?: string;
  dagOwnerId?: string;
  deployId?: number;
  description?: string;
  editDagId?: number;
  gmtCreate?: string;
  gmtModified?: string;
  id?: number;
  isPublic?: number;
  legacy?: boolean;
  system?: boolean;
  tenantId?: string;
  triggerOnce?: boolean;
  static names(): { [key: string]: string } {
    return {
      creatorId: 'CreatorId',
      cronBeginDate: 'CronBeginDate',
      cronEndDate: 'CronEndDate',
      cronTrigger: 'CronTrigger',
      DWDevelop: 'DWDevelop',
      dagName: 'DagName',
      dagOwnerId: 'DagOwnerId',
      deployId: 'DeployId',
      description: 'Description',
      editDagId: 'EditDagId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      isPublic: 'IsPublic',
      legacy: 'Legacy',
      system: 'System',
      tenantId: 'TenantId',
      triggerOnce: 'TriggerOnce',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorId: 'string',
      cronBeginDate: 'string',
      cronEndDate: 'string',
      cronTrigger: 'boolean',
      DWDevelop: 'boolean',
      dagName: 'string',
      dagOwnerId: 'string',
      deployId: 'number',
      description: 'string',
      editDagId: 'number',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      isPublic: 'number',
      legacy: 'boolean',
      system: 'boolean',
      tenantId: 'string',
      triggerOnce: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup extends $tea.Model {
  dbType?: string;
  description?: string;
  freeOrStable?: boolean;
  gmtCreate?: string;
  gmtModified?: string;
  groupMode?: string;
  groupName?: string;
  id?: number;
  lastMenderId?: number;
  static names(): { [key: string]: string } {
    return {
      dbType: 'DbType',
      description: 'Description',
      freeOrStable: 'FreeOrStable',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      groupMode: 'GroupMode',
      groupName: 'GroupName',
      id: 'Id',
      lastMenderId: 'LastMenderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbType: 'string',
      description: 'string',
      freeOrStable: 'boolean',
      gmtCreate: 'string',
      gmtModified: 'string',
      groupMode: 'string',
      groupName: 'string',
      id: 'number',
      lastMenderId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo extends $tea.Model {
  alias?: string;
  alterTimeout?: number;
  assetControl?: boolean;
  catalogName?: string;
  clusterNode?: string;
  dbId?: number;
  dbType?: string;
  dbaId?: number;
  dbaName?: string;
  description?: string;
  encoding?: string;
  envType?: string;
  follow?: boolean;
  host?: string;
  idc?: string;
  idcTitle?: string;
  instanceId?: number;
  instanceSource?: string;
  lastSyncTime?: string;
  level?: string;
  logic?: boolean;
  ownerIds?: number[];
  ownerNames?: string[];
  port?: number;
  schemaName?: string;
  searchName?: string;
  standardGroup?: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup;
  state?: string;
  tableCount?: number;
  tnsName?: string;
  unitType?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      alterTimeout: 'AlterTimeout',
      assetControl: 'AssetControl',
      catalogName: 'CatalogName',
      clusterNode: 'ClusterNode',
      dbId: 'DbId',
      dbType: 'DbType',
      dbaId: 'DbaId',
      dbaName: 'DbaName',
      description: 'Description',
      encoding: 'Encoding',
      envType: 'EnvType',
      follow: 'Follow',
      host: 'Host',
      idc: 'Idc',
      idcTitle: 'IdcTitle',
      instanceId: 'InstanceId',
      instanceSource: 'InstanceSource',
      lastSyncTime: 'LastSyncTime',
      level: 'Level',
      logic: 'Logic',
      ownerIds: 'OwnerIds',
      ownerNames: 'OwnerNames',
      port: 'Port',
      schemaName: 'SchemaName',
      searchName: 'SearchName',
      standardGroup: 'StandardGroup',
      state: 'State',
      tableCount: 'TableCount',
      tnsName: 'TnsName',
      unitType: 'UnitType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      alterTimeout: 'number',
      assetControl: 'boolean',
      catalogName: 'string',
      clusterNode: 'string',
      dbId: 'number',
      dbType: 'string',
      dbaId: 'number',
      dbaName: 'string',
      description: 'string',
      encoding: 'string',
      envType: 'string',
      follow: 'boolean',
      host: 'string',
      idc: 'string',
      idcTitle: 'string',
      instanceId: 'number',
      instanceSource: 'string',
      lastSyncTime: 'string',
      level: 'string',
      logic: 'boolean',
      ownerIds: { 'type': 'array', 'itemType': 'number' },
      ownerNames: { 'type': 'array', 'itemType': 'string' },
      port: 'number',
      schemaName: 'string',
      searchName: 'string',
      standardGroup: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup,
      state: 'string',
      tableCount: 'number',
      tnsName: 'string',
      unitType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances extends $tea.Model {
  businessTime?: string;
  dagId?: number;
  endTime?: string;
  gmtCreate?: string;
  gmtModified?: string;
  historyDagId?: number;
  id?: number;
  lastRunningContext?: string;
  msg?: string;
  status?: number;
  tenantId?: string;
  triggerType?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      businessTime: 'BusinessTime',
      dagId: 'DagId',
      endTime: 'EndTime',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      historyDagId: 'HistoryDagId',
      id: 'Id',
      lastRunningContext: 'LastRunningContext',
      msg: 'Msg',
      status: 'Status',
      tenantId: 'TenantId',
      triggerType: 'TriggerType',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessTime: 'string',
      dagId: 'number',
      endTime: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      historyDagId: 'number',
      id: 'number',
      lastRunningContext: 'string',
      msg: 'string',
      status: 'number',
      tenantId: 'string',
      triggerType: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataNextFireTimeResult extends $tea.Model {
  cronFireType?: string;
  static names(): { [key: string]: string } {
    return {
      cronFireType: 'CronFireType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cronFireType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData extends $tea.Model {
  dagInfo?: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo;
  dbBaseInfo?: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo;
  instanceTotal?: number;
  instances?: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances[];
  nextFireTimeResult?: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataNextFireTimeResult;
  pageIndex?: number;
  pageSize?: number;
  tempTableNameMap?: { [key: string]: any };
  static names(): { [key: string]: string } {
    return {
      dagInfo: 'DagInfo',
      dbBaseInfo: 'DbBaseInfo',
      instanceTotal: 'InstanceTotal',
      instances: 'Instances',
      nextFireTimeResult: 'NextFireTimeResult',
      pageIndex: 'PageIndex',
      pageSize: 'PageSize',
      tempTableNameMap: 'TempTableNameMap',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagInfo: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo,
      dbBaseInfo: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo,
      instanceTotal: 'number',
      instances: { 'type': 'array', 'itemType': GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances },
      nextFireTimeResult: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataNextFireTimeResult,
      pageIndex: 'number',
      pageSize: 'number',
      tempTableNameMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes extends $tea.Model {
  tableName?: string;
  tableWhere?: string;
  static names(): { [key: string]: string } {
    return {
      tableName: 'TableName',
      tableWhere: 'TableWhere',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tableName: 'string',
      tableWhere: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam extends $tea.Model {
  archiveMethod?: string;
  dbSchema?: string;
  logic?: boolean;
  orderAfter?: string[];
  runMethod?: string;
  sourceDatabaseId?: number;
  tableIncludes?: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes[];
  tableMapping?: string[];
  targetInstanceId?: string;
  variables?: string[];
  static names(): { [key: string]: string } {
    return {
      archiveMethod: 'ArchiveMethod',
      dbSchema: 'DbSchema',
      logic: 'Logic',
      orderAfter: 'OrderAfter',
      runMethod: 'RunMethod',
      sourceDatabaseId: 'SourceDatabaseId',
      tableIncludes: 'TableIncludes',
      tableMapping: 'TableMapping',
      targetInstanceId: 'TargetInstanceId',
      variables: 'Variables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      archiveMethod: 'string',
      dbSchema: 'string',
      logic: 'boolean',
      orderAfter: { 'type': 'array', 'itemType': 'string' },
      runMethod: 'string',
      sourceDatabaseId: 'number',
      tableIncludes: { 'type': 'array', 'itemType': GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes },
      tableMapping: { 'type': 'array', 'itemType': 'string' },
      targetInstanceId: 'string',
      variables: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail extends $tea.Model {
  comment?: string;
  committer?: string;
  committerId?: number;
  gmtCreate?: string;
  gmtModified?: string;
  id?: number;
  pluginExtraData?: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData;
  pluginParam?: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam;
  pluginType?: string;
  relatedUserList?: number[];
  relatedUserNickList?: string[];
  statusCode?: string;
  statusDesc?: string;
  workflowInstanceId?: number;
  workflowStatusDesc?: string;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      committer: 'Committer',
      committerId: 'CommitterId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      pluginExtraData: 'PluginExtraData',
      pluginParam: 'PluginParam',
      pluginType: 'PluginType',
      relatedUserList: 'RelatedUserList',
      relatedUserNickList: 'RelatedUserNickList',
      statusCode: 'StatusCode',
      statusDesc: 'StatusDesc',
      workflowInstanceId: 'WorkflowInstanceId',
      workflowStatusDesc: 'WorkflowStatusDesc',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      committer: 'string',
      committerId: 'number',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      pluginExtraData: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData,
      pluginParam: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam,
      pluginType: 'string',
      relatedUserList: { 'type': 'array', 'itemType': 'number' },
      relatedUserNickList: { 'type': 'array', 'itemType': 'string' },
      statusCode: 'string',
      statusDesc: 'string',
      workflowInstanceId: 'number',
      workflowStatusDesc: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles extends $tea.Model {
  fileUrl?: string[];
  static names(): { [key: string]: string } {
    return {
      fileUrl: 'FileUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileUrl: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailConfigDetailCronExtConfig extends $tea.Model {
  currentClearTaskCount?: number;
  optimizeTableAfterEveryClearTimes?: number;
  static names(): { [key: string]: string } {
    return {
      currentClearTaskCount: 'CurrentClearTaskCount',
      optimizeTableAfterEveryClearTimes: 'OptimizeTableAfterEveryClearTimes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentClearTaskCount: 'number',
      optimizeTableAfterEveryClearTimes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailConfigDetailImportExtConfig extends $tea.Model {
  csvFirstRowIsColumnDef?: boolean;
  ignoreError?: boolean;
  importMode?: string;
  insertType?: string;
  static names(): { [key: string]: string } {
    return {
      csvFirstRowIsColumnDef: 'CsvFirstRowIsColumnDef',
      ignoreError: 'IgnoreError',
      importMode: 'ImportMode',
      insertType: 'InsertType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      csvFirstRowIsColumnDef: 'boolean',
      ignoreError: 'boolean',
      importMode: 'string',
      insertType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailConfigDetail extends $tea.Model {
  cron?: boolean;
  cronCallTimes?: number;
  cronExtConfig?: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailConfigDetailCronExtConfig;
  cronFormat?: string;
  cronLastCallStartTime?: string;
  cronNextCallTime?: string;
  cronStatus?: string;
  csvTableName?: string;
  currentTaskId?: number;
  detailType?: string;
  duration?: number;
  fileEncoding?: string;
  fileType?: string;
  importExtConfig?: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailConfigDetailImportExtConfig;
  static names(): { [key: string]: string } {
    return {
      cron: 'Cron',
      cronCallTimes: 'CronCallTimes',
      cronExtConfig: 'CronExtConfig',
      cronFormat: 'CronFormat',
      cronLastCallStartTime: 'CronLastCallStartTime',
      cronNextCallTime: 'CronNextCallTime',
      cronStatus: 'CronStatus',
      csvTableName: 'CsvTableName',
      currentTaskId: 'CurrentTaskId',
      detailType: 'DetailType',
      duration: 'Duration',
      fileEncoding: 'FileEncoding',
      fileType: 'FileType',
      importExtConfig: 'ImportExtConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cron: 'boolean',
      cronCallTimes: 'number',
      cronExtConfig: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailConfigDetailCronExtConfig,
      cronFormat: 'string',
      cronLastCallStartTime: 'string',
      cronNextCallTime: 'string',
      cronStatus: 'string',
      csvTableName: 'string',
      currentTaskId: 'number',
      detailType: 'string',
      duration: 'number',
      fileEncoding: 'string',
      fileType: 'string',
      importExtConfig: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailConfigDetailImportExtConfig,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase extends $tea.Model {
  dbId?: number;
  dbType?: string;
  envType?: string;
  logic?: boolean;
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      dbType: 'DbType',
      envType: 'EnvType',
      logic: 'Logic',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      dbType: 'string',
      envType: 'string',
      logic: 'boolean',
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList extends $tea.Model {
  database?: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase[];
  static names(): { [key: string]: string } {
    return {
      database: 'Database',
    };
  }

  static types(): { [key: string]: any } {
    return {
      database: { 'type': 'array', 'itemType': GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail extends $tea.Model {
  actualAffectRows?: number;
  attachmentName?: string;
  classify?: string;
  estimateAffectRows?: number;
  exeSQL?: string;
  ignoreAffectRows?: boolean;
  ignoreAffectRowsReason?: string;
  rbAttachmentName?: string;
  rbSQL?: string;
  rbSQLType?: string;
  sqlType?: string;
  static names(): { [key: string]: string } {
    return {
      actualAffectRows: 'ActualAffectRows',
      attachmentName: 'AttachmentName',
      classify: 'Classify',
      estimateAffectRows: 'EstimateAffectRows',
      exeSQL: 'ExeSQL',
      ignoreAffectRows: 'IgnoreAffectRows',
      ignoreAffectRowsReason: 'IgnoreAffectRowsReason',
      rbAttachmentName: 'RbAttachmentName',
      rbSQL: 'RbSQL',
      rbSQLType: 'RbSQLType',
      sqlType: 'SqlType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actualAffectRows: 'number',
      attachmentName: 'string',
      classify: 'string',
      estimateAffectRows: 'number',
      exeSQL: 'string',
      ignoreAffectRows: 'boolean',
      ignoreAffectRowsReason: 'string',
      rbAttachmentName: 'string',
      rbSQL: 'string',
      rbSQLType: 'string',
      sqlType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO extends $tea.Model {
  checkStatus?: string;
  checkStep?: string;
  userTip?: string;
  static names(): { [key: string]: string } {
    return {
      checkStatus: 'CheckStatus',
      checkStep: 'CheckStep',
      userTip: 'UserTip',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkStatus: 'string',
      checkStep: 'string',
      userTip: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail extends $tea.Model {
  taskCheckDO?: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO[];
  static names(): { [key: string]: string } {
    return {
      taskCheckDO: 'TaskCheckDO',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskCheckDO: { 'type': 'array', 'itemType': GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail extends $tea.Model {
  configDetail?: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailConfigDetail;
  databaseList?: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList;
  execMode?: string;
  orderDetail?: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail;
  preCheckDetail?: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      configDetail: 'ConfigDetail',
      databaseList: 'DatabaseList',
      execMode: 'ExecMode',
      orderDetail: 'OrderDetail',
      preCheckDetail: 'PreCheckDetail',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configDetail: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailConfigDetail,
      databaseList: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList,
      execMode: 'string',
      orderDetail: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail,
      preCheckDetail: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail,
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail extends $tea.Model {
  actualAffectRows?: number;
  createTime?: string;
  DBTaskGroupId?: number;
  jobStatus?: string;
  static names(): { [key: string]: string } {
    return {
      actualAffectRows: 'ActualAffectRows',
      createTime: 'CreateTime',
      DBTaskGroupId: 'DBTaskGroupId',
      jobStatus: 'jobStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actualAffectRows: 'number',
      createTime: 'string',
      DBTaskGroupId: 'number',
      jobStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCronClearConfigResponseBodyDataCronClearConfig extends $tea.Model {
  cronCallTimes?: string;
  cronFormat?: string;
  cronLastCallStartTime?: string;
  cronNextCallTime?: string;
  cronStatus?: string;
  currentClearTaskCount?: number;
  duration?: string;
  optimizeTableAfterEveryClearTimes?: number;
  static names(): { [key: string]: string } {
    return {
      cronCallTimes: 'CronCallTimes',
      cronFormat: 'CronFormat',
      cronLastCallStartTime: 'CronLastCallStartTime',
      cronNextCallTime: 'CronNextCallTime',
      cronStatus: 'CronStatus',
      currentClearTaskCount: 'CurrentClearTaskCount',
      duration: 'Duration',
      optimizeTableAfterEveryClearTimes: 'OptimizeTableAfterEveryClearTimes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cronCallTimes: 'string',
      cronFormat: 'string',
      cronLastCallStartTime: 'string',
      cronNextCallTime: 'string',
      cronStatus: 'string',
      currentClearTaskCount: 'number',
      duration: 'string',
      optimizeTableAfterEveryClearTimes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList extends $tea.Model {
  actualAffectRows?: number;
  createTime?: string;
  DBTaskGroupId?: number;
  jobStatus?: string;
  static names(): { [key: string]: string } {
    return {
      actualAffectRows: 'ActualAffectRows',
      createTime: 'CreateTime',
      DBTaskGroupId: 'DBTaskGroupId',
      jobStatus: 'jobStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actualAffectRows: 'number',
      createTime: 'string',
      DBTaskGroupId: 'number',
      jobStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportDownloadURLResponseBodyDownloadURLResult extends $tea.Model {
  hasResult?: boolean;
  tipMessage?: string;
  URL?: string;
  static names(): { [key: string]: string } {
    return {
      hasResult: 'HasResult',
      tipMessage: 'TipMessage',
      URL: 'URL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hasResult: 'boolean',
      tipMessage: 'string',
      URL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo extends $tea.Model {
  jobStatus?: string;
  preCheckId?: number;
  static names(): { [key: string]: string } {
    return {
      jobStatus: 'JobStatus',
      preCheckId: 'PreCheckId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobStatus: 'string',
      preCheckId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail extends $tea.Model {
  actualAffectRows?: number;
  classify?: string;
  database?: string;
  dbId?: number;
  envType?: string;
  exeSQL?: string;
  ignoreAffectRows?: boolean;
  ignoreAffectRowsReason?: string;
  logic?: boolean;
  static names(): { [key: string]: string } {
    return {
      actualAffectRows: 'ActualAffectRows',
      classify: 'Classify',
      database: 'Database',
      dbId: 'DbId',
      envType: 'EnvType',
      exeSQL: 'ExeSQL',
      ignoreAffectRows: 'IgnoreAffectRows',
      ignoreAffectRowsReason: 'IgnoreAffectRowsReason',
      logic: 'Logic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actualAffectRows: 'number',
      classify: 'string',
      database: 'string',
      dbId: 'number',
      envType: 'string',
      exeSQL: 'string',
      ignoreAffectRows: 'boolean',
      ignoreAffectRowsReason: 'string',
      logic: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportOrderDetailResponseBodyDataExportOrderDetail extends $tea.Model {
  keyInfo?: GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo;
  orderDetail?: GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail;
  static names(): { [key: string]: string } {
    return {
      keyInfo: 'KeyInfo',
      orderDetail: 'OrderDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keyInfo: GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo,
      orderDetail: GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList extends $tea.Model {
  affectRows?: number;
  SQL?: string;
  static names(): { [key: string]: string } {
    return {
      affectRows: 'AffectRows',
      SQL: 'SQL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affectRows: 'number',
      SQL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailList extends $tea.Model {
  preCheckDetailList?: GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList[];
  static names(): { [key: string]: string } {
    return {
      preCheckDetailList: 'PreCheckDetailList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      preCheckDetailList: { 'type': 'array', 'itemType': GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportPreCheckDetailResponseBodyPreCheckResult extends $tea.Model {
  ignoreAffectRows?: boolean;
  preCheckDetailList?: GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailList;
  static names(): { [key: string]: string } {
    return {
      ignoreAffectRows: 'IgnoreAffectRows',
      preCheckDetailList: 'PreCheckDetailList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ignoreAffectRows: 'boolean',
      preCheckDetailList: GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataImportSQLResponseBodySQLDetail extends $tea.Model {
  execSql?: string;
  static names(): { [key: string]: string } {
    return {
      execSql: 'ExecSql',
    };
  }

  static types(): { [key: string]: any } {
    return {
      execSql: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataTrackJobDegreeResponseBodyJobDegree extends $tea.Model {
  downloadCompletionDegree?: number;
  filterCompletionDegree?: number;
  jobStatus?: string;
  listCompletionDegree?: number;
  statusDesc?: string;
  static names(): { [key: string]: string } {
    return {
      downloadCompletionDegree: 'DownloadCompletionDegree',
      filterCompletionDegree: 'FilterCompletionDegree',
      jobStatus: 'JobStatus',
      listCompletionDegree: 'ListCompletionDegree',
      statusDesc: 'StatusDesc',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadCompletionDegree: 'number',
      filterCompletionDegree: 'number',
      jobStatus: 'string',
      listCompletionDegree: 'number',
      statusDesc: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataTrackJobTableMetaResponseBodyTableMetaListColumns extends $tea.Model {
  charset?: string;
  columnName?: string;
  columnPosition?: number;
  columnType?: string;
  fictive?: boolean;
  static names(): { [key: string]: string } {
    return {
      charset: 'Charset',
      columnName: 'ColumnName',
      columnPosition: 'ColumnPosition',
      columnType: 'ColumnType',
      fictive: 'Fictive',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charset: 'string',
      columnName: 'string',
      columnPosition: 'number',
      columnType: 'string',
      fictive: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataTrackJobTableMetaResponseBodyTableMetaList extends $tea.Model {
  columns?: GetDataTrackJobTableMetaResponseBodyTableMetaListColumns[];
  schemaName?: string;
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      columns: 'Columns',
      schemaName: 'SchemaName',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columns: { 'type': 'array', 'itemType': GetDataTrackJobTableMetaResponseBodyTableMetaListColumns },
      schemaName: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail extends $tea.Model {
  databaseSearchName?: string;
  dbId?: number;
  jobEndTime?: string;
  jobStartTime?: string;
  jobStatus?: string;
  logic?: boolean;
  schemaName?: string;
  statusDesc?: string;
  tableNames?: string[];
  trackTypes?: string[];
  static names(): { [key: string]: string } {
    return {
      databaseSearchName: 'DatabaseSearchName',
      dbId: 'DbId',
      jobEndTime: 'JobEndTime',
      jobStartTime: 'JobStartTime',
      jobStatus: 'JobStatus',
      logic: 'Logic',
      schemaName: 'SchemaName',
      statusDesc: 'StatusDesc',
      tableNames: 'TableNames',
      trackTypes: 'TrackTypes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseSearchName: 'string',
      dbId: 'number',
      jobEndTime: 'string',
      jobStartTime: 'string',
      jobStatus: 'string',
      logic: 'boolean',
      schemaName: 'string',
      statusDesc: 'string',
      tableNames: { 'type': 'array', 'itemType': 'string' },
      trackTypes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseResponseBodyDatabaseOwnerIdList extends $tea.Model {
  ownerIds?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerIds: 'OwnerIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseResponseBodyDatabaseOwnerNameList extends $tea.Model {
  ownerNames?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerNames: 'OwnerNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseResponseBodyDatabase extends $tea.Model {
  catalogName?: string;
  databaseId?: string;
  dbType?: string;
  dbaId?: string;
  dbaName?: string;
  encoding?: string;
  envType?: string;
  host?: string;
  instanceAlias?: string;
  instanceId?: string;
  ownerIdList?: GetDatabaseResponseBodyDatabaseOwnerIdList;
  ownerNameList?: GetDatabaseResponseBodyDatabaseOwnerNameList;
  port?: number;
  schemaName?: string;
  searchName?: string;
  sid?: string;
  state?: string;
  static names(): { [key: string]: string } {
    return {
      catalogName: 'CatalogName',
      databaseId: 'DatabaseId',
      dbType: 'DbType',
      dbaId: 'DbaId',
      dbaName: 'DbaName',
      encoding: 'Encoding',
      envType: 'EnvType',
      host: 'Host',
      instanceAlias: 'InstanceAlias',
      instanceId: 'InstanceId',
      ownerIdList: 'OwnerIdList',
      ownerNameList: 'OwnerNameList',
      port: 'Port',
      schemaName: 'SchemaName',
      searchName: 'SearchName',
      sid: 'Sid',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      catalogName: 'string',
      databaseId: 'string',
      dbType: 'string',
      dbaId: 'string',
      dbaName: 'string',
      encoding: 'string',
      envType: 'string',
      host: 'string',
      instanceAlias: 'string',
      instanceId: 'string',
      ownerIdList: GetDatabaseResponseBodyDatabaseOwnerIdList,
      ownerNameList: GetDatabaseResponseBodyDatabaseOwnerNameList,
      port: 'number',
      schemaName: 'string',
      searchName: 'string',
      sid: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigExportTypes extends $tea.Model {
  exportTypes?: string[];
  static names(): { [key: string]: string } {
    return {
      exportTypes: 'ExportTypes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      exportTypes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSQLExtOption extends $tea.Model {
  SQLExtOption?: string[];
  static names(): { [key: string]: string } {
    return {
      SQLExtOption: 'SQLExtOption',
    };
  }

  static types(): { [key: string]: any } {
    return {
      SQLExtOption: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSelectedTables extends $tea.Model {
  selectedTables?: string[];
  static names(): { [key: string]: string } {
    return {
      selectedTables: 'SelectedTables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      selectedTables: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig extends $tea.Model {
  dbName?: string;
  exportContent?: string;
  exportTypes?: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigExportTypes;
  SQLExtOption?: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSQLExtOption;
  selectedTables?: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSelectedTables;
  targetOption?: string;
  static names(): { [key: string]: string } {
    return {
      dbName: 'DbName',
      exportContent: 'ExportContent',
      exportTypes: 'ExportTypes',
      SQLExtOption: 'SQLExtOption',
      selectedTables: 'SelectedTables',
      targetOption: 'TargetOption',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbName: 'string',
      exportContent: 'string',
      exportTypes: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigExportTypes,
      SQLExtOption: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSQLExtOption,
      selectedTables: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSelectedTables,
      targetOption: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo extends $tea.Model {
  auditDate?: string;
  config?: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig;
  dbId?: number;
  downloadURL?: string;
  static names(): { [key: string]: string } {
    return {
      auditDate: 'AuditDate',
      config: 'Config',
      dbId: 'DbId',
      downloadURL: 'DownloadURL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      auditDate: 'string',
      config: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig,
      dbId: 'number',
      downloadURL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail extends $tea.Model {
  comment?: string;
  committer?: string;
  committerId?: string;
  id?: number;
  keyInfo?: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo;
  log?: string;
  searchName?: string;
  statusDesc?: string;
  workflowStatusDesc?: string;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      committer: 'Committer',
      committerId: 'CommitterId',
      id: 'Id',
      keyInfo: 'KeyInfo',
      log: 'Log',
      searchName: 'SearchName',
      statusDesc: 'StatusDesc',
      workflowStatusDesc: 'WorkflowStatusDesc',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      committer: 'string',
      committerId: 'string',
      id: 'number',
      keyInfo: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo,
      log: 'string',
      searchName: 'string',
      statusDesc: 'string',
      workflowStatusDesc: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDbExportDownloadURLResponseBodyDownloadURLResult extends $tea.Model {
  hasResult?: boolean;
  tipMessage?: string;
  URL?: string;
  static names(): { [key: string]: string } {
    return {
      hasResult: 'HasResult',
      tipMessage: 'TipMessage',
      URL: 'URL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hasResult: 'boolean',
      tipMessage: 'string',
      URL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceResponseBodyInstanceOwnerIdList extends $tea.Model {
  ownerIds?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerIds: 'OwnerIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceResponseBodyInstanceOwnerNameList extends $tea.Model {
  ownerNames?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerNames: 'OwnerNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceResponseBodyInstanceStandardGroup extends $tea.Model {
  groupMode?: string;
  groupName?: string;
  static names(): { [key: string]: string } {
    return {
      groupMode: 'GroupMode',
      groupName: 'GroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupMode: 'string',
      groupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceResponseBodyInstance extends $tea.Model {
  dataLinkName?: string;
  databasePassword?: string;
  databaseUser?: string;
  dbaId?: string;
  dbaNickName?: string;
  ddlOnline?: number;
  ecsInstanceId?: string;
  ecsRegion?: string;
  envType?: string;
  exportTimeout?: number;
  host?: string;
  instanceAlias?: string;
  instanceId?: string;
  instanceSource?: string;
  instanceType?: string;
  ownerIdList?: GetInstanceResponseBodyInstanceOwnerIdList;
  ownerNameList?: GetInstanceResponseBodyInstanceOwnerNameList;
  port?: number;
  queryTimeout?: number;
  safeRuleId?: string;
  sellSitd?: string;
  sid?: string;
  standardGroup?: GetInstanceResponseBodyInstanceStandardGroup;
  state?: string;
  useDsql?: number;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      dataLinkName: 'DataLinkName',
      databasePassword: 'DatabasePassword',
      databaseUser: 'DatabaseUser',
      dbaId: 'DbaId',
      dbaNickName: 'DbaNickName',
      ddlOnline: 'DdlOnline',
      ecsInstanceId: 'EcsInstanceId',
      ecsRegion: 'EcsRegion',
      envType: 'EnvType',
      exportTimeout: 'ExportTimeout',
      host: 'Host',
      instanceAlias: 'InstanceAlias',
      instanceId: 'InstanceId',
      instanceSource: 'InstanceSource',
      instanceType: 'InstanceType',
      ownerIdList: 'OwnerIdList',
      ownerNameList: 'OwnerNameList',
      port: 'Port',
      queryTimeout: 'QueryTimeout',
      safeRuleId: 'SafeRuleId',
      sellSitd: 'SellSitd',
      sid: 'Sid',
      standardGroup: 'StandardGroup',
      state: 'State',
      useDsql: 'UseDsql',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataLinkName: 'string',
      databasePassword: 'string',
      databaseUser: 'string',
      dbaId: 'string',
      dbaNickName: 'string',
      ddlOnline: 'number',
      ecsInstanceId: 'string',
      ecsRegion: 'string',
      envType: 'string',
      exportTimeout: 'number',
      host: 'string',
      instanceAlias: 'string',
      instanceId: 'string',
      instanceSource: 'string',
      instanceType: 'string',
      ownerIdList: GetInstanceResponseBodyInstanceOwnerIdList,
      ownerNameList: GetInstanceResponseBodyInstanceOwnerNameList,
      port: 'number',
      queryTimeout: 'number',
      safeRuleId: 'string',
      sellSitd: 'string',
      sid: 'string',
      standardGroup: GetInstanceResponseBodyInstanceStandardGroup,
      state: 'string',
      useDsql: 'number',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLhSpaceByNameResponseBodyLakehouseSpace extends $tea.Model {
  creatorId?: string;
  description?: string;
  devDbId?: number;
  dwDbType?: string;
  id?: number;
  isDeleted?: boolean;
  mode?: number;
  prodDbId?: number;
  spaceConfig?: string;
  spaceName?: string;
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      creatorId: 'CreatorId',
      description: 'Description',
      devDbId: 'DevDbId',
      dwDbType: 'DwDbType',
      id: 'Id',
      isDeleted: 'IsDeleted',
      mode: 'Mode',
      prodDbId: 'ProdDbId',
      spaceConfig: 'SpaceConfig',
      spaceName: 'SpaceName',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorId: 'string',
      description: 'string',
      devDbId: 'number',
      dwDbType: 'string',
      id: 'number',
      isDeleted: 'boolean',
      mode: 'number',
      prodDbId: 'number',
      spaceConfig: 'string',
      spaceName: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds extends $tea.Model {
  databaseIds?: number[];
  static names(): { [key: string]: string } {
    return {
      databaseIds: 'DatabaseIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseIds: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList extends $tea.Model {
  ownerIds?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerIds: 'OwnerIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList extends $tea.Model {
  ownerNames?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerNames: 'OwnerNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLogicDatabaseResponseBodyLogicDatabase extends $tea.Model {
  alias?: string;
  databaseId?: string;
  databaseIds?: GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds;
  dbType?: string;
  envType?: string;
  logic?: boolean;
  ownerIdList?: GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList;
  ownerNameList?: GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList;
  schemaName?: string;
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      databaseId: 'DatabaseId',
      databaseIds: 'DatabaseIds',
      dbType: 'DbType',
      envType: 'EnvType',
      logic: 'Logic',
      ownerIdList: 'OwnerIdList',
      ownerNameList: 'OwnerNameList',
      schemaName: 'SchemaName',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      databaseId: 'string',
      databaseIds: GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds,
      dbType: 'string',
      envType: 'string',
      logic: 'boolean',
      ownerIdList: GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList,
      ownerNameList: GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList,
      schemaName: 'string',
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableColumnResponseBodyColumnList extends $tea.Model {
  autoIncrement?: boolean;
  columnId?: string;
  columnName?: string;
  columnType?: string;
  dataLength?: number;
  dataPrecision?: number;
  dataScale?: number;
  description?: string;
  nullable?: boolean;
  position?: number;
  primaryKey?: string;
  securityLevel?: string;
  static names(): { [key: string]: string } {
    return {
      autoIncrement: 'AutoIncrement',
      columnId: 'ColumnId',
      columnName: 'ColumnName',
      columnType: 'ColumnType',
      dataLength: 'DataLength',
      dataPrecision: 'DataPrecision',
      dataScale: 'DataScale',
      description: 'Description',
      nullable: 'Nullable',
      position: 'Position',
      primaryKey: 'PrimaryKey',
      securityLevel: 'SecurityLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoIncrement: 'boolean',
      columnId: 'string',
      columnName: 'string',
      columnType: 'string',
      dataLength: 'number',
      dataPrecision: 'number',
      dataScale: 'number',
      description: 'string',
      nullable: 'boolean',
      position: 'number',
      primaryKey: 'string',
      securityLevel: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableDetailInfoResponseBodyDetailInfoColumnList extends $tea.Model {
  autoIncrement?: boolean;
  columnId?: string;
  columnName?: string;
  columnType?: string;
  dataLength?: number;
  dataPrecision?: number;
  dataScale?: number;
  description?: string;
  nullable?: boolean;
  position?: string;
  static names(): { [key: string]: string } {
    return {
      autoIncrement: 'AutoIncrement',
      columnId: 'ColumnId',
      columnName: 'ColumnName',
      columnType: 'ColumnType',
      dataLength: 'DataLength',
      dataPrecision: 'DataPrecision',
      dataScale: 'DataScale',
      description: 'Description',
      nullable: 'Nullable',
      position: 'Position',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoIncrement: 'boolean',
      columnId: 'string',
      columnName: 'string',
      columnType: 'string',
      dataLength: 'number',
      dataPrecision: 'number',
      dataScale: 'number',
      description: 'string',
      nullable: 'boolean',
      position: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableDetailInfoResponseBodyDetailInfoIndexList extends $tea.Model {
  indexColumns?: string[];
  indexId?: string;
  indexName?: string;
  indexType?: string;
  unique?: boolean;
  static names(): { [key: string]: string } {
    return {
      indexColumns: 'IndexColumns',
      indexId: 'IndexId',
      indexName: 'IndexName',
      indexType: 'IndexType',
      unique: 'Unique',
    };
  }

  static types(): { [key: string]: any } {
    return {
      indexColumns: { 'type': 'array', 'itemType': 'string' },
      indexId: 'string',
      indexName: 'string',
      indexType: 'string',
      unique: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableDetailInfoResponseBodyDetailInfo extends $tea.Model {
  columnList?: GetMetaTableDetailInfoResponseBodyDetailInfoColumnList[];
  indexList?: GetMetaTableDetailInfoResponseBodyDetailInfoIndexList[];
  static names(): { [key: string]: string } {
    return {
      columnList: 'ColumnList',
      indexList: 'IndexList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnList: { 'type': 'array', 'itemType': GetMetaTableDetailInfoResponseBodyDetailInfoColumnList },
      indexList: { 'type': 'array', 'itemType': GetMetaTableDetailInfoResponseBodyDetailInfoIndexList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail extends $tea.Model {
  cleanStrategy?: string;
  copyChunkMode?: string;
  copyChunkSize?: number;
  copyCount?: number;
  copyTotal?: number;
  cutoverFailRetryTimes?: number;
  cutoverLockTimeSeconds?: number;
  cutoverWindowEndTime?: string;
  cutoverWindowStartTime?: string;
  delaySeconds?: number;
  jobStatus?: string;
  progressRatio?: string;
  statusDesc?: string;
  static names(): { [key: string]: string } {
    return {
      cleanStrategy: 'CleanStrategy',
      copyChunkMode: 'CopyChunkMode',
      copyChunkSize: 'CopyChunkSize',
      copyCount: 'CopyCount',
      copyTotal: 'CopyTotal',
      cutoverFailRetryTimes: 'CutoverFailRetryTimes',
      cutoverLockTimeSeconds: 'CutoverLockTimeSeconds',
      cutoverWindowEndTime: 'CutoverWindowEndTime',
      cutoverWindowStartTime: 'CutoverWindowStartTime',
      delaySeconds: 'DelaySeconds',
      jobStatus: 'JobStatus',
      progressRatio: 'ProgressRatio',
      statusDesc: 'StatusDesc',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cleanStrategy: 'string',
      copyChunkMode: 'string',
      copyChunkSize: 'number',
      copyCount: 'number',
      copyTotal: 'number',
      cutoverFailRetryTimes: 'number',
      cutoverLockTimeSeconds: 'number',
      cutoverWindowEndTime: 'string',
      cutoverWindowStartTime: 'string',
      delaySeconds: 'number',
      jobStatus: 'string',
      progressRatio: 'string',
      statusDesc: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpLogResponseBodyOpLogDetailsOpLogDetail extends $tea.Model {
  database?: string;
  module?: string;
  opContent?: string;
  opTime?: string;
  opUserId?: number;
  orderId?: number;
  userId?: string;
  userNick?: string;
  static names(): { [key: string]: string } {
    return {
      database: 'Database',
      module: 'Module',
      opContent: 'OpContent',
      opTime: 'OpTime',
      opUserId: 'OpUserId',
      orderId: 'OrderId',
      userId: 'UserId',
      userNick: 'UserNick',
    };
  }

  static types(): { [key: string]: any } {
    return {
      database: 'string',
      module: 'string',
      opContent: 'string',
      opTime: 'string',
      opUserId: 'number',
      orderId: 'number',
      userId: 'string',
      userNick: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpLogResponseBodyOpLogDetails extends $tea.Model {
  opLogDetail?: GetOpLogResponseBodyOpLogDetailsOpLogDetail[];
  static names(): { [key: string]: string } {
    return {
      opLogDetail: 'OpLogDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      opLogDetail: { 'type': 'array', 'itemType': GetOpLogResponseBodyOpLogDetailsOpLogDetail },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList extends $tea.Model {
  userIds?: string[];
  static names(): { [key: string]: string } {
    return {
      userIds: 'UserIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList extends $tea.Model {
  userNicks?: string[];
  static names(): { [key: string]: string } {
    return {
      userNicks: 'UserNicks',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userNicks: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOrderBaseInfoResponseBodyOrderBaseInfo extends $tea.Model {
  attachmentKey?: string;
  comment?: string;
  committer?: string;
  committerId?: number;
  createTime?: string;
  lastModifyTime?: string;
  orderId?: number;
  originAttachmentName?: string;
  pluginType?: string;
  relatedUserList?: GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList;
  relatedUserNickList?: GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList;
  statusCode?: string;
  statusDesc?: string;
  workflowInstanceId?: number;
  workflowStatusDesc?: string;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      committer: 'Committer',
      committerId: 'CommitterId',
      createTime: 'CreateTime',
      lastModifyTime: 'LastModifyTime',
      orderId: 'OrderId',
      originAttachmentName: 'OriginAttachmentName',
      pluginType: 'PluginType',
      relatedUserList: 'RelatedUserList',
      relatedUserNickList: 'RelatedUserNickList',
      statusCode: 'StatusCode',
      statusDesc: 'StatusDesc',
      workflowInstanceId: 'WorkflowInstanceId',
      workflowStatusDesc: 'WorkflowStatusDesc',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      committer: 'string',
      committerId: 'number',
      createTime: 'string',
      lastModifyTime: 'string',
      orderId: 'number',
      originAttachmentName: 'string',
      pluginType: 'string',
      relatedUserList: GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList,
      relatedUserNickList: GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList,
      statusCode: 'string',
      statusDesc: 'string',
      workflowInstanceId: 'number',
      workflowStatusDesc: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail extends $tea.Model {
  dbType?: string;
  envType?: string;
  ownerIds?: number[];
  ownerNickNames?: string[];
  searchName?: string;
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      dbType: 'DbType',
      envType: 'EnvType',
      ownerIds: 'OwnerIds',
      ownerNickNames: 'OwnerNickNames',
      searchName: 'SearchName',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbType: 'string',
      envType: 'string',
      ownerIds: { 'type': 'array', 'itemType': 'number' },
      ownerNickNames: { 'type': 'array', 'itemType': 'string' },
      searchName: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources extends $tea.Model {
  logic?: boolean;
  resourceDetail?: GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail;
  targetId?: string;
  static names(): { [key: string]: string } {
    return {
      logic: 'Logic',
      resourceDetail: 'ResourceDetail',
      targetId: 'TargetId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logic: 'boolean',
      resourceDetail: GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail,
      targetId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail extends $tea.Model {
  applyType?: string;
  resources?: GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources[];
  static names(): { [key: string]: string } {
    return {
      applyType: 'ApplyType',
      resources: 'Resources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyType: 'string',
      resources: { 'type': 'array', 'itemType': GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPagedInstanceResponseBodyDataInstance extends $tea.Model {
  businessTime?: string;
  checkStatus?: number;
  dagId?: number;
  delete?: string;
  endTime?: string;
  gmtCreate?: string;
  gmtModified?: string;
  historyDagId?: number;
  id?: number;
  lastRunningContext?: string;
  msg?: string;
  status?: number;
  taskType?: number;
  tenantId?: string;
  triggerType?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      businessTime: 'BusinessTime',
      checkStatus: 'CheckStatus',
      dagId: 'DagId',
      delete: 'Delete',
      endTime: 'EndTime',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      historyDagId: 'HistoryDagId',
      id: 'Id',
      lastRunningContext: 'LastRunningContext',
      msg: 'Msg',
      status: 'Status',
      taskType: 'TaskType',
      tenantId: 'TenantId',
      triggerType: 'TriggerType',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessTime: 'string',
      checkStatus: 'number',
      dagId: 'number',
      delete: 'string',
      endTime: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      historyDagId: 'number',
      id: 'number',
      lastRunningContext: 'string',
      msg: 'string',
      status: 'number',
      taskType: 'number',
      tenantId: 'string',
      triggerType: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPagedInstanceResponseBodyData extends $tea.Model {
  instance?: GetPagedInstanceResponseBodyDataInstance[];
  static names(): { [key: string]: string } {
    return {
      instance: 'Instance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instance: { 'type': 'array', 'itemType': GetPagedInstanceResponseBodyDataInstance },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo extends $tea.Model {
  columnName?: string;
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo extends $tea.Model {
  dbId?: number;
  dbType?: string;
  envType?: string;
  logic?: boolean;
  ownerIds?: number[];
  ownerNickNames?: string[];
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      dbType: 'DbType',
      envType: 'EnvType',
      logic: 'Logic',
      ownerIds: 'OwnerIds',
      ownerNickNames: 'OwnerNickNames',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      dbType: 'string',
      envType: 'string',
      logic: 'boolean',
      ownerIds: { 'type': 'array', 'itemType': 'number' },
      ownerNickNames: { 'type': 'array', 'itemType': 'string' },
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo extends $tea.Model {
  dbType?: string;
  dbaId?: number;
  dbaNickName?: string;
  envType?: string;
  host?: string;
  instanceId?: string;
  ownerIds?: number[];
  ownerNickName?: string[];
  port?: number;
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      dbType: 'DbType',
      dbaId: 'DbaId',
      dbaNickName: 'DbaNickName',
      envType: 'EnvType',
      host: 'Host',
      instanceId: 'InstanceId',
      ownerIds: 'OwnerIds',
      ownerNickName: 'OwnerNickName',
      port: 'Port',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbType: 'string',
      dbaId: 'number',
      dbaNickName: 'string',
      envType: 'string',
      host: 'string',
      instanceId: 'string',
      ownerIds: { 'type': 'array', 'itemType': 'number' },
      ownerNickName: { 'type': 'array', 'itemType': 'string' },
      port: 'number',
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo extends $tea.Model {
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources extends $tea.Model {
  columnInfo?: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo;
  databaseInfo?: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo;
  instanceInfo?: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo;
  tableInfo?: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo;
  static names(): { [key: string]: string } {
    return {
      columnInfo: 'ColumnInfo',
      databaseInfo: 'DatabaseInfo',
      instanceInfo: 'InstanceInfo',
      tableInfo: 'TableInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnInfo: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo,
      databaseInfo: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo,
      instanceInfo: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo,
      tableInfo: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail extends $tea.Model {
  applyType?: string;
  permType?: number;
  resources?: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources[];
  seconds?: number;
  static names(): { [key: string]: string } {
    return {
      applyType: 'ApplyType',
      permType: 'PermType',
      resources: 'Resources',
      seconds: 'Seconds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyType: 'string',
      permType: 'number',
      resources: { 'type': 'array', 'itemType': GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources },
      seconds: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList extends $tea.Model {
  ownerIds?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerIds: 'OwnerIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList extends $tea.Model {
  ownerNames?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerNames: 'OwnerNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPhysicalDatabaseResponseBodyDatabase extends $tea.Model {
  catalogName?: string;
  databaseId?: string;
  dbType?: string;
  dbaId?: string;
  dbaName?: string;
  encoding?: string;
  envType?: string;
  host?: string;
  instanceAlias?: string;
  instanceId?: string;
  ownerIdList?: GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList;
  ownerNameList?: GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList;
  port?: number;
  schemaName?: string;
  searchName?: string;
  sid?: string;
  state?: string;
  static names(): { [key: string]: string } {
    return {
      catalogName: 'CatalogName',
      databaseId: 'DatabaseId',
      dbType: 'DbType',
      dbaId: 'DbaId',
      dbaName: 'DbaName',
      encoding: 'Encoding',
      envType: 'EnvType',
      host: 'Host',
      instanceAlias: 'InstanceAlias',
      instanceId: 'InstanceId',
      ownerIdList: 'OwnerIdList',
      ownerNameList: 'OwnerNameList',
      port: 'Port',
      schemaName: 'SchemaName',
      searchName: 'SearchName',
      sid: 'Sid',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      catalogName: 'string',
      databaseId: 'string',
      dbType: 'string',
      dbaId: 'string',
      dbaName: 'string',
      encoding: 'string',
      envType: 'string',
      host: 'string',
      instanceAlias: 'string',
      instanceId: 'string',
      ownerIdList: GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList,
      ownerNameList: GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList,
      port: 'number',
      schemaName: 'string',
      searchName: 'string',
      sid: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProxyAccessResponseBodyProxyAccess extends $tea.Model {
  accessId?: string;
  gmtCreate?: string;
  indepAccount?: string;
  instanceId?: number;
  originInfo?: string;
  proxyAccessId?: number;
  proxyId?: number;
  userId?: number;
  userName?: string;
  userUid?: string;
  static names(): { [key: string]: string } {
    return {
      accessId: 'AccessId',
      gmtCreate: 'GmtCreate',
      indepAccount: 'IndepAccount',
      instanceId: 'InstanceId',
      originInfo: 'OriginInfo',
      proxyAccessId: 'ProxyAccessId',
      proxyId: 'ProxyId',
      userId: 'UserId',
      userName: 'UserName',
      userUid: 'UserUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessId: 'string',
      gmtCreate: 'string',
      indepAccount: 'string',
      instanceId: 'number',
      originInfo: 'string',
      proxyAccessId: 'number',
      proxyId: 'number',
      userId: 'number',
      userName: 'string',
      userUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult extends $tea.Model {
  checkNotPass?: number;
  checkPass?: number;
  forceNotPass?: number;
  forcePass?: number;
  new?: number;
  unknown?: number;
  static names(): { [key: string]: string } {
    return {
      checkNotPass: 'CheckNotPass',
      checkPass: 'CheckPass',
      forceNotPass: 'ForceNotPass',
      forcePass: 'ForcePass',
      new: 'New',
      unknown: 'Unknown',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkNotPass: 'number',
      checkPass: 'number',
      forceNotPass: 'number',
      forcePass: 'number',
      new: 'number',
      unknown: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult extends $tea.Model {
  mustImprove?: number;
  potentialIssue?: number;
  suggestImprove?: number;
  tableIndexSuggest?: number;
  useDmsDmlUnlock?: number;
  useDmsToolkit?: number;
  static names(): { [key: string]: string } {
    return {
      mustImprove: 'MustImprove',
      potentialIssue: 'PotentialIssue',
      suggestImprove: 'SuggestImprove',
      tableIndexSuggest: 'TableIndexSuggest',
      useDmsDmlUnlock: 'UseDmsDmlUnlock',
      useDmsToolkit: 'UseDmsToolkit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mustImprove: 'number',
      potentialIssue: 'number',
      suggestImprove: 'number',
      tableIndexSuggest: 'number',
      useDmsDmlUnlock: 'number',
      useDmsToolkit: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus extends $tea.Model {
  checkStatusResult?: GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult;
  checkedCount?: number;
  SQLReviewResult?: GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult;
  totalSQLCount?: number;
  static names(): { [key: string]: string } {
    return {
      checkStatusResult: 'CheckStatusResult',
      checkedCount: 'CheckedCount',
      SQLReviewResult: 'SQLReviewResult',
      totalSQLCount: 'TotalSQLCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkStatusResult: GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult,
      checkedCount: 'number',
      SQLReviewResult: GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult,
      totalSQLCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts extends $tea.Model {
  content?: string;
  opType?: string;
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      opType: 'OpType',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      opType: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults extends $tea.Model {
  comments?: string;
  feedback?: string;
  messages?: string[];
  ruleName?: string;
  ruleType?: string;
  scripts?: GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts[];
  static names(): { [key: string]: string } {
    return {
      comments: 'Comments',
      feedback: 'Feedback',
      messages: 'Messages',
      ruleName: 'RuleName',
      ruleType: 'RuleType',
      scripts: 'Scripts',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comments: 'string',
      feedback: 'string',
      messages: { 'type': 'array', 'itemType': 'string' },
      ruleName: 'string',
      ruleType: 'string',
      scripts: { 'type': 'array', 'itemType': GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult extends $tea.Model {
  errorMessage?: string;
  occurError?: boolean;
  results?: GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults[];
  static names(): { [key: string]: string } {
    return {
      errorMessage: 'ErrorMessage',
      occurError: 'OccurError',
      results: 'Results',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorMessage: 'string',
      occurError: 'boolean',
      results: { 'type': 'array', 'itemType': GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail extends $tea.Model {
  dbId?: number;
  instanceId?: number;
  qualityResult?: GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult;
  queryKey?: string;
  sqlType?: string;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      instanceId: 'InstanceId',
      qualityResult: 'QualityResult',
      queryKey: 'QueryKey',
      sqlType: 'SqlType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      instanceId: 'number',
      qualityResult: GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult,
      queryKey: 'string',
      sqlType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStandardGroupResponseBodyStandardGroup extends $tea.Model {
  dbType?: string;
  description?: string;
  groupId?: number;
  groupMode?: string;
  groupName?: string;
  lastMenderId?: number;
  static names(): { [key: string]: string } {
    return {
      dbType: 'DbType',
      description: 'Description',
      groupId: 'GroupId',
      groupMode: 'GroupMode',
      groupName: 'GroupName',
      lastMenderId: 'LastMenderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbType: 'string',
      description: 'string',
      groupId: 'number',
      groupMode: 'string',
      groupName: 'string',
      lastMenderId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail extends $tea.Model {
  execSql?: string;
  totalSqlCount?: number;
  static names(): { [key: string]: string } {
    return {
      execSql: 'ExecSql',
      totalSqlCount: 'TotalSqlCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      execSql: 'string',
      totalSqlCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList extends $tea.Model {
  script?: string;
  sourceTableName?: string;
  targetTableName?: string;
  static names(): { [key: string]: string } {
    return {
      script: 'Script',
      sourceTableName: 'SourceTableName',
      targetTableName: 'TargetTableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      script: 'string',
      sourceTableName: 'string',
      targetTableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList extends $tea.Model {
  compareType?: string;
  count?: number;
  static names(): { [key: string]: string } {
    return {
      compareType: 'CompareType',
      count: 'Count',
    };
  }

  static types(): { [key: string]: any } {
    return {
      compareType: 'string',
      count: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult extends $tea.Model {
  resultList?: GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList[];
  summaryList?: GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList[];
  static names(): { [key: string]: string } {
    return {
      resultList: 'ResultList',
      summaryList: 'SummaryList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resultList: { 'type': 'array', 'itemType': GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList },
      summaryList: { 'type': 'array', 'itemType': GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncJobDetailResponseBodyStructSyncJobDetail extends $tea.Model {
  DBTaskGroupId?: number;
  executeCount?: number;
  jobStatus?: string;
  message?: string;
  securityRule?: string;
  sqlCount?: number;
  tableAnalyzed?: number;
  tableCount?: number;
  static names(): { [key: string]: string } {
    return {
      DBTaskGroupId: 'DBTaskGroupId',
      executeCount: 'ExecuteCount',
      jobStatus: 'JobStatus',
      message: 'Message',
      securityRule: 'SecurityRule',
      sqlCount: 'SqlCount',
      tableAnalyzed: 'TableAnalyzed',
      tableCount: 'TableCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DBTaskGroupId: 'number',
      executeCount: 'number',
      jobStatus: 'string',
      message: 'string',
      securityRule: 'string',
      sqlCount: 'number',
      tableAnalyzed: 'number',
      tableCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo extends $tea.Model {
  dbId?: number;
  dbType?: string;
  envType?: string;
  logic?: boolean;
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      dbType: 'DbType',
      envType: 'EnvType',
      logic: 'Logic',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      dbType: 'string',
      envType: 'string',
      logic: 'boolean',
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo extends $tea.Model {
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      versionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList extends $tea.Model {
  sourceTableName?: string;
  targetTableName?: string;
  static names(): { [key: string]: string } {
    return {
      sourceTableName: 'SourceTableName',
      targetTableName: 'TargetTableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sourceTableName: 'string',
      targetTableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo extends $tea.Model {
  dbId?: number;
  dbType?: string;
  envType?: string;
  logic?: boolean;
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      dbType: 'DbType',
      envType: 'EnvType',
      logic: 'Logic',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      dbType: 'string',
      envType: 'string',
      logic: 'boolean',
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo extends $tea.Model {
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      versionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail extends $tea.Model {
  ignoreError?: boolean;
  sourceDatabaseInfo?: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo;
  sourceType?: string;
  sourceVersionInfo?: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo;
  tableInfoList?: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList[];
  targetDatabaseInfo?: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo;
  targetType?: string;
  targetVersionInfo?: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo;
  static names(): { [key: string]: string } {
    return {
      ignoreError: 'IgnoreError',
      sourceDatabaseInfo: 'SourceDatabaseInfo',
      sourceType: 'SourceType',
      sourceVersionInfo: 'SourceVersionInfo',
      tableInfoList: 'TableInfoList',
      targetDatabaseInfo: 'TargetDatabaseInfo',
      targetType: 'TargetType',
      targetVersionInfo: 'TargetVersionInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ignoreError: 'boolean',
      sourceDatabaseInfo: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo,
      sourceType: 'string',
      sourceVersionInfo: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo,
      tableInfoList: { 'type': 'array', 'itemType': GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList },
      targetDatabaseInfo: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo,
      targetType: 'string',
      targetVersionInfo: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList extends $tea.Model {
  tableId?: string;
  tableName?: string;
  tableType?: string;
  static names(): { [key: string]: string } {
    return {
      tableId: 'TableId',
      tableName: 'TableName',
      tableType: 'TableType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tableId: 'string',
      tableName: 'string',
      tableType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList extends $tea.Model {
  dbId?: string;
  dbName?: string;
  dbType?: string;
  envType?: string;
  tableList?: GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList[];
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      dbName: 'DbName',
      dbType: 'DbType',
      envType: 'EnvType',
      tableList: 'TableList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'string',
      dbName: 'string',
      dbType: 'string',
      envType: 'string',
      tableList: { 'type': 'array', 'itemType': GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDBTopologyResponseBodyDBTopologyDataSourceList extends $tea.Model {
  databaseList?: GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList[];
  dbType?: string;
  host?: string;
  port?: number;
  sid?: string;
  static names(): { [key: string]: string } {
    return {
      databaseList: 'DatabaseList',
      dbType: 'DbType',
      host: 'Host',
      port: 'Port',
      sid: 'Sid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseList: { 'type': 'array', 'itemType': GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList },
      dbType: 'string',
      host: 'string',
      port: 'number',
      sid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDBTopologyResponseBodyDBTopology extends $tea.Model {
  dataSourceList?: GetTableDBTopologyResponseBodyDBTopologyDataSourceList[];
  tableGuid?: string;
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      dataSourceList: 'DataSourceList',
      tableGuid: 'TableGuid',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceList: { 'type': 'array', 'itemType': GetTableDBTopologyResponseBodyDBTopologyDataSourceList },
      tableGuid: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDesignProjectFlowResponseBodyProjectFlowFlowNodeArray extends $tea.Model {
  backToDesign?: boolean;
  canSkip?: boolean;
  nodeRole?: string;
  nodeTitle?: string;
  position?: number;
  publishAnchor?: boolean;
  publishStrategies?: string[];
  static names(): { [key: string]: string } {
    return {
      backToDesign: 'BackToDesign',
      canSkip: 'CanSkip',
      nodeRole: 'NodeRole',
      nodeTitle: 'NodeTitle',
      position: 'Position',
      publishAnchor: 'PublishAnchor',
      publishStrategies: 'PublishStrategies',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backToDesign: 'boolean',
      canSkip: 'boolean',
      nodeRole: 'string',
      nodeTitle: 'string',
      position: 'number',
      publishAnchor: 'boolean',
      publishStrategies: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDesignProjectFlowResponseBodyProjectFlow extends $tea.Model {
  currentPosition?: number;
  flowNodeArray?: GetTableDesignProjectFlowResponseBodyProjectFlowFlowNodeArray[];
  ruleComment?: string;
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      currentPosition: 'CurrentPosition',
      flowNodeArray: 'FlowNodeArray',
      ruleComment: 'RuleComment',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPosition: 'number',
      flowNodeArray: { 'type': 'array', 'itemType': GetTableDesignProjectFlowResponseBodyProjectFlowFlowNodeArray },
      ruleComment: 'string',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDesignProjectInfoResponseBodyProjectInfoBaseDatabase extends $tea.Model {
  alias?: string;
  dbId?: number;
  dbType?: string;
  envType?: string;
  logic?: boolean;
  schemaName?: string;
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      dbId: 'DbId',
      dbType: 'DbType',
      envType: 'EnvType',
      logic: 'Logic',
      schemaName: 'SchemaName',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      dbId: 'number',
      dbType: 'string',
      envType: 'string',
      logic: 'boolean',
      schemaName: 'string',
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDesignProjectInfoResponseBodyProjectInfo extends $tea.Model {
  baseDatabase?: GetTableDesignProjectInfoResponseBodyProjectInfoBaseDatabase;
  creatorId?: number;
  description?: string;
  gmtCreate?: string;
  gmtModified?: string;
  orderId?: number;
  projectId?: number;
  status?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      baseDatabase: 'BaseDatabase',
      creatorId: 'CreatorId',
      description: 'Description',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      orderId: 'OrderId',
      projectId: 'ProjectId',
      status: 'Status',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baseDatabase: GetTableDesignProjectInfoResponseBodyProjectInfoBaseDatabase,
      creatorId: 'number',
      description: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      orderId: 'number',
      projectId: 'number',
      status: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList extends $tea.Model {
  dbId?: number;
  dbName?: string;
  dbSearchName?: string;
  dbType?: string;
  instanceId?: number;
  instanceResourceId?: string;
  instanceSource?: string;
  regionId?: string;
  tableCount?: number;
  tableNameExpr?: string;
  tableNameList?: string;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      dbName: 'DbName',
      dbSearchName: 'DbSearchName',
      dbType: 'DbType',
      instanceId: 'InstanceId',
      instanceResourceId: 'InstanceResourceId',
      instanceSource: 'InstanceSource',
      regionId: 'RegionId',
      tableCount: 'TableCount',
      tableNameExpr: 'TableNameExpr',
      tableNameList: 'TableNameList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      dbName: 'string',
      dbSearchName: 'string',
      dbType: 'string',
      instanceId: 'number',
      instanceResourceId: 'string',
      instanceSource: 'string',
      regionId: 'string',
      tableCount: 'number',
      tableNameExpr: 'string',
      tableNameList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableTopologyResponseBodyTableTopology extends $tea.Model {
  logic?: boolean;
  tableGuid?: string;
  tableName?: string;
  tableTopologyInfoList?: GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList[];
  static names(): { [key: string]: string } {
    return {
      logic: 'Logic',
      tableGuid: 'TableGuid',
      tableName: 'TableName',
      tableTopologyInfoList: 'TableTopologyInfoList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logic: 'boolean',
      tableGuid: 'string',
      tableName: 'string',
      tableTopologyInfoList: { 'type': 'array', 'itemType': GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskResponseBodyTask extends $tea.Model {
  dagId?: number;
  graphParam?: string;
  nodeConfig?: string;
  nodeContent?: string;
  nodeName?: string;
  nodeOutput?: string;
  nodeType?: string;
  timeVariables?: string;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      graphParam: 'GraphParam',
      nodeConfig: 'NodeConfig',
      nodeContent: 'NodeContent',
      nodeName: 'NodeName',
      nodeOutput: 'NodeOutput',
      nodeType: 'NodeType',
      timeVariables: 'TimeVariables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      graphParam: 'string',
      nodeConfig: 'string',
      nodeContent: 'string',
      nodeName: 'string',
      nodeOutput: 'string',
      nodeType: 'string',
      timeVariables: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge extends $tea.Model {
  dagId?: number;
  id?: number;
  nodeEnd?: number;
  nodeFrom?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      id: 'Id',
      nodeEnd: 'NodeEnd',
      nodeFrom: 'NodeFrom',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      id: 'number',
      nodeEnd: 'number',
      nodeFrom: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskFlowGraphResponseBodyTaskFlowGraphEdges extends $tea.Model {
  edge?: GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge[];
  static names(): { [key: string]: string } {
    return {
      edge: 'Edge',
    };
  }

  static types(): { [key: string]: any } {
    return {
      edge: { 'type': 'array', 'itemType': GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode extends $tea.Model {
  dagId?: number;
  graphParam?: string;
  nodeConfig?: string;
  nodeContent?: string;
  nodeId?: number;
  nodeName?: string;
  nodeType?: number;
  timeVariables?: string;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      graphParam: 'GraphParam',
      nodeConfig: 'NodeConfig',
      nodeContent: 'NodeContent',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      nodeType: 'NodeType',
      timeVariables: 'TimeVariables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      graphParam: 'string',
      nodeConfig: 'string',
      nodeContent: 'string',
      nodeId: 'number',
      nodeName: 'string',
      nodeType: 'number',
      timeVariables: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskFlowGraphResponseBodyTaskFlowGraphNodes extends $tea.Model {
  node?: GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode[];
  static names(): { [key: string]: string } {
    return {
      node: 'Node',
    };
  }

  static types(): { [key: string]: any } {
    return {
      node: { 'type': 'array', 'itemType': GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskFlowGraphResponseBodyTaskFlowGraph extends $tea.Model {
  canEdit?: boolean;
  dagName?: string;
  edges?: GetTaskFlowGraphResponseBodyTaskFlowGraphEdges;
  nodes?: GetTaskFlowGraphResponseBodyTaskFlowGraphNodes;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      canEdit: 'CanEdit',
      dagName: 'DagName',
      edges: 'Edges',
      nodes: 'Nodes',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canEdit: 'boolean',
      dagName: 'string',
      edges: GetTaskFlowGraphResponseBodyTaskFlowGraphEdges,
      nodes: GetTaskFlowGraphResponseBodyTaskFlowGraphNodes,
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskFlowNotificationResponseBodyNotification extends $tea.Model {
  dagNotificationFail?: boolean;
  dagNotificationSla?: boolean;
  dagNotificationSuccess?: boolean;
  static names(): { [key: string]: string } {
    return {
      dagNotificationFail: 'DagNotificationFail',
      dagNotificationSla: 'DagNotificationSla',
      dagNotificationSuccess: 'DagNotificationSuccess',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagNotificationFail: 'boolean',
      dagNotificationSla: 'boolean',
      dagNotificationSuccess: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskInstanceRelationResponseBodyNodeListNode extends $tea.Model {
  businessTime?: string;
  endTime?: string;
  executeTime?: number;
  id?: number;
  message?: string;
  nodeId?: number;
  nodeName?: string;
  nodeType?: number;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      businessTime: 'BusinessTime',
      endTime: 'EndTime',
      executeTime: 'ExecuteTime',
      id: 'Id',
      message: 'Message',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      nodeType: 'NodeType',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessTime: 'string',
      endTime: 'string',
      executeTime: 'number',
      id: 'number',
      message: 'string',
      nodeId: 'number',
      nodeName: 'string',
      nodeType: 'number',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskInstanceRelationResponseBodyNodeList extends $tea.Model {
  node?: GetTaskInstanceRelationResponseBodyNodeListNode[];
  static names(): { [key: string]: string } {
    return {
      node: 'Node',
    };
  }

  static types(): { [key: string]: any } {
    return {
      node: { 'type': 'array', 'itemType': GetTaskInstanceRelationResponseBodyNodeListNode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserResponseBodyUserRoleIdList extends $tea.Model {
  roleIds?: number[];
  static names(): { [key: string]: string } {
    return {
      roleIds: 'RoleIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleIds: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserResponseBodyUserRoleNameList extends $tea.Model {
  roleNames?: string[];
  static names(): { [key: string]: string } {
    return {
      roleNames: 'RoleNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserResponseBodyUser extends $tea.Model {
  curExecuteCount?: number;
  curResultCount?: number;
  dingRobot?: string;
  email?: string;
  lastLoginTime?: string;
  maxExecuteCount?: number;
  maxResultCount?: number;
  mobile?: string;
  nickName?: string;
  notificationMode?: string;
  parentUid?: number;
  roleIdList?: GetUserResponseBodyUserRoleIdList;
  roleNameList?: GetUserResponseBodyUserRoleNameList;
  signatureMethod?: string;
  state?: string;
  uid?: string;
  userId?: string;
  webhook?: string;
  static names(): { [key: string]: string } {
    return {
      curExecuteCount: 'CurExecuteCount',
      curResultCount: 'CurResultCount',
      dingRobot: 'DingRobot',
      email: 'Email',
      lastLoginTime: 'LastLoginTime',
      maxExecuteCount: 'MaxExecuteCount',
      maxResultCount: 'MaxResultCount',
      mobile: 'Mobile',
      nickName: 'NickName',
      notificationMode: 'NotificationMode',
      parentUid: 'ParentUid',
      roleIdList: 'RoleIdList',
      roleNameList: 'RoleNameList',
      signatureMethod: 'SignatureMethod',
      state: 'State',
      uid: 'Uid',
      userId: 'UserId',
      webhook: 'Webhook',
    };
  }

  static types(): { [key: string]: any } {
    return {
      curExecuteCount: 'number',
      curResultCount: 'number',
      dingRobot: 'string',
      email: 'string',
      lastLoginTime: 'string',
      maxExecuteCount: 'number',
      maxResultCount: 'number',
      mobile: 'string',
      nickName: 'string',
      notificationMode: 'string',
      parentUid: 'number',
      roleIdList: GetUserResponseBodyUserRoleIdList,
      roleNameList: GetUserResponseBodyUserRoleNameList,
      signatureMethod: 'string',
      state: 'string',
      uid: 'string',
      userId: 'string',
      webhook: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserActiveTenantResponseBodyTenant extends $tea.Model {
  status?: string;
  tenantName?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      tenantName: 'TenantName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      tenantName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam extends $tea.Model {
  bucketName?: string;
  endpoint?: string;
  objectName?: string;
  static names(): { [key: string]: string } {
    return {
      bucketName: 'BucketName',
      endpoint: 'Endpoint',
      objectName: 'ObjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bucketName: 'string',
      endpoint: 'string',
      objectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserUploadFileJobResponseBodyUploadFileJobDetail extends $tea.Model {
  attachmentKey?: string;
  fileName?: string;
  fileSize?: number;
  fileSource?: string;
  jobKey?: string;
  jobStatus?: string;
  jobStatusDesc?: string;
  uploadOSSParam?: GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam;
  uploadType?: string;
  uploadURL?: string;
  uploadedSize?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      fileName: 'FileName',
      fileSize: 'FileSize',
      fileSource: 'FileSource',
      jobKey: 'JobKey',
      jobStatus: 'JobStatus',
      jobStatusDesc: 'JobStatusDesc',
      uploadOSSParam: 'UploadOSSParam',
      uploadType: 'UploadType',
      uploadURL: 'UploadURL',
      uploadedSize: 'UploadedSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      fileName: 'string',
      fileSize: 'number',
      fileSource: 'string',
      jobKey: 'string',
      jobStatus: 'string',
      jobStatusDesc: 'string',
      uploadOSSParam: GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam,
      uploadType: 'string',
      uploadURL: 'string',
      uploadedSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView extends $tea.Model {
  createTime?: string;
  creatorId?: number;
  description?: string;
  name?: string;
  templateId?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      creatorId: 'CreatorId',
      description: 'Description',
      name: 'Name',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      creatorId: 'number',
      description: 'string',
      name: 'string',
      templateId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAuthorityTemplateResponseBodyAuthorityTemplateViewList extends $tea.Model {
  authorityTemplateView?: ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView[];
  static names(): { [key: string]: string } {
    return {
      authorityTemplateView: 'AuthorityTemplateView',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorityTemplateView: { 'type': 'array', 'itemType': ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClassificationTemplatesResponseBodyTemplateList extends $tea.Model {
  name?: string;
  remark?: string;
  templateId?: number;
  templateType?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      remark: 'Remark',
      templateId: 'TemplateId',
      templateType: 'TemplateType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      remark: 'string',
      templateId: 'number',
      templateType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListColumnsResponseBodyColumnListColumn extends $tea.Model {
  autoIncrement?: boolean;
  columnId?: string;
  columnName?: string;
  columnType?: string;
  dataLength?: number;
  dataPrecision?: number;
  dataScale?: number;
  defaultValue?: string;
  description?: string;
  functionType?: string;
  nullable?: boolean;
  securityLevel?: string;
  sensitive?: boolean;
  static names(): { [key: string]: string } {
    return {
      autoIncrement: 'AutoIncrement',
      columnId: 'ColumnId',
      columnName: 'ColumnName',
      columnType: 'ColumnType',
      dataLength: 'DataLength',
      dataPrecision: 'DataPrecision',
      dataScale: 'DataScale',
      defaultValue: 'DefaultValue',
      description: 'Description',
      functionType: 'FunctionType',
      nullable: 'Nullable',
      securityLevel: 'SecurityLevel',
      sensitive: 'Sensitive',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoIncrement: 'boolean',
      columnId: 'string',
      columnName: 'string',
      columnType: 'string',
      dataLength: 'number',
      dataPrecision: 'number',
      dataScale: 'number',
      defaultValue: 'string',
      description: 'string',
      functionType: 'string',
      nullable: 'boolean',
      securityLevel: 'string',
      sensitive: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListColumnsResponseBodyColumnList extends $tea.Model {
  column?: ListColumnsResponseBodyColumnListColumn[];
  static names(): { [key: string]: string } {
    return {
      column: 'Column',
    };
  }

  static types(): { [key: string]: any } {
    return {
      column: { 'type': 'array', 'itemType': ListColumnsResponseBodyColumnListColumn },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDAGVersionsResponseBodyDagVersionListDagVersion extends $tea.Model {
  dagName?: string;
  dagOwnerId?: string;
  dagOwnerNickName?: string;
  lastVersionId?: number;
  versionComments?: string;
  versionId?: number;
  static names(): { [key: string]: string } {
    return {
      dagName: 'DagName',
      dagOwnerId: 'DagOwnerId',
      dagOwnerNickName: 'DagOwnerNickName',
      lastVersionId: 'LastVersionId',
      versionComments: 'VersionComments',
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagName: 'string',
      dagOwnerId: 'string',
      dagOwnerNickName: 'string',
      lastVersionId: 'number',
      versionComments: 'string',
      versionId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDAGVersionsResponseBodyDagVersionList extends $tea.Model {
  dagVersion?: ListDAGVersionsResponseBodyDagVersionListDagVersion[];
  static names(): { [key: string]: string } {
    return {
      dagVersion: 'DagVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagVersion: { 'type': 'array', 'itemType': ListDAGVersionsResponseBodyDagVersionListDagVersion },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDBTaskSQLJobResponseBodyDBTaskSQLJobList extends $tea.Model {
  comment?: string;
  createTime?: string;
  dbId?: number;
  dbSearchName?: string;
  dbTaskGroupId?: number;
  jobId?: number;
  jobType?: string;
  lastExecTime?: string;
  logic?: boolean;
  status?: string;
  transactional?: boolean;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      createTime: 'CreateTime',
      dbId: 'DbId',
      dbSearchName: 'DbSearchName',
      dbTaskGroupId: 'DbTaskGroupId',
      jobId: 'JobId',
      jobType: 'JobType',
      lastExecTime: 'LastExecTime',
      logic: 'Logic',
      status: 'Status',
      transactional: 'Transactional',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      createTime: 'string',
      dbId: 'number',
      dbSearchName: 'string',
      dbTaskGroupId: 'number',
      jobId: 'number',
      jobType: 'string',
      lastExecTime: 'string',
      logic: 'boolean',
      status: 'string',
      transactional: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList extends $tea.Model {
  affectRows?: number;
  currentSql?: string;
  dbId?: number;
  endTime?: string;
  executeCount?: number;
  jobDetailId?: number;
  jobId?: number;
  log?: string;
  logic?: boolean;
  skip?: boolean;
  sqlType?: string;
  startTime?: string;
  status?: string;
  timeDelay?: number;
  static names(): { [key: string]: string } {
    return {
      affectRows: 'AffectRows',
      currentSql: 'CurrentSql',
      dbId: 'DbId',
      endTime: 'EndTime',
      executeCount: 'ExecuteCount',
      jobDetailId: 'JobDetailId',
      jobId: 'JobId',
      log: 'Log',
      logic: 'Logic',
      skip: 'Skip',
      sqlType: 'SqlType',
      startTime: 'StartTime',
      status: 'Status',
      timeDelay: 'TimeDelay',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affectRows: 'number',
      currentSql: 'string',
      dbId: 'number',
      endTime: 'string',
      executeCount: 'number',
      jobDetailId: 'number',
      jobId: 'number',
      log: 'string',
      logic: 'boolean',
      skip: 'boolean',
      sqlType: 'string',
      startTime: 'string',
      status: 'string',
      timeDelay: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList extends $tea.Model {
  DBTaskGroupId?: number;
  executeCount?: number;
  scripts?: string;
  statusDesc?: string;
  tableName?: string;
  taskJobStatus?: string;
  static names(): { [key: string]: string } {
    return {
      DBTaskGroupId: 'DBTaskGroupId',
      executeCount: 'ExecuteCount',
      scripts: 'Scripts',
      statusDesc: 'StatusDesc',
      tableName: 'TableName',
      taskJobStatus: 'TaskJobStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DBTaskGroupId: 'number',
      executeCount: 'number',
      scripts: 'string',
      statusDesc: 'string',
      tableName: 'string',
      taskJobStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList extends $tea.Model {
  dbId?: number;
  logic?: boolean;
  planTime?: string;
  publishJobList?: ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList[];
  publishStrategy?: string;
  statusDesc?: string;
  taskJobStatus?: string;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      logic: 'Logic',
      planTime: 'PlanTime',
      publishJobList: 'PublishJobList',
      publishStrategy: 'PublishStrategy',
      statusDesc: 'StatusDesc',
      taskJobStatus: 'TaskJobStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      logic: 'boolean',
      planTime: 'string',
      publishJobList: { 'type': 'array', 'itemType': ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList },
      publishStrategy: 'string',
      statusDesc: 'string',
      taskJobStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDDLPublishRecordsResponseBodyDDLPublishRecordList extends $tea.Model {
  auditExpireTime?: string;
  auditStatus?: string;
  comment?: string;
  creatorId?: number;
  finality?: boolean;
  finalityReason?: string;
  publishStatus?: string;
  publishTaskInfoList?: ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList[];
  riskLevel?: string;
  statusDesc?: string;
  workflowInstanceId?: number;
  static names(): { [key: string]: string } {
    return {
      auditExpireTime: 'AuditExpireTime',
      auditStatus: 'AuditStatus',
      comment: 'Comment',
      creatorId: 'CreatorId',
      finality: 'Finality',
      finalityReason: 'FinalityReason',
      publishStatus: 'PublishStatus',
      publishTaskInfoList: 'PublishTaskInfoList',
      riskLevel: 'RiskLevel',
      statusDesc: 'StatusDesc',
      workflowInstanceId: 'WorkflowInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      auditExpireTime: 'string',
      auditStatus: 'string',
      comment: 'string',
      creatorId: 'number',
      finality: 'boolean',
      finalityReason: 'string',
      publishStatus: 'string',
      publishTaskInfoList: { 'type': 'array', 'itemType': ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList },
      riskLevel: 'string',
      statusDesc: 'string',
      workflowInstanceId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataCorrectPreCheckDBResponseBodyPreCheckDBList extends $tea.Model {
  dbId?: number;
  searchName?: string;
  sqlNum?: number;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      searchName: 'SearchName',
      sqlNum: 'SqlNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      searchName: 'string',
      sqlNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList extends $tea.Model {
  affectRows?: number;
  checkSQL?: string;
  dbId?: number;
  SQLReviewQueryKey?: string;
  sqlReviewStatus?: string;
  sqlType?: string;
  tableNames?: string;
  static names(): { [key: string]: string } {
    return {
      affectRows: 'AffectRows',
      checkSQL: 'CheckSQL',
      dbId: 'DbId',
      SQLReviewQueryKey: 'SQLReviewQueryKey',
      sqlReviewStatus: 'SqlReviewStatus',
      sqlType: 'SqlType',
      tableNames: 'TableNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affectRows: 'number',
      checkSQL: 'string',
      dbId: 'number',
      SQLReviewQueryKey: 'string',
      sqlReviewStatus: 'string',
      sqlType: 'string',
      tableNames: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList extends $tea.Model {
  skip?: boolean;
  sqlId?: number;
  sqlType?: string;
  statusCode?: string;
  static names(): { [key: string]: string } {
    return {
      skip: 'Skip',
      sqlId: 'SqlId',
      sqlType: 'SqlType',
      statusCode: 'StatusCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      skip: 'boolean',
      sqlId: 'number',
      sqlType: 'string',
      statusCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail extends $tea.Model {
  createDate?: string;
  expireDate?: string;
  extraData?: string;
  originFrom?: string;
  permType?: string;
  userAccessId?: string;
  static names(): { [key: string]: string } {
    return {
      createDate: 'CreateDate',
      expireDate: 'ExpireDate',
      extraData: 'ExtraData',
      originFrom: 'OriginFrom',
      permType: 'PermType',
      userAccessId: 'UserAccessId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createDate: 'string',
      expireDate: 'string',
      extraData: 'string',
      originFrom: 'string',
      permType: 'string',
      userAccessId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails extends $tea.Model {
  permDetail?: ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail[];
  static names(): { [key: string]: string } {
    return {
      permDetail: 'PermDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      permDetail: { 'type': 'array', 'itemType': ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission extends $tea.Model {
  alias?: string;
  columnName?: string;
  dbId?: string;
  dbType?: string;
  dsType?: string;
  envType?: string;
  instanceId?: string;
  logic?: boolean;
  permDetails?: ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails;
  schemaName?: string;
  searchName?: string;
  tableId?: string;
  tableName?: string;
  userId?: string;
  userNickName?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      columnName: 'ColumnName',
      dbId: 'DbId',
      dbType: 'DbType',
      dsType: 'DsType',
      envType: 'EnvType',
      instanceId: 'InstanceId',
      logic: 'Logic',
      permDetails: 'PermDetails',
      schemaName: 'SchemaName',
      searchName: 'SearchName',
      tableId: 'TableId',
      tableName: 'TableName',
      userId: 'UserId',
      userNickName: 'UserNickName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      columnName: 'string',
      dbId: 'string',
      dbType: 'string',
      dsType: 'string',
      envType: 'string',
      instanceId: 'string',
      logic: 'boolean',
      permDetails: ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails,
      schemaName: 'string',
      searchName: 'string',
      tableId: 'string',
      tableName: 'string',
      userId: 'string',
      userNickName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabaseUserPermssionsResponseBodyUserPermissions extends $tea.Model {
  userPermission?: ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission[];
  static names(): { [key: string]: string } {
    return {
      userPermission: 'UserPermission',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userPermission: { 'type': 'array', 'itemType': ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList extends $tea.Model {
  ownerIds?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerIds: 'OwnerIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList extends $tea.Model {
  ownerNames?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerNames: 'OwnerNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabasesResponseBodyDatabaseListDatabase extends $tea.Model {
  catalogName?: string;
  databaseId?: string;
  dbType?: string;
  dbaId?: string;
  dbaName?: string;
  encoding?: string;
  envType?: string;
  host?: string;
  instanceId?: string;
  ownerIdList?: ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList;
  ownerNameList?: ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList;
  port?: number;
  schemaName?: string;
  searchName?: string;
  sid?: string;
  state?: string;
  static names(): { [key: string]: string } {
    return {
      catalogName: 'CatalogName',
      databaseId: 'DatabaseId',
      dbType: 'DbType',
      dbaId: 'DbaId',
      dbaName: 'DbaName',
      encoding: 'Encoding',
      envType: 'EnvType',
      host: 'Host',
      instanceId: 'InstanceId',
      ownerIdList: 'OwnerIdList',
      ownerNameList: 'OwnerNameList',
      port: 'Port',
      schemaName: 'SchemaName',
      searchName: 'SearchName',
      sid: 'Sid',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      catalogName: 'string',
      databaseId: 'string',
      dbType: 'string',
      dbaId: 'string',
      dbaName: 'string',
      encoding: 'string',
      envType: 'string',
      host: 'string',
      instanceId: 'string',
      ownerIdList: ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList,
      ownerNameList: ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList,
      port: 'number',
      schemaName: 'string',
      searchName: 'string',
      sid: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabasesResponseBodyDatabaseList extends $tea.Model {
  database?: ListDatabasesResponseBodyDatabaseListDatabase[];
  static names(): { [key: string]: string } {
    return {
      database: 'Database',
    };
  }

  static types(): { [key: string]: any } {
    return {
      database: { 'type': 'array', 'itemType': ListDatabasesResponseBodyDatabaseListDatabase },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDefaultSLARulesResponseBodySLARuleListSLARule extends $tea.Model {
  dagId?: number;
  id?: number;
  intervalMinutes?: number;
  nodeId?: number;
  ruleType?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      id: 'Id',
      intervalMinutes: 'IntervalMinutes',
      nodeId: 'NodeId',
      ruleType: 'RuleType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      id: 'number',
      intervalMinutes: 'number',
      nodeId: 'number',
      ruleType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDefaultSLARulesResponseBodySLARuleList extends $tea.Model {
  SLARule?: ListDefaultSLARulesResponseBodySLARuleListSLARule[];
  static names(): { [key: string]: string } {
    return {
      SLARule: 'SLARule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      SLARule: { 'type': 'array', 'itemType': ListDefaultSLARulesResponseBodySLARuleListSLARule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDesensitizationRuleResponseBodyDesensitizationRuleList extends $tea.Model {
  funcParams?: string;
  funcSample?: string;
  functionType?: string;
  lastModifierId?: string;
  lastModifierName?: string;
  referenceCount?: number;
  ruleDesc?: string;
  ruleId?: number;
  ruleName?: string;
  ruleType?: string;
  static names(): { [key: string]: string } {
    return {
      funcParams: 'FuncParams',
      funcSample: 'FuncSample',
      functionType: 'FunctionType',
      lastModifierId: 'LastModifierId',
      lastModifierName: 'LastModifierName',
      referenceCount: 'ReferenceCount',
      ruleDesc: 'RuleDesc',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      ruleType: 'RuleType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      funcParams: 'string',
      funcSample: 'string',
      functionType: 'string',
      lastModifierId: 'string',
      lastModifierName: 'string',
      referenceCount: 'number',
      ruleDesc: 'string',
      ruleId: 'number',
      ruleName: 'string',
      ruleType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEffectiveOrdersResponseBodyOrderSummaryOrderList extends $tea.Model {
  buyerId?: string;
  endTime?: string;
  insNum?: string;
  instanceId?: string;
  orderId?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      buyerId: 'BuyerId',
      endTime: 'EndTime',
      insNum: 'InsNum',
      instanceId: 'InstanceId',
      orderId: 'OrderId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      buyerId: 'string',
      endTime: 'string',
      insNum: 'string',
      instanceId: 'string',
      orderId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEffectiveOrdersResponseBodyOrderSummary extends $tea.Model {
  commodityCode?: string;
  commodityType?: string;
  orderList?: ListEffectiveOrdersResponseBodyOrderSummaryOrderList[];
  totalQuota?: number;
  versionType?: string;
  static names(): { [key: string]: string } {
    return {
      commodityCode: 'CommodityCode',
      commodityType: 'CommodityType',
      orderList: 'OrderList',
      totalQuota: 'TotalQuota',
      versionType: 'VersionType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commodityCode: 'string',
      commodityType: 'string',
      orderList: { 'type': 'array', 'itemType': ListEffectiveOrdersResponseBodyOrderSummaryOrderList },
      totalQuota: 'number',
      versionType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListIndexesResponseBodyIndexListIndex extends $tea.Model {
  indexComment?: string;
  indexId?: string;
  indexName?: string;
  indexType?: string;
  tableId?: string;
  static names(): { [key: string]: string } {
    return {
      indexComment: 'IndexComment',
      indexId: 'IndexId',
      indexName: 'IndexName',
      indexType: 'IndexType',
      tableId: 'TableId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      indexComment: 'string',
      indexId: 'string',
      indexName: 'string',
      indexType: 'string',
      tableId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListIndexesResponseBodyIndexList extends $tea.Model {
  index?: ListIndexesResponseBodyIndexListIndex[];
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: { 'type': 'array', 'itemType': ListIndexesResponseBodyIndexListIndex },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog extends $tea.Model {
  dbUser?: string;
  instanceId?: number;
  instanceName?: string;
  opTime?: string;
  requestIp?: string;
  userId?: number;
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      dbUser: 'DbUser',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      opTime: 'OpTime',
      requestIp: 'RequestIp',
      userId: 'UserId',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbUser: 'string',
      instanceId: 'number',
      instanceName: 'string',
      opTime: 'string',
      requestIp: 'string',
      userId: 'number',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList extends $tea.Model {
  instanceLoginAuditLog?: ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog[];
  static names(): { [key: string]: string } {
    return {
      instanceLoginAuditLog: 'InstanceLoginAuditLog',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceLoginAuditLog: { 'type': 'array', 'itemType': ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail extends $tea.Model {
  createDate?: string;
  expireDate?: string;
  extraData?: string;
  originFrom?: string;
  permType?: string;
  userAccessId?: string;
  static names(): { [key: string]: string } {
    return {
      createDate: 'CreateDate',
      expireDate: 'ExpireDate',
      extraData: 'ExtraData',
      originFrom: 'OriginFrom',
      permType: 'PermType',
      userAccessId: 'UserAccessId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createDate: 'string',
      expireDate: 'string',
      extraData: 'string',
      originFrom: 'string',
      permType: 'string',
      userAccessId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails extends $tea.Model {
  permDetail?: ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail[];
  static names(): { [key: string]: string } {
    return {
      permDetail: 'PermDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      permDetail: { 'type': 'array', 'itemType': ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission extends $tea.Model {
  instanceId?: string;
  permDetails?: ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails;
  userId?: string;
  userNickName?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      permDetails: 'PermDetails',
      userId: 'UserId',
      userNickName: 'UserNickName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      permDetails: ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails,
      userId: 'string',
      userNickName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceUserPermissionsResponseBodyUserPermissions extends $tea.Model {
  userPermission?: ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission[];
  static names(): { [key: string]: string } {
    return {
      userPermission: 'UserPermission',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userPermission: { 'type': 'array', 'itemType': ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstancesResponseBodyInstanceListInstanceOwnerIdList extends $tea.Model {
  ownerIds?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerIds: 'OwnerIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstancesResponseBodyInstanceListInstanceOwnerNameList extends $tea.Model {
  ownerNames?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerNames: 'OwnerNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstancesResponseBodyInstanceListInstanceStandardGroup extends $tea.Model {
  groupMode?: string;
  groupName?: string;
  static names(): { [key: string]: string } {
    return {
      groupMode: 'GroupMode',
      groupName: 'GroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupMode: 'string',
      groupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstancesResponseBodyInstanceListInstance extends $tea.Model {
  dataLinkName?: string;
  databasePassword?: string;
  databaseUser?: string;
  dbaId?: string;
  dbaNickName?: string;
  ddlOnline?: number;
  ecsInstanceId?: string;
  ecsRegion?: string;
  envType?: string;
  exportTimeout?: number;
  host?: string;
  instanceAlias?: string;
  instanceId?: string;
  instanceSource?: string;
  instanceType?: string;
  ownerIdList?: ListInstancesResponseBodyInstanceListInstanceOwnerIdList;
  ownerNameList?: ListInstancesResponseBodyInstanceListInstanceOwnerNameList;
  port?: number;
  queryTimeout?: number;
  safeRuleId?: string;
  sellSitd?: boolean;
  sid?: string;
  standardGroup?: ListInstancesResponseBodyInstanceListInstanceStandardGroup;
  state?: string;
  useDsql?: number;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      dataLinkName: 'DataLinkName',
      databasePassword: 'DatabasePassword',
      databaseUser: 'DatabaseUser',
      dbaId: 'DbaId',
      dbaNickName: 'DbaNickName',
      ddlOnline: 'DdlOnline',
      ecsInstanceId: 'EcsInstanceId',
      ecsRegion: 'EcsRegion',
      envType: 'EnvType',
      exportTimeout: 'ExportTimeout',
      host: 'Host',
      instanceAlias: 'InstanceAlias',
      instanceId: 'InstanceId',
      instanceSource: 'InstanceSource',
      instanceType: 'InstanceType',
      ownerIdList: 'OwnerIdList',
      ownerNameList: 'OwnerNameList',
      port: 'Port',
      queryTimeout: 'QueryTimeout',
      safeRuleId: 'SafeRuleId',
      sellSitd: 'SellSitd',
      sid: 'Sid',
      standardGroup: 'StandardGroup',
      state: 'State',
      useDsql: 'UseDsql',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataLinkName: 'string',
      databasePassword: 'string',
      databaseUser: 'string',
      dbaId: 'string',
      dbaNickName: 'string',
      ddlOnline: 'number',
      ecsInstanceId: 'string',
      ecsRegion: 'string',
      envType: 'string',
      exportTimeout: 'number',
      host: 'string',
      instanceAlias: 'string',
      instanceId: 'string',
      instanceSource: 'string',
      instanceType: 'string',
      ownerIdList: ListInstancesResponseBodyInstanceListInstanceOwnerIdList,
      ownerNameList: ListInstancesResponseBodyInstanceListInstanceOwnerNameList,
      port: 'number',
      queryTimeout: 'number',
      safeRuleId: 'string',
      sellSitd: 'boolean',
      sid: 'string',
      standardGroup: ListInstancesResponseBodyInstanceListInstanceStandardGroup,
      state: 'string',
      useDsql: 'number',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstancesResponseBodyInstanceList extends $tea.Model {
  instance?: ListInstancesResponseBodyInstanceListInstance[];
  static names(): { [key: string]: string } {
    return {
      instance: 'Instance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instance: { 'type': 'array', 'itemType': ListInstancesResponseBodyInstanceListInstance },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag extends $tea.Model {
  canEdit?: boolean;
  creatorId?: string;
  creatorNickName?: string;
  dagName?: string;
  dagOwnerId?: string;
  dagOwnerNickName?: string;
  dataFlowId?: number;
  demoId?: string;
  deployId?: number;
  id?: number;
  isDeleted?: boolean;
  latestInstanceStatus?: number;
  latestInstanceTime?: number;
  scenarioId?: number;
  spaceId?: number;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      canEdit: 'CanEdit',
      creatorId: 'CreatorId',
      creatorNickName: 'CreatorNickName',
      dagName: 'DagName',
      dagOwnerId: 'DagOwnerId',
      dagOwnerNickName: 'DagOwnerNickName',
      dataFlowId: 'DataFlowId',
      demoId: 'DemoId',
      deployId: 'DeployId',
      id: 'Id',
      isDeleted: 'IsDeleted',
      latestInstanceStatus: 'LatestInstanceStatus',
      latestInstanceTime: 'LatestInstanceTime',
      scenarioId: 'ScenarioId',
      spaceId: 'SpaceId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canEdit: 'boolean',
      creatorId: 'string',
      creatorNickName: 'string',
      dagName: 'string',
      dagOwnerId: 'string',
      dagOwnerNickName: 'string',
      dataFlowId: 'number',
      demoId: 'string',
      deployId: 'number',
      id: 'number',
      isDeleted: 'boolean',
      latestInstanceStatus: 'number',
      latestInstanceTime: 'number',
      scenarioId: 'number',
      spaceId: 'number',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLhTaskFlowAndScenarioResponseBodyRawDAGList extends $tea.Model {
  dag?: ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag[];
  static names(): { [key: string]: string } {
    return {
      dag: 'Dag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dag: { 'type': 'array', 'itemType': ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag extends $tea.Model {
  canEdit?: boolean;
  creatorId?: string;
  creatorNickName?: string;
  dagName?: string;
  dagOwnerId?: string;
  dagOwnerNickName?: string;
  dataFlowId?: number;
  demoId?: string;
  deployId?: number;
  id?: number;
  isDeleted?: boolean;
  latestInstanceStatus?: number;
  latestInstanceTime?: number;
  scenarioId?: number;
  spaceId?: number;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      canEdit: 'CanEdit',
      creatorId: 'CreatorId',
      creatorNickName: 'CreatorNickName',
      dagName: 'DagName',
      dagOwnerId: 'DagOwnerId',
      dagOwnerNickName: 'DagOwnerNickName',
      dataFlowId: 'DataFlowId',
      demoId: 'DemoId',
      deployId: 'DeployId',
      id: 'Id',
      isDeleted: 'IsDeleted',
      latestInstanceStatus: 'LatestInstanceStatus',
      latestInstanceTime: 'LatestInstanceTime',
      scenarioId: 'ScenarioId',
      spaceId: 'SpaceId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canEdit: 'boolean',
      creatorId: 'string',
      creatorNickName: 'string',
      dagName: 'string',
      dagOwnerId: 'string',
      dagOwnerNickName: 'string',
      dataFlowId: 'number',
      demoId: 'string',
      deployId: 'number',
      id: 'number',
      isDeleted: 'boolean',
      latestInstanceStatus: 'number',
      latestInstanceTime: 'number',
      scenarioId: 'number',
      spaceId: 'number',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList extends $tea.Model {
  dag?: ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag[];
  static names(): { [key: string]: string } {
    return {
      dag: 'Dag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dag: { 'type': 'array', 'itemType': ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario extends $tea.Model {
  creatorId?: string;
  description?: string;
  scenarioName?: string;
  static names(): { [key: string]: string } {
    return {
      creatorId: 'CreatorId',
      description: 'Description',
      scenarioName: 'ScenarioName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorId: 'string',
      description: 'string',
      scenarioName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG extends $tea.Model {
  dagList?: ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList;
  scenario?: ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario;
  static names(): { [key: string]: string } {
    return {
      dagList: 'DagList',
      scenario: 'Scenario',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagList: ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList,
      scenario: ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList extends $tea.Model {
  scenarioDAG?: ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG[];
  static names(): { [key: string]: string } {
    return {
      scenarioDAG: 'ScenarioDAG',
    };
  }

  static types(): { [key: string]: any } {
    return {
      scenarioDAG: { 'type': 'array', 'itemType': ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds extends $tea.Model {
  databaseIds?: number[];
  static names(): { [key: string]: string } {
    return {
      databaseIds: 'DatabaseIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseIds: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList extends $tea.Model {
  ownerIds?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerIds: 'OwnerIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList extends $tea.Model {
  ownerNames?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerNames: 'OwnerNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase extends $tea.Model {
  alias?: string;
  databaseId?: string;
  databaseIds?: ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds;
  dbType?: string;
  envType?: string;
  logic?: boolean;
  ownerIdList?: ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList;
  ownerNameList?: ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList;
  schemaName?: string;
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      databaseId: 'DatabaseId',
      databaseIds: 'DatabaseIds',
      dbType: 'DbType',
      envType: 'EnvType',
      logic: 'Logic',
      ownerIdList: 'OwnerIdList',
      ownerNameList: 'OwnerNameList',
      schemaName: 'SchemaName',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      databaseId: 'string',
      databaseIds: ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds,
      dbType: 'string',
      envType: 'string',
      logic: 'boolean',
      ownerIdList: ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList,
      ownerNameList: ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList,
      schemaName: 'string',
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicDatabasesResponseBodyLogicDatabaseList extends $tea.Model {
  logicDatabase?: ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase[];
  static names(): { [key: string]: string } {
    return {
      logicDatabase: 'LogicDatabase',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logicDatabase: { 'type': 'array', 'itemType': ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig extends $tea.Model {
  routeExpr?: string;
  routeKey?: string;
  tableId?: number;
  static names(): { [key: string]: string } {
    return {
      routeExpr: 'RouteExpr',
      routeKey: 'RouteKey',
      tableId: 'TableId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      routeExpr: 'string',
      routeKey: 'string',
      tableId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList extends $tea.Model {
  logicTableRouteConfig?: ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig[];
  static names(): { [key: string]: string } {
    return {
      logicTableRouteConfig: 'LogicTableRouteConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logicTableRouteConfig: { 'type': 'array', 'itemType': ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList extends $tea.Model {
  ownerIds?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerIds: 'OwnerIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList extends $tea.Model {
  ownerNames?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerNames: 'OwnerNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicTablesResponseBodyLogicTableListLogicTable extends $tea.Model {
  databaseId?: string;
  logic?: boolean;
  ownerIdList?: ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList;
  ownerNameList?: ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList;
  schemaName?: string;
  tableCount?: string;
  tableExpr?: string;
  tableGuid?: string;
  tableId?: string;
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      databaseId: 'DatabaseId',
      logic: 'Logic',
      ownerIdList: 'OwnerIdList',
      ownerNameList: 'OwnerNameList',
      schemaName: 'SchemaName',
      tableCount: 'TableCount',
      tableExpr: 'TableExpr',
      tableGuid: 'TableGuid',
      tableId: 'TableId',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseId: 'string',
      logic: 'boolean',
      ownerIdList: ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList,
      ownerNameList: ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList,
      schemaName: 'string',
      tableCount: 'string',
      tableExpr: 'string',
      tableGuid: 'string',
      tableId: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicTablesResponseBodyLogicTableList extends $tea.Model {
  logicTable?: ListLogicTablesResponseBodyLogicTableListLogicTable[];
  static names(): { [key: string]: string } {
    return {
      logicTable: 'LogicTable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logicTable: { 'type': 'array', 'itemType': ListLogicTablesResponseBodyLogicTableListLogicTable },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrdersResponseBodyOrdersOrder extends $tea.Model {
  comment?: string;
  committer?: string;
  committerId?: number;
  createTime?: string;
  lastModifyTime?: string;
  orderId?: number;
  pluginType?: string;
  statusCode?: string;
  statusDesc?: string;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      committer: 'Committer',
      committerId: 'CommitterId',
      createTime: 'CreateTime',
      lastModifyTime: 'LastModifyTime',
      orderId: 'OrderId',
      pluginType: 'PluginType',
      statusCode: 'StatusCode',
      statusDesc: 'StatusDesc',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      committer: 'string',
      committerId: 'number',
      createTime: 'string',
      lastModifyTime: 'string',
      orderId: 'number',
      pluginType: 'string',
      statusCode: 'string',
      statusDesc: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrdersResponseBodyOrders extends $tea.Model {
  order?: ListOrdersResponseBodyOrdersOrder[];
  static names(): { [key: string]: string } {
    return {
      order: 'Order',
    };
  }

  static types(): { [key: string]: any } {
    return {
      order: { 'type': 'array', 'itemType': ListOrdersResponseBodyOrdersOrder },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProxiesResponseBodyProxyList extends $tea.Model {
  creatorId?: number;
  creatorName?: string;
  httpsPort?: number;
  instanceId?: number;
  privateEnable?: boolean;
  privateHost?: string;
  protocolPort?: number;
  protocolType?: string;
  proxyId?: number;
  publicEnable?: boolean;
  publicHost?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      creatorId: 'CreatorId',
      creatorName: 'CreatorName',
      httpsPort: 'HttpsPort',
      instanceId: 'InstanceId',
      privateEnable: 'PrivateEnable',
      privateHost: 'PrivateHost',
      protocolPort: 'ProtocolPort',
      protocolType: 'ProtocolType',
      proxyId: 'ProxyId',
      publicEnable: 'PublicEnable',
      publicHost: 'PublicHost',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorId: 'number',
      creatorName: 'string',
      httpsPort: 'number',
      instanceId: 'number',
      privateEnable: 'boolean',
      privateHost: 'string',
      protocolPort: 'number',
      protocolType: 'string',
      proxyId: 'number',
      publicEnable: 'boolean',
      publicHost: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProxyAccessesResponseBodyProxyAccessList extends $tea.Model {
  accessId?: string;
  gmtCreate?: string;
  indepAccount?: string;
  instanceId?: number;
  originInfo?: string;
  proxyAccessId?: number;
  proxyId?: number;
  userId?: number;
  userName?: string;
  userUid?: string;
  static names(): { [key: string]: string } {
    return {
      accessId: 'AccessId',
      gmtCreate: 'GmtCreate',
      indepAccount: 'IndepAccount',
      instanceId: 'InstanceId',
      originInfo: 'OriginInfo',
      proxyAccessId: 'ProxyAccessId',
      proxyId: 'ProxyId',
      userId: 'UserId',
      userName: 'UserName',
      userUid: 'UserUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessId: 'string',
      gmtCreate: 'string',
      indepAccount: 'string',
      instanceId: 'number',
      originInfo: 'string',
      proxyAccessId: 'number',
      proxyId: 'number',
      userId: 'number',
      userName: 'string',
      userUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog extends $tea.Model {
  affectRows?: number;
  elapsedTime?: number;
  execState?: string;
  instanceId?: number;
  instanceName?: string;
  opTime?: string;
  remark?: string;
  SQL?: string;
  SQLType?: string;
  schemaName?: string;
  userId?: number;
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      affectRows: 'AffectRows',
      elapsedTime: 'ElapsedTime',
      execState: 'ExecState',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      opTime: 'OpTime',
      remark: 'Remark',
      SQL: 'SQL',
      SQLType: 'SQLType',
      schemaName: 'SchemaName',
      userId: 'UserId',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affectRows: 'number',
      elapsedTime: 'number',
      execState: 'string',
      instanceId: 'number',
      instanceName: 'string',
      opTime: 'string',
      remark: 'string',
      SQL: 'string',
      SQLType: 'string',
      schemaName: 'string',
      userId: 'number',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList extends $tea.Model {
  proxySQLExecAuditLog?: ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog[];
  static names(): { [key: string]: string } {
    return {
      proxySQLExecAuditLog: 'ProxySQLExecAuditLog',
    };
  }

  static types(): { [key: string]: any } {
    return {
      proxySQLExecAuditLog: { 'type': 'array', 'itemType': ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSLARulesResponseBodySLARuleListSLARule extends $tea.Model {
  dagId?: number;
  id?: number;
  intervalMinutes?: number;
  nodeId?: number;
  ruleType?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      id: 'Id',
      intervalMinutes: 'IntervalMinutes',
      nodeId: 'NodeId',
      ruleType: 'RuleType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      id: 'number',
      intervalMinutes: 'number',
      nodeId: 'number',
      ruleType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSLARulesResponseBodySLARuleList extends $tea.Model {
  SLARule?: ListSLARulesResponseBodySLARuleListSLARule[];
  static names(): { [key: string]: string } {
    return {
      SLARule: 'SLARule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      SLARule: { 'type': 'array', 'itemType': ListSLARulesResponseBodySLARuleListSLARule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog extends $tea.Model {
  affectRows?: number;
  dbId?: number;
  elapsedTime?: number;
  execState?: string;
  instanceId?: number;
  instanceName?: string;
  logic?: boolean;
  opTime?: string;
  remark?: string;
  SQL?: string;
  SQLType?: string;
  schemaName?: string;
  userId?: number;
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      affectRows: 'AffectRows',
      dbId: 'DbId',
      elapsedTime: 'ElapsedTime',
      execState: 'ExecState',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      logic: 'Logic',
      opTime: 'OpTime',
      remark: 'Remark',
      SQL: 'SQL',
      SQLType: 'SQLType',
      schemaName: 'SchemaName',
      userId: 'UserId',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affectRows: 'number',
      dbId: 'number',
      elapsedTime: 'number',
      execState: 'string',
      instanceId: 'number',
      instanceName: 'string',
      logic: 'boolean',
      opTime: 'string',
      remark: 'string',
      SQL: 'string',
      SQLType: 'string',
      schemaName: 'string',
      userId: 'number',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSQLExecAuditLogResponseBodySQLExecAuditLogList extends $tea.Model {
  SQLExecAuditLog?: ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog[];
  static names(): { [key: string]: string } {
    return {
      SQLExecAuditLog: 'SQLExecAuditLog',
    };
  }

  static types(): { [key: string]: any } {
    return {
      SQLExecAuditLog: { 'type': 'array', 'itemType': ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSQLReviewOriginSQLRequestOrderActionDetailPage extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSQLReviewOriginSQLRequestOrderActionDetail extends $tea.Model {
  checkStatusResult?: string;
  fileId?: number;
  page?: ListSQLReviewOriginSQLRequestOrderActionDetailPage;
  SQLReviewResult?: string;
  static names(): { [key: string]: string } {
    return {
      checkStatusResult: 'CheckStatusResult',
      fileId: 'FileId',
      page: 'Page',
      SQLReviewResult: 'SQLReviewResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkStatusResult: 'string',
      fileId: 'number',
      page: ListSQLReviewOriginSQLRequestOrderActionDetailPage,
      SQLReviewResult: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSQLReviewOriginSQLResponseBodyOriginSQLList extends $tea.Model {
  checkStatus?: string;
  checkedTime?: string;
  fileId?: number;
  fileName?: string;
  reviewSummary?: string;
  SQLContent?: string;
  SQLId?: number;
  SQLName?: string;
  SQLReviewQueryKey?: string;
  sqlHash?: string;
  statusDesc?: string;
  static names(): { [key: string]: string } {
    return {
      checkStatus: 'CheckStatus',
      checkedTime: 'CheckedTime',
      fileId: 'FileId',
      fileName: 'FileName',
      reviewSummary: 'ReviewSummary',
      SQLContent: 'SQLContent',
      SQLId: 'SQLId',
      SQLName: 'SQLName',
      SQLReviewQueryKey: 'SQLReviewQueryKey',
      sqlHash: 'SqlHash',
      statusDesc: 'StatusDesc',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkStatus: 'string',
      checkedTime: 'string',
      fileId: 'number',
      fileName: 'string',
      reviewSummary: 'string',
      SQLContent: 'string',
      SQLId: 'number',
      SQLName: 'string',
      SQLReviewQueryKey: 'string',
      sqlHash: 'string',
      statusDesc: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScenariosResponseBodyScenarioList extends $tea.Model {
  creatorId?: string;
  description?: string;
  id?: number;
  scenarioName?: string;
  static names(): { [key: string]: string } {
    return {
      creatorId: 'CreatorId',
      description: 'Description',
      id: 'Id',
      scenarioName: 'ScenarioName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorId: 'string',
      description: 'string',
      id: 'number',
      scenarioName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnDefaultDesensitizationRule extends $tea.Model {
  ruleId?: number;
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      ruleId: 'RuleId',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleId: 'number',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleListSemiDesensitizationRule extends $tea.Model {
  ruleId?: number;
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      ruleId: 'RuleId',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleId: 'number',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleList extends $tea.Model {
  semiDesensitizationRule?: ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleListSemiDesensitizationRule[];
  static names(): { [key: string]: string } {
    return {
      semiDesensitizationRule: 'SemiDesensitizationRule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      semiDesensitizationRule: { 'type': 'array', 'itemType': ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleListSemiDesensitizationRule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumn extends $tea.Model {
  categoryName?: string;
  columnName?: string;
  defaultDesensitizationRule?: ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnDefaultDesensitizationRule;
  instanceId?: number;
  isPlain?: boolean;
  sampleData?: string;
  schemaName?: string;
  securityLevel?: string;
  semiDesensitizationRuleList?: ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleList;
  tableName?: string;
  userSensitivityLevel?: string;
  static names(): { [key: string]: string } {
    return {
      categoryName: 'CategoryName',
      columnName: 'ColumnName',
      defaultDesensitizationRule: 'DefaultDesensitizationRule',
      instanceId: 'InstanceId',
      isPlain: 'IsPlain',
      sampleData: 'SampleData',
      schemaName: 'SchemaName',
      securityLevel: 'SecurityLevel',
      semiDesensitizationRuleList: 'SemiDesensitizationRuleList',
      tableName: 'TableName',
      userSensitivityLevel: 'UserSensitivityLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryName: 'string',
      columnName: 'string',
      defaultDesensitizationRule: ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnDefaultDesensitizationRule,
      instanceId: 'number',
      isPlain: 'boolean',
      sampleData: 'string',
      schemaName: 'string',
      securityLevel: 'string',
      semiDesensitizationRuleList: ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleList,
      tableName: 'string',
      userSensitivityLevel: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnInfoResponseBodySensitiveColumnList extends $tea.Model {
  sensitiveColumn?: ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumn[];
  static names(): { [key: string]: string } {
    return {
      sensitiveColumn: 'SensitiveColumn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sensitiveColumn: { 'type': 'array', 'itemType': ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumn },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn extends $tea.Model {
  columnCount?: number;
  columnName?: string;
  functionType?: string;
  schemaName?: string;
  securityLevel?: string;
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      columnCount: 'ColumnCount',
      columnName: 'ColumnName',
      functionType: 'FunctionType',
      schemaName: 'SchemaName',
      securityLevel: 'SecurityLevel',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnCount: 'number',
      columnName: 'string',
      functionType: 'string',
      schemaName: 'string',
      securityLevel: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnsResponseBodySensitiveColumnList extends $tea.Model {
  sensitiveColumn?: ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn[];
  static names(): { [key: string]: string } {
    return {
      sensitiveColumn: 'SensitiveColumn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sensitiveColumn: { 'type': 'array', 'itemType': ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail extends $tea.Model {
  columnDescription?: string;
  columnName?: string;
  columnType?: string;
  dbId?: number;
  dbType?: string;
  envType?: string;
  logic?: boolean;
  schemaName?: string;
  searchName?: string;
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      columnDescription: 'ColumnDescription',
      columnName: 'ColumnName',
      columnType: 'ColumnType',
      dbId: 'DbId',
      dbType: 'DbType',
      envType: 'EnvType',
      logic: 'Logic',
      schemaName: 'SchemaName',
      searchName: 'SearchName',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnDescription: 'string',
      columnName: 'string',
      columnType: 'string',
      dbId: 'number',
      dbType: 'string',
      envType: 'string',
      logic: 'boolean',
      schemaName: 'string',
      searchName: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList extends $tea.Model {
  sensitiveColumnsDetail?: ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail[];
  static names(): { [key: string]: string } {
    return {
      sensitiveColumnsDetail: 'SensitiveColumnsDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sensitiveColumnsDetail: { 'type': 'array', 'itemType': ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog extends $tea.Model {
  columnName?: string;
  columnPermissionType?: string;
  desensitizationRule?: string;
  securityLevel?: string;
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      columnPermissionType: 'ColumnPermissionType',
      desensitizationRule: 'DesensitizationRule',
      securityLevel: 'SecurityLevel',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      columnPermissionType: 'string',
      desensitizationRule: 'string',
      securityLevel: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList extends $tea.Model {
  dbDisplayName?: string;
  instanceId?: number;
  moduleName?: string;
  opTime?: string;
  sensitiveDataLog?: ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog[];
  targetName?: string;
  userId?: number;
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      dbDisplayName: 'DbDisplayName',
      instanceId: 'InstanceId',
      moduleName: 'ModuleName',
      opTime: 'OpTime',
      sensitiveDataLog: 'SensitiveDataLog',
      targetName: 'TargetName',
      userId: 'UserId',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbDisplayName: 'string',
      instanceId: 'number',
      moduleName: 'string',
      opTime: 'string',
      sensitiveDataLog: { 'type': 'array', 'itemType': ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog },
      targetName: 'string',
      userId: 'number',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitivityLevelResponseBodySensitivityLevelList extends $tea.Model {
  isPlain?: boolean;
  name?: string;
  templateId?: string;
  templateType?: string;
  static names(): { [key: string]: string } {
    return {
      isPlain: 'IsPlain',
      name: 'Name',
      templateId: 'TemplateId',
      templateType: 'TemplateType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isPlain: 'boolean',
      name: 'string',
      templateId: 'string',
      templateType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListStandardGroupsResponseBodyStandardGroupList extends $tea.Model {
  dbType?: string;
  description?: string;
  groupId?: number;
  groupMode?: string;
  groupName?: string;
  lastMenderId?: number;
  static names(): { [key: string]: string } {
    return {
      dbType: 'DbType',
      description: 'Description',
      groupId: 'GroupId',
      groupMode: 'GroupMode',
      groupName: 'GroupName',
      lastMenderId: 'LastMenderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbType: 'string',
      description: 'string',
      groupId: 'number',
      groupMode: 'string',
      groupName: 'string',
      lastMenderId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTablesResponseBodyTableListTableOwnerIdList extends $tea.Model {
  ownerIds?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerIds: 'OwnerIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTablesResponseBodyTableListTableOwnerNameList extends $tea.Model {
  ownerNames?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerNames: 'OwnerNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTablesResponseBodyTableListTable extends $tea.Model {
  databaseId?: string;
  description?: string;
  encoding?: string;
  engine?: string;
  numRows?: number;
  ownerIdList?: ListTablesResponseBodyTableListTableOwnerIdList;
  ownerNameList?: ListTablesResponseBodyTableListTableOwnerNameList;
  storeCapacity?: number;
  tableGuid?: string;
  tableId?: string;
  tableName?: string;
  tableSchemaName?: string;
  tableType?: string;
  static names(): { [key: string]: string } {
    return {
      databaseId: 'DatabaseId',
      description: 'Description',
      encoding: 'Encoding',
      engine: 'Engine',
      numRows: 'NumRows',
      ownerIdList: 'OwnerIdList',
      ownerNameList: 'OwnerNameList',
      storeCapacity: 'StoreCapacity',
      tableGuid: 'TableGuid',
      tableId: 'TableId',
      tableName: 'TableName',
      tableSchemaName: 'TableSchemaName',
      tableType: 'TableType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseId: 'string',
      description: 'string',
      encoding: 'string',
      engine: 'string',
      numRows: 'number',
      ownerIdList: ListTablesResponseBodyTableListTableOwnerIdList,
      ownerNameList: ListTablesResponseBodyTableListTableOwnerNameList,
      storeCapacity: 'number',
      tableGuid: 'string',
      tableId: 'string',
      tableName: 'string',
      tableSchemaName: 'string',
      tableType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTablesResponseBodyTableList extends $tea.Model {
  table?: ListTablesResponseBodyTableListTable[];
  static names(): { [key: string]: string } {
    return {
      table: 'Table',
    };
  }

  static types(): { [key: string]: any } {
    return {
      table: { 'type': 'array', 'itemType': ListTablesResponseBodyTableListTable },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowResponseBodyTaskFlowListTaskFlow extends $tea.Model {
  creatorId?: string;
  creatorNickName?: string;
  dagOwnerNickName?: string;
  deployId?: number;
  id?: number;
  latestInstanceStatus?: number;
  latestInstanceTime?: string;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      creatorId: 'CreatorId',
      creatorNickName: 'CreatorNickName',
      dagOwnerNickName: 'DagOwnerNickName',
      deployId: 'DeployId',
      id: 'Id',
      latestInstanceStatus: 'LatestInstanceStatus',
      latestInstanceTime: 'LatestInstanceTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorId: 'string',
      creatorNickName: 'string',
      dagOwnerNickName: 'string',
      deployId: 'number',
      id: 'number',
      latestInstanceStatus: 'number',
      latestInstanceTime: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowResponseBodyTaskFlowList extends $tea.Model {
  taskFlow?: ListTaskFlowResponseBodyTaskFlowListTaskFlow[];
  static names(): { [key: string]: string } {
    return {
      taskFlow: 'TaskFlow',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskFlow: { 'type': 'array', 'itemType': ListTaskFlowResponseBodyTaskFlowListTaskFlow },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowConstantsResponseBodyDagConstantsDagConstant extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowConstantsResponseBodyDagConstants extends $tea.Model {
  dagConstant?: ListTaskFlowConstantsResponseBodyDagConstantsDagConstant[];
  static names(): { [key: string]: string } {
    return {
      dagConstant: 'DagConstant',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagConstant: { 'type': 'array', 'itemType': ListTaskFlowConstantsResponseBodyDagConstantsDagConstant },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator extends $tea.Model {
  email?: string;
  loginName?: string;
  nickName?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      email: 'Email',
      loginName: 'LoginName',
      nickName: 'NickName',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      email: 'string',
      loginName: 'string',
      nickName: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowCooperatorsResponseBodyCooperatorList extends $tea.Model {
  cooperator?: ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator[];
  static names(): { [key: string]: string } {
    return {
      cooperator: 'Cooperator',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cooperator: { 'type': 'array', 'itemType': ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowEdgesByConditionResponseBodyEdgesEdge extends $tea.Model {
  id?: number;
  nodeEnd?: number;
  nodeFrom?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      nodeEnd: 'NodeEnd',
      nodeFrom: 'NodeFrom',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      nodeEnd: 'number',
      nodeFrom: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowEdgesByConditionResponseBodyEdges extends $tea.Model {
  edge?: ListTaskFlowEdgesByConditionResponseBodyEdgesEdge[];
  static names(): { [key: string]: string } {
    return {
      edge: 'Edge',
    };
  }

  static types(): { [key: string]: any } {
    return {
      edge: { 'type': 'array', 'itemType': ListTaskFlowEdgesByConditionResponseBodyEdgesEdge },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance extends $tea.Model {
  businessTime?: string;
  dagId?: string;
  dagName?: string;
  dagVersion?: string;
  endTime?: string;
  historyDagId?: number;
  id?: number;
  message?: string;
  ownerName?: string;
  status?: number;
  triggerType?: number;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      businessTime: 'BusinessTime',
      dagId: 'DagId',
      dagName: 'DagName',
      dagVersion: 'DagVersion',
      endTime: 'EndTime',
      historyDagId: 'HistoryDagId',
      id: 'Id',
      message: 'Message',
      ownerName: 'OwnerName',
      status: 'Status',
      triggerType: 'TriggerType',
      startTime: 'startTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessTime: 'string',
      dagId: 'string',
      dagName: 'string',
      dagVersion: 'string',
      endTime: 'string',
      historyDagId: 'number',
      id: 'number',
      message: 'string',
      ownerName: 'string',
      status: 'number',
      triggerType: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowInstanceResponseBodyDAGInstanceList extends $tea.Model {
  DAGInstance?: ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance[];
  static names(): { [key: string]: string } {
    return {
      DAGInstance: 'DAGInstance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DAGInstance: { 'type': 'array', 'itemType': ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable extends $tea.Model {
  name?: string;
  pattern?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      pattern: 'Pattern',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      pattern: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowTimeVariablesResponseBodyTimeVariables extends $tea.Model {
  timeVariable?: ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable[];
  static names(): { [key: string]: string } {
    return {
      timeVariable: 'TimeVariable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeVariable: { 'type': 'array', 'itemType': ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow extends $tea.Model {
  creatorId?: string;
  creatorNickName?: string;
  cronBeginDate?: string;
  cronEndDate?: string;
  cronStr?: string;
  cronSwitch?: boolean;
  cronType?: number;
  dagName?: string;
  dagOwnerId?: string;
  dagOwnerNickName?: string;
  deployId?: number;
  description?: string;
  id?: number;
  latestInstanceStatus?: number;
  latestInstanceTime?: string;
  scenarioId?: string;
  scheduleParam?: string;
  status?: number;
  timeZoneId?: string;
  triggerType?: number;
  static names(): { [key: string]: string } {
    return {
      creatorId: 'CreatorId',
      creatorNickName: 'CreatorNickName',
      cronBeginDate: 'CronBeginDate',
      cronEndDate: 'CronEndDate',
      cronStr: 'CronStr',
      cronSwitch: 'CronSwitch',
      cronType: 'CronType',
      dagName: 'DagName',
      dagOwnerId: 'DagOwnerId',
      dagOwnerNickName: 'DagOwnerNickName',
      deployId: 'DeployId',
      description: 'Description',
      id: 'Id',
      latestInstanceStatus: 'LatestInstanceStatus',
      latestInstanceTime: 'LatestInstanceTime',
      scenarioId: 'ScenarioId',
      scheduleParam: 'ScheduleParam',
      status: 'Status',
      timeZoneId: 'TimeZoneId',
      triggerType: 'TriggerType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorId: 'string',
      creatorNickName: 'string',
      cronBeginDate: 'string',
      cronEndDate: 'string',
      cronStr: 'string',
      cronSwitch: 'boolean',
      cronType: 'number',
      dagName: 'string',
      dagOwnerId: 'string',
      dagOwnerNickName: 'string',
      deployId: 'number',
      description: 'string',
      id: 'number',
      latestInstanceStatus: 'number',
      latestInstanceTime: 'string',
      scenarioId: 'string',
      scheduleParam: 'string',
      status: 'number',
      timeZoneId: 'string',
      triggerType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowsByPageResponseBodyTaskFlowList extends $tea.Model {
  taskFlow?: ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow[];
  static names(): { [key: string]: string } {
    return {
      taskFlow: 'TaskFlow',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskFlow: { 'type': 'array', 'itemType': ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTasksInTaskFlowResponseBodyTasksTask extends $tea.Model {
  graphParam?: string;
  nodeConfig?: string;
  nodeContent?: string;
  nodeId?: string;
  nodeName?: string;
  nodeOutput?: string;
  nodeType?: string;
  timeVariables?: string;
  static names(): { [key: string]: string } {
    return {
      graphParam: 'GraphParam',
      nodeConfig: 'NodeConfig',
      nodeContent: 'NodeContent',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      nodeOutput: 'NodeOutput',
      nodeType: 'NodeType',
      timeVariables: 'TimeVariables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      graphParam: 'string',
      nodeConfig: 'string',
      nodeContent: 'string',
      nodeId: 'string',
      nodeName: 'string',
      nodeOutput: 'string',
      nodeType: 'string',
      timeVariables: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTasksInTaskFlowResponseBodyTasks extends $tea.Model {
  task?: ListTasksInTaskFlowResponseBodyTasksTask[];
  static names(): { [key: string]: string } {
    return {
      task: 'Task',
    };
  }

  static types(): { [key: string]: any } {
    return {
      task: { 'type': 'array', 'itemType': ListTasksInTaskFlowResponseBodyTasksTask },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail extends $tea.Model {
  createDate?: string;
  expireDate?: string;
  extraData?: string;
  originFrom?: string;
  permType?: string;
  userAccessId?: string;
  static names(): { [key: string]: string } {
    return {
      createDate: 'CreateDate',
      expireDate: 'ExpireDate',
      extraData: 'ExtraData',
      originFrom: 'OriginFrom',
      permType: 'PermType',
      userAccessId: 'UserAccessId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createDate: 'string',
      expireDate: 'string',
      extraData: 'string',
      originFrom: 'string',
      permType: 'string',
      userAccessId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails extends $tea.Model {
  permDetail?: ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail[];
  static names(): { [key: string]: string } {
    return {
      permDetail: 'PermDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      permDetail: { 'type': 'array', 'itemType': ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserPermissionsResponseBodyUserPermissionsUserPermission extends $tea.Model {
  alias?: string;
  columnName?: string;
  dbId?: string;
  dbType?: string;
  dsType?: string;
  envType?: string;
  host?: string;
  instanceId?: string;
  logic?: boolean;
  permDetails?: ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails;
  port?: number;
  schemaName?: string;
  searchName?: string;
  tableId?: string;
  tableName?: string;
  userId?: string;
  userNickName?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      columnName: 'ColumnName',
      dbId: 'DbId',
      dbType: 'DbType',
      dsType: 'DsType',
      envType: 'EnvType',
      host: 'Host',
      instanceId: 'InstanceId',
      logic: 'Logic',
      permDetails: 'PermDetails',
      port: 'Port',
      schemaName: 'SchemaName',
      searchName: 'SearchName',
      tableId: 'TableId',
      tableName: 'TableName',
      userId: 'UserId',
      userNickName: 'UserNickName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      columnName: 'string',
      dbId: 'string',
      dbType: 'string',
      dsType: 'string',
      envType: 'string',
      host: 'string',
      instanceId: 'string',
      logic: 'boolean',
      permDetails: ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails,
      port: 'number',
      schemaName: 'string',
      searchName: 'string',
      tableId: 'string',
      tableName: 'string',
      userId: 'string',
      userNickName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserPermissionsResponseBodyUserPermissions extends $tea.Model {
  userPermission?: ListUserPermissionsResponseBodyUserPermissionsUserPermission[];
  static names(): { [key: string]: string } {
    return {
      userPermission: 'UserPermission',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userPermission: { 'type': 'array', 'itemType': ListUserPermissionsResponseBodyUserPermissionsUserPermission },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserTenantsResponseBodyTenantList extends $tea.Model {
  status?: string;
  tenantName?: string;
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      tenantName: 'TenantName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      tenantName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUsersResponseBodyUserListUserRoleIdList extends $tea.Model {
  roleIds?: number[];
  static names(): { [key: string]: string } {
    return {
      roleIds: 'RoleIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleIds: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUsersResponseBodyUserListUserRoleNameList extends $tea.Model {
  roleNames?: string[];
  static names(): { [key: string]: string } {
    return {
      roleNames: 'RoleNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUsersResponseBodyUserListUser extends $tea.Model {
  curExecuteCount?: number;
  curResultCount?: number;
  dingRobot?: string;
  email?: string;
  lastLoginTime?: string;
  maxExecuteCount?: number;
  maxResultCount?: number;
  mobile?: string;
  nickName?: string;
  notificationMode?: string;
  parentUid?: string;
  roleIdList?: ListUsersResponseBodyUserListUserRoleIdList;
  roleNameList?: ListUsersResponseBodyUserListUserRoleNameList;
  signatureMethod?: string;
  state?: string;
  uid?: string;
  userId?: string;
  webhook?: string;
  static names(): { [key: string]: string } {
    return {
      curExecuteCount: 'CurExecuteCount',
      curResultCount: 'CurResultCount',
      dingRobot: 'DingRobot',
      email: 'Email',
      lastLoginTime: 'LastLoginTime',
      maxExecuteCount: 'MaxExecuteCount',
      maxResultCount: 'MaxResultCount',
      mobile: 'Mobile',
      nickName: 'NickName',
      notificationMode: 'NotificationMode',
      parentUid: 'ParentUid',
      roleIdList: 'RoleIdList',
      roleNameList: 'RoleNameList',
      signatureMethod: 'SignatureMethod',
      state: 'State',
      uid: 'Uid',
      userId: 'UserId',
      webhook: 'Webhook',
    };
  }

  static types(): { [key: string]: any } {
    return {
      curExecuteCount: 'number',
      curResultCount: 'number',
      dingRobot: 'string',
      email: 'string',
      lastLoginTime: 'string',
      maxExecuteCount: 'number',
      maxResultCount: 'number',
      mobile: 'string',
      nickName: 'string',
      notificationMode: 'string',
      parentUid: 'string',
      roleIdList: ListUsersResponseBodyUserListUserRoleIdList,
      roleNameList: ListUsersResponseBodyUserListUserRoleNameList,
      signatureMethod: 'string',
      state: 'string',
      uid: 'string',
      userId: 'string',
      webhook: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUsersResponseBodyUserList extends $tea.Model {
  user?: ListUsersResponseBodyUserListUser[];
  static names(): { [key: string]: string } {
    return {
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      user: { 'type': 'array', 'itemType': ListUsersResponseBodyUserListUser },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser extends $tea.Model {
  nickName?: string;
  realName?: string;
  userId?: number;
  static names(): { [key: string]: string } {
    return {
      nickName: 'NickName',
      realName: 'RealName',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nickName: 'string',
      realName: 'string',
      userId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers extends $tea.Model {
  auditUser?: ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser[];
  static names(): { [key: string]: string } {
    return {
      auditUser: 'AuditUser',
    };
  }

  static types(): { [key: string]: any } {
    return {
      auditUser: { 'type': 'array', 'itemType': ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode extends $tea.Model {
  auditUsers?: ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers;
  comment?: string;
  createUserId?: number;
  createUserNickName?: string;
  nodeId?: number;
  nodeName?: string;
  nodeType?: string;
  static names(): { [key: string]: string } {
    return {
      auditUsers: 'AuditUsers',
      comment: 'Comment',
      createUserId: 'CreateUserId',
      createUserNickName: 'CreateUserNickName',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      nodeType: 'NodeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      auditUsers: ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers,
      comment: 'string',
      createUserId: 'number',
      createUserNickName: 'string',
      nodeId: 'number',
      nodeName: 'string',
      nodeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowNodesResponseBodyWorkflowNodes extends $tea.Model {
  workflowNode?: ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode[];
  static names(): { [key: string]: string } {
    return {
      workflowNode: 'WorkflowNode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      workflowNode: { 'type': 'array', 'itemType': ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode extends $tea.Model {
  comment?: string;
  createUserId?: number;
  nodeId?: number;
  nodeName?: string;
  nodeType?: string;
  position?: number;
  templateId?: number;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      createUserId: 'CreateUserId',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      nodeType: 'NodeType',
      position: 'Position',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      createUserId: 'number',
      nodeId: 'number',
      nodeName: 'string',
      nodeType: 'string',
      position: 'number',
      templateId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes extends $tea.Model {
  workflowNode?: ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode[];
  static names(): { [key: string]: string } {
    return {
      workflowNode: 'WorkflowNode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      workflowNode: { 'type': 'array', 'itemType': ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate extends $tea.Model {
  comment?: string;
  createUserId?: number;
  enabled?: string;
  isSystem?: number;
  templateId?: number;
  templateName?: string;
  workflowNodes?: ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      createUserId: 'CreateUserId',
      enabled: 'Enabled',
      isSystem: 'IsSystem',
      templateId: 'TemplateId',
      templateName: 'TemplateName',
      workflowNodes: 'WorkflowNodes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      createUserId: 'number',
      enabled: 'string',
      isSystem: 'number',
      templateId: 'number',
      templateName: 'string',
      workflowNodes: ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowTemplatesResponseBodyWorkFlowTemplates extends $tea.Model {
  workFlowTemplate?: ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate[];
  static names(): { [key: string]: string } {
    return {
      workFlowTemplate: 'WorkFlowTemplate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      workFlowTemplate: { 'type': 'array', 'itemType': ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser extends $tea.Model {
  nickName?: string;
  realName?: string;
  userId?: number;
  static names(): { [key: string]: string } {
    return {
      nickName: 'NickName',
      realName: 'RealName',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nickName: 'string',
      realName: 'string',
      userId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserList extends $tea.Model {
  auditUser?: PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser[];
  static names(): { [key: string]: string } {
    return {
      auditUser: 'AuditUser',
    };
  }

  static types(): { [key: string]: any } {
    return {
      auditUser: { 'type': 'array', 'itemType': PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode extends $tea.Model {
  auditUserList?: PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserList;
  comment?: string;
  nodeName?: string;
  nodeType?: string;
  static names(): { [key: string]: string } {
    return {
      auditUserList: 'AuditUserList',
      comment: 'Comment',
      nodeName: 'NodeName',
      nodeType: 'NodeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      auditUserList: PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserList,
      comment: 'string',
      nodeName: 'string',
      nodeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeList extends $tea.Model {
  workflowNode?: PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode[];
  static names(): { [key: string]: string } {
    return {
      workflowNode: 'WorkflowNode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      workflowNode: { 'type': 'array', 'itemType': PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreviewWorkflowResponseBodyWorkflowDetail extends $tea.Model {
  comment?: string;
  wfCateName?: string;
  workflowNodeList?: PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeList;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      wfCateName: 'WfCateName',
      workflowNodeList: 'WorkflowNodeList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      wfCateName: 'string',
      workflowNodeList: PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDataTrackResultDownloadStatusResponseBodyStatusResult extends $tea.Model {
  downloadStatus?: string;
  downloadUrl?: string;
  statusDesc?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      downloadStatus: 'DownloadStatus',
      downloadUrl: 'DownloadUrl',
      statusDesc: 'StatusDesc',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadStatus: 'string',
      downloadUrl: 'string',
      statusDesc: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDataTrackResultRequestColumnFilter extends $tea.Model {
  betweenEnd?: string;
  betweenStart?: string;
  columnName?: string;
  inList?: string[];
  operator?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      betweenEnd: 'BetweenEnd',
      betweenStart: 'BetweenStart',
      columnName: 'ColumnName',
      inList: 'InList',
      operator: 'Operator',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      betweenEnd: 'string',
      betweenStart: 'string',
      columnName: 'string',
      inList: { 'type': 'array', 'itemType': 'string' },
      operator: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDataTrackResultResponseBodyTrackResultEventList extends $tea.Model {
  dataAfter?: string[];
  dataBefore?: string[];
  eventId?: number;
  eventLength?: number;
  eventTimestamp?: string;
  eventType?: string;
  rollSQL?: string;
  static names(): { [key: string]: string } {
    return {
      dataAfter: 'DataAfter',
      dataBefore: 'DataBefore',
      eventId: 'EventId',
      eventLength: 'EventLength',
      eventTimestamp: 'EventTimestamp',
      eventType: 'EventType',
      rollSQL: 'RollSQL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataAfter: { 'type': 'array', 'itemType': 'string' },
      dataBefore: { 'type': 'array', 'itemType': 'string' },
      eventId: 'number',
      eventLength: 'number',
      eventTimestamp: 'string',
      eventType: 'string',
      rollSQL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns extends $tea.Model {
  columnName?: string;
  columnPosition?: number;
  columnType?: string;
  fictive?: boolean;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      columnPosition: 'ColumnPosition',
      columnType: 'ColumnType',
      fictive: 'Fictive',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      columnPosition: 'number',
      columnType: 'string',
      fictive: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDataTrackResultResponseBodyTrackResultTableInfoList extends $tea.Model {
  columns?: SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns[];
  description?: string;
  schemaName?: string;
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      columns: 'Columns',
      description: 'Description',
      schemaName: 'SchemaName',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columns: { 'type': 'array', 'itemType': SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns },
      description: 'string',
      schemaName: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDataTrackResultResponseBodyTrackResult extends $tea.Model {
  eventList?: SearchDataTrackResultResponseBodyTrackResultEventList[];
  tableInfoList?: SearchDataTrackResultResponseBodyTrackResultTableInfoList[];
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      eventList: 'EventList',
      tableInfoList: 'TableInfoList',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventList: { 'type': 'array', 'itemType': SearchDataTrackResultResponseBodyTrackResultEventList },
      tableInfoList: { 'type': 'array', 'itemType': SearchDataTrackResultResponseBodyTrackResultTableInfoList },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList extends $tea.Model {
  ownerIds?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerIds: 'OwnerIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList extends $tea.Model {
  ownerNames?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerNames: 'OwnerNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDatabaseResponseBodySearchDatabaseListSearchDatabase extends $tea.Model {
  alias?: string;
  catalogName?: string;
  databaseId?: string;
  datalinkName?: string;
  dbType?: string;
  dbaId?: string;
  encoding?: string;
  envType?: string;
  host?: string;
  logic?: boolean;
  ownerIdList?: SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList;
  ownerNameList?: SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList;
  port?: number;
  schemaName?: string;
  searchName?: string;
  sid?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      catalogName: 'CatalogName',
      databaseId: 'DatabaseId',
      datalinkName: 'DatalinkName',
      dbType: 'DbType',
      dbaId: 'DbaId',
      encoding: 'Encoding',
      envType: 'EnvType',
      host: 'Host',
      logic: 'Logic',
      ownerIdList: 'OwnerIdList',
      ownerNameList: 'OwnerNameList',
      port: 'Port',
      schemaName: 'SchemaName',
      searchName: 'SearchName',
      sid: 'Sid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      catalogName: 'string',
      databaseId: 'string',
      datalinkName: 'string',
      dbType: 'string',
      dbaId: 'string',
      encoding: 'string',
      envType: 'string',
      host: 'string',
      logic: 'boolean',
      ownerIdList: SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList,
      ownerNameList: SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList,
      port: 'number',
      schemaName: 'string',
      searchName: 'string',
      sid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDatabaseResponseBodySearchDatabaseList extends $tea.Model {
  searchDatabase?: SearchDatabaseResponseBodySearchDatabaseListSearchDatabase[];
  static names(): { [key: string]: string } {
    return {
      searchDatabase: 'SearchDatabase',
    };
  }

  static types(): { [key: string]: any } {
    return {
      searchDatabase: { 'type': 'array', 'itemType': SearchDatabaseResponseBodySearchDatabaseListSearchDatabase },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTableResponseBodySearchTableListSearchTableOwnerIdList extends $tea.Model {
  ownerIds?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerIds: 'OwnerIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTableResponseBodySearchTableListSearchTableOwnerNameList extends $tea.Model {
  ownerNames?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerNames: 'OwnerNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTableResponseBodySearchTableListSearchTable extends $tea.Model {
  DBSearchName?: string;
  databaseId?: string;
  dbName?: string;
  dbType?: string;
  description?: string;
  encoding?: string;
  engine?: string;
  envType?: string;
  logic?: boolean;
  ownerIdList?: SearchTableResponseBodySearchTableListSearchTableOwnerIdList;
  ownerNameList?: SearchTableResponseBodySearchTableListSearchTableOwnerNameList;
  tableGuid?: string;
  tableId?: string;
  tableName?: string;
  tableSchemaName?: string;
  static names(): { [key: string]: string } {
    return {
      DBSearchName: 'DBSearchName',
      databaseId: 'DatabaseId',
      dbName: 'DbName',
      dbType: 'DbType',
      description: 'Description',
      encoding: 'Encoding',
      engine: 'Engine',
      envType: 'EnvType',
      logic: 'Logic',
      ownerIdList: 'OwnerIdList',
      ownerNameList: 'OwnerNameList',
      tableGuid: 'TableGuid',
      tableId: 'TableId',
      tableName: 'TableName',
      tableSchemaName: 'TableSchemaName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DBSearchName: 'string',
      databaseId: 'string',
      dbName: 'string',
      dbType: 'string',
      description: 'string',
      encoding: 'string',
      engine: 'string',
      envType: 'string',
      logic: 'boolean',
      ownerIdList: SearchTableResponseBodySearchTableListSearchTableOwnerIdList,
      ownerNameList: SearchTableResponseBodySearchTableListSearchTableOwnerNameList,
      tableGuid: 'string',
      tableId: 'string',
      tableName: 'string',
      tableSchemaName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTableResponseBodySearchTableList extends $tea.Model {
  searchTable?: SearchTableResponseBodySearchTableListSearchTable[];
  static names(): { [key: string]: string } {
    return {
      searchTable: 'SearchTable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      searchTable: { 'type': 'array', 'itemType': SearchTableResponseBodySearchTableListSearchTable },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAuthorityTemplateResponseBodyAuthorityTemplateView extends $tea.Model {
  creatorId?: number;
  description?: string;
  name?: string;
  templateId?: number;
  static names(): { [key: string]: string } {
    return {
      creatorId: 'CreatorId',
      description: 'Description',
      name: 'Name',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorId: 'number',
      description: 'string',
      name: 'string',
      templateId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSLARulesRequestSlaRuleList extends $tea.Model {
  dagId?: number;
  intervalMinutes?: number;
  nodeId?: number;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      intervalMinutes: 'IntervalMinutes',
      nodeId: 'NodeId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      intervalMinutes: 'number',
      nodeId: 'number',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateStandardGroupResponseBodyStandardGroup extends $tea.Model {
  dbType?: string;
  description?: string;
  groupId?: number;
  groupMode?: string;
  groupName?: string;
  lastMenderId?: number;
  static names(): { [key: string]: string } {
    return {
      dbType: 'DbType',
      description: 'Description',
      groupId: 'GroupId',
      groupMode: 'GroupMode',
      groupName: 'GroupName',
      lastMenderId: 'LastMenderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbType: 'string',
      description: 'string',
      groupId: 'number',
      groupMode: 'string',
      groupName: 'string',
      lastMenderId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowConstantsRequestDagConstants extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowEdgesRequestEdges extends $tea.Model {
  id?: number;
  nodeEnd?: number;
  nodeFrom?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      nodeEnd: 'NodeEnd',
      nodeFrom: 'NodeFrom',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      nodeEnd: 'number',
      nodeFrom: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowRelationsRequestEdges extends $tea.Model {
  id?: number;
  nodeEnd?: number;
  nodeFrom?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      nodeEnd: 'NodeEnd',
      nodeFrom: 'NodeFrom',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      nodeEnd: 'number',
      nodeFrom: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends OpenApi {

  constructor(config: $OpenApi.Config) {
    super(config);
    this._endpointRule = "central";
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("dms-enterprise", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!Util.empty(endpoint)) {
      return endpoint;
    }

    if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  /**
   * @summary Adds a masking rule.
   *
   * @param request AddDesensitizationRuleRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return AddDesensitizationRuleResponse
   */
  async addDesensitizationRuleWithOptions(request: AddDesensitizationRuleRequest, runtime: $Util.RuntimeOptions): Promise<AddDesensitizationRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.functionType)) {
      query["FunctionType"] = request.functionType;
    }

    if (!Util.isUnset(request.ruleDescription)) {
      query["RuleDescription"] = request.ruleDescription;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.ruleType)) {
      query["RuleType"] = request.ruleType;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let body : {[key: string ]: any} = { };
    let bodyFlat : {[key: string ]: any} = { };
    if (!Util.isUnset(request.functionParams)) {
      bodyFlat["FunctionParams"] = request.functionParams;
    }

    body = {
      ...body,
      ...OpenApiUtil.query(bodyFlat),
    };
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "AddDesensitizationRule",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddDesensitizationRuleResponse>(await this.callApi(params, req, runtime), new AddDesensitizationRuleResponse({}));
  }

  /**
   * @summary Adds a masking rule.
   *
   * @param request AddDesensitizationRuleRequest
   * @return AddDesensitizationRuleResponse
   */
  async addDesensitizationRule(request: AddDesensitizationRuleRequest): Promise<AddDesensitizationRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addDesensitizationRuleWithOptions(request, runtime);
  }

  /**
   * @summary 添加实例
   *
   * @param request AddInstanceRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return AddInstanceResponse
   */
  async addInstanceWithOptions(request: AddInstanceRequest, runtime: $Util.RuntimeOptions): Promise<AddInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dataLinkName)) {
      query["DataLinkName"] = request.dataLinkName;
    }

    if (!Util.isUnset(request.databasePassword)) {
      query["DatabasePassword"] = request.databasePassword;
    }

    if (!Util.isUnset(request.databaseUser)) {
      query["DatabaseUser"] = request.databaseUser;
    }

    if (!Util.isUnset(request.dbaId)) {
      query["DbaId"] = request.dbaId;
    }

    if (!Util.isUnset(request.ddlOnline)) {
      query["DdlOnline"] = request.ddlOnline;
    }

    if (!Util.isUnset(request.ecsInstanceId)) {
      query["EcsInstanceId"] = request.ecsInstanceId;
    }

    if (!Util.isUnset(request.ecsRegion)) {
      query["EcsRegion"] = request.ecsRegion;
    }

    if (!Util.isUnset(request.enableSellCommon)) {
      query["EnableSellCommon"] = request.enableSellCommon;
    }

    if (!Util.isUnset(request.enableSellSitd)) {
      query["EnableSellSitd"] = request.enableSellSitd;
    }

    if (!Util.isUnset(request.enableSellStable)) {
      query["EnableSellStable"] = request.enableSellStable;
    }

    if (!Util.isUnset(request.enableSellTrust)) {
      query["EnableSellTrust"] = request.enableSellTrust;
    }

    if (!Util.isUnset(request.envType)) {
      query["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.exportTimeout)) {
      query["ExportTimeout"] = request.exportTimeout;
    }

    if (!Util.isUnset(request.host)) {
      query["Host"] = request.host;
    }

    if (!Util.isUnset(request.instanceAlias)) {
      query["InstanceAlias"] = request.instanceAlias;
    }

    if (!Util.isUnset(request.instanceSource)) {
      query["InstanceSource"] = request.instanceSource;
    }

    if (!Util.isUnset(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!Util.isUnset(request.networkType)) {
      query["NetworkType"] = request.networkType;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.queryTimeout)) {
      query["QueryTimeout"] = request.queryTimeout;
    }

    if (!Util.isUnset(request.safeRule)) {
      query["SafeRule"] = request.safeRule;
    }

    if (!Util.isUnset(request.sid)) {
      query["Sid"] = request.sid;
    }

    if (!Util.isUnset(request.skipTest)) {
      query["SkipTest"] = request.skipTest;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.templateType)) {
      query["TemplateType"] = request.templateType;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.useDsql)) {
      query["UseDsql"] = request.useDsql;
    }

    if (!Util.isUnset(request.useSsl)) {
      query["UseSsl"] = request.useSsl;
    }

    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddInstance",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddInstanceResponse>(await this.callApi(params, req, runtime), new AddInstanceResponse({}));
  }

  /**
   * @summary 添加实例
   *
   * @param request AddInstanceRequest
   * @return AddInstanceResponse
   */
  async addInstance(request: AddInstanceRequest): Promise<AddInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addInstanceWithOptions(request, runtime);
  }

  /**
   * @summary Adds a workspace administrator, a workspace member, or a task flow developer in Data Management (DMS).
   *
   * @description You must call this operation as a DMS administrator, a database administrator (DBA), or a workspace administrator.
   * Usage notes:
   * *   Before you call this operation to add a user as a task flow developer, make sure that you have added the user as a workspace member.
   * *   You cannot call this operation to transfer the ownership of a task flow. To transfer the ownership of a task flow, call the [ChangLhDagOwner](https://help.aliyun.com/document_detail/424761.html) operation.
   * *   For more information about workspace roles and permissions, see [Manage permissions on a workspace](https://help.aliyun.com/document_detail/410893.html).
   *
   * @param tmpReq AddLhMembersRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return AddLhMembersResponse
   */
  async addLhMembersWithOptions(tmpReq: AddLhMembersRequest, runtime: $Util.RuntimeOptions): Promise<AddLhMembersResponse> {
    Util.validateModel(tmpReq);
    let request = new AddLhMembersShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.members)) {
      request.membersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.members, "Members", "json");
    }

    let query = { };
    if (!Util.isUnset(request.membersShrink)) {
      query["Members"] = request.membersShrink;
    }

    if (!Util.isUnset(request.objectId)) {
      query["ObjectId"] = request.objectId;
    }

    if (!Util.isUnset(request.objectType)) {
      query["ObjectType"] = request.objectType;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddLhMembers",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddLhMembersResponse>(await this.callApi(params, req, runtime), new AddLhMembersResponse({}));
  }

  /**
   * @summary Adds a workspace administrator, a workspace member, or a task flow developer in Data Management (DMS).
   *
   * @description You must call this operation as a DMS administrator, a database administrator (DBA), or a workspace administrator.
   * Usage notes:
   * *   Before you call this operation to add a user as a task flow developer, make sure that you have added the user as a workspace member.
   * *   You cannot call this operation to transfer the ownership of a task flow. To transfer the ownership of a task flow, call the [ChangLhDagOwner](https://help.aliyun.com/document_detail/424761.html) operation.
   * *   For more information about workspace roles and permissions, see [Manage permissions on a workspace](https://help.aliyun.com/document_detail/410893.html).
   *
   * @param request AddLhMembersRequest
   * @return AddLhMembersResponse
   */
  async addLhMembers(request: AddLhMembersRequest): Promise<AddLhMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addLhMembersWithOptions(request, runtime);
  }

  /**
   * @summary Adds a routing algorithm to a logical table.
   *
   * @param request AddLogicTableRouteConfigRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return AddLogicTableRouteConfigResponse
   */
  async addLogicTableRouteConfigWithOptions(request: AddLogicTableRouteConfigRequest, runtime: $Util.RuntimeOptions): Promise<AddLogicTableRouteConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.routeExpr)) {
      query["RouteExpr"] = request.routeExpr;
    }

    if (!Util.isUnset(request.routeKey)) {
      query["RouteKey"] = request.routeKey;
    }

    if (!Util.isUnset(request.tableId)) {
      query["TableId"] = request.tableId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddLogicTableRouteConfig",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddLogicTableRouteConfigResponse>(await this.callApi(params, req, runtime), new AddLogicTableRouteConfigResponse({}));
  }

  /**
   * @summary Adds a routing algorithm to a logical table.
   *
   * @param request AddLogicTableRouteConfigRequest
   * @return AddLogicTableRouteConfigResponse
   */
  async addLogicTableRouteConfig(request: AddLogicTableRouteConfigRequest): Promise<AddLogicTableRouteConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addLogicTableRouteConfigWithOptions(request, runtime);
  }

  /**
   * @summary Adds directed edges for an existing task node.
   *
   * @description When you add directed edges for a task node, take note of the following limits:
   * 1. The endpoints of the specified edge exist in the Directed Acyclic Graph (DAG) of the task flow specified by DagId.
   * 2. After a backward edge is added, the DAG does not contain loops.
   *
   * @param tmpReq AddTaskFlowEdgesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return AddTaskFlowEdgesResponse
   */
  async addTaskFlowEdgesWithOptions(tmpReq: AddTaskFlowEdgesRequest, runtime: $Util.RuntimeOptions): Promise<AddTaskFlowEdgesResponse> {
    Util.validateModel(tmpReq);
    let request = new AddTaskFlowEdgesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.edges)) {
      request.edgesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.edges, "Edges", "json");
    }

    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.edgesShrink)) {
      query["Edges"] = request.edgesShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddTaskFlowEdges",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddTaskFlowEdgesResponse>(await this.callApi(params, req, runtime), new AddTaskFlowEdgesResponse({}));
  }

  /**
   * @summary Adds directed edges for an existing task node.
   *
   * @description When you add directed edges for a task node, take note of the following limits:
   * 1. The endpoints of the specified edge exist in the Directed Acyclic Graph (DAG) of the task flow specified by DagId.
   * 2. After a backward edge is added, the DAG does not contain loops.
   *
   * @param request AddTaskFlowEdgesRequest
   * @return AddTaskFlowEdgesResponse
   */
  async addTaskFlowEdges(request: AddTaskFlowEdgesRequest): Promise<AddTaskFlowEdgesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addTaskFlowEdgesWithOptions(request, runtime);
  }

  /**
   * @summary Analyzes the lineage (dependencies and influence) between tables and between fields in SQL statements.
   *
   * @description The following conditions must be met before you call this API operation.
   * *   The database instance is of one of the following types: ApsaraDB RDS for MySQL, PolarDB for MySQL, AnalyticDB for MySQL, ApsaraDB RDS for PostgreSQL, PolarDB for PostgreSQL, AnalyticDB for PostgreSQL, Oracle, and openGauss.
   * *   A database instance is managed in Security Collaboration mode. For more information about control modes, see [Control modes](https://help.aliyun.com/document_detail/151629.html).
   *
   * @param request AnalyzeSQLLineageRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return AnalyzeSQLLineageResponse
   */
  async analyzeSQLLineageWithOptions(request: AnalyzeSQLLineageRequest, runtime: $Util.RuntimeOptions): Promise<AnalyzeSQLLineageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.sqlContent)) {
      query["SqlContent"] = request.sqlContent;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AnalyzeSQLLineage",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AnalyzeSQLLineageResponse>(await this.callApi(params, req, runtime), new AnalyzeSQLLineageResponse({}));
  }

  /**
   * @summary Analyzes the lineage (dependencies and influence) between tables and between fields in SQL statements.
   *
   * @description The following conditions must be met before you call this API operation.
   * *   The database instance is of one of the following types: ApsaraDB RDS for MySQL, PolarDB for MySQL, AnalyticDB for MySQL, ApsaraDB RDS for PostgreSQL, PolarDB for PostgreSQL, AnalyticDB for PostgreSQL, Oracle, and openGauss.
   * *   A database instance is managed in Security Collaboration mode. For more information about control modes, see [Control modes](https://help.aliyun.com/document_detail/151629.html).
   *
   * @param request AnalyzeSQLLineageRequest
   * @return AnalyzeSQLLineageResponse
   */
  async analyzeSQLLineage(request: AnalyzeSQLLineageRequest): Promise<AnalyzeSQLLineageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.analyzeSQLLineageWithOptions(request, runtime);
  }

  /**
   * @summary Reviews a ticket.
   *
   * @param request ApproveOrderRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ApproveOrderResponse
   */
  async approveOrderWithOptions(request: ApproveOrderRequest, runtime: $Util.RuntimeOptions): Promise<ApproveOrderResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.approvalNodeId)) {
      query["ApprovalNodeId"] = request.approvalNodeId;
    }

    if (!Util.isUnset(request.approvalNodePos)) {
      query["ApprovalNodePos"] = request.approvalNodePos;
    }

    if (!Util.isUnset(request.approvalType)) {
      query["ApprovalType"] = request.approvalType;
    }

    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.newApprover)) {
      query["NewApprover"] = request.newApprover;
    }

    if (!Util.isUnset(request.newApproverList)) {
      query["NewApproverList"] = request.newApproverList;
    }

    if (!Util.isUnset(request.oldApprover)) {
      query["OldApprover"] = request.oldApprover;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.workflowInstanceId)) {
      query["WorkflowInstanceId"] = request.workflowInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ApproveOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ApproveOrderResponse>(await this.callApi(params, req, runtime), new ApproveOrderResponse({}));
  }

  /**
   * @summary Reviews a ticket.
   *
   * @param request ApproveOrderRequest
   * @return ApproveOrderResponse
   */
  async approveOrder(request: ApproveOrderRequest): Promise<ApproveOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.approveOrderWithOptions(request, runtime);
  }

  /**
   * @summary Backfills data for task orchestration.
   *
   * @description During a data backfill, task flows are run in sequence based on their dates. You can specify whether task flows are run in chronological or reverse chronological order. After the data backfill is complete, you can specify a date or date range, and a node range to run task flows.
   *
   * @param tmpReq BackFillRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return BackFillResponse
   */
  async backFillWithOptions(tmpReq: BackFillRequest, runtime: $Util.RuntimeOptions): Promise<BackFillResponse> {
    Util.validateModel(tmpReq);
    let request = new BackFillShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.filterNodeIds)) {
      request.filterNodeIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterNodeIds, "FilterNodeIds", "json");
    }

    if (!Util.isUnset(tmpReq.startNodeIds)) {
      request.startNodeIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.startNodeIds, "StartNodeIds", "json");
    }

    let query = { };
    if (!Util.isUnset(request.asc)) {
      query["Asc"] = request.asc;
    }

    if (!Util.isUnset(request.backFillDate)) {
      query["BackFillDate"] = request.backFillDate;
    }

    if (!Util.isUnset(request.backFillDateBegin)) {
      query["BackFillDateBegin"] = request.backFillDateBegin;
    }

    if (!Util.isUnset(request.backFillDateEnd)) {
      query["BackFillDateEnd"] = request.backFillDateEnd;
    }

    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.filterNodeIdsShrink)) {
      query["FilterNodeIds"] = request.filterNodeIdsShrink;
    }

    if (!Util.isUnset(request.historyDagId)) {
      query["HistoryDagId"] = request.historyDagId;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.isTriggerSubTree)) {
      query["IsTriggerSubTree"] = request.isTriggerSubTree;
    }

    if (!Util.isUnset(request.startNodeIdsShrink)) {
      query["StartNodeIds"] = request.startNodeIdsShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BackFill",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BackFillResponse>(await this.callApi(params, req, runtime), new BackFillResponse({}));
  }

  /**
   * @summary Backfills data for task orchestration.
   *
   * @description During a data backfill, task flows are run in sequence based on their dates. You can specify whether task flows are run in chronological or reverse chronological order. After the data backfill is complete, you can specify a date or date range, and a node range to run task flows.
   *
   * @param request BackFillRequest
   * @return BackFillResponse
   */
  async backFill(request: BackFillRequest): Promise<BackFillResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.backFillWithOptions(request, runtime);
  }

  /**
   * @summary Purchases a pay-as-you-go Data Management (DMS) resource.
   *
   * @param request BuyPayAsYouGoOrderRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return BuyPayAsYouGoOrderResponse
   */
  async buyPayAsYouGoOrderWithOptions(request: BuyPayAsYouGoOrderRequest, runtime: $Util.RuntimeOptions): Promise<BuyPayAsYouGoOrderResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.commodityType)) {
      query["CommodityType"] = request.commodityType;
    }

    if (!Util.isUnset(request.insNum)) {
      query["InsNum"] = request.insNum;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.versionType)) {
      query["VersionType"] = request.versionType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BuyPayAsYouGoOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BuyPayAsYouGoOrderResponse>(await this.callApi(params, req, runtime), new BuyPayAsYouGoOrderResponse({}));
  }

  /**
   * @summary Purchases a pay-as-you-go Data Management (DMS) resource.
   *
   * @param request BuyPayAsYouGoOrderRequest
   * @return BuyPayAsYouGoOrderResponse
   */
  async buyPayAsYouGoOrder(request: BuyPayAsYouGoOrderRequest): Promise<BuyPayAsYouGoOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.buyPayAsYouGoOrderWithOptions(request, runtime);
  }

  /**
   * @summary Adjusts the sensitivity level of one or more fields.
   *
   * @param request ChangeColumnSecLevelRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ChangeColumnSecLevelResponse
   */
  async changeColumnSecLevelWithOptions(request: ChangeColumnSecLevelRequest, runtime: $Util.RuntimeOptions): Promise<ChangeColumnSecLevelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.columnName)) {
      query["ColumnName"] = request.columnName;
    }

    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.isLogic)) {
      query["IsLogic"] = request.isLogic;
    }

    if (!Util.isUnset(request.newLevel)) {
      query["NewLevel"] = request.newLevel;
    }

    if (!Util.isUnset(request.schemaName)) {
      query["SchemaName"] = request.schemaName;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ChangeColumnSecLevel",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ChangeColumnSecLevelResponse>(await this.callApi(params, req, runtime), new ChangeColumnSecLevelResponse({}));
  }

  /**
   * @summary Adjusts the sensitivity level of one or more fields.
   *
   * @param request ChangeColumnSecLevelRequest
   * @return ChangeColumnSecLevelResponse
   */
  async changeColumnSecLevel(request: ChangeColumnSecLevelRequest): Promise<ChangeColumnSecLevelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.changeColumnSecLevelWithOptions(request, runtime);
  }

  /**
   * @summary 修改字段敏感序列
   *
   * @param request ChangeColumnSecurityLevelRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ChangeColumnSecurityLevelResponse
   */
  async changeColumnSecurityLevelWithOptions(request: ChangeColumnSecurityLevelRequest, runtime: $Util.RuntimeOptions): Promise<ChangeColumnSecurityLevelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.columnName)) {
      query["ColumnName"] = request.columnName;
    }

    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.isLogic)) {
      query["IsLogic"] = request.isLogic;
    }

    if (!Util.isUnset(request.newSensitivityLevel)) {
      query["NewSensitivityLevel"] = request.newSensitivityLevel;
    }

    if (!Util.isUnset(request.schemaName)) {
      query["SchemaName"] = request.schemaName;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ChangeColumnSecurityLevel",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ChangeColumnSecurityLevelResponse>(await this.callApi(params, req, runtime), new ChangeColumnSecurityLevelResponse({}));
  }

  /**
   * @summary 修改字段敏感序列
   *
   * @param request ChangeColumnSecurityLevelRequest
   * @return ChangeColumnSecurityLevelResponse
   */
  async changeColumnSecurityLevel(request: ChangeColumnSecurityLevelRequest): Promise<ChangeColumnSecurityLevelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.changeColumnSecurityLevelWithOptions(request, runtime);
  }

  /**
   * @summary 移交数仓开发任务流
   *
   * @description Usage notes:
   * *   If you call this operation to transfer the ownership of a published task flow, the ownership transfer does not take effect.
   * *   You can call the [ReDeployLhDagVersion](https://help.aliyun.com/document_detail/424712.html) operation to redeploy a published version of a task flow.
   *
   * @param request ChangeLhDagOwnerRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ChangeLhDagOwnerResponse
   */
  async changeLhDagOwnerWithOptions(request: ChangeLhDagOwnerRequest, runtime: $Util.RuntimeOptions): Promise<ChangeLhDagOwnerResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.ownerUserId)) {
      query["OwnerUserId"] = request.ownerUserId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ChangeLhDagOwner",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ChangeLhDagOwnerResponse>(await this.callApi(params, req, runtime), new ChangeLhDagOwnerResponse({}));
  }

  /**
   * @summary 移交数仓开发任务流
   *
   * @description Usage notes:
   * *   If you call this operation to transfer the ownership of a published task flow, the ownership transfer does not take effect.
   * *   You can call the [ReDeployLhDagVersion](https://help.aliyun.com/document_detail/424712.html) operation to redeploy a published version of a task flow.
   *
   * @param request ChangeLhDagOwnerRequest
   * @return ChangeLhDagOwnerResponse
   */
  async changeLhDagOwner(request: ChangeLhDagOwnerRequest): Promise<ChangeLhDagOwnerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.changeLhDagOwnerWithOptions(request, runtime);
  }

  /**
   * @summary Closes a ticket.
   *
   * @param request CloseOrderRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CloseOrderResponse
   */
  async closeOrderWithOptions(request: CloseOrderRequest, runtime: $Util.RuntimeOptions): Promise<CloseOrderResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.closeReason)) {
      query["CloseReason"] = request.closeReason;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CloseOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CloseOrderResponse>(await this.callApi(params, req, runtime), new CloseOrderResponse({}));
  }

  /**
   * @summary Closes a ticket.
   *
   * @param request CloseOrderRequest
   * @return CloseOrderResponse
   */
  async closeOrder(request: CloseOrderRequest): Promise<CloseOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.closeOrderWithOptions(request, runtime);
  }

  /**
   * @summary Creates a permission template
   *
   * @description You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
   *
   * @param request CreateAuthorityTemplateRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateAuthorityTemplateResponse
   */
  async createAuthorityTemplateWithOptions(request: CreateAuthorityTemplateRequest, runtime: $Util.RuntimeOptions): Promise<CreateAuthorityTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateAuthorityTemplate",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateAuthorityTemplateResponse>(await this.callApi(params, req, runtime), new CreateAuthorityTemplateResponse({}));
  }

  /**
   * @summary Creates a permission template
   *
   * @description You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
   *
   * @param request CreateAuthorityTemplateRequest
   * @return CreateAuthorityTemplateResponse
   */
  async createAuthorityTemplate(request: CreateAuthorityTemplateRequest): Promise<CreateAuthorityTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createAuthorityTemplateWithOptions(request, runtime);
  }

  /**
   * @summary Creates data archiving tickets.
   *
   * @param tmpReq CreateDataArchiveOrderRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateDataArchiveOrderResponse
   */
  async createDataArchiveOrderWithOptions(tmpReq: CreateDataArchiveOrderRequest, runtime: $Util.RuntimeOptions): Promise<CreateDataArchiveOrderResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateDataArchiveOrderShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.param)) {
      request.paramShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.param, "Param", "json");
    }

    if (!Util.isUnset(tmpReq.relatedUserList)) {
      request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, "RelatedUserList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.paramShrink)) {
      query["Param"] = request.paramShrink;
    }

    if (!Util.isUnset(request.parentId)) {
      query["ParentId"] = request.parentId;
    }

    if (!Util.isUnset(request.pluginType)) {
      query["PluginType"] = request.pluginType;
    }

    if (!Util.isUnset(request.relatedUserListShrink)) {
      query["RelatedUserList"] = request.relatedUserListShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDataArchiveOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDataArchiveOrderResponse>(await this.callApi(params, req, runtime), new CreateDataArchiveOrderResponse({}));
  }

  /**
   * @summary Creates data archiving tickets.
   *
   * @param request CreateDataArchiveOrderRequest
   * @return CreateDataArchiveOrderResponse
   */
  async createDataArchiveOrder(request: CreateDataArchiveOrderRequest): Promise<CreateDataArchiveOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDataArchiveOrderWithOptions(request, runtime);
  }

  /**
   * @summary Creates a ticket for changing data in Data Management (DMS).
   *
   * @description For more information about the Normal Data Modify feature, see [Change regular data](https://help.aliyun.com/document_detail/58419.html).
   *
   * @param tmpReq CreateDataCorrectOrderRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateDataCorrectOrderResponse
   */
  async createDataCorrectOrderWithOptions(tmpReq: CreateDataCorrectOrderRequest, runtime: $Util.RuntimeOptions): Promise<CreateDataCorrectOrderResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateDataCorrectOrderShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.param)) {
      request.paramShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.param, "Param", "json");
    }

    if (!Util.isUnset(tmpReq.relatedUserList)) {
      request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, "RelatedUserList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.attachmentKey)) {
      query["AttachmentKey"] = request.attachmentKey;
    }

    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.paramShrink)) {
      query["Param"] = request.paramShrink;
    }

    if (!Util.isUnset(request.relatedUserListShrink)) {
      query["RelatedUserList"] = request.relatedUserListShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDataCorrectOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDataCorrectOrderResponse>(await this.callApi(params, req, runtime), new CreateDataCorrectOrderResponse({}));
  }

  /**
   * @summary Creates a ticket for changing data in Data Management (DMS).
   *
   * @description For more information about the Normal Data Modify feature, see [Change regular data](https://help.aliyun.com/document_detail/58419.html).
   *
   * @param request CreateDataCorrectOrderRequest
   * @return CreateDataCorrectOrderResponse
   */
  async createDataCorrectOrder(request: CreateDataCorrectOrderRequest): Promise<CreateDataCorrectOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDataCorrectOrderWithOptions(request, runtime);
  }

  /**
   * @summary Creates a ticket for clearing historical data.
   *
   * @description For more information about the historical data cleaning, see [Clear historical data](https://help.aliyun.com/document_detail/162507.html).
   * This operation can be used only for MySQL databases.
   *
   * @param tmpReq CreateDataCronClearOrderRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateDataCronClearOrderResponse
   */
  async createDataCronClearOrderWithOptions(tmpReq: CreateDataCronClearOrderRequest, runtime: $Util.RuntimeOptions): Promise<CreateDataCronClearOrderResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateDataCronClearOrderShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.param)) {
      request.paramShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.param, "Param", "json");
    }

    if (!Util.isUnset(tmpReq.relatedUserList)) {
      request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, "RelatedUserList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.attachmentKey)) {
      query["AttachmentKey"] = request.attachmentKey;
    }

    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.paramShrink)) {
      query["Param"] = request.paramShrink;
    }

    if (!Util.isUnset(request.relatedUserListShrink)) {
      query["RelatedUserList"] = request.relatedUserListShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDataCronClearOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDataCronClearOrderResponse>(await this.callApi(params, req, runtime), new CreateDataCronClearOrderResponse({}));
  }

  /**
   * @summary Creates a ticket for clearing historical data.
   *
   * @description For more information about the historical data cleaning, see [Clear historical data](https://help.aliyun.com/document_detail/162507.html).
   * This operation can be used only for MySQL databases.
   *
   * @param request CreateDataCronClearOrderRequest
   * @return CreateDataCronClearOrderResponse
   */
  async createDataCronClearOrder(request: CreateDataCronClearOrderRequest): Promise<CreateDataCronClearOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDataCronClearOrderWithOptions(request, runtime);
  }

  /**
   * @summary Creates a ticket to export an SQL result set.
   *
   * @param tmpReq CreateDataExportOrderRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateDataExportOrderResponse
   */
  async createDataExportOrderWithOptions(tmpReq: CreateDataExportOrderRequest, runtime: $Util.RuntimeOptions): Promise<CreateDataExportOrderResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateDataExportOrderShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.pluginParam)) {
      request.pluginParamShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.pluginParam, "PluginParam", "json");
    }

    if (!Util.isUnset(tmpReq.relatedUserList)) {
      request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, "RelatedUserList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.attachmentKey)) {
      query["AttachmentKey"] = request.attachmentKey;
    }

    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.parentId)) {
      query["ParentId"] = request.parentId;
    }

    if (!Util.isUnset(request.pluginParamShrink)) {
      query["PluginParam"] = request.pluginParamShrink;
    }

    if (!Util.isUnset(request.relatedUserListShrink)) {
      query["RelatedUserList"] = request.relatedUserListShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDataExportOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDataExportOrderResponse>(await this.callApi(params, req, runtime), new CreateDataExportOrderResponse({}));
  }

  /**
   * @summary Creates a ticket to export an SQL result set.
   *
   * @param request CreateDataExportOrderRequest
   * @return CreateDataExportOrderResponse
   */
  async createDataExportOrder(request: CreateDataExportOrderRequest): Promise<CreateDataExportOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDataExportOrderWithOptions(request, runtime);
  }

  /**
   * @summary Creates a ticket for importing data to Data Management (DMS).
   *
   * @description For more information about the Large Data Import feature, see [Import data](https://help.aliyun.com/document_detail/161439.html).
   *
   * @param tmpReq CreateDataImportOrderRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateDataImportOrderResponse
   */
  async createDataImportOrderWithOptions(tmpReq: CreateDataImportOrderRequest, runtime: $Util.RuntimeOptions): Promise<CreateDataImportOrderResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateDataImportOrderShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.param)) {
      request.paramShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.param, "Param", "json");
    }

    if (!Util.isUnset(tmpReq.relatedUserList)) {
      request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, "RelatedUserList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.attachmentKey)) {
      query["AttachmentKey"] = request.attachmentKey;
    }

    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.paramShrink)) {
      query["Param"] = request.paramShrink;
    }

    if (!Util.isUnset(request.relatedUserListShrink)) {
      query["RelatedUserList"] = request.relatedUserListShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDataImportOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDataImportOrderResponse>(await this.callApi(params, req, runtime), new CreateDataImportOrderResponse({}));
  }

  /**
   * @summary Creates a ticket for importing data to Data Management (DMS).
   *
   * @description For more information about the Large Data Import feature, see [Import data](https://help.aliyun.com/document_detail/161439.html).
   *
   * @param request CreateDataImportOrderRequest
   * @return CreateDataImportOrderResponse
   */
  async createDataImportOrder(request: CreateDataImportOrderRequest): Promise<CreateDataImportOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDataImportOrderWithOptions(request, runtime);
  }

  /**
   * @summary Creates a data tracking ticket.
   *
   * @description This operation is available only for instances that are managed in Security Collaboration mode.
   *
   * @param tmpReq CreateDataTrackOrderRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateDataTrackOrderResponse
   */
  async createDataTrackOrderWithOptions(tmpReq: CreateDataTrackOrderRequest, runtime: $Util.RuntimeOptions): Promise<CreateDataTrackOrderResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateDataTrackOrderShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.param)) {
      request.paramShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.param, "Param", "json");
    }

    if (!Util.isUnset(tmpReq.relatedUserList)) {
      request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, "RelatedUserList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.paramShrink)) {
      query["Param"] = request.paramShrink;
    }

    if (!Util.isUnset(request.relatedUserListShrink)) {
      query["RelatedUserList"] = request.relatedUserListShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDataTrackOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDataTrackOrderResponse>(await this.callApi(params, req, runtime), new CreateDataTrackOrderResponse({}));
  }

  /**
   * @summary Creates a data tracking ticket.
   *
   * @description This operation is available only for instances that are managed in Security Collaboration mode.
   *
   * @param request CreateDataTrackOrderRequest
   * @return CreateDataTrackOrderResponse
   */
  async createDataTrackOrder(request: CreateDataTrackOrderRequest): Promise<CreateDataTrackOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDataTrackOrderWithOptions(request, runtime);
  }

  /**
   * @summary Creates a database export ticket.
   *
   * @param tmpReq CreateDatabaseExportOrderRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateDatabaseExportOrderResponse
   */
  async createDatabaseExportOrderWithOptions(tmpReq: CreateDatabaseExportOrderRequest, runtime: $Util.RuntimeOptions): Promise<CreateDatabaseExportOrderResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateDatabaseExportOrderShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.pluginParam)) {
      request.pluginParamShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.pluginParam, "PluginParam", "json");
    }

    if (!Util.isUnset(tmpReq.relatedUserList)) {
      request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, "RelatedUserList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.attachmentKey)) {
      query["AttachmentKey"] = request.attachmentKey;
    }

    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.parentId)) {
      query["ParentId"] = request.parentId;
    }

    if (!Util.isUnset(request.pluginParamShrink)) {
      query["PluginParam"] = request.pluginParamShrink;
    }

    if (!Util.isUnset(request.relatedUserListShrink)) {
      query["RelatedUserList"] = request.relatedUserListShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDatabaseExportOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDatabaseExportOrderResponse>(await this.callApi(params, req, runtime), new CreateDatabaseExportOrderResponse({}));
  }

  /**
   * @summary Creates a database export ticket.
   *
   * @param request CreateDatabaseExportOrderRequest
   * @return CreateDatabaseExportOrderResponse
   */
  async createDatabaseExportOrder(request: CreateDatabaseExportOrderRequest): Promise<CreateDatabaseExportOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDatabaseExportOrderWithOptions(request, runtime);
  }

  /**
   * @summary 创建无锁变更工单
   *
   * @description For more information about the lock-free change feature, see [Overview](https://help.aliyun.com/document_detail/207847.html).
   * This operation can be used only for instances that are managed in Stable Change or Security Collaboration mode. For more information, see [Change data without the need to lock tables](https://help.aliyun.com/document_detail/96145.html) and [Change schemas without locking tables](https://help.aliyun.com/document_detail/98373.html).
   *
   * @param tmpReq CreateFreeLockCorrectOrderRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateFreeLockCorrectOrderResponse
   */
  async createFreeLockCorrectOrderWithOptions(tmpReq: CreateFreeLockCorrectOrderRequest, runtime: $Util.RuntimeOptions): Promise<CreateFreeLockCorrectOrderResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateFreeLockCorrectOrderShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.param)) {
      request.paramShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.param, "Param", "json");
    }

    if (!Util.isUnset(tmpReq.relatedUserList)) {
      request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, "RelatedUserList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.attachmentKey)) {
      query["AttachmentKey"] = request.attachmentKey;
    }

    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.paramShrink)) {
      query["Param"] = request.paramShrink;
    }

    if (!Util.isUnset(request.relatedUserListShrink)) {
      query["RelatedUserList"] = request.relatedUserListShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateFreeLockCorrectOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateFreeLockCorrectOrderResponse>(await this.callApi(params, req, runtime), new CreateFreeLockCorrectOrderResponse({}));
  }

  /**
   * @summary 创建无锁变更工单
   *
   * @description For more information about the lock-free change feature, see [Overview](https://help.aliyun.com/document_detail/207847.html).
   * This operation can be used only for instances that are managed in Stable Change or Security Collaboration mode. For more information, see [Change data without the need to lock tables](https://help.aliyun.com/document_detail/96145.html) and [Change schemas without locking tables](https://help.aliyun.com/document_detail/98373.html).
   *
   * @param request CreateFreeLockCorrectOrderRequest
   * @return CreateFreeLockCorrectOrderResponse
   */
  async createFreeLockCorrectOrder(request: CreateFreeLockCorrectOrderRequest): Promise<CreateFreeLockCorrectOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createFreeLockCorrectOrderWithOptions(request, runtime);
  }

  /**
   * @summary Creates a workspace for data warehouse development in Data Management (DMS).
   *
   * @description *   The workspace name must be unique within a tenant. If a workspace with the same name already exists within the tenant, the call may fail.
   * *   You can call the [GetLhSpaceByName](https://help.aliyun.com/document_detail/424379.html) operation to query whether a workspace with a specific name already exists as a DMS administrator or database administrator (DBA).
   *
   * @param request CreateLakeHouseSpaceRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateLakeHouseSpaceResponse
   */
  async createLakeHouseSpaceWithOptions(request: CreateLakeHouseSpaceRequest, runtime: $Util.RuntimeOptions): Promise<CreateLakeHouseSpaceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.devDbId)) {
      query["DevDbId"] = request.devDbId;
    }

    if (!Util.isUnset(request.dwDbType)) {
      query["DwDbType"] = request.dwDbType;
    }

    if (!Util.isUnset(request.mode)) {
      query["Mode"] = request.mode;
    }

    if (!Util.isUnset(request.prodDbId)) {
      query["ProdDbId"] = request.prodDbId;
    }

    if (!Util.isUnset(request.spaceConfig)) {
      query["SpaceConfig"] = request.spaceConfig;
    }

    if (!Util.isUnset(request.spaceName)) {
      query["SpaceName"] = request.spaceName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateLakeHouseSpace",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateLakeHouseSpaceResponse>(await this.callApi(params, req, runtime), new CreateLakeHouseSpaceResponse({}));
  }

  /**
   * @summary Creates a workspace for data warehouse development in Data Management (DMS).
   *
   * @description *   The workspace name must be unique within a tenant. If a workspace with the same name already exists within the tenant, the call may fail.
   * *   You can call the [GetLhSpaceByName](https://help.aliyun.com/document_detail/424379.html) operation to query whether a workspace with a specific name already exists as a DMS administrator or database administrator (DBA).
   *
   * @param request CreateLakeHouseSpaceRequest
   * @return CreateLakeHouseSpaceResponse
   */
  async createLakeHouseSpace(request: CreateLakeHouseSpaceRequest): Promise<CreateLakeHouseSpaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createLakeHouseSpaceWithOptions(request, runtime);
  }

  /**
   * @summary Creates a logical database in Database Management (DMS).
   *
   * @param tmpReq CreateLogicDatabaseRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateLogicDatabaseResponse
   */
  async createLogicDatabaseWithOptions(tmpReq: CreateLogicDatabaseRequest, runtime: $Util.RuntimeOptions): Promise<CreateLogicDatabaseResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateLogicDatabaseShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.databaseIds)) {
      request.databaseIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.databaseIds, "DatabaseIds", "json");
    }

    let query = { };
    if (!Util.isUnset(request.alias)) {
      query["Alias"] = request.alias;
    }

    if (!Util.isUnset(request.databaseIdsShrink)) {
      query["DatabaseIds"] = request.databaseIdsShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateLogicDatabase",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateLogicDatabaseResponse>(await this.callApi(params, req, runtime), new CreateLogicDatabaseResponse({}));
  }

  /**
   * @summary Creates a logical database in Database Management (DMS).
   *
   * @param request CreateLogicDatabaseRequest
   * @return CreateLogicDatabaseResponse
   */
  async createLogicDatabase(request: CreateLogicDatabaseRequest): Promise<CreateLogicDatabaseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createLogicDatabaseWithOptions(request, runtime);
  }

  /**
   * @summary Creates a ticket in Data Management (DMS).
   *
   * @description To facilitate ticket creation, you can call the following dedicated operations to create some types of tickets:
   * *   [CreateDataCorrectOrder](https://help.aliyun.com/document_detail/208388.html): creates a regular data change ticket.
   * *   [CreateDataCronClearOrder](https://help.aliyun.com/document_detail/208385.html): creates a ticket to clear historical data.
   * *   [CreateDataImportOrder](https://help.aliyun.com/document_detail/208387.html): creates a data import ticket.
   * *   [CreateFreeLockCorrectOrder](https://help.aliyun.com/document_detail/208386.html): creates a lock-free change ticket.
   *
   * @param tmpReq CreateOrderRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateOrderResponse
   */
  async createOrderWithOptions(tmpReq: CreateOrderRequest, runtime: $Util.RuntimeOptions): Promise<CreateOrderResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateOrderShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.pluginParam)) {
      request.pluginParamShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.pluginParam, "PluginParam", "json");
    }

    let query = { };
    if (!Util.isUnset(request.attachmentKey)) {
      query["AttachmentKey"] = request.attachmentKey;
    }

    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.pluginType)) {
      query["PluginType"] = request.pluginType;
    }

    if (!Util.isUnset(request.relatedUserList)) {
      query["RelatedUserList"] = request.relatedUserList;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.pluginParamShrink)) {
      body["PluginParam"] = request.pluginParamShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOrderResponse>(await this.callApi(params, req, runtime), new CreateOrderResponse({}));
  }

  /**
   * @summary Creates a ticket in Data Management (DMS).
   *
   * @description To facilitate ticket creation, you can call the following dedicated operations to create some types of tickets:
   * *   [CreateDataCorrectOrder](https://help.aliyun.com/document_detail/208388.html): creates a regular data change ticket.
   * *   [CreateDataCronClearOrder](https://help.aliyun.com/document_detail/208385.html): creates a ticket to clear historical data.
   * *   [CreateDataImportOrder](https://help.aliyun.com/document_detail/208387.html): creates a data import ticket.
   * *   [CreateFreeLockCorrectOrder](https://help.aliyun.com/document_detail/208386.html): creates a lock-free change ticket.
   *
   * @param request CreateOrderRequest
   * @return CreateOrderResponse
   */
  async createOrder(request: CreateOrderRequest): Promise<CreateOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOrderWithOptions(request, runtime);
  }

  /**
   * @summary 创建可编程对象变更工单
   *
   * @param tmpReq CreateProcCorrectOrderRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateProcCorrectOrderResponse
   */
  async createProcCorrectOrderWithOptions(tmpReq: CreateProcCorrectOrderRequest, runtime: $Util.RuntimeOptions): Promise<CreateProcCorrectOrderResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateProcCorrectOrderShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.param)) {
      request.paramShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.param, "Param", "json");
    }

    if (!Util.isUnset(tmpReq.relatedUserList)) {
      request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, "RelatedUserList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.attachmentKey)) {
      query["AttachmentKey"] = request.attachmentKey;
    }

    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.paramShrink)) {
      query["Param"] = request.paramShrink;
    }

    if (!Util.isUnset(request.relatedUserListShrink)) {
      query["RelatedUserList"] = request.relatedUserListShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateProcCorrectOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateProcCorrectOrderResponse>(await this.callApi(params, req, runtime), new CreateProcCorrectOrderResponse({}));
  }

  /**
   * @summary 创建可编程对象变更工单
   *
   * @param request CreateProcCorrectOrderRequest
   * @return CreateProcCorrectOrderResponse
   */
  async createProcCorrectOrder(request: CreateProcCorrectOrderRequest): Promise<CreateProcCorrectOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createProcCorrectOrderWithOptions(request, runtime);
  }

  /**
   * @summary Enables the secure access proxy feature for a database instance.
   *
   * @description - The database instance runs the MySQL or MariaDB database engine. For example, the database instance can be an ApsaraDB RDS for MySQL instance, a PolarDB for MySQL cluster, a Distributed Relational Database Service (DRDS) cluster, or an AnalyticDB for MySQL cluster. The database instance can also be a self-managed MySQL or MariaDB database, or a MySQL or MariaDB database in a third-party cloud.
   * - The database instance resides in the China (Hangzhou) or China (Beijing) region.
   * - You are a Data Management (DMS) administrator, a database administrator (DBA), or the owner of the database instance.
   *
   * @param request CreateProxyRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateProxyResponse
   */
  async createProxyWithOptions(request: CreateProxyRequest, runtime: $Util.RuntimeOptions): Promise<CreateProxyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.password)) {
      query["Password"] = request.password;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.username)) {
      query["Username"] = request.username;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateProxy",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateProxyResponse>(await this.callApi(params, req, runtime), new CreateProxyResponse({}));
  }

  /**
   * @summary Enables the secure access proxy feature for a database instance.
   *
   * @description - The database instance runs the MySQL or MariaDB database engine. For example, the database instance can be an ApsaraDB RDS for MySQL instance, a PolarDB for MySQL cluster, a Distributed Relational Database Service (DRDS) cluster, or an AnalyticDB for MySQL cluster. The database instance can also be a self-managed MySQL or MariaDB database, or a MySQL or MariaDB database in a third-party cloud.
   * - The database instance resides in the China (Hangzhou) or China (Beijing) region.
   * - You are a Data Management (DMS) administrator, a database administrator (DBA), or the owner of the database instance.
   *
   * @param request CreateProxyRequest
   * @return CreateProxyResponse
   */
  async createProxy(request: CreateProxyRequest): Promise<CreateProxyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createProxyWithOptions(request, runtime);
  }

  /**
   * @summary You can call the CreateProxyAccess to authorize users to access the DB instance through the Data Security Protection agent.
   *
   * @description - The data security protection feature is enabled for the instance.
   * - Your user role is the administrator role, DBA role, or the owner of data security protection for the current instance.
   *
   * @param request CreateProxyAccessRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateProxyAccessResponse
   */
  async createProxyAccessWithOptions(request: CreateProxyAccessRequest, runtime: $Util.RuntimeOptions): Promise<CreateProxyAccessResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.indepAccount)) {
      query["IndepAccount"] = request.indepAccount;
    }

    if (!Util.isUnset(request.indepPassword)) {
      query["IndepPassword"] = request.indepPassword;
    }

    if (!Util.isUnset(request.proxyId)) {
      query["ProxyId"] = request.proxyId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.userId)) {
      query["UserId"] = request.userId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateProxyAccess",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateProxyAccessResponse>(await this.callApi(params, req, runtime), new CreateProxyAccessResponse({}));
  }

  /**
   * @summary You can call the CreateProxyAccess to authorize users to access the DB instance through the Data Security Protection agent.
   *
   * @description - The data security protection feature is enabled for the instance.
   * - Your user role is the administrator role, DBA role, or the owner of data security protection for the current instance.
   *
   * @param request CreateProxyAccessRequest
   * @return CreateProxyAccessResponse
   */
  async createProxyAccess(request: CreateProxyAccessRequest): Promise<CreateProxyAccessResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createProxyAccessWithOptions(request, runtime);
  }

  /**
   * @summary Executes a schema design ticket.
   *
   * @param request CreatePublishGroupTaskRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreatePublishGroupTaskResponse
   */
  async createPublishGroupTaskWithOptions(request: CreatePublishGroupTaskRequest, runtime: $Util.RuntimeOptions): Promise<CreatePublishGroupTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.logic)) {
      query["Logic"] = request.logic;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.planTime)) {
      query["PlanTime"] = request.planTime;
    }

    if (!Util.isUnset(request.publishStrategy)) {
      query["PublishStrategy"] = request.publishStrategy;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreatePublishGroupTask",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreatePublishGroupTaskResponse>(await this.callApi(params, req, runtime), new CreatePublishGroupTaskResponse({}));
  }

  /**
   * @summary Executes a schema design ticket.
   *
   * @param request CreatePublishGroupTaskRequest
   * @return CreatePublishGroupTaskResponse
   */
  async createPublishGroupTask(request: CreatePublishGroupTaskRequest): Promise<CreatePublishGroupTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createPublishGroupTaskWithOptions(request, runtime);
  }

  /**
   * @summary Creates a SQL review ticket.
   *
   * @description You can call this operation only for database instances that are managed in Security Collaboration mode.
   * For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
   *
   * @param tmpReq CreateSQLReviewOrderRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateSQLReviewOrderResponse
   */
  async createSQLReviewOrderWithOptions(tmpReq: CreateSQLReviewOrderRequest, runtime: $Util.RuntimeOptions): Promise<CreateSQLReviewOrderResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateSQLReviewOrderShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.param)) {
      request.paramShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.param, "Param", "json");
    }

    if (!Util.isUnset(tmpReq.relatedUserList)) {
      request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, "RelatedUserList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.paramShrink)) {
      query["Param"] = request.paramShrink;
    }

    if (!Util.isUnset(request.relatedUserListShrink)) {
      query["RelatedUserList"] = request.relatedUserListShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateSQLReviewOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSQLReviewOrderResponse>(await this.callApi(params, req, runtime), new CreateSQLReviewOrderResponse({}));
  }

  /**
   * @summary Creates a SQL review ticket.
   *
   * @description You can call this operation only for database instances that are managed in Security Collaboration mode.
   * For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
   *
   * @param request CreateSQLReviewOrderRequest
   * @return CreateSQLReviewOrderResponse
   */
  async createSQLReviewOrder(request: CreateSQLReviewOrderRequest): Promise<CreateSQLReviewOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSQLReviewOrderWithOptions(request, runtime);
  }

  /**
   * @summary Creates a business scenario to group task flows by business scenario.
   *
   * @param request CreateScenarioRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateScenarioResponse
   */
  async createScenarioWithOptions(request: CreateScenarioRequest, runtime: $Util.RuntimeOptions): Promise<CreateScenarioResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.scenarioName)) {
      query["ScenarioName"] = request.scenarioName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateScenario",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateScenarioResponse>(await this.callApi(params, req, runtime), new CreateScenarioResponse({}));
  }

  /**
   * @summary Creates a business scenario to group task flows by business scenario.
   *
   * @param request CreateScenarioRequest
   * @return CreateScenarioResponse
   */
  async createScenario(request: CreateScenarioRequest): Promise<CreateScenarioResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createScenarioWithOptions(request, runtime);
  }

  /**
   * @summary Creates a security rule set.
   *
   * @param request CreateStandardGroupRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateStandardGroupResponse
   */
  async createStandardGroupWithOptions(request: CreateStandardGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateStandardGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbType)) {
      query["DbType"] = request.dbType;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateStandardGroup",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateStandardGroupResponse>(await this.callApi(params, req, runtime), new CreateStandardGroupResponse({}));
  }

  /**
   * @summary Creates a security rule set.
   *
   * @param request CreateStandardGroupRequest
   * @return CreateStandardGroupResponse
   */
  async createStandardGroup(request: CreateStandardGroupRequest): Promise<CreateStandardGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createStandardGroupWithOptions(request, runtime);
  }

  /**
   * @summary Creates a schema synchronization ticket.
   *
   * @param tmpReq CreateStructSyncOrderRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateStructSyncOrderResponse
   */
  async createStructSyncOrderWithOptions(tmpReq: CreateStructSyncOrderRequest, runtime: $Util.RuntimeOptions): Promise<CreateStructSyncOrderResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateStructSyncOrderShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.param)) {
      request.paramShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.param, "Param", "json");
    }

    if (!Util.isUnset(tmpReq.relatedUserList)) {
      request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, "RelatedUserList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.attachmentKey)) {
      query["AttachmentKey"] = request.attachmentKey;
    }

    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.paramShrink)) {
      query["Param"] = request.paramShrink;
    }

    if (!Util.isUnset(request.relatedUserListShrink)) {
      query["RelatedUserList"] = request.relatedUserListShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateStructSyncOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateStructSyncOrderResponse>(await this.callApi(params, req, runtime), new CreateStructSyncOrderResponse({}));
  }

  /**
   * @summary Creates a schema synchronization ticket.
   *
   * @param request CreateStructSyncOrderRequest
   * @return CreateStructSyncOrderResponse
   */
  async createStructSyncOrder(request: CreateStructSyncOrderRequest): Promise<CreateStructSyncOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createStructSyncOrderWithOptions(request, runtime);
  }

  /**
   * @summary Creates a task node for a task flow.
   *
   * @param request CreateTaskRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateTaskResponse
   */
  async createTaskWithOptions(request: CreateTaskRequest, runtime: $Util.RuntimeOptions): Promise<CreateTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.graphParam)) {
      query["GraphParam"] = request.graphParam;
    }

    if (!Util.isUnset(request.nodeContent)) {
      query["NodeContent"] = request.nodeContent;
    }

    if (!Util.isUnset(request.nodeName)) {
      query["NodeName"] = request.nodeName;
    }

    if (!Util.isUnset(request.nodeOutput)) {
      query["NodeOutput"] = request.nodeOutput;
    }

    if (!Util.isUnset(request.nodeType)) {
      query["NodeType"] = request.nodeType;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.timeVariables)) {
      query["TimeVariables"] = request.timeVariables;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateTask",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateTaskResponse>(await this.callApi(params, req, runtime), new CreateTaskResponse({}));
  }

  /**
   * @summary Creates a task node for a task flow.
   *
   * @param request CreateTaskRequest
   * @return CreateTaskResponse
   */
  async createTask(request: CreateTaskRequest): Promise<CreateTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createTaskWithOptions(request, runtime);
  }

  /**
   * @summary Creates a task flow.
   *
   * @param request CreateTaskFlowRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateTaskFlowResponse
   */
  async createTaskFlowWithOptions(request: CreateTaskFlowRequest, runtime: $Util.RuntimeOptions): Promise<CreateTaskFlowResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagName)) {
      query["DagName"] = request.dagName;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.scenarioId)) {
      query["ScenarioId"] = request.scenarioId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateTaskFlow",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateTaskFlowResponse>(await this.callApi(params, req, runtime), new CreateTaskFlowResponse({}));
  }

  /**
   * @summary Creates a task flow.
   *
   * @param request CreateTaskFlowRequest
   * @return CreateTaskFlowResponse
   */
  async createTaskFlow(request: CreateTaskFlowRequest): Promise<CreateTaskFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createTaskFlowWithOptions(request, runtime);
  }

  /**
   * @summary 创建上传附件任务
   *
   * @param request CreateUploadFileJobRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateUploadFileJobResponse
   */
  async createUploadFileJobWithOptions(request: CreateUploadFileJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateUploadFileJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.fileName)) {
      query["FileName"] = request.fileName;
    }

    if (!Util.isUnset(request.fileSource)) {
      query["FileSource"] = request.fileSource;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.uploadURL)) {
      query["UploadURL"] = request.uploadURL;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateUploadFileJob",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateUploadFileJobResponse>(await this.callApi(params, req, runtime), new CreateUploadFileJobResponse({}));
  }

  /**
   * @summary 创建上传附件任务
   *
   * @param request CreateUploadFileJobRequest
   * @return CreateUploadFileJobResponse
   */
  async createUploadFileJob(request: CreateUploadFileJobRequest): Promise<CreateUploadFileJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createUploadFileJobWithOptions(request, runtime);
  }

  /**
   * @summary Creates a task to upload an Object Storage Service (OSS) file and obtain the key of the task.
   *
   * @param tmpReq CreateUploadOSSFileJobRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateUploadOSSFileJobResponse
   */
  async createUploadOSSFileJobWithOptions(tmpReq: CreateUploadOSSFileJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateUploadOSSFileJobResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateUploadOSSFileJobShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.uploadTarget)) {
      request.uploadTargetShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.uploadTarget, "UploadTarget", "json");
    }

    let query = { };
    if (!Util.isUnset(request.fileName)) {
      query["FileName"] = request.fileName;
    }

    if (!Util.isUnset(request.fileSource)) {
      query["FileSource"] = request.fileSource;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.uploadTargetShrink)) {
      query["UploadTarget"] = request.uploadTargetShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateUploadOSSFileJob",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateUploadOSSFileJobResponse>(await this.callApi(params, req, runtime), new CreateUploadOSSFileJobResponse({}));
  }

  /**
   * @summary Creates a task to upload an Object Storage Service (OSS) file and obtain the key of the task.
   *
   * @param request CreateUploadOSSFileJobRequest
   * @return CreateUploadOSSFileJobResponse
   */
  async createUploadOSSFileJob(request: CreateUploadOSSFileJobRequest): Promise<CreateUploadOSSFileJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createUploadOSSFileJobWithOptions(request, runtime);
  }

  /**
   * @summary 删除权限模版
   *
   * @param request DeleteAuthorityTemplateRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DeleteAuthorityTemplateResponse
   */
  async deleteAuthorityTemplateWithOptions(request: DeleteAuthorityTemplateRequest, runtime: $Util.RuntimeOptions): Promise<DeleteAuthorityTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteAuthorityTemplate",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteAuthorityTemplateResponse>(await this.callApi(params, req, runtime), new DeleteAuthorityTemplateResponse({}));
  }

  /**
   * @summary 删除权限模版
   *
   * @param request DeleteAuthorityTemplateRequest
   * @return DeleteAuthorityTemplateResponse
   */
  async deleteAuthorityTemplate(request: DeleteAuthorityTemplateRequest): Promise<DeleteAuthorityTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteAuthorityTemplateWithOptions(request, runtime);
  }

  /**
   * @summary Removes a database instance from Data Management (DMS).
   *
   * @description Note: You can call this operation only to remove a database instance from the instance list of DMS. The instance is not deleted or shut down.
   *
   * @param request DeleteInstanceRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DeleteInstanceResponse
   */
  async deleteInstanceWithOptions(request: DeleteInstanceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.host)) {
      query["Host"] = request.host;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.sid)) {
      query["Sid"] = request.sid;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteInstance",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteInstanceResponse>(await this.callApi(params, req, runtime), new DeleteInstanceResponse({}));
  }

  /**
   * @summary Removes a database instance from Data Management (DMS).
   *
   * @description Note: You can call this operation only to remove a database instance from the instance list of DMS. The instance is not deleted or shut down.
   *
   * @param request DeleteInstanceRequest
   * @return DeleteInstanceResponse
   */
  async deleteInstance(request: DeleteInstanceRequest): Promise<DeleteInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteInstanceWithOptions(request, runtime);
  }

  /**
   * @summary Deletes a workspace.
   *
   * @param request DeleteLakeHouseSpaceRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DeleteLakeHouseSpaceResponse
   */
  async deleteLakeHouseSpaceWithOptions(request: DeleteLakeHouseSpaceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLakeHouseSpaceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.spaceId)) {
      query["SpaceId"] = request.spaceId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLakeHouseSpace",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLakeHouseSpaceResponse>(await this.callApi(params, req, runtime), new DeleteLakeHouseSpaceResponse({}));
  }

  /**
   * @summary Deletes a workspace.
   *
   * @param request DeleteLakeHouseSpaceRequest
   * @return DeleteLakeHouseSpaceResponse
   */
  async deleteLakeHouseSpace(request: DeleteLakeHouseSpaceRequest): Promise<DeleteLakeHouseSpaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLakeHouseSpaceWithOptions(request, runtime);
  }

  /**
   * @summary 删除数仓空间成员
   *
   * @description You must call this operation as a DMS administrator, a database administrator (DBA), or a workspace administrator.
   * You cannot call this operation to transfer the ownership of a task flow. To transfer the ownership of a task flow, call the [ChangLhDagOwner](https://help.aliyun.com/document_detail/424761.html) operation.
   *
   * @param tmpReq DeleteLhMembersRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DeleteLhMembersResponse
   */
  async deleteLhMembersWithOptions(tmpReq: DeleteLhMembersRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLhMembersResponse> {
    Util.validateModel(tmpReq);
    let request = new DeleteLhMembersShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.memberIds)) {
      request.memberIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.memberIds, "MemberIds", "json");
    }

    let query = { };
    if (!Util.isUnset(request.memberIdsShrink)) {
      query["MemberIds"] = request.memberIdsShrink;
    }

    if (!Util.isUnset(request.objectId)) {
      query["ObjectId"] = request.objectId;
    }

    if (!Util.isUnset(request.objectType)) {
      query["ObjectType"] = request.objectType;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLhMembers",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLhMembersResponse>(await this.callApi(params, req, runtime), new DeleteLhMembersResponse({}));
  }

  /**
   * @summary 删除数仓空间成员
   *
   * @description You must call this operation as a DMS administrator, a database administrator (DBA), or a workspace administrator.
   * You cannot call this operation to transfer the ownership of a task flow. To transfer the ownership of a task flow, call the [ChangLhDagOwner](https://help.aliyun.com/document_detail/424761.html) operation.
   *
   * @param request DeleteLhMembersRequest
   * @return DeleteLhMembersResponse
   */
  async deleteLhMembers(request: DeleteLhMembersRequest): Promise<DeleteLhMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLhMembersWithOptions(request, runtime);
  }

  /**
   * @summary Deletes a logical database in Database Management (DMS). This operation only deletes the specified logical database but does not delete physical databases.
   *
   * @param request DeleteLogicDatabaseRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DeleteLogicDatabaseResponse
   */
  async deleteLogicDatabaseWithOptions(request: DeleteLogicDatabaseRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLogicDatabaseResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.logicDbId)) {
      query["LogicDbId"] = request.logicDbId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLogicDatabase",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLogicDatabaseResponse>(await this.callApi(params, req, runtime), new DeleteLogicDatabaseResponse({}));
  }

  /**
   * @summary Deletes a logical database in Database Management (DMS). This operation only deletes the specified logical database but does not delete physical databases.
   *
   * @param request DeleteLogicDatabaseRequest
   * @return DeleteLogicDatabaseResponse
   */
  async deleteLogicDatabase(request: DeleteLogicDatabaseRequest): Promise<DeleteLogicDatabaseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLogicDatabaseWithOptions(request, runtime);
  }

  /**
   * @summary Deletes the routing algorithm of a logical table.
   *
   * @param request DeleteLogicTableRouteConfigRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DeleteLogicTableRouteConfigResponse
   */
  async deleteLogicTableRouteConfigWithOptions(request: DeleteLogicTableRouteConfigRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLogicTableRouteConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.routeKey)) {
      query["RouteKey"] = request.routeKey;
    }

    if (!Util.isUnset(request.tableId)) {
      query["TableId"] = request.tableId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLogicTableRouteConfig",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLogicTableRouteConfigResponse>(await this.callApi(params, req, runtime), new DeleteLogicTableRouteConfigResponse({}));
  }

  /**
   * @summary Deletes the routing algorithm of a logical table.
   *
   * @param request DeleteLogicTableRouteConfigRequest
   * @return DeleteLogicTableRouteConfigResponse
   */
  async deleteLogicTableRouteConfig(request: DeleteLogicTableRouteConfigRequest): Promise<DeleteLogicTableRouteConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLogicTableRouteConfigWithOptions(request, runtime);
  }

  /**
   * @summary You can call this operation to disable the data security protection proxy of a DB instance.
   *
   * @description After you disable this feature, your DB instance loses the JDBC protocol. All authorization information is recycled.
   *
   * @param request DeleteProxyRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DeleteProxyResponse
   */
  async deleteProxyWithOptions(request: DeleteProxyRequest, runtime: $Util.RuntimeOptions): Promise<DeleteProxyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.proxyId)) {
      query["ProxyId"] = request.proxyId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteProxy",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteProxyResponse>(await this.callApi(params, req, runtime), new DeleteProxyResponse({}));
  }

  /**
   * @summary You can call this operation to disable the data security protection proxy of a DB instance.
   *
   * @description After you disable this feature, your DB instance loses the JDBC protocol. All authorization information is recycled.
   *
   * @param request DeleteProxyRequest
   * @return DeleteProxyResponse
   */
  async deleteProxy(request: DeleteProxyRequest): Promise<DeleteProxyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteProxyWithOptions(request, runtime);
  }

  /**
   * @summary You can call this operation to DeleteProxyAccess reclaim the data security protection authorization of the target user.
   *
   * @param request DeleteProxyAccessRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DeleteProxyAccessResponse
   */
  async deleteProxyAccessWithOptions(request: DeleteProxyAccessRequest, runtime: $Util.RuntimeOptions): Promise<DeleteProxyAccessResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.proxyAccessId)) {
      query["ProxyAccessId"] = request.proxyAccessId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteProxyAccess",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteProxyAccessResponse>(await this.callApi(params, req, runtime), new DeleteProxyAccessResponse({}));
  }

  /**
   * @summary You can call this operation to DeleteProxyAccess reclaim the data security protection authorization of the target user.
   *
   * @param request DeleteProxyAccessRequest
   * @return DeleteProxyAccessResponse
   */
  async deleteProxyAccess(request: DeleteProxyAccessRequest): Promise<DeleteProxyAccessResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteProxyAccessWithOptions(request, runtime);
  }

  /**
   * @summary Deletes a business scenario.
   *
   * @description When you call this operation, make sure that no task flow is specified in the business scenario.
   *
   * @param request DeleteScenarioRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DeleteScenarioResponse
   */
  async deleteScenarioWithOptions(request: DeleteScenarioRequest, runtime: $Util.RuntimeOptions): Promise<DeleteScenarioResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.scenarioId)) {
      query["ScenarioId"] = request.scenarioId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteScenario",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteScenarioResponse>(await this.callApi(params, req, runtime), new DeleteScenarioResponse({}));
  }

  /**
   * @summary Deletes a business scenario.
   *
   * @description When you call this operation, make sure that no task flow is specified in the business scenario.
   *
   * @param request DeleteScenarioRequest
   * @return DeleteScenarioResponse
   */
  async deleteScenario(request: DeleteScenarioRequest): Promise<DeleteScenarioResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteScenarioWithOptions(request, runtime);
  }

  /**
   * @summary 删除安全规则
   *
   * @param request DeleteStandardGroupRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DeleteStandardGroupResponse
   */
  async deleteStandardGroupWithOptions(request: DeleteStandardGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteStandardGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteStandardGroup",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteStandardGroupResponse>(await this.callApi(params, req, runtime), new DeleteStandardGroupResponse({}));
  }

  /**
   * @summary 删除安全规则
   *
   * @param request DeleteStandardGroupRequest
   * @return DeleteStandardGroupResponse
   */
  async deleteStandardGroup(request: DeleteStandardGroupRequest): Promise<DeleteStandardGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteStandardGroupWithOptions(request, runtime);
  }

  /**
   * @summary Deletes a task in a specified task flow.
   *
   * @param request DeleteTaskRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DeleteTaskResponse
   */
  async deleteTaskWithOptions(request: DeleteTaskRequest, runtime: $Util.RuntimeOptions): Promise<DeleteTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.nodeId)) {
      query["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTask",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteTaskResponse>(await this.callApi(params, req, runtime), new DeleteTaskResponse({}));
  }

  /**
   * @summary Deletes a task in a specified task flow.
   *
   * @param request DeleteTaskRequest
   * @return DeleteTaskResponse
   */
  async deleteTask(request: DeleteTaskRequest): Promise<DeleteTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteTaskWithOptions(request, runtime);
  }

  /**
   * @summary Deletes a task flow.
   *
   * @param request DeleteTaskFlowRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DeleteTaskFlowResponse
   */
  async deleteTaskFlowWithOptions(request: DeleteTaskFlowRequest, runtime: $Util.RuntimeOptions): Promise<DeleteTaskFlowResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTaskFlow",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteTaskFlowResponse>(await this.callApi(params, req, runtime), new DeleteTaskFlowResponse({}));
  }

  /**
   * @summary Deletes a task flow.
   *
   * @param request DeleteTaskFlowRequest
   * @return DeleteTaskFlowResponse
   */
  async deleteTaskFlow(request: DeleteTaskFlowRequest): Promise<DeleteTaskFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteTaskFlowWithOptions(request, runtime);
  }

  /**
   * @summary Deletes task flow edges based on multiple conditions.
   *
   * @description This operation is used for multi-condition query. You can call it to delete the edges of a specified task flow that meet all specified conditions.
   *
   * @param request DeleteTaskFlowEdgesByConditionRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DeleteTaskFlowEdgesByConditionResponse
   */
  async deleteTaskFlowEdgesByConditionWithOptions(request: DeleteTaskFlowEdgesByConditionRequest, runtime: $Util.RuntimeOptions): Promise<DeleteTaskFlowEdgesByConditionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.nodeEnd)) {
      query["NodeEnd"] = request.nodeEnd;
    }

    if (!Util.isUnset(request.nodeFrom)) {
      query["NodeFrom"] = request.nodeFrom;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTaskFlowEdgesByCondition",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteTaskFlowEdgesByConditionResponse>(await this.callApi(params, req, runtime), new DeleteTaskFlowEdgesByConditionResponse({}));
  }

  /**
   * @summary Deletes task flow edges based on multiple conditions.
   *
   * @description This operation is used for multi-condition query. You can call it to delete the edges of a specified task flow that meet all specified conditions.
   *
   * @param request DeleteTaskFlowEdgesByConditionRequest
   * @return DeleteTaskFlowEdgesByConditionResponse
   */
  async deleteTaskFlowEdgesByCondition(request: DeleteTaskFlowEdgesByConditionRequest): Promise<DeleteTaskFlowEdgesByConditionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteTaskFlowEdgesByConditionWithOptions(request, runtime);
  }

  /**
   * @summary Deletes an Alibaba Cloud account that is no longer used.
   *
   * @description The effect of deleting a user by calling this operation is the same as that of deleting a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to delete a user that is no longer used from DMS Enterprise. After the user is deleted, the data source permission, data owner configuration, and database administrator (DBA) configuration of the corresponding Alibaba Cloud account or Resource Access Management (RAM) user are revoked and become invalid.
   * >  This operation only removes the association of the Alibaba Cloud account or RAM user with DMS Enterprise of the enterprise, rather than actually deleting the Alibaba Cloud account or RAM user. After the user is deleted, the Alibaba Cloud account or RAM user cannot log on to DMS Enterprise, unless the user is added to DMS Enterprise again.
   *
   * @param request DeleteUserRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DeleteUserResponse
   */
  async deleteUserWithOptions(request: DeleteUserRequest, runtime: $Util.RuntimeOptions): Promise<DeleteUserResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.uid)) {
      query["Uid"] = request.uid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteUser",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteUserResponse>(await this.callApi(params, req, runtime), new DeleteUserResponse({}));
  }

  /**
   * @summary Deletes an Alibaba Cloud account that is no longer used.
   *
   * @description The effect of deleting a user by calling this operation is the same as that of deleting a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to delete a user that is no longer used from DMS Enterprise. After the user is deleted, the data source permission, data owner configuration, and database administrator (DBA) configuration of the corresponding Alibaba Cloud account or Resource Access Management (RAM) user are revoked and become invalid.
   * >  This operation only removes the association of the Alibaba Cloud account or RAM user with DMS Enterprise of the enterprise, rather than actually deleting the Alibaba Cloud account or RAM user. After the user is deleted, the Alibaba Cloud account or RAM user cannot log on to DMS Enterprise, unless the user is added to DMS Enterprise again.
   *
   * @param request DeleteUserRequest
   * @return DeleteUserResponse
   */
  async deleteUser(request: DeleteUserRequest): Promise<DeleteUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteUserWithOptions(request, runtime);
  }

  /**
   * @summary You can call this operation to disable a user that is temporarily not used in Data Management (DMS) Enterprise.
   *
   * @description The effect of disabling a user by calling this operation is the same as that of disabling a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to disable a user that is temporarily not used in DMS Enterprise. After the user is disabled, the data source permission, data owner configuration, and database administrator (DBA) configuration of the corresponding Alibaba Cloud account or Resource Access Management (RAM) user are revoked and become invalid.
   * >  This operation only stops the Alibaba Cloud account or RAM user from logging on to DMS Enterprise of the enterprise, rather than actually disabling the Alibaba Cloud account or RAM user. After the user is disabled, the Alibaba Cloud account or RAM user cannot log on to DMS Enterprise, unless the user is enabled again. The disabled user, however, still exists in DMS Enterprise.
   *
   * @param request DisableUserRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DisableUserResponse
   */
  async disableUserWithOptions(request: DisableUserRequest, runtime: $Util.RuntimeOptions): Promise<DisableUserResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.uid)) {
      query["Uid"] = request.uid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DisableUser",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DisableUserResponse>(await this.callApi(params, req, runtime), new DisableUserResponse({}));
  }

  /**
   * @summary You can call this operation to disable a user that is temporarily not used in Data Management (DMS) Enterprise.
   *
   * @description The effect of disabling a user by calling this operation is the same as that of disabling a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to disable a user that is temporarily not used in DMS Enterprise. After the user is disabled, the data source permission, data owner configuration, and database administrator (DBA) configuration of the corresponding Alibaba Cloud account or Resource Access Management (RAM) user are revoked and become invalid.
   * >  This operation only stops the Alibaba Cloud account or RAM user from logging on to DMS Enterprise of the enterprise, rather than actually disabling the Alibaba Cloud account or RAM user. After the user is disabled, the Alibaba Cloud account or RAM user cannot log on to DMS Enterprise, unless the user is enabled again. The disabled user, however, still exists in DMS Enterprise.
   *
   * @param request DisableUserRequest
   * @return DisableUserResponse
   */
  async disableUser(request: DisableUserRequest): Promise<DisableUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableUserWithOptions(request, runtime);
  }

  /**
   * @summary Downloads the parsing result of a data tracking task.
   *
   * @param tmpReq DownloadDataTrackResultRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DownloadDataTrackResultResponse
   */
  async downloadDataTrackResultWithOptions(tmpReq: DownloadDataTrackResultRequest, runtime: $Util.RuntimeOptions): Promise<DownloadDataTrackResultResponse> {
    Util.validateModel(tmpReq);
    let request = new DownloadDataTrackResultShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.columnFilter)) {
      request.columnFilterShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.columnFilter, "ColumnFilter", "json");
    }

    if (!Util.isUnset(tmpReq.eventIdList)) {
      request.eventIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.eventIdList, "EventIdList", "json");
    }

    if (!Util.isUnset(tmpReq.filterTableList)) {
      request.filterTableListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterTableList, "FilterTableList", "json");
    }

    if (!Util.isUnset(tmpReq.filterTypeList)) {
      request.filterTypeListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterTypeList, "FilterTypeList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.columnFilterShrink)) {
      query["ColumnFilter"] = request.columnFilterShrink;
    }

    if (!Util.isUnset(request.eventIdListShrink)) {
      query["EventIdList"] = request.eventIdListShrink;
    }

    if (!Util.isUnset(request.filterEndTime)) {
      query["FilterEndTime"] = request.filterEndTime;
    }

    if (!Util.isUnset(request.filterStartTime)) {
      query["FilterStartTime"] = request.filterStartTime;
    }

    if (!Util.isUnset(request.filterTableListShrink)) {
      query["FilterTableList"] = request.filterTableListShrink;
    }

    if (!Util.isUnset(request.filterTypeListShrink)) {
      query["FilterTypeList"] = request.filterTypeListShrink;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.rollbackSQLType)) {
      query["RollbackSQLType"] = request.rollbackSQLType;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DownloadDataTrackResult",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DownloadDataTrackResultResponse>(await this.callApi(params, req, runtime), new DownloadDataTrackResultResponse({}));
  }

  /**
   * @summary Downloads the parsing result of a data tracking task.
   *
   * @param request DownloadDataTrackResultRequest
   * @return DownloadDataTrackResultResponse
   */
  async downloadDataTrackResult(request: DownloadDataTrackResultRequest): Promise<DownloadDataTrackResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.downloadDataTrackResultWithOptions(request, runtime);
  }

  /**
   * @summary Modifies the information about a logical database.
   *
   * @param tmpReq EditLogicDatabaseRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return EditLogicDatabaseResponse
   */
  async editLogicDatabaseWithOptions(tmpReq: EditLogicDatabaseRequest, runtime: $Util.RuntimeOptions): Promise<EditLogicDatabaseResponse> {
    Util.validateModel(tmpReq);
    let request = new EditLogicDatabaseShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.databaseIds)) {
      request.databaseIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.databaseIds, "DatabaseIds", "json");
    }

    let query = { };
    if (!Util.isUnset(request.alias)) {
      query["Alias"] = request.alias;
    }

    if (!Util.isUnset(request.databaseIdsShrink)) {
      query["DatabaseIds"] = request.databaseIdsShrink;
    }

    if (!Util.isUnset(request.logicDbId)) {
      query["LogicDbId"] = request.logicDbId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EditLogicDatabase",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EditLogicDatabaseResponse>(await this.callApi(params, req, runtime), new EditLogicDatabaseResponse({}));
  }

  /**
   * @summary Modifies the information about a logical database.
   *
   * @param request EditLogicDatabaseRequest
   * @return EditLogicDatabaseResponse
   */
  async editLogicDatabase(request: EditLogicDatabaseRequest): Promise<EditLogicDatabaseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.editLogicDatabaseWithOptions(request, runtime);
  }

  /**
   * @summary You can call this operation to enable a user that has been disabled in Data Management (DMS) Enterprise.
   *
   * @description The effect of enabling a user by calling this operation is the same as that of enabling a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to enable a user that has been disabled in DMS Enterprise. After the user is enabled, the corresponding Alibaba Cloud account or Resource Access Management (RAM) user can continue to log on to DMS Enterprise and perform relevant operations.
   * >  This operation only enables the Alibaba Cloud account or RAM user to log on to DMS Enterprise of the enterprise and perform relevant operations, rather than granting other permissions to the Alibaba Cloud account or RAM user.
   *
   * @param request EnableUserRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return EnableUserResponse
   */
  async enableUserWithOptions(request: EnableUserRequest, runtime: $Util.RuntimeOptions): Promise<EnableUserResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.uid)) {
      query["Uid"] = request.uid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableUser",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EnableUserResponse>(await this.callApi(params, req, runtime), new EnableUserResponse({}));
  }

  /**
   * @summary You can call this operation to enable a user that has been disabled in Data Management (DMS) Enterprise.
   *
   * @description The effect of enabling a user by calling this operation is the same as that of enabling a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to enable a user that has been disabled in DMS Enterprise. After the user is enabled, the corresponding Alibaba Cloud account or Resource Access Management (RAM) user can continue to log on to DMS Enterprise and perform relevant operations.
   * >  This operation only enables the Alibaba Cloud account or RAM user to log on to DMS Enterprise of the enterprise and perform relevant operations, rather than granting other permissions to the Alibaba Cloud account or RAM user.
   *
   * @param request EnableUserRequest
   * @return EnableUserResponse
   */
  async enableUser(request: EnableUserRequest): Promise<EnableUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableUserWithOptions(request, runtime);
  }

  /**
   * @summary Submits a ticket for data change.
   *
   * @param tmpReq ExecuteDataCorrectRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ExecuteDataCorrectResponse
   */
  async executeDataCorrectWithOptions(tmpReq: ExecuteDataCorrectRequest, runtime: $Util.RuntimeOptions): Promise<ExecuteDataCorrectResponse> {
    Util.validateModel(tmpReq);
    let request = new ExecuteDataCorrectShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.actionDetail)) {
      request.actionDetailShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.actionDetail, "ActionDetail", "json");
    }

    let query = { };
    if (!Util.isUnset(request.actionDetailShrink)) {
      query["ActionDetail"] = request.actionDetailShrink;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ExecuteDataCorrect",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ExecuteDataCorrectResponse>(await this.callApi(params, req, runtime), new ExecuteDataCorrectResponse({}));
  }

  /**
   * @summary Submits a ticket for data change.
   *
   * @param request ExecuteDataCorrectRequest
   * @return ExecuteDataCorrectResponse
   */
  async executeDataCorrect(request: ExecuteDataCorrectRequest): Promise<ExecuteDataCorrectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.executeDataCorrectWithOptions(request, runtime);
  }

  /**
   * @summary Executes a data export ticket.
   *
   * @param tmpReq ExecuteDataExportRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ExecuteDataExportResponse
   */
  async executeDataExportWithOptions(tmpReq: ExecuteDataExportRequest, runtime: $Util.RuntimeOptions): Promise<ExecuteDataExportResponse> {
    Util.validateModel(tmpReq);
    let request = new ExecuteDataExportShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.actionDetail)) {
      request.actionDetailShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.actionDetail, "ActionDetail", "json");
    }

    let query = { };
    if (!Util.isUnset(request.actionDetailShrink)) {
      query["ActionDetail"] = request.actionDetailShrink;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ExecuteDataExport",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ExecuteDataExportResponse>(await this.callApi(params, req, runtime), new ExecuteDataExportResponse({}));
  }

  /**
   * @summary Executes a data export ticket.
   *
   * @param request ExecuteDataExportRequest
   * @return ExecuteDataExportResponse
   */
  async executeDataExport(request: ExecuteDataExportRequest): Promise<ExecuteDataExportResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.executeDataExportWithOptions(request, runtime);
  }

  /**
   * @summary Executes SQL statements.
   *
   * @description You can call this operation only for instances that are managed in Security Collaboration mode.
   *
   * @param request ExecuteScriptRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ExecuteScriptResponse
   */
  async executeScriptWithOptions(request: ExecuteScriptRequest, runtime: $Util.RuntimeOptions): Promise<ExecuteScriptResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.logic)) {
      query["Logic"] = request.logic;
    }

    if (!Util.isUnset(request.script)) {
      query["Script"] = request.script;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ExecuteScript",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ExecuteScriptResponse>(await this.callApi(params, req, runtime), new ExecuteScriptResponse({}));
  }

  /**
   * @summary Executes SQL statements.
   *
   * @description You can call this operation only for instances that are managed in Security Collaboration mode.
   *
   * @param request ExecuteScriptRequest
   * @return ExecuteScriptResponse
   */
  async executeScript(request: ExecuteScriptRequest): Promise<ExecuteScriptResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.executeScriptWithOptions(request, runtime);
  }

  /**
   * @summary Executes a schema synchronization task.
   *
   * @description If the security rules of an instance indicate that a ticket must be approved before you perform schema synchronization, you can call the [SubmitStructSyncOrderApproval](https://help.aliyun.com/document_detail/206166.html) operation to submit the ticket for approval.
   * >  You can call the [GetStructSyncJobDetail](https://help.aliyun.com/document_detail/206160.html) operation to query whether you need to submit a ticket for approval.
   *
   * @param request ExecuteStructSyncRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ExecuteStructSyncResponse
   */
  async executeStructSyncWithOptions(request: ExecuteStructSyncRequest, runtime: $Util.RuntimeOptions): Promise<ExecuteStructSyncResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ExecuteStructSync",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ExecuteStructSyncResponse>(await this.callApi(params, req, runtime), new ExecuteStructSyncResponse({}));
  }

  /**
   * @summary Executes a schema synchronization task.
   *
   * @description If the security rules of an instance indicate that a ticket must be approved before you perform schema synchronization, you can call the [SubmitStructSyncOrderApproval](https://help.aliyun.com/document_detail/206166.html) operation to submit the ticket for approval.
   * >  You can call the [GetStructSyncJobDetail](https://help.aliyun.com/document_detail/206160.html) operation to query whether you need to submit a ticket for approval.
   *
   * @param request ExecuteStructSyncRequest
   * @return ExecuteStructSyncResponse
   */
  async executeStructSync(request: ExecuteStructSyncRequest): Promise<ExecuteStructSyncResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.executeStructSyncWithOptions(request, runtime);
  }

  /**
   * @summary Queries the approval details of a ticket.
   *
   * @param request GetApprovalDetailRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetApprovalDetailResponse
   */
  async getApprovalDetailWithOptions(request: GetApprovalDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetApprovalDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.workflowInstanceId)) {
      query["WorkflowInstanceId"] = request.workflowInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetApprovalDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetApprovalDetailResponse>(await this.callApi(params, req, runtime), new GetApprovalDetailResponse({}));
  }

  /**
   * @summary Queries the approval details of a ticket.
   *
   * @param request GetApprovalDetailRequest
   * @return GetApprovalDetailResponse
   */
  async getApprovalDetail(request: GetApprovalDetailRequest): Promise<GetApprovalDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getApprovalDetailWithOptions(request, runtime);
  }

  /**
   * @summary Queries the information about a permission template.
   *
   * @description You must be a Data Management (DMS) administrator or a database administrator (DBA). For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
   *
   * @param request GetAuthorityTemplateRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetAuthorityTemplateResponse
   */
  async getAuthorityTemplateWithOptions(request: GetAuthorityTemplateRequest, runtime: $Util.RuntimeOptions): Promise<GetAuthorityTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetAuthorityTemplate",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetAuthorityTemplateResponse>(await this.callApi(params, req, runtime), new GetAuthorityTemplateResponse({}));
  }

  /**
   * @summary Queries the information about a permission template.
   *
   * @description You must be a Data Management (DMS) administrator or a database administrator (DBA). For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
   *
   * @param request GetAuthorityTemplateRequest
   * @return GetAuthorityTemplateResponse
   */
  async getAuthorityTemplate(request: GetAuthorityTemplateRequest): Promise<GetAuthorityTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getAuthorityTemplateWithOptions(request, runtime);
  }

  /**
   * @summary Queries the resources in a permission template.
   *
   * @description You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
   *
   * @param request GetAuthorityTemplateItemRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetAuthorityTemplateItemResponse
   */
  async getAuthorityTemplateItemWithOptions(request: GetAuthorityTemplateItemRequest, runtime: $Util.RuntimeOptions): Promise<GetAuthorityTemplateItemResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetAuthorityTemplateItem",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetAuthorityTemplateItemResponse>(await this.callApi(params, req, runtime), new GetAuthorityTemplateItemResponse({}));
  }

  /**
   * @summary Queries the resources in a permission template.
   *
   * @description You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
   *
   * @param request GetAuthorityTemplateItemRequest
   * @return GetAuthorityTemplateItemResponse
   */
  async getAuthorityTemplateItem(request: GetAuthorityTemplateItemRequest): Promise<GetAuthorityTemplateItemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getAuthorityTemplateItemWithOptions(request, runtime);
  }

  /**
   * @summary 获取实例绑定的分类分级模板
   *
   * @param request GetClassificationTemplateRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetClassificationTemplateResponse
   */
  async getClassificationTemplateWithOptions(request: GetClassificationTemplateRequest, runtime: $Util.RuntimeOptions): Promise<GetClassificationTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetClassificationTemplate",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetClassificationTemplateResponse>(await this.callApi(params, req, runtime), new GetClassificationTemplateResponse({}));
  }

  /**
   * @summary 获取实例绑定的分类分级模板
   *
   * @param request GetClassificationTemplateRequest
   * @return GetClassificationTemplateResponse
   */
  async getClassificationTemplate(request: GetClassificationTemplateRequest): Promise<GetClassificationTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getClassificationTemplateWithOptions(request, runtime);
  }

  /**
   * @summary Queries the log that records the scheduling details of an SQL task.
   *
   * @param request GetDBTaskSQLJobLogRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetDBTaskSQLJobLogResponse
   */
  async getDBTaskSQLJobLogWithOptions(request: GetDBTaskSQLJobLogRequest, runtime: $Util.RuntimeOptions): Promise<GetDBTaskSQLJobLogResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDBTaskSQLJobLog",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDBTaskSQLJobLogResponse>(await this.callApi(params, req, runtime), new GetDBTaskSQLJobLogResponse({}));
  }

  /**
   * @summary Queries the log that records the scheduling details of an SQL task.
   *
   * @param request GetDBTaskSQLJobLogRequest
   * @return GetDBTaskSQLJobLogResponse
   */
  async getDBTaskSQLJobLog(request: GetDBTaskSQLJobLogRequest): Promise<GetDBTaskSQLJobLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDBTaskSQLJobLogWithOptions(request, runtime);
  }

  /**
   * @summary Queries the topologies of a logical database and its physical database shards.
   *
   * @param request GetDBTopologyRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetDBTopologyResponse
   */
  async getDBTopologyWithOptions(request: GetDBTopologyRequest, runtime: $Util.RuntimeOptions): Promise<GetDBTopologyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.logicDbId)) {
      query["LogicDbId"] = request.logicDbId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDBTopology",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDBTopologyResponse>(await this.callApi(params, req, runtime), new GetDBTopologyResponse({}));
  }

  /**
   * @summary Queries the topologies of a logical database and its physical database shards.
   *
   * @param request GetDBTopologyRequest
   * @return GetDBTopologyResponse
   */
  async getDBTopology(request: GetDBTopologyRequest): Promise<GetDBTopologyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDBTopologyWithOptions(request, runtime);
  }

  /**
   * @summary Queries the statistics of data archiving orders, including the number of successful archiving tickets, the number of failed archiving tickets, the number of in-progress archiving tickets, and the total number of archiving tickets.
   *
   * @param request GetDataArchiveCountRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetDataArchiveCountResponse
   */
  async getDataArchiveCountWithOptions(request: GetDataArchiveCountRequest, runtime: $Util.RuntimeOptions): Promise<GetDataArchiveCountResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderResultType)) {
      query["OrderResultType"] = request.orderResultType;
    }

    if (!Util.isUnset(request.pluginType)) {
      query["PluginType"] = request.pluginType;
    }

    if (!Util.isUnset(request.searchDateType)) {
      query["SearchDateType"] = request.searchDateType;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataArchiveCount",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataArchiveCountResponse>(await this.callApi(params, req, runtime), new GetDataArchiveCountResponse({}));
  }

  /**
   * @summary Queries the statistics of data archiving orders, including the number of successful archiving tickets, the number of failed archiving tickets, the number of in-progress archiving tickets, and the total number of archiving tickets.
   *
   * @param request GetDataArchiveCountRequest
   * @return GetDataArchiveCountResponse
   */
  async getDataArchiveCount(request: GetDataArchiveCountRequest): Promise<GetDataArchiveCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataArchiveCountWithOptions(request, runtime);
  }

  /**
   * @summary Queries the details of a data archiving ticket.
   *
   * @param request GetDataArchiveOrderDetailRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetDataArchiveOrderDetailResponse
   */
  async getDataArchiveOrderDetailWithOptions(request: GetDataArchiveOrderDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetDataArchiveOrderDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataArchiveOrderDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataArchiveOrderDetailResponse>(await this.callApi(params, req, runtime), new GetDataArchiveOrderDetailResponse({}));
  }

  /**
   * @summary Queries the details of a data archiving ticket.
   *
   * @param request GetDataArchiveOrderDetailRequest
   * @return GetDataArchiveOrderDetailResponse
   */
  async getDataArchiveOrderDetail(request: GetDataArchiveOrderDetailRequest): Promise<GetDataArchiveOrderDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataArchiveOrderDetailWithOptions(request, runtime);
  }

  /**
   * @summary Queries the download URL of the backup file for a data change ticket in Data Management (DMS).
   *
   * @param tmpReq GetDataCorrectBackupFilesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetDataCorrectBackupFilesResponse
   */
  async getDataCorrectBackupFilesWithOptions(tmpReq: GetDataCorrectBackupFilesRequest, runtime: $Util.RuntimeOptions): Promise<GetDataCorrectBackupFilesResponse> {
    Util.validateModel(tmpReq);
    let request = new GetDataCorrectBackupFilesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.actionDetail)) {
      request.actionDetailShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.actionDetail, "ActionDetail", "json");
    }

    let query = { };
    if (!Util.isUnset(request.actionDetailShrink)) {
      query["ActionDetail"] = request.actionDetailShrink;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataCorrectBackupFiles",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataCorrectBackupFilesResponse>(await this.callApi(params, req, runtime), new GetDataCorrectBackupFilesResponse({}));
  }

  /**
   * @summary Queries the download URL of the backup file for a data change ticket in Data Management (DMS).
   *
   * @param request GetDataCorrectBackupFilesRequest
   * @return GetDataCorrectBackupFilesResponse
   */
  async getDataCorrectBackupFiles(request: GetDataCorrectBackupFilesRequest): Promise<GetDataCorrectBackupFilesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataCorrectBackupFilesWithOptions(request, runtime);
  }

  /**
   * @summary Queries the information about a data change ticket in Data Management (DMS).
   *
   * @param request GetDataCorrectOrderDetailRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetDataCorrectOrderDetailResponse
   */
  async getDataCorrectOrderDetailWithOptions(request: GetDataCorrectOrderDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetDataCorrectOrderDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataCorrectOrderDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataCorrectOrderDetailResponse>(await this.callApi(params, req, runtime), new GetDataCorrectOrderDetailResponse({}));
  }

  /**
   * @summary Queries the information about a data change ticket in Data Management (DMS).
   *
   * @param request GetDataCorrectOrderDetailRequest
   * @return GetDataCorrectOrderDetailResponse
   */
  async getDataCorrectOrderDetail(request: GetDataCorrectOrderDetailRequest): Promise<GetDataCorrectOrderDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataCorrectOrderDetailWithOptions(request, runtime);
  }

  /**
   * @summary Queries the download URL of the rollback attachment submitted along with a data change ticket.
   *
   * @param request GetDataCorrectRollbackFileRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetDataCorrectRollbackFileResponse
   */
  async getDataCorrectRollbackFileWithOptions(request: GetDataCorrectRollbackFileRequest, runtime: $Util.RuntimeOptions): Promise<GetDataCorrectRollbackFileResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataCorrectRollbackFile",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataCorrectRollbackFileResponse>(await this.callApi(params, req, runtime), new GetDataCorrectRollbackFileResponse({}));
  }

  /**
   * @summary Queries the download URL of the rollback attachment submitted along with a data change ticket.
   *
   * @param request GetDataCorrectRollbackFileRequest
   * @return GetDataCorrectRollbackFileResponse
   */
  async getDataCorrectRollbackFile(request: GetDataCorrectRollbackFileRequest): Promise<GetDataCorrectRollbackFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataCorrectRollbackFileWithOptions(request, runtime);
  }

  /**
   * @summary Queries the download URL of the SQL script for a data change task.
   *
   * @description This operation applies to [regular data change](https://help.aliyun.com/document_detail/58419.html) and [batch data import](https://help.aliyun.com/document_detail/144643.html).
   *
   * @param request GetDataCorrectSQLFileRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetDataCorrectSQLFileResponse
   */
  async getDataCorrectSQLFileWithOptions(request: GetDataCorrectSQLFileRequest, runtime: $Util.RuntimeOptions): Promise<GetDataCorrectSQLFileResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataCorrectSQLFile",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataCorrectSQLFileResponse>(await this.callApi(params, req, runtime), new GetDataCorrectSQLFileResponse({}));
  }

  /**
   * @summary Queries the download URL of the SQL script for a data change task.
   *
   * @description This operation applies to [regular data change](https://help.aliyun.com/document_detail/58419.html) and [batch data import](https://help.aliyun.com/document_detail/144643.html).
   *
   * @param request GetDataCorrectSQLFileRequest
   * @return GetDataCorrectSQLFileResponse
   */
  async getDataCorrectSQLFile(request: GetDataCorrectSQLFileRequest): Promise<GetDataCorrectSQLFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataCorrectSQLFileWithOptions(request, runtime);
  }

  /**
   * @summary Queries the information about a data change, lock-free data change, or data import task.
   *
   * @param request GetDataCorrectTaskDetailRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetDataCorrectTaskDetailResponse
   */
  async getDataCorrectTaskDetailWithOptions(request: GetDataCorrectTaskDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetDataCorrectTaskDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataCorrectTaskDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataCorrectTaskDetailResponse>(await this.callApi(params, req, runtime), new GetDataCorrectTaskDetailResponse({}));
  }

  /**
   * @summary Queries the information about a data change, lock-free data change, or data import task.
   *
   * @param request GetDataCorrectTaskDetailRequest
   * @return GetDataCorrectTaskDetailResponse
   */
  async getDataCorrectTaskDetail(request: GetDataCorrectTaskDetailRequest): Promise<GetDataCorrectTaskDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataCorrectTaskDetailWithOptions(request, runtime);
  }

  /**
   * @summary Queries the scheduling configuration of a ticket for cleaning up historical data.
   *
   * @param request GetDataCronClearConfigRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetDataCronClearConfigResponse
   */
  async getDataCronClearConfigWithOptions(request: GetDataCronClearConfigRequest, runtime: $Util.RuntimeOptions): Promise<GetDataCronClearConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataCronClearConfig",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataCronClearConfigResponse>(await this.callApi(params, req, runtime), new GetDataCronClearConfigResponse({}));
  }

  /**
   * @summary Queries the scheduling configuration of a ticket for cleaning up historical data.
   *
   * @param request GetDataCronClearConfigRequest
   * @return GetDataCronClearConfigResponse
   */
  async getDataCronClearConfig(request: GetDataCronClearConfigRequest): Promise<GetDataCronClearConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataCronClearConfigWithOptions(request, runtime);
  }

  /**
   * @summary Queries the details of a historical data cleansing ticket.
   *
   * @param request GetDataCronClearTaskDetailListRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetDataCronClearTaskDetailListResponse
   */
  async getDataCronClearTaskDetailListWithOptions(request: GetDataCronClearTaskDetailListRequest, runtime: $Util.RuntimeOptions): Promise<GetDataCronClearTaskDetailListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataCronClearTaskDetailList",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataCronClearTaskDetailListResponse>(await this.callApi(params, req, runtime), new GetDataCronClearTaskDetailListResponse({}));
  }

  /**
   * @summary Queries the details of a historical data cleansing ticket.
   *
   * @param request GetDataCronClearTaskDetailListRequest
   * @return GetDataCronClearTaskDetailListResponse
   */
  async getDataCronClearTaskDetailList(request: GetDataCronClearTaskDetailListRequest): Promise<GetDataCronClearTaskDetailListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataCronClearTaskDetailListWithOptions(request, runtime);
  }

  /**
   * @summary Queries the download URL of the file that records the export results for a data export ticket in Data Management (DMS).
   *
   * @param request GetDataExportDownloadURLRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetDataExportDownloadURLResponse
   */
  async getDataExportDownloadURLWithOptions(request: GetDataExportDownloadURLRequest, runtime: $Util.RuntimeOptions): Promise<GetDataExportDownloadURLResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataExportDownloadURL",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataExportDownloadURLResponse>(await this.callApi(params, req, runtime), new GetDataExportDownloadURLResponse({}));
  }

  /**
   * @summary Queries the download URL of the file that records the export results for a data export ticket in Data Management (DMS).
   *
   * @param request GetDataExportDownloadURLRequest
   * @return GetDataExportDownloadURLResponse
   */
  async getDataExportDownloadURL(request: GetDataExportDownloadURLRequest): Promise<GetDataExportDownloadURLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataExportDownloadURLWithOptions(request, runtime);
  }

  /**
   * @summary Queries the information about a data export ticket.
   *
   * @param request GetDataExportOrderDetailRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetDataExportOrderDetailResponse
   */
  async getDataExportOrderDetailWithOptions(request: GetDataExportOrderDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetDataExportOrderDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.orderId)) {
      body["OrderId"] = request.orderId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetDataExportOrderDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataExportOrderDetailResponse>(await this.callApi(params, req, runtime), new GetDataExportOrderDetailResponse({}));
  }

  /**
   * @summary Queries the information about a data export ticket.
   *
   * @param request GetDataExportOrderDetailRequest
   * @return GetDataExportOrderDetailResponse
   */
  async getDataExportOrderDetail(request: GetDataExportOrderDetailRequest): Promise<GetDataExportOrderDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataExportOrderDetailWithOptions(request, runtime);
  }

  /**
   * @summary Queries the precheck details of an SQL result set export ticket.
   *
   * @param request GetDataExportPreCheckDetailRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetDataExportPreCheckDetailResponse
   */
  async getDataExportPreCheckDetailWithOptions(request: GetDataExportPreCheckDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetDataExportPreCheckDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataExportPreCheckDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataExportPreCheckDetailResponse>(await this.callApi(params, req, runtime), new GetDataExportPreCheckDetailResponse({}));
  }

  /**
   * @summary Queries the precheck details of an SQL result set export ticket.
   *
   * @param request GetDataExportPreCheckDetailRequest
   * @return GetDataExportPreCheckDetailResponse
   */
  async getDataExportPreCheckDetail(request: GetDataExportPreCheckDetailRequest): Promise<GetDataExportPreCheckDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataExportPreCheckDetailWithOptions(request, runtime);
  }

  /**
   * @summary Queries the SQL statements used for data import in a ticket.
   *
   * @description You can call this operation only if the data is imported in security mode in your data import ticket.
   *
   * @param request GetDataImportSQLRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetDataImportSQLResponse
   */
  async getDataImportSQLWithOptions(request: GetDataImportSQLRequest, runtime: $Util.RuntimeOptions): Promise<GetDataImportSQLResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.sqlId)) {
      query["SqlId"] = request.sqlId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataImportSQL",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataImportSQLResponse>(await this.callApi(params, req, runtime), new GetDataImportSQLResponse({}));
  }

  /**
   * @summary Queries the SQL statements used for data import in a ticket.
   *
   * @description You can call this operation only if the data is imported in security mode in your data import ticket.
   *
   * @param request GetDataImportSQLRequest
   * @return GetDataImportSQLResponse
   */
  async getDataImportSQL(request: GetDataImportSQLRequest): Promise<GetDataImportSQLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataImportSQLWithOptions(request, runtime);
  }

  /**
   * @summary Queries the progress of a data tracking task.
   *
   * @param request GetDataTrackJobDegreeRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetDataTrackJobDegreeResponse
   */
  async getDataTrackJobDegreeWithOptions(request: GetDataTrackJobDegreeRequest, runtime: $Util.RuntimeOptions): Promise<GetDataTrackJobDegreeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataTrackJobDegree",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataTrackJobDegreeResponse>(await this.callApi(params, req, runtime), new GetDataTrackJobDegreeResponse({}));
  }

  /**
   * @summary Queries the progress of a data tracking task.
   *
   * @param request GetDataTrackJobDegreeRequest
   * @return GetDataTrackJobDegreeResponse
   */
  async getDataTrackJobDegree(request: GetDataTrackJobDegreeRequest): Promise<GetDataTrackJobDegreeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataTrackJobDegreeWithOptions(request, runtime);
  }

  /**
   * @summary Queries the metadata of tables involved in a data tracking task.
   *
   * @param request GetDataTrackJobTableMetaRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetDataTrackJobTableMetaResponse
   */
  async getDataTrackJobTableMetaWithOptions(request: GetDataTrackJobTableMetaRequest, runtime: $Util.RuntimeOptions): Promise<GetDataTrackJobTableMetaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataTrackJobTableMeta",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataTrackJobTableMetaResponse>(await this.callApi(params, req, runtime), new GetDataTrackJobTableMetaResponse({}));
  }

  /**
   * @summary Queries the metadata of tables involved in a data tracking task.
   *
   * @param request GetDataTrackJobTableMetaRequest
   * @return GetDataTrackJobTableMetaResponse
   */
  async getDataTrackJobTableMeta(request: GetDataTrackJobTableMetaRequest): Promise<GetDataTrackJobTableMetaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataTrackJobTableMetaWithOptions(request, runtime);
  }

  /**
   * @summary Queries the details of a data tracking ticket.
   *
   * @param request GetDataTrackOrderDetailRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetDataTrackOrderDetailResponse
   */
  async getDataTrackOrderDetailWithOptions(request: GetDataTrackOrderDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetDataTrackOrderDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataTrackOrderDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataTrackOrderDetailResponse>(await this.callApi(params, req, runtime), new GetDataTrackOrderDetailResponse({}));
  }

  /**
   * @summary Queries the details of a data tracking ticket.
   *
   * @param request GetDataTrackOrderDetailRequest
   * @return GetDataTrackOrderDetailResponse
   */
  async getDataTrackOrderDetail(request: GetDataTrackOrderDetailRequest): Promise<GetDataTrackOrderDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataTrackOrderDetailWithOptions(request, runtime);
  }

  /**
   * @summary Queries details of a specific database.
   *
   * @param request GetDatabaseRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetDatabaseResponse
   */
  async getDatabaseWithOptions(request: GetDatabaseRequest, runtime: $Util.RuntimeOptions): Promise<GetDatabaseResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.host)) {
      query["Host"] = request.host;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.schemaName)) {
      query["SchemaName"] = request.schemaName;
    }

    if (!Util.isUnset(request.sid)) {
      query["Sid"] = request.sid;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDatabase",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDatabaseResponse>(await this.callApi(params, req, runtime), new GetDatabaseResponse({}));
  }

  /**
   * @summary Queries details of a specific database.
   *
   * @param request GetDatabaseRequest
   * @return GetDatabaseResponse
   */
  async getDatabase(request: GetDatabaseRequest): Promise<GetDatabaseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDatabaseWithOptions(request, runtime);
  }

  /**
   * @summary Queries the details of a database export ticket.
   *
   * @param request GetDatabaseExportOrderDetailRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetDatabaseExportOrderDetailResponse
   */
  async getDatabaseExportOrderDetailWithOptions(request: GetDatabaseExportOrderDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetDatabaseExportOrderDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.orderId)) {
      body["OrderId"] = request.orderId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetDatabaseExportOrderDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDatabaseExportOrderDetailResponse>(await this.callApi(params, req, runtime), new GetDatabaseExportOrderDetailResponse({}));
  }

  /**
   * @summary Queries the details of a database export ticket.
   *
   * @param request GetDatabaseExportOrderDetailRequest
   * @return GetDatabaseExportOrderDetailResponse
   */
  async getDatabaseExportOrderDetail(request: GetDatabaseExportOrderDetailRequest): Promise<GetDatabaseExportOrderDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDatabaseExportOrderDetailWithOptions(request, runtime);
  }

  /**
   * @summary 获取数据库导出下载地址
   *
   * @param request GetDbExportDownloadURLRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetDbExportDownloadURLResponse
   */
  async getDbExportDownloadURLWithOptions(request: GetDbExportDownloadURLRequest, runtime: $Util.RuntimeOptions): Promise<GetDbExportDownloadURLResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDbExportDownloadURL",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDbExportDownloadURLResponse>(await this.callApi(params, req, runtime), new GetDbExportDownloadURLResponse({}));
  }

  /**
   * @summary 获取数据库导出下载地址
   *
   * @param request GetDbExportDownloadURLRequest
   * @return GetDbExportDownloadURLResponse
   */
  async getDbExportDownloadURL(request: GetDbExportDownloadURLRequest): Promise<GetDbExportDownloadURLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDbExportDownloadURLWithOptions(request, runtime);
  }

  /**
   * @summary Queries the details of a database instance.
   *
   * @param request GetInstanceRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetInstanceResponse
   */
  async getInstanceWithOptions(request: GetInstanceRequest, runtime: $Util.RuntimeOptions): Promise<GetInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.host)) {
      query["Host"] = request.host;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.sid)) {
      query["Sid"] = request.sid;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetInstance",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetInstanceResponse>(await this.callApi(params, req, runtime), new GetInstanceResponse({}));
  }

  /**
   * @summary Queries the details of a database instance.
   *
   * @param request GetInstanceRequest
   * @return GetInstanceResponse
   */
  async getInstance(request: GetInstanceRequest): Promise<GetInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getInstanceWithOptions(request, runtime);
  }

  /**
   * @summary Queries the minimum scheduling cycle of a task flow when a service level agreement (SLA) timeout rule is configured for the task flow.
   *
   * @description The scheduling cycle of a task flow must be greater than the minimum scheduling cycle configured in the SLA rule for the task flow.
   *
   * @param request GetIntervalLimitOfSLARequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetIntervalLimitOfSLAResponse
   */
  async getIntervalLimitOfSLAWithOptions(request: GetIntervalLimitOfSLARequest, runtime: $Util.RuntimeOptions): Promise<GetIntervalLimitOfSLAResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetIntervalLimitOfSLA",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetIntervalLimitOfSLAResponse>(await this.callApi(params, req, runtime), new GetIntervalLimitOfSLAResponse({}));
  }

  /**
   * @summary Queries the minimum scheduling cycle of a task flow when a service level agreement (SLA) timeout rule is configured for the task flow.
   *
   * @description The scheduling cycle of a task flow must be greater than the minimum scheduling cycle configured in the SLA rule for the task flow.
   *
   * @param request GetIntervalLimitOfSLARequest
   * @return GetIntervalLimitOfSLAResponse
   */
  async getIntervalLimitOfSLA(request: GetIntervalLimitOfSLARequest): Promise<GetIntervalLimitOfSLAResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getIntervalLimitOfSLAWithOptions(request, runtime);
  }

  /**
   * @summary Queries the information about a workspace based on the workspace name in Data Management (DMS).
   *
   * @description You are a DMS administrator or a database administrator (DBA).
   *
   * @param request GetLhSpaceByNameRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetLhSpaceByNameResponse
   */
  async getLhSpaceByNameWithOptions(request: GetLhSpaceByNameRequest, runtime: $Util.RuntimeOptions): Promise<GetLhSpaceByNameResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.spaceName)) {
      query["SpaceName"] = request.spaceName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetLhSpaceByName",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetLhSpaceByNameResponse>(await this.callApi(params, req, runtime), new GetLhSpaceByNameResponse({}));
  }

  /**
   * @summary Queries the information about a workspace based on the workspace name in Data Management (DMS).
   *
   * @description You are a DMS administrator or a database administrator (DBA).
   *
   * @param request GetLhSpaceByNameRequest
   * @return GetLhSpaceByNameResponse
   */
  async getLhSpaceByName(request: GetLhSpaceByNameRequest): Promise<GetLhSpaceByNameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getLhSpaceByNameWithOptions(request, runtime);
  }

  /**
   * @summary Queries the details of a logical database.
   *
   * @param request GetLogicDatabaseRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetLogicDatabaseResponse
   */
  async getLogicDatabaseWithOptions(request: GetLogicDatabaseRequest, runtime: $Util.RuntimeOptions): Promise<GetLogicDatabaseResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetLogicDatabase",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetLogicDatabaseResponse>(await this.callApi(params, req, runtime), new GetLogicDatabaseResponse({}));
  }

  /**
   * @summary Queries the details of a logical database.
   *
   * @param request GetLogicDatabaseRequest
   * @return GetLogicDatabaseResponse
   */
  async getLogicDatabase(request: GetLogicDatabaseRequest): Promise<GetLogicDatabaseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getLogicDatabaseWithOptions(request, runtime);
  }

  /**
   * @summary Queries the details of columns in a table.
   *
   * @description You can call this operation only for database instances whose control mode is Security Collaboration.
   *
   * @param request GetMetaTableColumnRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetMetaTableColumnResponse
   */
  async getMetaTableColumnWithOptions(request: GetMetaTableColumnRequest, runtime: $Util.RuntimeOptions): Promise<GetMetaTableColumnResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tableGuid)) {
      query["TableGuid"] = request.tableGuid;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMetaTableColumn",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMetaTableColumnResponse>(await this.callApi(params, req, runtime), new GetMetaTableColumnResponse({}));
  }

  /**
   * @summary Queries the details of columns in a table.
   *
   * @description You can call this operation only for database instances whose control mode is Security Collaboration.
   *
   * @param request GetMetaTableColumnRequest
   * @return GetMetaTableColumnResponse
   */
  async getMetaTableColumn(request: GetMetaTableColumnRequest): Promise<GetMetaTableColumnResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMetaTableColumnWithOptions(request, runtime);
  }

  /**
   * @summary Queries the details of columns and indexes in a table.
   *
   * @description You can call this operation only for database instances whose control mode is Security Collaboration.
   *
   * @param request GetMetaTableDetailInfoRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetMetaTableDetailInfoResponse
   */
  async getMetaTableDetailInfoWithOptions(request: GetMetaTableDetailInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetMetaTableDetailInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tableGuid)) {
      query["TableGuid"] = request.tableGuid;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMetaTableDetailInfo",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMetaTableDetailInfoResponse>(await this.callApi(params, req, runtime), new GetMetaTableDetailInfoResponse({}));
  }

  /**
   * @summary Queries the details of columns and indexes in a table.
   *
   * @description You can call this operation only for database instances whose control mode is Security Collaboration.
   *
   * @param request GetMetaTableDetailInfoRequest
   * @return GetMetaTableDetailInfoResponse
   */
  async getMetaTableDetailInfo(request: GetMetaTableDetailInfoRequest): Promise<GetMetaTableDetailInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMetaTableDetailInfoWithOptions(request, runtime);
  }

  /**
   * @summary Queries the details and progress of an OnlineDDL task.
   *
   * @param request GetOnlineDDLProgressRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetOnlineDDLProgressResponse
   */
  async getOnlineDDLProgressWithOptions(request: GetOnlineDDLProgressRequest, runtime: $Util.RuntimeOptions): Promise<GetOnlineDDLProgressResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.jobDetailId)) {
      query["JobDetailId"] = request.jobDetailId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetOnlineDDLProgress",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOnlineDDLProgressResponse>(await this.callApi(params, req, runtime), new GetOnlineDDLProgressResponse({}));
  }

  /**
   * @summary Queries the details and progress of an OnlineDDL task.
   *
   * @param request GetOnlineDDLProgressRequest
   * @return GetOnlineDDLProgressResponse
   */
  async getOnlineDDLProgress(request: GetOnlineDDLProgressRequest): Promise<GetOnlineDDLProgressResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getOnlineDDLProgressWithOptions(request, runtime);
  }

  /**
   * @summary Queries the details of operation logs that are generated in a specified period of time.
   *
   * @description Prerequisites: You are an administrator of Data Management (DMS) or a security administrator. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to obtain your user role from the RoleIdList parameter that is returned.
   *
   * @param request GetOpLogRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetOpLogResponse
   */
  async getOpLogWithOptions(request: GetOpLogRequest, runtime: $Util.RuntimeOptions): Promise<GetOpLogResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.databaseName)) {
      query["DatabaseName"] = request.databaseName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.module)) {
      query["Module"] = request.module;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.userNick)) {
      query["UserNick"] = request.userNick;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetOpLog",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOpLogResponse>(await this.callApi(params, req, runtime), new GetOpLogResponse({}));
  }

  /**
   * @summary Queries the details of operation logs that are generated in a specified period of time.
   *
   * @description Prerequisites: You are an administrator of Data Management (DMS) or a security administrator. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to obtain your user role from the RoleIdList parameter that is returned.
   *
   * @param request GetOpLogRequest
   * @return GetOpLogResponse
   */
  async getOpLog(request: GetOpLogRequest): Promise<GetOpLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getOpLogWithOptions(request, runtime);
  }

  /**
   * @summary Queries the download URL of the attachment of a ticket.
   *
   * @param request GetOrderAttachmentFileRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetOrderAttachmentFileResponse
   */
  async getOrderAttachmentFileWithOptions(request: GetOrderAttachmentFileRequest, runtime: $Util.RuntimeOptions): Promise<GetOrderAttachmentFileResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetOrderAttachmentFile",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOrderAttachmentFileResponse>(await this.callApi(params, req, runtime), new GetOrderAttachmentFileResponse({}));
  }

  /**
   * @summary Queries the download URL of the attachment of a ticket.
   *
   * @param request GetOrderAttachmentFileRequest
   * @return GetOrderAttachmentFileResponse
   */
  async getOrderAttachmentFile(request: GetOrderAttachmentFileRequest): Promise<GetOrderAttachmentFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getOrderAttachmentFileWithOptions(request, runtime);
  }

  /**
   * @summary Queries the basic information about a ticket.
   *
   * @param request GetOrderBaseInfoRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetOrderBaseInfoResponse
   */
  async getOrderBaseInfoWithOptions(request: GetOrderBaseInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetOrderBaseInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetOrderBaseInfo",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOrderBaseInfoResponse>(await this.callApi(params, req, runtime), new GetOrderBaseInfoResponse({}));
  }

  /**
   * @summary Queries the basic information about a ticket.
   *
   * @param request GetOrderBaseInfoRequest
   * @return GetOrderBaseInfoResponse
   */
  async getOrderBaseInfo(request: GetOrderBaseInfoRequest): Promise<GetOrderBaseInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getOrderBaseInfoWithOptions(request, runtime);
  }

  /**
   * @summary Queries the details of the Database-OWNER, Table-OWNER, and Instance-OWNER tickets.
   *
   * @param request GetOwnerApplyOrderDetailRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetOwnerApplyOrderDetailResponse
   */
  async getOwnerApplyOrderDetailWithOptions(request: GetOwnerApplyOrderDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetOwnerApplyOrderDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetOwnerApplyOrderDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOwnerApplyOrderDetailResponse>(await this.callApi(params, req, runtime), new GetOwnerApplyOrderDetailResponse({}));
  }

  /**
   * @summary Queries the details of the Database-OWNER, Table-OWNER, and Instance-OWNER tickets.
   *
   * @param request GetOwnerApplyOrderDetailRequest
   * @return GetOwnerApplyOrderDetailResponse
   */
  async getOwnerApplyOrderDetail(request: GetOwnerApplyOrderDetailRequest): Promise<GetOwnerApplyOrderDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getOwnerApplyOrderDetailWithOptions(request, runtime);
  }

  /**
   * @summary 获取数据归档工单任务实例
   *
   * @param request GetPagedInstanceRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetPagedInstanceResponse
   */
  async getPagedInstanceWithOptions(request: GetPagedInstanceRequest, runtime: $Util.RuntimeOptions): Promise<GetPagedInstanceResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetPagedInstance",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetPagedInstanceResponse>(await this.callApi(params, req, runtime), new GetPagedInstanceResponse({}));
  }

  /**
   * @summary 获取数据归档工单任务实例
   *
   * @param request GetPagedInstanceRequest
   * @return GetPagedInstanceResponse
   */
  async getPagedInstance(request: GetPagedInstanceRequest): Promise<GetPagedInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getPagedInstanceWithOptions(request, runtime);
  }

  /**
   * @summary Queries the details of a ticket that applies for permissions.
   *
   * @description You can call this operation to query the information about tickets that apply for permissions on databases, tables, and sensitive columns.
   *
   * @param request GetPermApplyOrderDetailRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetPermApplyOrderDetailResponse
   */
  async getPermApplyOrderDetailWithOptions(request: GetPermApplyOrderDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetPermApplyOrderDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetPermApplyOrderDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetPermApplyOrderDetailResponse>(await this.callApi(params, req, runtime), new GetPermApplyOrderDetailResponse({}));
  }

  /**
   * @summary Queries the details of a ticket that applies for permissions.
   *
   * @description You can call this operation to query the information about tickets that apply for permissions on databases, tables, and sensitive columns.
   *
   * @param request GetPermApplyOrderDetailRequest
   * @return GetPermApplyOrderDetailResponse
   */
  async getPermApplyOrderDetail(request: GetPermApplyOrderDetailRequest): Promise<GetPermApplyOrderDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getPermApplyOrderDetailWithOptions(request, runtime);
  }

  /**
   * @summary Queries the details of a physical database.
   *
   * @param request GetPhysicalDatabaseRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetPhysicalDatabaseResponse
   */
  async getPhysicalDatabaseWithOptions(request: GetPhysicalDatabaseRequest, runtime: $Util.RuntimeOptions): Promise<GetPhysicalDatabaseResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetPhysicalDatabase",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetPhysicalDatabaseResponse>(await this.callApi(params, req, runtime), new GetPhysicalDatabaseResponse({}));
  }

  /**
   * @summary Queries the details of a physical database.
   *
   * @param request GetPhysicalDatabaseRequest
   * @return GetPhysicalDatabaseResponse
   */
  async getPhysicalDatabase(request: GetPhysicalDatabaseRequest): Promise<GetPhysicalDatabaseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getPhysicalDatabaseWithOptions(request, runtime);
  }

  /**
   * @summary Queries the details of a secure access proxy.
   *
   * @param request GetProxyRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetProxyResponse
   */
  async getProxyWithOptions(request: GetProxyRequest, runtime: $Util.RuntimeOptions): Promise<GetProxyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.proxyId)) {
      query["ProxyId"] = request.proxyId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetProxy",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetProxyResponse>(await this.callApi(params, req, runtime), new GetProxyResponse({}));
  }

  /**
   * @summary Queries the details of a secure access proxy.
   *
   * @param request GetProxyRequest
   * @return GetProxyResponse
   */
  async getProxy(request: GetProxyRequest): Promise<GetProxyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getProxyWithOptions(request, runtime);
  }

  /**
   * @summary Queries the authorization information about the secure access proxy feature.
   *
   * @param request GetProxyAccessRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetProxyAccessResponse
   */
  async getProxyAccessWithOptions(request: GetProxyAccessRequest, runtime: $Util.RuntimeOptions): Promise<GetProxyAccessResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.proxyAccessId)) {
      query["ProxyAccessId"] = request.proxyAccessId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetProxyAccess",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetProxyAccessResponse>(await this.callApi(params, req, runtime), new GetProxyAccessResponse({}));
  }

  /**
   * @summary Queries the authorization information about the secure access proxy feature.
   *
   * @param request GetProxyAccessRequest
   * @return GetProxyAccessResponse
   */
  async getProxyAccess(request: GetProxyAccessRequest): Promise<GetProxyAccessResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getProxyAccessWithOptions(request, runtime);
  }

  /**
   * @summary Queries the maximum number of custom service-level agreement (SLA) rules for task orchestration.
   *
   * @param request GetRuleNumLimitOfSLARequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetRuleNumLimitOfSLAResponse
   */
  async getRuleNumLimitOfSLAWithOptions(request: GetRuleNumLimitOfSLARequest, runtime: $Util.RuntimeOptions): Promise<GetRuleNumLimitOfSLAResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetRuleNumLimitOfSLA",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetRuleNumLimitOfSLAResponse>(await this.callApi(params, req, runtime), new GetRuleNumLimitOfSLAResponse({}));
  }

  /**
   * @summary Queries the maximum number of custom service-level agreement (SLA) rules for task orchestration.
   *
   * @param request GetRuleNumLimitOfSLARequest
   * @return GetRuleNumLimitOfSLAResponse
   */
  async getRuleNumLimitOfSLA(request: GetRuleNumLimitOfSLARequest): Promise<GetRuleNumLimitOfSLAResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getRuleNumLimitOfSLAWithOptions(request, runtime);
  }

  /**
   * @summary Queries the result of an SQL review.
   *
   * @description For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
   *
   * @param request GetSQLReviewCheckResultStatusRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetSQLReviewCheckResultStatusResponse
   */
  async getSQLReviewCheckResultStatusWithOptions(request: GetSQLReviewCheckResultStatusRequest, runtime: $Util.RuntimeOptions): Promise<GetSQLReviewCheckResultStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetSQLReviewCheckResultStatus",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetSQLReviewCheckResultStatusResponse>(await this.callApi(params, req, runtime), new GetSQLReviewCheckResultStatusResponse({}));
  }

  /**
   * @summary Queries the result of an SQL review.
   *
   * @description For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
   *
   * @param request GetSQLReviewCheckResultStatusRequest
   * @return GetSQLReviewCheckResultStatusResponse
   */
  async getSQLReviewCheckResultStatus(request: GetSQLReviewCheckResultStatusRequest): Promise<GetSQLReviewCheckResultStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSQLReviewCheckResultStatusWithOptions(request, runtime);
  }

  /**
   * @summary Queries the details of optimization suggestions. The operation applies only to the tickets for the data changes and SQL review.
   *
   * @description For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
   *
   * @param request GetSQLReviewOptimizeDetailRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetSQLReviewOptimizeDetailResponse
   */
  async getSQLReviewOptimizeDetailWithOptions(request: GetSQLReviewOptimizeDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetSQLReviewOptimizeDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.SQLReviewQueryKey)) {
      query["SQLReviewQueryKey"] = request.SQLReviewQueryKey;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetSQLReviewOptimizeDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetSQLReviewOptimizeDetailResponse>(await this.callApi(params, req, runtime), new GetSQLReviewOptimizeDetailResponse({}));
  }

  /**
   * @summary Queries the details of optimization suggestions. The operation applies only to the tickets for the data changes and SQL review.
   *
   * @description For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
   *
   * @param request GetSQLReviewOptimizeDetailRequest
   * @return GetSQLReviewOptimizeDetailResponse
   */
  async getSQLReviewOptimizeDetail(request: GetSQLReviewOptimizeDetailRequest): Promise<GetSQLReviewOptimizeDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSQLReviewOptimizeDetailWithOptions(request, runtime);
  }

  /**
   * @summary 获取安全规则
   *
   * @param request GetStandardGroupRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetStandardGroupResponse
   */
  async getStandardGroupWithOptions(request: GetStandardGroupRequest, runtime: $Util.RuntimeOptions): Promise<GetStandardGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetStandardGroup",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetStandardGroupResponse>(await this.callApi(params, req, runtime), new GetStandardGroupResponse({}));
  }

  /**
   * @summary 获取安全规则
   *
   * @param request GetStandardGroupRequest
   * @return GetStandardGroupResponse
   */
  async getStandardGroup(request: GetStandardGroupRequest): Promise<GetStandardGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getStandardGroupWithOptions(request, runtime);
  }

  /**
   * @summary Queries the SQL statements that are involved in a schema synchronization ticket.
   *
   * @param request GetStructSyncExecSqlDetailRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetStructSyncExecSqlDetailResponse
   */
  async getStructSyncExecSqlDetailWithOptions(request: GetStructSyncExecSqlDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetStructSyncExecSqlDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetStructSyncExecSqlDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetStructSyncExecSqlDetailResponse>(await this.callApi(params, req, runtime), new GetStructSyncExecSqlDetailResponse({}));
  }

  /**
   * @summary Queries the SQL statements that are involved in a schema synchronization ticket.
   *
   * @param request GetStructSyncExecSqlDetailRequest
   * @return GetStructSyncExecSqlDetailResponse
   */
  async getStructSyncExecSqlDetail(request: GetStructSyncExecSqlDetailRequest): Promise<GetStructSyncExecSqlDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getStructSyncExecSqlDetailWithOptions(request, runtime);
  }

  /**
   * @summary Queries the analysis result of a schema synchronization task.
   *
   * @param request GetStructSyncJobAnalyzeResultRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetStructSyncJobAnalyzeResultResponse
   */
  async getStructSyncJobAnalyzeResultWithOptions(request: GetStructSyncJobAnalyzeResultRequest, runtime: $Util.RuntimeOptions): Promise<GetStructSyncJobAnalyzeResultResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.compareType)) {
      query["CompareType"] = request.compareType;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetStructSyncJobAnalyzeResult",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetStructSyncJobAnalyzeResultResponse>(await this.callApi(params, req, runtime), new GetStructSyncJobAnalyzeResultResponse({}));
  }

  /**
   * @summary Queries the analysis result of a schema synchronization task.
   *
   * @param request GetStructSyncJobAnalyzeResultRequest
   * @return GetStructSyncJobAnalyzeResultResponse
   */
  async getStructSyncJobAnalyzeResult(request: GetStructSyncJobAnalyzeResultRequest): Promise<GetStructSyncJobAnalyzeResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getStructSyncJobAnalyzeResultWithOptions(request, runtime);
  }

  /**
   * @summary Queries the information of a schema synchronization task.
   *
   * @param request GetStructSyncJobDetailRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetStructSyncJobDetailResponse
   */
  async getStructSyncJobDetailWithOptions(request: GetStructSyncJobDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetStructSyncJobDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetStructSyncJobDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetStructSyncJobDetailResponse>(await this.callApi(params, req, runtime), new GetStructSyncJobDetailResponse({}));
  }

  /**
   * @summary Queries the information of a schema synchronization task.
   *
   * @param request GetStructSyncJobDetailRequest
   * @return GetStructSyncJobDetailResponse
   */
  async getStructSyncJobDetail(request: GetStructSyncJobDetailRequest): Promise<GetStructSyncJobDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getStructSyncJobDetailWithOptions(request, runtime);
  }

  /**
   * @summary Queries the details of a schema synchronization ticket.
   *
   * @param request GetStructSyncOrderDetailRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetStructSyncOrderDetailResponse
   */
  async getStructSyncOrderDetailWithOptions(request: GetStructSyncOrderDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetStructSyncOrderDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetStructSyncOrderDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetStructSyncOrderDetailResponse>(await this.callApi(params, req, runtime), new GetStructSyncOrderDetailResponse({}));
  }

  /**
   * @summary Queries the details of a schema synchronization ticket.
   *
   * @param request GetStructSyncOrderDetailRequest
   * @return GetStructSyncOrderDetailResponse
   */
  async getStructSyncOrderDetail(request: GetStructSyncOrderDetailRequest): Promise<GetStructSyncOrderDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getStructSyncOrderDetailWithOptions(request, runtime);
  }

  /**
   * @summary Queries the topology of a data table.
   *
   * @param request GetTableDBTopologyRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetTableDBTopologyResponse
   */
  async getTableDBTopologyWithOptions(request: GetTableDBTopologyRequest, runtime: $Util.RuntimeOptions): Promise<GetTableDBTopologyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tableGuid)) {
      query["TableGuid"] = request.tableGuid;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetTableDBTopology",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetTableDBTopologyResponse>(await this.callApi(params, req, runtime), new GetTableDBTopologyResponse({}));
  }

  /**
   * @summary Queries the topology of a data table.
   *
   * @param request GetTableDBTopologyRequest
   * @return GetTableDBTopologyResponse
   */
  async getTableDBTopology(request: GetTableDBTopologyRequest): Promise<GetTableDBTopologyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getTableDBTopologyWithOptions(request, runtime);
  }

  /**
   * @summary 获取结构设计项目的流程信息
   *
   * @param request GetTableDesignProjectFlowRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetTableDesignProjectFlowResponse
   */
  async getTableDesignProjectFlowWithOptions(request: GetTableDesignProjectFlowRequest, runtime: $Util.RuntimeOptions): Promise<GetTableDesignProjectFlowResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetTableDesignProjectFlow",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetTableDesignProjectFlowResponse>(await this.callApi(params, req, runtime), new GetTableDesignProjectFlowResponse({}));
  }

  /**
   * @summary 获取结构设计项目的流程信息
   *
   * @param request GetTableDesignProjectFlowRequest
   * @return GetTableDesignProjectFlowResponse
   */
  async getTableDesignProjectFlow(request: GetTableDesignProjectFlowRequest): Promise<GetTableDesignProjectFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getTableDesignProjectFlowWithOptions(request, runtime);
  }

  /**
   * @summary 获取结构设计项目的详细信息
   *
   * @param request GetTableDesignProjectInfoRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetTableDesignProjectInfoResponse
   */
  async getTableDesignProjectInfoWithOptions(request: GetTableDesignProjectInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetTableDesignProjectInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetTableDesignProjectInfo",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetTableDesignProjectInfoResponse>(await this.callApi(params, req, runtime), new GetTableDesignProjectInfoResponse({}));
  }

  /**
   * @summary 获取结构设计项目的详细信息
   *
   * @param request GetTableDesignProjectInfoRequest
   * @return GetTableDesignProjectInfoResponse
   */
  async getTableDesignProjectInfo(request: GetTableDesignProjectInfoRequest): Promise<GetTableDesignProjectInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getTableDesignProjectInfoWithOptions(request, runtime);
  }

  /**
   * @summary Queries the topology of a table.
   *
   * @param request GetTableTopologyRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetTableTopologyResponse
   */
  async getTableTopologyWithOptions(request: GetTableTopologyRequest, runtime: $Util.RuntimeOptions): Promise<GetTableTopologyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tableGuid)) {
      query["TableGuid"] = request.tableGuid;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetTableTopology",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetTableTopologyResponse>(await this.callApi(params, req, runtime), new GetTableTopologyResponse({}));
  }

  /**
   * @summary Queries the topology of a table.
   *
   * @param request GetTableTopologyRequest
   * @return GetTableTopologyResponse
   */
  async getTableTopology(request: GetTableTopologyRequest): Promise<GetTableTopologyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getTableTopologyWithOptions(request, runtime);
  }

  /**
   * @summary Queries the configurations, including time variables, of a specified task node based on the task node ID.
   *
   * @param request GetTaskRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetTaskResponse
   */
  async getTaskWithOptions(request: GetTaskRequest, runtime: $Util.RuntimeOptions): Promise<GetTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.nodeId)) {
      query["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetTask",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetTaskResponse>(await this.callApi(params, req, runtime), new GetTaskResponse({}));
  }

  /**
   * @summary Queries the configurations, including time variables, of a specified task node based on the task node ID.
   *
   * @param request GetTaskRequest
   * @return GetTaskResponse
   */
  async getTask(request: GetTaskRequest): Promise<GetTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getTaskWithOptions(request, runtime);
  }

  /**
   * @summary Queries the Directed Acyclic Graph (DAG) of a task flow.
   *
   * @param request GetTaskFlowGraphRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetTaskFlowGraphResponse
   */
  async getTaskFlowGraphWithOptions(request: GetTaskFlowGraphRequest, runtime: $Util.RuntimeOptions): Promise<GetTaskFlowGraphResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetTaskFlowGraph",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetTaskFlowGraphResponse>(await this.callApi(params, req, runtime), new GetTaskFlowGraphResponse({}));
  }

  /**
   * @summary Queries the Directed Acyclic Graph (DAG) of a task flow.
   *
   * @param request GetTaskFlowGraphRequest
   * @return GetTaskFlowGraphResponse
   */
  async getTaskFlowGraph(request: GetTaskFlowGraphRequest): Promise<GetTaskFlowGraphResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getTaskFlowGraphWithOptions(request, runtime);
  }

  /**
   * @summary Queries the notification settings for task flows.
   *
   * @param request GetTaskFlowNotificationRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetTaskFlowNotificationResponse
   */
  async getTaskFlowNotificationWithOptions(request: GetTaskFlowNotificationRequest, runtime: $Util.RuntimeOptions): Promise<GetTaskFlowNotificationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetTaskFlowNotification",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetTaskFlowNotificationResponse>(await this.callApi(params, req, runtime), new GetTaskFlowNotificationResponse({}));
  }

  /**
   * @summary Queries the notification settings for task flows.
   *
   * @param request GetTaskFlowNotificationRequest
   * @return GetTaskFlowNotificationResponse
   */
  async getTaskFlowNotification(request: GetTaskFlowNotificationRequest): Promise<GetTaskFlowNotificationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getTaskFlowNotificationWithOptions(request, runtime);
  }

  /**
   * @summary Queries the information about the nodes in an execution record of a task flow.
   *
   * @param request GetTaskInstanceRelationRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetTaskInstanceRelationResponse
   */
  async getTaskInstanceRelationWithOptions(request: GetTaskInstanceRelationRequest, runtime: $Util.RuntimeOptions): Promise<GetTaskInstanceRelationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.dagInstanceId)) {
      query["DagInstanceId"] = request.dagInstanceId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetTaskInstanceRelation",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetTaskInstanceRelationResponse>(await this.callApi(params, req, runtime), new GetTaskInstanceRelationResponse({}));
  }

  /**
   * @summary Queries the information about the nodes in an execution record of a task flow.
   *
   * @param request GetTaskInstanceRelationRequest
   * @return GetTaskInstanceRelationResponse
   */
  async getTaskInstanceRelation(request: GetTaskInstanceRelationRequest): Promise<GetTaskInstanceRelationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getTaskInstanceRelationWithOptions(request, runtime);
  }

  /**
   * @summary Queries the information about a user.
   *
   * @param request GetUserRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetUserResponse
   */
  async getUserWithOptions(request: GetUserRequest, runtime: $Util.RuntimeOptions): Promise<GetUserResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.uid)) {
      query["Uid"] = request.uid;
    }

    if (!Util.isUnset(request.userId)) {
      query["UserId"] = request.userId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetUser",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetUserResponse>(await this.callApi(params, req, runtime), new GetUserResponse({}));
  }

  /**
   * @summary Queries the information about a user.
   *
   * @param request GetUserRequest
   * @return GetUserResponse
   */
  async getUser(request: GetUserRequest): Promise<GetUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getUserWithOptions(request, runtime);
  }

  /**
   * @summary Queries details of the active tenant.
   *
   * @param request GetUserActiveTenantRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetUserActiveTenantResponse
   */
  async getUserActiveTenantWithOptions(request: GetUserActiveTenantRequest, runtime: $Util.RuntimeOptions): Promise<GetUserActiveTenantResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetUserActiveTenant",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetUserActiveTenantResponse>(await this.callApi(params, req, runtime), new GetUserActiveTenantResponse({}));
  }

  /**
   * @summary Queries details of the active tenant.
   *
   * @param request GetUserActiveTenantRequest
   * @return GetUserActiveTenantResponse
   */
  async getUserActiveTenant(request: GetUserActiveTenantRequest): Promise<GetUserActiveTenantResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getUserActiveTenantWithOptions(request, runtime);
  }

  /**
   * @summary Obtains the information of a file upload task.
   *
   * @param request GetUserUploadFileJobRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetUserUploadFileJobResponse
   */
  async getUserUploadFileJobWithOptions(request: GetUserUploadFileJobRequest, runtime: $Util.RuntimeOptions): Promise<GetUserUploadFileJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.jobKey)) {
      query["JobKey"] = request.jobKey;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetUserUploadFileJob",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetUserUploadFileJobResponse>(await this.callApi(params, req, runtime), new GetUserUploadFileJobResponse({}));
  }

  /**
   * @summary Obtains the information of a file upload task.
   *
   * @param request GetUserUploadFileJobRequest
   * @return GetUserUploadFileJobResponse
   */
  async getUserUploadFileJob(request: GetUserUploadFileJobRequest): Promise<GetUserUploadFileJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getUserUploadFileJobWithOptions(request, runtime);
  }

  /**
   * @summary Grants permissions on resources to users by using a permission template.
   *
   * @description You must be a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
   *
   * @param request GrantTemplateAuthorityRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GrantTemplateAuthorityResponse
   */
  async grantTemplateAuthorityWithOptions(request: GrantTemplateAuthorityRequest, runtime: $Util.RuntimeOptions): Promise<GrantTemplateAuthorityResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.expireDate)) {
      query["ExpireDate"] = request.expireDate;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.userIds)) {
      query["UserIds"] = request.userIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GrantTemplateAuthority",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GrantTemplateAuthorityResponse>(await this.callApi(params, req, runtime), new GrantTemplateAuthorityResponse({}));
  }

  /**
   * @summary Grants permissions on resources to users by using a permission template.
   *
   * @description You must be a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
   *
   * @param request GrantTemplateAuthorityRequest
   * @return GrantTemplateAuthorityResponse
   */
  async grantTemplateAuthority(request: GrantTemplateAuthorityRequest): Promise<GrantTemplateAuthorityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.grantTemplateAuthorityWithOptions(request, runtime);
  }

  /**
   * @summary Grants permissions on an instance, a database, or a table to a user.
   *
   * @param request GrantUserPermissionRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GrantUserPermissionResponse
   */
  async grantUserPermissionWithOptions(request: GrantUserPermissionRequest, runtime: $Util.RuntimeOptions): Promise<GrantUserPermissionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.dsType)) {
      query["DsType"] = request.dsType;
    }

    if (!Util.isUnset(request.expireDate)) {
      query["ExpireDate"] = request.expireDate;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.logic)) {
      query["Logic"] = request.logic;
    }

    if (!Util.isUnset(request.permTypes)) {
      query["PermTypes"] = request.permTypes;
    }

    if (!Util.isUnset(request.tableId)) {
      query["TableId"] = request.tableId;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.userId)) {
      query["UserId"] = request.userId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GrantUserPermission",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GrantUserPermissionResponse>(await this.callApi(params, req, runtime), new GrantUserPermissionResponse({}));
  }

  /**
   * @summary Grants permissions on an instance, a database, or a table to a user.
   *
   * @param request GrantUserPermissionRequest
   * @return GrantUserPermissionResponse
   */
  async grantUserPermission(request: GrantUserPermissionRequest): Promise<GrantUserPermissionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.grantUserPermissionWithOptions(request, runtime);
  }

  /**
   * @summary You can call this operation to obtain the authorization password of the security protection agent InspectProxyAccessSecret.
   *
   * @param request InspectProxyAccessSecretRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return InspectProxyAccessSecretResponse
   */
  async inspectProxyAccessSecretWithOptions(request: InspectProxyAccessSecretRequest, runtime: $Util.RuntimeOptions): Promise<InspectProxyAccessSecretResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.proxyAccessId)) {
      query["ProxyAccessId"] = request.proxyAccessId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "InspectProxyAccessSecret",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<InspectProxyAccessSecretResponse>(await this.callApi(params, req, runtime), new InspectProxyAccessSecretResponse({}));
  }

  /**
   * @summary You can call this operation to obtain the authorization password of the security protection agent InspectProxyAccessSecret.
   *
   * @param request InspectProxyAccessSecretRequest
   * @return InspectProxyAccessSecretResponse
   */
  async inspectProxyAccessSecret(request: InspectProxyAccessSecretRequest): Promise<InspectProxyAccessSecretResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.inspectProxyAccessSecretWithOptions(request, runtime);
  }

  /**
   * @summary 获取权限模版列表
   *
   * @param request ListAuthorityTemplateRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListAuthorityTemplateResponse
   */
  async listAuthorityTemplateWithOptions(request: ListAuthorityTemplateRequest, runtime: $Util.RuntimeOptions): Promise<ListAuthorityTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchKey)) {
      query["SearchKey"] = request.searchKey;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListAuthorityTemplate",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListAuthorityTemplateResponse>(await this.callApi(params, req, runtime), new ListAuthorityTemplateResponse({}));
  }

  /**
   * @summary 获取权限模版列表
   *
   * @param request ListAuthorityTemplateRequest
   * @return ListAuthorityTemplateResponse
   */
  async listAuthorityTemplate(request: ListAuthorityTemplateRequest): Promise<ListAuthorityTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAuthorityTemplateWithOptions(request, runtime);
  }

  /**
   * @summary Queries the classification templates.
   *
   * @param request ListClassificationTemplatesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListClassificationTemplatesResponse
   */
  async listClassificationTemplatesWithOptions(request: ListClassificationTemplatesRequest, runtime: $Util.RuntimeOptions): Promise<ListClassificationTemplatesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListClassificationTemplates",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListClassificationTemplatesResponse>(await this.callApi(params, req, runtime), new ListClassificationTemplatesResponse({}));
  }

  /**
   * @summary Queries the classification templates.
   *
   * @param request ListClassificationTemplatesRequest
   * @return ListClassificationTemplatesResponse
   */
  async listClassificationTemplates(request: ListClassificationTemplatesRequest): Promise<ListClassificationTemplatesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClassificationTemplatesWithOptions(request, runtime);
  }

  /**
   * @summary Returns the column information of a table.
   *
   * @description You can call this operation only for database instances whose control mode is Security Collaboration.
   *
   * @param request ListColumnsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListColumnsResponse
   */
  async listColumnsWithOptions(request: ListColumnsRequest, runtime: $Util.RuntimeOptions): Promise<ListColumnsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.logic)) {
      query["Logic"] = request.logic;
    }

    if (!Util.isUnset(request.tableId)) {
      query["TableId"] = request.tableId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListColumns",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListColumnsResponse>(await this.callApi(params, req, runtime), new ListColumnsResponse({}));
  }

  /**
   * @summary Returns the column information of a table.
   *
   * @description You can call this operation only for database instances whose control mode is Security Collaboration.
   *
   * @param request ListColumnsRequest
   * @return ListColumnsResponse
   */
  async listColumns(request: ListColumnsRequest): Promise<ListColumnsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listColumnsWithOptions(request, runtime);
  }

  /**
   * @summary Queries the published versions of a task flow.
   *
   * @param request ListDAGVersionsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListDAGVersionsResponse
   */
  async listDAGVersionsWithOptions(request: ListDAGVersionsRequest, runtime: $Util.RuntimeOptions): Promise<ListDAGVersionsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.pageIndex)) {
      query["PageIndex"] = request.pageIndex;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDAGVersions",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDAGVersionsResponse>(await this.callApi(params, req, runtime), new ListDAGVersionsResponse({}));
  }

  /**
   * @summary Queries the published versions of a task flow.
   *
   * @param request ListDAGVersionsRequest
   * @return ListDAGVersionsResponse
   */
  async listDAGVersions(request: ListDAGVersionsRequest): Promise<ListDAGVersionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDAGVersionsWithOptions(request, runtime);
  }

  /**
   * @summary Queries a list of SQL tasks.
   *
   * @param request ListDBTaskSQLJobRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListDBTaskSQLJobResponse
   */
  async listDBTaskSQLJobWithOptions(request: ListDBTaskSQLJobRequest, runtime: $Util.RuntimeOptions): Promise<ListDBTaskSQLJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.DBTaskGroupId)) {
      query["DBTaskGroupId"] = request.DBTaskGroupId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDBTaskSQLJob",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDBTaskSQLJobResponse>(await this.callApi(params, req, runtime), new ListDBTaskSQLJobResponse({}));
  }

  /**
   * @summary Queries a list of SQL tasks.
   *
   * @param request ListDBTaskSQLJobRequest
   * @return ListDBTaskSQLJobResponse
   */
  async listDBTaskSQLJob(request: ListDBTaskSQLJobRequest): Promise<ListDBTaskSQLJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDBTaskSQLJobWithOptions(request, runtime);
  }

  /**
   * @summary Queries the details of an SQL task.
   *
   * @param request ListDBTaskSQLJobDetailRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListDBTaskSQLJobDetailResponse
   */
  async listDBTaskSQLJobDetailWithOptions(request: ListDBTaskSQLJobDetailRequest, runtime: $Util.RuntimeOptions): Promise<ListDBTaskSQLJobDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDBTaskSQLJobDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDBTaskSQLJobDetailResponse>(await this.callApi(params, req, runtime), new ListDBTaskSQLJobDetailResponse({}));
  }

  /**
   * @summary Queries the details of an SQL task.
   *
   * @param request ListDBTaskSQLJobDetailRequest
   * @return ListDBTaskSQLJobDetailResponse
   */
  async listDBTaskSQLJobDetail(request: ListDBTaskSQLJobDetailRequest): Promise<ListDBTaskSQLJobDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDBTaskSQLJobDetailWithOptions(request, runtime);
  }

  /**
   * @summary Queries the publishing details of a schema design ticket.
   *
   * @param request ListDDLPublishRecordsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListDDLPublishRecordsResponse
   */
  async listDDLPublishRecordsWithOptions(request: ListDDLPublishRecordsRequest, runtime: $Util.RuntimeOptions): Promise<ListDDLPublishRecordsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDDLPublishRecords",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDDLPublishRecordsResponse>(await this.callApi(params, req, runtime), new ListDDLPublishRecordsResponse({}));
  }

  /**
   * @summary Queries the publishing details of a schema design ticket.
   *
   * @param request ListDDLPublishRecordsRequest
   * @return ListDDLPublishRecordsResponse
   */
  async listDDLPublishRecords(request: ListDDLPublishRecordsRequest): Promise<ListDDLPublishRecordsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDDLPublishRecordsWithOptions(request, runtime);
  }

  /**
   * @summary Queries the databases that are involved in the precheck of a data change ticket.
   *
   * @description For more information about the Normal Data Modify feature, see [Change regular data](https://help.aliyun.com/document_detail/58419.html).
   *
   * @param request ListDataCorrectPreCheckDBRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListDataCorrectPreCheckDBResponse
   */
  async listDataCorrectPreCheckDBWithOptions(request: ListDataCorrectPreCheckDBRequest, runtime: $Util.RuntimeOptions): Promise<ListDataCorrectPreCheckDBResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDataCorrectPreCheckDB",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDataCorrectPreCheckDBResponse>(await this.callApi(params, req, runtime), new ListDataCorrectPreCheckDBResponse({}));
  }

  /**
   * @summary Queries the databases that are involved in the precheck of a data change ticket.
   *
   * @description For more information about the Normal Data Modify feature, see [Change regular data](https://help.aliyun.com/document_detail/58419.html).
   *
   * @param request ListDataCorrectPreCheckDBRequest
   * @return ListDataCorrectPreCheckDBResponse
   */
  async listDataCorrectPreCheckDB(request: ListDataCorrectPreCheckDBRequest): Promise<ListDataCorrectPreCheckDBResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDataCorrectPreCheckDBWithOptions(request, runtime);
  }

  /**
   * @summary Queries the precheck information about an SQL statement that is specified in a data change ticket.
   *
   * @description For more information about the Normal Data Modify feature, see [Change regular data](https://help.aliyun.com/document_detail/58419.html).
   *
   * @param request ListDataCorrectPreCheckSQLRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListDataCorrectPreCheckSQLResponse
   */
  async listDataCorrectPreCheckSQLWithOptions(request: ListDataCorrectPreCheckSQLRequest, runtime: $Util.RuntimeOptions): Promise<ListDataCorrectPreCheckSQLResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDataCorrectPreCheckSQL",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDataCorrectPreCheckSQLResponse>(await this.callApi(params, req, runtime), new ListDataCorrectPreCheckSQLResponse({}));
  }

  /**
   * @summary Queries the precheck information about an SQL statement that is specified in a data change ticket.
   *
   * @description For more information about the Normal Data Modify feature, see [Change regular data](https://help.aliyun.com/document_detail/58419.html).
   *
   * @param request ListDataCorrectPreCheckSQLRequest
   * @return ListDataCorrectPreCheckSQLResponse
   */
  async listDataCorrectPreCheckSQL(request: ListDataCorrectPreCheckSQLRequest): Promise<ListDataCorrectPreCheckSQLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDataCorrectPreCheckSQLWithOptions(request, runtime);
  }

  /**
   * @summary Queries the precheck information of SQL statements used for data import in a ticket.
   *
   * @description You can call this operation only if the data is imported in security mode in your data import ticket.
   *
   * @param request ListDataImportSQLPreCheckDetailRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListDataImportSQLPreCheckDetailResponse
   */
  async listDataImportSQLPreCheckDetailWithOptions(request: ListDataImportSQLPreCheckDetailRequest, runtime: $Util.RuntimeOptions): Promise<ListDataImportSQLPreCheckDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.pageNumer)) {
      query["PageNumer"] = request.pageNumer;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.sqlType)) {
      query["SqlType"] = request.sqlType;
    }

    if (!Util.isUnset(request.statusCode)) {
      query["StatusCode"] = request.statusCode;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDataImportSQLPreCheckDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDataImportSQLPreCheckDetailResponse>(await this.callApi(params, req, runtime), new ListDataImportSQLPreCheckDetailResponse({}));
  }

  /**
   * @summary Queries the precheck information of SQL statements used for data import in a ticket.
   *
   * @description You can call this operation only if the data is imported in security mode in your data import ticket.
   *
   * @param request ListDataImportSQLPreCheckDetailRequest
   * @return ListDataImportSQLPreCheckDetailResponse
   */
  async listDataImportSQLPreCheckDetail(request: ListDataImportSQLPreCheckDetailRequest): Promise<ListDataImportSQLPreCheckDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDataImportSQLPreCheckDetailWithOptions(request, runtime);
  }

  /**
   * @summary Queries the types of SQL statements used for data import in a ticket.
   *
   * @description You can call this operation only if the data is imported in security mode in your data import ticket.
   *
   * @param request ListDataImportSQLTypeRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListDataImportSQLTypeResponse
   */
  async listDataImportSQLTypeWithOptions(request: ListDataImportSQLTypeRequest, runtime: $Util.RuntimeOptions): Promise<ListDataImportSQLTypeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDataImportSQLType",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDataImportSQLTypeResponse>(await this.callApi(params, req, runtime), new ListDataImportSQLTypeResponse({}));
  }

  /**
   * @summary Queries the types of SQL statements used for data import in a ticket.
   *
   * @description You can call this operation only if the data is imported in security mode in your data import ticket.
   *
   * @param request ListDataImportSQLTypeRequest
   * @return ListDataImportSQLTypeResponse
   */
  async listDataImportSQLType(request: ListDataImportSQLTypeRequest): Promise<ListDataImportSQLTypeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDataImportSQLTypeWithOptions(request, runtime);
  }

  /**
   * @summary Queries the permissions of users on a database.
   *
   * @param request ListDatabaseUserPermssionsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListDatabaseUserPermssionsResponse
   */
  async listDatabaseUserPermssionsWithOptions(request: ListDatabaseUserPermssionsRequest, runtime: $Util.RuntimeOptions): Promise<ListDatabaseUserPermssionsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.logic)) {
      query["Logic"] = request.logic;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.permType)) {
      query["PermType"] = request.permType;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.userName)) {
      query["UserName"] = request.userName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDatabaseUserPermssions",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDatabaseUserPermssionsResponse>(await this.callApi(params, req, runtime), new ListDatabaseUserPermssionsResponse({}));
  }

  /**
   * @summary Queries the permissions of users on a database.
   *
   * @param request ListDatabaseUserPermssionsRequest
   * @return ListDatabaseUserPermssionsResponse
   */
  async listDatabaseUserPermssions(request: ListDatabaseUserPermssionsRequest): Promise<ListDatabaseUserPermssionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDatabaseUserPermssionsWithOptions(request, runtime);
  }

  /**
   * @summary Queries the databases in a database instance.
   *
   * @param request ListDatabasesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListDatabasesResponse
   */
  async listDatabasesWithOptions(request: ListDatabasesRequest, runtime: $Util.RuntimeOptions): Promise<ListDatabasesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDatabases",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDatabasesResponse>(await this.callApi(params, req, runtime), new ListDatabasesResponse({}));
  }

  /**
   * @summary Queries the databases in a database instance.
   *
   * @param request ListDatabasesRequest
   * @return ListDatabasesResponse
   */
  async listDatabases(request: ListDatabasesRequest): Promise<ListDatabasesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDatabasesWithOptions(request, runtime);
  }

  /**
   * @summary Queries the default service level agreement (SLA) timeout rules.
   *
   * @param request ListDefaultSLARulesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListDefaultSLARulesResponse
   */
  async listDefaultSLARulesWithOptions(request: ListDefaultSLARulesRequest, runtime: $Util.RuntimeOptions): Promise<ListDefaultSLARulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDefaultSLARules",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDefaultSLARulesResponse>(await this.callApi(params, req, runtime), new ListDefaultSLARulesResponse({}));
  }

  /**
   * @summary Queries the default service level agreement (SLA) timeout rules.
   *
   * @param request ListDefaultSLARulesRequest
   * @return ListDefaultSLARulesResponse
   */
  async listDefaultSLARules(request: ListDefaultSLARulesRequest): Promise<ListDefaultSLARulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDefaultSLARulesWithOptions(request, runtime);
  }

  /**
   * @summary Queries masking rules.
   *
   * @param request ListDesensitizationRuleRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListDesensitizationRuleResponse
   */
  async listDesensitizationRuleWithOptions(request: ListDesensitizationRuleRequest, runtime: $Util.RuntimeOptions): Promise<ListDesensitizationRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.funcType)) {
      query["FuncType"] = request.funcType;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.ruleType)) {
      query["RuleType"] = request.ruleType;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDesensitizationRule",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDesensitizationRuleResponse>(await this.callApi(params, req, runtime), new ListDesensitizationRuleResponse({}));
  }

  /**
   * @summary Queries masking rules.
   *
   * @param request ListDesensitizationRuleRequest
   * @return ListDesensitizationRuleResponse
   */
  async listDesensitizationRule(request: ListDesensitizationRuleRequest): Promise<ListDesensitizationRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDesensitizationRuleWithOptions(request, runtime);
  }

  /**
   * @summary Queries valid orders.
   *
   * @param request ListEffectiveOrdersRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListEffectiveOrdersResponse
   */
  async listEffectiveOrdersWithOptions(request: ListEffectiveOrdersRequest, runtime: $Util.RuntimeOptions): Promise<ListEffectiveOrdersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListEffectiveOrders",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListEffectiveOrdersResponse>(await this.callApi(params, req, runtime), new ListEffectiveOrdersResponse({}));
  }

  /**
   * @summary Queries valid orders.
   *
   * @param request ListEffectiveOrdersRequest
   * @return ListEffectiveOrdersResponse
   */
  async listEffectiveOrders(request: ListEffectiveOrdersRequest): Promise<ListEffectiveOrdersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listEffectiveOrdersWithOptions(request, runtime);
  }

  /**
   * @summary Queries the indexes of a table.
   *
   * @param request ListIndexesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListIndexesResponse
   */
  async listIndexesWithOptions(request: ListIndexesRequest, runtime: $Util.RuntimeOptions): Promise<ListIndexesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.logic)) {
      query["Logic"] = request.logic;
    }

    if (!Util.isUnset(request.tableId)) {
      query["TableId"] = request.tableId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListIndexes",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListIndexesResponse>(await this.callApi(params, req, runtime), new ListIndexesResponse({}));
  }

  /**
   * @summary Queries the indexes of a table.
   *
   * @param request ListIndexesRequest
   * @return ListIndexesResponse
   */
  async listIndexes(request: ListIndexesRequest): Promise<ListIndexesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listIndexesWithOptions(request, runtime);
  }

  /**
   * @summary Queries the logon records of an instance.
   *
   * @param request ListInstanceLoginAuditLogRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListInstanceLoginAuditLogResponse
   */
  async listInstanceLoginAuditLogWithOptions(request: ListInstanceLoginAuditLogRequest, runtime: $Util.RuntimeOptions): Promise<ListInstanceLoginAuditLogResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.opUserName)) {
      query["OpUserName"] = request.opUserName;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchName)) {
      query["SearchName"] = request.searchName;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListInstanceLoginAuditLog",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListInstanceLoginAuditLogResponse>(await this.callApi(params, req, runtime), new ListInstanceLoginAuditLogResponse({}));
  }

  /**
   * @summary Queries the logon records of an instance.
   *
   * @param request ListInstanceLoginAuditLogRequest
   * @return ListInstanceLoginAuditLogResponse
   */
  async listInstanceLoginAuditLog(request: ListInstanceLoginAuditLogRequest): Promise<ListInstanceLoginAuditLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listInstanceLoginAuditLogWithOptions(request, runtime);
  }

  /**
   * @summary Queries the permissions of a user on a specific instance.
   *
   * @param request ListInstanceUserPermissionsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListInstanceUserPermissionsResponse
   */
  async listInstanceUserPermissionsWithOptions(request: ListInstanceUserPermissionsRequest, runtime: $Util.RuntimeOptions): Promise<ListInstanceUserPermissionsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.userName)) {
      query["UserName"] = request.userName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListInstanceUserPermissions",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListInstanceUserPermissionsResponse>(await this.callApi(params, req, runtime), new ListInstanceUserPermissionsResponse({}));
  }

  /**
   * @summary Queries the permissions of a user on a specific instance.
   *
   * @param request ListInstanceUserPermissionsRequest
   * @return ListInstanceUserPermissionsResponse
   */
  async listInstanceUserPermissions(request: ListInstanceUserPermissionsRequest): Promise<ListInstanceUserPermissionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listInstanceUserPermissionsWithOptions(request, runtime);
  }

  /**
   * @summary Queries the information about database instances.
   *
   * @param request ListInstancesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListInstancesResponse
   */
  async listInstancesWithOptions(request: ListInstancesRequest, runtime: $Util.RuntimeOptions): Promise<ListInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbType)) {
      query["DbType"] = request.dbType;
    }

    if (!Util.isUnset(request.envType)) {
      query["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.instanceSource)) {
      query["InstanceSource"] = request.instanceSource;
    }

    if (!Util.isUnset(request.instanceState)) {
      query["InstanceState"] = request.instanceState;
    }

    if (!Util.isUnset(request.netType)) {
      query["NetType"] = request.netType;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchKey)) {
      query["SearchKey"] = request.searchKey;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListInstances",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListInstancesResponse>(await this.callApi(params, req, runtime), new ListInstancesResponse({}));
  }

  /**
   * @summary Queries the information about database instances.
   *
   * @param request ListInstancesRequest
   * @return ListInstancesResponse
   */
  async listInstances(request: ListInstancesRequest): Promise<ListInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listInstancesWithOptions(request, runtime);
  }

  /**
   * @summary Queries the task flows corresponding to a specific business scenario in a workspace in Data Management (DMS).
   *
   * @description *   Before you call this operation, make sure that you have the access permissions on the workspace. If you do not have the access permissions on the workspace, you can contact a DMS administrator, database administrator (DBA), or workspace administrator to add you as a member of the workspace. The [AddLhMembers](https://help.aliyun.com/document_detail/424759.html) operation can be called to add a workspace member.
   * *   If you are a DMS administrator or a workspace administrator, you can query the business scenarios and task flows related to a user in a workspace based on the user ID.
   *
   * @param request ListLhTaskFlowAndScenarioRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListLhTaskFlowAndScenarioResponse
   */
  async listLhTaskFlowAndScenarioWithOptions(request: ListLhTaskFlowAndScenarioRequest, runtime: $Util.RuntimeOptions): Promise<ListLhTaskFlowAndScenarioResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.spaceId)) {
      query["SpaceId"] = request.spaceId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.userId)) {
      query["UserId"] = request.userId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListLhTaskFlowAndScenario",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListLhTaskFlowAndScenarioResponse>(await this.callApi(params, req, runtime), new ListLhTaskFlowAndScenarioResponse({}));
  }

  /**
   * @summary Queries the task flows corresponding to a specific business scenario in a workspace in Data Management (DMS).
   *
   * @description *   Before you call this operation, make sure that you have the access permissions on the workspace. If you do not have the access permissions on the workspace, you can contact a DMS administrator, database administrator (DBA), or workspace administrator to add you as a member of the workspace. The [AddLhMembers](https://help.aliyun.com/document_detail/424759.html) operation can be called to add a workspace member.
   * *   If you are a DMS administrator or a workspace administrator, you can query the business scenarios and task flows related to a user in a workspace based on the user ID.
   *
   * @param request ListLhTaskFlowAndScenarioRequest
   * @return ListLhTaskFlowAndScenarioResponse
   */
  async listLhTaskFlowAndScenario(request: ListLhTaskFlowAndScenarioRequest): Promise<ListLhTaskFlowAndScenarioResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listLhTaskFlowAndScenarioWithOptions(request, runtime);
  }

  /**
   * @summary Queries the details of logical databases.
   *
   * @param request ListLogicDatabasesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListLogicDatabasesResponse
   */
  async listLogicDatabasesWithOptions(request: ListLogicDatabasesRequest, runtime: $Util.RuntimeOptions): Promise<ListLogicDatabasesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListLogicDatabases",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListLogicDatabasesResponse>(await this.callApi(params, req, runtime), new ListLogicDatabasesResponse({}));
  }

  /**
   * @summary Queries the details of logical databases.
   *
   * @param request ListLogicDatabasesRequest
   * @return ListLogicDatabasesResponse
   */
  async listLogicDatabases(request: ListLogicDatabasesRequest): Promise<ListLogicDatabasesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listLogicDatabasesWithOptions(request, runtime);
  }

  /**
   * @summary Queries the routing algorithms of a logical table.
   *
   * @param request ListLogicTableRouteConfigRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListLogicTableRouteConfigResponse
   */
  async listLogicTableRouteConfigWithOptions(request: ListLogicTableRouteConfigRequest, runtime: $Util.RuntimeOptions): Promise<ListLogicTableRouteConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tableId)) {
      query["TableId"] = request.tableId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListLogicTableRouteConfig",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListLogicTableRouteConfigResponse>(await this.callApi(params, req, runtime), new ListLogicTableRouteConfigResponse({}));
  }

  /**
   * @summary Queries the routing algorithms of a logical table.
   *
   * @param request ListLogicTableRouteConfigRequest
   * @return ListLogicTableRouteConfigResponse
   */
  async listLogicTableRouteConfig(request: ListLogicTableRouteConfigRequest): Promise<ListLogicTableRouteConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listLogicTableRouteConfigWithOptions(request, runtime);
  }

  /**
   * @summary Queries the details of the logical tables in a logical database.
   *
   * @param request ListLogicTablesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListLogicTablesResponse
   */
  async listLogicTablesWithOptions(request: ListLogicTablesRequest, runtime: $Util.RuntimeOptions): Promise<ListLogicTablesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.databaseId)) {
      query["DatabaseId"] = request.databaseId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.returnGuid)) {
      query["ReturnGuid"] = request.returnGuid;
    }

    if (!Util.isUnset(request.searchName)) {
      query["SearchName"] = request.searchName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListLogicTables",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListLogicTablesResponse>(await this.callApi(params, req, runtime), new ListLogicTablesResponse({}));
  }

  /**
   * @summary Queries the details of the logical tables in a logical database.
   *
   * @param request ListLogicTablesRequest
   * @return ListLogicTablesResponse
   */
  async listLogicTables(request: ListLogicTablesRequest): Promise<ListLogicTablesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listLogicTablesWithOptions(request, runtime);
  }

  /**
   * @summary Queries tickets in Data Management (DMS).
   *
   * @param request ListOrdersRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListOrdersResponse
   */
  async listOrdersWithOptions(request: ListOrdersRequest, runtime: $Util.RuntimeOptions): Promise<ListOrdersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.orderResultType)) {
      query["OrderResultType"] = request.orderResultType;
    }

    if (!Util.isUnset(request.orderStatus)) {
      query["OrderStatus"] = request.orderStatus;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.pluginType)) {
      query["PluginType"] = request.pluginType;
    }

    if (!Util.isUnset(request.searchContent)) {
      query["SearchContent"] = request.searchContent;
    }

    if (!Util.isUnset(request.searchDateType)) {
      query["SearchDateType"] = request.searchDateType;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListOrders",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListOrdersResponse>(await this.callApi(params, req, runtime), new ListOrdersResponse({}));
  }

  /**
   * @summary Queries tickets in Data Management (DMS).
   *
   * @param request ListOrdersRequest
   * @return ListOrdersResponse
   */
  async listOrders(request: ListOrdersRequest): Promise<ListOrdersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listOrdersWithOptions(request, runtime);
  }

  /**
   * @summary Queries the proxies that are generated by the secure access proxy feature.
   *
   * @param request ListProxiesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListProxiesResponse
   */
  async listProxiesWithOptions(request: ListProxiesRequest, runtime: $Util.RuntimeOptions): Promise<ListProxiesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListProxies",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListProxiesResponse>(await this.callApi(params, req, runtime), new ListProxiesResponse({}));
  }

  /**
   * @summary Queries the proxies that are generated by the secure access proxy feature.
   *
   * @param request ListProxiesRequest
   * @return ListProxiesResponse
   */
  async listProxies(request: ListProxiesRequest): Promise<ListProxiesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listProxiesWithOptions(request, runtime);
  }

  /**
   * @summary Queries information about users that are authorized to access a database instance by using the secure access proxy feature.
   *
   * @param request ListProxyAccessesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListProxyAccessesResponse
   */
  async listProxyAccessesWithOptions(request: ListProxyAccessesRequest, runtime: $Util.RuntimeOptions): Promise<ListProxyAccessesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.proxyId)) {
      query["ProxyId"] = request.proxyId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListProxyAccesses",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListProxyAccessesResponse>(await this.callApi(params, req, runtime), new ListProxyAccessesResponse({}));
  }

  /**
   * @summary Queries information about users that are authorized to access a database instance by using the secure access proxy feature.
   *
   * @param request ListProxyAccessesRequest
   * @return ListProxyAccessesResponse
   */
  async listProxyAccesses(request: ListProxyAccessesRequest): Promise<ListProxyAccessesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listProxyAccessesWithOptions(request, runtime);
  }

  /**
   * @summary 操作审计-数据安全代理SQL执行列表
   *
   * @param request ListProxySQLExecAuditLogRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListProxySQLExecAuditLogResponse
   */
  async listProxySQLExecAuditLogWithOptions(request: ListProxySQLExecAuditLogRequest, runtime: $Util.RuntimeOptions): Promise<ListProxySQLExecAuditLogResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.execState)) {
      query["ExecState"] = request.execState;
    }

    if (!Util.isUnset(request.opUserName)) {
      query["OpUserName"] = request.opUserName;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.SQLType)) {
      query["SQLType"] = request.SQLType;
    }

    if (!Util.isUnset(request.searchName)) {
      query["SearchName"] = request.searchName;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListProxySQLExecAuditLog",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListProxySQLExecAuditLogResponse>(await this.callApi(params, req, runtime), new ListProxySQLExecAuditLogResponse({}));
  }

  /**
   * @summary 操作审计-数据安全代理SQL执行列表
   *
   * @param request ListProxySQLExecAuditLogRequest
   * @return ListProxySQLExecAuditLogResponse
   */
  async listProxySQLExecAuditLog(request: ListProxySQLExecAuditLogRequest): Promise<ListProxySQLExecAuditLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listProxySQLExecAuditLogWithOptions(request, runtime);
  }

  /**
   * @summary Queries the custom service level agreement (SLA) rules.
   *
   * @param request ListSLARulesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListSLARulesResponse
   */
  async listSLARulesWithOptions(request: ListSLARulesRequest, runtime: $Util.RuntimeOptions): Promise<ListSLARulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSLARules",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSLARulesResponse>(await this.callApi(params, req, runtime), new ListSLARulesResponse({}));
  }

  /**
   * @summary Queries the custom service level agreement (SLA) rules.
   *
   * @param request ListSLARulesRequest
   * @return ListSLARulesResponse
   */
  async listSLARules(request: ListSLARulesRequest): Promise<ListSLARulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSLARulesWithOptions(request, runtime);
  }

  /**
   * @summary Queries SQL statements that were written on the SQLConsole tab.
   *
   * @param request ListSQLExecAuditLogRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListSQLExecAuditLogResponse
   */
  async listSQLExecAuditLogWithOptions(request: ListSQLExecAuditLogRequest, runtime: $Util.RuntimeOptions): Promise<ListSQLExecAuditLogResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.execState)) {
      query["ExecState"] = request.execState;
    }

    if (!Util.isUnset(request.opUserName)) {
      query["OpUserName"] = request.opUserName;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchName)) {
      query["SearchName"] = request.searchName;
    }

    if (!Util.isUnset(request.sqlType)) {
      query["SqlType"] = request.sqlType;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSQLExecAuditLog",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSQLExecAuditLogResponse>(await this.callApi(params, req, runtime), new ListSQLExecAuditLogResponse({}));
  }

  /**
   * @summary Queries SQL statements that were written on the SQLConsole tab.
   *
   * @param request ListSQLExecAuditLogRequest
   * @return ListSQLExecAuditLogResponse
   */
  async listSQLExecAuditLog(request: ListSQLExecAuditLogRequest): Promise<ListSQLExecAuditLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSQLExecAuditLogWithOptions(request, runtime);
  }

  /**
   * @summary Queries the details of the SQL statements that are involved in an SQL review ticket.
   *
   * @description For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
   *
   * @param tmpReq ListSQLReviewOriginSQLRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListSQLReviewOriginSQLResponse
   */
  async listSQLReviewOriginSQLWithOptions(tmpReq: ListSQLReviewOriginSQLRequest, runtime: $Util.RuntimeOptions): Promise<ListSQLReviewOriginSQLResponse> {
    Util.validateModel(tmpReq);
    let request = new ListSQLReviewOriginSQLShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.orderActionDetail)) {
      request.orderActionDetailShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.orderActionDetail, "OrderActionDetail", "json");
    }

    let query = { };
    if (!Util.isUnset(request.orderActionDetailShrink)) {
      query["OrderActionDetail"] = request.orderActionDetailShrink;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSQLReviewOriginSQL",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSQLReviewOriginSQLResponse>(await this.callApi(params, req, runtime), new ListSQLReviewOriginSQLResponse({}));
  }

  /**
   * @summary Queries the details of the SQL statements that are involved in an SQL review ticket.
   *
   * @description For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
   *
   * @param request ListSQLReviewOriginSQLRequest
   * @return ListSQLReviewOriginSQLResponse
   */
  async listSQLReviewOriginSQL(request: ListSQLReviewOriginSQLRequest): Promise<ListSQLReviewOriginSQLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSQLReviewOriginSQLWithOptions(request, runtime);
  }

  /**
   * @summary Queries business scenarios.
   *
   * @param request ListScenariosRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListScenariosResponse
   */
  async listScenariosWithOptions(request: ListScenariosRequest, runtime: $Util.RuntimeOptions): Promise<ListScenariosResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListScenarios",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListScenariosResponse>(await this.callApi(params, req, runtime), new ListScenariosResponse({}));
  }

  /**
   * @summary Queries business scenarios.
   *
   * @param request ListScenariosRequest
   * @return ListScenariosResponse
   */
  async listScenarios(request: ListScenariosRequest): Promise<ListScenariosResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listScenariosWithOptions(request, runtime);
  }

  /**
   * @summary 获取敏感字段信息
   *
   * @param request ListSensitiveColumnInfoRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListSensitiveColumnInfoResponse
   */
  async listSensitiveColumnInfoWithOptions(request: ListSensitiveColumnInfoRequest, runtime: $Util.RuntimeOptions): Promise<ListSensitiveColumnInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.columnName)) {
      query["ColumnName"] = request.columnName;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.schemaName)) {
      query["SchemaName"] = request.schemaName;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSensitiveColumnInfo",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSensitiveColumnInfoResponse>(await this.callApi(params, req, runtime), new ListSensitiveColumnInfoResponse({}));
  }

  /**
   * @summary 获取敏感字段信息
   *
   * @param request ListSensitiveColumnInfoRequest
   * @return ListSensitiveColumnInfoResponse
   */
  async listSensitiveColumnInfo(request: ListSensitiveColumnInfoRequest): Promise<ListSensitiveColumnInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSensitiveColumnInfoWithOptions(request, runtime);
  }

  /**
   * @summary Queries sensitive fields in a table of a database.
   *
   * @param request ListSensitiveColumnsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListSensitiveColumnsResponse
   */
  async listSensitiveColumnsWithOptions(request: ListSensitiveColumnsRequest, runtime: $Util.RuntimeOptions): Promise<ListSensitiveColumnsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.columnName)) {
      query["ColumnName"] = request.columnName;
    }

    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.logic)) {
      query["Logic"] = request.logic;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.schemaName)) {
      query["SchemaName"] = request.schemaName;
    }

    if (!Util.isUnset(request.securityLevel)) {
      query["SecurityLevel"] = request.securityLevel;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSensitiveColumns",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSensitiveColumnsResponse>(await this.callApi(params, req, runtime), new ListSensitiveColumnsResponse({}));
  }

  /**
   * @summary Queries sensitive fields in a table of a database.
   *
   * @param request ListSensitiveColumnsRequest
   * @return ListSensitiveColumnsResponse
   */
  async listSensitiveColumns(request: ListSensitiveColumnsRequest): Promise<ListSensitiveColumnsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSensitiveColumnsWithOptions(request, runtime);
  }

  /**
   * @summary Queries the details of a sensitive field.
   *
   * @param request ListSensitiveColumnsDetailRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListSensitiveColumnsDetailResponse
   */
  async listSensitiveColumnsDetailWithOptions(request: ListSensitiveColumnsDetailRequest, runtime: $Util.RuntimeOptions): Promise<ListSensitiveColumnsDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.columnName)) {
      query["ColumnName"] = request.columnName;
    }

    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.logic)) {
      query["Logic"] = request.logic;
    }

    if (!Util.isUnset(request.schemaName)) {
      query["SchemaName"] = request.schemaName;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSensitiveColumnsDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSensitiveColumnsDetailResponse>(await this.callApi(params, req, runtime), new ListSensitiveColumnsDetailResponse({}));
  }

  /**
   * @summary Queries the details of a sensitive field.
   *
   * @param request ListSensitiveColumnsDetailRequest
   * @return ListSensitiveColumnsDetailResponse
   */
  async listSensitiveColumnsDetail(request: ListSensitiveColumnsDetailRequest): Promise<ListSensitiveColumnsDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSensitiveColumnsDetailWithOptions(request, runtime);
  }

  /**
   * @summary Queries the audit logs for sensitive information.
   *
   * @param request ListSensitiveDataAuditLogRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListSensitiveDataAuditLogResponse
   */
  async listSensitiveDataAuditLogWithOptions(request: ListSensitiveDataAuditLogRequest, runtime: $Util.RuntimeOptions): Promise<ListSensitiveDataAuditLogResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.columnName)) {
      query["ColumnName"] = request.columnName;
    }

    if (!Util.isUnset(request.dbName)) {
      query["DbName"] = request.dbName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.moduleName)) {
      query["ModuleName"] = request.moduleName;
    }

    if (!Util.isUnset(request.opUserName)) {
      query["OpUserName"] = request.opUserName;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSensitiveDataAuditLog",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSensitiveDataAuditLogResponse>(await this.callApi(params, req, runtime), new ListSensitiveDataAuditLogResponse({}));
  }

  /**
   * @summary Queries the audit logs for sensitive information.
   *
   * @param request ListSensitiveDataAuditLogRequest
   * @return ListSensitiveDataAuditLogResponse
   */
  async listSensitiveDataAuditLog(request: ListSensitiveDataAuditLogRequest): Promise<ListSensitiveDataAuditLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSensitiveDataAuditLogWithOptions(request, runtime);
  }

  /**
   * @summary Queries the sensitivity levels of a classification template.
   *
   * @param request ListSensitivityLevelRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListSensitivityLevelResponse
   */
  async listSensitivityLevelWithOptions(request: ListSensitivityLevelRequest, runtime: $Util.RuntimeOptions): Promise<ListSensitivityLevelResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSensitivityLevel",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSensitivityLevelResponse>(await this.callApi(params, req, runtime), new ListSensitivityLevelResponse({}));
  }

  /**
   * @summary Queries the sensitivity levels of a classification template.
   *
   * @param request ListSensitivityLevelRequest
   * @return ListSensitivityLevelResponse
   */
  async listSensitivityLevel(request: ListSensitivityLevelRequest): Promise<ListSensitivityLevelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSensitivityLevelWithOptions(request, runtime);
  }

  /**
   * @summary Queries security rule sets.
   *
   * @param request ListStandardGroupsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListStandardGroupsResponse
   */
  async listStandardGroupsWithOptions(request: ListStandardGroupsRequest, runtime: $Util.RuntimeOptions): Promise<ListStandardGroupsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListStandardGroups",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListStandardGroupsResponse>(await this.callApi(params, req, runtime), new ListStandardGroupsResponse({}));
  }

  /**
   * @summary Queries security rule sets.
   *
   * @param request ListStandardGroupsRequest
   * @return ListStandardGroupsResponse
   */
  async listStandardGroups(request: ListStandardGroupsRequest): Promise<ListStandardGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listStandardGroupsWithOptions(request, runtime);
  }

  /**
   * @summary Queries the tables in a database.
   *
   * @description You can call this operation only for database instances whose control mode is Security Collaboration.
   *
   * @param request ListTablesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListTablesResponse
   */
  async listTablesWithOptions(request: ListTablesRequest, runtime: $Util.RuntimeOptions): Promise<ListTablesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.databaseId)) {
      query["DatabaseId"] = request.databaseId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.returnGuid)) {
      query["ReturnGuid"] = request.returnGuid;
    }

    if (!Util.isUnset(request.searchName)) {
      query["SearchName"] = request.searchName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTables",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTablesResponse>(await this.callApi(params, req, runtime), new ListTablesResponse({}));
  }

  /**
   * @summary Queries the tables in a database.
   *
   * @description You can call this operation only for database instances whose control mode is Security Collaboration.
   *
   * @param request ListTablesRequest
   * @return ListTablesResponse
   */
  async listTables(request: ListTablesRequest): Promise<ListTablesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTablesWithOptions(request, runtime);
  }

  /**
   * @summary 任务编排获取任务流列表
   *
   * @param request ListTaskFlowRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListTaskFlowResponse
   */
  async listTaskFlowWithOptions(request: ListTaskFlowRequest, runtime: $Util.RuntimeOptions): Promise<ListTaskFlowResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTaskFlow",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTaskFlowResponse>(await this.callApi(params, req, runtime), new ListTaskFlowResponse({}));
  }

  /**
   * @summary 任务编排获取任务流列表
   *
   * @param request ListTaskFlowRequest
   * @return ListTaskFlowResponse
   */
  async listTaskFlow(request: ListTaskFlowRequest): Promise<ListTaskFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTaskFlowWithOptions(request, runtime);
  }

  /**
   * @summary Queries the constants for a task flow.
   *
   * @param request ListTaskFlowConstantsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListTaskFlowConstantsResponse
   */
  async listTaskFlowConstantsWithOptions(request: ListTaskFlowConstantsRequest, runtime: $Util.RuntimeOptions): Promise<ListTaskFlowConstantsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTaskFlowConstants",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTaskFlowConstantsResponse>(await this.callApi(params, req, runtime), new ListTaskFlowConstantsResponse({}));
  }

  /**
   * @summary Queries the constants for a task flow.
   *
   * @param request ListTaskFlowConstantsRequest
   * @return ListTaskFlowConstantsResponse
   */
  async listTaskFlowConstants(request: ListTaskFlowConstantsRequest): Promise<ListTaskFlowConstantsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTaskFlowConstantsWithOptions(request, runtime);
  }

  /**
   * @summary Queries the users that are involved in a specified task flow.
   *
   * @param request ListTaskFlowCooperatorsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListTaskFlowCooperatorsResponse
   */
  async listTaskFlowCooperatorsWithOptions(request: ListTaskFlowCooperatorsRequest, runtime: $Util.RuntimeOptions): Promise<ListTaskFlowCooperatorsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTaskFlowCooperators",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTaskFlowCooperatorsResponse>(await this.callApi(params, req, runtime), new ListTaskFlowCooperatorsResponse({}));
  }

  /**
   * @summary Queries the users that are involved in a specified task flow.
   *
   * @param request ListTaskFlowCooperatorsRequest
   * @return ListTaskFlowCooperatorsResponse
   */
  async listTaskFlowCooperators(request: ListTaskFlowCooperatorsRequest): Promise<ListTaskFlowCooperatorsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTaskFlowCooperatorsWithOptions(request, runtime);
  }

  /**
   * @summary Queries the edges of the directed acyclic graph (DAG) for a specified task flow based on multiple conditions.
   *
   * @description This operation is used for multi-condition query. You can call this operation to query the edges of a specified task flow that meet all specified conditions.
   *
   * @param request ListTaskFlowEdgesByConditionRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListTaskFlowEdgesByConditionResponse
   */
  async listTaskFlowEdgesByConditionWithOptions(request: ListTaskFlowEdgesByConditionRequest, runtime: $Util.RuntimeOptions): Promise<ListTaskFlowEdgesByConditionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.nodeEnd)) {
      query["NodeEnd"] = request.nodeEnd;
    }

    if (!Util.isUnset(request.nodeFrom)) {
      query["NodeFrom"] = request.nodeFrom;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTaskFlowEdgesByCondition",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTaskFlowEdgesByConditionResponse>(await this.callApi(params, req, runtime), new ListTaskFlowEdgesByConditionResponse({}));
  }

  /**
   * @summary Queries the edges of the directed acyclic graph (DAG) for a specified task flow based on multiple conditions.
   *
   * @description This operation is used for multi-condition query. You can call this operation to query the edges of a specified task flow that meet all specified conditions.
   *
   * @param request ListTaskFlowEdgesByConditionRequest
   * @return ListTaskFlowEdgesByConditionResponse
   */
  async listTaskFlowEdgesByCondition(request: ListTaskFlowEdgesByConditionRequest): Promise<ListTaskFlowEdgesByConditionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTaskFlowEdgesByConditionWithOptions(request, runtime);
  }

  /**
   * @summary Queries the execution records of a task flow.
   *
   * @param request ListTaskFlowInstanceRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListTaskFlowInstanceResponse
   */
  async listTaskFlowInstanceWithOptions(request: ListTaskFlowInstanceRequest, runtime: $Util.RuntimeOptions): Promise<ListTaskFlowInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.pageIndex)) {
      query["PageIndex"] = request.pageIndex;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTimeBegin)) {
      query["StartTimeBegin"] = request.startTimeBegin;
    }

    if (!Util.isUnset(request.startTimeEnd)) {
      query["StartTimeEnd"] = request.startTimeEnd;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.triggerType)) {
      query["TriggerType"] = request.triggerType;
    }

    if (!Util.isUnset(request.useBizDate)) {
      query["UseBizDate"] = request.useBizDate;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTaskFlowInstance",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTaskFlowInstanceResponse>(await this.callApi(params, req, runtime), new ListTaskFlowInstanceResponse({}));
  }

  /**
   * @summary Queries the execution records of a task flow.
   *
   * @param request ListTaskFlowInstanceRequest
   * @return ListTaskFlowInstanceResponse
   */
  async listTaskFlowInstance(request: ListTaskFlowInstanceRequest): Promise<ListTaskFlowInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTaskFlowInstanceWithOptions(request, runtime);
  }

  /**
   * @summary Queries the time variables for a task flow.
   *
   * @param request ListTaskFlowTimeVariablesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListTaskFlowTimeVariablesResponse
   */
  async listTaskFlowTimeVariablesWithOptions(request: ListTaskFlowTimeVariablesRequest, runtime: $Util.RuntimeOptions): Promise<ListTaskFlowTimeVariablesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTaskFlowTimeVariables",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTaskFlowTimeVariablesResponse>(await this.callApi(params, req, runtime), new ListTaskFlowTimeVariablesResponse({}));
  }

  /**
   * @summary Queries the time variables for a task flow.
   *
   * @param request ListTaskFlowTimeVariablesRequest
   * @return ListTaskFlowTimeVariablesResponse
   */
  async listTaskFlowTimeVariables(request: ListTaskFlowTimeVariablesRequest): Promise<ListTaskFlowTimeVariablesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTaskFlowTimeVariablesWithOptions(request, runtime);
  }

  /**
   * @summary Queries task flows by page.
   *
   * @param tmpReq ListTaskFlowsByPageRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListTaskFlowsByPageResponse
   */
  async listTaskFlowsByPageWithOptions(tmpReq: ListTaskFlowsByPageRequest, runtime: $Util.RuntimeOptions): Promise<ListTaskFlowsByPageResponse> {
    Util.validateModel(tmpReq);
    let request = new ListTaskFlowsByPageShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.dagIdList)) {
      request.dagIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dagIdList, "DagIdList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.dagIdListShrink)) {
      query["DagIdList"] = request.dagIdListShrink;
    }

    if (!Util.isUnset(request.pageIndex)) {
      query["PageIndex"] = request.pageIndex;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.scenarioId)) {
      query["ScenarioId"] = request.scenarioId;
    }

    if (!Util.isUnset(request.searchKey)) {
      query["SearchKey"] = request.searchKey;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTaskFlowsByPage",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTaskFlowsByPageResponse>(await this.callApi(params, req, runtime), new ListTaskFlowsByPageResponse({}));
  }

  /**
   * @summary Queries task flows by page.
   *
   * @param request ListTaskFlowsByPageRequest
   * @return ListTaskFlowsByPageResponse
   */
  async listTaskFlowsByPage(request: ListTaskFlowsByPageRequest): Promise<ListTaskFlowsByPageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTaskFlowsByPageWithOptions(request, runtime);
  }

  /**
   * @summary Queries the tasks in a specified task flow.
   *
   * @param request ListTasksInTaskFlowRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListTasksInTaskFlowResponse
   */
  async listTasksInTaskFlowWithOptions(request: ListTasksInTaskFlowRequest, runtime: $Util.RuntimeOptions): Promise<ListTasksInTaskFlowResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTasksInTaskFlow",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTasksInTaskFlowResponse>(await this.callApi(params, req, runtime), new ListTasksInTaskFlowResponse({}));
  }

  /**
   * @summary Queries the tasks in a specified task flow.
   *
   * @param request ListTasksInTaskFlowRequest
   * @return ListTasksInTaskFlowResponse
   */
  async listTasksInTaskFlow(request: ListTasksInTaskFlowRequest): Promise<ListTasksInTaskFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTasksInTaskFlowWithOptions(request, runtime);
  }

  /**
   * @summary Queries the permissions of a specific user on a database or a table.
   *
   * @param request ListUserPermissionsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListUserPermissionsResponse
   */
  async listUserPermissionsWithOptions(request: ListUserPermissionsRequest, runtime: $Util.RuntimeOptions): Promise<ListUserPermissionsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.databaseName)) {
      query["DatabaseName"] = request.databaseName;
    }

    if (!Util.isUnset(request.dbType)) {
      query["DbType"] = request.dbType;
    }

    if (!Util.isUnset(request.envType)) {
      query["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.logic)) {
      query["Logic"] = request.logic;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.permType)) {
      query["PermType"] = request.permType;
    }

    if (!Util.isUnset(request.searchKey)) {
      query["SearchKey"] = request.searchKey;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.userId)) {
      query["UserId"] = request.userId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListUserPermissions",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListUserPermissionsResponse>(await this.callApi(params, req, runtime), new ListUserPermissionsResponse({}));
  }

  /**
   * @summary Queries the permissions of a specific user on a database or a table.
   *
   * @param request ListUserPermissionsRequest
   * @return ListUserPermissionsResponse
   */
  async listUserPermissions(request: ListUserPermissionsRequest): Promise<ListUserPermissionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listUserPermissionsWithOptions(request, runtime);
  }

  /**
   * @summary 获取用户租户列表
   *
   * @param request ListUserTenantsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListUserTenantsResponse
   */
  async listUserTenantsWithOptions(request: ListUserTenantsRequest, runtime: $Util.RuntimeOptions): Promise<ListUserTenantsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListUserTenants",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListUserTenantsResponse>(await this.callApi(params, req, runtime), new ListUserTenantsResponse({}));
  }

  /**
   * @summary 获取用户租户列表
   *
   * @param request ListUserTenantsRequest
   * @return ListUserTenantsResponse
   */
  async listUserTenants(request: ListUserTenantsRequest): Promise<ListUserTenantsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listUserTenantsWithOptions(request, runtime);
  }

  /**
   * @summary Queries the details of users.
   *
   * @param request ListUsersRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListUsersResponse
   */
  async listUsersWithOptions(request: ListUsersRequest, runtime: $Util.RuntimeOptions): Promise<ListUsersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.role)) {
      query["Role"] = request.role;
    }

    if (!Util.isUnset(request.searchKey)) {
      query["SearchKey"] = request.searchKey;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.userState)) {
      query["UserState"] = request.userState;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListUsers",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListUsersResponse>(await this.callApi(params, req, runtime), new ListUsersResponse({}));
  }

  /**
   * @summary Queries the details of users.
   *
   * @param request ListUsersRequest
   * @return ListUsersResponse
   */
  async listUsers(request: ListUsersRequest): Promise<ListUsersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listUsersWithOptions(request, runtime);
  }

  /**
   * @summary Queries approval nodes.
   *
   * @param request ListWorkFlowNodesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListWorkFlowNodesResponse
   */
  async listWorkFlowNodesWithOptions(request: ListWorkFlowNodesRequest, runtime: $Util.RuntimeOptions): Promise<ListWorkFlowNodesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.searchName)) {
      query["SearchName"] = request.searchName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListWorkFlowNodes",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListWorkFlowNodesResponse>(await this.callApi(params, req, runtime), new ListWorkFlowNodesResponse({}));
  }

  /**
   * @summary Queries approval nodes.
   *
   * @param request ListWorkFlowNodesRequest
   * @return ListWorkFlowNodesResponse
   */
  async listWorkFlowNodes(request: ListWorkFlowNodesRequest): Promise<ListWorkFlowNodesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listWorkFlowNodesWithOptions(request, runtime);
  }

  /**
   * @summary Queries approval templates.
   *
   * @param request ListWorkFlowTemplatesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListWorkFlowTemplatesResponse
   */
  async listWorkFlowTemplatesWithOptions(request: ListWorkFlowTemplatesRequest, runtime: $Util.RuntimeOptions): Promise<ListWorkFlowTemplatesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.searchName)) {
      query["SearchName"] = request.searchName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListWorkFlowTemplates",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListWorkFlowTemplatesResponse>(await this.callApi(params, req, runtime), new ListWorkFlowTemplatesResponse({}));
  }

  /**
   * @summary Queries approval templates.
   *
   * @param request ListWorkFlowTemplatesRequest
   * @return ListWorkFlowTemplatesResponse
   */
  async listWorkFlowTemplates(request: ListWorkFlowTemplatesRequest): Promise<ListWorkFlowTemplatesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listWorkFlowTemplatesWithOptions(request, runtime);
  }

  /**
   * @summary Sets the status of a task flow to "Successful".
   *
   * @param request MakeTaskFlowInstanceSuccessRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return MakeTaskFlowInstanceSuccessResponse
   */
  async makeTaskFlowInstanceSuccessWithOptions(request: MakeTaskFlowInstanceSuccessRequest, runtime: $Util.RuntimeOptions): Promise<MakeTaskFlowInstanceSuccessResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.dagInstanceId)) {
      query["DagInstanceId"] = request.dagInstanceId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "MakeTaskFlowInstanceSuccess",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<MakeTaskFlowInstanceSuccessResponse>(await this.callApi(params, req, runtime), new MakeTaskFlowInstanceSuccessResponse({}));
  }

  /**
   * @summary Sets the status of a task flow to "Successful".
   *
   * @param request MakeTaskFlowInstanceSuccessRequest
   * @return MakeTaskFlowInstanceSuccessResponse
   */
  async makeTaskFlowInstanceSuccess(request: MakeTaskFlowInstanceSuccessRequest): Promise<MakeTaskFlowInstanceSuccessResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.makeTaskFlowInstanceSuccessWithOptions(request, runtime);
  }

  /**
   * @summary Modifies the SQL script that is submitted by using a data change ticket.
   *
   * @param request ModifyDataCorrectExecSQLRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ModifyDataCorrectExecSQLResponse
   */
  async modifyDataCorrectExecSQLWithOptions(request: ModifyDataCorrectExecSQLRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDataCorrectExecSQLResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.execSQL)) {
      query["ExecSQL"] = request.execSQL;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyDataCorrectExecSQL",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyDataCorrectExecSQLResponse>(await this.callApi(params, req, runtime), new ModifyDataCorrectExecSQLResponse({}));
  }

  /**
   * @summary Modifies the SQL script that is submitted by using a data change ticket.
   *
   * @param request ModifyDataCorrectExecSQLRequest
   * @return ModifyDataCorrectExecSQLResponse
   */
  async modifyDataCorrectExecSQL(request: ModifyDataCorrectExecSQLRequest): Promise<ModifyDataCorrectExecSQLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDataCorrectExecSQLWithOptions(request, runtime);
  }

  /**
   * @summary Modifies the masking rule bound to a specified field.
   *
   * @param request ModifyDesensitizationStrategyRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ModifyDesensitizationStrategyResponse
   */
  async modifyDesensitizationStrategyWithOptions(request: ModifyDesensitizationStrategyRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDesensitizationStrategyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.columnName)) {
      query["ColumnName"] = request.columnName;
    }

    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.isDefault)) {
      query["IsDefault"] = request.isDefault;
    }

    if (!Util.isUnset(request.isLogic)) {
      query["IsLogic"] = request.isLogic;
    }

    if (!Util.isUnset(request.isReset)) {
      query["IsReset"] = request.isReset;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.schemaName)) {
      query["SchemaName"] = request.schemaName;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyDesensitizationStrategy",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyDesensitizationStrategyResponse>(await this.callApi(params, req, runtime), new ModifyDesensitizationStrategyResponse({}));
  }

  /**
   * @summary Modifies the masking rule bound to a specified field.
   *
   * @param request ModifyDesensitizationStrategyRequest
   * @return ModifyDesensitizationStrategyResponse
   */
  async modifyDesensitizationStrategy(request: ModifyDesensitizationStrategyRequest): Promise<ModifyDesensitizationStrategyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDesensitizationStrategyWithOptions(request, runtime);
  }

  /**
   * @summary 修改实例信息，同时检查该实例连通性
   *
   * @param request ModifyInstanceRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ModifyInstanceResponse
   */
  async modifyInstanceWithOptions(request: ModifyInstanceRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dataLinkName)) {
      query["DataLinkName"] = request.dataLinkName;
    }

    if (!Util.isUnset(request.databasePassword)) {
      query["DatabasePassword"] = request.databasePassword;
    }

    if (!Util.isUnset(request.databaseUser)) {
      query["DatabaseUser"] = request.databaseUser;
    }

    if (!Util.isUnset(request.dbaId)) {
      query["DbaId"] = request.dbaId;
    }

    if (!Util.isUnset(request.ddlOnline)) {
      query["DdlOnline"] = request.ddlOnline;
    }

    if (!Util.isUnset(request.ecsInstanceId)) {
      query["EcsInstanceId"] = request.ecsInstanceId;
    }

    if (!Util.isUnset(request.ecsRegion)) {
      query["EcsRegion"] = request.ecsRegion;
    }

    if (!Util.isUnset(request.enableSellCommon)) {
      query["EnableSellCommon"] = request.enableSellCommon;
    }

    if (!Util.isUnset(request.enableSellSitd)) {
      query["EnableSellSitd"] = request.enableSellSitd;
    }

    if (!Util.isUnset(request.enableSellStable)) {
      query["EnableSellStable"] = request.enableSellStable;
    }

    if (!Util.isUnset(request.enableSellTrust)) {
      query["EnableSellTrust"] = request.enableSellTrust;
    }

    if (!Util.isUnset(request.envType)) {
      query["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.exportTimeout)) {
      query["ExportTimeout"] = request.exportTimeout;
    }

    if (!Util.isUnset(request.host)) {
      query["Host"] = request.host;
    }

    if (!Util.isUnset(request.instanceAlias)) {
      query["InstanceAlias"] = request.instanceAlias;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.instanceSource)) {
      query["InstanceSource"] = request.instanceSource;
    }

    if (!Util.isUnset(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!Util.isUnset(request.networkType)) {
      query["NetworkType"] = request.networkType;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.queryTimeout)) {
      query["QueryTimeout"] = request.queryTimeout;
    }

    if (!Util.isUnset(request.safeRule)) {
      query["SafeRule"] = request.safeRule;
    }

    if (!Util.isUnset(request.sid)) {
      query["Sid"] = request.sid;
    }

    if (!Util.isUnset(request.skipTest)) {
      query["SkipTest"] = request.skipTest;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.templateType)) {
      query["TemplateType"] = request.templateType;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.useDsql)) {
      query["UseDsql"] = request.useDsql;
    }

    if (!Util.isUnset(request.useSsl)) {
      query["UseSsl"] = request.useSsl;
    }

    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyInstance",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyInstanceResponse>(await this.callApi(params, req, runtime), new ModifyInstanceResponse({}));
  }

  /**
   * @summary 修改实例信息，同时检查该实例连通性
   *
   * @param request ModifyInstanceRequest
   * @return ModifyInstanceResponse
   */
  async modifyInstance(request: ModifyInstanceRequest): Promise<ModifyInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceWithOptions(request, runtime);
  }

  /**
   * @summary Migrates a task flow to a specified business scenario.
   *
   * @param request MoveTaskFlowToScenarioRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return MoveTaskFlowToScenarioResponse
   */
  async moveTaskFlowToScenarioWithOptions(request: MoveTaskFlowToScenarioRequest, runtime: $Util.RuntimeOptions): Promise<MoveTaskFlowToScenarioResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.scenarioId)) {
      query["ScenarioId"] = request.scenarioId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "MoveTaskFlowToScenario",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<MoveTaskFlowToScenarioResponse>(await this.callApi(params, req, runtime), new MoveTaskFlowToScenarioResponse({}));
  }

  /**
   * @summary Migrates a task flow to a specified business scenario.
   *
   * @param request MoveTaskFlowToScenarioRequest
   * @return MoveTaskFlowToScenarioResponse
   */
  async moveTaskFlowToScenario(request: MoveTaskFlowToScenarioRequest): Promise<MoveTaskFlowToScenarioResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.moveTaskFlowToScenarioWithOptions(request, runtime);
  }

  /**
   * @summary Unpublishes a published task flow.
   *
   * @param request OfflineTaskFlowRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return OfflineTaskFlowResponse
   */
  async offlineTaskFlowWithOptions(request: OfflineTaskFlowRequest, runtime: $Util.RuntimeOptions): Promise<OfflineTaskFlowResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "OfflineTaskFlow",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<OfflineTaskFlowResponse>(await this.callApi(params, req, runtime), new OfflineTaskFlowResponse({}));
  }

  /**
   * @summary Unpublishes a published task flow.
   *
   * @param request OfflineTaskFlowRequest
   * @return OfflineTaskFlowResponse
   */
  async offlineTaskFlow(request: OfflineTaskFlowRequest): Promise<OfflineTaskFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.offlineTaskFlowWithOptions(request, runtime);
  }

  /**
   * @summary Pauses a SQL task for data change.
   *
   * @description You can call this operation only for database instances that are managed in Security Collaboration mode.
   *
   * @param request PauseDataCorrectSQLJobRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return PauseDataCorrectSQLJobResponse
   */
  async pauseDataCorrectSQLJobWithOptions(request: PauseDataCorrectSQLJobRequest, runtime: $Util.RuntimeOptions): Promise<PauseDataCorrectSQLJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PauseDataCorrectSQLJob",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PauseDataCorrectSQLJobResponse>(await this.callApi(params, req, runtime), new PauseDataCorrectSQLJobResponse({}));
  }

  /**
   * @summary Pauses a SQL task for data change.
   *
   * @description You can call this operation only for database instances that are managed in Security Collaboration mode.
   *
   * @param request PauseDataCorrectSQLJobRequest
   * @return PauseDataCorrectSQLJobResponse
   */
  async pauseDataCorrectSQLJob(request: PauseDataCorrectSQLJobRequest): Promise<PauseDataCorrectSQLJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.pauseDataCorrectSQLJobWithOptions(request, runtime);
  }

  /**
   * @summary 创建工单审批流
   *
   * @param request PreviewWorkflowRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return PreviewWorkflowResponse
   */
  async previewWorkflowWithOptions(request: PreviewWorkflowRequest, runtime: $Util.RuntimeOptions): Promise<PreviewWorkflowResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PreviewWorkflow",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PreviewWorkflowResponse>(await this.callApi(params, req, runtime), new PreviewWorkflowResponse({}));
  }

  /**
   * @summary 创建工单审批流
   *
   * @param request PreviewWorkflowRequest
   * @return PreviewWorkflowResponse
   */
  async previewWorkflow(request: PreviewWorkflowRequest): Promise<PreviewWorkflowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.previewWorkflowWithOptions(request, runtime);
  }

  /**
   * @summary Publishes and deploys a task flow.
   *
   * @param request PublishAndDeployTaskFlowRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return PublishAndDeployTaskFlowResponse
   */
  async publishAndDeployTaskFlowWithOptions(request: PublishAndDeployTaskFlowRequest, runtime: $Util.RuntimeOptions): Promise<PublishAndDeployTaskFlowResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.versionComments)) {
      query["VersionComments"] = request.versionComments;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PublishAndDeployTaskFlow",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PublishAndDeployTaskFlowResponse>(await this.callApi(params, req, runtime), new PublishAndDeployTaskFlowResponse({}));
  }

  /**
   * @summary Publishes and deploys a task flow.
   *
   * @param request PublishAndDeployTaskFlowRequest
   * @return PublishAndDeployTaskFlowResponse
   */
  async publishAndDeployTaskFlow(request: PublishAndDeployTaskFlowRequest): Promise<PublishAndDeployTaskFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.publishAndDeployTaskFlowWithOptions(request, runtime);
  }

  /**
   * @summary Queries the download and parsing progress of data tracking logs.
   *
   * @param request QueryDataTrackResultDownloadStatusRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return QueryDataTrackResultDownloadStatusResponse
   */
  async queryDataTrackResultDownloadStatusWithOptions(request: QueryDataTrackResultDownloadStatusRequest, runtime: $Util.RuntimeOptions): Promise<QueryDataTrackResultDownloadStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.downloadKeyId)) {
      query["DownloadKeyId"] = request.downloadKeyId;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDataTrackResultDownloadStatus",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDataTrackResultDownloadStatusResponse>(await this.callApi(params, req, runtime), new QueryDataTrackResultDownloadStatusResponse({}));
  }

  /**
   * @summary Queries the download and parsing progress of data tracking logs.
   *
   * @param request QueryDataTrackResultDownloadStatusRequest
   * @return QueryDataTrackResultDownloadStatusResponse
   */
  async queryDataTrackResultDownloadStatus(request: QueryDataTrackResultDownloadStatusRequest): Promise<QueryDataTrackResultDownloadStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDataTrackResultDownloadStatusWithOptions(request, runtime);
  }

  /**
   * @summary 部署任务流的历史版本
   *
   * @param request ReDeployLhDagVersionRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ReDeployLhDagVersionResponse
   */
  async reDeployLhDagVersionWithOptions(request: ReDeployLhDagVersionRequest, runtime: $Util.RuntimeOptions): Promise<ReDeployLhDagVersionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.dagVersion)) {
      query["DagVersion"] = request.dagVersion;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ReDeployLhDagVersion",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ReDeployLhDagVersionResponse>(await this.callApi(params, req, runtime), new ReDeployLhDagVersionResponse({}));
  }

  /**
   * @summary 部署任务流的历史版本
   *
   * @param request ReDeployLhDagVersionRequest
   * @return ReDeployLhDagVersionResponse
   */
  async reDeployLhDagVersion(request: ReDeployLhDagVersionRequest): Promise<ReDeployLhDagVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.reDeployLhDagVersionWithOptions(request, runtime);
  }

  /**
   * @summary Reruns a task flow instance.
   *
   * @param request ReRunTaskFlowInstanceRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ReRunTaskFlowInstanceResponse
   */
  async reRunTaskFlowInstanceWithOptions(request: ReRunTaskFlowInstanceRequest, runtime: $Util.RuntimeOptions): Promise<ReRunTaskFlowInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.dagInstanceId)) {
      query["DagInstanceId"] = request.dagInstanceId;
    }

    if (!Util.isUnset(request.dagVersion)) {
      query["DagVersion"] = request.dagVersion;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ReRunTaskFlowInstance",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ReRunTaskFlowInstanceResponse>(await this.callApi(params, req, runtime), new ReRunTaskFlowInstanceResponse({}));
  }

  /**
   * @summary Reruns a task flow instance.
   *
   * @param request ReRunTaskFlowInstanceRequest
   * @return ReRunTaskFlowInstanceResponse
   */
  async reRunTaskFlowInstance(request: ReRunTaskFlowInstanceRequest): Promise<ReRunTaskFlowInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.reRunTaskFlowInstanceWithOptions(request, runtime);
  }

  /**
   * @summary Unsubscribes from a pay-as-you-go Data Management (DMS) resource.
   *
   * @param request RefundPayAsYouGoOrderRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return RefundPayAsYouGoOrderResponse
   */
  async refundPayAsYouGoOrderWithOptions(request: RefundPayAsYouGoOrderRequest, runtime: $Util.RuntimeOptions): Promise<RefundPayAsYouGoOrderResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RefundPayAsYouGoOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RefundPayAsYouGoOrderResponse>(await this.callApi(params, req, runtime), new RefundPayAsYouGoOrderResponse({}));
  }

  /**
   * @summary Unsubscribes from a pay-as-you-go Data Management (DMS) resource.
   *
   * @param request RefundPayAsYouGoOrderRequest
   * @return RefundPayAsYouGoOrderResponse
   */
  async refundPayAsYouGoOrder(request: RefundPayAsYouGoOrderRequest): Promise<RefundPayAsYouGoOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.refundPayAsYouGoOrderWithOptions(request, runtime);
  }

  /**
   * @summary Registers a database instance in Data Management (DMS).
   *
   * @description Prerequisites: You are a DMS administrator or a database administrator (DBA). You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to query your user role from the RoleIdList parameter that is returned.
   *
   * @param request RegisterInstanceRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return RegisterInstanceResponse
   */
  async registerInstanceWithOptions(request: RegisterInstanceRequest, runtime: $Util.RuntimeOptions): Promise<RegisterInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dataLinkName)) {
      query["DataLinkName"] = request.dataLinkName;
    }

    if (!Util.isUnset(request.databasePassword)) {
      query["DatabasePassword"] = request.databasePassword;
    }

    if (!Util.isUnset(request.databaseUser)) {
      query["DatabaseUser"] = request.databaseUser;
    }

    if (!Util.isUnset(request.dbaUid)) {
      query["DbaUid"] = request.dbaUid;
    }

    if (!Util.isUnset(request.dbaUidByString)) {
      query["DbaUidByString"] = request.dbaUidByString;
    }

    if (!Util.isUnset(request.ddlOnline)) {
      query["DdlOnline"] = request.ddlOnline;
    }

    if (!Util.isUnset(request.ecsInstanceId)) {
      query["EcsInstanceId"] = request.ecsInstanceId;
    }

    if (!Util.isUnset(request.ecsRegion)) {
      query["EcsRegion"] = request.ecsRegion;
    }

    if (!Util.isUnset(request.enableSellSitd)) {
      query["EnableSellSitd"] = request.enableSellSitd;
    }

    if (!Util.isUnset(request.envType)) {
      query["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.exportTimeout)) {
      query["ExportTimeout"] = request.exportTimeout;
    }

    if (!Util.isUnset(request.host)) {
      query["Host"] = request.host;
    }

    if (!Util.isUnset(request.instanceAlias)) {
      query["InstanceAlias"] = request.instanceAlias;
    }

    if (!Util.isUnset(request.instanceSource)) {
      query["InstanceSource"] = request.instanceSource;
    }

    if (!Util.isUnset(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!Util.isUnset(request.networkType)) {
      query["NetworkType"] = request.networkType;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.queryTimeout)) {
      query["QueryTimeout"] = request.queryTimeout;
    }

    if (!Util.isUnset(request.safeRule)) {
      query["SafeRule"] = request.safeRule;
    }

    if (!Util.isUnset(request.sid)) {
      query["Sid"] = request.sid;
    }

    if (!Util.isUnset(request.skipTest)) {
      query["SkipTest"] = request.skipTest;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.templateType)) {
      query["TemplateType"] = request.templateType;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.useDsql)) {
      query["UseDsql"] = request.useDsql;
    }

    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RegisterInstance",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RegisterInstanceResponse>(await this.callApi(params, req, runtime), new RegisterInstanceResponse({}));
  }

  /**
   * @summary Registers a database instance in Data Management (DMS).
   *
   * @description Prerequisites: You are a DMS administrator or a database administrator (DBA). You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to query your user role from the RoleIdList parameter that is returned.
   *
   * @param request RegisterInstanceRequest
   * @return RegisterInstanceResponse
   */
  async registerInstance(request: RegisterInstanceRequest): Promise<RegisterInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.registerInstanceWithOptions(request, runtime);
  }

  /**
   * @summary Registers a user for your enterprise.
   *
   * @description If you are an **administrator** in Data Management (DMS), you can call this operation to register a user for your enterprise. To view users that are assigned the administrator role, perform the following steps: Log on to the DMS console. In the top navigation bar, click O&M. In the left-side navigation pane, click User.
   *
   * @param request RegisterUserRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return RegisterUserResponse
   */
  async registerUserWithOptions(request: RegisterUserRequest, runtime: $Util.RuntimeOptions): Promise<RegisterUserResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.mobile)) {
      query["Mobile"] = request.mobile;
    }

    if (!Util.isUnset(request.roleNames)) {
      query["RoleNames"] = request.roleNames;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.uid)) {
      query["Uid"] = request.uid;
    }

    if (!Util.isUnset(request.userNick)) {
      query["UserNick"] = request.userNick;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RegisterUser",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RegisterUserResponse>(await this.callApi(params, req, runtime), new RegisterUserResponse({}));
  }

  /**
   * @summary Registers a user for your enterprise.
   *
   * @description If you are an **administrator** in Data Management (DMS), you can call this operation to register a user for your enterprise. To view users that are assigned the administrator role, perform the following steps: Log on to the DMS console. In the top navigation bar, click O&M. In the left-side navigation pane, click User.
   *
   * @param request RegisterUserRequest
   * @return RegisterUserResponse
   */
  async registerUser(request: RegisterUserRequest): Promise<RegisterUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.registerUserWithOptions(request, runtime);
  }

  /**
   * @summary Reruns a failed SQL task for data change.
   *
   * @param request RestartDataCorrectSQLJobRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return RestartDataCorrectSQLJobResponse
   */
  async restartDataCorrectSQLJobWithOptions(request: RestartDataCorrectSQLJobRequest, runtime: $Util.RuntimeOptions): Promise<RestartDataCorrectSQLJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RestartDataCorrectSQLJob",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RestartDataCorrectSQLJobResponse>(await this.callApi(params, req, runtime), new RestartDataCorrectSQLJobResponse({}));
  }

  /**
   * @summary Reruns a failed SQL task for data change.
   *
   * @param request RestartDataCorrectSQLJobRequest
   * @return RestartDataCorrectSQLJobResponse
   */
  async restartDataCorrectSQLJob(request: RestartDataCorrectSQLJobRequest): Promise<RestartDataCorrectSQLJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.restartDataCorrectSQLJobWithOptions(request, runtime);
  }

  /**
   * @summary Resumes a suspended task flow.
   *
   * @description You can call this operation only for task flows that are suspended.
   *
   * @param request ResumeTaskFlowInstanceRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ResumeTaskFlowInstanceResponse
   */
  async resumeTaskFlowInstanceWithOptions(request: ResumeTaskFlowInstanceRequest, runtime: $Util.RuntimeOptions): Promise<ResumeTaskFlowInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.dagInstanceId)) {
      query["DagInstanceId"] = request.dagInstanceId;
    }

    if (!Util.isUnset(request.dagVersion)) {
      query["DagVersion"] = request.dagVersion;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ResumeTaskFlowInstance",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ResumeTaskFlowInstanceResponse>(await this.callApi(params, req, runtime), new ResumeTaskFlowInstanceResponse({}));
  }

  /**
   * @summary Resumes a suspended task flow.
   *
   * @description You can call this operation only for task flows that are suspended.
   *
   * @param request ResumeTaskFlowInstanceRequest
   * @return ResumeTaskFlowInstanceResponse
   */
  async resumeTaskFlowInstance(request: ResumeTaskFlowInstanceRequest): Promise<ResumeTaskFlowInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.resumeTaskFlowInstanceWithOptions(request, runtime);
  }

  /**
   * @summary Reruns the precheck for a data change ticket.
   *
   * @param request RetryDataCorrectPreCheckRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return RetryDataCorrectPreCheckResponse
   */
  async retryDataCorrectPreCheckWithOptions(request: RetryDataCorrectPreCheckRequest, runtime: $Util.RuntimeOptions): Promise<RetryDataCorrectPreCheckResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RetryDataCorrectPreCheck",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RetryDataCorrectPreCheckResponse>(await this.callApi(params, req, runtime), new RetryDataCorrectPreCheckResponse({}));
  }

  /**
   * @summary Reruns the precheck for a data change ticket.
   *
   * @param request RetryDataCorrectPreCheckRequest
   * @return RetryDataCorrectPreCheckResponse
   */
  async retryDataCorrectPreCheck(request: RetryDataCorrectPreCheckRequest): Promise<RetryDataCorrectPreCheckResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.retryDataCorrectPreCheckWithOptions(request, runtime);
  }

  /**
   * @summary Revokes permissions on resources from Data Management (DMS) users by using a permission template.
   *
   * @description You must be a database administrator (DBA) or a DMS administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
   *
   * @param request RevokeTemplateAuthorityRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return RevokeTemplateAuthorityResponse
   */
  async revokeTemplateAuthorityWithOptions(request: RevokeTemplateAuthorityRequest, runtime: $Util.RuntimeOptions): Promise<RevokeTemplateAuthorityResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.userIds)) {
      query["UserIds"] = request.userIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RevokeTemplateAuthority",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RevokeTemplateAuthorityResponse>(await this.callApi(params, req, runtime), new RevokeTemplateAuthorityResponse({}));
  }

  /**
   * @summary Revokes permissions on resources from Data Management (DMS) users by using a permission template.
   *
   * @description You must be a database administrator (DBA) or a DMS administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
   *
   * @param request RevokeTemplateAuthorityRequest
   * @return RevokeTemplateAuthorityResponse
   */
  async revokeTemplateAuthority(request: RevokeTemplateAuthorityRequest): Promise<RevokeTemplateAuthorityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.revokeTemplateAuthorityWithOptions(request, runtime);
  }

  /**
   * @summary Revokes a permission on a resource from a user.
   *
   * @param request RevokeUserPermissionRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return RevokeUserPermissionResponse
   */
  async revokeUserPermissionWithOptions(request: RevokeUserPermissionRequest, runtime: $Util.RuntimeOptions): Promise<RevokeUserPermissionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.dsType)) {
      query["DsType"] = request.dsType;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.logic)) {
      query["Logic"] = request.logic;
    }

    if (!Util.isUnset(request.permTypes)) {
      query["PermTypes"] = request.permTypes;
    }

    if (!Util.isUnset(request.tableId)) {
      query["TableId"] = request.tableId;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.userAccessId)) {
      query["UserAccessId"] = request.userAccessId;
    }

    if (!Util.isUnset(request.userId)) {
      query["UserId"] = request.userId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RevokeUserPermission",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RevokeUserPermissionResponse>(await this.callApi(params, req, runtime), new RevokeUserPermissionResponse({}));
  }

  /**
   * @summary Revokes a permission on a resource from a user.
   *
   * @param request RevokeUserPermissionRequest
   * @return RevokeUserPermissionResponse
   */
  async revokeUserPermission(request: RevokeUserPermissionRequest): Promise<RevokeUserPermissionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.revokeUserPermissionWithOptions(request, runtime);
  }

  /**
   * @summary Searches for the parsing result of a data tracking task.
   *
   * @param tmpReq SearchDataTrackResultRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return SearchDataTrackResultResponse
   */
  async searchDataTrackResultWithOptions(tmpReq: SearchDataTrackResultRequest, runtime: $Util.RuntimeOptions): Promise<SearchDataTrackResultResponse> {
    Util.validateModel(tmpReq);
    let request = new SearchDataTrackResultShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.columnFilter)) {
      request.columnFilterShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.columnFilter, "ColumnFilter", "json");
    }

    if (!Util.isUnset(tmpReq.filterTableList)) {
      request.filterTableListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterTableList, "FilterTableList", "json");
    }

    if (!Util.isUnset(tmpReq.filterTypeList)) {
      request.filterTypeListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterTypeList, "FilterTypeList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.columnFilterShrink)) {
      query["ColumnFilter"] = request.columnFilterShrink;
    }

    if (!Util.isUnset(request.filterEndTime)) {
      query["FilterEndTime"] = request.filterEndTime;
    }

    if (!Util.isUnset(request.filterStartTime)) {
      query["FilterStartTime"] = request.filterStartTime;
    }

    if (!Util.isUnset(request.filterTableListShrink)) {
      query["FilterTableList"] = request.filterTableListShrink;
    }

    if (!Util.isUnset(request.filterTypeListShrink)) {
      query["FilterTypeList"] = request.filterTypeListShrink;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SearchDataTrackResult",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SearchDataTrackResultResponse>(await this.callApi(params, req, runtime), new SearchDataTrackResultResponse({}));
  }

  /**
   * @summary Searches for the parsing result of a data tracking task.
   *
   * @param request SearchDataTrackResultRequest
   * @return SearchDataTrackResultResponse
   */
  async searchDataTrackResult(request: SearchDataTrackResultRequest): Promise<SearchDataTrackResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchDataTrackResultWithOptions(request, runtime);
  }

  /**
   * @summary Queries the details of the databases.
   *
   * @param request SearchDatabaseRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return SearchDatabaseResponse
   */
  async searchDatabaseWithOptions(request: SearchDatabaseRequest, runtime: $Util.RuntimeOptions): Promise<SearchDatabaseResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbType)) {
      query["DbType"] = request.dbType;
    }

    if (!Util.isUnset(request.envType)) {
      query["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchKey)) {
      query["SearchKey"] = request.searchKey;
    }

    if (!Util.isUnset(request.searchRange)) {
      query["SearchRange"] = request.searchRange;
    }

    if (!Util.isUnset(request.searchTarget)) {
      query["SearchTarget"] = request.searchTarget;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SearchDatabase",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SearchDatabaseResponse>(await this.callApi(params, req, runtime), new SearchDatabaseResponse({}));
  }

  /**
   * @summary Queries the details of the databases.
   *
   * @param request SearchDatabaseRequest
   * @return SearchDatabaseResponse
   */
  async searchDatabase(request: SearchDatabaseRequest): Promise<SearchDatabaseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchDatabaseWithOptions(request, runtime);
  }

  /**
   * @summary Queries detailed information about tables.
   *
   * @description You can call this operation only for database instances that are managed in Security Collaboration mode.
   *
   * @param request SearchTableRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return SearchTableResponse
   */
  async searchTableWithOptions(request: SearchTableRequest, runtime: $Util.RuntimeOptions): Promise<SearchTableResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbType)) {
      query["DbType"] = request.dbType;
    }

    if (!Util.isUnset(request.envType)) {
      query["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.returnGuid)) {
      query["ReturnGuid"] = request.returnGuid;
    }

    if (!Util.isUnset(request.searchKey)) {
      query["SearchKey"] = request.searchKey;
    }

    if (!Util.isUnset(request.searchRange)) {
      query["SearchRange"] = request.searchRange;
    }

    if (!Util.isUnset(request.searchTarget)) {
      query["SearchTarget"] = request.searchTarget;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SearchTable",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SearchTableResponse>(await this.callApi(params, req, runtime), new SearchTableResponse({}));
  }

  /**
   * @summary Queries detailed information about tables.
   *
   * @description You can call this operation only for database instances that are managed in Security Collaboration mode.
   *
   * @param request SearchTableRequest
   * @return SearchTableResponse
   */
  async searchTable(request: SearchTableRequest): Promise<SearchTableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchTableWithOptions(request, runtime);
  }

  /**
   * @summary Configures the owner of an instance, a database, or a table.
   *
   * @param request SetOwnersRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return SetOwnersResponse
   */
  async setOwnersWithOptions(request: SetOwnersRequest, runtime: $Util.RuntimeOptions): Promise<SetOwnersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerIds)) {
      query["OwnerIds"] = request.ownerIds;
    }

    if (!Util.isUnset(request.ownerType)) {
      query["OwnerType"] = request.ownerType;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetOwners",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetOwnersResponse>(await this.callApi(params, req, runtime), new SetOwnersResponse({}));
  }

  /**
   * @summary Configures the owner of an instance, a database, or a table.
   *
   * @param request SetOwnersRequest
   * @return SetOwnersResponse
   */
  async setOwners(request: SetOwnersRequest): Promise<SetOwnersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setOwnersWithOptions(request, runtime);
  }

  /**
   * @summary Skips the verification on the number of rows in the precheck for data change.
   *
   * @param request SkipDataCorrectRowCheckRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return SkipDataCorrectRowCheckResponse
   */
  async skipDataCorrectRowCheckWithOptions(request: SkipDataCorrectRowCheckRequest, runtime: $Util.RuntimeOptions): Promise<SkipDataCorrectRowCheckResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.reason)) {
      query["Reason"] = request.reason;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SkipDataCorrectRowCheck",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SkipDataCorrectRowCheckResponse>(await this.callApi(params, req, runtime), new SkipDataCorrectRowCheckResponse({}));
  }

  /**
   * @summary Skips the verification on the number of rows in the precheck for data change.
   *
   * @param request SkipDataCorrectRowCheckRequest
   * @return SkipDataCorrectRowCheckResponse
   */
  async skipDataCorrectRowCheck(request: SkipDataCorrectRowCheckRequest): Promise<SkipDataCorrectRowCheckResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.skipDataCorrectRowCheckWithOptions(request, runtime);
  }

  /**
   * @summary Stops a task flow instance.
   *
   * @param request StopTaskFlowInstanceRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return StopTaskFlowInstanceResponse
   */
  async stopTaskFlowInstanceWithOptions(request: StopTaskFlowInstanceRequest, runtime: $Util.RuntimeOptions): Promise<StopTaskFlowInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.dagInstanceId)) {
      query["DagInstanceId"] = request.dagInstanceId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StopTaskFlowInstance",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StopTaskFlowInstanceResponse>(await this.callApi(params, req, runtime), new StopTaskFlowInstanceResponse({}));
  }

  /**
   * @summary Stops a task flow instance.
   *
   * @param request StopTaskFlowInstanceRequest
   * @return StopTaskFlowInstanceResponse
   */
  async stopTaskFlowInstance(request: StopTaskFlowInstanceRequest): Promise<StopTaskFlowInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopTaskFlowInstanceWithOptions(request, runtime);
  }

  /**
   * @summary Submits a ticket for approval.
   *
   * @param request SubmitOrderApprovalRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return SubmitOrderApprovalResponse
   */
  async submitOrderApprovalWithOptions(request: SubmitOrderApprovalRequest, runtime: $Util.RuntimeOptions): Promise<SubmitOrderApprovalResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SubmitOrderApproval",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SubmitOrderApprovalResponse>(await this.callApi(params, req, runtime), new SubmitOrderApprovalResponse({}));
  }

  /**
   * @summary Submits a ticket for approval.
   *
   * @param request SubmitOrderApprovalRequest
   * @return SubmitOrderApprovalResponse
   */
  async submitOrderApproval(request: SubmitOrderApprovalRequest): Promise<SubmitOrderApprovalResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitOrderApprovalWithOptions(request, runtime);
  }

  /**
   * @summary Submits a schema synchronization ticket for approval.
   *
   * @param request SubmitStructSyncOrderApprovalRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return SubmitStructSyncOrderApprovalResponse
   */
  async submitStructSyncOrderApprovalWithOptions(request: SubmitStructSyncOrderApprovalRequest, runtime: $Util.RuntimeOptions): Promise<SubmitStructSyncOrderApprovalResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SubmitStructSyncOrderApproval",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SubmitStructSyncOrderApprovalResponse>(await this.callApi(params, req, runtime), new SubmitStructSyncOrderApprovalResponse({}));
  }

  /**
   * @summary Submits a schema synchronization ticket for approval.
   *
   * @param request SubmitStructSyncOrderApprovalRequest
   * @return SubmitStructSyncOrderApprovalResponse
   */
  async submitStructSyncOrderApproval(request: SubmitStructSyncOrderApprovalRequest): Promise<SubmitStructSyncOrderApprovalResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitStructSyncOrderApprovalWithOptions(request, runtime);
  }

  /**
   * @summary Suspends a task flow instance.
   *
   * @param request SuspendTaskFlowInstanceRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return SuspendTaskFlowInstanceResponse
   */
  async suspendTaskFlowInstanceWithOptions(request: SuspendTaskFlowInstanceRequest, runtime: $Util.RuntimeOptions): Promise<SuspendTaskFlowInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.dagInstanceId)) {
      query["DagInstanceId"] = request.dagInstanceId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SuspendTaskFlowInstance",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SuspendTaskFlowInstanceResponse>(await this.callApi(params, req, runtime), new SuspendTaskFlowInstanceResponse({}));
  }

  /**
   * @summary Suspends a task flow instance.
   *
   * @param request SuspendTaskFlowInstanceRequest
   * @return SuspendTaskFlowInstanceResponse
   */
  async suspendTaskFlowInstance(request: SuspendTaskFlowInstanceRequest): Promise<SuspendTaskFlowInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.suspendTaskFlowInstanceWithOptions(request, runtime);
  }

  /**
   * @summary Synchronizes the metadata of a database.
   *
   * @param request SyncDatabaseMetaRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return SyncDatabaseMetaResponse
   */
  async syncDatabaseMetaWithOptions(request: SyncDatabaseMetaRequest, runtime: $Util.RuntimeOptions): Promise<SyncDatabaseMetaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.logic)) {
      query["Logic"] = request.logic;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SyncDatabaseMeta",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SyncDatabaseMetaResponse>(await this.callApi(params, req, runtime), new SyncDatabaseMetaResponse({}));
  }

  /**
   * @summary Synchronizes the metadata of a database.
   *
   * @param request SyncDatabaseMetaRequest
   * @return SyncDatabaseMetaResponse
   */
  async syncDatabaseMeta(request: SyncDatabaseMetaRequest): Promise<SyncDatabaseMetaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.syncDatabaseMetaWithOptions(request, runtime);
  }

  /**
   * @summary Synchronizes the metadata of all databases in a database instance.
   *
   * @description You can call this operation only for database instances whose control mode is Security Collaboration.
   *
   * @param request SyncInstanceMetaRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return SyncInstanceMetaResponse
   */
  async syncInstanceMetaWithOptions(request: SyncInstanceMetaRequest, runtime: $Util.RuntimeOptions): Promise<SyncInstanceMetaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ignoreTable)) {
      query["IgnoreTable"] = request.ignoreTable;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SyncInstanceMeta",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SyncInstanceMetaResponse>(await this.callApi(params, req, runtime), new SyncInstanceMetaResponse({}));
  }

  /**
   * @summary Synchronizes the metadata of all databases in a database instance.
   *
   * @description You can call this operation only for database instances whose control mode is Security Collaboration.
   *
   * @param request SyncInstanceMetaRequest
   * @return SyncInstanceMetaResponse
   */
  async syncInstanceMeta(request: SyncInstanceMetaRequest): Promise<SyncInstanceMetaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.syncInstanceMetaWithOptions(request, runtime);
  }

  /**
   * @summary Modifies a permission template.
   *
   * @description You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
   *
   * @param request UpdateAuthorityTemplateRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateAuthorityTemplateResponse
   */
  async updateAuthorityTemplateWithOptions(request: UpdateAuthorityTemplateRequest, runtime: $Util.RuntimeOptions): Promise<UpdateAuthorityTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateAuthorityTemplate",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateAuthorityTemplateResponse>(await this.callApi(params, req, runtime), new UpdateAuthorityTemplateResponse({}));
  }

  /**
   * @summary Modifies a permission template.
   *
   * @description You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
   *
   * @param request UpdateAuthorityTemplateRequest
   * @return UpdateAuthorityTemplateResponse
   */
  async updateAuthorityTemplate(request: UpdateAuthorityTemplateRequest): Promise<UpdateAuthorityTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateAuthorityTemplateWithOptions(request, runtime);
  }

  /**
   * @summary Updates the information about a database instance and checks the connectivity of the database instance.
   *
   * @description Before you call the UpdateInstance operation, call the [GetInstance](https://help.aliyun.com/document_detail/141567.html) or [ListInstances](https://help.aliyun.com/document_detail/141936.html) operation to obtain the complete information about the instance.
   *
   * @param request UpdateInstanceRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateInstanceResponse
   */
  async updateInstanceWithOptions(request: UpdateInstanceRequest, runtime: $Util.RuntimeOptions): Promise<UpdateInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dataLinkName)) {
      query["DataLinkName"] = request.dataLinkName;
    }

    if (!Util.isUnset(request.databasePassword)) {
      query["DatabasePassword"] = request.databasePassword;
    }

    if (!Util.isUnset(request.databaseUser)) {
      query["DatabaseUser"] = request.databaseUser;
    }

    if (!Util.isUnset(request.dbaId)) {
      query["DbaId"] = request.dbaId;
    }

    if (!Util.isUnset(request.ddlOnline)) {
      query["DdlOnline"] = request.ddlOnline;
    }

    if (!Util.isUnset(request.ecsInstanceId)) {
      query["EcsInstanceId"] = request.ecsInstanceId;
    }

    if (!Util.isUnset(request.ecsRegion)) {
      query["EcsRegion"] = request.ecsRegion;
    }

    if (!Util.isUnset(request.enableSellSitd)) {
      query["EnableSellSitd"] = request.enableSellSitd;
    }

    if (!Util.isUnset(request.envType)) {
      query["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.exportTimeout)) {
      query["ExportTimeout"] = request.exportTimeout;
    }

    if (!Util.isUnset(request.host)) {
      query["Host"] = request.host;
    }

    if (!Util.isUnset(request.instanceAlias)) {
      query["InstanceAlias"] = request.instanceAlias;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.instanceSource)) {
      query["InstanceSource"] = request.instanceSource;
    }

    if (!Util.isUnset(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.queryTimeout)) {
      query["QueryTimeout"] = request.queryTimeout;
    }

    if (!Util.isUnset(request.safeRuleId)) {
      query["SafeRuleId"] = request.safeRuleId;
    }

    if (!Util.isUnset(request.sid)) {
      query["Sid"] = request.sid;
    }

    if (!Util.isUnset(request.skipTest)) {
      query["SkipTest"] = request.skipTest;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.templateType)) {
      query["TemplateType"] = request.templateType;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.useDsql)) {
      query["UseDsql"] = request.useDsql;
    }

    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateInstance",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateInstanceResponse>(await this.callApi(params, req, runtime), new UpdateInstanceResponse({}));
  }

  /**
   * @summary Updates the information about a database instance and checks the connectivity of the database instance.
   *
   * @description Before you call the UpdateInstance operation, call the [GetInstance](https://help.aliyun.com/document_detail/141567.html) or [ListInstances](https://help.aliyun.com/document_detail/141936.html) operation to obtain the complete information about the instance.
   *
   * @param request UpdateInstanceRequest
   * @return UpdateInstanceResponse
   */
  async updateInstance(request: UpdateInstanceRequest): Promise<UpdateInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateInstanceWithOptions(request, runtime);
  }

  /**
   * @summary Updates the service level agreement (SLA) timeout reminder for a task flow.
   *
   * @description SLA rules take effect after task flows are deployed and published.
   *
   * @param tmpReq UpdateSLARulesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateSLARulesResponse
   */
  async updateSLARulesWithOptions(tmpReq: UpdateSLARulesRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSLARulesResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateSLARulesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.slaRuleList)) {
      request.slaRuleListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.slaRuleList, "SlaRuleList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.slaRuleListShrink)) {
      query["SlaRuleList"] = request.slaRuleListShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateSLARules",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateSLARulesResponse>(await this.callApi(params, req, runtime), new UpdateSLARulesResponse({}));
  }

  /**
   * @summary Updates the service level agreement (SLA) timeout reminder for a task flow.
   *
   * @description SLA rules take effect after task flows are deployed and published.
   *
   * @param request UpdateSLARulesRequest
   * @return UpdateSLARulesResponse
   */
  async updateSLARules(request: UpdateSLARulesRequest): Promise<UpdateSLARulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSLARulesWithOptions(request, runtime);
  }

  /**
   * @summary Updates the name and description of the business scenario for a specified task flow.
   *
   * @param request UpdateScenarioRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateScenarioResponse
   */
  async updateScenarioWithOptions(request: UpdateScenarioRequest, runtime: $Util.RuntimeOptions): Promise<UpdateScenarioResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.scenarioId)) {
      query["ScenarioId"] = request.scenarioId;
    }

    if (!Util.isUnset(request.scenarioName)) {
      query["ScenarioName"] = request.scenarioName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateScenario",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateScenarioResponse>(await this.callApi(params, req, runtime), new UpdateScenarioResponse({}));
  }

  /**
   * @summary Updates the name and description of the business scenario for a specified task flow.
   *
   * @param request UpdateScenarioRequest
   * @return UpdateScenarioResponse
   */
  async updateScenario(request: UpdateScenarioRequest): Promise<UpdateScenarioResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateScenarioWithOptions(request, runtime);
  }

  /**
   * @summary Modifies the name and description of a specific security rule set.
   *
   * @param request UpdateStandardGroupRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateStandardGroupResponse
   */
  async updateStandardGroupWithOptions(request: UpdateStandardGroupRequest, runtime: $Util.RuntimeOptions): Promise<UpdateStandardGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateStandardGroup",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateStandardGroupResponse>(await this.callApi(params, req, runtime), new UpdateStandardGroupResponse({}));
  }

  /**
   * @summary Modifies the name and description of a specific security rule set.
   *
   * @param request UpdateStandardGroupRequest
   * @return UpdateStandardGroupResponse
   */
  async updateStandardGroup(request: UpdateStandardGroupRequest): Promise<UpdateStandardGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateStandardGroupWithOptions(request, runtime);
  }

  /**
   * @summary Updates the advanced configuration of a task node.
   *
   * @description You can call this operation to configure a failed task or rerun a task.
   *
   * @param request UpdateTaskConfigRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateTaskConfigResponse
   */
  async updateTaskConfigWithOptions(request: UpdateTaskConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.nodeConfig)) {
      query["NodeConfig"] = request.nodeConfig;
    }

    if (!Util.isUnset(request.nodeId)) {
      query["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskConfig",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskConfigResponse>(await this.callApi(params, req, runtime), new UpdateTaskConfigResponse({}));
  }

  /**
   * @summary Updates the advanced configuration of a task node.
   *
   * @description You can call this operation to configure a failed task or rerun a task.
   *
   * @param request UpdateTaskConfigRequest
   * @return UpdateTaskConfigResponse
   */
  async updateTaskConfig(request: UpdateTaskConfigRequest): Promise<UpdateTaskConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskConfigWithOptions(request, runtime);
  }

  /**
   * @summary Updates tasks in a task flow.
   *
   * @description You can call this operation to modify node configurations.
   *
   * @param request UpdateTaskContentRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateTaskContentResponse
   */
  async updateTaskContentWithOptions(request: UpdateTaskContentRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskContentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.nodeContent)) {
      query["NodeContent"] = request.nodeContent;
    }

    if (!Util.isUnset(request.nodeId)) {
      query["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskContent",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskContentResponse>(await this.callApi(params, req, runtime), new UpdateTaskContentResponse({}));
  }

  /**
   * @summary Updates tasks in a task flow.
   *
   * @description You can call this operation to modify node configurations.
   *
   * @param request UpdateTaskContentRequest
   * @return UpdateTaskContentResponse
   */
  async updateTaskContent(request: UpdateTaskContentRequest): Promise<UpdateTaskContentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskContentWithOptions(request, runtime);
  }

  /**
   * @summary Updates the constants for a specified task flow.
   *
   * @param tmpReq UpdateTaskFlowConstantsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateTaskFlowConstantsResponse
   */
  async updateTaskFlowConstantsWithOptions(tmpReq: UpdateTaskFlowConstantsRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskFlowConstantsResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateTaskFlowConstantsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.dagConstants)) {
      request.dagConstantsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dagConstants, "DagConstants", "json");
    }

    let query = { };
    if (!Util.isUnset(request.dagConstantsShrink)) {
      query["DagConstants"] = request.dagConstantsShrink;
    }

    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskFlowConstants",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskFlowConstantsResponse>(await this.callApi(params, req, runtime), new UpdateTaskFlowConstantsResponse({}));
  }

  /**
   * @summary Updates the constants for a specified task flow.
   *
   * @param request UpdateTaskFlowConstantsRequest
   * @return UpdateTaskFlowConstantsResponse
   */
  async updateTaskFlowConstants(request: UpdateTaskFlowConstantsRequest): Promise<UpdateTaskFlowConstantsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskFlowConstantsWithOptions(request, runtime);
  }

  /**
   * @summary Updates the IDs of the users who are involved in the task flow.
   *
   * @param tmpReq UpdateTaskFlowCooperatorsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateTaskFlowCooperatorsResponse
   */
  async updateTaskFlowCooperatorsWithOptions(tmpReq: UpdateTaskFlowCooperatorsRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskFlowCooperatorsResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateTaskFlowCooperatorsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.cooperatorIds)) {
      request.cooperatorIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.cooperatorIds, "CooperatorIds", "json");
    }

    let query = { };
    if (!Util.isUnset(request.cooperatorIdsShrink)) {
      query["CooperatorIds"] = request.cooperatorIdsShrink;
    }

    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskFlowCooperators",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskFlowCooperatorsResponse>(await this.callApi(params, req, runtime), new UpdateTaskFlowCooperatorsResponse({}));
  }

  /**
   * @summary Updates the IDs of the users who are involved in the task flow.
   *
   * @param request UpdateTaskFlowCooperatorsRequest
   * @return UpdateTaskFlowCooperatorsResponse
   */
  async updateTaskFlowCooperators(request: UpdateTaskFlowCooperatorsRequest): Promise<UpdateTaskFlowCooperatorsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskFlowCooperatorsWithOptions(request, runtime);
  }

  /**
   * @summary Updates the start node and end node of multiple edges at a time for a task flow.
   *
   * @description ###
   * The edges can be updated only when the following conditions are met:
   * 1.  The specified edge exists in the directed acyclic graph (DAG) of the task flow specified by DagId.
   * 2.  The specified edge nodes exist in the DAG of the task flow specified by DagId.
   * 3.  After the update, rings do not exist in the DAG.
   *
   * @param tmpReq UpdateTaskFlowEdgesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateTaskFlowEdgesResponse
   */
  async updateTaskFlowEdgesWithOptions(tmpReq: UpdateTaskFlowEdgesRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskFlowEdgesResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateTaskFlowEdgesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.edges)) {
      request.edgesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.edges, "Edges", "json");
    }

    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.edgesShrink)) {
      query["Edges"] = request.edgesShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskFlowEdges",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskFlowEdgesResponse>(await this.callApi(params, req, runtime), new UpdateTaskFlowEdgesResponse({}));
  }

  /**
   * @summary Updates the start node and end node of multiple edges at a time for a task flow.
   *
   * @description ###
   * The edges can be updated only when the following conditions are met:
   * 1.  The specified edge exists in the directed acyclic graph (DAG) of the task flow specified by DagId.
   * 2.  The specified edge nodes exist in the DAG of the task flow specified by DagId.
   * 3.  After the update, rings do not exist in the DAG.
   *
   * @param request UpdateTaskFlowEdgesRequest
   * @return UpdateTaskFlowEdgesResponse
   */
  async updateTaskFlowEdges(request: UpdateTaskFlowEdgesRequest): Promise<UpdateTaskFlowEdgesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskFlowEdgesWithOptions(request, runtime);
  }

  /**
   * @summary Updates the name and description of a task flow.
   *
   * @param request UpdateTaskFlowNameAndDescRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateTaskFlowNameAndDescResponse
   */
  async updateTaskFlowNameAndDescWithOptions(request: UpdateTaskFlowNameAndDescRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskFlowNameAndDescResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.dagName)) {
      query["DagName"] = request.dagName;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskFlowNameAndDesc",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskFlowNameAndDescResponse>(await this.callApi(params, req, runtime), new UpdateTaskFlowNameAndDescResponse({}));
  }

  /**
   * @summary Updates the name and description of a task flow.
   *
   * @param request UpdateTaskFlowNameAndDescRequest
   * @return UpdateTaskFlowNameAndDescResponse
   */
  async updateTaskFlowNameAndDesc(request: UpdateTaskFlowNameAndDescRequest): Promise<UpdateTaskFlowNameAndDescResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskFlowNameAndDescWithOptions(request, runtime);
  }

  /**
   * @summary Updates the notification settings for task flows.
   *
   * @param request UpdateTaskFlowNotificationRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateTaskFlowNotificationResponse
   */
  async updateTaskFlowNotificationWithOptions(request: UpdateTaskFlowNotificationRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskFlowNotificationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.dagNotificationFail)) {
      query["DagNotificationFail"] = request.dagNotificationFail;
    }

    if (!Util.isUnset(request.dagNotificationSla)) {
      query["DagNotificationSla"] = request.dagNotificationSla;
    }

    if (!Util.isUnset(request.dagNotificationSuccess)) {
      query["DagNotificationSuccess"] = request.dagNotificationSuccess;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskFlowNotification",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskFlowNotificationResponse>(await this.callApi(params, req, runtime), new UpdateTaskFlowNotificationResponse({}));
  }

  /**
   * @summary Updates the notification settings for task flows.
   *
   * @param request UpdateTaskFlowNotificationRequest
   * @return UpdateTaskFlowNotificationResponse
   */
  async updateTaskFlowNotification(request: UpdateTaskFlowNotificationRequest): Promise<UpdateTaskFlowNotificationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskFlowNotificationWithOptions(request, runtime);
  }

  /**
   * @summary Changes the owner of a task flow.
   *
   * @description Note: The new owner of the task flow must belong to the same tenant as the previous owner.
   *
   * @param request UpdateTaskFlowOwnerRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateTaskFlowOwnerResponse
   */
  async updateTaskFlowOwnerWithOptions(request: UpdateTaskFlowOwnerRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskFlowOwnerResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.newOwnerId)) {
      query["NewOwnerId"] = request.newOwnerId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskFlowOwner",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskFlowOwnerResponse>(await this.callApi(params, req, runtime), new UpdateTaskFlowOwnerResponse({}));
  }

  /**
   * @summary Changes the owner of a task flow.
   *
   * @description Note: The new owner of the task flow must belong to the same tenant as the previous owner.
   *
   * @param request UpdateTaskFlowOwnerRequest
   * @return UpdateTaskFlowOwnerResponse
   */
  async updateTaskFlowOwner(request: UpdateTaskFlowOwnerRequest): Promise<UpdateTaskFlowOwnerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskFlowOwnerWithOptions(request, runtime);
  }

  /**
   * @summary Fully updates the edges of a task flow.
   *
   * @description You can call this operation to perform a full update. For incremental updates, see AddTaskFlowEdges, UpdateTaskFlowEdges, and DeleteTaskFlowEdgesByMultiCondition.
   *
   * @param tmpReq UpdateTaskFlowRelationsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateTaskFlowRelationsResponse
   */
  async updateTaskFlowRelationsWithOptions(tmpReq: UpdateTaskFlowRelationsRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskFlowRelationsResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateTaskFlowRelationsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.edges)) {
      request.edgesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.edges, "Edges", "json");
    }

    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.edgesShrink)) {
      query["Edges"] = request.edgesShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskFlowRelations",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskFlowRelationsResponse>(await this.callApi(params, req, runtime), new UpdateTaskFlowRelationsResponse({}));
  }

  /**
   * @summary Fully updates the edges of a task flow.
   *
   * @description You can call this operation to perform a full update. For incremental updates, see AddTaskFlowEdges, UpdateTaskFlowEdges, and DeleteTaskFlowEdgesByMultiCondition.
   *
   * @param request UpdateTaskFlowRelationsRequest
   * @return UpdateTaskFlowRelationsResponse
   */
  async updateTaskFlowRelations(request: UpdateTaskFlowRelationsRequest): Promise<UpdateTaskFlowRelationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskFlowRelationsWithOptions(request, runtime);
  }

  /**
   * @summary Updates the scheduling properties for a task flow.
   *
   * @description You can call this operation to update the scheduling properties for a task flow in the editing state. You can configure a **timed scheduling** task flow or an **event scheduling** task flow. When you configure a **timed scheduling** task flow, you can choose from one-time scheduling or periodic scheduling. When you configure an **event scheduling** task flow, you can subscribe to task flows or task flow nodes.****\\
   * After you update the scheduling properties, you need to publish and deploy the task flow again. The new task flow instance will run based on the updated scheduling properties.
   *
   * @param request UpdateTaskFlowScheduleRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateTaskFlowScheduleResponse
   */
  async updateTaskFlowScheduleWithOptions(request: UpdateTaskFlowScheduleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskFlowScheduleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.cronBeginDate)) {
      query["CronBeginDate"] = request.cronBeginDate;
    }

    if (!Util.isUnset(request.cronEndDate)) {
      query["CronEndDate"] = request.cronEndDate;
    }

    if (!Util.isUnset(request.cronStr)) {
      query["CronStr"] = request.cronStr;
    }

    if (!Util.isUnset(request.cronType)) {
      query["CronType"] = request.cronType;
    }

    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.scheduleParam)) {
      query["ScheduleParam"] = request.scheduleParam;
    }

    if (!Util.isUnset(request.scheduleSwitch)) {
      query["ScheduleSwitch"] = request.scheduleSwitch;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.timeZoneId)) {
      query["TimeZoneId"] = request.timeZoneId;
    }

    if (!Util.isUnset(request.triggerType)) {
      query["TriggerType"] = request.triggerType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskFlowSchedule",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskFlowScheduleResponse>(await this.callApi(params, req, runtime), new UpdateTaskFlowScheduleResponse({}));
  }

  /**
   * @summary Updates the scheduling properties for a task flow.
   *
   * @description You can call this operation to update the scheduling properties for a task flow in the editing state. You can configure a **timed scheduling** task flow or an **event scheduling** task flow. When you configure a **timed scheduling** task flow, you can choose from one-time scheduling or periodic scheduling. When you configure an **event scheduling** task flow, you can subscribe to task flows or task flow nodes.****\\
   * After you update the scheduling properties, you need to publish and deploy the task flow again. The new task flow instance will run based on the updated scheduling properties.
   *
   * @param request UpdateTaskFlowScheduleRequest
   * @return UpdateTaskFlowScheduleResponse
   */
  async updateTaskFlowSchedule(request: UpdateTaskFlowScheduleRequest): Promise<UpdateTaskFlowScheduleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskFlowScheduleWithOptions(request, runtime);
  }

  /**
   * @summary Updates the time variables for a task flow.
   *
   * @param request UpdateTaskFlowTimeVariablesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateTaskFlowTimeVariablesResponse
   */
  async updateTaskFlowTimeVariablesWithOptions(request: UpdateTaskFlowTimeVariablesRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskFlowTimeVariablesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.timeVariables)) {
      query["TimeVariables"] = request.timeVariables;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskFlowTimeVariables",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskFlowTimeVariablesResponse>(await this.callApi(params, req, runtime), new UpdateTaskFlowTimeVariablesResponse({}));
  }

  /**
   * @summary Updates the time variables for a task flow.
   *
   * @param request UpdateTaskFlowTimeVariablesRequest
   * @return UpdateTaskFlowTimeVariablesResponse
   */
  async updateTaskFlowTimeVariables(request: UpdateTaskFlowTimeVariablesRequest): Promise<UpdateTaskFlowTimeVariablesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskFlowTimeVariablesWithOptions(request, runtime);
  }

  /**
   * @summary Updates the name of a specified task.
   *
   * @param request UpdateTaskNameRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateTaskNameResponse
   */
  async updateTaskNameWithOptions(request: UpdateTaskNameRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskNameResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.nodeId)) {
      query["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.nodeName)) {
      query["NodeName"] = request.nodeName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskName",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskNameResponse>(await this.callApi(params, req, runtime), new UpdateTaskNameResponse({}));
  }

  /**
   * @summary Updates the name of a specified task.
   *
   * @param request UpdateTaskNameRequest
   * @return UpdateTaskNameResponse
   */
  async updateTaskName(request: UpdateTaskNameRequest): Promise<UpdateTaskNameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskNameWithOptions(request, runtime);
  }

  /**
   * @summary Updates the output variables for a specified task node.
   *
   * @description Only nodes of single-instance SQL assignment, script code, and ECS remote command have output variables.
   *
   * @param request UpdateTaskOutputRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateTaskOutputResponse
   */
  async updateTaskOutputWithOptions(request: UpdateTaskOutputRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskOutputResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.nodeId)) {
      query["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.nodeOutput)) {
      query["NodeOutput"] = request.nodeOutput;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskOutput",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskOutputResponse>(await this.callApi(params, req, runtime), new UpdateTaskOutputResponse({}));
  }

  /**
   * @summary Updates the output variables for a specified task node.
   *
   * @description Only nodes of single-instance SQL assignment, script code, and ECS remote command have output variables.
   *
   * @param request UpdateTaskOutputRequest
   * @return UpdateTaskOutputResponse
   */
  async updateTaskOutput(request: UpdateTaskOutputRequest): Promise<UpdateTaskOutputResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskOutputWithOptions(request, runtime);
  }

  /**
   * @summary Updates time variables for a task.
   *
   * @param request UpdateTaskTimeVariablesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateTaskTimeVariablesResponse
   */
  async updateTaskTimeVariablesWithOptions(request: UpdateTaskTimeVariablesRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskTimeVariablesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.nodeId)) {
      query["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.timeVariables)) {
      query["TimeVariables"] = request.timeVariables;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskTimeVariables",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskTimeVariablesResponse>(await this.callApi(params, req, runtime), new UpdateTaskTimeVariablesResponse({}));
  }

  /**
   * @summary Updates time variables for a task.
   *
   * @param request UpdateTaskTimeVariablesRequest
   * @return UpdateTaskTimeVariablesResponse
   */
  async updateTaskTimeVariables(request: UpdateTaskTimeVariablesRequest): Promise<UpdateTaskTimeVariablesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskTimeVariablesWithOptions(request, runtime);
  }

  /**
   * @summary Updates user information.
   *
   * @param request UpdateUserRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateUserResponse
   */
  async updateUserWithOptions(request: UpdateUserRequest, runtime: $Util.RuntimeOptions): Promise<UpdateUserResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.maxExecuteCount)) {
      query["MaxExecuteCount"] = request.maxExecuteCount;
    }

    if (!Util.isUnset(request.maxResultCount)) {
      query["MaxResultCount"] = request.maxResultCount;
    }

    if (!Util.isUnset(request.mobile)) {
      query["Mobile"] = request.mobile;
    }

    if (!Util.isUnset(request.roleNames)) {
      query["RoleNames"] = request.roleNames;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.uid)) {
      query["Uid"] = request.uid;
    }

    if (!Util.isUnset(request.userNick)) {
      query["UserNick"] = request.userNick;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateUser",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateUserResponse>(await this.callApi(params, req, runtime), new UpdateUserResponse({}));
  }

  /**
   * @summary Updates user information.
   *
   * @param request UpdateUserRequest
   * @return UpdateUserResponse
   */
  async updateUser(request: UpdateUserRequest): Promise<UpdateUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateUserWithOptions(request, runtime);
  }

}
