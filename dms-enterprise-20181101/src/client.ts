// This file is auto-generated, don't edit it
/**
 */
import Util, * as $Util from '@alicloud/tea-util';
import OpenApi, * as $OpenApi from '@alicloud/openapi-client';
import OpenApiUtil from '@alicloud/openapi-util';
import EndpointUtil from '@alicloud/endpoint-util';
import * as $tea from '@alicloud/tea-typescript';

export class AsyncTaskVO extends $tea.Model {
  datasetId?: string;
  id?: number;
  remark?: string;
  taskName?: string;
  taskStatus?: number;
  taskType?: number;
  userId?: number;
  static names(): { [key: string]: string } {
    return {
      datasetId: 'DatasetId',
      id: 'Id',
      remark: 'Remark',
      taskName: 'TaskName',
      taskStatus: 'TaskStatus',
      taskType: 'TaskType',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      datasetId: 'string',
      id: 'number',
      remark: 'string',
      taskName: 'string',
      taskStatus: 'number',
      taskType: 'number',
      userId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DatasetItemVO extends $tea.Model {
  asyncTaskList?: AsyncTaskVO[];
  datasetStatus?: number;
  datasetType?: number;
  digest?: string;
  fileSystem?: string;
  id?: string;
  keyName?: string;
  moreInfo?: string;
  path?: string;
  projectsLinked?: ProjectDetailsLiteVO[];
  recentTaskStatus?: number;
  remark?: string;
  schema?: string;
  tableName?: string;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      asyncTaskList: 'AsyncTaskList',
      datasetStatus: 'DatasetStatus',
      datasetType: 'DatasetType',
      digest: 'Digest',
      fileSystem: 'FileSystem',
      id: 'Id',
      keyName: 'KeyName',
      moreInfo: 'MoreInfo',
      path: 'Path',
      projectsLinked: 'ProjectsLinked',
      recentTaskStatus: 'RecentTaskStatus',
      remark: 'Remark',
      schema: 'Schema',
      tableName: 'TableName',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asyncTaskList: { 'type': 'array', 'itemType': AsyncTaskVO },
      datasetStatus: 'number',
      datasetType: 'number',
      digest: 'string',
      fileSystem: 'string',
      id: 'string',
      keyName: 'string',
      moreInfo: 'string',
      path: 'string',
      projectsLinked: { 'type': 'array', 'itemType': ProjectDetailsLiteVO },
      recentTaskStatus: 'number',
      remark: 'string',
      schema: 'string',
      tableName: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDataKeyVO extends $tea.Model {
  colName?: string;
  dbName?: string;
  mekId?: number;
  schemaName?: string;
  tblName?: string;
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      colName: 'ColName',
      dbName: 'DbName',
      mekId: 'MekId',
      schemaName: 'SchemaName',
      tblName: 'TblName',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      colName: 'string',
      dbName: 'string',
      mekId: 'number',
      schemaName: 'string',
      tblName: 'string',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportMasterKeyVO extends $tea.Model {
  encryptMekDataBase64?: string;
  mekId?: number;
  projectId?: number[];
  static names(): { [key: string]: string } {
    return {
      encryptMekDataBase64: 'EncryptMekDataBase64',
      mekId: 'MekId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      encryptMekDataBase64: 'string',
      mekId: 'number',
      projectId: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ProjectDetailsLiteVO extends $tea.Model {
  id?: number;
  projectName?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      projectName: 'ProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      projectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StsApplyVO extends $tea.Model {
  aliyunId?: string;
  duration?: number;
  static names(): { [key: string]: string } {
    return {
      aliyunId: 'AliyunId',
      duration: 'Duration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunId: 'string',
      duration: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StsTokenVO extends $tea.Model {
  accessKeyId?: string;
  accessKeySecret?: string;
  expiration?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      accessKeyId: 'AccessKeyId',
      accessKeySecret: 'AccessKeySecret',
      expiration: 'Expiration',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKeyId: 'string',
      accessKeySecret: 'string',
      expiration: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TeeEvidenceVO extends $tea.Model {
  cipherSuite?: string;
  enclaveData?: string;
  encryptPublicKeyPem?: string;
  encryptPublicKeyType?: string;
  modifiedDate?: string;
  publicKey?: string;
  publicKeyRaBase64?: string;
  publicKeyRaType?: string;
  quoteReport?: string;
  signPublicKeyPem?: string;
  signPublicKeyType?: string;
  trustedMrEnclave?: string[];
  static names(): { [key: string]: string } {
    return {
      cipherSuite: 'CipherSuite',
      enclaveData: 'EnclaveData',
      encryptPublicKeyPem: 'EncryptPublicKeyPem',
      encryptPublicKeyType: 'EncryptPublicKeyType',
      modifiedDate: 'ModifiedDate',
      publicKey: 'PublicKey',
      publicKeyRaBase64: 'PublicKeyRaBase64',
      publicKeyRaType: 'PublicKeyRaType',
      quoteReport: 'QuoteReport',
      signPublicKeyPem: 'SignPublicKeyPem',
      signPublicKeyType: 'SignPublicKeyType',
      trustedMrEnclave: 'TrustedMrEnclave',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cipherSuite: 'string',
      enclaveData: 'string',
      encryptPublicKeyPem: 'string',
      encryptPublicKeyType: 'string',
      modifiedDate: 'string',
      publicKey: 'string',
      publicKeyRaBase64: 'string',
      publicKeyRaType: 'string',
      quoteReport: 'string',
      signPublicKeyPem: 'string',
      signPublicKeyType: 'string',
      trustedMrEnclave: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UsersDetailsVO extends $tea.Model {
  approvalSignatureBase64?: string;
  approvalSqlTemplate?: string;
  approvalStatus?: string;
  creator?: number;
  dataReady?: number;
  id?: number;
  mekid?: number;
  pathPrefix?: string;
  resultParty?: number;
  uid?: string;
  userConfirmed?: number;
  userName?: string;
  userPublicKeyPem?: string;
  static names(): { [key: string]: string } {
    return {
      approvalSignatureBase64: 'ApprovalSignatureBase64',
      approvalSqlTemplate: 'ApprovalSqlTemplate',
      approvalStatus: 'ApprovalStatus',
      creator: 'Creator',
      dataReady: 'DataReady',
      id: 'Id',
      mekid: 'Mekid',
      pathPrefix: 'PathPrefix',
      resultParty: 'ResultParty',
      uid: 'Uid',
      userConfirmed: 'UserConfirmed',
      userName: 'UserName',
      userPublicKeyPem: 'UserPublicKeyPem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      approvalSignatureBase64: 'string',
      approvalSqlTemplate: 'string',
      approvalStatus: 'string',
      creator: 'number',
      dataReady: 'number',
      id: 'number',
      mekid: 'number',
      pathPrefix: 'string',
      resultParty: 'number',
      uid: 'string',
      userConfirmed: 'number',
      userName: 'string',
      userPublicKeyPem: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDesensitizationRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The parameters of the algorithm.
   */
  functionParams?: { [key: string]: string }[];
  /**
   * @remarks
   * The type of the masking algorithm.
   * 
   * Valid values:
   * 
   * *   FIX_POS : masks characters in the specified position.
   * *   DATE_ROUNDING: rounds the date.
   * *   PLAINTEXT: does not mask data.
   * *   SHA1: masks characters by using the secure hash algorithm 1 (SHA-1)
   * *   HMAC: masks characters by using the hash-based message authentication code (HMAC).
   * *   STRING_TRANSFORM: shift characters.
   * *   NUMBER_ROUNDING: rounds numbers.
   * *   AES: masks characters by using the advanced encryption standard (AES) algorithm.
   * *   SHA256: masks characters by using SHA-256 algorithm.
   * *   DES: masks characters by using the data encryption standard (DES) algorithm.
   * *   MAP_REPLACE: masks the mapped data.
   * *   FIX_CHAR: masks fixed characters.
   * *   DEFAULT: masks all characters.
   * *   RANDOM_REPLACE: randomly replaces characters.
   * *   MD5: masks characters by using the MD5 algorithm.
   * 
   * This parameter is required.
   * 
   * @example
   * MD5
   */
  functionType?: string;
  /**
   * @remarks
   * The description of the rule.
   * 
   * @example
   * hash algorithm
   */
  ruleDescription?: string;
  /**
   * @remarks
   * The name of the rule.
   * 
   * This parameter is required.
   * 
   * @example
   * desensitization algorithm test
   */
  ruleName?: string;
  /**
   * @remarks
   * The masking algorithm.
   * 
   * Valid values:
   * 
   * *   PLAINTEXT
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   TRANSFORM
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   ENCRYPT
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   REPLACE
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   HASH
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   MASK
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * This parameter is required.
   * 
   * @example
   * HASH
   */
  ruleType?: string;
  /**
   * @remarks
   * The tenant ID.
   * 
   * >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the "Manage DMS tenants" topic.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      functionParams: 'FunctionParams',
      functionType: 'FunctionType',
      ruleDescription: 'RuleDescription',
      ruleName: 'RuleName',
      ruleType: 'RuleType',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionParams: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'string' } },
      functionType: 'string',
      ruleDescription: 'string',
      ruleName: 'string',
      ruleType: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDesensitizationRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code that is returned.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message that is returned.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0C1CB646-1DE4-4AD0-B4A4-7D47DD52E931
   */
  requestId?: string;
  /**
   * @remarks
   * The ID generated for the data masking rule.
   * 
   * @example
   * 35***
   */
  ruleId?: number;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      ruleId: 'RuleId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      ruleId: 'number',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDesensitizationRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddDesensitizationRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddDesensitizationRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddInstanceRequest extends $tea.Model {
  /**
   * @example
   * dblink_test
   */
  dataLinkName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test***
   */
  databasePassword?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * testsdb
   */
  databaseUser?: string;
  /**
   * @example
   * 27****
   */
  dbaId?: number;
  /**
   * @example
   * 2
   */
  ddlOnline?: number;
  /**
   * @example
   * i-2zei9gs1t7h8l7ac****
   */
  ecsInstanceId?: string;
  /**
   * @example
   * cn-hangzhou
   */
  ecsRegion?: string;
  /**
   * @example
   * Y
   */
  enableSellCommon?: string;
  /**
   * @example
   * Y
   */
  enableSellSitd?: string;
  /**
   * @example
   * NULL
   */
  enableSellStable?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * Y
   */
  enableSellTrust?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * product
   */
  envType?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 86400
   */
  exportTimeout?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 172.XX.XXX.254
   */
  host?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  instanceAlias?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * RDS
   */
  instanceSource?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * MySQL
   */
  instanceType?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * VPC
   */
  networkType?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 3306
   */
  port?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 7200
   */
  queryTimeout?: number;
  safeRule?: string;
  /**
   * @example
   * testSid
   */
  sid?: string;
  /**
   * @example
   * false
   */
  skipTest?: boolean;
  /**
   * @example
   * 31***
   */
  templateId?: number;
  /**
   * @example
   * INNER
   */
  templateType?: string;
  /**
   * @example
   * 23****
   */
  tid?: number;
  /**
   * @example
   * 1
   */
  useDsql?: number;
  useSsl?: number;
  /**
   * @example
   * vpc-2zef4o1hu7ljd****
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      dataLinkName: 'DataLinkName',
      databasePassword: 'DatabasePassword',
      databaseUser: 'DatabaseUser',
      dbaId: 'DbaId',
      ddlOnline: 'DdlOnline',
      ecsInstanceId: 'EcsInstanceId',
      ecsRegion: 'EcsRegion',
      enableSellCommon: 'EnableSellCommon',
      enableSellSitd: 'EnableSellSitd',
      enableSellStable: 'EnableSellStable',
      enableSellTrust: 'EnableSellTrust',
      envType: 'EnvType',
      exportTimeout: 'ExportTimeout',
      host: 'Host',
      instanceAlias: 'InstanceAlias',
      instanceSource: 'InstanceSource',
      instanceType: 'InstanceType',
      networkType: 'NetworkType',
      port: 'Port',
      queryTimeout: 'QueryTimeout',
      safeRule: 'SafeRule',
      sid: 'Sid',
      skipTest: 'SkipTest',
      templateId: 'TemplateId',
      templateType: 'TemplateType',
      tid: 'Tid',
      useDsql: 'UseDsql',
      useSsl: 'UseSsl',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataLinkName: 'string',
      databasePassword: 'string',
      databaseUser: 'string',
      dbaId: 'number',
      ddlOnline: 'number',
      ecsInstanceId: 'string',
      ecsRegion: 'string',
      enableSellCommon: 'string',
      enableSellSitd: 'string',
      enableSellStable: 'string',
      enableSellTrust: 'string',
      envType: 'string',
      exportTimeout: 'number',
      host: 'string',
      instanceAlias: 'string',
      instanceSource: 'string',
      instanceType: 'string',
      networkType: 'string',
      port: 'number',
      queryTimeout: 'number',
      safeRule: 'string',
      sid: 'string',
      skipTest: 'boolean',
      templateId: 'number',
      templateType: 'string',
      tid: 'number',
      useDsql: 'number',
      useSsl: 'number',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddInstanceResponseBody extends $tea.Model {
  /**
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @example
   * 0C1CB646-1DE4-4AD0-B4A4-7D47DD52E931
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLhMembersRequest extends $tea.Model {
  /**
   * @remarks
   * The information about the users to be added.
   * 
   * This parameter is required.
   */
  members?: AddLhMembersRequestMembers[];
  /**
   * @remarks
   * The ID of the object.
   * 
   * *   If the object is a workspace, you can call the [GetLhSpaceByName](https://help.aliyun.com/document_detail/424379.html) operation to obtain the workspace ID.
   * *   If the object is a task flow, you can call the [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to obtain the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  objectId?: number;
  /**
   * @remarks
   * The type of the object. Valid values:
   * 
   * *   **0**: workspace
   * *   **1**: task flow
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  objectType?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3000
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      members: 'Members',
      objectId: 'ObjectId',
      objectType: 'ObjectType',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      members: { 'type': 'array', 'itemType': AddLhMembersRequestMembers },
      objectId: 'number',
      objectType: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLhMembersShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The information about the users to be added.
   * 
   * This parameter is required.
   */
  membersShrink?: string;
  /**
   * @remarks
   * The ID of the object.
   * 
   * *   If the object is a workspace, you can call the [GetLhSpaceByName](https://help.aliyun.com/document_detail/424379.html) operation to obtain the workspace ID.
   * *   If the object is a task flow, you can call the [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to obtain the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  objectId?: number;
  /**
   * @remarks
   * The type of the object. Valid values:
   * 
   * *   **0**: workspace
   * *   **1**: task flow
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  objectType?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3000
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      membersShrink: 'Members',
      objectId: 'ObjectId',
      objectType: 'ObjectType',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      membersShrink: 'string',
      objectId: 'number',
      objectType: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLhMembersResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request fails.
   * 
   * @example
   * 403
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request fails.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 31853A2B-DC9D-5B39-8492-D2AC8BCF550E
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**: The request is successful.
   * *   **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLhMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddLhMembersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddLhMembersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLogicTableRouteConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The routing algorithm expression. For more information about how to configure a routing algorithm expression, see [Configure a routing algorithm](https://www.alibabacloud.com/help/en/data-management-service/latest/configure-a-routing-algorithm).
   * 
   * This parameter is required.
   * 
   * @example
   * #id#%16
   */
  routeExpr?: string;
  /**
   * @remarks
   * The unique key of the routing algorithm. 
   * 
   * > - You can create a custom unique key for the routing algorithm. No requirements are imposed on custom unique keys.
   * > - The unique key of the routing algorithm in the same logical table must be unique.
   * 
   * This parameter is required.
   * 
   * @example
   * id-hash-mod16
   */
  routeKey?: string;
  /**
   * @remarks
   * The ID of the logical table. You can call the [ListLogicTables](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogictables) operation to query the ID of the logical table.
   * 
   * This parameter is required.
   * 
   * @example
   * 4****
   */
  tableId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the tenant ID.
   * 
   * @example
   * 4***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      routeExpr: 'RouteExpr',
      routeKey: 'RouteKey',
      tableId: 'TableId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      routeExpr: 'string',
      routeKey: 'string',
      tableId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLogicTableRouteConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * can not find table, tableId : 11133
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * B43AD641-49C2-5299-9E06-1B37EC1B****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * - **true**: The request was successful.
   * - **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLogicTableRouteConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddLogicTableRouteConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddLogicTableRouteConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTaskFlowEdgesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 15***
   */
  dagId?: number;
  /**
   * @remarks
   * The list of edges of the task flow.
   * 
   * This parameter is required.
   */
  edges?: AddTaskFlowEdgesRequestEdges[];
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      edges: 'Edges',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      edges: { 'type': 'array', 'itemType': AddTaskFlowEdgesRequestEdges },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTaskFlowEdgesShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 15***
   */
  dagId?: number;
  /**
   * @remarks
   * The list of edges of the task flow.
   * 
   * This parameter is required.
   */
  edgesShrink?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      edgesShrink: 'Edges',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      edgesShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTaskFlowEdgesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of task flow edge IDs.
   */
  edgeIds?: AddTaskFlowEdgesResponseBodyEdgeIds;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * E5EE2B9E-2F95-57FA-B284-CB441CEE49D6
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      edgeIds: 'EdgeIds',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      edgeIds: AddTaskFlowEdgesResponseBodyEdgeIds,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTaskFlowEdgesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddTaskFlowEdgesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddTaskFlowEdgesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AnalyzeSQLLineageRequest extends $tea.Model {
  /**
   * @remarks
   * The database ID.
   * 
   * >  You can call one of the [SearchDatabase](https://help.aliyun.com/document_detail/141876.html), [ListDatabases](https://help.aliyun.com/document_detail/141873.html), and [GetDatabase](https://help.aliyun.com/document_detail/141869.html) operations to obtain the database ID provided in the DatabaseId response parameter.
   * 
   * This parameter is required.
   * 
   * @example
   * 123***
   */
  dbId?: number;
  /**
   * @remarks
   * The SQL statement.
   * 
   * This parameter is required.
   * 
   * @example
   * insert into a (id) select id from b;
   */
  sqlContent?: string;
  /**
   * @remarks
   * The tenant ID.
   * 
   * >  To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      sqlContent: 'SqlContent',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      sqlContent: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AnalyzeSQLLineageResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * Returned data set of SQL lineage.
   */
  lineageResult?: AnalyzeSQLLineageResponseBodyLineageResult;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * B4B07137-F6AE-4756-8474-7F92BB6C4E04
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      lineageResult: 'LineageResult',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      lineageResult: AnalyzeSQLLineageResponseBodyLineageResult,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AnalyzeSQLLineageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AnalyzeSQLLineageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AnalyzeSQLLineageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApproveOrderRequest extends $tea.Model {
  /**
   * @remarks
   * If ApprovalType is set to ADD_APPROVAL_NODE, you need to specify this parameter. The ID of the user that is added as the new approval node. This node must be a user-defined approval node. You can call the ListUserDefineWorkFlowNodes operation to obtain the value of this parameter.
   * 
   * @example
   * 1
   */
  approvalNodeId?: number;
  /**
   * @remarks
   * If ApprovalType is set to ADD_APPROVAL_NODE, you need to specify this parameter. The position of the new approval node. Valid values:
   * 
   * *   **PRE_ADD_APPROVAL_NODE**: before the current approval node.
   * *   **POST_ADD_APPROVAL_NODE**: after the current approval node.
   * 
   * @example
   * POST_ADD_APPROVAL_NODE
   */
  approvalNodePos?: string;
  /**
   * @remarks
   * The action that you want to perform on the ticket. Valid values:
   * 
   * *   **AGREE**
   * *   **CANCEL**
   * *   **REJECT**
   * *   **TRANSFER**
   * *   **ADD_APPROVAL_NODE**
   * 
   * This parameter is required.
   * 
   * @example
   * agree
   */
  approvalType?: string;
  /**
   * @remarks
   * The description of the ticket.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * The ID of the user to which the ticket is transferred. If ApprovalType is set to TRANSFER, you need to specify this parameter.
   * 
   * @example
   * 12***
   */
  newApprover?: number;
  newApproverList?: string;
  /**
   * @remarks
   * The ID of the user that transfers the ticket to another user. The default value is the ID of the current user. If the current user is an administrator or a database administrator (DBA), the user can change the value of this parameter to the ID of another user.
   * 
   * @example
   * 23***
   */
  oldApprover?: number;
  realLoginUserUid?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to obtain the tenant ID.
   * 
   * @example
   * -1
   */
  tid?: number;
  /**
   * @remarks
   * The ID of the approval process. You can call the [GetOrderBaseInfo](https://help.aliyun.com/document_detail/144642.html) operation to obtain the ID of the approval process.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  workflowInstanceId?: number;
  static names(): { [key: string]: string } {
    return {
      approvalNodeId: 'ApprovalNodeId',
      approvalNodePos: 'ApprovalNodePos',
      approvalType: 'ApprovalType',
      comment: 'Comment',
      newApprover: 'NewApprover',
      newApproverList: 'NewApproverList',
      oldApprover: 'OldApprover',
      realLoginUserUid: 'RealLoginUserUid',
      tid: 'Tid',
      workflowInstanceId: 'WorkflowInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      approvalNodeId: 'number',
      approvalNodePos: 'string',
      approvalType: 'string',
      comment: 'string',
      newApprover: 'number',
      newApproverList: 'string',
      oldApprover: 'number',
      realLoginUserUid: 'string',
      tid: 'number',
      workflowInstanceId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApproveOrderResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 427688B8-ADFB-4C4E-9D45-EF5C1FD6E23D
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApproveOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ApproveOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ApproveOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BackFillRequest extends $tea.Model {
  /**
   * @remarks
   * The running sequence of task flows for data backfill. Valid values:
   * 
   * *   **0**: reverse chronological order.
   * *   **1**: chronological order. This is the default value.
   * 
   * @example
   * 0
   */
  asc?: boolean;
  /**
   * @remarks
   * The date for the data to be backfilled. This parameter is required if you specify a date for data backfill.
   * 
   * @example
   * 2022-01-14
   */
  backFillDate?: string;
  /**
   * @remarks
   * The start date of the date range for the data to be backfilled. This parameter is required if you specify a date range for data backfill.
   * 
   * @example
   * 2022-01-14
   */
  backFillDateBegin?: string;
  /**
   * @remarks
   * The end date of the date range for the data to be backfilled. This parameter is required if you specify a date range for data backfill.
   * 
   * @example
   * 2022-09-29
   */
  backFillDateEnd?: string;
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 15***
   */
  dagId?: number;
  /**
   * @remarks
   * Filter condition, which specifies the list of node IDs in the task flow that do not need to supplement data.
   */
  filterNodeIds?: number[];
  /**
   * @remarks
   * The ID of the historical task flow.
   * 
   * @example
   * 16***
   */
  historyDagId?: number;
  /**
   * @remarks
   * The interval at which data backfill is performed. Unit: hours. Minimum value: 1. Default value: 24.
   * 
   * @example
   * 24
   */
  interval?: number;
  /**
   * @remarks
   * Specifies whether to run descendant nodes. Default value: true.
   * 
   * @example
   * true
   */
  isTriggerSubTree?: boolean;
  /**
   * @remarks
   * The number of nodes for which you want to backfill data.
   */
  startNodeIds?: number[];
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      backFillDate: 'BackFillDate',
      backFillDateBegin: 'BackFillDateBegin',
      backFillDateEnd: 'BackFillDateEnd',
      dagId: 'DagId',
      filterNodeIds: 'FilterNodeIds',
      historyDagId: 'HistoryDagId',
      interval: 'Interval',
      isTriggerSubTree: 'IsTriggerSubTree',
      startNodeIds: 'StartNodeIds',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'boolean',
      backFillDate: 'string',
      backFillDateBegin: 'string',
      backFillDateEnd: 'string',
      dagId: 'number',
      filterNodeIds: { 'type': 'array', 'itemType': 'number' },
      historyDagId: 'number',
      interval: 'number',
      isTriggerSubTree: 'boolean',
      startNodeIds: { 'type': 'array', 'itemType': 'number' },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BackFillShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The running sequence of task flows for data backfill. Valid values:
   * 
   * *   **0**: reverse chronological order.
   * *   **1**: chronological order. This is the default value.
   * 
   * @example
   * 0
   */
  asc?: boolean;
  /**
   * @remarks
   * The date for the data to be backfilled. This parameter is required if you specify a date for data backfill.
   * 
   * @example
   * 2022-01-14
   */
  backFillDate?: string;
  /**
   * @remarks
   * The start date of the date range for the data to be backfilled. This parameter is required if you specify a date range for data backfill.
   * 
   * @example
   * 2022-01-14
   */
  backFillDateBegin?: string;
  /**
   * @remarks
   * The end date of the date range for the data to be backfilled. This parameter is required if you specify a date range for data backfill.
   * 
   * @example
   * 2022-09-29
   */
  backFillDateEnd?: string;
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 15***
   */
  dagId?: number;
  /**
   * @remarks
   * Filter condition, which specifies the list of node IDs in the task flow that do not need to supplement data.
   */
  filterNodeIdsShrink?: string;
  /**
   * @remarks
   * The ID of the historical task flow.
   * 
   * @example
   * 16***
   */
  historyDagId?: number;
  /**
   * @remarks
   * The interval at which data backfill is performed. Unit: hours. Minimum value: 1. Default value: 24.
   * 
   * @example
   * 24
   */
  interval?: number;
  /**
   * @remarks
   * Specifies whether to run descendant nodes. Default value: true.
   * 
   * @example
   * true
   */
  isTriggerSubTree?: boolean;
  /**
   * @remarks
   * The number of nodes for which you want to backfill data.
   */
  startNodeIdsShrink?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      asc: 'Asc',
      backFillDate: 'BackFillDate',
      backFillDateBegin: 'BackFillDateBegin',
      backFillDateEnd: 'BackFillDateEnd',
      dagId: 'DagId',
      filterNodeIdsShrink: 'FilterNodeIds',
      historyDagId: 'HistoryDagId',
      interval: 'Interval',
      isTriggerSubTree: 'IsTriggerSubTree',
      startNodeIdsShrink: 'StartNodeIds',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asc: 'boolean',
      backFillDate: 'string',
      backFillDateBegin: 'string',
      backFillDateEnd: 'string',
      dagId: 'number',
      filterNodeIdsShrink: 'string',
      historyDagId: 'number',
      interval: 'number',
      isTriggerSubTree: 'boolean',
      startNodeIdsShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BackFillResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the execution record of the task flow.
   * 
   * @example
   * 47****
   */
  dagInstanceId?: number;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the node.
   * 
   * @example
   * 43****
   */
  nodeId?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 7FAD400F-7A5C-4193-8F9A-39D86C4F0231
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      dagInstanceId: 'DagInstanceId',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      nodeId: 'NodeId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagInstanceId: 'number',
      errorCode: 'string',
      errorMessage: 'string',
      nodeId: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BackFillResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BackFillResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BackFillResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BuyPayAsYouGoOrderRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the resource that you want to purchase.
   * 
   * *   **VersionType**: DMS that supports control modes
   * *   **SensitiveDataProtection**: DMS that supports sensitive data protection
   * 
   * This parameter is required.
   * 
   * @example
   * SensitiveDataProtection
   */
  commodityType?: string;
  /**
   * @remarks
   * The number of database instances that you want to use DMS to manage.
   * 
   * > A quota can be used for only one database instance.
   * 
   * This parameter is required.
   * 
   * @example
   * 7
   */
  insNum?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  /**
   * @remarks
   * The control mode of DMS. Valid values:
   * 
   * *   **stand**: Stable Change
   * *   **safety**: Security Collaboration
   * 
   * @example
   * stand
   */
  versionType?: string;
  static names(): { [key: string]: string } {
    return {
      commodityType: 'CommodityType',
      insNum: 'InsNum',
      tid: 'Tid',
      versionType: 'VersionType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commodityType: 'string',
      insNum: 'number',
      tid: 'number',
      versionType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BuyPayAsYouGoOrderResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * If the purchase is successful, the ID of the purchased instance is returned.
   * 
   * @example
   * dms_pre_public_cn-nif23l****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C51420E3-144A-4A94-B473-8662FCF4AD10
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      instanceId: 'InstanceId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      instanceId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BuyPayAsYouGoOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BuyPayAsYouGoOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BuyPayAsYouGoOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeColumnSecLevelRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the field. You can call the [ListSensitiveColumns](https://help.aliyun.com/document_detail/188103.html) operation to obtain the name of the field.
   * 
   * > You can also call the [ListColumns](https://help.aliyun.com/document_detail/141870.html) operation to obtain the name of the field.
   * 
   * This parameter is required.
   * 
   * @example
   * test_column
   */
  columnName?: string;
  /**
   * @remarks
   * The ID of the database. You can call the [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to obtain the ID of the database.
   * 
   * > You can also call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) operation to obtain the ID of a physical database and the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) operation to obtain the ID of a logical database.
   * 
   * This parameter is required.
   * 
   * @example
   * 325
   */
  dbId?: number;
  /**
   * @remarks
   * Specifies whether the database is a logical database. Valid values:
   * 
   * *   true: The database is a physical database.
   * *   false: The database is a logical database.
   * 
   * This parameter is required.
   * 
   * @example
   * false
   */
  isLogic?: boolean;
  /**
   * @remarks
   * The new sensitivity level of the field that you want to specify. Valid values:
   * 
   * *   INNER: low sensitivity level
   * *   SENSITIVE: medium sensitivity level
   * *   CONFIDENTIAL: high sensitivity level
   * 
   * This parameter is required.
   * 
   * @example
   * SENSITIVE
   */
  newLevel?: string;
  /**
   * @remarks
   * The name of the database. You can call the [ListSensitiveColumns](https://help.aliyun.com/document_detail/188103.html) operation to obtain the name of the database.
   * 
   * *   You can also call the [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to obtain the name of the database.
   * *   You can also call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) operation to obtain the name of a physical database and the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) operation to obtain the name of a logical database.
   * 
   * This parameter is required.
   * 
   * @example
   * test_schema
   */
  schemaName?: string;
  /**
   * @remarks
   * The name of the table. You can call the [ListSensitiveColumns](https://help.aliyun.com/document_detail/188103.html) operation to obtain the name of the table.
   * 
   * > You can also call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation to obtain the name of the table.
   * 
   * This parameter is required.
   * 
   * @example
   * test_table
   */
  tableName?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 43253
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      dbId: 'DbId',
      isLogic: 'IsLogic',
      newLevel: 'NewLevel',
      schemaName: 'SchemaName',
      tableName: 'TableName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      dbId: 'number',
      isLogic: 'boolean',
      newLevel: 'string',
      schemaName: 'string',
      tableName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeColumnSecLevelResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C51420E3-144A-4A94-B473-8662FCF4AD10
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true: The request was successful.
   * *   false: The request failed.
   * 
   * @example
   * false
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeColumnSecLevelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ChangeColumnSecLevelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ChangeColumnSecLevelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeColumnSecurityLevelRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test_column
   */
  columnName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 325**
   */
  dbId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * false
   */
  isLogic?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * S2
   */
  newSensitivityLevel?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test_schema
   */
  schemaName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test_table
   */
  tableName?: string;
  /**
   * @example
   * 10****
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      dbId: 'DbId',
      isLogic: 'IsLogic',
      newSensitivityLevel: 'NewSensitivityLevel',
      schemaName: 'SchemaName',
      tableName: 'TableName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      dbId: 'number',
      isLogic: 'boolean',
      newSensitivityLevel: 'string',
      schemaName: 'string',
      tableName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeColumnSecurityLevelResponseBody extends $tea.Model {
  /**
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @example
   * E103C5F9-DE47-53F2-BF34-D71DF38F****
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeColumnSecurityLevelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ChangeColumnSecurityLevelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ChangeColumnSecurityLevelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeLhDagOwnerRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to obtain the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 9***
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the user to be specified as the new owner of the task flow. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to obtain the user ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 50****
   */
  ownerUserId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      ownerUserId: 'OwnerUserId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      ownerUserId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeLhDagOwnerResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request fails.
   * 
   * @example
   * 403
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request fails.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9997630E-1993-5E6D-9DF1-4EFEE755FE31
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**: The request is successful.
   * *   **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeLhDagOwnerResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ChangeLhDagOwnerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ChangeLhDagOwnerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseOrderRequest extends $tea.Model {
  /**
   * @remarks
   * The reason why the ticket is closed.
   * 
   * This parameter is required.
   * 
   * @example
   * close reason
   */
  closeReason?: string;
  /**
   * @remarks
   * The ID of the ticket.
   * 
   * This parameter is required.
   * 
   * @example
   * 1343
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * -1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      closeReason: 'CloseReason',
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      closeReason: 'string',
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseOrderResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 427688B8-ADFB-4C4E-9D45-EF5C1FD6E23D
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CloseOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CloseOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CloseOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAuthorityTemplateRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the permission template.
   * 
   * @example
   * This template is used for business testing.
   */
  description?: string;
  /**
   * @remarks
   * The name of the permission template.
   * 
   * This parameter is required.
   * 
   * @example
   * Test template.
   */
  name?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAuthorityTemplateResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the permission template.
   */
  authorityTemplateView?: CreateAuthorityTemplateResponseBodyAuthorityTemplateView;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0C1CB646-1DE4-4AD0-B4A4-7D47DD52E931
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      authorityTemplateView: 'AuthorityTemplateView',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorityTemplateView: CreateAuthorityTemplateResponseBodyAuthorityTemplateView,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAuthorityTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateAuthorityTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateAuthorityTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataArchiveOrderRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the task.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * The parameters for archiving data.
   * 
   * This parameter is required.
   */
  param?: CreateDataArchiveOrderRequestParam;
  /**
   * @remarks
   * The ID of the parent ticket. A parent ticket is generated only when a child ticket is created.
   * 
   * @example
   * 123****
   */
  parentId?: number;
  /**
   * @remarks
   * The type of the plug-in. Default value: DATA_ARCHIVE.
   * 
   * @example
   * DATA_ARCHIVE
   */
  pluginType?: string;
  /**
   * @remarks
   * The list of the related users.
   */
  relatedUserList?: string[];
  /**
   * @remarks
   * The tenant ID. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      param: 'Param',
      parentId: 'ParentId',
      pluginType: 'PluginType',
      relatedUserList: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      param: CreateDataArchiveOrderRequestParam,
      parentId: 'number',
      pluginType: 'string',
      relatedUserList: { 'type': 'array', 'itemType': 'string' },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataArchiveOrderShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the task.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * The parameters for archiving data.
   * 
   * This parameter is required.
   */
  paramShrink?: string;
  /**
   * @remarks
   * The ID of the parent ticket. A parent ticket is generated only when a child ticket is created.
   * 
   * @example
   * 123****
   */
  parentId?: number;
  /**
   * @remarks
   * The type of the plug-in. Default value: DATA_ARCHIVE.
   * 
   * @example
   * DATA_ARCHIVE
   */
  pluginType?: string;
  /**
   * @remarks
   * The list of the related users.
   */
  relatedUserListShrink?: string;
  /**
   * @remarks
   * The tenant ID. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      paramShrink: 'Param',
      parentId: 'ParentId',
      pluginType: 'PluginType',
      relatedUserListShrink: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      paramShrink: 'string',
      parentId: 'number',
      pluginType: 'string',
      relatedUserListShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataArchiveOrderResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the data archiving ticket.
   */
  createOrderResult?: number[];
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request, which is used to query logs and troubleshoot issues.
   * 
   * @example
   * 283C461F-11D8-48AA-B695-DF092DA32AF3
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: { 'type': 'array', 'itemType': 'number' },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataArchiveOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDataArchiveOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDataArchiveOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataCorrectOrderRequest extends $tea.Model {
  /**
   * @remarks
   * The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to obtain the attachment key from the value of the AttachmentKey parameter.
   * 
   * @example
   * order_attachment.txt
   */
  attachmentKey?: string;
  /**
   * @remarks
   * The purpose or objective of the data change. This parameter is used to help reduce unnecessary communication.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * The parameters of the ticket.
   * 
   * This parameter is required.
   */
  param?: CreateDataCorrectOrderRequestParam;
  realLoginUserUid?: string;
  /**
   * @remarks
   * The stakeholders of the data change. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
   */
  relatedUserList?: number[];
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      param: 'Param',
      realLoginUserUid: 'RealLoginUserUid',
      relatedUserList: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      param: CreateDataCorrectOrderRequestParam,
      realLoginUserUid: 'string',
      relatedUserList: { 'type': 'array', 'itemType': 'number' },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataCorrectOrderShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to obtain the attachment key from the value of the AttachmentKey parameter.
   * 
   * @example
   * order_attachment.txt
   */
  attachmentKey?: string;
  /**
   * @remarks
   * The purpose or objective of the data change. This parameter is used to help reduce unnecessary communication.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * The parameters of the ticket.
   * 
   * This parameter is required.
   */
  paramShrink?: string;
  realLoginUserUid?: string;
  /**
   * @remarks
   * The stakeholders of the data change. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
   */
  relatedUserListShrink?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      paramShrink: 'Param',
      realLoginUserUid: 'RealLoginUserUid',
      relatedUserListShrink: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      paramShrink: 'string',
      realLoginUserUid: 'string',
      relatedUserListShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataCorrectOrderResponseBody extends $tea.Model {
  /**
   * @remarks
   * The IDs of the tickets.
   */
  createOrderResult?: number[];
  /**
   * @remarks
   * The error code returned if the request fails.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request fails.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0C1CB646-1DE4-4AD0-B4A4-7D47DD52E931
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**: The request is successful.
   * *   **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: { 'type': 'array', 'itemType': 'number' },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataCorrectOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDataCorrectOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDataCorrectOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataCronClearOrderRequest extends $tea.Model {
  /**
   * @remarks
   * The key of the attachment for the ticket. The attachment provides more instructions for this operation.
   * 
   * You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to query the key of the attachment.
   * 
   * @example
   * order_attachement.txt
   */
  attachmentKey?: string;
  /**
   * @remarks
   * The purpose or objective of the data change. This reduces unnecessary communication.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * The parameters of the ticket.
   * 
   * This parameter is required.
   */
  param?: CreateDataCronClearOrderRequestParam;
  /**
   * @remarks
   * The stakeholders of this operation. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than Data Management (DMS) administrators and database administrators (DBAs) are not allowed to view the ticket details.
   */
  relatedUserList?: number[];
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  The ID of the tenant is displayed when you move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the Manage DMS tenants topic.
   * 
   * @example
   * 123454324
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      param: 'Param',
      relatedUserList: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      param: CreateDataCronClearOrderRequestParam,
      relatedUserList: { 'type': 'array', 'itemType': 'number' },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataCronClearOrderShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The key of the attachment for the ticket. The attachment provides more instructions for this operation.
   * 
   * You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to query the key of the attachment.
   * 
   * @example
   * order_attachement.txt
   */
  attachmentKey?: string;
  /**
   * @remarks
   * The purpose or objective of the data change. This reduces unnecessary communication.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * The parameters of the ticket.
   * 
   * This parameter is required.
   */
  paramShrink?: string;
  /**
   * @remarks
   * The stakeholders of this operation. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than Data Management (DMS) administrators and database administrators (DBAs) are not allowed to view the ticket details.
   */
  relatedUserListShrink?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  The ID of the tenant is displayed when you move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the Manage DMS tenants topic.
   * 
   * @example
   * 123454324
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      paramShrink: 'Param',
      relatedUserListShrink: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      paramShrink: 'string',
      relatedUserListShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataCronClearOrderResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the ticket.
   */
  createOrderResult?: number[];
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0C1CB646-1DE4-4AD0-B4A4-7D47DD52E931
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: { 'type': 'array', 'itemType': 'number' },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataCronClearOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDataCronClearOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDataCronClearOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataExportOrderRequest extends $tea.Model {
  /**
   * @remarks
   * The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to obtain the attachment key.
   * 
   * @example
   * order_attachment.txt
   */
  attachmentKey?: string;
  /**
   * @remarks
   * The purpose or objective of the ticket. This parameter helps reduce unnecessary communication.
   * 
   * This parameter is required.
   * 
   * @example
   * business_test
   */
  comment?: string;
  /**
   * @remarks
   * The ID of the parent ticket.
   * 
   * @example
   * 877****
   */
  parentId?: number;
  /**
   * @remarks
   * The parameters of the ticket.
   * 
   * This parameter is required.
   */
  pluginParam?: CreateDataExportOrderRequestPluginParam;
  realLoginUserUid?: string;
  /**
   * @remarks
   * The stakeholders involved in this operation.
   */
  relatedUserList?: number[];
  /**
   * @remarks
   * The tenant ID.
   * 
   * > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the "Manage DMS tenants" topic.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      parentId: 'ParentId',
      pluginParam: 'PluginParam',
      realLoginUserUid: 'RealLoginUserUid',
      relatedUserList: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      parentId: 'number',
      pluginParam: CreateDataExportOrderRequestPluginParam,
      realLoginUserUid: 'string',
      relatedUserList: { 'type': 'array', 'itemType': 'number' },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataExportOrderShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to obtain the attachment key.
   * 
   * @example
   * order_attachment.txt
   */
  attachmentKey?: string;
  /**
   * @remarks
   * The purpose or objective of the ticket. This parameter helps reduce unnecessary communication.
   * 
   * This parameter is required.
   * 
   * @example
   * business_test
   */
  comment?: string;
  /**
   * @remarks
   * The ID of the parent ticket.
   * 
   * @example
   * 877****
   */
  parentId?: number;
  /**
   * @remarks
   * The parameters of the ticket.
   * 
   * This parameter is required.
   */
  pluginParamShrink?: string;
  realLoginUserUid?: string;
  /**
   * @remarks
   * The stakeholders involved in this operation.
   */
  relatedUserListShrink?: string;
  /**
   * @remarks
   * The tenant ID.
   * 
   * > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the "Manage DMS tenants" topic.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      parentId: 'ParentId',
      pluginParamShrink: 'PluginParam',
      realLoginUserUid: 'RealLoginUserUid',
      relatedUserListShrink: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      parentId: 'number',
      pluginParamShrink: 'string',
      realLoginUserUid: 'string',
      relatedUserListShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataExportOrderResponseBody extends $tea.Model {
  /**
   * @remarks
   * The content of the ticket.
   */
  createOrderResult?: CreateDataExportOrderResponseBodyCreateOrderResult;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The request ID. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * 7FAD400F-7A5C-4193-8F9A-39D86C4F0231
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: CreateDataExportOrderResponseBodyCreateOrderResult,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataExportOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDataExportOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDataExportOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataImportOrderRequest extends $tea.Model {
  /**
   * @remarks
   * The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to obtain the attachment key from the value of the AttachmentKey parameter.
   * 
   * @example
   * order_attachment.txt
   */
  attachmentKey?: string;
  /**
   * @remarks
   * The purpose or objective of the data import. This parameter is used to help reduce unnecessary communication.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * The parameters of the ticket.
   * 
   * This parameter is required.
   */
  param?: CreateDataImportOrderRequestParam;
  /**
   * @remarks
   * The stakeholders of the data import. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
   */
  relatedUserList?: number[];
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      param: 'Param',
      relatedUserList: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      param: CreateDataImportOrderRequestParam,
      relatedUserList: { 'type': 'array', 'itemType': 'number' },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataImportOrderShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to obtain the attachment key from the value of the AttachmentKey parameter.
   * 
   * @example
   * order_attachment.txt
   */
  attachmentKey?: string;
  /**
   * @remarks
   * The purpose or objective of the data import. This parameter is used to help reduce unnecessary communication.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * The parameters of the ticket.
   * 
   * This parameter is required.
   */
  paramShrink?: string;
  /**
   * @remarks
   * The stakeholders of the data import. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
   */
  relatedUserListShrink?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      paramShrink: 'Param',
      relatedUserListShrink: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      paramShrink: 'string',
      relatedUserListShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataImportOrderResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the ticket.
   */
  createOrderResult?: number[];
  /**
   * @remarks
   * The error code returned if the request fails.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request fails.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0C1CB646-1DE4-4AD0-B4A4-7D47DD52E931
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**: The request is successful.
   * *   **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: { 'type': 'array', 'itemType': 'number' },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataImportOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDataImportOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDataImportOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataTrackOrderRequest extends $tea.Model {
  /**
   * @remarks
   * The purpose or objective of the data tracking ticket. This parameter is used to help reduce unnecessary communication.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * The parameters of the ticket.
   * 
   * This parameter is required.
   */
  param?: CreateDataTrackOrderRequestParam;
  /**
   * @remarks
   * The IDs of the operators that are related to the ticket.
   */
  relatedUserList?: string[];
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      param: 'Param',
      relatedUserList: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      param: CreateDataTrackOrderRequestParam,
      relatedUserList: { 'type': 'array', 'itemType': 'string' },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataTrackOrderShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The purpose or objective of the data tracking ticket. This parameter is used to help reduce unnecessary communication.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * The parameters of the ticket.
   * 
   * This parameter is required.
   */
  paramShrink?: string;
  /**
   * @remarks
   * The IDs of the operators that are related to the ticket.
   */
  relatedUserListShrink?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      paramShrink: 'Param',
      relatedUserListShrink: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      paramShrink: 'string',
      relatedUserListShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataTrackOrderResponseBody extends $tea.Model {
  /**
   * @remarks
   * The IDs of the data tracking tickets.
   */
  createOrderResult?: number[];
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 283C461F-11D8-48AA-B695-DF092DA32AF3
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: { 'type': 'array', 'itemType': 'number' },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataTrackOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDataTrackOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDataTrackOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDatabaseExportOrderRequest extends $tea.Model {
  /**
   * @remarks
   * The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to obtain the attachment key.
   * 
   * @example
   * order_attachment.txt
   */
  attachmentKey?: string;
  /**
   * @remarks
   * The purpose or objective of the ticket. This parameter helps reduce unnecessary communication.
   * 
   * This parameter is required.
   * 
   * @example
   * document_test
   */
  comment?: string;
  /**
   * @remarks
   * The ID of the parent ticket.
   * 
   * @example
   * 877****
   */
  parentId?: number;
  /**
   * @remarks
   * The parameters of the ticket.
   * 
   * This parameter is required.
   */
  pluginParam?: CreateDatabaseExportOrderRequestPluginParam;
  /**
   * @remarks
   * The stakeholders involved in this operation.
   */
  relatedUserList?: number[];
  /**
   * @remarks
   * The tenant ID.
   * 
   * > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the "Manage DMS tenants" topic.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      parentId: 'ParentId',
      pluginParam: 'PluginParam',
      relatedUserList: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      parentId: 'number',
      pluginParam: CreateDatabaseExportOrderRequestPluginParam,
      relatedUserList: { 'type': 'array', 'itemType': 'number' },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDatabaseExportOrderShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to obtain the attachment key.
   * 
   * @example
   * order_attachment.txt
   */
  attachmentKey?: string;
  /**
   * @remarks
   * The purpose or objective of the ticket. This parameter helps reduce unnecessary communication.
   * 
   * This parameter is required.
   * 
   * @example
   * document_test
   */
  comment?: string;
  /**
   * @remarks
   * The ID of the parent ticket.
   * 
   * @example
   * 877****
   */
  parentId?: number;
  /**
   * @remarks
   * The parameters of the ticket.
   * 
   * This parameter is required.
   */
  pluginParamShrink?: string;
  /**
   * @remarks
   * The stakeholders involved in this operation.
   */
  relatedUserListShrink?: string;
  /**
   * @remarks
   * The tenant ID.
   * 
   * > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the "Manage DMS tenants" topic.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      parentId: 'ParentId',
      pluginParamShrink: 'PluginParam',
      relatedUserListShrink: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      parentId: 'number',
      pluginParamShrink: 'string',
      relatedUserListShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDatabaseExportOrderResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the ticket.
   */
  createOrderResult?: CreateDatabaseExportOrderResponseBodyCreateOrderResult;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The request ID. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * 0C1CB646-1DE4-4AD0-B4A4-7D47DD52E931
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: CreateDatabaseExportOrderResponseBodyCreateOrderResult,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDatabaseExportOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDatabaseExportOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDatabaseExportOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFreeLockCorrectOrderRequest extends $tea.Model {
  /**
   * @remarks
   * The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to obtain the attachment key from the value of the AttachmentKey parameter.
   * 
   * @example
   * order_attachment.txt
   */
  attachmentKey?: string;
  /**
   * @remarks
   * The purpose or objective of the data change. This parameter is used to help reduce unnecessary communication.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * The parameters of the ticket.
   * 
   * This parameter is required.
   */
  param?: CreateFreeLockCorrectOrderRequestParam;
  /**
   * @remarks
   * The stakeholders of the data change. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
   */
  relatedUserList?: number[];
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      param: 'Param',
      relatedUserList: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      param: CreateFreeLockCorrectOrderRequestParam,
      relatedUserList: { 'type': 'array', 'itemType': 'number' },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFreeLockCorrectOrderShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to obtain the attachment key from the value of the AttachmentKey parameter.
   * 
   * @example
   * order_attachment.txt
   */
  attachmentKey?: string;
  /**
   * @remarks
   * The purpose or objective of the data change. This parameter is used to help reduce unnecessary communication.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * The parameters of the ticket.
   * 
   * This parameter is required.
   */
  paramShrink?: string;
  /**
   * @remarks
   * The stakeholders of the data change. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
   */
  relatedUserListShrink?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      paramShrink: 'Param',
      relatedUserListShrink: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      paramShrink: 'string',
      relatedUserListShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFreeLockCorrectOrderResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the ticket.
   */
  createOrderResult?: number[];
  /**
   * @remarks
   * The error code returned if the request fails.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request fails.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0C1CB646-1DE4-4AD0-B4A4-7D47DD52E931
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**: The request is successful.
   * *   **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: { 'type': 'array', 'itemType': 'number' },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFreeLockCorrectOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateFreeLockCorrectOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateFreeLockCorrectOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLakeHouseSpaceRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the workspace.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The ID of the development database. You can call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 2435****
   */
  devDbId?: string;
  /**
   * @remarks
   * The type of the database. Valid values:
   * 
   * *   **14**: AnalyticDB for MySQL
   * *   **18**: AnalyticDB for PostgreSQL
   * 
   * This parameter is required.
   * 
   * @example
   * 14
   */
  dwDbType?: string;
  /**
   * @remarks
   * The mode in which the workspace runs. Valid values:
   * 
   * *   **0**: basic mode. This mode is unavailable.
   * *   **1**: standard mode.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  mode?: string;
  /**
   * @remarks
   * The ID of the production database. You can call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to obtain the ID.
   * 
   * @example
   * 2442****
   */
  prodDbId?: string;
  /**
   * @remarks
   * The configuration of the workspace. Valid values:
   * 
   * *   **skipManualRunCheck**: No security rule check is required in the trial run phase.
   * *   **skipPublishApprove**: No approval is required for publishing and O\\&M.
   * 
   * This parameter is required.
   * 
   * @example
   * {\\"skipManualRunCheck\\":true,\\"skipPublishApprove\\":true}
   */
  spaceConfig?: string;
  /**
   * @remarks
   * The name of the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * test_space
   */
  spaceName?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      devDbId: 'DevDbId',
      dwDbType: 'DwDbType',
      mode: 'Mode',
      prodDbId: 'ProdDbId',
      spaceConfig: 'SpaceConfig',
      spaceName: 'SpaceName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      devDbId: 'string',
      dwDbType: 'string',
      mode: 'string',
      prodDbId: 'string',
      spaceConfig: 'string',
      spaceName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLakeHouseSpaceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request fails.
   * 
   * @example
   * InvalidParameterValid
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request fails.
   * 
   * @example
   * Invalid parameters: space name,mode,prod db id,db type,config.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 7FAD400F-7A5C-4193-8F9A-39D86C4F0231
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * @example
   * 24
   */
  spaceId?: number;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**: The request is successful.
   * *   **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      spaceId: 'SpaceId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      spaceId: 'number',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLakeHouseSpaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateLakeHouseSpaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateLakeHouseSpaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLogicDatabaseRequest extends $tea.Model {
  /**
   * @remarks
   * The alias of the logical database.
   * 
   * This parameter is required.
   * 
   * @example
   * test_logic_db
   */
  alias?: string;
  /**
   * @remarks
   * The IDs of the physical databases that compose the logical database. You can specify one or more database IDs. You can call the [ListDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to query the IDs of the physical databases.
   * 
   * This parameter is required.
   */
  databaseIds?: number[];
  /**
   * @remarks
   * The ID of the tenant. 
   * 
   * >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      databaseIds: 'DatabaseIds',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      databaseIds: { 'type': 'array', 'itemType': 'number' },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLogicDatabaseShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The alias of the logical database.
   * 
   * This parameter is required.
   * 
   * @example
   * test_logic_db
   */
  alias?: string;
  /**
   * @remarks
   * The IDs of the physical databases that compose the logical database. You can specify one or more database IDs. You can call the [ListDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to query the IDs of the physical databases.
   * 
   * This parameter is required.
   */
  databaseIdsShrink?: string;
  /**
   * @remarks
   * The ID of the tenant. 
   * 
   * >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      databaseIdsShrink: 'DatabaseIds',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      databaseIdsShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLogicDatabaseResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the logical database.
   * 
   * @example
   * 1***
   */
  logicDbId?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C51420E3-144A-4A94-B473-8662FCF4AD10
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * - true: The request is successful.
   * - false: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      logicDbId: 'LogicDbId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      logicDbId: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLogicDatabaseResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateLogicDatabaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateLogicDatabaseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrderRequest extends $tea.Model {
  /**
   * @remarks
   * The key of an attachment that is returned after the attachment is uploaded. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to query the key of the attachment.
   * 
   * @example
   * test_AttachmentKey
   */
  attachmentKey?: string;
  /**
   * @remarks
   * The description of the ticket to be created.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * The ticket creation parameter. The value is a JSON string. The value of this parameter differs based on the type of the ticket. For more information, see the **PluginParam parameter** section in this topic.
   * 
   * This parameter is required.
   * 
   * @example
   * {PluginParam_test}
   */
  pluginParam?: { [key: string]: any };
  /**
   * @remarks
   * The type of the ticket. For more information, see [PluginType parameter](https://help.aliyun.com/document_detail/429109.html).
   * 
   * This parameter is required.
   * 
   * @example
   * DATA_EXPORT
   */
  pluginType?: string;
  /**
   * @remarks
   * The IDs of the stakeholders that are involved in the ticket. Separate multiple IDs with commas (,).
   * 
   * @example
   * user1,user2
   */
  relatedUserList?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      pluginParam: 'PluginParam',
      pluginType: 'PluginType',
      relatedUserList: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      pluginParam: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      pluginType: 'string',
      relatedUserList: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrderShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The key of an attachment that is returned after the attachment is uploaded. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to query the key of the attachment.
   * 
   * @example
   * test_AttachmentKey
   */
  attachmentKey?: string;
  /**
   * @remarks
   * The description of the ticket to be created.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * The ticket creation parameter. The value is a JSON string. The value of this parameter differs based on the type of the ticket. For more information, see the **PluginParam parameter** section in this topic.
   * 
   * This parameter is required.
   * 
   * @example
   * {PluginParam_test}
   */
  pluginParamShrink?: string;
  /**
   * @remarks
   * The type of the ticket. For more information, see [PluginType parameter](https://help.aliyun.com/document_detail/429109.html).
   * 
   * This parameter is required.
   * 
   * @example
   * DATA_EXPORT
   */
  pluginType?: string;
  /**
   * @remarks
   * The IDs of the stakeholders that are involved in the ticket. Separate multiple IDs with commas (,).
   * 
   * @example
   * user1,user2
   */
  relatedUserList?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      pluginParamShrink: 'PluginParam',
      pluginType: 'PluginType',
      relatedUserList: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      pluginParamShrink: 'string',
      pluginType: 'string',
      relatedUserList: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrderResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the ticket.
   */
  createOrderResult?: CreateOrderResponseBodyCreateOrderResult;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 427688B8-ADFB-4C4E-9D45-EF5C1FD6****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: CreateOrderResponseBodyCreateOrderResult,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProcCorrectOrderRequest extends $tea.Model {
  /**
   * @example
   * order_attachment.txt
   */
  attachmentKey?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  param?: CreateProcCorrectOrderRequestParam;
  relatedUserList?: number[];
  /**
   * @example
   * 4***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      param: 'Param',
      relatedUserList: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      param: CreateProcCorrectOrderRequestParam,
      relatedUserList: { 'type': 'array', 'itemType': 'number' },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProcCorrectOrderShrinkRequest extends $tea.Model {
  /**
   * @example
   * order_attachment.txt
   */
  attachmentKey?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  paramShrink?: string;
  relatedUserListShrink?: string;
  /**
   * @example
   * 4***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      paramShrink: 'Param',
      relatedUserListShrink: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      paramShrink: 'string',
      relatedUserListShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProcCorrectOrderResponseBody extends $tea.Model {
  createOrderResult?: number[];
  /**
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @example
   * 427688B8-ADFB-4C4E-9D45-EF5C1FD6E23D
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: { 'type': 'array', 'itemType': 'number' },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProcCorrectOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateProcCorrectOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateProcCorrectOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProxyRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the database instance. You can call the [ListInstances](https://www.alibabacloud.com/help/en/data-management-service/latest/listinstances) or [GetInstance](https://www.alibabacloud.com/help/en/data-management-service/latest/getinstance) operation to query the database instance ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 183****
   */
  instanceId?: number;
  /**
   * @remarks
   * The password of the database account.
   * 
   * This parameter is required.
   * 
   * @example
   * ******
   */
  password?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  /**
   * @remarks
   * The username of the database account.
   * 
   * This parameter is required.
   * 
   * @example
   * username
   */
  username?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      password: 'Password',
      tid: 'Tid',
      username: 'Username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'number',
      password: 'string',
      tid: 'number',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProxyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * InvalidParameterValid
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * the instance proxy already exists.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the secure access proxy.
   * 
   * @example
   * 4**
   */
  proxyId?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4FFD154E-F57F-5374-B568-D6276F15****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * - **true**: The request was successful.
   * - **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      proxyId: 'ProxyId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      proxyId: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProxyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateProxyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateProxyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProxyAccessRequest extends $tea.Model {
  /**
   * @remarks
   * The database account.
   * 
   * @example
   * xxx
   */
  indepAccount?: string;
  /**
   * @remarks
   * The password that is used to log on to the database.
   * 
   * @example
   * xxx
   */
  indepPassword?: string;
  /**
   * @remarks
   * The ID of the security protection agent. You can call the [ListProxies](https://www.alibabacloud.com/help/en/data-management-service/latest/listproxies) or [GetProxy](https://www.alibabacloud.com/help/en/data-management-service/latest/getproxy) operation to obtain this parameter.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  proxyId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) or [ListUserTenants](https://www.alibabacloud.com/help/en/data-management-service/latest/listusertenants) operation to obtain this parameter.
   * 
   * @example
   * 1
   */
  tid?: number;
  /**
   * @remarks
   * The ID of the user. You can call the [ListUsers](https://www.alibabacloud.com/help/en/data-management-service/latest/listusers) or [GetUser](https://www.alibabacloud.com/help/en/data-management-service/latest/getuser) operation to obtain this parameter.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  userId?: number;
  static names(): { [key: string]: string } {
    return {
      indepAccount: 'IndepAccount',
      indepPassword: 'IndepPassword',
      proxyId: 'ProxyId',
      tid: 'Tid',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      indepAccount: 'string',
      indepPassword: 'string',
      proxyId: 'number',
      tid: 'number',
      userId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProxyAccessResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned to the query task.
   * 
   * @example
   * 200
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message that is returned.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the security protection authorization. After the security protection agent authorizes the target user, the system automatically generates a security protection authorization ID. The ID is globally unique.
   * 
   * @example
   * 1
   */
  proxyAccessId?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0C1CB646-1DE4-4AD0-B4A4-7D47DD52E931
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      proxyAccessId: 'ProxyAccessId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      proxyAccessId: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProxyAccessResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateProxyAccessResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateProxyAccessResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePublishGroupTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the database for which the schema design is executed.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  dbId?: number;
  /**
   * @remarks
   * Indicates whether the database is a logical database.
   * 
   * This parameter is required.
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The ID of the ticket.
   * 
   * > : You can create a schema design ticket in the DMS console. For more information, see [Design schemas](https://help.aliyun.com/document_detail/69711.html). You can also create a schema design ticket by calling the [CreateOrder](https://help.aliyun.com/document_detail/144649.html) operation and obtain the ticket ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 142435
   */
  orderId?: number;
  /**
   * @remarks
   * The time to execute the schema design ticket.
   * 
   * @example
   * 2019-10-10 00:00:00
   */
  planTime?: string;
  /**
   * @remarks
   * The policy to execute the schema design ticket. Valid values:
   * 
   * *   IMMEDIATELY: immediately executes the schema design ticket.
   * *   REGULARLY: executes the schema design ticket at a scheduled time.
   * 
   * This parameter is required.
   * 
   * @example
   * IMMEDIATELY
   */
  publishStrategy?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * -1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      logic: 'Logic',
      orderId: 'OrderId',
      planTime: 'PlanTime',
      publishStrategy: 'PublishStrategy',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      logic: 'boolean',
      orderId: 'number',
      planTime: 'string',
      publishStrategy: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePublishGroupTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 427688B8-ADFB-4C4E-9D45-EF5C1FD6E23D
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The ID of the job.
   * 
   * @example
   * 413452
   */
  taskId?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      taskId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePublishGroupTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreatePublishGroupTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreatePublishGroupTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSQLReviewOrderRequest extends $tea.Model {
  /**
   * @remarks
   * The purpose or objective of the SQL review. This reduces unnecessary communication.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * The parameters of the ticket.
   * 
   * This parameter is required.
   */
  param?: CreateSQLReviewOrderRequestParam;
  /**
   * @remarks
   * The stakeholders involved in this operation. All the specified stakeholders can view the ticket details and take part in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
   */
  relatedUserList?: number[];
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      param: 'Param',
      relatedUserList: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      param: CreateSQLReviewOrderRequestParam,
      relatedUserList: { 'type': 'array', 'itemType': 'number' },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSQLReviewOrderShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The purpose or objective of the SQL review. This reduces unnecessary communication.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * The parameters of the ticket.
   * 
   * This parameter is required.
   */
  paramShrink?: string;
  /**
   * @remarks
   * The stakeholders involved in this operation. All the specified stakeholders can view the ticket details and take part in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
   */
  relatedUserListShrink?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      paramShrink: 'Param',
      relatedUserListShrink: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      paramShrink: 'string',
      relatedUserListShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSQLReviewOrderResponseBody extends $tea.Model {
  /**
   * @remarks
   * The result of the ticket creation task.
   */
  createOrderResult?: number[];
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * 200
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0C1CB646-1DE4-4AD0-B4A4-7D47DD52E931
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: { 'type': 'array', 'itemType': 'number' },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSQLReviewOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateSQLReviewOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSQLReviewOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScenarioRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the business scenario.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The name of the business scenario.
   * 
   * This parameter is required.
   * 
   * @example
   * Business scenario - test
   */
  scenarioName?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      scenarioName: 'ScenarioName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      scenarioName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScenarioResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4E1D2B4D-3E53-4ABC-999D-1D2520B3471A
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the business scenario.
   * 
   * @example
   * 36***
   */
  scenarioId?: number;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      scenarioId: 'ScenarioId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      scenarioId: 'number',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScenarioResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateScenarioResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateScenarioResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStandardGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the database engine. For more information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
   * 
   * This parameter is required.
   * 
   * @example
   * mysql
   */
  dbType?: string;
  /**
   * @remarks
   * The description of the security rule set.
   * 
   * This parameter is required.
   * 
   * @example
   * test_rule
   */
  description?: string;
  /**
   * @remarks
   * The name of the security rule set.
   * 
   * This parameter is required.
   * 
   * @example
   * test_group
   */
  groupName?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * 3000
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dbType: 'DbType',
      description: 'Description',
      groupName: 'GroupName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbType: 'string',
      description: 'string',
      groupName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStandardGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request fails.
   * 
   * @example
   * 403
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request fails.
   * 
   * @example
   * xxx
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 34E01EDD-6A16-4CF0-9541-C644D1BE01AA
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the created security rule set.
   */
  standardGroup?: CreateStandardGroupResponseBodyStandardGroup;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      standardGroup: 'StandardGroup',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      standardGroup: CreateStandardGroupResponseBodyStandardGroup,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStandardGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateStandardGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateStandardGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStructSyncOrderRequest extends $tea.Model {
  /**
   * @remarks
   * The key of an attachment that is returned after the attachment is uploaded. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to query the key of the attachment.
   * 
   * @example
   * upload_3c7edea3-e4c3-4403-857d-737043036f69_test.sql
   */
  attachmentKey?: string;
  /**
   * @remarks
   * The remarks of the ticket.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * The parameters of the ticket.
   * 
   * This parameter is required.
   */
  param?: CreateStructSyncOrderRequestParam;
  /**
   * @remarks
   * The IDs of the stakeholders.
   */
  relatedUserList?: number[];
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      param: 'Param',
      relatedUserList: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      param: CreateStructSyncOrderRequestParam,
      relatedUserList: { 'type': 'array', 'itemType': 'number' },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStructSyncOrderShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The key of an attachment that is returned after the attachment is uploaded. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to query the key of the attachment.
   * 
   * @example
   * upload_3c7edea3-e4c3-4403-857d-737043036f69_test.sql
   */
  attachmentKey?: string;
  /**
   * @remarks
   * The remarks of the ticket.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * The parameters of the ticket.
   * 
   * This parameter is required.
   */
  paramShrink?: string;
  /**
   * @remarks
   * The IDs of the stakeholders.
   */
  relatedUserListShrink?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      paramShrink: 'Param',
      relatedUserListShrink: 'RelatedUserList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      paramShrink: 'string',
      relatedUserListShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStructSyncOrderResponseBody extends $tea.Model {
  /**
   * @remarks
   * The result of creating the ticket.
   */
  createOrderResult?: number[];
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4E1D2B4D-3E53-4ABC-999D-1D2520B3471A
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: { 'type': 'array', 'itemType': 'number' },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStructSyncOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateStructSyncOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateStructSyncOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 7***
   */
  dagId?: number;
  /**
   * @remarks
   * The position of the node on the Directed Acyclic Graph (DAG).
   * 
   * @example
   * test
   */
  graphParam?: string;
  /**
   * @remarks
   * The configuration of the node.
   * 
   * @example
   * test
   */
  nodeContent?: string;
  /**
   * @remarks
   * The name of the node that you want to create.
   * 
   * This parameter is required.
   * 
   * @example
   * zhttest
   */
  nodeName?: string;
  /**
   * @remarks
   * The output variables configured for the task.
   * 
   * @example
   * test
   */
  nodeOutput?: string;
  /**
   * @remarks
   * The type of the node that you want to create. For more information about the valid values for this parameter, see [NodeType parameter](https://help.aliyun.com/document_detail/424705.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 36
   */
  nodeType?: string;
  /**
   * @remarks
   * The tenant ID.
   * 
   * >  To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
   * 
   * @example
   * 3***
   */
  tid?: number;
  /**
   * @remarks
   * The time variables configured for the node.
   * 
   * @example
   * test
   */
  timeVariables?: string;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      graphParam: 'GraphParam',
      nodeContent: 'NodeContent',
      nodeName: 'NodeName',
      nodeOutput: 'NodeOutput',
      nodeType: 'NodeType',
      tid: 'Tid',
      timeVariables: 'TimeVariables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      graphParam: 'string',
      nodeContent: 'string',
      nodeName: 'string',
      nodeOutput: 'string',
      nodeType: 'string',
      tid: 'number',
      timeVariables: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * InvalidParameterValid
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * InvalidParameterValid
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the task node returned when the task was created.
   * 
   * @example
   * 3***
   */
  nodeId?: number;
  /**
   * @remarks
   * The ID of the request. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * CFD8FE00-36D9-4C1B-940D-65A7B73D9066
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      nodeId: 'NodeId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      nodeId: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTaskFlowRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the task flow.
   * 
   * This parameter is required.
   * 
   * @example
   * Dag_Name
   */
  dagName?: string;
  /**
   * @remarks
   * The description of the task flow.
   * 
   * @example
   * zht_test
   */
  description?: string;
  /**
   * @remarks
   * The ID of the scenario.
   * 
   * @example
   * 2**
   */
  scenarioId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagName: 'DagName',
      description: 'Description',
      scenarioId: 'ScenarioId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagName: 'string',
      description: 'string',
      scenarioId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTaskFlowResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow.
   * 
   * @example
   * 33***
   */
  dagId?: number;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * User can not access to Tenant [1]
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * 19DA51A9-AC3E-5C36-8351-07EBCD2B89A1
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTaskFlowResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTaskFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTaskFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUploadFileJobRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the attachment file.
   * 
   * >  The file name must end with .txt or .sql. For example, the file name can be test.txt or test.sql.
   * 
   * This parameter is required.
   * 
   * @example
   * test.txt
   */
  fileName?: string;
  /**
   * @remarks
   * The purpose of the attachment file. Valid values:
   * 
   * *   **datacorrect**: The file is uploaded to change data.
   * *   **order_info_attachment**: The file is uploaded as an attachment in a ticket.
   * *   **big-file**: The file is uploaded to import multiple data records at a time.
   * *   **sqlreview**: The file is uploaded for SQL review.
   * 
   * This parameter is required.
   * 
   * @example
   * datacorrect
   */
  fileSource?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  /**
   * @remarks
   * The URL of the attachment file. The URL must be an HTTP URL or an HTTPS URL.
   * 
   * >  You can upload the attachment file to an Object Storage Service (OSS) bucket and obtain the URL of the file in the OSS console. For more information, see [Share objects](https://help.aliyun.com/document_detail/195674.html).
   * 
   * This parameter is required.
   * 
   * @example
   * https://XXX.oss-cn-hangzhou.aliyuncs.com/test.txt
   */
  uploadURL?: string;
  static names(): { [key: string]: string } {
    return {
      fileName: 'FileName',
      fileSource: 'FileSource',
      tid: 'Tid',
      uploadURL: 'UploadURL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileName: 'string',
      fileSource: 'string',
      tid: 'number',
      uploadURL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUploadFileJobResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * InvalidParameterValid
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * Unsupported url scheme : null, scheme must be https or http
   */
  errorMessage?: string;
  /**
   * @remarks
   * The key of the task.
   * 
   * >  You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to query the progress and details of the task.
   * 
   * @example
   * 761f18031635736380812****
   */
  jobKey?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E103C5F9-DE47-53F2-BF34-D71DF38F****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      jobKey: 'JobKey',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      jobKey: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUploadFileJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateUploadFileJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateUploadFileJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUploadOSSFileJobRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the file.
   * 
   * > The file name must end with .txt or .sql. For example, the file name can be text.txt.
   * 
   * This parameter is required.
   * 
   * @example
   * test.sql
   */
  fileName?: string;
  /**
   * @remarks
   * The purpose of the file upload task. Valid values:
   * 
   * *   **datacorrect**: The file is uploaded to change data.
   * *   **order_info_attachment**: The file is uploaded as an attachment in a ticket.
   * *   **big-file**: The file is uploaded to import multiple data records at a time.
   * *   **sqlreview**: The file is uploaded for SQL review.
   * 
   * This parameter is required.
   * 
   * @example
   * datacorrect
   */
  fileSource?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
   * 
   * @example
   * -1
   */
  tid?: number;
  /**
   * @remarks
   * The information about the OSS file to be uploaded.
   * 
   * This parameter is required.
   */
  uploadTarget?: CreateUploadOSSFileJobRequestUploadTarget;
  static names(): { [key: string]: string } {
    return {
      fileName: 'FileName',
      fileSource: 'FileSource',
      tid: 'Tid',
      uploadTarget: 'UploadTarget',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileName: 'string',
      fileSource: 'string',
      tid: 'number',
      uploadTarget: CreateUploadOSSFileJobRequestUploadTarget,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUploadOSSFileJobShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the file.
   * 
   * > The file name must end with .txt or .sql. For example, the file name can be text.txt.
   * 
   * This parameter is required.
   * 
   * @example
   * test.sql
   */
  fileName?: string;
  /**
   * @remarks
   * The purpose of the file upload task. Valid values:
   * 
   * *   **datacorrect**: The file is uploaded to change data.
   * *   **order_info_attachment**: The file is uploaded as an attachment in a ticket.
   * *   **big-file**: The file is uploaded to import multiple data records at a time.
   * *   **sqlreview**: The file is uploaded for SQL review.
   * 
   * This parameter is required.
   * 
   * @example
   * datacorrect
   */
  fileSource?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
   * 
   * @example
   * -1
   */
  tid?: number;
  /**
   * @remarks
   * The information about the OSS file to be uploaded.
   * 
   * This parameter is required.
   */
  uploadTargetShrink?: string;
  static names(): { [key: string]: string } {
    return {
      fileName: 'FileName',
      fileSource: 'FileSource',
      tid: 'Tid',
      uploadTargetShrink: 'UploadTarget',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileName: 'string',
      fileSource: 'string',
      tid: 'number',
      uploadTargetShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUploadOSSFileJobResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The key of the file upload task. You can query the upload progress and task details. For more information, see [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html).
   * 
   * @example
   * 65254a4c1614235217749100e
   */
  jobKey?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4E1D2B4D-3E53-4ABC-999D-1D2520B3471A
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      jobKey: 'JobKey',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      jobKey: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUploadOSSFileJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateUploadOSSFileJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateUploadOSSFileJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAuthorityTemplateRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2592
   */
  templateId?: number;
  /**
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      templateId: 'TemplateId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      templateId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAuthorityTemplateResponseBody extends $tea.Model {
  /**
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @example
   * 0C1CB646-1DE4-4AD0-B4A4-7D47DD52E931
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAuthorityTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteAuthorityTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteAuthorityTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The endpoint of the database instance. You can call the [ListInstances](https://help.aliyun.com/document_detail/141936.html) or [GetInstance](https://help.aliyun.com/document_detail/141567.html) operation to obtain the endpoint.
   * 
   * This parameter is required.
   * 
   * @example
   * xxx.mysql.rds.aliyuncs.com
   */
  host?: string;
  /**
   * @remarks
   * The port number that is used to connect to the database instance. You can call the [ListInstances](https://help.aliyun.com/document_detail/141936.html) or [GetInstance](https://help.aliyun.com/document_detail/141567.html) operation to obtain the port number.
   * 
   * This parameter is required.
   * 
   * @example
   * 3306
   */
  port?: number;
  /**
   * @remarks
   * The system ID (SID) of the database instance. You can call the [ListInstances](https://help.aliyun.com/document_detail/141936.html) or [GetInstance](https://help.aliyun.com/document_detail/141567.html) operation to obtain the SID.
   * 
   * @example
   * testSid
   */
  sid?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
      port: 'Port',
      sid: 'Sid',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: 'string',
      port: 'number',
      sid: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code that is returned.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message that is returned.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * B4B07137-F6AE-4756-8474-7F92BB6C4E04
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLakeHouseSpaceRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the workspace. You can call the [GetLhSpaceByName](https://help.aliyun.com/document_detail/424379.html) operation to obtain the workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 24
   */
  spaceId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      spaceId: 'SpaceId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      spaceId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLakeHouseSpaceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request fails.
   * 
   * @example
   * NoPermission
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request fails.
   * 
   * @example
   * You are not authorized to perform this operation.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E76DD2E7-EBAC-5724-B163-19AAC233F8F2
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   true: The request is successful.
   * *   false: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLakeHouseSpaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteLakeHouseSpaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLakeHouseSpaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLhMembersRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the user to be removed. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to obtain the user ID.
   * 
   * This parameter is required.
   */
  memberIds?: number[];
  /**
   * @remarks
   * The ID of the object.
   * 
   * *   If the object is a workspace, you can call the [GetLhSpaceByName](https://help.aliyun.com/document_detail/424379.html) operation to obtain the workspace ID.
   * *   If the object is a task flow, you can call the [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to obtain the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 9***
   */
  objectId?: number;
  /**
   * @remarks
   * The type of the object. Valid values:
   * 
   * *   **0**: workspace
   * *   **1**: task flow
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  objectType?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      memberIds: 'MemberIds',
      objectId: 'ObjectId',
      objectType: 'ObjectType',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      memberIds: { 'type': 'array', 'itemType': 'number' },
      objectId: 'number',
      objectType: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLhMembersShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the user to be removed. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to obtain the user ID.
   * 
   * This parameter is required.
   */
  memberIdsShrink?: string;
  /**
   * @remarks
   * The ID of the object.
   * 
   * *   If the object is a workspace, you can call the [GetLhSpaceByName](https://help.aliyun.com/document_detail/424379.html) operation to obtain the workspace ID.
   * *   If the object is a task flow, you can call the [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to obtain the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 9***
   */
  objectId?: number;
  /**
   * @remarks
   * The type of the object. Valid values:
   * 
   * *   **0**: workspace
   * *   **1**: task flow
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  objectType?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      memberIdsShrink: 'MemberIds',
      objectId: 'ObjectId',
      objectType: 'ObjectType',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      memberIdsShrink: 'string',
      objectId: 'number',
      objectType: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLhMembersResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request fails.
   * 
   * @example
   * 403
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request fails.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F1C78D32-1AFD-58AD-9DD2-C8A0896969DD
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**: The request is successful.
   * *   **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLhMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteLhMembersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLhMembersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLogicDatabaseRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the logical database. You can call the [ListLogicDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogicdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to query the ID of the logical database.
   * 
   * This parameter is required.
   * 
   * @example
   * 1***
   */
  logicDbId?: number;
  /**
   * @remarks
   * The ID of the tenant. 
   * 
   * >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      logicDbId: 'LogicDbId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logicDbId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLogicDatabaseResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C51420E3-144A-4A94-B473-8662FCF4AD10
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * - true: The request is successful.
   * - false: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLogicDatabaseResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteLogicDatabaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLogicDatabaseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLogicTableRouteConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The unique key of the routing algorithm. You can call the [ListLogicTableRouteConfig](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogictablerouteconfig) operation to query the unique key.
   * 
   * This parameter is required.
   * 
   * @example
   * id-hash-mod15
   */
  routeKey?: string;
  /**
   * @remarks
   * The ID of the logical table. You can call the [ListLogicTables](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogictables) operation to query the ID of the logical table.
   * 
   * This parameter is required.
   * 
   * @example
   * 1****
   */
  tableId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      routeKey: 'RouteKey',
      tableId: 'TableId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      routeKey: 'string',
      tableId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLogicTableRouteConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * MissingRouteKey
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * RouteKey is mandatory for this action.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * A916A004-A88C-5B39-ABDB-DE808E80****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * - **true**: The request was successful.
   * - **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLogicTableRouteConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteLogicTableRouteConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLogicTableRouteConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProxyRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the security protection agent. You can call the [ListProxies](https://www.alibabacloud.com/help/en/data-management-service/latest/listproxies) or [GetProxy](https://www.alibabacloud.com/help/en/data-management-service/latest/getproxy) operation to obtain this parameter.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  proxyId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) or [ListUserTenants](https://www.alibabacloud.com/help/en/data-management-service/latest/listusertenants) operation to obtain this parameter.
   * 
   * @example
   * 1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      proxyId: 'ProxyId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      proxyId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProxyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned to the query task.
   * 
   * @example
   * 200
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message that is returned.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0C1CB646-1DE4-4AD0-B4A4-7D47DD52E931
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProxyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteProxyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteProxyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProxyAccessRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the security protection authorization. After the security protection agent authorizes the target user, the system automatically generates a security protection authorization ID. The ID is globally unique. You can call the [ListProxyAccesses](https://www.alibabacloud.com/help/en/data-management-service/latest/listproxyaccesses) operation to obtain this parameter.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  proxyAccessId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) or [ListUserTenants](https://www.alibabacloud.com/help/en/data-management-service/latest/listusertenants) operation to obtain this parameter.
   * 
   * @example
   * 1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      proxyAccessId: 'ProxyAccessId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      proxyAccessId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProxyAccessResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned to the query task.
   * 
   * @example
   * 200
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message that is returned.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0C1CB646-1DE4-4AD0-B4A4-7D47DD52E931
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProxyAccessResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteProxyAccessResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteProxyAccessResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScenarioRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the business scenario.
   * 
   * This parameter is required.
   * 
   * @example
   * 12***
   */
  scenarioId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      scenarioId: 'ScenarioId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      scenarioId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScenarioResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 12***
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScenarioResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteScenarioResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteScenarioResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteStandardGroupRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 242***
   */
  groupId?: number;
  /**
   * @example
   * 23****
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteStandardGroupResponseBody extends $tea.Model {
  /**
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @example
   * C5B8E84B-42B6-4374-AD5A-6264E1753378
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteStandardGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteStandardGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteStandardGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the node you want to delete.
   * 
   * This parameter is required.
   * 
   * @example
   * 54****
   */
  nodeId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * Unknown server error
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3B460770-40D9-5F07-B68A-173D1D708B72
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTaskFlowRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to obtain the ID of the task flow.
   * 
   * This parameter is required.
   * 
   * @example
   * 134137***
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTaskFlowResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request fails.
   * 
   * @example
   * 403
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request fails.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9AFE13F6-A4FD-581B-BFDE-B63B1CDC2336
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**: The request is successful.
   * *   **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTaskFlowResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTaskFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTaskFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTaskFlowEdgesByConditionRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 15****
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the task flow edge to delete.
   * 
   * @example
   * 24***
   */
  id?: number;
  /**
   * @remarks
   * The ID of the end node of the edge to delete.
   * 
   * @example
   * 44***
   */
  nodeEnd?: number;
  /**
   * @remarks
   * The ID of the start node on the edge to delete.
   * 
   * @example
   * 44***
   */
  nodeFrom?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      id: 'Id',
      nodeEnd: 'NodeEnd',
      nodeFrom: 'NodeFrom',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      id: 'number',
      nodeEnd: 'number',
      nodeFrom: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTaskFlowEdgesByConditionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * 21234B66-6859-5558-9E5B-006EFE915CD0
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTaskFlowEdgesByConditionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTaskFlowEdgesByConditionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTaskFlowEdgesByConditionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUserRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the tenant. 
   * 
   * >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
   * 
   * @example
   * -1
   */
  tid?: number;
  /**
   * @remarks
   * The unique ID (UID) of Alibaba Cloud account to delete.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  uid?: string;
  static names(): { [key: string]: string } {
    return {
      tid: 'Tid',
      uid: 'Uid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tid: 'number',
      uid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUserResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 403
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified user not exists.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 34E01EDD-6A16-4CF0-9541-C644D1BE01AA
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUserResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableUserRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * -1
   */
  tid?: number;
  /**
   * @remarks
   * The UID of the Alibaba Cloud account.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  uid?: string;
  static names(): { [key: string]: string } {
    return {
      tid: 'Tid',
      uid: 'Uid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tid: 'number',
      uid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableUserResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request fails.
   * 
   * @example
   * 403
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request fails.
   * 
   * @example
   * The specified user not exists.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 34E01EDD-6A16-4CF0-9541-C644D1BE01AA
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * - true: The request is successful.
   * - false: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableUserResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DisableUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DisableUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadDataTrackResultRequest extends $tea.Model {
  /**
   * @remarks
   * The condition to filter columns.
   */
  columnFilter?: DownloadDataTrackResultRequestColumnFilter;
  /**
   * @remarks
   * The IDs of the events.
   */
  eventIdList?: number[];
  /**
   * @remarks
   * The end time of the time range in which you want to track data operations. The time must be specified in the yyyy-MM-dd HH:mm:ss format.
   * 
   * @example
   * 2023-04-23 10:00:00
   */
  filterEndTime?: string;
  /**
   * @remarks
   * The start time of the time range in which you want to track data operations. The time must be specified in the yyyy-MM-dd HH:mm:ss format.
   * 
   * @example
   * 2023-04-23 00:00:00
   */
  filterStartTime?: string;
  /**
   * @remarks
   * The names of the tables for which you want to track data operations.
   */
  filterTableList?: string[];
  /**
   * @remarks
   * The types of data operations that you want to track.
   */
  filterTypeList?: string[];
  /**
   * @remarks
   * The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to obtain the ticket ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 406****
   */
  orderId?: number;
  /**
   * @remarks
   * The type of the SQL statement.
   * 
   * *   **REVERSE**: undoes or rolls back an executed SQL statement, which is equivalent to the UNDO SQL statement.
   * *   **FORWARD**: redoes or re-executes an SQL statement that failed to be executed, which is equivalent to the REDO SQL statement.
   * 
   * This parameter is required.
   * 
   * @example
   * REVERSE
   */
  rollbackSQLType?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      columnFilter: 'ColumnFilter',
      eventIdList: 'EventIdList',
      filterEndTime: 'FilterEndTime',
      filterStartTime: 'FilterStartTime',
      filterTableList: 'FilterTableList',
      filterTypeList: 'FilterTypeList',
      orderId: 'OrderId',
      rollbackSQLType: 'RollbackSQLType',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnFilter: DownloadDataTrackResultRequestColumnFilter,
      eventIdList: { 'type': 'array', 'itemType': 'number' },
      filterEndTime: 'string',
      filterStartTime: 'string',
      filterTableList: { 'type': 'array', 'itemType': 'string' },
      filterTypeList: { 'type': 'array', 'itemType': 'string' },
      orderId: 'number',
      rollbackSQLType: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadDataTrackResultShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The condition to filter columns.
   */
  columnFilterShrink?: string;
  /**
   * @remarks
   * The IDs of the events.
   */
  eventIdListShrink?: string;
  /**
   * @remarks
   * The end time of the time range in which you want to track data operations. The time must be specified in the yyyy-MM-dd HH:mm:ss format.
   * 
   * @example
   * 2023-04-23 10:00:00
   */
  filterEndTime?: string;
  /**
   * @remarks
   * The start time of the time range in which you want to track data operations. The time must be specified in the yyyy-MM-dd HH:mm:ss format.
   * 
   * @example
   * 2023-04-23 00:00:00
   */
  filterStartTime?: string;
  /**
   * @remarks
   * The names of the tables for which you want to track data operations.
   */
  filterTableListShrink?: string;
  /**
   * @remarks
   * The types of data operations that you want to track.
   */
  filterTypeListShrink?: string;
  /**
   * @remarks
   * The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to obtain the ticket ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 406****
   */
  orderId?: number;
  /**
   * @remarks
   * The type of the SQL statement.
   * 
   * *   **REVERSE**: undoes or rolls back an executed SQL statement, which is equivalent to the UNDO SQL statement.
   * *   **FORWARD**: redoes or re-executes an SQL statement that failed to be executed, which is equivalent to the REDO SQL statement.
   * 
   * This parameter is required.
   * 
   * @example
   * REVERSE
   */
  rollbackSQLType?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      columnFilterShrink: 'ColumnFilter',
      eventIdListShrink: 'EventIdList',
      filterEndTime: 'FilterEndTime',
      filterStartTime: 'FilterStartTime',
      filterTableListShrink: 'FilterTableList',
      filterTypeListShrink: 'FilterTypeList',
      orderId: 'OrderId',
      rollbackSQLType: 'RollbackSQLType',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnFilterShrink: 'string',
      eventIdListShrink: 'string',
      filterEndTime: 'string',
      filterStartTime: 'string',
      filterTableListShrink: 'string',
      filterTypeListShrink: 'string',
      orderId: 'number',
      rollbackSQLType: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadDataTrackResultResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the download key, which is used to download the parsing result of the data tracking task.
   * 
   * @example
   * e23dd7ec-a19f-4a69-8eb3-8ffd26e6****
   */
  downloadKeyId?: string;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * B43AD641-49C2-5299-9E06-1B37EC1B****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      downloadKeyId: 'DownloadKeyId',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadKeyId: 'string',
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadDataTrackResultResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DownloadDataTrackResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DownloadDataTrackResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditLogicDatabaseRequest extends $tea.Model {
  /**
   * @remarks
   * - The alias of the logical database. If you want to change the alias, specify a new alias.
   * - If you do not need to change the alias of the logical database, call the [GetLogicDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/getlogicdatabase) or [GetDBTopology](https://www.alibabacloud.com/help/en/data-management-service/latest/getdbtopology) operation to query the alias of the logical database.
   * 
   * This parameter is required.
   * 
   * @example
   * test_logic_db
   */
  alias?: string;
  /**
   * @remarks
   * - The IDs of the physical databases that compose the logical database. If you want to change the physical databases, you can call the [ListDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to query the IDs of the new physical databases that you want to specify.
   * - If you do not want to change the physical databases, you can call the [GetDBTopology](https://www.alibabacloud.com/help/en/data-management-service/latest/getdbtopology) operation to query the IDs of the physical databases that compose the logical database.
   * 
   * This parameter is required.
   */
  databaseIds?: number[];
  /**
   * @remarks
   * The ID of the logical database. You can call the [ListLogicDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogicdatabases) operation to query the ID of the logical database.
   * 
   * This parameter is required.
   * 
   * @example
   * 1***
   */
  logicDbId?: number;
  /**
   * @remarks
   * The ID of the tenant. 
   * 
   * >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      databaseIds: 'DatabaseIds',
      logicDbId: 'LogicDbId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      databaseIds: { 'type': 'array', 'itemType': 'number' },
      logicDbId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditLogicDatabaseShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * - The alias of the logical database. If you want to change the alias, specify a new alias.
   * - If you do not need to change the alias of the logical database, call the [GetLogicDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/getlogicdatabase) or [GetDBTopology](https://www.alibabacloud.com/help/en/data-management-service/latest/getdbtopology) operation to query the alias of the logical database.
   * 
   * This parameter is required.
   * 
   * @example
   * test_logic_db
   */
  alias?: string;
  /**
   * @remarks
   * - The IDs of the physical databases that compose the logical database. If you want to change the physical databases, you can call the [ListDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to query the IDs of the new physical databases that you want to specify.
   * - If you do not want to change the physical databases, you can call the [GetDBTopology](https://www.alibabacloud.com/help/en/data-management-service/latest/getdbtopology) operation to query the IDs of the physical databases that compose the logical database.
   * 
   * This parameter is required.
   */
  databaseIdsShrink?: string;
  /**
   * @remarks
   * The ID of the logical database. You can call the [ListLogicDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogicdatabases) operation to query the ID of the logical database.
   * 
   * This parameter is required.
   * 
   * @example
   * 1***
   */
  logicDbId?: number;
  /**
   * @remarks
   * The ID of the tenant. 
   * 
   * >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      databaseIdsShrink: 'DatabaseIds',
      logicDbId: 'LogicDbId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      databaseIdsShrink: 'string',
      logicDbId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditLogicDatabaseResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C51420E3-144A-4A94-B473-8662FCF4AD10
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * - true: The request is successful.
   * - false: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditLogicDatabaseResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EditLogicDatabaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EditLogicDatabaseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableUserRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To obtain the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Tenant information](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * -1
   */
  tid?: number;
  /**
   * @remarks
   * The UID of the Alibaba Cloud account.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  uid?: string;
  static names(): { [key: string]: string } {
    return {
      tid: 'Tid',
      uid: 'Uid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tid: 'number',
      uid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableUserResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request fails.
   * 
   * @example
   * 403
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request fails.
   * 
   * @example
   * The specified user not exists.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 34E01EDD-6A16-4CF0-9541-C644D1BE01AA
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**: The request is successful.
   * *   **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableUserResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EnableUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EnableUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteDataCorrectRequest extends $tea.Model {
  /**
   * @remarks
   * The parameters that are required to perform the data change.
   * 
   * ```
   * 
   * json
   * "actionDetail" : {
   *     "startTime" :"2021-07-01 00:00:00", // Specify the start time to change data. If you want to immediately change data, you do not need to set this parameter. 
   *     "endTime" : "2021-07-01 01:00:00", // Specify the end time to change data. If you want to immediately change data, you do not need to set this parameter. 
   *     "transaction" : false, // Specify whether to change data as a transaction. 
   *     "backupData" : true // Specify whether to back up data. 
   *   }
   * ```
   * 
   * @example
   * { "startTime" : "2021-07-0100:00:00", "endTime" : "2021-07-0101:00:00", "transaction" : false, "backupData" : true }
   */
  actionDetail?: { [key: string]: any };
  /**
   * @remarks
   * The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ID of the ticket.
   * 
   * This parameter is required.
   * 
   * @example
   * 406****
   */
  orderId?: number;
  realLoginUserUid?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: string;
  static names(): { [key: string]: string } {
    return {
      actionDetail: 'ActionDetail',
      orderId: 'OrderId',
      realLoginUserUid: 'RealLoginUserUid',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionDetail: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      orderId: 'number',
      realLoginUserUid: 'string',
      tid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteDataCorrectShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The parameters that are required to perform the data change.
   * 
   * ```
   * 
   * json
   * "actionDetail" : {
   *     "startTime" :"2021-07-01 00:00:00", // Specify the start time to change data. If you want to immediately change data, you do not need to set this parameter. 
   *     "endTime" : "2021-07-01 01:00:00", // Specify the end time to change data. If you want to immediately change data, you do not need to set this parameter. 
   *     "transaction" : false, // Specify whether to change data as a transaction. 
   *     "backupData" : true // Specify whether to back up data. 
   *   }
   * ```
   * 
   * @example
   * { "startTime" : "2021-07-0100:00:00", "endTime" : "2021-07-0101:00:00", "transaction" : false, "backupData" : true }
   */
  actionDetailShrink?: string;
  /**
   * @remarks
   * The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ID of the ticket.
   * 
   * This parameter is required.
   * 
   * @example
   * 406****
   */
  orderId?: number;
  realLoginUserUid?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: string;
  static names(): { [key: string]: string } {
    return {
      actionDetailShrink: 'ActionDetail',
      orderId: 'OrderId',
      realLoginUserUid: 'RealLoginUserUid',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionDetailShrink: 'string',
      orderId: 'number',
      realLoginUserUid: 'string',
      tid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteDataCorrectResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * Unknown server error
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EADDA791-2809-58CE-A303-743A77FF****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**: The request is successful.
   * *   **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteDataCorrectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExecuteDataCorrectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExecuteDataCorrectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteDataExportRequest extends $tea.Model {
  /**
   * @remarks
   * The parameters that are required to perform the operation:
   * 
   * ```json
   * {
   *    "fileType": "CSV", // The format of the exported file.
   *    "encoding": "" // The encoding format.
   *  }
   * ```
   * 
   * @example
   * {    "fileType": "CSV",    "encoding": ""  }
   */
  actionDetail?: { [key: string]: any };
  /**
   * @remarks
   * The ID of the ticket.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  orderId?: number;
  realLoginUserUid?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * -1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      actionDetail: 'ActionDetail',
      orderId: 'OrderId',
      realLoginUserUid: 'RealLoginUserUid',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionDetail: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      orderId: 'number',
      realLoginUserUid: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteDataExportShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The parameters that are required to perform the operation:
   * 
   * ```json
   * {
   *    "fileType": "CSV", // The format of the exported file.
   *    "encoding": "" // The encoding format.
   *  }
   * ```
   * 
   * @example
   * {    "fileType": "CSV",    "encoding": ""  }
   */
  actionDetailShrink?: string;
  /**
   * @remarks
   * The ID of the ticket.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  orderId?: number;
  realLoginUserUid?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * -1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      actionDetailShrink: 'ActionDetail',
      orderId: 'OrderId',
      realLoginUserUid: 'RealLoginUserUid',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionDetailShrink: 'string',
      orderId: 'number',
      realLoginUserUid: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteDataExportResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * FE8EE2F1-4880-46BC-A704-5CF63EAF9A04
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteDataExportResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExecuteDataExportResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExecuteDataExportResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteScriptRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the database.
   * 
   * >  This parameter is equivalent to the DatabaseId parameter in the SearchDatabase, ListDatabases, and GetDatabase operations. You can call one of these operations to obtain the required database ID. For more information, see [SearchDatabase](https://help.aliyun.com/document_detail/141876.html), [ListDatabases](https://help.aliyun.com/document_detail/141873.html), and [GetDatabase](https://help.aliyun.com/document_detail/141869.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  dbId?: number;
  /**
   * @remarks
   * Specifies whether the database is a logical database.
   * 
   * This parameter is required.
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The SQL statements to be executed. Data query language (DQL) statements, data definition language (DDL) statements, and data manipulation language (DML) statements are supported. The control mode of the instance that you want to query determines whether you can execute DDL and DML statements.
   * 
   * This parameter is required.
   * 
   * @example
   * select dt from report_daily
   */
  script?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To obtain the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Tenant information](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 234
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      logic: 'Logic',
      script: 'Script',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      logic: 'boolean',
      script: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteScriptResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message about the gateway.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * FE8EE2F1-4880-46BC-A704-5CF63EAF9A04
   */
  requestId?: string;
  /**
   * @remarks
   * The results of the SQL statements that are executed, in the format of an array. Each entry in the array indicates the result of an SQL statement.
   */
  results?: ExecuteScriptResponseBodyResults[];
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      results: 'Results',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      results: { 'type': 'array', 'itemType': ExecuteScriptResponseBodyResults },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteScriptResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExecuteScriptResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExecuteScriptResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteStructSyncRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ticket.
   * 
   * This parameter is required.
   * 
   * @example
   * 112345
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteStructSyncResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4E1D2B4D-3E53-4ABC-999D-1D2520B3471A
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteStructSyncResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExecuteStructSyncResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExecuteStructSyncResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApprovalDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  /**
   * @remarks
   * The ID of the approval process. You can call the [GetOrderBaseInfo](https://help.aliyun.com/document_detail/144642.html) operation to obtain the ID of the approval process.
   * 
   * This parameter is required.
   * 
   * @example
   * 184****
   */
  workflowInstanceId?: number;
  static names(): { [key: string]: string } {
    return {
      tid: 'Tid',
      workflowInstanceId: 'WorkflowInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tid: 'number',
      workflowInstanceId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApprovalDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The approval details of the ticket.
   */
  approvalDetail?: GetApprovalDetailResponseBodyApprovalDetail;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * MissingWorkflowInstanceId
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * WorkflowInstanceId is mandatory for this action.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 66DE630B-ECA1-52A3-9198-602066F9****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**: The request is successful.
   * *   **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      approvalDetail: 'ApprovalDetail',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      approvalDetail: GetApprovalDetailResponseBodyApprovalDetail,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApprovalDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetApprovalDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetApprovalDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthorityTemplateRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the permission template.
   * 
   * This parameter is required.
   * 
   * @example
   * 1563
   */
  templateId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      templateId: 'TemplateId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      templateId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthorityTemplateResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the permission template.
   */
  authorityTemplateView?: GetAuthorityTemplateResponseBodyAuthorityTemplateView;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0C1CB646-1DE4-4AD0-B4A4-7D47DD52E931
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      authorityTemplateView: 'AuthorityTemplateView',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorityTemplateView: GetAuthorityTemplateResponseBodyAuthorityTemplateView,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthorityTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetAuthorityTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetAuthorityTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthorityTemplateItemRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the permission template.
   * 
   * This parameter is required.
   * 
   * @example
   * 1563
   */
  templateId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      templateId: 'TemplateId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      templateId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthorityTemplateItemResponseBody extends $tea.Model {
  /**
   * @remarks
   * The permission templates.
   */
  authorityTemplateItemList?: GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemList;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 5B96E35F-A58E-5399-9041-09CF9A1E46EA
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      authorityTemplateItemList: 'AuthorityTemplateItemList',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorityTemplateItemList: GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemList,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthorityTemplateItemResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetAuthorityTemplateItemResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetAuthorityTemplateItemResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClassificationTemplateRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 169****
   */
  instanceId?: number;
  /**
   * @example
   * 23***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClassificationTemplateResponseBody extends $tea.Model {
  classificationResourceTemplateMap?: GetClassificationTemplateResponseBodyClassificationResourceTemplateMap;
  /**
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @example
   * 427688B8-ADFB-4C4E-9D45-EF5C1FD6E23D
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      classificationResourceTemplateMap: 'ClassificationResourceTemplateMap',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      classificationResourceTemplateMap: GetClassificationTemplateResponseBodyClassificationResourceTemplateMap,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClassificationTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetClassificationTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetClassificationTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDBTaskSQLJobLogRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the SQL task. You can call the [ListDBTaskSQLJob](https://help.aliyun.com/document_detail/207049.html) operation to query the ID of the SQL task.
   * 
   * This parameter is required.
   * 
   * @example
   * 1276****
   */
  jobId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDBTaskSQLJobLogResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * MissingJobId
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * JobId is mandatory for this action.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The log that records the scheduling details.
   * 
   * @example
   * log_****
   */
  log?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4AC23904-55DE-550B-9676-E8946F07****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      log: 'Log',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      log: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDBTaskSQLJobLogResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDBTaskSQLJobLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDBTaskSQLJobLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDBTopologyRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the logical database. You can call the [ListLogicDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogicdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to query the ID of the logical database.
   * 
   * This parameter is required.
   * 
   * @example
   * 134***
   */
  logicDbId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 43***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      logicDbId: 'LogicDbId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logicDbId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDBTopologyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The topology of the data table.
   */
  DBTopology?: GetDBTopologyResponseBodyDBTopology;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C5B8E84B-42B6-4374-AD5A-6264E1753378
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**: The request is successful.
   * *   **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      DBTopology: 'DBTopology',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DBTopology: GetDBTopologyResponseBodyDBTopology,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDBTopologyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDBTopologyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDBTopologyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveCountRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the identity. Default value: AS_ADMIN.
   * 
   * @example
   * AS_ADMIN
   */
  orderResultType?: string;
  /**
   * @remarks
   * The plugin type. Default value: DATA_ARCHIVE.
   * 
   * @example
   * DATA_ARCHIVE
   */
  pluginType?: string;
  /**
   * @remarks
   * The time when the ticket is modified or created. The statistics of data archiving tickets are calculated based on the creation time.
   * 
   * @example
   * CREATE_TIME
   */
  searchDateType?: string;
  /**
   * @remarks
   * The tenant ID.
   * 
   * >  To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 2****
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderResultType: 'OrderResultType',
      pluginType: 'PluginType',
      searchDateType: 'SearchDateType',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderResultType: 'string',
      pluginType: 'string',
      searchDateType: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveCountResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data returned.
   */
  data?: GetDataArchiveCountResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 4B63CAC5-BD7F-5C7C-82C9-59DFFBC3C5C2
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetDataArchiveCountResponseBodyData,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveCountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataArchiveCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataArchiveCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveOrderDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of data archiving tickets.
   * 
   * This parameter is required.
   * 
   * @example
   * 868****
   */
  orderId?: number;
  /**
   * @remarks
   * The tenant ID.
   * 
   * >  To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 5***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveOrderDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of data archiving tickets.
   */
  dataArchiveOrderDetail?: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail;
  /**
   * @remarks
   * The error code returned if the call failed.
   * 
   * @example
   * NoPermission
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message that is returned if the request failed.
   * 
   * @example
   * User [19929582****] not exist
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request, which is used to query logs and troubleshoot issues.
   * 
   * @example
   * 4161CE36-28DF-5191-8A6F-A17076A0B124
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * Tracks service requests.
   * 
   * @example
   * 0a06e1e316757357507896067d3780
   */
  traceId?: string;
  static names(): { [key: string]: string } {
    return {
      dataArchiveOrderDetail: 'DataArchiveOrderDetail',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      traceId: 'TraceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataArchiveOrderDetail: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      traceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveOrderDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataArchiveOrderDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataArchiveOrderDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectBackupFilesRequest extends $tea.Model {
  /**
   * @remarks
   * The parameters that are required to perform the operation. You do not need to specify this parameter.
   * 
   * @example
   * {}
   */
  actionDetail?: { [key: string]: any };
  /**
   * @remarks
   * The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to obtain the ticket ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 4200000
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      actionDetail: 'ActionDetail',
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionDetail: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectBackupFilesShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The parameters that are required to perform the operation. You do not need to specify this parameter.
   * 
   * @example
   * {}
   */
  actionDetailShrink?: string;
  /**
   * @remarks
   * The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to obtain the ticket ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 4200000
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      actionDetailShrink: 'ActionDetail',
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionDetailShrink: 'string',
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectBackupFilesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The download URL of the backup file for the ticket.
   */
  dataCorrectBackupFiles?: GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4AFF4109-FEFB-44E8-96A3-923B1FA8C46E
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      dataCorrectBackupFiles: 'DataCorrectBackupFiles',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataCorrectBackupFiles: GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectBackupFilesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataCorrectBackupFilesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataCorrectBackupFilesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectOrderDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to obtain the ticket ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 420****
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectOrderDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the data change ticket.
   */
  dataCorrectOrderDetail?: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail;
  /**
   * @remarks
   * The error code returned if the request fails.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request fails.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 427688B8-ADFB-4C4E-9D45-EF5C1FD6E23D
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * - **true**: The request is successful.
   * - **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      dataCorrectOrderDetail: 'DataCorrectOrderDetail',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataCorrectOrderDetail: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectOrderDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataCorrectOrderDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataCorrectOrderDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectRollbackFileRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ticket ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 51****
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectRollbackFileResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The download URL of the attachment.
   * 
   * @example
   * https://dmsxxx
   */
  fileUrl?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3CDB8601-AD74-4A47-8114-08E08CD6****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      fileUrl: 'FileUrl',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      fileUrl: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectRollbackFileResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataCorrectRollbackFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataCorrectRollbackFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectSQLFileRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ticket.
   * 
   * This parameter is required.
   * 
   * @example
   * 730000
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * -1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectSQLFileResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The download URL of the SQL script.
   * 
   * @example
   * https://dmsxxx
   */
  fileUrl?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 283C461F-11D8-48AA-B695-DF092DA32AF3
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      fileUrl: 'FileUrl',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      fileUrl: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectSQLFileResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataCorrectSQLFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataCorrectSQLFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectTaskDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ticket. You can call the [CreateDataCorrectOrder](https://help.aliyun.com/document_detail/208388.html), [CreateDataImportOrder](https://help.aliyun.com/document_detail/208387.html), or [CreateFreeLockCorrectOrder](https://help.aliyun.com/document_detail/208386.html) operation to obtain the ticket ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 12435523
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
   * 
   * @example
   * 14325432
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectTaskDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the data change task.
   */
  dataCorrectTaskDetail?: GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * B5FD0BC8-2D90-4478-B8EC-A0E92E0B1773
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      dataCorrectTaskDetail: 'DataCorrectTaskDetail',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataCorrectTaskDetail: GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectTaskDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataCorrectTaskDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataCorrectTaskDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCronClearConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ticket ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 420****
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCronClearConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * Data configuration.
   */
  dataCronClearConfig?: GetDataCronClearConfigResponseBodyDataCronClearConfig;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 283C461F-11D8-48AA-B695-DF092DA32AF3
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true: The request was successful.
   * *   false: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      dataCronClearConfig: 'DataCronClearConfig',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataCronClearConfig: GetDataCronClearConfigResponseBodyDataCronClearConfig,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCronClearConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataCronClearConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataCronClearConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCronClearTaskDetailListRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ticket. You can query the ticket ID from the response parameters of the [CreateDataCronClearOrder](https://help.aliyun.com/document_detail/208385.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 432532
   */
  orderId?: number;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
   * 
   * @example
   * 12345
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCronClearTaskDetailListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The historical data cleansing tasks
   */
  dataCronClearTaskDetailList?: GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList[];
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C1D39814-9808-47F8-AFE0-AF167239AC9B
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of SQL tasks.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      dataCronClearTaskDetailList: 'DataCronClearTaskDetailList',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataCronClearTaskDetailList: { 'type': 'array', 'itemType': GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCronClearTaskDetailListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataCronClearTaskDetailListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataCronClearTaskDetailListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportDownloadURLRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to obtain the ticket ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 546****
   */
  orderId?: number;
  realLoginUserUid?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      realLoginUserUid: 'RealLoginUserUid',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      realLoginUserUid: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportDownloadURLResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details about the download URL of the file that records the export results for the ticket.
   */
  downloadURLResult?: GetDataExportDownloadURLResponseBodyDownloadURLResult;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4BF24EA5-9013-4C85-AE68-6C23AF5E0097
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      downloadURLResult: 'DownloadURLResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadURLResult: GetDataExportDownloadURLResponseBodyDownloadURLResult,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportDownloadURLResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataExportDownloadURLResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataExportDownloadURLResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportOrderDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The ticket ID. You can call the [ListOrders](https://help.aliyun.com/document_detail/465867.html) operation to query the ticket ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * -1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportOrderDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the data export ticket.
   */
  dataExportOrderDetail?: GetDataExportOrderDetailResponseBodyDataExportOrderDetail;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 427688B8-ADFB-4C4E-9D45-EF5C1FD6E23D
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values: Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      dataExportOrderDetail: 'DataExportOrderDetail',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataExportOrderDetail: GetDataExportOrderDetailResponseBodyDataExportOrderDetail,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportOrderDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataExportOrderDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataExportOrderDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportPreCheckDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to obtain the ticket ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 34****
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportPreCheckDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * Indicates the result of the precheck task.
   */
  preCheckResult?: GetDataExportPreCheckDetailResponseBodyPreCheckResult;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C1D39814-9808-47F8-AFE0-AF167239AC9B
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      preCheckResult: 'PreCheckResult',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      preCheckResult: GetDataExportPreCheckDetailResponseBodyPreCheckResult,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportPreCheckDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataExportPreCheckDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataExportPreCheckDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataImportSQLRequest extends $tea.Model {
  /**
   * @remarks
   * The ticket ID. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ticket ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 14****
   */
  orderId?: number;
  /**
   * @remarks
   * The SQL ID. You can call the ListDataImportSQLPreCheckDetail operation to query the SQL ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 15****
   */
  sqlId?: number;
  /**
   * @remarks
   * The tenant ID. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      sqlId: 'SqlId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      sqlId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataImportSQLResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The request ID. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * B43AD641-49C2-5299-9E06-1B37EC1B****
   */
  requestId?: string;
  /**
   * @remarks
   * The details of SQL statements.
   */
  SQLDetail?: GetDataImportSQLResponseBodySQLDetail;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      SQLDetail: 'SQLDetail',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      SQLDetail: GetDataImportSQLResponseBodySQLDetail,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataImportSQLResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataImportSQLResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataImportSQLResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataTrackJobDegreeRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ticket ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 321****
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataTrackJobDegreeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The progress details of the data tracking task.
   */
  jobDegree?: GetDataTrackJobDegreeResponseBodyJobDegree;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * C51420E3-144A-4A94-B473-8662FCF4AD10
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      jobDegree: 'JobDegree',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      jobDegree: GetDataTrackJobDegreeResponseBodyJobDegree,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataTrackJobDegreeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataTrackJobDegreeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataTrackJobDegreeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataTrackJobTableMetaRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ID of the ticket.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the ID of the tenant.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataTrackJobTableMetaResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0C1CB646-1DE4-4AD0-B4A4-7D47DD52E931
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The metadata of tables.
   */
  tableMetaList?: GetDataTrackJobTableMetaResponseBodyTableMetaList[];
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      tableMetaList: 'TableMetaList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      tableMetaList: { 'type': 'array', 'itemType': GetDataTrackJobTableMetaResponseBodyTableMetaList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataTrackJobTableMetaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataTrackJobTableMetaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataTrackJobTableMetaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataTrackOrderDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ticket ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 4328****
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataTrackOrderDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the ticket.
   */
  dataTrackOrderDetail?: GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 283C461F-11D8-48AA-B695-DF092DA32AF3
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      dataTrackOrderDetail: 'DataTrackOrderDetail',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataTrackOrderDetail: GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataTrackOrderDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataTrackOrderDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataTrackOrderDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseRequest extends $tea.Model {
  /**
   * @remarks
   * The endpoint that is used to connect to the database.
   * 
   * This parameter is required.
   * 
   * @example
   * 192.168.XX.XX
   */
  host?: string;
  /**
   * @remarks
   * The port that is used to connect to the database.
   * 
   * This parameter is required.
   * 
   * @example
   * 3306
   */
  port?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * This parameter is required.
   * 
   * @example
   * mysql
   */
  schemaName?: string;
  /**
   * @remarks
   * The system identifier (SID) of the database.
   * 
   * >  The SID uniquely identifies an Oracle database. After a database is created, a SID is generated for the database.
   * 
   * @example
   * test_sid
   */
  sid?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the ID of the tenant.
   * 
   * @example
   * -1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
      port: 'Port',
      schemaName: 'SchemaName',
      sid: 'Sid',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: 'string',
      port: 'number',
      schemaName: 'string',
      sid: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the database.
   */
  database?: GetDatabaseResponseBodyDatabase;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * An unknown error occurred.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3CDB8601-AD74-4A47-8114-08E08CD6****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**: The request is successful.
   * *   **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      database: 'Database',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      database: GetDatabaseResponseBodyDatabase,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDatabaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDatabaseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseExportOrderDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The ticket ID. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to obtain the ticket ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 821****
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the "Manage DMS tenants" topic.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseExportOrderDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the database export ticket.
   */
  databaseExportOrderDetail?: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The request ID. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * CFD8FE00-36D9-4C1B-940D-65A7B73D9066
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      databaseExportOrderDetail: 'DatabaseExportOrderDetail',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseExportOrderDetail: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseExportOrderDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDatabaseExportOrderDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDatabaseExportOrderDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDbExportDownloadURLRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 73****
   */
  orderId?: number;
  /**
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDbExportDownloadURLResponseBody extends $tea.Model {
  downloadURLResult?: GetDbExportDownloadURLResponseBodyDownloadURLResult;
  /**
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @example
   * 0C1CB646-1DE4-4AD0-B4A4-7D47DD52E931
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      downloadURLResult: 'DownloadURLResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadURLResult: GetDbExportDownloadURLResponseBodyDownloadURLResult,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDbExportDownloadURLResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDbExportDownloadURLResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDbExportDownloadURLResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The endpoint of the database instance. You can call the [ListInstances](https://help.aliyun.com/document_detail/141936.html) operation to obtain the endpoint.
   * 
   * This parameter is required.
   * 
   * @example
   * 172.17.XXX.XXX
   */
  host?: string;
  /**
   * @remarks
   * The port number that is used to connect to the database instance. You can call the [ListInstances](https://help.aliyun.com/document_detail/141936.html) operation to obtain the port number.
   * 
   * This parameter is required.
   * 
   * @example
   * 5432
   */
  port?: number;
  /**
   * @remarks
   * The system ID (SID) of the database instance. You can call the [ListInstances](https://help.aliyun.com/document_detail/141936.html) operation to obtain the SID.
   * 
   * @example
   * test
   */
  sid?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to obtain the tenant ID.
   * 
   * @example
   * 2***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
      port: 'Port',
      sid: 'Sid',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: 'string',
      port: 'number',
      sid: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code that is returned.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message that is returned.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The details of the database instance.
   */
  instance?: GetInstanceResponseBodyInstance;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F6C80B69-3203-56AC-8021-18BA72A6F4E1
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * - **true**: The request was successful.
   * - **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      instance: 'Instance',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      instance: GetInstanceResponseBodyInstance,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetIntervalLimitOfSLARequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 11****
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetIntervalLimitOfSLAResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The minimum scheduling cycle. Unit: minutes.
   * 
   * @example
   * 59
   */
  intervalLimit?: number;
  /**
   * @remarks
   * The ID of the request. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * 5B96E35F-A58E-5399-9041-09CF9A1E46EA
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      intervalLimit: 'IntervalLimit',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      intervalLimit: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetIntervalLimitOfSLAResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetIntervalLimitOfSLAResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetIntervalLimitOfSLAResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLhSpaceByNameRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * test_space
   */
  spaceName?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3000
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      spaceName: 'SpaceName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      spaceName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLhSpaceByNameResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request fails.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request fails.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The workspace for data warehouse development.
   */
  lakehouseSpace?: GetLhSpaceByNameResponseBodyLakehouseSpace;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * FE8CA4A8-AB2D-55B7-BD30-01A4609F40D8
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**: The request is successful.
   * *   **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      lakehouseSpace: 'LakehouseSpace',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      lakehouseSpace: GetLhSpaceByNameResponseBodyLakehouseSpace,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLhSpaceByNameResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetLhSpaceByNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetLhSpaceByNameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLogicDatabaseRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the logical database. You can call the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to obtain the ID of the logical database.
   * 
   * This parameter is required.
   * 
   * @example
   * 1***
   */
  dbId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLogicDatabaseResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The details of the logical database.
   */
  logicDatabase?: GetLogicDatabaseResponseBodyLogicDatabase;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 90260530-565C-42B9-A6E8-893481FE6AB6
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true: The request was successful.
   * *   false: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      logicDatabase: 'LogicDatabase',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      logicDatabase: GetLogicDatabaseResponseBodyLogicDatabase,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLogicDatabaseResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetLogicDatabaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetLogicDatabaseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableColumnRequest extends $tea.Model {
  /**
   * @remarks
   * The globally unique identifier (GUID) of the table in Data Management (DMS).
   * 
   * *   If the database to which the table belongs is a logical database, you can call the [ListLogicTables](https://help.aliyun.com/document_detail/141875.html) operation to obtain the value of this parameter.
   * *   If the database to which the table belongs is a physical database, you can call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation to obtain the value of this parameter.
   * 
   * This parameter is required.
   * 
   * @example
   * IDB_40753****.qntest2.activity_setting
   */
  tableGuid?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      tableGuid: 'TableGuid',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tableGuid: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableColumnResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details about fields in the table.
   */
  columnList?: GetMetaTableColumnResponseBodyColumnList[];
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * MissingTableGuid
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * TableGuid is mandatory for this action.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 087DFBA1-378B-5D25-B13B-31F6409F****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      columnList: 'ColumnList',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnList: { 'type': 'array', 'itemType': GetMetaTableColumnResponseBodyColumnList },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableColumnResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMetaTableColumnResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMetaTableColumnResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableDetailInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The GUID of the table in Data Management (DMS).
   * 
   * > 
   * 
   * *   You can call the [ListLogicTables](https://help.aliyun.com/document_detail/141875.html) operation with ReturnGuid set to true to query the GUIDs of logical tables in a specific logical database.
   * 
   * *   You can call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation with ReturnGuid set to true to query the GUIDs of tables in a specific physical database.
   * 
   * This parameter is required.
   * 
   * @example
   * IDB_L_9032.db-test.yuyang_test
   */
  tableGuid?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the Manage DMS tenants topic.
   * 
   * @example
   * 123
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      tableGuid: 'TableGuid',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tableGuid: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableDetailInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the table.
   */
  detailInfo?: GetMetaTableDetailInfoResponseBodyDetailInfo;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E881CB2F-DE42-42E5-90EB-8B3173DCB9B9
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      detailInfo: 'DetailInfo',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      detailInfo: GetMetaTableDetailInfoResponseBodyDetailInfo,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableDetailInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMetaTableDetailInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMetaTableDetailInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOnlineDDLProgressRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the OnlineDDL SQL task details. You can call the [ListDBTaskSQLJobDetail](https://help.aliyun.com/document_detail/207073.html) operation to obtain the task detail ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 15***
   */
  jobDetailId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      jobDetailId: 'JobDetailId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobDetailId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOnlineDDLProgressResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * 403
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The details of the task.
   */
  onlineDDLTaskDetail?: GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 34E01EDD-6A16-4CF0-9541-C644D1BE01AA
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      onlineDDLTaskDetail: 'OnlineDDLTaskDetail',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      onlineDDLTaskDetail: GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOnlineDDLProgressResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetOnlineDDLProgressResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOnlineDDLProgressResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpLogRequest extends $tea.Model {
  /**
   * @remarks
   * DatabaseName.
   * 
   * @example
   * dmstest@rm-bp1qb97d4b****.mysql.rds.aliyuncs.com:3306[poc_dev]
   */
  databaseName?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the yyyy-MM-DD HH:mm:ss format.
   * 
   * This parameter is required.
   * 
   * @example
   * 2022-03-29 10:00:00
   */
  endTime?: string;
  /**
   * @remarks
   * The functional module for which you want to query operation logs. If you do not specify this parameter, operation logs for all functional modules are returned. Valid values:
   * 
   * *   **PERMISSION**: permissions
   * *   **OWNER**: data owner
   * *   **SQL_CONSOLE**: data query
   * *   **SQL_CONSOLE_EXPORT**: query result export
   * *   **DATA_CHANGE**: data change
   * *   **DATA_EXPORT**: data export
   * *   **SQL_REVIEW**: SQL review
   * *   **DT_SYNC**: database and table synchronization
   * *   **DT_DETAIL**: database and table details
   * *   **DB_TASK**: task management
   * *   **INSTANCE_MANAGE**: instance management
   * *   **USER_MANAGE**: user management
   * *   **SECURITY_RULE**: security rules
   * *   **CONFIG_MANAGE**: configuration management
   * *   **RESOURCE_AUTH**: resource authorization
   * *   **ACCESS_WHITE_IP**: access IP address whitelist
   * *   **NDDL**: schema design
   * *   **DSQL_CONSOLE**: cross-database data query
   * *   **DSQL_CONSOLE_EXPORT**: cross-database query result export
   * *   **DATA_TRACT**: data tracking
   * *   **DATA_QUALITY**: data quality
   * *   **DATALINK_MANAGE** :DBLink management
   * *   **DATASEC_MANAGE**: sensitive data management
   * *   **SELL**: sales
   * 
   * @example
   * SECURITY_RULE
   */
  module?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Valid values:
   * 
   * *   30
   * *   50
   * *   100
   * 
   * This parameter is required.
   * 
   * @example
   * 30
   */
  pageSize?: number;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the yyyy-MM-DD HH:mm:ss format.
   * 
   * This parameter is required.
   * 
   * @example
   * 2022-03-23 10:00:00
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  /**
   * @remarks
   * UserNick.
   * 
   * @example
   * test_name
   */
  userNick?: string;
  static names(): { [key: string]: string } {
    return {
      databaseName: 'DatabaseName',
      endTime: 'EndTime',
      module: 'Module',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startTime: 'StartTime',
      tid: 'Tid',
      userNick: 'UserNick',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseName: 'string',
      endTime: 'string',
      module: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startTime: 'string',
      tid: 'number',
      userNick: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpLogResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 403
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The details of the operation log.
   */
  opLogDetails?: GetOpLogResponseBodyOpLogDetails;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 47D56208-DB1D-4FD3-BE32-300E43185488
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of operation logs that are returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      opLogDetails: 'OpLogDetails',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      opLogDetails: GetOpLogResponseBodyOpLogDetails,
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpLogResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetOpLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOpLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOrderAttachmentFileRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ticket ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 51****
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOrderAttachmentFileResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned. Take note of the following rules:
   * 
   * *   The **ErrorCode** parameter is not returned if the request is successful.
   * *   The **ErrorCode** parameter is returned if the request fails. For more information, see the **Error codes** section of this topic.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The download URL of the attachment.
   * 
   * @example
   * https://dmsxxx
   */
  fileUrl?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * FE8EE2F1-4880-46BC-A704-5CF63EAF9A04
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      fileUrl: 'FileUrl',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      fileUrl: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOrderAttachmentFileResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetOrderAttachmentFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOrderAttachmentFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOrderBaseInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ticket.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * -1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOrderBaseInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The basic information about the ticket.
   */
  orderBaseInfo?: GetOrderBaseInfoResponseBodyOrderBaseInfo;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 7133DF67-5B25-460F-8285-C4CC93472C2F
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      orderBaseInfo: 'OrderBaseInfo',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      orderBaseInfo: GetOrderBaseInfoResponseBodyOrderBaseInfo,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOrderBaseInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetOrderBaseInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOrderBaseInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOwnerApplyOrderDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ticket.
   * 
   * This parameter is required.
   * 
   * @example
   * 730000
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * -1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOwnerApplyOrderDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The details of the ticket.
   */
  ownerApplyOrderDetail?: GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CB784055-E8CB-4461-AB0B-483A1DA32BB5
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      ownerApplyOrderDetail: 'OwnerApplyOrderDetail',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      ownerApplyOrderDetail: GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOwnerApplyOrderDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetOwnerApplyOrderDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOwnerApplyOrderDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPagedInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 868*****
   */
  orderId?: number;
  /**
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPagedInstanceResponseBody extends $tea.Model {
  data?: GetPagedInstanceResponseBodyData;
  /**
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @example
   * 1
   */
  pageIndex?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * 7FAD400F-7A5C-4193-8F9A-39D86C4F0231
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 2
   */
  total?: number;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 0a06e1e316757357507896067d3780
   */
  traceId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      pageIndex: 'PageIndex',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      success: 'Success',
      total: 'Total',
      traceId: 'TraceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetPagedInstanceResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      pageIndex: 'number',
      pageSize: 'number',
      requestId: 'string',
      success: 'boolean',
      total: 'number',
      traceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPagedInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPagedInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPagedInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermApplyOrderDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The ticket ID. You can call the [ListOrders](https://help.aliyun.com/document_detail/465867.html) operation to query the ticket ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 730000
   */
  orderId?: number;
  /**
   * @remarks
   * The tenant ID.
   * 
   * > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the "Manage DMS tenants" topic.
   * 
   * @example
   * -1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermApplyOrderDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The details of the permission application ticket.
   */
  permApplyOrderDetail?: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail;
  /**
   * @remarks
   * The request ID. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * A4C4499E-5AC2-4318-9FCF-03E426781A04
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      permApplyOrderDetail: 'PermApplyOrderDetail',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      permApplyOrderDetail: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermApplyOrderDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPermApplyOrderDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPermApplyOrderDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPhysicalDatabaseRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the physical database. You can call the [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 43153
   */
  dbId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the ID of the tenant.
   * 
   * @example
   * 1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPhysicalDatabaseResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the physical database.
   */
  database?: GetPhysicalDatabaseResponseBodyDatabase;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 7FAD400F-7A5C-4193-8F9A-39D86C4F0231
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      database: 'Database',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      database: GetPhysicalDatabaseResponseBodyDatabase,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPhysicalDatabaseResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPhysicalDatabaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPhysicalDatabaseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProxyRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the secure access proxy. You can call the [ListProxies](https://help.aliyun.com/document_detail/295371.html) operation to query the ID of the secure access proxy.
   * 
   * This parameter is required.
   * 
   * @example
   * 4**
   */
  proxyId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      proxyId: 'ProxyId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      proxyId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProxyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the user who enabled the secure access proxy feature.
   * 
   * @example
   * 12****
   */
  creatorId?: number;
  /**
   * @remarks
   * The nickname of the user who enabled the secure access proxy feature.
   * 
   * @example
   * test_name
   */
  creatorName?: string;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * The condition cannot be empty!
   */
  errorMessage?: string;
  /**
   * @remarks
   * The port number used by the HTTPS protocol.
   * 
   * @example
   * 443
   */
  httpsPort?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * 183****
   */
  instanceId?: number;
  /**
   * @remarks
   * Indicates whether the internal endpoint was enabled. Default value: **true**.
   * 
   * @example
   * true
   */
  privateEnable?: boolean;
  /**
   * @remarks
   * The internal endpoint.
   * 
   * @example
   * dphzmy-5j8oimjsz6ze****.proxy.dms.aliyuncs.com
   */
  privateHost?: string;
  /**
   * @remarks
   * The port number used by the protocol.
   * 
   * @example
   * 3306
   */
  protocolPort?: number;
  /**
   * @remarks
   * The protocol type of the database. Example: MYSQL.
   * 
   * @example
   * MYSQL
   */
  protocolType?: string;
  /**
   * @remarks
   * The ID of the secure access proxy.
   * 
   * @example
   * 4**
   */
  proxyId?: number;
  /**
   * @remarks
   * Indicates whether the public endpoint was enabled. Valid values:
   * 
   * *   **true**: The public endpoint was enabled.
   * *   **false**: The public endpoint was disabled.
   * 
   * @example
   * true
   */
  publicEnable?: boolean;
  /**
   * @remarks
   * The public endpoint. A public endpoint is returned no matter whether the public endpoint is enabled or disabled.
   * 
   * > 
   * 
   * *   If the value of the PublicEnable parameter is **true**, a valid public endpoint that can be resolved by using Alibaba Cloud DNS is returned.
   * 
   * *   If the value of the PublicEnable parameter is **false**, an invalid public endpoint that cannot be resolved by using Alibaba Cloud DNS is returned.
   * 
   * @example
   * dphzmy-5j8oimjsz6zed7k****.proxy.dms.aliyuncs.com
   */
  publicHost?: string;
  /**
   * @remarks
   * The ID of the region in which the instance resides.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F49D4598-2B3C-5723-865E-2CCB818E****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      creatorId: 'CreatorId',
      creatorName: 'CreatorName',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpsPort: 'HttpsPort',
      instanceId: 'InstanceId',
      privateEnable: 'PrivateEnable',
      privateHost: 'PrivateHost',
      protocolPort: 'ProtocolPort',
      protocolType: 'ProtocolType',
      proxyId: 'ProxyId',
      publicEnable: 'PublicEnable',
      publicHost: 'PublicHost',
      regionId: 'RegionId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorId: 'number',
      creatorName: 'string',
      errorCode: 'string',
      errorMessage: 'string',
      httpsPort: 'number',
      instanceId: 'number',
      privateEnable: 'boolean',
      privateHost: 'string',
      protocolPort: 'number',
      protocolType: 'string',
      proxyId: 'number',
      publicEnable: 'boolean',
      publicHost: 'string',
      regionId: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProxyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetProxyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetProxyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProxyAccessRequest extends $tea.Model {
  /**
   * @remarks
   * The ID that Data Management (DMS) generates after the user is authorized to enable the secure access proxy feature for an instance. The ID is unique in DMS. You can call the [ListProxyAccesses](https://help.aliyun.com/document_detail/295386.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  proxyAccessId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      proxyAccessId: 'ProxyAccessId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      proxyAccessId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProxyAccessResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UserNotExist
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * The specified user not exists.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The authorization information about the secure access proxy feature.
   */
  proxyAccess?: GetProxyAccessResponseBodyProxyAccess;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3CDB8601-AD74-4A47-8114-08E08CD6****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      proxyAccess: 'ProxyAccess',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      proxyAccess: GetProxyAccessResponseBodyProxyAccess,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProxyAccessResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetProxyAccessResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetProxyAccessResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleNumLimitOfSLARequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 11****
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleNumLimitOfSLAResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * D05B3EE1-B6D3-5B17-8CA6-A8054828E5B2
   */
  requestId?: string;
  /**
   * @remarks
   * The maximum number of SLA rules.
   * 
   * @example
   * 12
   */
  ruleNumLimit?: number;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      ruleNumLimit: 'RuleNumLimit',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      ruleNumLimit: 'number',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRuleNumLimitOfSLAResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRuleNumLimitOfSLAResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRuleNumLimitOfSLAResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSQLReviewCheckResultStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ticket. You can obtain the ticket ID from the response parameters of the [CreateSQLReviewOrder](https://help.aliyun.com/document_detail/257777.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123321
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the ID of the tenant.
   * 
   * @example
   * 1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSQLReviewCheckResultStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The result of the SQL review.
   */
  checkResultStatus?: GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0C1CB646-1DE4-4AD0-B4A4-7D47DD52E931
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      checkResultStatus: 'CheckResultStatus',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkResultStatus: GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSQLReviewCheckResultStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSQLReviewCheckResultStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSQLReviewCheckResultStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSQLReviewOptimizeDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The key that is used to query the details of optimization suggestions. You can call the [ListSQLReviewOriginSQL](https://help.aliyun.com/document_detail/257870.html) operation to query the key.
   * 
   * This parameter is required.
   * 
   * @example
   * a57e54ec5433475ea3082d882fdb****
   */
  SQLReviewQueryKey?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the ID of the tenant.
   * 
   * @example
   * 1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      SQLReviewQueryKey: 'SQLReviewQueryKey',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      SQLReviewQueryKey: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSQLReviewOptimizeDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The details of optimization suggestions for SQL statements.
   */
  optimizeDetail?: GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0C1CB646-1DE4-4AD0-B4A4-7D47DD52E931
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      optimizeDetail: 'OptimizeDetail',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      optimizeDetail: GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSQLReviewOptimizeDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSQLReviewOptimizeDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSQLReviewOptimizeDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStandardGroupRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 242***
   */
  groupId?: number;
  /**
   * @example
   * 23****
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStandardGroupResponseBody extends $tea.Model {
  /**
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @example
   * BF7E9543-F431-566A-991A-B5C493EA36C2
   */
  requestId?: string;
  standardGroup?: GetStandardGroupResponseBodyStandardGroup;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      standardGroup: 'StandardGroup',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      standardGroup: GetStandardGroupResponseBodyStandardGroup,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStandardGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetStandardGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetStandardGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncExecSqlDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ticket.
   * 
   * This parameter is required.
   * 
   * @example
   * 342153
   */
  orderId?: number;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncExecSqlDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 1810E635-A2D7-428B-BAA9-85DAEB9B1A77
   */
  requestId?: string;
  /**
   * @remarks
   * The details of the SQL statements.
   */
  structSyncExecSqlDetail?: GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      structSyncExecSqlDetail: 'StructSyncExecSqlDetail',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      structSyncExecSqlDetail: GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncExecSqlDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetStructSyncExecSqlDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetStructSyncExecSqlDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncJobAnalyzeResultRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the comparison. Valid values:
   * 
   * *   **CREATE_TABLE**: compares the created tables.
   * *   **ALTER_TABLE**: compares the modified tables.
   * *   **EQUAL_TABLE**: compares the identical tables.
   * *   **PASS_TABLE**: compares the tables that are skipped during schema synchronization.
   * *   **NOT_COMPARE**: does not compare tables.
   * 
   * @example
   * CREATE_TABLE
   */
  compareType?: string;
  /**
   * @remarks
   * The ID of the ticket.
   * 
   * This parameter is required.
   * 
   * @example
   * 1342355
   */
  orderId?: number;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      compareType: 'CompareType',
      orderId: 'OrderId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      compareType: 'string',
      orderId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncJobAnalyzeResultResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 1810E635-A2D7-428B-BAA9-85DAEB9B1A77
   */
  requestId?: string;
  /**
   * @remarks
   * The analysis result of the schema synchronization task.
   */
  structSyncJobAnalyzeResult?: GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      structSyncJobAnalyzeResult: 'StructSyncJobAnalyzeResult',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      structSyncJobAnalyzeResult: GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncJobAnalyzeResultResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetStructSyncJobAnalyzeResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetStructSyncJobAnalyzeResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncJobDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The ticket ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 4324321
   */
  orderId?: number;
  /**
   * @remarks
   * The tenant ID.
   * 
   * > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncJobDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 48602B78-0DDF-414C-8688-70CAB6070115
   */
  requestId?: string;
  /**
   * @remarks
   * The details of the schema synchronization task.
   */
  structSyncJobDetail?: GetStructSyncJobDetailResponseBodyStructSyncJobDetail;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      structSyncJobDetail: 'StructSyncJobDetail',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      structSyncJobDetail: GetStructSyncJobDetailResponseBodyStructSyncJobDetail,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncJobDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetStructSyncJobDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetStructSyncJobDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncOrderDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ticket.
   * 
   * This parameter is required.
   * 
   * @example
   * 43****
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncOrderDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4E1D2B4D-3E53-4ABC-999D-1D2520B3471A
   */
  requestId?: string;
  /**
   * @remarks
   * The details of the schema synchronization ticket.
   */
  structSyncOrderDetail?: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      structSyncOrderDetail: 'StructSyncOrderDetail',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      structSyncOrderDetail: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncOrderDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetStructSyncOrderDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetStructSyncOrderDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDBTopologyRequest extends $tea.Model {
  /**
   * @remarks
   * The GUID of the table in DMS.
   * 
   * > 
   * 
   * *   If the database to which the table belongs is a logical database, you can call the [ListLogicTables](https://help.aliyun.com/document_detail/141875.html) operation to obtain the GUID. The value of the ReturnGuid parameter must be set to true.
   * 
   * *   If the database to which the table belongs is a physical database, you can call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation to obtain the GUID. The value of the ReturnGuid parameter must be set to true.
   * 
   * This parameter is required.
   * 
   * @example
   * IDB_L_9032.db-test.yuyang_test
   */
  tableGuid?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      tableGuid: 'TableGuid',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tableGuid: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDBTopologyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The topology of the data table.
   */
  DBTopology?: GetTableDBTopologyResponseBodyDBTopology;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 853F7FD4-D922-4EFB-931C-D253EF159E06
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      DBTopology: 'DBTopology',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DBTopology: GetTableDBTopologyResponseBodyDBTopology,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDBTopologyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTableDBTopologyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTableDBTopologyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDesignProjectFlowRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the schema design ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 95****
   */
  orderId?: number;
  /**
   * @remarks
   * The tenant ID.
   * 
   * >  To view the tenant ID, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the "Manage DMS tenants" topic.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDesignProjectFlowResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The information about the schema design process.
   */
  projectFlow?: GetTableDesignProjectFlowResponseBodyProjectFlow;
  /**
   * @remarks
   * The request ID. You can use the request ID to query logs and troubleshoot issues.
   * 
   * @example
   * B5FD0BC8-2D90-4478-B8EC-A0E92E0B1773
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      projectFlow: 'ProjectFlow',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      projectFlow: GetTableDesignProjectFlowResponseBodyProjectFlow,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDesignProjectFlowResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTableDesignProjectFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTableDesignProjectFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDesignProjectInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the schema design ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/465867.html) operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 95****
   */
  orderId?: number;
  /**
   * @remarks
   * The tenant ID.
   * 
   * >  To view the tenant ID, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the "Manage DMS tenants" topic
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDesignProjectInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The information about the schema design project.
   */
  projectInfo?: GetTableDesignProjectInfoResponseBodyProjectInfo;
  /**
   * @remarks
   * The request ID. You can use the request ID to query logs and troubleshoot issues.
   * 
   * @example
   * 48778434-5796-571A-8455-A59146588401
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      projectInfo: 'ProjectInfo',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      projectInfo: GetTableDesignProjectInfoResponseBodyProjectInfo,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDesignProjectInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTableDesignProjectInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTableDesignProjectInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableTopologyRequest extends $tea.Model {
  /**
   * @remarks
   * The GUID of the table in Data Management (DMS).
   * 
   * > 
   * > - You can call the [ListLogicTables](https://help.aliyun.com/document_detail/141875.html) operation with ReturnGuid set to true to query the GUIDs of logical tables in a specific logical database.
   * > - You can call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation with ReturnGuid set to true to query the GUIDs of tables in a specific physical database.
   * 
   * This parameter is required.
   * 
   * @example
   * IDB_L_308302.yuyang_test.test_ch
   */
  tableGuid?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Tenant information](https://help.aliyun.com/document_detail/181330.html) topic.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      tableGuid: 'TableGuid',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tableGuid: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableTopologyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F5ED6A40-F344-4C7D-A8F0-5685CA584CA7
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The topology information.
   */
  tableTopology?: GetTableTopologyResponseBodyTableTopology;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      tableTopology: 'TableTopology',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      tableTopology: GetTableTopologyResponseBodyTableTopology,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableTopologyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTableTopologyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTableTopologyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task node. You can call the [GetTaskInstanceRelation](https://help.aliyun.com/document_detail/424711.html) operation to query the node ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 51***
   */
  nodeId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * 7838266C-E17B-58F4-B072-4DC356B58258
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The task node.
   */
  task?: GetTaskResponseBodyTask;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      task: 'Task',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      task: GetTaskResponseBodyTask,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskFlowGraphRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 15***
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskFlowGraphResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * D9D91166-A626-5F4E-9CA6-7AB10C59DBD8
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The list of DAG variables of the task flow.
   */
  taskFlowGraph?: GetTaskFlowGraphResponseBodyTaskFlowGraph;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      taskFlowGraph: 'TaskFlowGraph',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      taskFlowGraph: GetTaskFlowGraphResponseBodyTaskFlowGraph,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskFlowGraphResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTaskFlowGraphResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTaskFlowGraphResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskFlowNotificationRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 15***
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskFlowNotificationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The notification settings specified by the user.
   */
  notification?: GetTaskFlowNotificationResponseBodyNotification;
  /**
   * @remarks
   * The ID of the request. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * F19D575F-EBEA-5683-AFA3-A8F6D9A7DE03
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      notification: 'Notification',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      notification: GetTaskFlowNotificationResponseBodyNotification,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskFlowNotificationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTaskFlowNotificationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTaskFlowNotificationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskInstanceRelationRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to obtain the ID of the task flow.
   * 
   * This parameter is required.
   * 
   * @example
   * 7***
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the execution record of the task flow. You can call the [ListTaskFlowInstance](https://help.aliyun.com/document_detail/424689.html) operation to obtain the execution record ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 47****
   */
  dagInstanceId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      dagInstanceId: 'DagInstanceId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      dagInstanceId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskInstanceRelationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request fails.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request fails.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The information about the nodes in the execution record of the task flow.
   */
  nodeList?: GetTaskInstanceRelationResponseBodyNodeList;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 028BF827-3801-5869-8548-F4A039256304
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**: The request is successful.
   * *   **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      nodeList: 'NodeList',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      nodeList: GetTaskInstanceRelationResponseBodyNodeList,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskInstanceRelationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTaskInstanceRelationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTaskInstanceRelationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  /**
   * @remarks
   * The UID of the Alibaba Cloud account. You can view your UID by moving the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console.
   * 
   * @example
   * 22973492647626****
   */
  uid?: string;
  /**
   * @remarks
   * The ID of the user. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) operation to query the ID of the user.
   * 
   * @example
   * 51****
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      tid: 'Tid',
      uid: 'Uid',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tid: 'number',
      uid: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * Unknown server error
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 804BB128-CAFA-5DD0-BA1E-43DDE488****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The information about the user.
   */
  user?: GetUserResponseBodyUser;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      user: GetUserResponseBodyUser,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserActiveTenantRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserActiveTenantResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * TenantNotExist
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified tenant does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4B63CAC5-BD7F-5C7C-82C9-59DFFBC3C5C2
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**: The request is successful.
   * *   **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The details of the tenant.
   */
  tenant?: GetUserActiveTenantResponseBodyTenant;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      tenant: 'Tenant',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      tenant: GetUserActiveTenantResponseBodyTenant,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserActiveTenantResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetUserActiveTenantResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetUserActiveTenantResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserUploadFileJobRequest extends $tea.Model {
  /**
   * @remarks
   * The key of the file upload task. The key is returned when you call the [CreateUploadFileJob](https://help.aliyun.com/document_detail/206059.html) or [CreateUploadOSSFileJob](https://help.aliyun.com/document_detail/206060.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 65254a49100e
   */
  jobKey?: string;
  /**
   * @remarks
   * The tenant ID.
   * 
   * > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * -1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      jobKey: 'JobKey',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobKey: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserUploadFileJobResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * BDEFE9F2-B3B4-42D0-83AE-ECF9FC067DCD
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The details of the file upload task.
   */
  uploadFileJobDetail?: GetUserUploadFileJobResponseBodyUploadFileJobDetail;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      uploadFileJobDetail: 'UploadFileJobDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      uploadFileJobDetail: GetUserUploadFileJobResponseBodyUploadFileJobDetail,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserUploadFileJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetUserUploadFileJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetUserUploadFileJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrantTemplateAuthorityRequest extends $tea.Model {
  /**
   * @remarks
   * The reason why you want to grant permissions on resources to the users by using the permission template.
   * 
   * @example
   * Business test.
   */
  comment?: string;
  /**
   * @remarks
   * The time when the permission expires. Specify the time in the yyyy-MM-DD HH:mm:ss format.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-03-08 17:58:53
   */
  expireDate?: string;
  /**
   * @remarks
   * The ID of the permission template.
   * 
   * This parameter is required.
   * 
   * @example
   * 1563
   */
  templateId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  /**
   * @remarks
   * The IDs of users to which you want to grant permissions on resources by using the permission template.
   * 
   * This parameter is required.
   * 
   * @example
   * [12***,34***,56***]
   */
  userIds?: string;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      expireDate: 'ExpireDate',
      templateId: 'TemplateId',
      tid: 'Tid',
      userIds: 'UserIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      expireDate: 'string',
      templateId: 'number',
      tid: 'number',
      userIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrantTemplateAuthorityResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 34E01EDD-6A16-4CF0-9541-C644D1BE01AA
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the permissions on resources were granted to the users by using the permission template.
   * 
   * @example
   * true
   */
  result?: boolean;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true: The request was successful.
   * *   false: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: 'boolean',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrantTemplateAuthorityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GrantTemplateAuthorityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GrantTemplateAuthorityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrantUserPermissionRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the database. You can call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) operation to query the ID of a physical database and the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) operation to query the ID of a logical database.
   * 
   * >  The value of the DatabaseId parameter is that of the DbId parameter.
   * 
   * @example
   * 1***
   */
  dbId?: string;
  /**
   * @remarks
   * The permissions on a specific type of object that you want to grant to the user. Valid values:
   * 
   * *   INSTANCE: permissions on instances
   * *   DATABASE: permissions on physical databases
   * *   LOGIC_DATABASE: permissions on logical databases
   * *   TABLE: permissions on physical tables
   * *   LOGIC_TABLE: permissions on logical tables
   * 
   * This parameter is required.
   * 
   * @example
   * DATABASE
   */
  dsType?: string;
  /**
   * @remarks
   * The time when the permissions expire.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-12-12 00:00:00
   */
  expireDate?: string;
  /**
   * @remarks
   * The ID of the instance. You must specify this parameter if you grant permissions on an instance to the user. You can call the [ListInstances](https://help.aliyun.com/document_detail/141936.html) or [GetInstance](https://help.aliyun.com/document_detail/141567.html) operation to query the ID of the instance.
   * 
   * @example
   * 174****
   */
  instanceId?: number;
  /**
   * @remarks
   * Specifies whether the database is a logical database. You must specify this parameter if you grant permissions on a database to the user. Valid values:
   * 
   * *   true: The database is a logical database.
   * *   false: The database is a physical database.
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The permission type. Separate multiple permission types with commas (,). Valid values:
   * 
   * *   **QUERY**: the query permissions
   * *   **EXPORT**: the export permissions
   * *   **CORRECT**: the change permissions
   * *   **LOGIN**: the logon permissions
   * *   **PERF**: the query permissions on the performance details of the instance
   * 
   * This parameter is required.
   * 
   * @example
   * QUERY
   */
  permTypes?: string;
  /**
   * @remarks
   * The ID of the table. You must specify this parameter if you grant permissions on a table to the user. You can call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation to query the table ID.
   * 
   * @example
   * 132***
   */
  tableId?: string;
  /**
   * @remarks
   * The name of the table. You must specify this parameter if you grant permissions on a table to the user.
   * 
   * @example
   * table_name
   */
  tableName?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
   * 
   * @example
   * 3***
   */
  tid?: number;
  /**
   * @remarks
   * The ID of the user. You can call the [GetUser](https://help.aliyun.com/document_detail/147098.html) or [ListUsers](https://help.aliyun.com/document_detail/141938.html) operation to query the ID of the user.
   * 
   * >  The user ID is different from the ID of your Alibaba Cloud account.
   * 
   * This parameter is required.
   * 
   * @example
   * 51****
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      dsType: 'DsType',
      expireDate: 'ExpireDate',
      instanceId: 'InstanceId',
      logic: 'Logic',
      permTypes: 'PermTypes',
      tableId: 'TableId',
      tableName: 'TableName',
      tid: 'Tid',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'string',
      dsType: 'string',
      expireDate: 'string',
      instanceId: 'number',
      logic: 'boolean',
      permTypes: 'string',
      tableId: 'string',
      tableName: 'string',
      tid: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrantUserPermissionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * A99CD576-1E18-4E86-931E-C3CCE56DC030
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true: The request was successful.
   * *   false: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GrantUserPermissionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GrantUserPermissionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GrantUserPermissionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InspectProxyAccessSecretRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the security protection authorization. After the security protection agent authorizes the target user, the system automatically generates a security protection authorization ID. The ID is globally unique. You can call the [ListProxyAccesses](https://www.alibabacloud.com/help/en/data-management-service/latest/listproxyaccesses) operation to obtain this parameter.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  proxyAccessId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) or [ListUserTenants](https://www.alibabacloud.com/help/en/data-management-service/latest/listusertenants) operation to obtain this parameter.
   * 
   * @example
   * 1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      proxyAccessId: 'ProxyAccessId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      proxyAccessId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InspectProxyAccessSecretResponseBody extends $tea.Model {
  /**
   * @remarks
   * The authorization password of the security protection agent.
   * 
   * @example
   * xxx
   */
  accessSecret?: string;
  /**
   * @remarks
   * The error code returned to the query task.
   * 
   * @example
   * 200
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message that is returned.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0C1CB646-1DE4-4AD0-B4A4-7D47DD52E931
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the call was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      accessSecret: 'AccessSecret',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessSecret: 'string',
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InspectProxyAccessSecretResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: InspectProxyAccessSecretResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: InspectProxyAccessSecretResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAuthorityTemplateRequest extends $tea.Model {
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  searchKey?: string;
  /**
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchKey: 'SearchKey',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      searchKey: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAuthorityTemplateResponseBody extends $tea.Model {
  authorityTemplateViewList?: ListAuthorityTemplateResponseBodyAuthorityTemplateViewList;
  /**
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @example
   * 31853A2B-DC9D-5B39-8492-D2AC8BCF550E
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 3***
   */
  tid?: number;
  /**
   * @example
   * 10
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      authorityTemplateViewList: 'AuthorityTemplateViewList',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      tid: 'Tid',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorityTemplateViewList: ListAuthorityTemplateResponseBodyAuthorityTemplateViewList,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      tid: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAuthorityTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListAuthorityTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAuthorityTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClassificationTemplatesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClassificationTemplatesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 90260530-565C-42B9-A6E8-893481FE6AB6
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The list of templates.
   */
  templateList?: ListClassificationTemplatesResponseBodyTemplateList[];
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      templateList: 'TemplateList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      templateList: { 'type': 'array', 'itemType': ListClassificationTemplatesResponseBodyTemplateList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClassificationTemplatesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListClassificationTemplatesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListClassificationTemplatesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListColumnsRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether the database is a logical database. Valid values:
   * 
   * *   **true**: The database is a logical database.
   * *   **false**: The database is a physical database.
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The ID of the table. You can call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation to obtain the table ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 39281****
   */
  tableId?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      logic: 'Logic',
      tableId: 'TableId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logic: 'boolean',
      tableId: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListColumnsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details about columns.
   */
  columnList?: ListColumnsResponseBodyColumnList;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0AD9AC55-5873-474A-9F33-4285806A3619
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      columnList: 'ColumnList',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnList: ListColumnsResponseBodyColumnList,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListColumnsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListColumnsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListColumnsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDAGVersionsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to obtain the ID of the task flow.
   * 
   * This parameter is required.
   * 
   * @example
   * 7***
   */
  dagId?: number;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageIndex?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      pageIndex: 'PageIndex',
      pageSize: 'PageSize',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      pageIndex: 'number',
      pageSize: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDAGVersionsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the published versions.
   */
  dagVersionList?: ListDAGVersionsResponseBodyDagVersionList;
  /**
   * @remarks
   * The error code returned if the request fails.
   * 
   * @example
   * 403
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request fails.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C7775630-7901-51B9-8782-9B585EC0799A
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**: The request is successful.
   * *   **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      dagVersionList: 'DagVersionList',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagVersionList: ListDAGVersionsResponseBodyDagVersionList,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDAGVersionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDAGVersionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDAGVersionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDBTaskSQLJobRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the SQL task group. You can call the [GetStructSyncJobDetail](https://help.aliyun.com/document_detail/206160.html) operation to obtain this parameter.
   * 
   * This parameter is required.
   * 
   * @example
   * 1324235
   */
  DBTaskGroupId?: number;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      DBTaskGroupId: 'DBTaskGroupId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DBTaskGroupId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDBTaskSQLJobResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of the SQL tasks.
   */
  DBTaskSQLJobList?: ListDBTaskSQLJobResponseBodyDBTaskSQLJobList[];
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F6C47680-8D2D-43A4-8902-F2740D71A398
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of the SQL tasks.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      DBTaskSQLJobList: 'DBTaskSQLJobList',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DBTaskSQLJobList: { 'type': 'array', 'itemType': ListDBTaskSQLJobResponseBodyDBTaskSQLJobList },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDBTaskSQLJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDBTaskSQLJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDBTaskSQLJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDBTaskSQLJobDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the SQL task. You can call the [ListDBTaskSQLJob](https://help.aliyun.com/document_detail/207049.html) operation to query the SQL task ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1276****
   */
  jobId?: number;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDBTaskSQLJobDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of SQL tasks.
   */
  DBTaskSQLJobDetailList?: ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList[];
  /**
   * @remarks
   * The error code that is returned.
   * 
   * @example
   * MissingJobId
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message that is returned.
   * 
   * @example
   * JobId is mandatory for this action.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3F044E33-FE09-58F1-8C61-A0F612EC****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**: The request is successful.
   * *   **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of SQL tasks.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      DBTaskSQLJobDetailList: 'DBTaskSQLJobDetailList',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DBTaskSQLJobDetailList: { 'type': 'array', 'itemType': ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDBTaskSQLJobDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDBTaskSQLJobDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDBTaskSQLJobDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDDLPublishRecordsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ticket.
   * 
   * > You can create a schema design ticket in the Data Management (DMS) console. For more information, see [Design schemas](https://help.aliyun.com/document_detail/69711.html). You can also call the [CreateOrder](https://help.aliyun.com/document_detail/144649.html) operation to create a schema design ticket and obtain the ID of the ticket.
   * 
   * This parameter is required.
   * 
   * @example
   * 3214325
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the ID of the tenant, log on to the DMS console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDDLPublishRecordsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the publishing records.
   */
  DDLPublishRecordList?: ListDDLPublishRecordsResponseBodyDDLPublishRecordList[];
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * A1549FB0-D4B8-4140-919F-17322C1072B8
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      DDLPublishRecordList: 'DDLPublishRecordList',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DDLPublishRecordList: { 'type': 'array', 'itemType': ListDDLPublishRecordsResponseBodyDDLPublishRecordList },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDDLPublishRecordsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDDLPublishRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDDLPublishRecordsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataCorrectPreCheckDBRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ticket for the data change.
   * 
   * This parameter is required.
   * 
   * @example
   * 432****
   */
  orderId?: number;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * Valid values: an integer that is greater than 0.
   * 
   * Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the ID of the tenant.
   * 
   * @example
   * 4321****
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataCorrectPreCheckDBResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The information about the databases that are involved in the precheck.
   */
  preCheckDBList?: ListDataCorrectPreCheckDBResponseBodyPreCheckDBList[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 95A972AF-FAED-4768-9360-7C0DF5D594D0
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      preCheckDBList: 'PreCheckDBList',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      preCheckDBList: { 'type': 'array', 'itemType': ListDataCorrectPreCheckDBResponseBodyPreCheckDBList },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataCorrectPreCheckDBResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDataCorrectPreCheckDBResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDataCorrectPreCheckDBResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataCorrectPreCheckSQLRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the database. The database can be a physical database or a logical database.
   * 
   * *   To query the ID of a physical database, call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation.
   * *   To query the ID of a logical database, call the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation.
   * 
   * @example
   * 1930****
   */
  dbId?: number;
  /**
   * @remarks
   * The ID of the data change ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ID of the data change ticket.
   * 
   * This parameter is required.
   * 
   * @example
   * 453****
   */
  orderId?: number;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      orderId: 'OrderId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      orderId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataCorrectPreCheckSQLResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The precheck information about SQL statements.
   */
  preCheckSQLList?: ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 31853A2B-DC9D-5B39-8492-D2AC8BCF550E
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**: The request is successful.
   * *   **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      preCheckSQLList: 'PreCheckSQLList',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      preCheckSQLList: { 'type': 'array', 'itemType': ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataCorrectPreCheckSQLResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDataCorrectPreCheckSQLResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDataCorrectPreCheckSQLResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataImportSQLPreCheckDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The ticket ID. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ticket ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 11****
   */
  orderId?: number;
  /**
   * @remarks
   * The page number. Pages start from page 1.
   * 
   * @example
   * 1
   */
  pageNumer?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The type of the SQL statement. Valid values:
   * 
   * *   **SELECT**
   * *   **INSERT**
   * *   **DELETE**
   * *   **CREATE_TABLE**
   * 
   * > You can log on to the Data Management (DMS) console and choose **Security and Specifications** > **Operation Audit** in the top navigation bar to view more types of SQL statements.
   * 
   * @example
   * INSERT
   */
  sqlType?: string;
  /**
   * @remarks
   * The state of the ticket. If you leave this parameter empty, all the states are queried by default. Valid values:
   * 
   * *   **INIT**: The ticket is being initialized.
   * *   **RUNNING**: The ticket is in progress.
   * *   **SUCCESS**: The ticket is complete.
   * *   **TIMEOUT**: The ticket is skipped due to timeout.
   * *   **FAIL**: The ticket fails.
   * 
   * @example
   * SUCCESS
   */
  statusCode?: string;
  /**
   * @remarks
   * The tenant ID. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
   * 
   * @example
   * 1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      pageNumer: 'PageNumer',
      pageSize: 'PageSize',
      sqlType: 'SqlType',
      statusCode: 'StatusCode',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      pageNumer: 'number',
      pageSize: 'number',
      sqlType: 'string',
      statusCode: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataImportSQLPreCheckDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The precheck information of SQL statements.
   */
  preCheckSQLDetailList?: ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList[];
  /**
   * @remarks
   * The request ID. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * 31853A2B-DC9D-5B39-8492-D2AC8BCF550E
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The number of SQL statements.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      preCheckSQLDetailList: 'PreCheckSQLDetailList',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      preCheckSQLDetailList: { 'type': 'array', 'itemType': ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList },
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataImportSQLPreCheckDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDataImportSQLPreCheckDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDataImportSQLPreCheckDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataImportSQLTypeRequest extends $tea.Model {
  /**
   * @remarks
   * The ticket ID. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ticket ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 420****
   */
  orderId?: number;
  /**
   * @remarks
   * The tenant ID. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
   * 
   * @example
   * 1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataImportSQLTypeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The request ID. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * E5EE2B9E-2F95-57FA-B284-CB441CEE49D6
   */
  requestId?: string;
  /**
   * @remarks
   * The types of SQL statements.
   */
  sqlTypeResult?: string[];
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      sqlTypeResult: 'SqlTypeResult',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      sqlTypeResult: { 'type': 'array', 'itemType': 'string' },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataImportSQLTypeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDataImportSQLTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDataImportSQLTypeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabaseUserPermssionsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the database.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  dbId?: string;
  /**
   * @remarks
   * Specifies whether the database is a logical database.
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The type of the permission. Valid values:
   * 
   * *   DATABASE: permissions on databases
   * *   TABLE: permissions on tables
   * *   COLUMN: permissions on fields
   * 
   * This parameter is required.
   * 
   * @example
   * DATABASE
   */
  permType?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * -1
   */
  tid?: number;
  /**
   * @remarks
   * The nickname of the user.
   * 
   * @example
   * search_user_name
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      logic: 'Logic',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      permType: 'PermType',
      tid: 'Tid',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'string',
      logic: 'boolean',
      pageNumber: 'number',
      pageSize: 'number',
      permType: 'string',
      tid: 'number',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabaseUserPermssionsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 68075D06-7406-4887-83A7-F558A4D28C13
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  /**
   * @remarks
   * The details of user permissions.
   */
  userPermissions?: ListDatabaseUserPermssionsResponseBodyUserPermissions;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
      userPermissions: 'UserPermissions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
      userPermissions: ListDatabaseUserPermssionsResponseBodyUserPermissions,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabaseUserPermssionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDatabaseUserPermssionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDatabaseUserPermssionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabasesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance. The valid value is returned if you call the ListInstances operation. The instance ID is not the ID of the RDS instance.
   * 
   * This parameter is required.
   * 
   * @example
   * 12***
   */
  instanceId?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabasesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the databases.
   */
  databaseList?: ListDatabasesResponseBodyDatabaseList;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 5541CDA6-F674-435C-81BD-40C2FB926CE3
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The number of databases that belong to an instance.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      databaseList: 'DatabaseList',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseList: ListDatabasesResponseBodyDatabaseList,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabasesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDatabasesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDatabasesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDefaultSLARulesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 11****
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDefaultSLARulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * 3E8AF4C3-A822-53A8-970C-059EE83BBD5A
   */
  requestId?: string;
  /**
   * @remarks
   * The list of SLA rules.
   */
  SLARuleList?: ListDefaultSLARulesResponseBodySLARuleList;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      SLARuleList: 'SLARuleList',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      SLARuleList: ListDefaultSLARulesResponseBodySLARuleList,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDefaultSLARulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDefaultSLARulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDefaultSLARulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDesensitizationRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the masking algorithm.
   * 
   * @example
   * MD5
   */
  funcType?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. The maximum value is 100.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the masking rule.
   * 
   * @example
   * 1
   */
  ruleId?: number;
  /**
   * @remarks
   * The name of the masking rule.
   * 
   * @example
   * default desensitization rule test
   */
  ruleName?: string;
  /**
   * @remarks
   * The algorithm used for masking.
   * 
   * @example
   * HASH
   */
  ruleType?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      funcType: 'FuncType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      ruleType: 'RuleType',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      funcType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      ruleId: 'number',
      ruleName: 'string',
      ruleType: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDesensitizationRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of masking rules.
   */
  desensitizationRuleList?: ListDesensitizationRuleResponseBodyDesensitizationRuleList[];
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * This parameter is required.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E76DD2E7-EBAC-5724-B163-19AAC233F8F2
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true: The request was successful.
   * *   false: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of entries returned. By default, this parameter is not returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      desensitizationRuleList: 'DesensitizationRuleList',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desensitizationRuleList: { 'type': 'array', 'itemType': ListDesensitizationRuleResponseBodyDesensitizationRuleList },
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDesensitizationRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDesensitizationRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDesensitizationRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEffectiveOrdersRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEffectiveOrdersResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The information about orders.
   */
  orderSummary?: ListEffectiveOrdersResponseBodyOrderSummary[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * A8FE12AA-300D-5FDF-806F-C2CB99161F32
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      orderSummary: 'OrderSummary',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      orderSummary: { 'type': 'array', 'itemType': ListEffectiveOrdersResponseBodyOrderSummary },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEffectiveOrdersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEffectiveOrdersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEffectiveOrdersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListIndexesRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether the table is a logical table.
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The ID of the table.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  tableId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 0
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      logic: 'Logic',
      tableId: 'TableId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logic: 'boolean',
      tableId: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListIndexesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The details of indexes.
   */
  indexList?: ListIndexesResponseBodyIndexList;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 1F4DE2F1-5B47-462A-A973-E02EB7AF386B
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      indexList: 'IndexList',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      indexList: ListIndexesResponseBodyIndexList,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListIndexesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListIndexesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListIndexesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceLoginAuditLogRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * >  The end time supports fuzzy match. Specify the time in the YYYY-MM-DD hh:mm:ss format. We recommend that you use the StartTime and EndTime parameters to specify a time range that does not exceed one day. This way, the returned entries can be displayed by page to increase query efficiency.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-11-18 18:00:00
   */
  endTime?: string;
  /**
   * @remarks
   * The alias of the user.
   * 
   * @example
   * test_OpUserName
   */
  opUserName?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 100.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The name of the database or instance whose logon records you want to query.
   * 
   * >  If SQL statements are executed at the instance level, you can set this parameter to an instance name. If SQL statements are executed at the database level, you can set this parameter to a database name.
   * 
   * @example
   * test_SearchName
   */
  searchName?: string;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * >  The start time supports fuzzy match. Specify the time in the YYYY-MM-DD hh:mm:ss format.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-11-18 11:00:00
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      opUserName: 'OpUserName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchName: 'SearchName',
      startTime: 'StartTime',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      opUserName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchName: 'string',
      startTime: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceLoginAuditLogResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * InvalidPageSize
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * Specified parameter PageSize is not valid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The logon records of the instance.
   */
  instanceLoginAuditLogList?: ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 074CE7C9-4F9C-5B62-89BC-7B4914A3****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The number of entries returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      instanceLoginAuditLogList: 'InstanceLoginAuditLogList',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      instanceLoginAuditLogList: ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList,
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceLoginAuditLogResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListInstanceLoginAuditLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListInstanceLoginAuditLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceUserPermissionsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance. You can call the [ListInstances](https://help.aliyun.com/document_detail/141936.html) or [GetInstance](https://help.aliyun.com/document_detail/141567.html) operation to query the ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * 174****
   */
  instanceId?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 100
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
   * 
   * @example
   * 3***
   */
  tid?: number;
  /**
   * @remarks
   * The nickname of the user. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to query the nickname of the user.
   * 
   * >  The value of the NickName parameter is that of the UserName parameter.
   * 
   * @example
   * test_nick_name
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tid: 'Tid',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      tid: 'number',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceUserPermissionsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 7D162AAE-6501-5691-BF14-D7018F662895
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * - true: The request is successful.
   * - false: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  /**
   * @remarks
   * The permissions of the user on the instance.
   */
  userPermissions?: ListInstanceUserPermissionsResponseBodyUserPermissions;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
      userPermissions: 'UserPermissions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
      userPermissions: ListInstanceUserPermissionsResponseBodyUserPermissions,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceUserPermissionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListInstanceUserPermissionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListInstanceUserPermissionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstancesRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the database. For more information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
   * 
   * @example
   * MySQL
   */
  dbType?: string;
  /**
   * @remarks
   * The type of the environment to which the database instance belongs. Valid values:
   * 
   * *   **product:** production environment
   * *   **dev**: development environment
   * *   **pre**: pre-release environment
   * *   **test**: test environment
   * *   **sit**: system integration testing (SIT) environment
   * *   **uat**: user acceptance testing (UAT) environment
   * *   **pet**: stress testing environment
   * *   **stag:** staging environment
   * 
   * @example
   * product
   */
  envType?: string;
  /**
   * @remarks
   * The source of the database instance. Valid values:
   * 
   * *   **PUBLIC_OWN**: a self-managed database instance that is deployed on the Internet
   * *   **RDS**: an ApsaraDB RDS instance
   * *   **ECS_OWN**: a self-managed database that is deployed on an Elastic Compute Service (ECS) instance
   * *   **VPC_IDC**: a self-managed database instance that is deployed in a data center connected over a virtual private cloud (VPC)
   * 
   * @example
   * RDS
   */
  instanceSource?: string;
  /**
   * @remarks
   * The status of the database instance. Valid values:
   * 
   * *   **NORMAL**
   * *   **DISABLE**
   * 
   * @example
   * NORMAL
   */
  instanceState?: string;
  /**
   * @remarks
   * The network type of the database instance. Valid values:
   * 
   * *   **CLASSIC:** classic network
   * *   **VPC:** VPC
   * 
   * @example
   * VPC
   */
  netType?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. The number cannot exceed 100.
   * 
   * @example
   * 50
   */
  pageSize?: number;
  /**
   * @remarks
   * The keyword that is used to search for database instances.
   * 
   * @example
   * test
   */
  searchKey?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dbType: 'DbType',
      envType: 'EnvType',
      instanceSource: 'InstanceSource',
      instanceState: 'InstanceState',
      netType: 'NetType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchKey: 'SearchKey',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbType: 'string',
      envType: 'string',
      instanceSource: 'string',
      instanceState: 'string',
      netType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchKey: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstancesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code that is returned.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message that is returned.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The information about the database instances that are returned.
   */
  instanceList?: ListInstancesResponseBodyInstanceList;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * B4B07137-F6AE-4756-8474-7F92BB6C4E04
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of database instances that are returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      instanceList: 'InstanceList',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      instanceList: ListInstancesResponseBodyInstanceList,
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLhTaskFlowAndScenarioRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the workspace. You can call the [GetLhSpaceByName](https://help.aliyun.com/document_detail/424379.html) operation to obtain the workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 24
   */
  spaceId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  /**
   * @remarks
   * The ID of the user. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to obtain the user ID.
   * 
   * @example
   * 51****
   */
  userId?: number;
  static names(): { [key: string]: string } {
    return {
      spaceId: 'SpaceId',
      tid: 'Tid',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      spaceId: 'number',
      tid: 'number',
      userId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLhTaskFlowAndScenarioResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request fails.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request fails.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The task flows in the default business scenario.
   */
  rawDAGList?: ListLhTaskFlowAndScenarioResponseBodyRawDAGList;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 48602B78-0DDF-414C-8688-70CAB6070115
   */
  requestId?: string;
  /**
   * @remarks
   * The task flows in other business scenarios.
   */
  scenarioDAGList?: ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * - **true**: The request is successful.
   * - **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      rawDAGList: 'RawDAGList',
      requestId: 'RequestId',
      scenarioDAGList: 'ScenarioDAGList',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      rawDAGList: ListLhTaskFlowAndScenarioResponseBodyRawDAGList,
      requestId: 'string',
      scenarioDAGList: ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLhTaskFlowAndScenarioResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListLhTaskFlowAndScenarioResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListLhTaskFlowAndScenarioResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicDatabasesRequest extends $tea.Model {
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 50
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the tenant ID.
   * 
   * @example
   * 3422
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicDatabasesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code that is returned.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message that is returned.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The details of logical databases.
   */
  logicDatabaseList?: ListLogicDatabasesResponseBodyLogicDatabaseList;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 8068AF82-8A1A-592C-AC2E-6B75338BAB87
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * - **true**: The request is successful.
   * - **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of logical databases.
   * 
   * @example
   * 7
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      logicDatabaseList: 'LogicDatabaseList',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      logicDatabaseList: ListLogicDatabasesResponseBodyLogicDatabaseList,
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicDatabasesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListLogicDatabasesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListLogicDatabasesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicTableRouteConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the logical table. You can call the [ListLogicTables](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogictables) operation to query the ID of the logical table.
   * 
   * This parameter is required.
   * 
   * @example
   * 1****
   */
  tableId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      tableId: 'TableId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tableId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicTableRouteConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * MissingTableId
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * TableId is mandatory for this action.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The routing algorithms.
   */
  logicTableRouteConfigList?: ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 7C6A0D7D-B034-59F6-854C-32425AC6****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * - **true**: The request was successful.
   * - **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      logicTableRouteConfigList: 'LogicTableRouteConfigList',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      logicTableRouteConfigList: ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicTableRouteConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListLogicTableRouteConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListLogicTableRouteConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicTablesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the logical database.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  databaseId?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * Specifies whether to return the GUID of the table.
   * 
   * @example
   * true
   */
  returnGuid?: boolean;
  /**
   * @remarks
   * The keyword that is used to search for the logical tables. Prefix match is supported.
   * 
   * @example
   * test
   */
  searchName?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * -1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      databaseId: 'DatabaseId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      returnGuid: 'ReturnGuid',
      searchName: 'SearchName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      returnGuid: 'boolean',
      searchName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicTablesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The details of the logical tables.
   */
  logicTableList?: ListLogicTablesResponseBodyLogicTableList;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F1E6484F-9DF1-4406-9BDE-0861C4629B69
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of logical tables that meet the query conditions.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      logicTableList: 'LogicTableList',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      logicTableList: ListLogicTablesResponseBodyLogicTableList,
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicTablesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListLogicTablesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListLogicTablesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrdersRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * @example
   * 2022-04-09 11:00:00
   */
  endTime?: string;
  /**
   * @remarks
   * The scope of the tickets that you want to query. Valid values:
   * 
   * *   **AS_ADMIN**: all tickets.
   * *   **AS_COMMITTER**: the tickets that are submitted by the current user.
   * *   **AS_HANDLER**: the tickets to be processed by the current user.
   * *   **AS_OWNER**: the tickets that are processed by the current user.
   * *   **AS_Related**: the tickets that are related to the current user.
   * 
   * @example
   * AS_ADMIN
   */
  orderResultType?: string;
  /**
   * @remarks
   * The status of the tickets that you want to query. Valid values:
   * 
   * *   **ALL**: queries the tickets of all statuses.
   * *   **FINISHED**: queries the tickets that are completed.
   * *   **RUNNING**: queries the tickets that are being processed.
   * 
   * @example
   * ALL
   */
  orderStatus?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The type of the tickets that you want to query. For more information, see [PluginType parameter](https://help.aliyun.com/document_detail/429109.html).
   * 
   * @example
   * DC_COMMON
   */
  pluginType?: string;
  /**
   * @remarks
   * The keyword that is used to query tickets.
   * 
   * @example
   * test
   */
  searchContent?: string;
  /**
   * @remarks
   * The time condition based on which you want to query tickets. Valid values:
   * 
   * *   **CREATE_TIME**: the time when a ticket was created.
   * *   **MODIFY_TIME**: the time when a ticket was last modified.
   * 
   * @example
   * CREATE_TIME
   */
  searchDateType?: string;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * @example
   * 2022-04-08 11:00:00
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3000
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      orderResultType: 'OrderResultType',
      orderStatus: 'OrderStatus',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      pluginType: 'PluginType',
      searchContent: 'SearchContent',
      searchDateType: 'SearchDateType',
      startTime: 'StartTime',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      orderResultType: 'string',
      orderStatus: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      pluginType: 'string',
      searchContent: 'string',
      searchDateType: 'string',
      startTime: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrdersResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The details about the tickets.
   */
  orders?: ListOrdersResponseBodyOrders;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 427688B8-ADFB-4C4E-9D45-EF5C1FD6E23D
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * - **true**: The request was successful.
   * - **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of entries that are returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      orders: 'Orders',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      orders: ListOrdersResponseBodyOrders,
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrdersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListOrdersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListOrdersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProxiesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProxiesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * User can not access to Tenant [123445]
   */
  errorMessage?: string;
  /**
   * @remarks
   * The proxies that are generated by the secure access proxy feature.
   */
  proxyList?: ListProxiesResponseBodyProxyList[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 5812180E-555F-5F90-BE4F-280576F4****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      proxyList: 'ProxyList',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      proxyList: { 'type': 'array', 'itemType': ListProxiesResponseBodyProxyList },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProxiesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProxiesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProxiesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProxyAccessesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the secure access proxy. 
   * 
   * >  You can call the [ListProxies](https://www.alibabacloud.com/help/en/data-management-service/latest/listproxies) operation to query the ID of the secure access proxy.
   * 
   * This parameter is required.
   * 
   * @example
   * 47
   */
  proxyId?: number;
  /**
   * @remarks
   * The ID of the tenant. 
   * 
   * >  You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the ID of the tenant.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      proxyId: 'ProxyId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      proxyId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProxyAccessesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * MissingProxyId
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * ProxyId is mandatory for this action.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The information about the users that are authorized to access the database instance by using the secure access proxy feature.
   */
  proxyAccessList?: ListProxyAccessesResponseBodyProxyAccessList[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E53D178A-85E9-5E1F-88B6-3CB1FCF2****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * - **true**: The request was successful.
   * - **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      proxyAccessList: 'ProxyAccessList',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      proxyAccessList: { 'type': 'array', 'itemType': ListProxyAccessesResponseBodyProxyAccessList },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProxyAccessesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProxyAccessesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProxyAccessesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProxySQLExecAuditLogRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. The value of this parameter must be a timestamp that follows the UNIX time format.
   * 
   * This parameter is required.
   * 
   * @example
   * 1636962846000
   */
  endTime?: number;
  /**
   * @remarks
   * The execution status of the SQL statement. Valid values:
   * 
   * *   **FAIL**: The execution of the SQL statement fails.
   * *   **CANCEL**: The execution of the SQL statement is canceled.
   * *   **SUCCESS**: The SQL statement is executed.
   * 
   * @example
   * SUCCESS
   */
  execState?: string;
  /**
   * @remarks
   * The alias of the user.
   * 
   * @example
   * testNickName
   */
  opUserName?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum values: 100.
   * 
   * @example
   * 100
   */
  pageSize?: number;
  /**
   * @remarks
   * The type of SQL statement. Valid values:
   * 
   * *   **SELECT**
   * *   **INSERT**
   * *   **DELETE**
   * *   **CREATE_TABLE**
   * 
   * >  You can choose Operation Audit > Secure Access Proxy in the top navigation bar of the DMS console to view more types of SQL statements.
   * 
   * @example
   * SELECT
   */
  SQLType?: string;
  /**
   * @remarks
   * The name of the database instance.
   * 
   * @example
   * test
   */
  searchName?: string;
  /**
   * @remarks
   * The beginning of the time range to query. The value of this parameter must be a timestamp that follows the UNIX time format.
   * 
   * This parameter is required.
   * 
   * @example
   * 1636876446000
   */
  startTime?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
   * 
   * @example
   * 14****
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      execState: 'ExecState',
      opUserName: 'OpUserName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      SQLType: 'SQLType',
      searchName: 'SearchName',
      startTime: 'StartTime',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      execState: 'string',
      opUserName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      SQLType: 'string',
      searchName: 'string',
      startTime: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProxySQLExecAuditLogResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * InvalidStartTime
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * Specified parameter StartTime is not valid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The audit information about the database instance that is provided by the secure access proxy feature.
   */
  proxySQLExecAuditLogList?: ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 50ECB006-2C35-5FCA-91B9-01987A0B****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The number of entries returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      proxySQLExecAuditLogList: 'ProxySQLExecAuditLogList',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      proxySQLExecAuditLogList: ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList,
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProxySQLExecAuditLogResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProxySQLExecAuditLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProxySQLExecAuditLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSLARulesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 11****
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSLARulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * 3D1A59F4-EB2B-5D24-80A5-90C446A00DE2
   */
  requestId?: string;
  /**
   * @remarks
   * The list of SLA rules.
   */
  SLARuleList?: ListSLARulesResponseBodySLARuleList;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      SLARuleList: 'SLARuleList',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      SLARuleList: ListSLARulesResponseBodySLARuleList,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSLARulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSLARulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSLARulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSQLExecAuditLogRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * >  The end time supports fuzzy match. Specify the time in the YYYY-MM-DD hh:mm:ss format. We recommend that you use the StartTime and EndTime parameters to specify a time range that does not exceed one day. The returned entries can be displayed by page to improve query efficiency.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-11-08 11:00:00
   */
  endTime?: string;
  /**
   * @remarks
   * The execution status of the SQL statement. Valid values:
   * 
   * *   **FAIL**: The SQL statement fails to be executed.
   * *   **NOEXE**: The SQL statement has not been executed.
   * *   **RUNNING**: The SQL statement is being executed.
   * *   **CANCEL**: The execution of the SQL statement is canceled.
   * *   **SUCCESS**: The SQL statement is executed.
   * 
   * @example
   * SUCCESS
   */
  execState?: string;
  /**
   * @remarks
   * The nickname of the user who wrote the SQL statement.
   * 
   * @example
   * test_OpUserName
   */
  opUserName?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. The value cannot exceed 100.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The name of the database or instance based on which you want to query SQL statements.
   * 
   * >  If the SQL statements to be queried are at the instance level, you can set this parameter to an instance name. If the SQL statements to be queried are at the database level, you can set this parameter to a database name.
   * 
   * @example
   * test_SearchName
   */
  searchName?: string;
  /**
   * @remarks
   * The type of the SQL statement. Valid values:
   * 
   * *   **SELECT**: the SQL statement that is used to query data.
   * *   **INSERT**: the SQL statement that is used to insert data.
   * *   **DELETE**: the SQL statement that is used to delete data.
   * *   **CREATE_TABLE**: the SQL statement that is used to create tables.
   * 
   * >  To view more types of SQL statements, log on to the DMS console and click Security and Specifications. In the left-side navigation pane, click **Operation Audit**. Then, you can view all supported types of SQL statements from the **SQL type** drop-down list.
   * 
   * @example
   * SELECT
   */
  sqlType?: string;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * >  The start time supports fuzzy match. Specify the time in the YYYY-MM-DD hh:mm:ss format.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-11-08 11:04:00
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      execState: 'ExecState',
      opUserName: 'OpUserName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchName: 'SearchName',
      sqlType: 'SqlType',
      startTime: 'StartTime',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      execState: 'string',
      opUserName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchName: 'string',
      sqlType: 'string',
      startTime: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSQLExecAuditLogResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * MissingStartTime
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * StartTime is mandatory for this action.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 39BC9C86-95AE-58F2-9862-A7C3D896****
   */
  requestId?: string;
  /**
   * @remarks
   * The entries returned.
   */
  SQLExecAuditLogList?: ListSQLExecAuditLogResponseBodySQLExecAuditLogList;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The number of entries returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      SQLExecAuditLogList: 'SQLExecAuditLogList',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      SQLExecAuditLogList: ListSQLExecAuditLogResponseBodySQLExecAuditLogList,
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSQLExecAuditLogResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSQLExecAuditLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSQLExecAuditLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSQLReviewOriginSQLRequest extends $tea.Model {
  /**
   * @remarks
   * The parameters that are used to filter SQL statements involved in the ticket.
   */
  orderActionDetail?: ListSQLReviewOriginSQLRequestOrderActionDetail;
  /**
   * @remarks
   * The ID of the ticket for the SQL review. You can call the [CreateSQLReviewOrder](https://help.aliyun.com/document_detail/257777.html) operation to query the ID of the ticket.
   * 
   * This parameter is required.
   * 
   * @example
   * 123321
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/465818.html) operation to query the ID of the tenant.
   * 
   * @example
   * 1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderActionDetail: 'OrderActionDetail',
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderActionDetail: ListSQLReviewOriginSQLRequestOrderActionDetail,
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSQLReviewOriginSQLShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The parameters that are used to filter SQL statements involved in the ticket.
   */
  orderActionDetailShrink?: string;
  /**
   * @remarks
   * The ID of the ticket for the SQL review. You can call the [CreateSQLReviewOrder](https://help.aliyun.com/document_detail/257777.html) operation to query the ID of the ticket.
   * 
   * This parameter is required.
   * 
   * @example
   * 123321
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/465818.html) operation to query the ID of the tenant.
   * 
   * @example
   * 1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderActionDetailShrink: 'OrderActionDetail',
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderActionDetailShrink: 'string',
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSQLReviewOriginSQLResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The information about the parsed SQL statements.
   */
  originSQLList?: ListSQLReviewOriginSQLResponseBodyOriginSQLList[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0C1CB646-1DE4-4AD0-B4A4-7D47DD52E931
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of the SQL statements.
   * 
   * @example
   * 10
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      originSQLList: 'OriginSQLList',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      originSQLList: { 'type': 'array', 'itemType': ListSQLReviewOriginSQLResponseBodyOriginSQLList },
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSQLReviewOriginSQLResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSQLReviewOriginSQLResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSQLReviewOriginSQLResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScenariosRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScenariosResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 7FAD400F-7A5C-4193-8F9A-39D86C4F0231
   */
  requestId?: string;
  /**
   * @remarks
   * The details of the returned business scenarios.
   */
  scenarioList?: ListScenariosResponseBodyScenarioList[];
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      scenarioList: 'ScenarioList',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      scenarioList: { 'type': 'array', 'itemType': ListScenariosResponseBodyScenarioList },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScenariosResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListScenariosResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListScenariosResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnInfoRequest extends $tea.Model {
  /**
   * @example
   * test_column
   */
  columnName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 183****
   */
  instanceId?: number;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 100
   */
  pageSize?: number;
  /**
   * @example
   * test_schema
   */
  schemaName?: string;
  /**
   * @example
   * test_table
   */
  tableName?: string;
  /**
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      schemaName: 'SchemaName',
      tableName: 'TableName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      instanceId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      schemaName: 'string',
      tableName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnInfoResponseBody extends $tea.Model {
  /**
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @example
   * 0C1CB646-1DE4-4AD0-B4A4-7D47DD52E931
   */
  requestId?: string;
  sensitiveColumnList?: ListSensitiveColumnInfoResponseBodySensitiveColumnList;
  /**
   * @example
   * true
   */
  success?: boolean;
  /**
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      sensitiveColumnList: 'SensitiveColumnList',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      sensitiveColumnList: ListSensitiveColumnInfoResponseBodySensitiveColumnList,
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSensitiveColumnInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSensitiveColumnInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnsRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the field. You can call the [ListColumns](https://help.aliyun.com/document_detail/141870.html) operation to query the name of the field.
   * 
   * @example
   * test_column
   */
  columnName?: string;
  /**
   * @remarks
   * The ID of the database. You can call the [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to query the ID of the database.
   * 
   * >  You can also call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) operation to query the ID of the physical database and the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) operation to query the ID of a logical database.
   * 
   * @example
   * 1860
   */
  dbId?: number;
  /**
   * @remarks
   * Specifies whether the database is a logical database. Valid values:
   * 
   * *   true: The database is a logical database.
   * *   false: The database is a physical database.
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 100
   */
  pageSize?: number;
  /**
   * @remarks
   * The name of the database. You can call the [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to query the name of the database.
   * 
   * >  You can also call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) operation to query the name of a physical database and the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) operation to query the name of a logical database.
   * 
   * @example
   * test_schema
   */
  schemaName?: string;
  /**
   * @remarks
   * The sensitivity level of the field. Valid values:
   * 
   * *   SENSITIVE: medium sensitivity level
   * *   CONFIDENTIAL: high sensitivity level
   * 
   * @example
   * SENSITIVE
   */
  securityLevel?: string;
  /**
   * @remarks
   * The name of the table. You can call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation to query the ID of the table.
   * 
   * @example
   * test_table
   */
  tableName?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
   * 
   * @example
   * 3
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      dbId: 'DbId',
      logic: 'Logic',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      schemaName: 'SchemaName',
      securityLevel: 'SecurityLevel',
      tableName: 'TableName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      dbId: 'number',
      logic: 'boolean',
      pageNumber: 'number',
      pageSize: 'number',
      schemaName: 'string',
      securityLevel: 'string',
      tableName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 09D82FD7-F87F-59EF-AA82-AEF71B09E306
   */
  requestId?: string;
  /**
   * @remarks
   * The sensitive fields.
   */
  sensitiveColumnList?: ListSensitiveColumnsResponseBodySensitiveColumnList;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * - true: The request is successful.
   * - false: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      sensitiveColumnList: 'SensitiveColumnList',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      sensitiveColumnList: ListSensitiveColumnsResponseBodySensitiveColumnList,
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSensitiveColumnsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSensitiveColumnsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnsDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the field. You can call the [ListSensitiveColumns](https://help.aliyun.com/document_detail/188103.html) operation to obtain the name of the field.
   * 
   * >  You can also call the [ListColumns](https://help.aliyun.com/document_detail/141870.html) operation to obtain the name of the field.
   * 
   * This parameter is required.
   * 
   * @example
   * ColumnName_test
   */
  columnName?: string;
  /**
   * @remarks
   * The ID of the database. The database can be a physical database or a logical database.
   * 
   * *   To obtain the ID of a physical database, call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation.
   * *   To obtain the ID of a logical database, call the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation.
   * 
   * @example
   * 1860****
   */
  dbId?: number;
  /**
   * @remarks
   * Specifies whether the database is a logical database. Valid values:
   * 
   * *   **true**: The database is a logical database.
   * *   **false**: The database is a physical database.
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The name of the database. You can call the [ListSensitiveColumns](https://help.aliyun.com/document_detail/188103.html) operation to obtain the name of the database.
   * 
   * > * You can also call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to obtain the name of a physical database.
   * > * You can also call the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to obtain the name of a logical database.
   * 
   * This parameter is required.
   * 
   * @example
   * SchemaName_test
   */
  schemaName?: string;
  /**
   * @remarks
   * The name of the table. You can call the [ListSensitiveColumns](https://help.aliyun.com/document_detail/188103.html) operation to obtain the name of the table.
   * 
   * >  You can also call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation to obtain the name of the table.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  tableName?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      dbId: 'DbId',
      logic: 'Logic',
      schemaName: 'SchemaName',
      tableName: 'TableName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      dbId: 'number',
      logic: 'boolean',
      schemaName: 'string',
      tableName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnsDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 7629888F-C9FB-4D16-A7D3-B443FE06FBD4
   */
  requestId?: string;
  /**
   * @remarks
   * The details of the sensitive field.
   */
  sensitiveColumnsDetailList?: ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * - **true**: The request was successful.
   * - **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      sensitiveColumnsDetailList: 'SensitiveColumnsDetailList',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      sensitiveColumnsDetailList: ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnsDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSensitiveColumnsDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSensitiveColumnsDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveDataAuditLogRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the column that contains sensitive data.
   * 
   * @example
   * ExampleColumnName
   */
  columnName?: string;
  /**
   * @remarks
   * The name of the database that stores the sensitive data.
   * 
   * @example
   * ExampleDbName
   */
  dbName?: string;
  /**
   * @remarks
   * The end of the time range for which you want to query the audit logs for sensitive information. Specify the time in the yyyy-MM-DD HH:mm:ss format.
   * 
   * @example
   * 2022-11-18 11:00:00
   */
  endTime?: string;
  /**
   * @remarks
   * The function module whose audit logs you want to query for sensitive data. If you do not specify this parameter, all audit logs are queried. Valid values:
   * 
   * *   **SQL_CONSOLE**: data query
   * *   **SQL_CONSOLE_EXPORT**: query result export
   * *   **DATA_CHANGE**: data change
   * *   **DATA_EXPORT**: data export
   * 
   * @example
   * SQL_CONSOLE
   */
  moduleName?: string;
  /**
   * @remarks
   * The username of the requester.
   * 
   * @example
   * ExampleOpUserName
   */
  opUserName?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Example: 100
   * 
   * @example
   * 100
   */
  pageSize?: number;
  /**
   * @remarks
   * The beginning of the time range for which you want to query the audit logs for sensitive information. Specify the time in the yyyy-MM-DD HH:mm:ss format.
   * 
   * @example
   * 2022-11-18 10:00:00
   */
  startTime?: string;
  /**
   * @remarks
   * The name of the table that stores the sensitive data.
   * 
   * @example
   * ExampleTableName
   */
  tableName?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      dbName: 'DbName',
      endTime: 'EndTime',
      moduleName: 'ModuleName',
      opUserName: 'OpUserName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startTime: 'StartTime',
      tableName: 'TableName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      dbName: 'string',
      endTime: 'string',
      moduleName: 'string',
      opUserName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startTime: 'string',
      tableName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveDataAuditLogResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * 403
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E0D21075-CD3E-4D98-8264-FD8AD04A63B6
   */
  requestId?: string;
  /**
   * @remarks
   * The audit logs for sensitive data.
   */
  sensitiveDataAuditLogList?: ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList[];
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      sensitiveDataAuditLogList: 'SensitiveDataAuditLogList',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      sensitiveDataAuditLogList: { 'type': 'array', 'itemType': ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList },
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveDataAuditLogResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSensitiveDataAuditLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSensitiveDataAuditLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitivityLevelRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the classification template. You can call the [ListClassificationTemplates](https://help.aliyun.com/document_detail/460613.html) operation to query the ID of the classification template.
   * 
   * @example
   * 15**
   */
  templateId?: number;
  /**
   * @remarks
   * The type of the classification template. You can call the [ListClassificationTemplates](https://help.aliyun.com/document_detail/460613.html) operation to query the type of the classification template.
   * 
   * Valid values:
   * 
   * *   USER_DEFINE: a custom template.
   * *   INNER: a built-in template.
   * 
   * @example
   * INNER
   */
  templateType?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) in the topic "Manage DMS tenants."
   * 
   * @example
   * 20***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      templateId: 'TemplateId',
      templateType: 'TemplateType',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      templateId: 'number',
      templateType: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitivityLevelResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The request ID. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * 4E1D2B4D-3E53-4ABC-999D-1D2520B3471A
   */
  requestId?: string;
  /**
   * @remarks
   * The sensitivity levels.
   */
  sensitivityLevelList?: ListSensitivityLevelResponseBodySensitivityLevelList[];
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      sensitivityLevelList: 'SensitivityLevelList',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      sensitivityLevelList: { 'type': 'array', 'itemType': ListSensitivityLevelResponseBodySensitivityLevelList },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitivityLevelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSensitivityLevelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSensitivityLevelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListStandardGroupsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListStandardGroupsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request fails.
   * 
   * @example
   * 403
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request fails.
   * 
   * @example
   * xxx
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 34E01EDD-6A16-4CF0-9541-C644D1BE01AA
   */
  requestId?: string;
  /**
   * @remarks
   * The security rule sets returned.
   */
  standardGroupList?: ListStandardGroupsResponseBodyStandardGroupList[];
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      standardGroupList: 'StandardGroupList',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      standardGroupList: { 'type': 'array', 'itemType': ListStandardGroupsResponseBodyStandardGroupList },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListStandardGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListStandardGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListStandardGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTablesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the physical database. You can call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to obtain the ID of the physical database.
   * 
   * This parameter is required.
   * 
   * @example
   * 1860****
   */
  databaseId?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * Specifies whether to return the GUID of a table. Valid values:
   * 
   * *   **true**: returns the GUID of a table.
   * *   **false**: does not return the GUID of a table.
   * 
   * @example
   * true
   */
  returnGuid?: boolean;
  /**
   * @remarks
   * The name used to search for tables. Fuzzy search is supported.
   * 
   * @example
   * test
   */
  searchName?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      databaseId: 'DatabaseId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      returnGuid: 'ReturnGuid',
      searchName: 'SearchName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      returnGuid: 'boolean',
      searchName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTablesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * B16FB618-5E96-4FFD-BB0D-490C890A4030
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The details of the tables.
   */
  tableList?: ListTablesResponseBodyTableList;
  /**
   * @remarks
   * The total number of tables that meet the query conditions.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      tableList: 'TableList',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      tableList: ListTablesResponseBodyTableList,
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTablesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTablesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTablesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 403
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4116147E-C628-5816-8779-8EEAF8E973F4
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The information about the task flows returned.
   */
  taskFlowList?: ListTaskFlowResponseBodyTaskFlowList;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      taskFlowList: 'TaskFlowList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      taskFlowList: ListTaskFlowResponseBodyTaskFlowList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTaskFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTaskFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowConstantsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 3****
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowConstantsResponseBody extends $tea.Model {
  /**
   * @remarks
   * A list of constant key-value pairs for the task flow.
   */
  dagConstants?: ListTaskFlowConstantsResponseBodyDagConstants;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * 028BF827-3801-5869-8548-F4A039256304
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      dagConstants: 'DagConstants',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagConstants: ListTaskFlowConstantsResponseBodyDagConstants,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowConstantsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTaskFlowConstantsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTaskFlowConstantsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowCooperatorsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 15****
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowCooperatorsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The users that are involved in the task flow.
   */
  cooperatorList?: ListTaskFlowCooperatorsResponseBodyCooperatorList;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * 54C99C70-2DFF-5A8C-A252-EBAA1EB668EC
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      cooperatorList: 'CooperatorList',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cooperatorList: ListTaskFlowCooperatorsResponseBodyCooperatorList,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowCooperatorsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTaskFlowCooperatorsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTaskFlowCooperatorsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowEdgesByConditionRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 15***
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the task flow edge.
   * 
   * @example
   * 24***
   */
  id?: number;
  /**
   * @remarks
   * The ID of the end node on the edge.
   * 
   * @example
   * 44***
   */
  nodeEnd?: number;
  /**
   * @remarks
   * The ID of the start node on the edge.
   * 
   * @example
   * 44***
   */
  nodeFrom?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      id: 'Id',
      nodeEnd: 'NodeEnd',
      nodeFrom: 'NodeFrom',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      id: 'number',
      nodeEnd: 'number',
      nodeFrom: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowEdgesByConditionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of task flow edges.
   */
  edges?: ListTaskFlowEdgesByConditionResponseBodyEdges;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * D86249CD-422F-5ACF-85BA-9187C986AE0B
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      edges: 'Edges',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      edges: ListTaskFlowEdgesByConditionResponseBodyEdges,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowEdgesByConditionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTaskFlowEdgesByConditionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTaskFlowEdgesByConditionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to obtain the ID of the task flow.
   * 
   * This parameter is required.
   * 
   * @example
   * 7***
   */
  dagId?: number;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageIndex?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * This parameter is required.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The beginning of the time range to query the execution records of the task flow. Specify the time in the yyyy-MM-DD format.
   * 
   * @example
   * 2022-01-07
   */
  startTimeBegin?: string;
  /**
   * @remarks
   * The end of the time range to query the execution records of the task flow. Specify the time in the yyyy-MM-DD format.
   * 
   * @example
   * 2022-04-08
   */
  startTimeEnd?: string;
  /**
   * @remarks
   * The running status of the task node. Valid values:
   * 
   * - **0**: Waiting for scheduling
   * 
   * - **1**: Running
   * 
   * - **2**: Suspend
   * 
   * - **3**: Failed to run
   * 
   * - **4**: Run successfully
   * 
   * - **5**: Completed
   * 
   * @example
   * 3
   */
  status?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  /**
   * @remarks
   * The mode in which the task flow is triggered. Valid values:
   * 
   * *   **0**: The task flow is automatically triggered based on periodic scheduling.
   * *   **1**: The task flow is manually triggered.
   * 
   * @example
   * 1
   */
  triggerType?: number;
  /**
   * @remarks
   * Adjust filter conditions:
   * 
   * - true: StartTimeBegin and StartTimeEnd are the time range for filtering services.
   * 
   * - false: StartTimeBegin and StartTimeEnd are the time range for the task to run.
   * 
   * @example
   * true
   */
  useBizDate?: boolean;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      pageIndex: 'PageIndex',
      pageSize: 'PageSize',
      startTimeBegin: 'StartTimeBegin',
      startTimeEnd: 'StartTimeEnd',
      status: 'Status',
      tid: 'Tid',
      triggerType: 'TriggerType',
      useBizDate: 'UseBizDate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      pageIndex: 'number',
      pageSize: 'number',
      startTimeBegin: 'string',
      startTimeEnd: 'string',
      status: 'number',
      tid: 'number',
      triggerType: 'number',
      useBizDate: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the execution records returned.
   */
  DAGInstanceList?: ListTaskFlowInstanceResponseBodyDAGInstanceList;
  /**
   * @remarks
   * The error code returned if the request fails.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request fails.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 8CFF2295-8249-5287-B888-DBD4F0D76CB0
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**: The request is successful.
   * *   **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of execution records returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      DAGInstanceList: 'DAGInstanceList',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DAGInstanceList: ListTaskFlowInstanceResponseBodyDAGInstanceList,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTaskFlowInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTaskFlowInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowTimeVariablesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 11****
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowTimeVariablesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EC12A3BE-149F-5365-AF33-12CC8C963923
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The time variables for the task flow.
   */
  timeVariables?: ListTaskFlowTimeVariablesResponseBodyTimeVariables;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      timeVariables: 'TimeVariables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      timeVariables: ListTaskFlowTimeVariablesResponseBodyTimeVariables,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowTimeVariablesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTaskFlowTimeVariablesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTaskFlowTimeVariablesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowsByPageRequest extends $tea.Model {
  /**
   * @remarks
   * Filter condition, task flow ID list.
   */
  dagIdList?: number[];
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageIndex?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * Filter condition, application scenario ID.
   * 
   * @example
   * 12***
   */
  scenarioId?: number;
  /**
   * @remarks
   * The keyword that is used to search for task flow names.
   * 
   * @example
   * Test node
   */
  searchKey?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagIdList: 'DagIdList',
      pageIndex: 'PageIndex',
      pageSize: 'PageSize',
      scenarioId: 'ScenarioId',
      searchKey: 'SearchKey',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagIdList: { 'type': 'array', 'itemType': 'number' },
      pageIndex: 'number',
      pageSize: 'number',
      scenarioId: 'number',
      searchKey: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowsByPageShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * Filter condition, task flow ID list.
   */
  dagIdListShrink?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageIndex?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * Filter condition, application scenario ID.
   * 
   * @example
   * 12***
   */
  scenarioId?: number;
  /**
   * @remarks
   * The keyword that is used to search for task flow names.
   * 
   * @example
   * Test node
   */
  searchKey?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagIdListShrink: 'DagIdList',
      pageIndex: 'PageIndex',
      pageSize: 'PageSize',
      scenarioId: 'ScenarioId',
      searchKey: 'SearchKey',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagIdListShrink: 'string',
      pageIndex: 'number',
      pageSize: 'number',
      scenarioId: 'number',
      searchKey: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowsByPageResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6CB28697-BFE2-5739-9228-3971990E982C
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The details of the returned task flows.
   */
  taskFlowList?: ListTaskFlowsByPageResponseBodyTaskFlowList;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 24
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      taskFlowList: 'TaskFlowList',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      taskFlowList: ListTaskFlowsByPageResponseBodyTaskFlowList,
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowsByPageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTaskFlowsByPageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTaskFlowsByPageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTasksInTaskFlowRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 32***
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTasksInTaskFlowResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * 8B36B063-6B7D-5595-9FCF-3844B7B7ACD4
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The tasks in the task flow.
   */
  tasks?: ListTasksInTaskFlowResponseBodyTasks;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      tasks: 'Tasks',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      tasks: ListTasksInTaskFlowResponseBodyTasks,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTasksInTaskFlowResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTasksInTaskFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTasksInTaskFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserPermissionsRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * db_name
   */
  databaseName?: string;
  /**
   * @remarks
   * The type of the database. For more information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
   * 
   * @example
   * polardb
   */
  dbType?: string;
  /**
   * @remarks
   * The type of the environment to which the database belongs. Valid values:
   * 
   * *   product: production environment
   * *   dev: development environment
   * *   pre: staging environment
   * *   test: test environment
   * *   sit: SIT environment
   * *   uat: user acceptance testing (UAT) environment
   * *   pet: stress testing environment
   * *   stag: STAG environment
   * 
   * @example
   * dev
   */
  envType?: string;
  /**
   * @remarks
   * Specifies whether the database is a logical database. Valid values:
   * 
   * *   true: The database is a logical database.
   * *   false: The database is a physical database.
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 5
   */
  pageSize?: number;
  /**
   * @remarks
   * The permissions on a specific type of resources that you want to query. Valid values:
   * 
   * *   DATABASE: permissions on databases
   * *   TABLE: permissions on tables
   * *   COLUMN: permissions on fields
   * *   INSTANCE: permissions on instances
   * 
   * This parameter is required.
   * 
   * @example
   * DATABASE
   */
  permType?: string;
  /**
   * @remarks
   * The keyword used in the query. For example, if you want to query permissions on an instance, you can specify the endpoint of the instance, such as rm-bp144d5ky4l4r****.
   * 
   * @example
   * rm-bp144d5ky4l4r****
   */
  searchKey?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
   * 
   * @example
   * 3***
   */
  tid?: number;
  /**
   * @remarks
   * The ID of the user. You can call the [GetUser](https://help.aliyun.com/document_detail/147098.html) or [ListUsers](https://help.aliyun.com/document_detail/141938.html) operation to query the ID of the user.
   * 
   * >  The user ID is different from the ID of your Alibaba Cloud account.
   * 
   * This parameter is required.
   * 
   * @example
   * 51****
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      databaseName: 'DatabaseName',
      dbType: 'DbType',
      envType: 'EnvType',
      logic: 'Logic',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      permType: 'PermType',
      searchKey: 'SearchKey',
      tid: 'Tid',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseName: 'string',
      dbType: 'string',
      envType: 'string',
      logic: 'boolean',
      pageNumber: 'number',
      pageSize: 'number',
      permType: 'string',
      searchKey: 'string',
      tid: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserPermissionsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C51420E3-144A-4A94-B473-8662FCF4AD10
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * - true: The request is successful.
   * - false: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of entries that meet the query conditions.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  /**
   * @remarks
   * The details of the permissions that the user has.
   */
  userPermissions?: ListUserPermissionsResponseBodyUserPermissions;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
      userPermissions: 'UserPermissions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
      userPermissions: ListUserPermissionsResponseBodyUserPermissions,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserPermissionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListUserPermissionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListUserPermissionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserTenantsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserTenantsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * TenantNotExist
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified tenant does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C478D9DA-3615-50F6-A2BC-7855AD65****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**: The request is successful.
   * *   **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The details of the tenants that were returned.
   */
  tenantList?: ListUserTenantsResponseBodyTenantList[];
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      tenantList: 'TenantList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      tenantList: { 'type': 'array', 'itemType': ListUserTenantsResponseBodyTenantList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserTenantsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListUserTenantsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListUserTenantsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUsersRequest extends $tea.Model {
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * **
   * 
   * Valid values: 10, 20, 50, and 100.**** Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The role that is assigned to the user. Valid values:
   * 
   * *   **USER**: a regular user.
   * *   **DBA** : a database administrator (DBA).
   * *   **ADMIN**: a Data Management (DMS) administrator.
   * *   **SECURITY_ADMIN**: a security administrator.
   * *   **STRUCT_READ_ONLY**: a schema read-only user.
   * 
   * >  To check your role, move the pointer over the profile picture in the upper-right corner of the DMS console.
   * 
   * @example
   * DBA
   */
  role?: string;
  /**
   * @remarks
   * The search keyword. Fuzzy match is supported.
   * 
   * @example
   * test
   */
  searchKey?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  /**
   * @remarks
   * The status of the user. Valid values:
   * 
   * *   **NORMAL**: The user is normal.
   * *   **DISABLE**: The user is disabled.
   * *   **DELETE**: The user is deleted.
   * 
   * @example
   * NORMAL
   */
  userState?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      role: 'Role',
      searchKey: 'SearchKey',
      tid: 'Tid',
      userState: 'UserState',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      role: 'string',
      searchKey: 'string',
      tid: 'number',
      userState: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUsersResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * InvalidTid
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * Specified parameter Tid is not valid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 69161997-6030-53BA-A333-DBEC83B732FF
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 3
   */
  totalCount?: number;
  /**
   * @remarks
   * The details of users.
   */
  userList?: ListUsersResponseBodyUserList;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      totalCount: 'TotalCount',
      userList: 'UserList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      totalCount: 'number',
      userList: ListUsersResponseBodyUserList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUsersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListUsersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListUsersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowNodesRequest extends $tea.Model {
  /**
   * @remarks
   * The name that is used to search for approval nodes.
   * 
   * @example
   * admin
   */
  searchName?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * -1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      searchName: 'SearchName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      searchName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowNodesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CFD8FE00-36D9-4C1B-940D-65A7B73D9066
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The details of approval nodes.
   */
  workflowNodes?: ListWorkFlowNodesResponseBodyWorkflowNodes;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      workflowNodes: 'WorkflowNodes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      workflowNodes: ListWorkFlowNodesResponseBodyWorkflowNodes,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowNodesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWorkFlowNodesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWorkFlowNodesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowTemplatesRequest extends $tea.Model {
  /**
   * @remarks
   * The name that is used to query approval templates.
   * 
   * @example
   * Admin
   */
  searchName?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * -1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      searchName: 'SearchName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      searchName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowTemplatesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 41067071-0243-4AAB-B3CF-4DE6D54F53B4
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The approval templates.
   */
  workFlowTemplates?: ListWorkFlowTemplatesResponseBodyWorkFlowTemplates;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      workFlowTemplates: 'WorkFlowTemplates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      workFlowTemplates: ListWorkFlowTemplatesResponseBodyWorkFlowTemplates,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowTemplatesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWorkFlowTemplatesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWorkFlowTemplatesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MakeTaskFlowInstanceSuccessRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 7***
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the execution record of the task flow. You can call the [ListTaskFlowInstance](https://help.aliyun.com/document_detail/424689.html) operation to query the execution record ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 47****
   */
  dagInstanceId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      dagInstanceId: 'DagInstanceId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      dagInstanceId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MakeTaskFlowInstanceSuccessResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * 028BF827-3801-5869-8548-F4A039256304
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MakeTaskFlowInstanceSuccessResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: MakeTaskFlowInstanceSuccessResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: MakeTaskFlowInstanceSuccessResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDataCorrectExecSQLRequest extends $tea.Model {
  /**
   * @remarks
   * The new SQL script.
   * 
   * This parameter is required.
   * 
   * @example
   * update tb set id = 1 where id = 1;
   */
  execSQL?: string;
  /**
   * @remarks
   * The ID of the data change ticket.
   * 
   * This parameter is required.
   * 
   * @example
   * 4328****
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
   * 
   * @example
   * 4****
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      execSQL: 'ExecSQL',
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      execSQL: 'string',
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDataCorrectExecSQLResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * InvalidOrderId
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * Specified parameter OrderId is not valid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0C1CB646-1DE4-4AD0-B4A4-7D47DD52****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDataCorrectExecSQLResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyDataCorrectExecSQLResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyDataCorrectExecSQLResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDesensitizationStrategyRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the field. You can call the [ListSensitiveColumns](https://help.aliyun.com/document_detail/188103.html) operation to obtain the field name.
   * 
   * >  You can also call the [ListColumns](https://help.aliyun.com/document_detail/141870.html) operation to obtain the field name.
   * 
   * This parameter is required.
   * 
   * @example
   * test_column
   */
  columnName?: string;
  /**
   * @remarks
   * The ID of the database. You can call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  dbId?: number;
  /**
   * @remarks
   * The desensitization algorithm of the field setting. The default value is false. The values are as follows:
   * 
   * - **true**: default desensitization algorithm.
   * 
   * - **false** :semi-desensitization algorithm.
   * 
   * @example
   * false
   */
  isDefault?: boolean;
  /**
   * @remarks
   * Specifies whether the database is a logical database. Valid values:
   * 
   * *   **true**: The database is a physical database.
   * *   **false**: The database is a logical database.
   * 
   * This parameter is required.
   * 
   * @example
   * false
   */
  isLogic?: boolean;
  /**
   * @remarks
   * Specifies whether to reset the masking rule. Valid value:
   * 
   * *   **true**: Reset the masking rule.
   * *   **false**: Do not reset the masking rule. This is the default value.
   * 
   * @example
   * false
   */
  isReset?: boolean;
  /**
   * @remarks
   * The ID of the masking rule.
   * 
   * @example
   * 53
   */
  ruleId?: number;
  /**
   * @remarks
   * The name of the database. You can call the [ListSensitiveColumns](https://help.aliyun.com/document_detail/188103.html) operation to obtain the database name.
   * 
   * > 
   * 
   * *   If the database is a physical database, you can call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to obtain the database name.
   * 
   * *   If the database is a logical database, you can call the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to obtain the name of the database.
   * 
   * This parameter is required.
   * 
   * @example
   * test_schema
   */
  schemaName?: string;
  /**
   * @remarks
   * The name of the table. You can call the [ListSensitiveColumns](https://help.aliyun.com/document_detail/188103.html) operation to obtain the table name.
   * 
   * >  You can also call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation to obtain the table name.
   * 
   * This parameter is required.
   * 
   * @example
   * test_table
   */
  tableName?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) in the topic "Manage DMS tenants."
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      dbId: 'DbId',
      isDefault: 'IsDefault',
      isLogic: 'IsLogic',
      isReset: 'IsReset',
      ruleId: 'RuleId',
      schemaName: 'SchemaName',
      tableName: 'TableName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      dbId: 'number',
      isDefault: 'boolean',
      isLogic: 'boolean',
      isReset: 'boolean',
      ruleId: 'number',
      schemaName: 'string',
      tableName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDesensitizationStrategyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 283C461F-11D8-48AA-B695-DF092DA32AF3
   */
  requestId?: string;
  /**
   * @remarks
   * The returned result.
   * 
   * @example
   * True
   */
  result?: boolean;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * false
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: 'boolean',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDesensitizationStrategyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyDesensitizationStrategyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyDesensitizationStrategyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceRequest extends $tea.Model {
  /**
   * @example
   * dblink_test
   */
  dataLinkName?: string;
  /**
   * @example
   * test***
   */
  databasePassword?: string;
  /**
   * @example
   * testsdb
   */
  databaseUser?: string;
  /**
   * @example
   * 27****
   */
  dbaId?: number;
  /**
   * @example
   * 2
   */
  ddlOnline?: number;
  /**
   * @example
   * i-2zei9gs1t7h8l7ac****
   */
  ecsInstanceId?: string;
  /**
   * @example
   * cn-hangzhou
   */
  ecsRegion?: string;
  /**
   * @example
   * Y
   */
  enableSellCommon?: string;
  /**
   * @example
   * Y
   */
  enableSellSitd?: string;
  /**
   * @example
   * NULL
   */
  enableSellStable?: string;
  /**
   * @example
   * Y
   */
  enableSellTrust?: string;
  /**
   * @example
   * dev
   */
  envType?: string;
  /**
   * @example
   * 86400
   */
  exportTimeout?: number;
  /**
   * @example
   * 192.XXX.0.56
   */
  host?: string;
  /**
   * @example
   * instance_test
   */
  instanceAlias?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 183****
   */
  instanceId?: string;
  /**
   * @example
   * RDS
   */
  instanceSource?: string;
  /**
   * @example
   * MySQL
   */
  instanceType?: string;
  /**
   * @example
   * VPC
   */
  networkType?: string;
  /**
   * @example
   * 3306
   */
  port?: number;
  /**
   * @example
   * 7200
   */
  queryTimeout?: number;
  safeRule?: string;
  /**
   * @example
   * testSid
   */
  sid?: string;
  /**
   * @example
   * false
   */
  skipTest?: boolean;
  /**
   * @example
   * 31***
   */
  templateId?: number;
  /**
   * @example
   * INNER
   */
  templateType?: string;
  /**
   * @example
   * 23****
   */
  tid?: number;
  /**
   * @example
   * 1
   */
  useDsql?: number;
  useSsl?: number;
  /**
   * @example
   * vpc-bp10wnlcmor****
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      dataLinkName: 'DataLinkName',
      databasePassword: 'DatabasePassword',
      databaseUser: 'DatabaseUser',
      dbaId: 'DbaId',
      ddlOnline: 'DdlOnline',
      ecsInstanceId: 'EcsInstanceId',
      ecsRegion: 'EcsRegion',
      enableSellCommon: 'EnableSellCommon',
      enableSellSitd: 'EnableSellSitd',
      enableSellStable: 'EnableSellStable',
      enableSellTrust: 'EnableSellTrust',
      envType: 'EnvType',
      exportTimeout: 'ExportTimeout',
      host: 'Host',
      instanceAlias: 'InstanceAlias',
      instanceId: 'InstanceId',
      instanceSource: 'InstanceSource',
      instanceType: 'InstanceType',
      networkType: 'NetworkType',
      port: 'Port',
      queryTimeout: 'QueryTimeout',
      safeRule: 'SafeRule',
      sid: 'Sid',
      skipTest: 'SkipTest',
      templateId: 'TemplateId',
      templateType: 'TemplateType',
      tid: 'Tid',
      useDsql: 'UseDsql',
      useSsl: 'UseSsl',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataLinkName: 'string',
      databasePassword: 'string',
      databaseUser: 'string',
      dbaId: 'number',
      ddlOnline: 'number',
      ecsInstanceId: 'string',
      ecsRegion: 'string',
      enableSellCommon: 'string',
      enableSellSitd: 'string',
      enableSellStable: 'string',
      enableSellTrust: 'string',
      envType: 'string',
      exportTimeout: 'number',
      host: 'string',
      instanceAlias: 'string',
      instanceId: 'string',
      instanceSource: 'string',
      instanceType: 'string',
      networkType: 'string',
      port: 'number',
      queryTimeout: 'number',
      safeRule: 'string',
      sid: 'string',
      skipTest: 'boolean',
      templateId: 'number',
      templateType: 'string',
      tid: 'number',
      useDsql: 'number',
      useSsl: 'number',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceResponseBody extends $tea.Model {
  /**
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @example
   * 0C1CB646-1DE4-4AD0-B4A4-7D47DD52E931
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MoveTaskFlowToScenarioRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 11****
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the business scenario to which you want to migrate your task flow. If this parameter is set to the default value or a value that is less than or equal to 0, the task flow is migrated to the default business scenario.
   * 
   * @example
   * 1****
   */
  scenarioId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      scenarioId: 'ScenarioId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      scenarioId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MoveTaskFlowToScenarioResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * D85FD18C-4322-5D49-8C14-5A10E668F86C
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MoveTaskFlowToScenarioResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: MoveTaskFlowToScenarioResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: MoveTaskFlowToScenarioResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OfflineTaskFlowRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to obtain the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 7***
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OfflineTaskFlowResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request fails.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request fails.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * A8FE12AA-300D-5FDF-806F-C2CB99161F32
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**: The request is successful.
   * *   **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OfflineTaskFlowResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: OfflineTaskFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OfflineTaskFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PauseDataCorrectSQLJobRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the SQL task. You can call the [GetDataCorrectTaskDetail](https://help.aliyun.com/document_detail/208481.html) or [ListDBTaskSQLJob](https://help.aliyun.com/document_detail/207049.html) operation to obtain the value of this parameter.
   * 
   * >  If Type is set to SINGLE, you must pass in the value of JobId to confirm the ID of the SQL task that you want to pause.
   * 
   * @example
   * 43253
   */
  jobId?: number;
  /**
   * @remarks
   * The ID of the data change ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ID of the data change ticket.
   * 
   * This parameter is required.
   * 
   * @example
   * 43253
   */
  orderId?: number;
  /**
   * @remarks
   * The tenant ID. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
   * 
   * @example
   * 4325
   */
  tid?: number;
  /**
   * @remarks
   * The type of the pause operation. Valid values:
   * 
   * *   ALL: pauses all SQL tasks.
   * *   SINGLE: pauses a single SQL task.
   * 
   * This parameter is required.
   * 
   * @example
   * SINGLE
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
      orderId: 'OrderId',
      tid: 'Tid',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'number',
      orderId: 'number',
      tid: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PauseDataCorrectSQLJobResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code that is returned.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message that is returned.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 335C5BC8-490C-56EF-BDDE-94A4B53FEB72
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PauseDataCorrectSQLJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PauseDataCorrectSQLJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PauseDataCorrectSQLJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreviewWorkflowRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1069****
   */
  orderId?: number;
  /**
   * @example
   * 23****
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreviewWorkflowResponseBody extends $tea.Model {
  /**
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @example
   * 0C1CB646-1DE4-4AD0-B4A4-7D47DD52E931
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  workflowDetail?: PreviewWorkflowResponseBodyWorkflowDetail;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      workflowDetail: 'WorkflowDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      workflowDetail: PreviewWorkflowResponseBodyWorkflowDetail,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreviewWorkflowResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PreviewWorkflowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PreviewWorkflowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishAndDeployTaskFlowRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 7***
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  /**
   * @remarks
   * The description of the version.
   * 
   * @example
   * vc_test
   */
  versionComments?: string;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
      versionComments: 'VersionComments',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
      versionComments: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishAndDeployTaskFlowResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the deployment record.
   * 
   * @example
   * 12**
   */
  deployId?: number;
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * Unknown server error
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * 64E26249-B61F-51C6-B6DF-47EFF50128CC
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      deployId: 'DeployId',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deployId: 'number',
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishAndDeployTaskFlowResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PublishAndDeployTaskFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PublishAndDeployTaskFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDataTrackResultDownloadStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the download key, which is used to identify the parsing progress of data tracking logs. You can call the DownloadDataTrackResult operation to query the ID of the key.
   * 
   * This parameter is required.
   * 
   * @example
   * e23dd7ec-a19f-4a69-8eb3-8ffd26e6****
   */
  downloadKeyId?: string;
  /**
   * @remarks
   * The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ID of the ticket.
   * 
   * This parameter is required.
   * 
   * @example
   * 11****
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the ID of the tenant.
   * 
   * @example
   * 1***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      downloadKeyId: 'DownloadKeyId',
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadKeyId: 'string',
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDataTrackResultDownloadStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0C1CB646-1DE4-4AD0-B4A4-7D47DD52E931
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the download progress.
   */
  statusResult?: QueryDataTrackResultDownloadStatusResponseBodyStatusResult;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      statusResult: 'StatusResult',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      statusResult: QueryDataTrackResultDownloadStatusResponseBodyStatusResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDataTrackResultDownloadStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryDataTrackResultDownloadStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDataTrackResultDownloadStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReDeployLhDagVersionRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to obtain the ID of the task flow.
   * 
   * This parameter is required.
   * 
   * @example
   * 7***
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the task flow version. You can call the [ListDAGVersions](https://help.aliyun.com/document_detail/424682.html) operation to obtain the ID of the task flow version.
   * 
   * @example
   * 2****
   */
  dagVersion?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the ID of the tenant.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      dagVersion: 'DagVersion',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      dagVersion: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReDeployLhDagVersionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the deployment record.
   * 
   * @example
   * 15990
   */
  deployId?: number;
  /**
   * @remarks
   * The error code returned if the request fails.
   * 
   * @example
   * 403
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request fails.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 035C92E0-2EAD-50E5-A6DD-550F5F73D7CE
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**: The request is successful.
   * *   **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      deployId: 'DeployId',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deployId: 'number',
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReDeployLhDagVersionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ReDeployLhDagVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReDeployLhDagVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReRunTaskFlowInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 7***
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the execution record of the task flow. You can call the [ListTaskFlowInstance](https://help.aliyun.com/document_detail/424689.html) operation to query the execution record ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 47****
   */
  dagInstanceId?: number;
  /**
   * @remarks
   * The version number of the task flow. You can call the ListTaskFlowVersions operation to query the version number of the task flow.
   * 
   * @example
   * 2****
   */
  dagVersion?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      dagInstanceId: 'DagInstanceId',
      dagVersion: 'DagVersion',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      dagInstanceId: 'number',
      dagVersion: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReRunTaskFlowInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * 8CFF2295-8249-5287-B888-DBD4F0D76CB0
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true: The request was successful.
   * *   false: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReRunTaskFlowInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ReRunTaskFlowInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ReRunTaskFlowInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefundPayAsYouGoOrderRequest extends $tea.Model {
  /**
   * @remarks
   * The instance ID in the sales order.
   * 
   * This parameter is required.
   * 
   * @example
   * dms_pre_public_intl-sg-vf****
   */
  instanceId?: string;
  /**
   * @remarks
   * The order ID of the order for the pay-as-you-go resource. You can call the ListEffectiveOrders operation to query the order ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 2190037****
   */
  orderId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      orderId: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefundPayAsYouGoOrderResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C51420E3-144A-4A94-B473-8662FCF4AD10
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefundPayAsYouGoOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RefundPayAsYouGoOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RefundPayAsYouGoOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the database link for cross-database queries.
   * 
   * > 
   * 
   * *   This parameter is required if UseDsql is set to 1.
   * 
   * *   The name can contain only lowercase letters and underscores (_).
   * 
   * *   The name must be unique within a tenant.
   * 
   * @example
   * dblink_test
   */
  dataLinkName?: string;
  /**
   * @remarks
   * The password that is used to log on to the database.
   * 
   * This parameter is required.
   * 
   * @example
   * ******
   */
  databasePassword?: string;
  /**
   * @remarks
   * The account that is used to log on to the database.
   * 
   * This parameter is required.
   * 
   * @example
   * dmstest
   */
  databaseUser?: string;
  /**
   * @remarks
   * The ID of the user who assumes the DBA role of the database instance. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetInstance](https://help.aliyun.com/document_detail/141567.html) operation to query the user ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 22275482072787****
   */
  dbaUid?: number;
  /**
   * @remarks
   * The ID of the user who assumes the DBA role of the database instance. If the user ID is a non-numeric value such as a role or an account, you can use this parameter to replace DbaUid.
   * 
   * @example
   * 22275482072787****
   */
  dbaUidByString?: string;
  /**
   * @remarks
   * Specifies whether to enable the lock-free schema change feature for the database instance. Valid values:
   * 
   * *   **0**: disables the lock-free schema change feature.
   * *   **1**: uses the online DDL of MySQL first.
   * *   **2**: uses the lock-free schema change feature of DMS first.
   * 
   * > Supported database types: ApsaraDB RDS for MySQL, PolarDB for MySQL, ApsaraDB MyBase for MySQL, and third-party MySQL databases.
   * 
   * @example
   * 2
   */
  ddlOnline?: number;
  /**
   * @remarks
   * The ID of the ECS instance on which the database instance is deployed.
   * 
   * > This parameter is required if the InstanceSource parameter is set to ECS_OWN.
   * 
   * @example
   * i-2zei9gs1t7h8l7ac****
   */
  ecsInstanceId?: string;
  /**
   * @remarks
   * The ID of the region in which the database instance resides.
   * 
   * > This parameter is required if the InstanceSource parameter is set to RDS, ECS_OWN, or VPC_IDC.
   * 
   * @example
   * cn-hangzhou
   */
  ecsRegion?: string;
  /**
   * @remarks
   * *   **Y:** enables the sensitive data protection feature
   * *   **NULL or other:** disables the sensitive data protection feature
   * 
   * @example
   * Y
   */
  enableSellSitd?: string;
  /**
   * @remarks
   * The type of the environment in which the database instance is deployed. Valid values:
   * 
   * *   product: production environment
   * *   dev: development environment
   * *   pre: pre-release environment
   * *   test: test environment
   * *   sit: system integration testing (SIT) environment
   * *   uat: user acceptance testing (UAT) environment
   * *   pet: stress testing environment
   * *   stag: staging environment
   * 
   * This parameter is required.
   * 
   * @example
   * product
   */
  envType?: string;
  /**
   * @remarks
   * The timeout period for exporting data from the database instance. Unit: seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 600
   */
  exportTimeout?: number;
  /**
   * @remarks
   * The host address that is used to connect to the database instance.
   * 
   * This parameter is required.
   * 
   * @example
   * 172.XX.XXX.254
   */
  host?: string;
  /**
   * @remarks
   * The alias of the database instance. Specify an alias that can help you identify the database instance in DMS.
   * 
   * This parameter is required.
   * 
   * @example
   * Test instance
   */
  instanceAlias?: string;
  /**
   * @remarks
   * The source of the database instance. Valid values:
   * 
   * *   **PUBLIC_OWN:** a self-managed database instance that is deployed on the Internet
   * *   **RDS:** an ApsaraDB RDS instance
   * *   **ECS_OWN:** a self-managed database that is deployed on an Elastic Compute Service (ECS) instance
   * *   **VPC_IDC:** a self-managed database instance that is deployed in a data center connected over a virtual private cloud (VPC)
   * 
   * This parameter is required.
   * 
   * @example
   * RDS
   */
  instanceSource?: string;
  /**
   * @remarks
   * The type of the database. For more information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
   * 
   * This parameter is required.
   * 
   * @example
   * MySQL
   */
  instanceType?: string;
  /**
   * @remarks
   * The network type of the database instance. Valid values:
   * 
   * *   **CLASSIC:** classic network
   * *   **VPC:** VPC
   * 
   * This parameter is required.
   * 
   * @example
   * VPC
   */
  networkType?: string;
  /**
   * @remarks
   * The port that is used to connect to the database instance.
   * 
   * This parameter is required.
   * 
   * @example
   * 3306
   */
  port?: number;
  /**
   * @remarks
   * The timeout period for querying data in the database instance. Unit: seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 60
   */
  queryTimeout?: number;
  /**
   * @remarks
   * The name of the security rule set (GroupName) for the database instance. You can call the [ListStandardGroups](https://help.aliyun.com/document_detail/417891.html) or [GetInstance](https://help.aliyun.com/document_detail/141567.html) operation to query the name of the security rule set.
   * 
   * This parameter is required.
   * 
   * @example
   * Test
   */
  safeRule?: string;
  /**
   * @remarks
   * The system ID (SID) of the database.
   * 
   * > This parameter is required if the InstanceType parameter is set to ORACLE.
   * 
   * @example
   * XXX
   */
  sid?: string;
  /**
   * @remarks
   * Specifies whether to skip the connectivity test. Valid values:
   * 
   * *   **true:** skips the connectivity test
   * *   **false:** does not skip the connectivity test
   * 
   * @example
   * true
   */
  skipTest?: boolean;
  /**
   * @remarks
   * The ID of the classification template. You can call the [ListClassificationTemplates](https://help.aliyun.com/document_detail/460613.html) operation to query the template ID.
   * 
   * @example
   * 31***
   */
  templateId?: number;
  /**
   * @remarks
   * The type of the classification template. You can call the [ListClassificationTemplates](https://help.aliyun.com/document_detail/460613.html) operation to query the template type.
   * 
   * @example
   * INNER
   */
  templateType?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  /**
   * @remarks
   * Specifies whether to enable the cross-database query feature for the database instance. Valid values:
   * 
   * *   **0**: disables the cross-database query feature.
   * *   **1**: enables the cross-database query feature.
   * 
   * > Supported database types: MySQL, SQL Server, PostgreSQL, PolarDB for PostgreSQL (compatible with Oracle), and ApsaraDB for Redis.
   * 
   * @example
   * 1
   */
  useDsql?: number;
  /**
   * @remarks
   * The ID of the VPC to which the database instance belongs.
   * 
   * > This parameter is required if the InstanceSource parameter is set to VPC_IDC.
   * 
   * @example
   * vpc-xxxxxxxxxxxxxxxxxxxxx
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      dataLinkName: 'DataLinkName',
      databasePassword: 'DatabasePassword',
      databaseUser: 'DatabaseUser',
      dbaUid: 'DbaUid',
      dbaUidByString: 'DbaUidByString',
      ddlOnline: 'DdlOnline',
      ecsInstanceId: 'EcsInstanceId',
      ecsRegion: 'EcsRegion',
      enableSellSitd: 'EnableSellSitd',
      envType: 'EnvType',
      exportTimeout: 'ExportTimeout',
      host: 'Host',
      instanceAlias: 'InstanceAlias',
      instanceSource: 'InstanceSource',
      instanceType: 'InstanceType',
      networkType: 'NetworkType',
      port: 'Port',
      queryTimeout: 'QueryTimeout',
      safeRule: 'SafeRule',
      sid: 'Sid',
      skipTest: 'SkipTest',
      templateId: 'TemplateId',
      templateType: 'TemplateType',
      tid: 'Tid',
      useDsql: 'UseDsql',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataLinkName: 'string',
      databasePassword: 'string',
      databaseUser: 'string',
      dbaUid: 'number',
      dbaUidByString: 'string',
      ddlOnline: 'number',
      ecsInstanceId: 'string',
      ecsRegion: 'string',
      enableSellSitd: 'string',
      envType: 'string',
      exportTimeout: 'number',
      host: 'string',
      instanceAlias: 'string',
      instanceSource: 'string',
      instanceType: 'string',
      networkType: 'string',
      port: 'number',
      queryTimeout: 'number',
      safeRule: 'string',
      sid: 'string',
      skipTest: 'boolean',
      templateId: 'number',
      templateType: 'string',
      tid: 'number',
      useDsql: 'number',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F4E2A94B-604F-43FF-93E7-F4EE3DCF412E
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true:** The request was successful.
   * *   **false:** The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RegisterInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RegisterInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterUserRequest extends $tea.Model {
  /**
   * @remarks
   * The mobile number of the user.
   * 
   * @example
   * 130000000xx
   */
  mobile?: string;
  /**
   * @remarks
   * The role that you want to assign to the user. Valid values:
   * 
   * *   **USER**: a regular user role
   * *   **DBA**: a database administrator (DBA) role
   * *   **ADMIN**: a DMS administrator role
   * *   **SECURITY_ADMIN**: a security administrator role
   * 
   * >  If you do not specify this parameter, the regular user role is assigned to the user by default. You can assign one or more roles to the user. Separate multiple roles with commas (,).
   * 
   * @example
   * USER,DBA
   */
  roleNames?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To query ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
   * 
   * @example
   * -1
   */
  tid?: number;
  /**
   * @remarks
   * The UID of the Alibaba Cloud account of the user that you want to register.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345678
   */
  uid?: string;
  /**
   * @remarks
   * The nickname of the user.
   * 
   * @example
   * dmstest
   */
  userNick?: string;
  static names(): { [key: string]: string } {
    return {
      mobile: 'Mobile',
      roleNames: 'RoleNames',
      tid: 'Tid',
      uid: 'Uid',
      userNick: 'UserNick',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mobile: 'string',
      roleNames: 'string',
      tid: 'number',
      uid: 'string',
      userNick: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterUserResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * 403
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The specified user already exists.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 34E01EDD-6A16-4CF0-9541-C644D1BE01AA
   */
  requestId?: string;
  /**
   * @remarks
   * *   true: The request was successful.
   * *   false: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterUserResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RegisterUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RegisterUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RestartDataCorrectSQLJobRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the SQL task. You can call the [GetDataCorrectTaskDetail](https://help.aliyun.com/document_detail/208481.html) and [ListDBTaskSQLJob](https://help.aliyun.com/document_detail/207049.html) operations to obtain the value of this parameter.
   * 
   * If the Type parameter is set to SINGLE, you must pass the value of the JobId parameter to confirm the ID of the SQL task that you want to rerun.
   * 
   * @example
   * 43253
   */
  jobId?: number;
  /**
   * @remarks
   * The ID of the data change ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ID of the data change ticket.
   * 
   * This parameter is required.
   * 
   * @example
   * 453****
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  /**
   * @remarks
   * The type of the rerun operation. Valid values:
   * 
   * *   **ALL**: reruns all SQL tasks.
   * *   **SINGLE**: reruns a single SQL task.
   * 
   * This parameter is required.
   * 
   * @example
   * ALL
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
      orderId: 'OrderId',
      tid: 'Tid',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'number',
      orderId: 'number',
      tid: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RestartDataCorrectSQLJobResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 809B52F2-CD2B-53DA-88C8-F7042787E673
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**: The request is successful.
   * *   **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RestartDataCorrectSQLJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RestartDataCorrectSQLJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RestartDataCorrectSQLJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeTaskFlowInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 11****
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the execution record of the task flow. You can call the [ListTaskFlowInstance](https://help.aliyun.com/document_detail/424689.html) operation to query the execution record ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 3****
   */
  dagInstanceId?: number;
  /**
   * @remarks
   * The version number of the task flow. You can call the [ListDAGVersions](https://help.aliyun.com/document_detail/424682.html) operation to query the version number.
   * 
   * @example
   * []
   */
  dagVersion?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      dagInstanceId: 'DagInstanceId',
      dagVersion: 'DagVersion',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      dagInstanceId: 'number',
      dagVersion: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeTaskFlowInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 7FF2E325-763F-5E27-9157-C3CFA02F4CBF
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeTaskFlowInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ResumeTaskFlowInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ResumeTaskFlowInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryDataCorrectPreCheckRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the data change ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ID of the data change ticket.
   * 
   * This parameter is required.
   * 
   * @example
   * 414****
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryDataCorrectPreCheckResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * MissingOrderId
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * OrderId is mandatory for this action.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 5BC081C7-5F77-5C92-9758-E1ED17CA****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryDataCorrectPreCheckResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RetryDataCorrectPreCheckResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RetryDataCorrectPreCheckResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RevokeTemplateAuthorityRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the permission template.
   * 
   * This parameter is required.
   * 
   * @example
   * 1563
   */
  templateId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  /**
   * @remarks
   * The IDs of users from whom you want to revoke permissions by using a permission template.
   * 
   * This parameter is required.
   * 
   * @example
   * [12***,34***,56***]
   */
  userIds?: string;
  static names(): { [key: string]: string } {
    return {
      templateId: 'TemplateId',
      tid: 'Tid',
      userIds: 'UserIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      templateId: 'number',
      tid: 'number',
      userIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RevokeTemplateAuthorityResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C51420E3-144A-4A94-B473-8662FCF4AD10
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the permissions were revoked from the users.
   * 
   * @example
   * true
   */
  result?: boolean;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      result: 'boolean',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RevokeTemplateAuthorityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RevokeTemplateAuthorityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RevokeTemplateAuthorityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RevokeUserPermissionRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the database. The database can be a physical database or a logical database.
   * 
   * *   To query the ID of a physical database, call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation.
   * *   To query the ID of a logical database, call the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation.
   * 
   * @example
   * 1860****
   */
  dbId?: string;
  /**
   * @remarks
   * The object type on which the permission you want to revoke from the user. Valid values:
   * 
   * *   **INSTANCE**: database instances
   * *   **DATABASE**: physical databases
   * *   **LOGIC_DATABASE**: logical databases
   * *   **TABLE**: physical tables
   * *   **LOGIC_TABLE**: logical tables
   * 
   * This parameter is required.
   * 
   * @example
   * DATABASE
   */
  dsType?: string;
  /**
   * @remarks
   * The ID of the database instance. You must specify this parameter when you revoke a permission from the database instance. You can call the [ListInstances](https://help.aliyun.com/document_detail/141936.html) or [GetInstance](https://help.aliyun.com/document_detail/141567.html) operation to query the database instance ID.
   * 
   * @example
   * 174****
   */
  instanceId?: number;
  /**
   * @remarks
   * Specifies whether the database is a logical database. Valid values:
   * 
   * * **true**: The database is a logical database.
   * * **false**: The database is a physical database.
   * 
   * > * If the database is a logical database, set this parameter to **true**.
   * > * If the database is a physical database, set this parameter to **false**.
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The type of the permission. Valid values:
   * 
   * *   **QUERY**: the data query permission
   * *   **EXPORT**: the data export permission
   * *   **CORRECT**: the data change permission
   * 
   * This parameter is required.
   * 
   * @example
   * CORRECT
   */
  permTypes?: string;
  /**
   * @remarks
   * The ID of the table. You must specify this parameter when you revoke a permission from the table. You can call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation to query the table ID.
   * 
   * @example
   * 13****
   */
  tableId?: string;
  /**
   * @remarks
   * The name of the table. You can call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation to query the table name.
   * 
   * @example
   * table_name
   */
  tableName?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  /**
   * @remarks
   * The ID of the permission. You can call the [ListUserPermission](https://help.aliyun.com/document_detail/146957.html) operation to query the permission ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 774****
   */
  userAccessId?: string;
  /**
   * @remarks
   * The ID of the user. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to query the user ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 51****
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      dsType: 'DsType',
      instanceId: 'InstanceId',
      logic: 'Logic',
      permTypes: 'PermTypes',
      tableId: 'TableId',
      tableName: 'TableName',
      tid: 'Tid',
      userAccessId: 'UserAccessId',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'string',
      dsType: 'string',
      instanceId: 'number',
      logic: 'boolean',
      permTypes: 'string',
      tableId: 'string',
      tableName: 'string',
      tid: 'number',
      userAccessId: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RevokeUserPermissionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * MissingUserId
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * UserId is mandatory for this action.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * A99CD576-1E18-4E86-931E-C3CCE56D****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RevokeUserPermissionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RevokeUserPermissionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RevokeUserPermissionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDataTrackResultRequest extends $tea.Model {
  /**
   * @remarks
   * The condition to filter columns.
   */
  columnFilter?: SearchDataTrackResultRequestColumnFilter;
  /**
   * @remarks
   * The end time of the time range in which you want to track data operations. The time must be in the yyyy-MM-dd HH:mm:ss format.
   * 
   * @example
   * 2023-04-23 10:00:00
   */
  filterEndTime?: string;
  /**
   * @remarks
   * The start time of the time range in which you want to track data operations. The time must be in the yyyy-MM-dd HH:mm:ss format.
   * 
   * @example
   * 2023-04-23 00:00:00
   */
  filterStartTime?: string;
  /**
   * @remarks
   * The names of the tables for which you want to track data operations.
   */
  filterTableList?: string[];
  /**
   * @remarks
   * The types of data operations that you want to track.
   */
  filterTypeList?: string[];
  /**
   * @remarks
   * The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ticket ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 420****
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
   * 
   * @example
   * 62***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      columnFilter: 'ColumnFilter',
      filterEndTime: 'FilterEndTime',
      filterStartTime: 'FilterStartTime',
      filterTableList: 'FilterTableList',
      filterTypeList: 'FilterTypeList',
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnFilter: SearchDataTrackResultRequestColumnFilter,
      filterEndTime: 'string',
      filterStartTime: 'string',
      filterTableList: { 'type': 'array', 'itemType': 'string' },
      filterTypeList: { 'type': 'array', 'itemType': 'string' },
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDataTrackResultShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The condition to filter columns.
   */
  columnFilterShrink?: string;
  /**
   * @remarks
   * The end time of the time range in which you want to track data operations. The time must be in the yyyy-MM-dd HH:mm:ss format.
   * 
   * @example
   * 2023-04-23 10:00:00
   */
  filterEndTime?: string;
  /**
   * @remarks
   * The start time of the time range in which you want to track data operations. The time must be in the yyyy-MM-dd HH:mm:ss format.
   * 
   * @example
   * 2023-04-23 00:00:00
   */
  filterStartTime?: string;
  /**
   * @remarks
   * The names of the tables for which you want to track data operations.
   */
  filterTableListShrink?: string;
  /**
   * @remarks
   * The types of data operations that you want to track.
   */
  filterTypeListShrink?: string;
  /**
   * @remarks
   * The ID of the ticket. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to query the ticket ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 420****
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
   * 
   * @example
   * 62***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      columnFilterShrink: 'ColumnFilter',
      filterEndTime: 'FilterEndTime',
      filterStartTime: 'FilterStartTime',
      filterTableListShrink: 'FilterTableList',
      filterTypeListShrink: 'FilterTypeList',
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnFilterShrink: 'string',
      filterEndTime: 'string',
      filterStartTime: 'string',
      filterTableListShrink: 'string',
      filterTypeListShrink: 'string',
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDataTrackResultResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0C1CB646-1DE4-4AD0-B4A4-7D47DD52E931
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The parsing result of the data tracking task.
   */
  trackResult?: SearchDataTrackResultResponseBodyTrackResult;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      trackResult: 'TrackResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      trackResult: SearchDataTrackResultResponseBodyTrackResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDataTrackResultResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchDataTrackResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchDataTrackResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDatabaseRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the database. For more information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
   * 
   * @example
   * MYSQL
   */
  dbType?: string;
  /**
   * @remarks
   * The environment type of the database. For more information, see [Change the environment type of an instance](https://help.aliyun.com/document_detail/163309.html).
   * 
   * @example
   * test
   */
  envType?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The keyword that is used to search for databases.
   * 
   * @example
   * testdb
   */
  searchKey?: string;
  /**
   * @remarks
   * The query range based on permissions. Valid values:
   * 
   * *   **HAS_PERMSSION**: searches for databases on which the current user has permissions.
   * *   **OWNER**: searches for databases owned by the current user.
   * *   **MY_FOCUS**: searches for databases that the current user follows.
   * *   **UNKNOWN**: searches for all databases.
   * 
   * @example
   * HAS_PERMSSION
   */
  searchRange?: string;
  /**
   * @remarks
   * The category of the database. Valid values:
   * 
   * *   **DB**: single database or logical database.
   * *   **SINGLE_DB**: single database.
   * *   **LOGIC_DB**: logical database.
   * 
   * @example
   * SINGLE_DB
   */
  searchTarget?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dbType: 'DbType',
      envType: 'EnvType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchKey: 'SearchKey',
      searchRange: 'SearchRange',
      searchTarget: 'SearchTarget',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbType: 'string',
      envType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchKey: 'string',
      searchRange: 'string',
      searchTarget: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDatabaseResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E0D21075-CD3E-4D98-8264-FD8AD04A63B6
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the databases.
   */
  searchDatabaseList?: SearchDatabaseResponseBodySearchDatabaseList;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**: The request is successful.
   * *   **false**: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      searchDatabaseList: 'SearchDatabaseList',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      searchDatabaseList: SearchDatabaseResponseBodySearchDatabaseList,
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDatabaseResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchDatabaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchDatabaseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTableRequest extends $tea.Model {
  /**
   * @remarks
   * The type of database. Valid values:
   * 
   * *   **MySQL**
   * *   **SQLServer**
   * *   **PostgreSQL**
   * *   **Oracle**
   * *   **DRDS**
   * *   **OceanBase**
   * *   **Mongo**
   * *   **Redis**
   * 
   * @example
   * MySQL
   */
  dbType?: string;
  /**
   * @remarks
   * The type of the environment to which databases belong. For more information, see [Change the environment type of an instance](https://help.aliyun.com/document_detail/163309.html).
   * 
   * @example
   * PRODUCT
   */
  envType?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * Specifies whether to return the GUID of each table.
   * 
   * @example
   * false
   */
  returnGuid?: boolean;
  /**
   * @remarks
   * The keyword that is used to query tables.
   * 
   * @example
   * test
   */
  searchKey?: string;
  /**
   * @remarks
   * The scope of tables that you want to query. Valid values:
   * 
   * *   **HAS_PERMSSION**: the tables on which the current account has permissions.
   * *   **OWNER**: the tables owned by the current account.
   * *   **MY_FOCUS**: the tables that the current account follows.
   * *   **UNKNOWN**: all tables.
   * 
   * @example
   * OWNER
   */
  searchRange?: string;
  /**
   * @remarks
   * The type of table that you want to query. Valid values:
   * 
   * *   **TABLE**: physical and logical tables
   * *   **SINGLE_TABLE**: physical tables
   * *   **LOGIC_TABLE**: logical tables
   * 
   * @example
   * LOGIC_TABLE
   */
  searchTarget?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the "Manage DMS tenants" topic.
   * 
   * @example
   * 1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dbType: 'DbType',
      envType: 'EnvType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      returnGuid: 'ReturnGuid',
      searchKey: 'SearchKey',
      searchRange: 'SearchRange',
      searchTarget: 'SearchTarget',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbType: 'string',
      envType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      returnGuid: 'boolean',
      searchKey: 'string',
      searchRange: 'string',
      searchTarget: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTableResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 1489257F-1B5D-4B5B-89EF-923C12CEEBD1
   */
  requestId?: string;
  /**
   * @remarks
   * The details of the tables.
   */
  searchTableList?: SearchTableResponseBodySearchTableList;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The total number of entries that are returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      searchTableList: 'SearchTableList',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      searchTableList: SearchTableResponseBodySearchTableList,
      success: 'boolean',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTableResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchTableResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchTableResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetOwnersRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the user whom you want to specify as an owner. Separate multiple IDs with commas (,). You can call the [GetUser](https://help.aliyun.com/document_detail/147098.html) or [ListUsers](https://help.aliyun.com/document_detail/141938.html) operation to query the ID of the user.
   * 
   * >  The value of the OwnerIds parameter is that of the UserId parameter.
   * 
   * This parameter is required.
   * 
   * @example
   * 51****
   */
  ownerIds?: string;
  /**
   * @remarks
   * The type of the owner. Valid values:
   * 
   * *   INSTANCE: an owner of an instance.
   * *   DATABASE: an owner of a physical database.
   * *   LOGIC_DATABASE: an owner of a logical database.
   * *   TABLE: an owner of a physical table.
   * *   LOGIC_TABLE: an owner of a logical table.
   * 
   * This parameter is required.
   * 
   * @example
   * INSTANCE
   */
  ownerType?: string;
  /**
   * @remarks
   * The ID of the resource. The ID of the resource varies with the owner type. The owner types and resource IDs have the following mappings:
   * 
   * *   INSTANCE: the ID of an instance. You can call the [ListInstances](https://help.aliyun.com/document_detail/141936.html) operation to query the ID of the instance.
   * *   DATABASE: the ID of a physical database. You can call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) operation to query the ID of the physical database.
   * *   LOGIC_DATABASE: the ID of a logical database. You can call the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) operation to query the ID of the logical database.
   * *   TABLE: the ID of a physical table. You can call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation to query the ID of the physical table.
   * *   LOGIC_DATABASE: the ID of a logical table. You can call the [ListLogicTables](https://help.aliyun.com/document_detail/141875.html) operation to query the ID of the logical table.
   * 
   * This parameter is required.
   * 
   * @example
   * 174****
   */
  resourceId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html) topic.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      ownerIds: 'OwnerIds',
      ownerType: 'OwnerType',
      resourceId: 'ResourceId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerIds: 'string',
      ownerType: 'string',
      resourceId: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetOwnersResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * A99CD576-1E18-4E86-931E-C3CCE56DC030
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   true: The request is successful.
   * *   false: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetOwnersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetOwnersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetOwnersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SkipDataCorrectRowCheckRequest extends $tea.Model {
  /**
   * @remarks
   * The ticket ID. You can call the [ListOrders](https://help.aliyun.com/document_detail/144643.html) operation to obtain the ticket ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 420****
   */
  orderId?: number;
  /**
   * @remarks
   * The reason for skipping the verification on the number of rows in the precheck for data change.
   * 
   * This parameter is required.
   * 
   * @example
   * save test time
   */
  reason?: string;
  /**
   * @remarks
   * The tenant ID. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to obtain the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      reason: 'Reason',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      reason: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SkipDataCorrectRowCheckResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 7FAD400F-7A5C-4193-8F9A-39D86C4F0231
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SkipDataCorrectRowCheckResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SkipDataCorrectRowCheckResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SkipDataCorrectRowCheckResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopTaskFlowInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 7***
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the execution record of the task flow. You can call the [ListTaskFlowInstance](https://help.aliyun.com/document_detail/424689.html) operation to query the execution record ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 47****
   */
  dagInstanceId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      dagInstanceId: 'DagInstanceId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      dagInstanceId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopTaskFlowInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * 028BF827-3801-5869-8548-F4A039256308
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopTaskFlowInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StopTaskFlowInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopTaskFlowInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitOrderApprovalRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ticket.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  orderId?: number;
  realLoginUserUid?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * -1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      realLoginUserUid: 'RealLoginUserUid',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      realLoginUserUid: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitOrderApprovalResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 427688B8-ADFB-4C4E-9D45-EF5C1FD6E23D
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitOrderApprovalResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SubmitOrderApprovalResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SubmitOrderApprovalResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitStructSyncOrderApprovalRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the ticket.
   * 
   * This parameter is required.
   * 
   * @example
   * 4324535
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      orderId: 'OrderId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitStructSyncOrderApprovalResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4E1D2B4D-3E53-4ABC-999D-1D2520B3471D
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The ID of the approval process.
   * 
   * @example
   * 432523
   */
  workflowInstanceId?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      workflowInstanceId: 'WorkflowInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      workflowInstanceId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitStructSyncOrderApprovalResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SubmitStructSyncOrderApprovalResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SubmitStructSyncOrderApprovalResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SuspendTaskFlowInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 7***
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the execution record of the task flow. You can call the [ListTaskFlowInstance](https://help.aliyun.com/document_detail/424689.html) operation to query the execution record ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 47****
   */
  dagInstanceId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      dagInstanceId: 'DagInstanceId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      dagInstanceId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SuspendTaskFlowInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * 028BF827-3801-5869-8548-F4A039256305
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SuspendTaskFlowInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SuspendTaskFlowInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SuspendTaskFlowInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncDatabaseMetaRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the database.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  dbId?: string;
  /**
   * @remarks
   * Specifies whether the database is a logical database.
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * -1
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      logic: 'Logic',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'string',
      logic: 'boolean',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncDatabaseMetaResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * A99CD576-1E18-4E86-931E-C3CCE56DC030
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncDatabaseMetaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SyncDatabaseMetaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SyncDatabaseMetaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncInstanceMetaRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to skip synchronization for the metadata of table dictionaries. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  ignoreTable?: boolean;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * 12***
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the Manage DMS tenants topic.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      ignoreTable: 'IgnoreTable',
      instanceId: 'InstanceId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ignoreTable: 'boolean',
      instanceId: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncInstanceMetaResponseBody extends $tea.Model {
  /**
   * @remarks
   * Details about the topology of the data table.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * A99CD576-1E18-4E86-931E-C3CCE56DC030
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncInstanceMetaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SyncInstanceMetaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SyncInstanceMetaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAuthorityTemplateRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the permission template.
   * 
   * >  You must specify the Name or Description parameter. Otherwise, the API call fails.
   * 
   * This parameter is required.
   * 
   * @example
   * This template is used for business testing.
   */
  description?: string;
  /**
   * @remarks
   * The name of the permission template.
   * 
   * >  You must specify the Name or Description parameter. Otherwise, the API call fails.
   * 
   * This parameter is required.
   * 
   * @example
   * Test template.
   */
  name?: string;
  /**
   * @remarks
   * The ID of the permission template.
   * 
   * This parameter is required.
   * 
   * @example
   * 1563
   */
  templateId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      templateId: 'TemplateId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      templateId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAuthorityTemplateResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the permission template.
   */
  authorityTemplateView?: UpdateAuthorityTemplateResponseBodyAuthorityTemplateView;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4E1D2B4D-3E53-4ABC-999D-1D2520B3471A
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      authorityTemplateView: 'AuthorityTemplateView',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorityTemplateView: UpdateAuthorityTemplateResponseBodyAuthorityTemplateView,
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAuthorityTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateAuthorityTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateAuthorityTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the database link for cross-database queries.
   * 
   * > 
   * 
   * *   This parameter is required if UseDsql is set to 1.
   * 
   * *   The name can contain only lowercase letters and underscores (_).
   * 
   * *   The name must be unique within a tenant.
   * 
   * @example
   * datalink_test
   */
  dataLinkName?: string;
  /**
   * @remarks
   * The password that is used to log on to the database.
   * 
   * This parameter is required.
   * 
   * @example
   * ******
   */
  databasePassword?: string;
  /**
   * @remarks
   * The account that is used to log on to the database.
   * 
   * This parameter is required.
   * 
   * @example
   * dbuser
   */
  databaseUser?: string;
  /**
   * @remarks
   * The ID of the user who assumes the database administrator (DBA) role of the database instance. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetInstance](https://help.aliyun.com/document_detail/141567.html) operation to query the user ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 27****
   */
  dbaId?: string;
  /**
   * @remarks
   * Specifies whether to enable the lock-free schema change feature for the database instance. Valid values:
   * 
   * *   **0:** disables the lock-free schema change feature.
   * *   **1**: uses the online DDL of MySQL first.
   * *   **2**: uses the lock-free schema change feature of DMS first.
   * 
   * @example
   * 0
   */
  ddlOnline?: number;
  /**
   * @remarks
   * The ID of the ECS instance on which the database instance is deployed.
   * 
   * > This parameter is required if the InstanceSource parameter is set to ECS_OWN.
   * 
   * @example
   * i-2zei9gs1t7h8l7ac****
   */
  ecsInstanceId?: string;
  /**
   * @remarks
   * The ID of the region in which the database instance resides.
   * 
   * > This parameter is required if InstanceSource is set to RDS, ECS_OWN, and VPC_IDC.
   * 
   * @example
   * cn-hangzhou
   */
  ecsRegion?: string;
  /**
   * @remarks
   * *   **Y:** enables the sensitive data protection feature
   * *   **N:** disables the sensitive data protection feature
   * *   **NULL or other:** does not update the status of the sensitive data protection feature
   * 
   * @example
   * Y
   */
  enableSellSitd?: string;
  /**
   * @remarks
   * The type of the environment in which the database instance is deployed. Valid values:
   * 
   * *   **product:** production environment
   * *   **dev:** development environment
   * *   **pre:** pre-release environment
   * *   **test:** test environment
   * *   **sit:** system integration testing (SIT) environment
   * *   **uat:** user acceptance testing (UAT) environment
   * *   **pet:** stress testing environment
   * *   **stag:** staging environment
   * 
   * This parameter is required.
   * 
   * @example
   * product
   */
  envType?: string;
  /**
   * @remarks
   * The timeout period for exporting data from the database instance.
   * 
   * This parameter is required.
   * 
   * @example
   * 600
   */
  exportTimeout?: number;
  /**
   * @remarks
   * The host address that is used to connect to the database instance.
   * 
   * This parameter is required.
   * 
   * @example
   * 192.XXX.0.56
   */
  host?: string;
  /**
   * @remarks
   * The alias of the database instance. Specify an alias that can help you identify the database instance in DMS.
   * 
   * This parameter is required.
   * 
   * @example
   * instance_test
   */
  instanceAlias?: string;
  /**
   * @remarks
   * The ID of the database instance. You can call the [GetInstance](https://help.aliyun.com/document_detail/141567.html) operation to query the instance ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 126****
   */
  instanceId?: string;
  /**
   * @remarks
   * The source of the database instance. Valid values:
   * 
   * *   **PUBLIC_OWN:** a self-managed database instance that is deployed on the Internet
   * *   **RDS:** an ApsaraDB RDS instance
   * *   **ECS_OWN:** a self-managed database that is deployed on an Elastic Compute Service (ECS) instance
   * *   **VPC_IDC:** a self-managed database instance that is deployed in a data center connected over a virtual private cloud (VPC)
   * 
   * This parameter is required.
   * 
   * @example
   * ECS_OWN
   */
  instanceSource?: string;
  /**
   * @remarks
   * The type of the database. For more information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
   * 
   * This parameter is required.
   * 
   * @example
   * mysql
   */
  instanceType?: string;
  /**
   * @remarks
   * The port that is used to connect to the database instance.
   * 
   * This parameter is required.
   * 
   * @example
   * 3306
   */
  port?: number;
  /**
   * @remarks
   * The timeout period for querying data in the database instance.
   * 
   * This parameter is required.
   * 
   * @example
   * 60
   */
  queryTimeout?: number;
  /**
   * @remarks
   * The name of the security rule set (GroupName) for the instance. You can call the [ListStandardGroups](https://help.aliyun.com/document_detail/417891.html) or [GetInstance](https://help.aliyun.com/document_detail/141567.html) operation to query the name of the security rule set.
   * 
   * This parameter is required.
   * 
   * @example
   * 3****
   */
  safeRuleId?: string;
  /**
   * @remarks
   * The system ID (SID) of the database instance.
   * 
   * > This parameter is required if the InstanceType parameter is set to ORACLE.
   * 
   * @example
   * XXX
   */
  sid?: string;
  /**
   * @remarks
   * Specifies whether to skip the connectivity test. Valid values:
   * 
   * *   **true:** skips the connectivity test
   * *   **false:** does not skip the connectivity test
   * 
   * @example
   * false
   */
  skipTest?: boolean;
  /**
   * @remarks
   * The ID of the classification template. You can call the [ListClassificationTemplates](https://help.aliyun.com/document_detail/460613.html) operation to query the template ID.
   * 
   * @example
   * 3***
   */
  templateId?: number;
  /**
   * @remarks
   * The type of the classification template. You can call the [ListClassificationTemplates](https://help.aliyun.com/document_detail/460613.html) operation to query the template type.
   * 
   * @example
   * INNER
   */
  templateType?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  /**
   * @remarks
   * Specifies whether to enable the cross-database query feature for the database instance. Valid values:
   * 
   * *   **0**: disables the cross-database query feature.
   * *   **1**: enables the cross-database query feature.
   * 
   * > Supported database types: MySQL, SQL Server, PostgreSQL, PolarDB for PostgreSQL (compatible with Oracle), and ApsaraDB for Redis.
   * 
   * @example
   * 0
   */
  useDsql?: number;
  /**
   * @remarks
   * The ID of the VPC to which the database instance belongs.
   * 
   * > This parameter is required if the InstanceSource parameter is set to VPC_IDC.
   * 
   * @example
   * vpc-xxx
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      dataLinkName: 'DataLinkName',
      databasePassword: 'DatabasePassword',
      databaseUser: 'DatabaseUser',
      dbaId: 'DbaId',
      ddlOnline: 'DdlOnline',
      ecsInstanceId: 'EcsInstanceId',
      ecsRegion: 'EcsRegion',
      enableSellSitd: 'EnableSellSitd',
      envType: 'EnvType',
      exportTimeout: 'ExportTimeout',
      host: 'Host',
      instanceAlias: 'InstanceAlias',
      instanceId: 'InstanceId',
      instanceSource: 'InstanceSource',
      instanceType: 'InstanceType',
      port: 'Port',
      queryTimeout: 'QueryTimeout',
      safeRuleId: 'SafeRuleId',
      sid: 'Sid',
      skipTest: 'SkipTest',
      templateId: 'TemplateId',
      templateType: 'TemplateType',
      tid: 'Tid',
      useDsql: 'UseDsql',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataLinkName: 'string',
      databasePassword: 'string',
      databaseUser: 'string',
      dbaId: 'string',
      ddlOnline: 'number',
      ecsInstanceId: 'string',
      ecsRegion: 'string',
      enableSellSitd: 'string',
      envType: 'string',
      exportTimeout: 'number',
      host: 'string',
      instanceAlias: 'string',
      instanceId: 'string',
      instanceSource: 'string',
      instanceType: 'string',
      port: 'number',
      queryTimeout: 'number',
      safeRuleId: 'string',
      sid: 'string',
      skipTest: 'boolean',
      templateId: 'number',
      templateType: 'string',
      tid: 'number',
      useDsql: 'number',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E9BEBF41-4F69-4605-A5D5-A67955173941
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true:** The request was successful.
   * *   **false:** The request failed.
   * 
   * @example
   * false
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSLARulesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 11****
   */
  dagId?: number;
  /**
   * @remarks
   * The list of SLA rules.
   */
  slaRuleList?: UpdateSLARulesRequestSlaRuleList[];
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      slaRuleList: 'SlaRuleList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      slaRuleList: { 'type': 'array', 'itemType': UpdateSLARulesRequestSlaRuleList },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSLARulesShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 11****
   */
  dagId?: number;
  /**
   * @remarks
   * The list of SLA rules.
   */
  slaRuleListShrink?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      slaRuleListShrink: 'SlaRuleList',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      slaRuleListShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSLARulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * 88E053F7-347B-52DD-A186-1F340EEC0C27
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSLARulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateSLARulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSLARulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScenarioRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the business scenario.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The ID of the business scenario.
   * 
   * This parameter is required.
   * 
   * @example
   * 12***
   */
  scenarioId?: string;
  /**
   * @remarks
   * The name of the business scenario.
   * 
   * This parameter is required.
   * 
   * @example
   * Business scenario - test
   */
  scenarioName?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      scenarioId: 'ScenarioId',
      scenarioName: 'ScenarioName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      scenarioId: 'string',
      scenarioName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScenarioResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 7FAD400F-7A5C-4193-8F9A-39D86C4F0231
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScenarioResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateScenarioResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateScenarioResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateStandardGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the security rule set.
   * 
   * This parameter is required.
   * 
   * @example
   * Production Environment test rules
   */
  description?: string;
  /**
   * @remarks
   * The security rule set ID. You can call the [ListStandardGroups](https://help.aliyun.com/document_detail/465940.html) operation to obtain the ID of the security rule set.
   * 
   * This parameter is required.
   * 
   * @example
   * 242***
   */
  groupId?: number;
  /**
   * @remarks
   * The name of the security rule set.
   * 
   * This parameter is required.
   * 
   * @example
   * poc_test
   */
  groupName?: string;
  /**
   * @remarks
   * The tenant ID.
   * 
   * >  To view the tenant ID, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see the [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html) section of the "Manage DMS tenants" topic.
   * 
   * @example
   * 23****
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      groupId: 'GroupId',
      groupName: 'GroupName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      groupId: 'number',
      groupName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateStandardGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The request ID. You can use the request ID to locate logs and troubleshoot issues.
   * 
   * @example
   * 4E1D2B4D-3E53-4ABC-999D-1D2520B3471A
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the security rule set.
   */
  standardGroup?: UpdateStandardGroupResponseBodyStandardGroup;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      standardGroup: 'StandardGroup',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      standardGroup: UpdateStandardGroupResponseBodyStandardGroup,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateStandardGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateStandardGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateStandardGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The advanced configuration for the node. The value of this parameter must be a JSON string.
   * 
   * This parameter is required.
   * 
   * @example
   * { "rerun":{ "rerunEnable":true,  "rerunCount":1,   "rerunInterval":10 } }
   */
  nodeConfig?: string;
  /**
   * @remarks
   * The ID of the task node. You can call the [GetTaskInstanceRelation](https://help.aliyun.com/document_detail/424711.html) operation to query the node ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 43****
   */
  nodeId?: string;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      nodeConfig: 'NodeConfig',
      nodeId: 'NodeId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeConfig: 'string',
      nodeId: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F4E2A94B-604F-43FF-93E7-F4EE3DCF412E
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskContentRequest extends $tea.Model {
  /**
   * @remarks
   * The node configurations after modification.
   * 
   * @example
   * { "dbId":12****, "sql":"select * from test_table",   "dbType":"lindorm_sql"  }
   */
  nodeContent?: string;
  /**
   * @remarks
   * The ID of the task node. You can call the [GetTaskInstanceRelation](https://help.aliyun.com/document_detail/424711.html) operation to query the node ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 43****
   */
  nodeId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the ["View information about the current tenant"](https://help.aliyun.com/document_detail/181330.html) section of the Manage DMS tenants topic.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      nodeContent: 'NodeContent',
      nodeId: 'NodeId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeContent: 'string',
      nodeId: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskContentResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * 39557312-28D5-528F-9554-80C0700EB489
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskContentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskContentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskContentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowConstantsRequest extends $tea.Model {
  /**
   * @remarks
   * The constants for the task flow.
   */
  dagConstants?: UpdateTaskFlowConstantsRequestDagConstants[];
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 3****
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagConstants: 'DagConstants',
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagConstants: { 'type': 'array', 'itemType': UpdateTaskFlowConstantsRequestDagConstants },
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowConstantsShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The constants for the task flow.
   */
  dagConstantsShrink?: string;
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 3****
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the tenant. You can call the [GetUserActiveTenant](https://help.aliyun.com/document_detail/198073.html) or [ListUserTenants](https://help.aliyun.com/document_detail/198074.html) operation to query the tenant ID.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagConstantsShrink: 'DagConstants',
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagConstantsShrink: 'string',
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowConstantsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * C4CCC000-C193-5A32-B701-573F497BF729
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowConstantsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskFlowConstantsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskFlowConstantsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowCooperatorsRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of the users who are involved in the task flow to be updated.
   */
  cooperatorIds?: string[];
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 11****
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      cooperatorIds: 'CooperatorIds',
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cooperatorIds: { 'type': 'array', 'itemType': 'string' },
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowCooperatorsShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of the users who are involved in the task flow to be updated.
   */
  cooperatorIdsShrink?: string;
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 11****
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      cooperatorIdsShrink: 'CooperatorIds',
      dagId: 'DagId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cooperatorIdsShrink: 'string',
      dagId: 'number',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowCooperatorsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * D05B3EE1-B6D3-5B17-8CA6-A8054828E5B2
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowCooperatorsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskFlowCooperatorsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskFlowCooperatorsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowEdgesRequest extends $tea.Model {
  /**
   * @remarks
   * The task flow ID. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 15***
   */
  dagId?: number;
  /**
   * @remarks
   * The list of updated task flow edges.
   * 
   * This parameter is required.
   */
  edges?: UpdateTaskFlowEdgesRequestEdges[];
  /**
   * @remarks
   * The tenant ID.
   * 
   * > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      edges: 'Edges',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      edges: { 'type': 'array', 'itemType': UpdateTaskFlowEdgesRequestEdges },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowEdgesShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The task flow ID. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 15***
   */
  dagId?: number;
  /**
   * @remarks
   * The list of updated task flow edges.
   * 
   * This parameter is required.
   */
  edgesShrink?: string;
  /**
   * @remarks
   * The tenant ID.
   * 
   * > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      edgesShrink: 'Edges',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      edgesShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowEdgesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 93FC1AE1-EC54-52B1-B146-650180FB82E8
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowEdgesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskFlowEdgesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskFlowEdgesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowNameAndDescRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 15***
   */
  dagId?: number;
  /**
   * @remarks
   * The new name that you want to specify for the task flow.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  dagName?: string;
  /**
   * @remarks
   * The description that you want to specify for the task flow.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      dagName: 'DagName',
      description: 'Description',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      dagName: 'string',
      description: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowNameAndDescResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * F73CCB9D-0CF3-5D3D-97B0-D852A8022663
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowNameAndDescResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskFlowNameAndDescResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskFlowNameAndDescResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowNotificationRequest extends $tea.Model {
  /**
   * @remarks
   * The unique ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 15***
   */
  dagId?: number;
  /**
   * @remarks
   * Specifies whether to enable notifications for failed task flows. Notifications are disabled by default. You can enable notifications based on your business requirements.
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  dagNotificationFail?: boolean;
  /**
   * @remarks
   * Specifies whether to enable SLA global notifications for task flows. Notifications are disabled by default. You can enable notifications based on your business requirements.
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  dagNotificationSla?: boolean;
  /**
   * @remarks
   * Specifies whether to enable notifications for successful task flows. Notifications are disabled by default. You can enable notifications based on your business requirements.
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  dagNotificationSuccess?: boolean;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      dagNotificationFail: 'DagNotificationFail',
      dagNotificationSla: 'DagNotificationSla',
      dagNotificationSuccess: 'DagNotificationSuccess',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      dagNotificationFail: 'boolean',
      dagNotificationSla: 'boolean',
      dagNotificationSuccess: 'boolean',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowNotificationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * 3BDC762F-2525-5E47-8748-D6C58BDB3B38
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowNotificationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskFlowNotificationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskFlowNotificationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowOwnerRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlowInstance](https://help.aliyun.com/document_detail/424689.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 15***
   */
  dagId?: number;
  /**
   * @remarks
   * The user ID of the new owner. You can call the [GetUser](https://help.aliyun.com/document_detail/147098.html) or [ListUsers](https://help.aliyun.com/document_detail/141938.html) operation to query the user ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 51****
   */
  newOwnerId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      newOwnerId: 'NewOwnerId',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      newOwnerId: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowOwnerResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * 482C61C1-2537-5BFB-8E58-34D9F17AD3C3
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowOwnerResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskFlowOwnerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskFlowOwnerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowRelationsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 15***
   */
  dagId?: number;
  /**
   * @remarks
   * The list of task flow edges to be updated.
   */
  edges?: UpdateTaskFlowRelationsRequestEdges[];
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      edges: 'Edges',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      edges: { 'type': 'array', 'itemType': UpdateTaskFlowRelationsRequestEdges },
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowRelationsShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to query the task flow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 15***
   */
  dagId?: number;
  /**
   * @remarks
   * The list of task flow edges to be updated.
   */
  edgesShrink?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      edgesShrink: 'Edges',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      edgesShrink: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowRelationsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * 15D9E71C-405B-57D7-BE6E-707C2C7A8E0B
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowRelationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskFlowRelationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskFlowRelationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowScheduleRequest extends $tea.Model {
  /**
   * @remarks
   * The start of the time range for scheduling.
   * 
   * @example
   * CronBeginDate_test
   */
  cronBeginDate?: string;
  /**
   * @remarks
   * The end of the time range for scheduling.
   * 
   * @example
   * CronEndDate_test
   */
  cronEndDate?: string;
  /**
   * @remarks
   * The cron expression for timed scheduling.
   * 
   * @example
   * CronStr_test
   */
  cronStr?: string;
  /**
   * @remarks
   * The type of the scheduling cycle. Valid values:
   * 
   * *   **MINUTE**: scheduling by minute
   * *   **HOUR**: scheduling by hour
   * *   **DAY**: scheduling by day
   * *   **WEEK**: scheduling by week
   * *   **MONTH**: scheduling by month
   * 
   * @example
   * HOUR
   */
  cronType?: string;
  /**
   * @remarks
   * The ID of the task flow.
   * 
   * This parameter is required.
   * 
   * @example
   * 7***
   */
  dagId?: number;
  /**
   * @remarks
   * The event scheduling configuration. The value of this parameter is a JSON string.
   * 
   * This parameter is required.
   * 
   * @example
   * ScheduleParam_test
   */
  scheduleParam?: string;
  /**
   * @remarks
   * Specifies whether to enable scheduling. Valid values:
   * 
   * *   **Enable**
   * *   **Disable**
   * 
   * This parameter is required.
   * 
   * @example
   * Disable
   */
  scheduleSwitch?: boolean;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  /**
   * @remarks
   * The time zone. The default time zone is UTC+8 (Asia/Shanghai).
   * 
   * @example
   * Asia/Shanghai
   */
  timeZoneId?: string;
  /**
   * @remarks
   * The mode in which the task flow is triggered. Valid values:
   * 
   * *   **Cron**: The task flow is triggered based on timed scheduling.
   * *   **Event**: The task flow is triggered by events.
   * 
   * This parameter is required.
   * 
   * @example
   * Event
   */
  triggerType?: string;
  static names(): { [key: string]: string } {
    return {
      cronBeginDate: 'CronBeginDate',
      cronEndDate: 'CronEndDate',
      cronStr: 'CronStr',
      cronType: 'CronType',
      dagId: 'DagId',
      scheduleParam: 'ScheduleParam',
      scheduleSwitch: 'ScheduleSwitch',
      tid: 'Tid',
      timeZoneId: 'TimeZoneId',
      triggerType: 'TriggerType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cronBeginDate: 'string',
      cronEndDate: 'string',
      cronStr: 'string',
      cronType: 'string',
      dagId: 'number',
      scheduleParam: 'string',
      scheduleSwitch: 'boolean',
      tid: 'number',
      timeZoneId: 'string',
      triggerType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowScheduleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * InvalidParameterValid
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * InvalidParameterValid
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * 7BF38A13-C181-5B5E-97F1-8643F8A10093
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowScheduleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskFlowScheduleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskFlowScheduleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowTimeVariablesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task node. You can call the [GetTaskInstanceRelation](https://help.aliyun.com/document_detail/424711.html) operation to query the node ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 43****
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  /**
   * @remarks
   * The time variables for the task flow.
   * 
   * This parameter is required.
   * 
   * @example
   * {"variables":[ {"name":"var", "pattern":"yyyy-MM-dd|+0m+0h-2d+0w+0M+1y"} ]}
   */
  timeVariables?: string;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      tid: 'Tid',
      timeVariables: 'TimeVariables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      tid: 'number',
      timeVariables: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowTimeVariablesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * 39557312-28D5-528F-9554-80C0700EB489
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowTimeVariablesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskFlowTimeVariablesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskFlowTimeVariablesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskNameRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the node. You can call the [GetTaskInstanceRelation](https://help.aliyun.com/document_detail/424711.html) operation to query the node ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 449***
   */
  nodeId?: string;
  /**
   * @remarks
   * The name of the node. You can call the [GetTaskInstanceRelation](https://help.aliyun.com/document_detail/424711.html) operation to query the node name.
   * 
   * This parameter is required.
   * 
   * @example
   * Spark-test
   */
  nodeName?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'string',
      nodeName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskNameResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * C4604178-3BE1-5973-ACF0-7D561AEEF3A8
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskNameResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskNameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskOutputRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the node. You can call the [GetTaskInstanceRelation](https://help.aliyun.com/document_detail/424711.html) operation to query the node ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 14059
   */
  nodeId?: string;
  /**
   * @remarks
   * The output variables for the task.
   * 
   * @example
   * {outputs:[{"row":0, "column":-1,"combiner":","}"extractMethod":"{\\"row\\":0,\\"column\\":-1,\\"combiner\\":\\",\\"}",   "variableName":"var", "description":"For demo" }]}
   */
  nodeOutput?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      nodeOutput: 'NodeOutput',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'string',
      nodeOutput: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskOutputResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * AB524768-8A5F-523A-91BD-1147187FCD62
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskOutputResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskOutputResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskOutputResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskTimeVariablesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task node. You can call the [GetTaskInstanceRelation](https://help.aliyun.com/document_detail/424711.html) operation to query the node ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 43****
   */
  nodeId?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * 3***
   */
  tid?: number;
  /**
   * @remarks
   * The time variables configured for the node. The value of this parameter must be a JSON string.
   * 
   * This parameter is required.
   * 
   * @example
   * {"variables":[ {"name":"var", "pattern":"yyyy-MM-dd|+0m+0h-2d+0w+0M+1y"} ]}
   */
  timeVariables?: string;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      tid: 'Tid',
      timeVariables: 'TimeVariables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'string',
      tid: 'number',
      timeVariables: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskTimeVariablesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 39557312-28D5-528F-9554-80C0700EB489
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**: The request was successful.
   * *   **false**: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskTimeVariablesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTaskTimeVariablesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTaskTimeVariablesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserRequest extends $tea.Model {
  /**
   * @remarks
   * The maximum number of queries that can be performed each day.
   * 
   * @example
   * 1000
   */
  maxExecuteCount?: number;
  /**
   * @remarks
   * The maximum number of rows that can be queried each day.
   * 
   * @example
   * 1000
   */
  maxResultCount?: number;
  /**
   * @remarks
   * The DingTalk ID or mobile number of the user.
   * 
   * @example
   * 188xxxxxxxx
   */
  mobile?: string;
  /**
   * @remarks
   * The roles that the user assumes. For more information about the valid values, see the Request parameters section in the [UpdateUser](https://help.aliyun.com/document_detail/465812.html) topic.
   * 
   * @example
   * ADMIN,DBA
   */
  roleNames?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](https://help.aliyun.com/document_detail/181330.html).
   * 
   * @example
   * -1
   */
  tid?: number;
  /**
   * @remarks
   * The Alibaba Cloud unique ID (UID) of the user to update.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456789
   */
  uid?: number;
  /**
   * @remarks
   * The nickname of the user.
   * 
   * @example
   * test
   */
  userNick?: string;
  static names(): { [key: string]: string } {
    return {
      maxExecuteCount: 'MaxExecuteCount',
      maxResultCount: 'MaxResultCount',
      mobile: 'Mobile',
      roleNames: 'RoleNames',
      tid: 'Tid',
      uid: 'Uid',
      userNick: 'UserNick',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxExecuteCount: 'number',
      maxResultCount: 'number',
      mobile: 'string',
      roleNames: 'string',
      tid: 'number',
      uid: 'number',
      userNick: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * UnknownError
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E9BEBF41-4F69-4605-A5D5-A67955173941
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request succeeded.
   * 
   * @example
   * false
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddLhMembersRequestMembers extends $tea.Model {
  /**
   * @remarks
   * The role. Valid values:
   * 
   * *   **ADMIN**: workspace administrator. You can add a workspace administrator only as a DMS administrator or a DBA.
   * *   **MEMBER**: workspace member.
   * *   **DEVELOPER**: task flow developer. Only a workspace member can be added as a task flow developer.
   * 
   * This parameter is required.
   */
  roles?: string[];
  /**
   * @remarks
   * The ID of the user to be added. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to obtain the user ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 15****
   */
  userId?: number;
  static names(): { [key: string]: string } {
    return {
      roles: 'Roles',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roles: { 'type': 'array', 'itemType': 'string' },
      userId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTaskFlowEdgesRequestEdges extends $tea.Model {
  /**
   * @remarks
   * The ID of the node where the end node of the edge is located.
   * 
   * This parameter is required.
   * 
   * @example
   * 44***
   */
  nodeEnd?: number;
  /**
   * @remarks
   * The ID of the node where the start node of the edge is located.
   * 
   * This parameter is required.
   * 
   * @example
   * 44***
   */
  nodeFrom?: number;
  static names(): { [key: string]: string } {
    return {
      nodeEnd: 'NodeEnd',
      nodeFrom: 'NodeFrom',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeEnd: 'number',
      nodeFrom: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTaskFlowEdgesResponseBodyEdgeIds extends $tea.Model {
  edgeId?: number[];
  static names(): { [key: string]: string } {
    return {
      edgeId: 'EdgeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      edgeId: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail extends $tea.Model {
  /**
   * @remarks
   * The calculating method. Valid values:
   * 
   * *   **DIRECT**: No function or expression is used.
   * *   **EXPR**: A function or expression is used.
   * 
   * @example
   * DIRECT
   */
  calWay?: string;
  /**
   * @remarks
   * The SQL code snippet for field processing.
   * 
   * @example
   * dmstest.b.id
   */
  code?: string;
  static names(): { [key: string]: string } {
    return {
      calWay: 'CalWay',
      code: 'Code',
    };
  }

  static types(): { [key: string]: any } {
    return {
      calWay: 'string',
      code: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AnalyzeSQLLineageResponseBodyLineageResultLineages extends $tea.Model {
  /**
   * @remarks
   * The target.
   * 
   * @example
   * dmstest.a.id
   */
  dst?: string;
  /**
   * @remarks
   * The type of the lineage. Valid values:
   * 
   * *   **FIELD_DEPEND_FIELD**: Fields depend on fields.
   * *   **TABLE_DEPEND_TABLE**: Tables depend on tables.
   * *   **FIELD_INFLU_TABLE**: Fields influence tables.
   * *   **FIELD_INFLU_FIELD**: Fields influence fields.
   * *   **FIELD_INFLU_TABLE**: Tables influence fields.
   * *   **FIELD_JOIN_FIELD**: Fields are associated with fields.
   * 
   * @example
   * FIELD_DEPEND_FIELD
   */
  lineageType?: string;
  /**
   * @remarks
   * The operation type of the SQL statement in which the data lineage is generated. For example, if the operation type is SELECT, the data lineage is generated from a SELECT statement.
   * 
   * >  This field is an extended field which has no practical use.
   * 
   * @example
   * SELECT
   */
  operType?: string;
  /**
   * @remarks
   * The handling details. This parameter is returned only when LineageType is FIELD_DEPEND_FIELD.
   */
  processDetail?: AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail;
  /**
   * @remarks
   * The source.
   * 
   * @example
   * dmstest.b.id
   */
  src?: string;
  static names(): { [key: string]: string } {
    return {
      dst: 'Dst',
      lineageType: 'LineageType',
      operType: 'OperType',
      processDetail: 'ProcessDetail',
      src: 'Src',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dst: 'string',
      lineageType: 'string',
      operType: 'string',
      processDetail: AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail,
      src: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields extends $tea.Model {
  /**
   * @remarks
   * The name of the field.
   * 
   * @example
   * dmstest.a.id
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata extends $tea.Model {
  /**
   * @remarks
   * The fields in the metatable.
   */
  fields?: AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields[];
  /**
   * @remarks
   * The object name.
   * 
   * @example
   * a
   */
  name?: string;
  /**
   * @remarks
   * The source of metadata. Valid values:
   * 
   * *   **DDL**: The metadata comes from parsed SQL statements or definition of databases and tables collected by DMS.
   * *   **LINEAGE**: The metadata comes from lineage analysis results.
   * 
   * @example
   * DDL
   */
  source?: string;
  /**
   * @remarks
   * The object type. Valid values:
   * 
   * *   **TABLE**
   * *   **VIEW**
   * *   **TMP_TABLE**
   * 
   * @example
   * TABLE
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      fields: 'Fields',
      name: 'Name',
      source: 'Source',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fields: { 'type': 'array', 'itemType': AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields },
      name: 'string',
      source: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AnalyzeSQLLineageResponseBodyLineageResult extends $tea.Model {
  /**
   * @remarks
   * The details about the lineage.
   */
  lineages?: AnalyzeSQLLineageResponseBodyLineageResultLineages[];
  /**
   * @remarks
   * The table and field metadata information.
   */
  objectMetadata?: AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata[];
  static names(): { [key: string]: string } {
    return {
      lineages: 'Lineages',
      objectMetadata: 'ObjectMetadata',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lineages: { 'type': 'array', 'itemType': AnalyzeSQLLineageResponseBodyLineageResultLineages },
      objectMetadata: { 'type': 'array', 'itemType': AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAuthorityTemplateResponseBodyAuthorityTemplateView extends $tea.Model {
  /**
   * @remarks
   * The time when the permission template was created. The time is in the yyyy-MM-DD HH:mm:ss format.
   * 
   * @example
   * 2023-01-11 14:17:33
   */
  createTime?: string;
  /**
   * @remarks
   * The ID of the user who created the permission template.
   * 
   * @example
   * 12***
   */
  creatorId?: number;
  /**
   * @remarks
   * The description of the permission template.
   * 
   * @example
   * This template is used for business testing.
   */
  description?: string;
  /**
   * @remarks
   * The name of the permission template.
   * 
   * @example
   * Test template.
   */
  name?: string;
  /**
   * @remarks
   * The ID of the permission template.
   * 
   * @example
   * 1563
   */
  templateId?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      creatorId: 'CreatorId',
      description: 'Description',
      name: 'Name',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      creatorId: 'number',
      description: 'string',
      name: 'string',
      templateId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataArchiveOrderRequestParamTableIncludes extends $tea.Model {
  /**
   * @remarks
   * The table name.
   * 
   * This parameter is required.
   * 
   * @example
   * table1
   */
  tableName?: string;
  /**
   * @remarks
   * The filter condition that is specified by the WHERE clause of the archiving configuration. If a time variable is used in the filter condition, the filter condition is specified in the following format: field name <=\\"${variable name}\\". The variable name in the filter condition must be the same as the time variable name that is specified in the Variables parameter.
   * 
   * @example
   * gmt_modified<\\"${time}\\"
   */
  tableWhere?: string;
  static names(): { [key: string]: string } {
    return {
      tableName: 'TableName',
      tableWhere: 'TableWhere',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tableName: 'string',
      tableWhere: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataArchiveOrderRequestParamVariables extends $tea.Model {
  name?: string;
  pattern?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      pattern: 'Pattern',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      pattern: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataArchiveOrderRequestParam extends $tea.Model {
  /**
   * @remarks
   * The archiving destination to which you want to archive data. Valid values:
   * 
   * >  If you set ArchiveMethod to a value other than inner_oss, you must register the corresponding destination database with Data Management (DMS) before you create the data archiving ticket. After the database is registered with DMS, the database is displayed in the Instances Connected section of the DMS console.
   * 
   * *   **inner_oss**: dedicated storage, which is a built-in Object Storage Service (OSS) bucket.
   * *   **oss_userself**: OSS bucket of the user.
   * *   **mysql**: ApsaraDB RDS for MySQL instance.
   * *   **polardb**: PolarDB for MySQL cluster.
   * *   **adb_mysql**: AnalyticDB for MySQL V3.0 cluster.
   * *   **lindorm**: Lindorm instance.
   * 
   * This parameter is required.
   * 
   * @example
   * mysql
   */
  archiveMethod?: string;
  /**
   * @remarks
   * A crontab expression that specifies the scheduling cycle of the data archiving task. For more information, see the [Crontab expressions](https://help.aliyun.com/document_detail/206581.html) section of the "Create shadow tables for synchronization" topic. You must specify this parameter if you set RunMethod to schedule.
   * 
   * @example
   * 00 05 11 * * ?
   */
  cronStr?: string;
  /**
   * @remarks
   * The database ID. If the database is a self-managed database or a third-party cloud database, you can call the [GetDatabase](https://help.aliyun.com/document_detail/465856.html) operation to query the database ID. If the database is an Alibaba Cloud database, ignore this parameter.
   * 
   * @example
   * 1***
   */
  databaseId?: string;
  /**
   * @remarks
   * Specifies whether the database is a logical database.
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The post behaviors.
   */
  orderAfter?: string[];
  /**
   * @remarks
   * The method that is used to run the data archiving task. Valid values:
   * 
   * *   **schedule**: The data archiving task is periodically scheduled.
   * *   **now**: The data archiving task is immediately run.
   * 
   * This parameter is required.
   * 
   * @example
   * now
   */
  runMethod?: string;
  /**
   * @remarks
   * The catalog of the source database. Valid values:
   * 
   * *   **def**: Set this parameter to def if the source database is of the two-layer logical schema, such as a MySQL database, a PolarDB for MySQL cluster, or an AnalyticDB for MySQL instance.
   * *   **Empty string**: Set this parameter to an empty string if the source database is a Lindorm or ApsaraDB for MongoDB instance.
   * *   **Catalog name**: Set this parameter to the catalog name of the source database if the source database is of the three-layer logical schema, such as a PostgreSQL database.
   * 
   * This parameter is required.
   * 
   * @example
   * def
   */
  sourceCatalogName?: string;
  /**
   * @remarks
   * The name of the source instance. If the database instance is a self-managed database or a third-party cloud database, you can call the [GetInstance](https://help.aliyun.com/document_detail/465826.html) operation to query the instance ID.
   * 
   * This parameter is required.
   * 
   * @example
   * pc-bp1*******
   */
  sourceInstanceName?: string;
  /**
   * @remarks
   * The schema name of the source database. The schema name of the source database is the same as that of the destination database. If the source database is a MySQL database, this parameter specifies the name of the source database. If the source database is a PostgreSQL database, this parameter specifies the schema name of the source database.
   * 
   * This parameter is required.
   * 
   * @example
   * schema_test
   */
  sourceSchemaName?: string;
  /**
   * @remarks
   * The collection of tables to be archived.
   * 
   * This parameter is required.
   */
  tableIncludes?: CreateDataArchiveOrderRequestParamTableIncludes[];
  /**
   * @remarks
   * The table names mapped to the destination database. This parameter is not required and the default value is used.
   */
  tableMapping?: string[];
  /**
   * @remarks
   * The host of the destination instance. If the destination instance can be accessed over an internal network or the Internet, preferentially set the value to the internal endpoint of the destination instance.
   * 
   * *   If data is archived in an OSS bucket, set the value to the name of the bucket.
   * *   If data is archived in dedicated storage space, set the value to inner_oss.
   * 
   * This parameter is required.
   * 
   * @example
   * am-bp1*********.ads.aliyuncs.com
   */
  targetInstanceHost?: string;
  /**
   * @remarks
   * The configuration of archiving variables. You can use a time variable as a filter condition for archiving data. Each variable has two attributes: name and pattern.
   */
  variables?: CreateDataArchiveOrderRequestParamVariables[];
  static names(): { [key: string]: string } {
    return {
      archiveMethod: 'ArchiveMethod',
      cronStr: 'CronStr',
      databaseId: 'DatabaseId',
      logic: 'Logic',
      orderAfter: 'OrderAfter',
      runMethod: 'RunMethod',
      sourceCatalogName: 'SourceCatalogName',
      sourceInstanceName: 'SourceInstanceName',
      sourceSchemaName: 'SourceSchemaName',
      tableIncludes: 'TableIncludes',
      tableMapping: 'TableMapping',
      targetInstanceHost: 'TargetInstanceHost',
      variables: 'Variables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      archiveMethod: 'string',
      cronStr: 'string',
      databaseId: 'string',
      logic: 'boolean',
      orderAfter: { 'type': 'array', 'itemType': 'string' },
      runMethod: 'string',
      sourceCatalogName: 'string',
      sourceInstanceName: 'string',
      sourceSchemaName: 'string',
      tableIncludes: { 'type': 'array', 'itemType': CreateDataArchiveOrderRequestParamTableIncludes },
      tableMapping: { 'type': 'array', 'itemType': 'string' },
      targetInstanceHost: 'string',
      variables: { 'type': 'array', 'itemType': CreateDataArchiveOrderRequestParamVariables },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataCorrectOrderRequestParamDbItemList extends $tea.Model {
  /**
   * @remarks
   * The ID of the database. The database can be a physical database or a logical database.
   * 
   * *   To obtain the ID of a physical database, call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation.
   * *   To obtain the ID of a logical database, call the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1860****
   */
  dbId?: number;
  /**
   * @remarks
   * Specifies whether the database is a logical database. Valid values:
   * 
   * *   **true**: The database is a logical database.
   * *   **false**: The database is a physical database.
   * 
   * This parameter is required.
   * 
   * @example
   * false
   */
  logic?: boolean;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      logic: 'Logic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      logic: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataCorrectOrderRequestParam extends $tea.Model {
  /**
   * @remarks
   * The key of the attachment that contains the SQL statements used to change data. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to obtain the attachment key from the value of the AttachmentKey parameter.
   * 
   * >  This parameter is required if you set the **SqlType** parameter to **ATTACHMENT**.
   * 
   * @example
   * test.sql
   */
  attachmentName?: string;
  /**
   * @remarks
   * The reason for the data change.
   * 
   * @example
   * test
   */
  classify?: string;
  /**
   * @remarks
   * The databases in which you want to change data.
   * 
   * This parameter is required.
   */
  dbItemList?: CreateDataCorrectOrderRequestParamDbItemList[];
  /**
   * @remarks
   * The estimated number of data rows to be affected by the data change.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  estimateAffectRows?: number;
  /**
   * @remarks
   * The execution mode of the ticket after the ticket is approved. Valid values:
   * 
   * *   **COMMITOR**: The data change is performed by the user who submits the ticket.
   * *   **AUTO**: The data change is automatically performed after the ticket is approved.
   * *   **LAST_AUDITOR**: The data change is performed by the last approver of the ticket.
   * 
   * @example
   * COMMITOR
   */
  execMode?: string;
  /**
   * @remarks
   * The SQL statements that you want to execute to change data.
   * 
   * >  This parameter is required if you set the **SqlType** parameter to **TEXT**.
   * 
   * @example
   * update base_user set id = 1 where id  = 1;
   */
  execSQL?: string;
  /**
   * @remarks
   * The key of the attachment that contains the SQL statements used to roll back the data change. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to the attachment key from the value of the AttachmentKey parameter.
   * 
   * >  This parameter is required if you set the **RollbackSqlType** parameter to **ATTACHMENT**.
   * 
   * @example
   * test_rollback.sql
   */
  rollbackAttachmentName?: string;
  /**
   * @remarks
   * The SQL statements used to roll back the data change.
   * 
   * > This parameter is required if you set the **RollbackSqlType** parameter to **TEXT**.
   * 
   * @example
   * update base_user set id = 1 where id  = 1;
   */
  rollbackSQL?: string;
  /**
   * @remarks
   * The format of the SQL statements used to roll back the data change. Valid values:
   * 
   * *   **TEXT**: text
   * *   **ATTACHMENT**: attachment
   * 
   * @example
   * TEXT
   */
  rollbackSqlType?: string;
  /**
   * @remarks
   * The format of the SQL statements used to change data. Valid values:
   * 
   * *   **TEXT**: text
   * *   **ATTACHMENT**: attachment
   * 
   * This parameter is required.
   * 
   * @example
   * TEXT
   */
  sqlType?: string;
  static names(): { [key: string]: string } {
    return {
      attachmentName: 'AttachmentName',
      classify: 'Classify',
      dbItemList: 'DbItemList',
      estimateAffectRows: 'EstimateAffectRows',
      execMode: 'ExecMode',
      execSQL: 'ExecSQL',
      rollbackAttachmentName: 'RollbackAttachmentName',
      rollbackSQL: 'RollbackSQL',
      rollbackSqlType: 'RollbackSqlType',
      sqlType: 'SqlType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentName: 'string',
      classify: 'string',
      dbItemList: { 'type': 'array', 'itemType': CreateDataCorrectOrderRequestParamDbItemList },
      estimateAffectRows: 'number',
      execMode: 'string',
      execSQL: 'string',
      rollbackAttachmentName: 'string',
      rollbackSQL: 'string',
      rollbackSqlType: 'string',
      sqlType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataCronClearOrderRequestParamCronClearItemList extends $tea.Model {
  /**
   * @remarks
   * The name of the field.
   * 
   * This parameter is required.
   * 
   * @example
   * gmt_create
   */
  columnName?: string;
  /**
   * @remarks
   * The filter conditions.
   * 
   * @example
   * where 1 = 1
   */
  filterSQL?: string;
  /**
   * @remarks
   * The retention period of the historical data. Unit: days. For example, if you set the parameter to 7, DMS deletes the data that is retained for more than seven days.
   * 
   * This parameter is required.
   * 
   * @example
   * 7
   */
  remainDays?: number;
  /**
   * @remarks
   * The name of the table. You can call the [ListTables](https://help.aliyun.com/document_detail/141878.html) operation to query the name of the table.
   * 
   * This parameter is required.
   * 
   * @example
   * t1
   */
  tableName?: string;
  /**
   * @remarks
   * The type of time granularity. If the ColumnName parameter specifies a field of a time type, this parameter is required. Valid values:
   * 
   * *   **MILLISECONDS**: milliseconds
   * *   **SECONDS**: seconds
   * 
   * @example
   * MILLISECONDS
   */
  timeUnit?: string;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      filterSQL: 'FilterSQL',
      remainDays: 'RemainDays',
      tableName: 'TableName',
      timeUnit: 'TimeUnit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      filterSQL: 'string',
      remainDays: 'number',
      tableName: 'string',
      timeUnit: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataCronClearOrderRequestParamDbItemList extends $tea.Model {
  /**
   * @remarks
   * The ID of the database. You can call the [SearchDatabases](https://help.aliyun.com/document_detail/141876.html) operation to query the ID of the database.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  dbId?: number;
  /**
   * @remarks
   * Indicates whether the database is a logical database. Valid values:
   * 
   * *   **true**: The database is a logical database.
   * *   **false**: The database is not a logical database.
   * 
   * This parameter is required.
   * 
   * @example
   * false
   */
  logic?: boolean;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      logic: 'Logic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      logic: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataCronClearOrderRequestParam extends $tea.Model {
  /**
   * @remarks
   * The reason for the data change.
   * 
   * @example
   * test
   */
  classify?: string;
  /**
   * @remarks
   * The tables for which you want to clear historical data.
   * 
   * This parameter is required.
   */
  cronClearItemList?: CreateDataCronClearOrderRequestParamCronClearItemList[];
  /**
   * @remarks
   * The crontab expression that you can use to run the task at a specified time. For more information, see [Crontab expression](https://help.aliyun.com/document_detail/206581.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 0 0 2 * * ?
   */
  cronFormat?: string;
  /**
   * @remarks
   * The databases for which you want to clear historical data.
   * 
   * This parameter is required.
   */
  dbItemList?: CreateDataCronClearOrderRequestParamDbItemList[];
  /**
   * @remarks
   * The amount of time taken to run the task. Unit: hours.
   * 
   * >  If the **specifyDuration** parameter is set to **true**, this parameter is required.
   * 
   * @example
   * 4
   */
  durationHour?: number;
  /**
   * @remarks
   * Specifies whether to specify an end time for the task. Valid values:
   * 
   * *   **true**: specifies an end time for the task. The task is automatically suspended after this end time.
   * *   **false**: does not specify an end time for the task. The task is stopped after the historical data is cleared.
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  specifyDuration?: boolean;
  static names(): { [key: string]: string } {
    return {
      classify: 'Classify',
      cronClearItemList: 'CronClearItemList',
      cronFormat: 'CronFormat',
      dbItemList: 'DbItemList',
      durationHour: 'DurationHour',
      specifyDuration: 'specifyDuration',
    };
  }

  static types(): { [key: string]: any } {
    return {
      classify: 'string',
      cronClearItemList: { 'type': 'array', 'itemType': CreateDataCronClearOrderRequestParamCronClearItemList },
      cronFormat: 'string',
      dbItemList: { 'type': 'array', 'itemType': CreateDataCronClearOrderRequestParamDbItemList },
      durationHour: 'number',
      specifyDuration: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataExportOrderRequestPluginParamWatermark extends $tea.Model {
  /**
   * @remarks
   * The field into which the watermark is to be embedded.
   * 
   * @example
   * user_number
   */
  columnName?: string;
  /**
   * @remarks
   * The information to be embedded as a watermark into data.
   * 
   * @example
   * test
   */
  dataWatermark?: string;
  /**
   * @remarks
   * The information to be embedded as a watermark into files.
   * 
   * @example
   * test
   */
  fileWatermark?: string;
  /**
   * @remarks
   * One or more primary keys or unique keys.
   */
  keys?: string[];
  /**
   * @remarks
   * The methods in which the watermark is embedded.
   */
  watermarkTypes?: string[];
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      dataWatermark: 'DataWatermark',
      fileWatermark: 'FileWatermark',
      keys: 'Keys',
      watermarkTypes: 'WatermarkTypes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      dataWatermark: 'string',
      fileWatermark: 'string',
      keys: { 'type': 'array', 'itemType': 'string' },
      watermarkTypes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataExportOrderRequestPluginParam extends $tea.Model {
  /**
   * @remarks
   * The estimated number of data rows to be affected.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  affectRows?: number;
  /**
   * @remarks
   * The reason for the export ticket.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  classify?: string;
  /**
   * @remarks
   * The database ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 18****
   */
  dbId?: number;
  /**
   * @remarks
   * The SQL statements that can be executed.
   * 
   * This parameter is required.
   * 
   * @example
   * SELECT * FROM DMS_test
   *  LIMIT 20;
   */
  exeSQL?: string;
  /**
   * @remarks
   * Specifies whether to skip verification. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  ignoreAffectRows?: boolean;
  /**
   * @remarks
   * The reason for skipping verification. This parameter is required if you set IgnoreAffectRows to true.
   * 
   * @example
   * Test only, does not affect the business, and does not require verification.
   */
  ignoreAffectRowsReason?: string;
  /**
   * @remarks
   * The instance ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 132****
   */
  instanceId?: number;
  /**
   * @remarks
   * Specifies whether the database is a logical database. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * > If you set this parameter to **true**, the database that you specify must be a logical database.
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  logic?: boolean;
  /**
   * @remarks
   * The information about the watermarks.
   */
  watermark?: CreateDataExportOrderRequestPluginParamWatermark;
  static names(): { [key: string]: string } {
    return {
      affectRows: 'AffectRows',
      classify: 'Classify',
      dbId: 'DbId',
      exeSQL: 'ExeSQL',
      ignoreAffectRows: 'IgnoreAffectRows',
      ignoreAffectRowsReason: 'IgnoreAffectRowsReason',
      instanceId: 'InstanceId',
      logic: 'Logic',
      watermark: 'Watermark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affectRows: 'number',
      classify: 'string',
      dbId: 'number',
      exeSQL: 'string',
      ignoreAffectRows: 'boolean',
      ignoreAffectRowsReason: 'string',
      instanceId: 'number',
      logic: 'boolean',
      watermark: CreateDataExportOrderRequestPluginParamWatermark,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataExportOrderResponseBodyCreateOrderResult extends $tea.Model {
  createOrderResult?: number[];
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataImportOrderRequestParamDbItemList extends $tea.Model {
  /**
   * @remarks
   * The ID of the database. The database can be a physical database or a logical database.
   * 
   * *   To obtain the ID of a physical database, call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation.
   * *   To obtain the ID of a logical database, call the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1860****
   */
  dbId?: number;
  /**
   * @remarks
   * Specifies whether the database is a logical database. Valid values:
   * 
   * *   **true**: The database is a logical database.
   * *   **false**: The database is a physical database.
   * 
   * >  If you set this parameter to **true**, the database that you specify must be a logical database.
   * 
   * This parameter is required.
   * 
   * @example
   * false
   */
  logic?: boolean;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      logic: 'Logic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      logic: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataImportOrderRequestParam extends $tea.Model {
  /**
   * @remarks
   * The key of the attachment that contains the SQL statements used to import data. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to the attachment key from the value of the AttachmentKey parameter.
   * 
   * This parameter is required.
   * 
   * @example
   * order_text
   */
  attachmentName?: string;
  /**
   * @remarks
   * The reason for the data import.
   * 
   * @example
   * test
   */
  classify?: string;
  /**
   * @remarks
   * The type of the CSV file. Valid values:
   * 
   * *   **true**: The first row in the CSV file contains field names.
   * *   **false**: The first row in the CSV file contains data.
   * 
   * >  This parameter is required if you set the **FileType** parameter to **CSV**.
   * 
   * @example
   * true
   */
  csvFirstRowIsColumnDef?: boolean;
  /**
   * @remarks
   * The database to which you want to import data. You can specify only one database.
   * 
   * This parameter is required.
   */
  dbItemList?: CreateDataImportOrderRequestParamDbItemList[];
  /**
   * @remarks
   * The encoding algorithm to be used by the destination database. Valid values:
   * 
   * *   **AUTO**: automatic identification
   * *   **UTF-8**: UTF-8 encoding
   * *   **GBK**: GBK encoding
   * *   **ISO-8859-1**: ISO-8859-1 encoding
   * 
   * @example
   * AUTO
   */
  fileEncoding?: string;
  /**
   * @remarks
   * The format of the file for the data import. Valid values:
   * 
   * *   **SQL**: an SQL file
   * *   **CSV**: a CSV file
   * 
   * This parameter is required.
   * 
   * @example
   * CSV
   */
  fileType?: string;
  /**
   * @remarks
   * Specifies whether to skip an error that occurs. Valid values:
   * 
   * *   **true**: skips the error and continues to execute SQL statements.
   * *   **false**: stops executing SQL statements.
   * 
   * @example
   * false
   */
  ignoreError?: boolean;
  /**
   * @remarks
   * The import mode. Valid values:
   * 
   * *   **FAST_MODE**: In the Execute step, the uploaded file is read and SQL statements are executed to import data to the specified destination database. Compared with the security mode, this mode can be used to import data in a less secure but more efficient manner.
   * *   **SAFE_MODE**: In the Precheck step, the uploaded file is parsed, and SQL statements or CSV file data is cached. In the Execute step, the cached SQL statements are read and executed to import data, or the cached CSV file data is read and imported to the specified destination database. This mode can be used to import data in a more secure but less efficient manner.
   * 
   * @example
   * FAST_MODE
   */
  importMode?: string;
  /**
   * @remarks
   * The mode in which the data in the CSV format is to be written to the destination table. Valid values:
   * 
   * *   **INSERT**: The database checks the primary key when data is written. If a duplicate primary key value exists, an error message is returned.
   * *   **INSERT_IGNORE**: If the imported data contains data records that are the same as those in the destination table, the new data records are ignored.
   * *   **REPLACE_INTO**: If the imported data contains a row that has the same value for the primary key or unique index as one row in the destination table, the database deletes the existing row and inserts the new row into the destination table.
   * 
   * >  This parameter is required if you set the **FileType** parameter to **CSV**.
   * 
   * @example
   * INSERT
   */
  insertType?: string;
  /**
   * @remarks
   * The key of the attachment that contains the SQL statements used to roll back the data import. You can call the [GetUserUploadFileJob](https://help.aliyun.com/document_detail/206069.html) operation to obtain the attachment key from the value of the AttachmentKey parameter.
   * 
   * >  This parameter is required if you set the **RollbackSqlType** parameter to **ATTACHMENT**.
   * 
   * @example
   * rollback.sql
   */
  rollbackAttachmentName?: string;
  /**
   * @remarks
   * The SQL statements used to roll back the data import.
   * 
   * >  This parameter is required if you set the **RollbackSqlType** parameter to **TEXT**.
   * 
   * @example
   * empty
   */
  rollbackSQL?: string;
  /**
   * @remarks
   * The format of the SQL statements used to roll back the data import. Valid values:
   * 
   * *   **TEXT**: text
   * *   **ATTACHMENT**: attachment
   * 
   * @example
   * TEXT
   */
  rollbackSqlType?: string;
  /**
   * @remarks
   * The destination table to which you want to import the data in the CSV format.
   * 
   * >  This parameter is required if you set the **FileType** parameter to **CSV**.
   * 
   * @example
   * Table_text
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      attachmentName: 'AttachmentName',
      classify: 'Classify',
      csvFirstRowIsColumnDef: 'CsvFirstRowIsColumnDef',
      dbItemList: 'DbItemList',
      fileEncoding: 'FileEncoding',
      fileType: 'FileType',
      ignoreError: 'IgnoreError',
      importMode: 'ImportMode',
      insertType: 'InsertType',
      rollbackAttachmentName: 'RollbackAttachmentName',
      rollbackSQL: 'RollbackSQL',
      rollbackSqlType: 'RollbackSqlType',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentName: 'string',
      classify: 'string',
      csvFirstRowIsColumnDef: 'boolean',
      dbItemList: { 'type': 'array', 'itemType': CreateDataImportOrderRequestParamDbItemList },
      fileEncoding: 'string',
      fileType: 'string',
      ignoreError: 'boolean',
      importMode: 'string',
      insertType: 'string',
      rollbackAttachmentName: 'string',
      rollbackSQL: 'string',
      rollbackSqlType: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataTrackOrderRequestParam extends $tea.Model {
  /**
   * @remarks
   * The ID of the database. You can call the [SearchDatabases](https://help.aliyun.com/document_detail/141876.html) operation to query the ID of the database.
   * 
   * > You can call this operation to create a data tracking ticket for only physical databases. This operation is not applicable to logical databases.
   * 
   * This parameter is required.
   * 
   * @example
   * 123***
   */
  dbId?: string;
  /**
   * @remarks
   * The end time of the time range in which you want to track data operations. The time must be in the yyyy-MM-dd HH:mm:ss format.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-23 10:00:00
   */
  jobEndTime?: string;
  /**
   * @remarks
   * The start time of the time range in which you want to track data operations. The time must be in the yyyy-MM-dd HH:mm:ss format.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-23 00:00:00
   */
  jobStartTime?: string;
  /**
   * @remarks
   * The names of the tables for which you want to track data operations.
   * 
   * This parameter is required.
   */
  tableNames?: string[];
  /**
   * @remarks
   * The types of data operations that you want to track.
   * 
   * This parameter is required.
   */
  trackTypes?: string[];
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      jobEndTime: 'JobEndTime',
      jobStartTime: 'JobStartTime',
      tableNames: 'TableNames',
      trackTypes: 'TrackTypes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'string',
      jobEndTime: 'string',
      jobStartTime: 'string',
      tableNames: { 'type': 'array', 'itemType': 'string' },
      trackTypes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDatabaseExportOrderRequestPluginParamConfig extends $tea.Model {
  /**
   * @remarks
   * The export options for big data. The options are used to filter the big data to be exported. You can leave this parameter empty.
   * 
   * This parameter is required.
   */
  dataOption?: string[];
  /**
   * @remarks
   * The type of data that you want to export. Valid values:
   * 
   * *   **DATA**: The data of the database is exported.
   * *   **STRUCT**: The schema of the database is exported.
   * *   **DATA_STRUCT**: The data and schema of the database are exported.
   * 
   * This parameter is required.
   * 
   * @example
   * DATA
   */
  exportContent?: string;
  /**
   * @remarks
   * The types of schemas that you want to export.
   */
  exportTypes?: string[];
  /**
   * @remarks
   * The extension options of the SQL script. You can leave this parameter empty.
   * 
   * This parameter is required.
   */
  SQLExtOption?: string[];
  /**
   * @remarks
   * The tables that you want to export.
   */
  selectedTables?: string[];
  /**
   * @remarks
   * The conditions used to filter the tables to be exported.
   */
  tables?: { [key: string]: string };
  /**
   * @remarks
   * The format in which the database is exported. Valid values:
   * 
   * *   **SQL**
   * *   **CSV**
   * *   **XLSX**
   * 
   * This parameter is required.
   * 
   * @example
   * SQL
   */
  targetOption?: string;
  static names(): { [key: string]: string } {
    return {
      dataOption: 'DataOption',
      exportContent: 'ExportContent',
      exportTypes: 'ExportTypes',
      SQLExtOption: 'SQLExtOption',
      selectedTables: 'SelectedTables',
      tables: 'Tables',
      targetOption: 'TargetOption',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataOption: { 'type': 'array', 'itemType': 'string' },
      exportContent: 'string',
      exportTypes: { 'type': 'array', 'itemType': 'string' },
      SQLExtOption: { 'type': 'array', 'itemType': 'string' },
      selectedTables: { 'type': 'array', 'itemType': 'string' },
      tables: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      targetOption: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDatabaseExportOrderRequestPluginParam extends $tea.Model {
  /**
   * @remarks
   * The reason for the database export.
   * 
   * This parameter is required.
   * 
   * @example
   * document_test
   */
  classify?: string;
  /**
   * @remarks
   * The configurations for database export.
   * 
   * This parameter is required.
   */
  config?: CreateDatabaseExportOrderRequestPluginParamConfig;
  /**
   * @remarks
   * The database ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 17****
   */
  dbId?: number;
  /**
   * @remarks
   * The instance ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 137****
   */
  instanceId?: number;
  /**
   * @remarks
   * Specifies whether the database is a logical database. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  logic?: boolean;
  /**
   * @remarks
   * The name that is used to search for the database.
   * 
   * This parameter is required.
   * 
   * @example
   * test@xxx.xxx.xxx.xxx:3306
   */
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      classify: 'Classify',
      config: 'Config',
      dbId: 'DbId',
      instanceId: 'InstanceId',
      logic: 'Logic',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      classify: 'string',
      config: CreateDatabaseExportOrderRequestPluginParamConfig,
      dbId: 'number',
      instanceId: 'number',
      logic: 'boolean',
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDatabaseExportOrderResponseBodyCreateOrderResult extends $tea.Model {
  createOrderResult?: number[];
  static names(): { [key: string]: string } {
    return {
      createOrderResult: 'CreateOrderResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createOrderResult: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFreeLockCorrectOrderRequestParamDbItemList extends $tea.Model {
  /**
   * @remarks
   * The ID of the database. The database can be a physical database or a logical database.
   * 
   * *   To obtain the ID of a physical database, call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation.
   * *   To obtain the ID of a logical database, call the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) or [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1860****
   */
  dbId?: number;
  /**
   * @remarks
   * Specifies whether the database is a logical database. Valid values:
   * 
   * *   **true**: The database is a logical database.
   * *   **false**: The database is a physical database.
   * 
   * This parameter is required.
   * 
   * @example
   * false
   */
  logic?: boolean;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      logic: 'Logic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      logic: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFreeLockCorrectOrderRequestParam extends $tea.Model {
  /**
   * @remarks
   * The key of the attachment that contains the SQL statements used to change data. This parameter is not supported.
   * 
   * @example
   * test.sql
   */
  attachmentName?: string;
  /**
   * @remarks
   * The reason for the data change.
   * 
   * @example
   * test
   */
  classify?: string;
  /**
   * @remarks
   * The databases in which you want to change data.
   * 
   * This parameter is required.
   */
  dbItemList?: CreateFreeLockCorrectOrderRequestParamDbItemList[];
  /**
   * @remarks
   * The execution mode of the ticket after the ticket is approved. Valid values:
   * 
   * *   **COMMITOR**: The data change is performed by the user who submits the ticket.
   * *   **AUTO**: The data change is automatically performed after the ticket is approved.
   * *   **LAST_AUDITOR**: The data change is performed by the last approver of the ticket.
   * 
   * @example
   * COMMITOR
   */
  execMode?: string;
  /**
   * @remarks
   * The SQL statements that you want to execute to change data.
   * 
   * This parameter is required.
   * 
   * @example
   * delete from base_user where 1 = 1;
   */
  execSQL?: string;
  /**
   * @remarks
   * The key of the attachment that contains the SQL statements used to roll back the data change.
   * 
   * @example
   * test_rollback.sql
   */
  rollbackAttachmentName?: string;
  /**
   * @remarks
   * The SQL statements used to roll back the data change.
   * 
   * @example
   * empty
   */
  rollbackSQL?: string;
  /**
   * @remarks
   * The format of the SQL statements used to roll back the data change. Valid values:
   * 
   * *   **TEXT**: text
   * *   **ATTACHMENT**: attachment. This value is not supported.
   * 
   * @example
   * TEXT
   */
  rollbackSqlType?: string;
  /**
   * @remarks
   * The format of the SQL statements used to change data. Valid values:
   * 
   * *   **TEXT**: text
   * *   **ATTACHMENT**: attachment. This value is not supported.
   * 
   * This parameter is required.
   * 
   * @example
   * TEXT
   */
  sqlType?: string;
  static names(): { [key: string]: string } {
    return {
      attachmentName: 'AttachmentName',
      classify: 'Classify',
      dbItemList: 'DbItemList',
      execMode: 'ExecMode',
      execSQL: 'ExecSQL',
      rollbackAttachmentName: 'RollbackAttachmentName',
      rollbackSQL: 'RollbackSQL',
      rollbackSqlType: 'RollbackSqlType',
      sqlType: 'SqlType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentName: 'string',
      classify: 'string',
      dbItemList: { 'type': 'array', 'itemType': CreateFreeLockCorrectOrderRequestParamDbItemList },
      execMode: 'string',
      execSQL: 'string',
      rollbackAttachmentName: 'string',
      rollbackSQL: 'string',
      rollbackSqlType: 'string',
      sqlType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrderResponseBodyCreateOrderResult extends $tea.Model {
  orderIds?: number[];
  static names(): { [key: string]: string } {
    return {
      orderIds: 'OrderIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderIds: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProcCorrectOrderRequestParamDbItemList extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 19721978
   */
  dbId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * false
   */
  logic?: boolean;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      logic: 'Logic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      logic: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProcCorrectOrderRequestParam extends $tea.Model {
  /**
   * @example
   * test
   */
  classify?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  dbItemList?: CreateProcCorrectOrderRequestParamDbItemList[];
  execMode?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * DELIMITER ///
   * CREATE PROCEDURE GetAllProducts()
   * BEGIN
   * SELECT *  FROM base_user;
   * END ///
   */
  execSQL?: string;
  /**
   * @example
   * test_rollback.sql
   */
  rollbackAttachmentName?: string;
  /**
   * @example
   * empty
   */
  rollbackSQL?: string;
  /**
   * @example
   * TEXT
   */
  rollbackSqlType?: string;
  static names(): { [key: string]: string } {
    return {
      classify: 'Classify',
      dbItemList: 'DbItemList',
      execMode: 'ExecMode',
      execSQL: 'ExecSQL',
      rollbackAttachmentName: 'RollbackAttachmentName',
      rollbackSQL: 'RollbackSQL',
      rollbackSqlType: 'RollbackSqlType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      classify: 'string',
      dbItemList: { 'type': 'array', 'itemType': CreateProcCorrectOrderRequestParamDbItemList },
      execMode: 'string',
      execSQL: 'string',
      rollbackAttachmentName: 'string',
      rollbackSQL: 'string',
      rollbackSqlType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSQLReviewOrderRequestParam extends $tea.Model {
  /**
   * @remarks
   * The files to be reviewed. Multiple files can be reviewed at a time.
   * 
   * This parameter is required.
   */
  attachmentKeyList?: string[];
  /**
   * @remarks
   * The ID of the database. You can call the [SearchDatabases](https://help.aliyun.com/document_detail/141876.html) operation to query the ID of the database.
   * 
   * >  You can call this operation to query only physical databases. This operation is unavailable to query logical databases.
   * 
   * This parameter is required.
   * 
   * @example
   * 123321
   */
  dbId?: number;
  /**
   * @remarks
   * The name of the project.
   * 
   * This parameter is required.
   * 
   * @example
   * SQL review for xxx
   */
  projectName?: string;
  static names(): { [key: string]: string } {
    return {
      attachmentKeyList: 'AttachmentKeyList',
      dbId: 'DbId',
      projectName: 'ProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKeyList: { 'type': 'array', 'itemType': 'string' },
      dbId: 'number',
      projectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStandardGroupResponseBodyStandardGroup extends $tea.Model {
  /**
   * @remarks
   * The type of the database engine. For more information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
   * 
   * @example
   * mysql
   */
  dbType?: string;
  /**
   * @remarks
   * The description of the security rule set.
   * 
   * @example
   * test_rule
   */
  description?: string;
  /**
   * @remarks
   * The security rule set ID.
   * 
   * @example
   * 41****
   */
  groupId?: number;
  /**
   * @remarks
   * The control mode. Valid values:
   * 
   * *   **NONE_CONTROL**: Flexible Management
   * *   **STABLE**: Stable Change
   * *   **COMMON**: Security Collaboration
   * 
   * @example
   * COMMON
   */
  groupMode?: string;
  /**
   * @remarks
   * The name of the security rule set.
   * 
   * @example
   * test_group
   */
  groupName?: string;
  /**
   * @remarks
   * The ID of the user who creates the security rule set.
   * 
   * @example
   * 51****
   */
  lastMenderId?: number;
  static names(): { [key: string]: string } {
    return {
      dbType: 'DbType',
      description: 'Description',
      groupId: 'GroupId',
      groupMode: 'GroupMode',
      groupName: 'GroupName',
      lastMenderId: 'LastMenderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbType: 'string',
      description: 'string',
      groupId: 'number',
      groupMode: 'string',
      groupName: 'string',
      lastMenderId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStructSyncOrderRequestParamSource extends $tea.Model {
  /**
   * @remarks
   * The ID of the database. You can call the [SearchDatabases](https://help.aliyun.com/document_detail/141876.html) operation to query the ID of the database.
   * 
   * This parameter is required.
   * 
   * @example
   * 4324532
   */
  dbId?: number;
  /**
   * @remarks
   * The name that is used to search for the database. You can call the [SearchDatabases](https://help.aliyun.com/document_detail/141876.html) operation to query the name of the database.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  dbSearchName?: string;
  /**
   * @remarks
   * Specifies whether the database is a logical database. Valid values:
   * 
   * *   **true**: The database is a logical database.
   * *   **false**: The database is not a logical database.
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The version number of the schema. The default value is the latest schema version number. For more information, see [Manage schema versions](https://help.aliyun.com/document_detail/202275.html).
   * 
   * @example
   * e179bbb8163dcdcfacda24858bedb4d8006ae2b8
   */
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      dbSearchName: 'DbSearchName',
      logic: 'Logic',
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      dbSearchName: 'string',
      logic: 'boolean',
      versionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStructSyncOrderRequestParamTableInfoList extends $tea.Model {
  /**
   * @remarks
   * The name of the source table.
   * 
   * @example
   * test_tbl
   */
  sourceTableName?: string;
  /**
   * @remarks
   * The name of the destination table.
   * 
   * @example
   * test_tbl
   */
  targetTableName?: string;
  static names(): { [key: string]: string } {
    return {
      sourceTableName: 'SourceTableName',
      targetTableName: 'TargetTableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sourceTableName: 'string',
      targetTableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStructSyncOrderRequestParamTarget extends $tea.Model {
  /**
   * @remarks
   * The ID of the database. You can call the [SearchDatabases](https://help.aliyun.com/document_detail/141876.html) operation to query the ID of the database.
   * 
   * This parameter is required.
   * 
   * @example
   * 432432
   */
  dbId?: number;
  /**
   * @remarks
   * The name that is used to search for the database. You can call the [SearchDatabases](https://help.aliyun.com/document_detail/141876.html) operation to query the name of the database.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  dbSearchName?: string;
  /**
   * @remarks
   * Specifies whether the database is a logical database. Valid values:
   * 
   * *   **true**: The database is a logical database.
   * *   **false**: The database is not a logical database.
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The version number. By default, this parameter is left empty.
   * 
   * >  If you specify the schema version number of the destination database, Data Management (DMS) only compares the schemas of the two databases.
   * 
   * @example
   * e179bbb8163dcdcfacda24858bedb4d8006ae2b8
   */
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      dbSearchName: 'DbSearchName',
      logic: 'Logic',
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      dbSearchName: 'string',
      logic: 'boolean',
      versionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateStructSyncOrderRequestParam extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to skip an error that occurs in executing an SQL statement. Valid values:
   * 
   * *   **true**: continues to execute subsequent SQL statements if an error occurs in executing an SQL statement.
   * *   **false**: stops executing subsequent SQL statements if an error occurs in executing an SQL statement.
   * 
   * @example
   * false
   */
  ignoreError?: boolean;
  /**
   * @remarks
   * The information about the base database.
   * 
   * This parameter is required.
   */
  source?: CreateStructSyncOrderRequestParamSource;
  /**
   * @remarks
   * The information about the table of which you want to synchronize the schema.
   */
  tableInfoList?: CreateStructSyncOrderRequestParamTableInfoList[];
  /**
   * @remarks
   * The information about the database to which you want to synchronize the schema of a table.
   * 
   * This parameter is required.
   */
  target?: CreateStructSyncOrderRequestParamTarget;
  static names(): { [key: string]: string } {
    return {
      ignoreError: 'IgnoreError',
      source: 'Source',
      tableInfoList: 'TableInfoList',
      target: 'Target',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ignoreError: 'boolean',
      source: CreateStructSyncOrderRequestParamSource,
      tableInfoList: { 'type': 'array', 'itemType': CreateStructSyncOrderRequestParamTableInfoList },
      target: CreateStructSyncOrderRequestParamTarget,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUploadOSSFileJobRequestUploadTarget extends $tea.Model {
  /**
   * @remarks
   * The name of the OSS bucket.
   * 
   * This parameter is required.
   * 
   * @example
   * test_bucket
   */
  bucketName?: string;
  /**
   * @remarks
   * The endpoint of the OSS bucket.
   * 
   * This parameter is required.
   * 
   * @example
   * http://oss-cn-hangzhou.aliyuncs.com
   */
  endpoint?: string;
  /**
   * @remarks
   * The name of the OSS object.
   * 
   * This parameter is required.
   * 
   * @example
   * test.sql
   */
  objectName?: string;
  static names(): { [key: string]: string } {
    return {
      bucketName: 'BucketName',
      endpoint: 'Endpoint',
      objectName: 'ObjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bucketName: 'string',
      endpoint: 'string',
      objectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadDataTrackResultRequestColumnFilter extends $tea.Model {
  /**
   * @remarks
   * The end value of the range used in the filter condition. This parameter takes effect only when Operator is set to BETWEEN.
   * 
   * @example
   * 10
   */
  betweenEnd?: string;
  /**
   * @remarks
   * The start value of the range used in the filter condition. This parameter takes effect only when Operator is set to BETWEEN.
   * 
   * @example
   * 1
   */
  betweenStart?: string;
  /**
   * @remarks
   * The name of the column.
   * 
   * @example
   * account_name
   */
  columnName?: string;
  /**
   * @remarks
   * The IN list used in the filter condition.
   */
  inList?: string[];
  /**
   * @remarks
   * The type of the operator used to configure the filter condition. Valid values:
   * 
   * *   **EQUAL**: retrieves the column whose value is equal to the specified value.
   * *   **NOT_EQUAL**: retrieves the column whose value is not equal to the specified value.
   * *   **IN**: retrieves the column whose value is in the IN list.
   * *   **BETWEEN**: retrieves the column whose value is in the specified range.
   * *   **LESS**: retrieves the column whose value is less than the specified value.
   * *   **MORE**: retrieves the column whose value is greater than the specified value.
   * *   **NOT_IN**: retrieves the column whose value is not in the IN list.
   * 
   * @example
   * EQUAL
   */
  operator?: string;
  /**
   * @remarks
   * The value used in the filter condition.
   * 
   * @example
   * 1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      betweenEnd: 'BetweenEnd',
      betweenStart: 'BetweenStart',
      columnName: 'ColumnName',
      inList: 'InList',
      operator: 'Operator',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      betweenEnd: 'string',
      betweenStart: 'string',
      columnName: 'string',
      inList: { 'type': 'array', 'itemType': 'string' },
      operator: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecuteScriptResponseBodyResults extends $tea.Model {
  /**
   * @remarks
   * The fields that are queried after the SQL statement is executed.
   */
  columnNames?: string[];
  /**
   * @remarks
   * The error message that is returned if the SQL statement fails to be executed. For example, an error message is returned because the SQL statement is invalid.
   * 
   * @example
   * UnknownError
   */
  message?: string;
  /**
   * @remarks
   * The total number of entries that are returned.
   * 
   * @example
   * 1
   */
  rowCount?: number;
  /**
   * @remarks
   * The rows that are queried after the SQL statement is executed.
   */
  rows?: { [key: string]: any }[];
  /**
   * @remarks
   * Indicates whether the SQL statement is executed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      columnNames: 'ColumnNames',
      message: 'Message',
      rowCount: 'RowCount',
      rows: 'Rows',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnNames: { 'type': 'array', 'itemType': 'string' },
      message: 'string',
      rowCount: 'number',
      rows: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler extends $tea.Model {
  /**
   * @remarks
   * The ID of the user.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @remarks
   * The nickname of the user.
   * 
   * @example
   * nickName
   */
  nickName?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      nickName: 'NickName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      nickName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers extends $tea.Model {
  currentHandler?: GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler[];
  static names(): { [key: string]: string } {
    return {
      currentHandler: 'CurrentHandler',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentHandler: { 'type': 'array', 'itemType': GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApprovalDetailResponseBodyApprovalDetailReasonList extends $tea.Model {
  reasons?: string[];
  static names(): { [key: string]: string } {
    return {
      reasons: 'Reasons',
    };
  }

  static types(): { [key: string]: any } {
    return {
      reasons: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList extends $tea.Model {
  auditUserIds?: string[];
  static names(): { [key: string]: string } {
    return {
      auditUserIds: 'AuditUserIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      auditUserIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode extends $tea.Model {
  /**
   * @remarks
   * The IDs of the approvers.
   */
  auditUserIdList?: GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList;
  /**
   * @remarks
   * The name of the approval node.
   * 
   * @example
   * DBA
   */
  nodeName?: string;
  /**
   * @remarks
   * The remarks of the approval.
   * 
   * @example
   * Reason: Approved
   */
  operateComment?: string;
  /**
   * @remarks
   * The time when the ticket was submitted.
   * 
   * @example
   * 2019-10-15 13:47:54
   */
  operateTime?: string;
  /**
   * @remarks
   * The ID of the user who submitted the ticket.
   * 
   * @example
   * 1****
   */
  operatorId?: number;
  /**
   * @remarks
   * The approval status of the ticket. Valid values:
   * 
   * *   **START**: The ticket was submitted.
   * *   **ERROR**: An error occurred.
   * *   **AUDITING**: The ticket is being reviewed.
   * *   **REJECT**: The ticket was rejected.
   * *   **CANCEL**: The ticket was revoked.
   * *   **APPROVED**: The ticket was approved.
   * 
   * @example
   * APPROVED
   */
  workflowInsCode?: string;
  static names(): { [key: string]: string } {
    return {
      auditUserIdList: 'AuditUserIdList',
      nodeName: 'NodeName',
      operateComment: 'OperateComment',
      operateTime: 'OperateTime',
      operatorId: 'OperatorId',
      workflowInsCode: 'WorkflowInsCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      auditUserIdList: GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList,
      nodeName: 'string',
      operateComment: 'string',
      operateTime: 'string',
      operatorId: 'number',
      workflowInsCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes extends $tea.Model {
  workflowNode?: GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode[];
  static names(): { [key: string]: string } {
    return {
      workflowNode: 'WorkflowNode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      workflowNode: { 'type': 'array', 'itemType': GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApprovalDetailResponseBodyApprovalDetail extends $tea.Model {
  /**
   * @remarks
   * The ID of the approval process.
   * 
   * @example
   * 184****
   */
  auditId?: number;
  /**
   * @remarks
   * The time when the approval process was created.
   * 
   * @example
   * 2021-10-29 14:17:25
   */
  createTime?: string;
  /**
   * @remarks
   * The information about the approver.
   */
  currentHandlers?: GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers;
  /**
   * @remarks
   * The description of the approval process.
   * 
   * @example
   * [Instance permissions] Application\\<br/>Permission type: Logon\\<br/>Application period: 30.0 days\\<br/>Background description: [Instance permissions] logon test\\<br/>\\<br/>[Application list]\\<br/>\\<span style=\\"color:red\\">product\\</span> rm-bp144d5ky4l4rli0417\\*\\*\\*\\*.mysql.rds.aliyuncs.com:3306 - PRODUCT\\<br/>
   */
  description?: string;
  /**
   * @remarks
   * The ID of the ticket.
   * 
   * @example
   * 384****
   */
  orderId?: number;
  /**
   * @remarks
   * The type of the ticket. Valid values:
   * 
   * *   **NDDL**: a schema design ticket
   * *   **DATA_TRACK**: a data tracking ticket
   * *   **TABLE_SYNC**: a table synchronization ticket
   * *   **PERM_APPLY**: a permission application ticket
   * *   **DATA_EXPORT**: a data export ticket
   * *   **DATA_CORRECT**: a data change ticket
   * *   **OWNER_APPLY**: an owner role application ticket
   * *   **SENSITIVITY**: a column sensitivity level change ticket
   * 
   * @example
   * PERM_APPLY
   */
  orderType?: string;
  /**
   * @remarks
   * The reasons for the approval.
   */
  reasonList?: GetApprovalDetailResponseBodyApprovalDetailReasonList;
  /**
   * @remarks
   * The ID of the workflow template.
   * 
   * @example
   * 1234
   */
  templateId?: number;
  /**
   * @remarks
   * The title of the approval process.
   * 
   * @example
   * Permission application ticket - 384\\*\\*\\*\\*
   */
  title?: string;
  /**
   * @remarks
   * The approval status of the ticket. Valid values:
   * 
   * *   **AUDITING**: The ticket is being reviewed.
   * *   **REJECT**: The ticket was rejected.
   * *   **CANCEL**: The ticket was revoked.
   * *   **APPROVED**: The ticket was approved.
   * 
   * > An approval process contains multiple approval nodes, and this parameter is returned for each approval node.
   * 
   * @example
   * APPROVED
   */
  workflowInsCode?: string;
  /**
   * @remarks
   * The details of approval nodes.
   */
  workflowNodes?: GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes;
  static names(): { [key: string]: string } {
    return {
      auditId: 'AuditId',
      createTime: 'CreateTime',
      currentHandlers: 'CurrentHandlers',
      description: 'Description',
      orderId: 'OrderId',
      orderType: 'OrderType',
      reasonList: 'ReasonList',
      templateId: 'TemplateId',
      title: 'Title',
      workflowInsCode: 'WorkflowInsCode',
      workflowNodes: 'WorkflowNodes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      auditId: 'number',
      createTime: 'string',
      currentHandlers: GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers,
      description: 'string',
      orderId: 'number',
      orderType: 'string',
      reasonList: GetApprovalDetailResponseBodyApprovalDetailReasonList,
      templateId: 'number',
      title: 'string',
      workflowInsCode: 'string',
      workflowNodes: GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem extends $tea.Model {
  /**
   * @remarks
   * Other information. For example, you can add the logon permission on an instance to the permission template.
   * 
   * @example
   * "permissionTypes": [
   *             "LOGIN"
   *           ]
   */
  attribute?: string;
  /**
   * @remarks
   * The ID of the database.
   * 
   * @example
   * 43***
   */
  dbId?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * 188****
   */
  instanceId?: number;
  /**
   * @remarks
   * The ID of the resource.
   * 
   * @example
   * 12***
   */
  itemId?: number;
  /**
   * @remarks
   * The ID of the user who modified the resource.
   * 
   * @example
   * 51***
   */
  modifierId?: number;
  /**
   * @remarks
   * The type of the resource. Valid values:
   * 
   * *   **INSTANCE**: instance
   * *   **LOGIC_DB**: logical database
   * *   **META_DB**: physical database
   * *   **LOGIC_TABLE**: logical table
   * *   **SINGLE_TABLE**: physical table
   * 
   * @example
   * INSTANCE
   */
  resourceType?: string;
  /**
   * @remarks
   * The name of the table.
   * 
   * @example
   * ExampleTable
   */
  tableName?: string;
  /**
   * @remarks
   * The ID of the permission template.
   * 
   * @example
   * 1563
   */
  templateId?: number;
  static names(): { [key: string]: string } {
    return {
      attribute: 'Attribute',
      dbId: 'DbId',
      instanceId: 'InstanceId',
      itemId: 'ItemId',
      modifierId: 'ModifierId',
      resourceType: 'ResourceType',
      tableName: 'TableName',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attribute: 'string',
      dbId: 'number',
      instanceId: 'number',
      itemId: 'number',
      modifierId: 'number',
      resourceType: 'string',
      tableName: 'string',
      templateId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemList extends $tea.Model {
  authorityTemplateItem?: GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem[];
  static names(): { [key: string]: string } {
    return {
      authorityTemplateItem: 'AuthorityTemplateItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorityTemplateItem: { 'type': 'array', 'itemType': GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthorityTemplateResponseBodyAuthorityTemplateView extends $tea.Model {
  /**
   * @remarks
   * The resource information in the permission template.
   */
  authorityTemplateItemList?: GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemList;
  /**
   * @remarks
   * The time when the permission template was created. The time is in the yyyy-MM-DD HH:mm:ss format.
   * 
   * @example
   * 2023-01-01 00:00:00
   */
  createTime?: string;
  /**
   * @remarks
   * The ID of the user who created the permission template.
   * 
   * @example
   * 12***
   */
  creatorId?: number;
  /**
   * @remarks
   * The description of the permission template.
   * 
   * @example
   * This template is used for business testing.
   */
  description?: string;
  /**
   * @remarks
   * The name of the permission template.
   * 
   * @example
   * TestTemplate
   */
  name?: string;
  /**
   * @remarks
   * The ID of the permission template.
   * 
   * @example
   * 1563
   */
  templateId?: number;
  static names(): { [key: string]: string } {
    return {
      authorityTemplateItemList: 'AuthorityTemplateItemList',
      createTime: 'CreateTime',
      creatorId: 'CreatorId',
      description: 'Description',
      name: 'Name',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorityTemplateItemList: GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemList,
      createTime: 'string',
      creatorId: 'number',
      description: 'string',
      name: 'string',
      templateId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem extends $tea.Model {
  /**
   * @remarks
   * The additional information. For example, permissions to log on to an instance are added to the permission template.
   * 
   * @example
   * "permissionTypes": [
   *             "LOGIN"
   *           ]
   */
  attribute?: string;
  /**
   * @remarks
   * The ID of the database.
   * 
   * @example
   * 43***
   */
  dbId?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * 188****
   */
  instanceId?: number;
  /**
   * @remarks
   * The ID of the resource.
   * 
   * @example
   * 12***
   */
  itemId?: number;
  /**
   * @remarks
   * The ID of the user who modifies the resource.
   * 
   * @example
   * 51***
   */
  modifierId?: number;
  /**
   * @remarks
   * The type of the resource. Valid values:
   * 
   * *   **INSTANCE**: instance
   * *   **LOGIC_DB**: logical database
   * *   **META_DB**: physical database
   * *   **LOGIC_TABLE**: logical table
   * *   **LOGIC_TABLE**: physical table
   * 
   * @example
   * INSTANCE
   */
  resourceType?: string;
  /**
   * @remarks
   * The name of the table.
   * 
   * @example
   * ExampleTable
   */
  tableName?: string;
  /**
   * @remarks
   * The ID of the permission template.
   * 
   * @example
   * 1563
   */
  templateId?: number;
  static names(): { [key: string]: string } {
    return {
      attribute: 'Attribute',
      dbId: 'DbId',
      instanceId: 'InstanceId',
      itemId: 'ItemId',
      modifierId: 'ModifierId',
      resourceType: 'ResourceType',
      tableName: 'TableName',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attribute: 'string',
      dbId: 'number',
      instanceId: 'number',
      itemId: 'number',
      modifierId: 'number',
      resourceType: 'string',
      tableName: 'string',
      templateId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemList extends $tea.Model {
  authorityTemplateItem?: GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem[];
  static names(): { [key: string]: string } {
    return {
      authorityTemplateItem: 'AuthorityTemplateItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorityTemplateItem: { 'type': 'array', 'itemType': GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClassificationTemplateResponseBodyClassificationResourceTemplateMap extends $tea.Model {
  /**
   * @example
   * 24****
   */
  resourceId?: number;
  /**
   * @example
   * INSTANCE
   */
  resourceType?: string;
  /**
   * @example
   * 3***
   */
  templateId?: number;
  /**
   * @example
   * INNER
   */
  templateType?: string;
  static names(): { [key: string]: string } {
    return {
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      templateId: 'TemplateId',
      templateType: 'TemplateType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceId: 'number',
      resourceType: 'string',
      templateId: 'number',
      templateType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList extends $tea.Model {
  /**
   * @remarks
   * The name of the catalog to which the database belongs.
   * 
   * > If the database is a PostgreSQL database, the value of this parameter is the name of the database.
   * 
   * @example
   * def
   */
  catalogName?: string;
  /**
   * @remarks
   * The ID of the database for which the schema design is executed.
   * 
   * @example
   * 423532
   */
  dbId?: number;
  /**
   * @remarks
   * The type of the database engine.
   * 
   * @example
   * polardb
   */
  dbType?: string;
  /**
   * @remarks
   * The type of the environment to which the database belongs. Valid values:
   * 
   * *   product: production environment
   * *   dev: development environment
   * *   pre: staging environment
   * *   test: test environment
   * *   sit: SIT environment
   * *   uat: user acceptance testing (UAT) environment
   * *   pet: stress testing environment
   * *   stag: STAG environment
   * 
   * @example
   * dev
   */
  envType?: string;
  /**
   * @remarks
   * The ID of the instance. The valid value is returned if you call the ListInstances operation. The instance ID is not the ID of the RDS instance.
   * 
   * @example
   * 4325325
   */
  instanceId?: number;
  /**
   * @remarks
   * Instance resource ID.
   * 
   * @example
   * rm-xxx
   */
  instanceResourceId?: string;
  /**
   * @remarks
   * The source of the database instance. Valid values:
   * 
   * *   **PUBLIC_OWN:** a self-managed database instance that is deployed on the Internet
   * *   **RDS:** an ApsaraDB RDS instance
   * *   **ECS_OWN:** a self-managed database that is deployed on an Elastic Compute Service (ECS) instance
   * *   **VPC_IDC:** a self-managed database instance that is deployed in a data center connected over a virtual private cloud (VPC)
   * 
   * @example
   * RDS
   */
  instanceSource?: string;
  /**
   * @remarks
   * The ID of the region in which the instance resides.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The name of the logical database.
   * 
   * > If the database is a PostgreSQL database, the value of this parameter is the name of the database schema.
   * 
   * @example
   * db_test@rm-xxx:3306
   */
  schemaName?: string;
  /**
   * @remarks
   * The name of the saved search.
   * 
   * @example
   * db_test
   */
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      catalogName: 'CatalogName',
      dbId: 'DbId',
      dbType: 'DbType',
      envType: 'EnvType',
      instanceId: 'InstanceId',
      instanceResourceId: 'InstanceResourceId',
      instanceSource: 'InstanceSource',
      regionId: 'RegionId',
      schemaName: 'SchemaName',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      catalogName: 'string',
      dbId: 'number',
      dbType: 'string',
      envType: 'string',
      instanceId: 'number',
      instanceResourceId: 'string',
      instanceSource: 'string',
      regionId: 'string',
      schemaName: 'string',
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDBTopologyResponseBodyDBTopology extends $tea.Model {
  /**
   * @remarks
   * The alias of the access point.
   * 
   * @example
   * logic_db_test
   */
  alias?: string;
  /**
   * @remarks
   * The list of database splitting topology information.
   */
  DBTopologyInfoList?: GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList[];
  /**
   * @remarks
   * The type of the database engine.
   * 
   * @example
   * polardb
   */
  dbType?: string;
  /**
   * @remarks
   * The type of the environment in which the database instance is deployed. Valid values:
   * 
   * *   product: production environment
   * *   dev: development environment
   * *   pre: pre-release environment
   * *   test: test environment
   * *   sit: system integration testing (SIT) environment
   * *   uat: user acceptance testing (UAT) environment
   * *   pet: stress testing environment
   * *   stag: staging environment
   * 
   * @example
   * dev
   */
  envType?: string;
  /**
   * @remarks
   * The ID of the logical database.
   * 
   * @example
   * 1234
   */
  logicDbId?: number;
  /**
   * @remarks
   * Logical database name.
   * 
   * @example
   * logic_db_test
   */
  logicDbName?: string;
  /**
   * @remarks
   * The name of the saved search.
   * 
   * @example
   * logic_db_test
   */
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      DBTopologyInfoList: 'DBTopologyInfoList',
      dbType: 'DbType',
      envType: 'EnvType',
      logicDbId: 'LogicDbId',
      logicDbName: 'LogicDbName',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      DBTopologyInfoList: { 'type': 'array', 'itemType': GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList },
      dbType: 'string',
      envType: 'string',
      logicDbId: 'number',
      logicDbName: 'string',
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveCountResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The number of tickets that data archiving failed.
   * 
   * @example
   * 1**
   */
  failCount?: number;
  /**
   * @remarks
   * The number of tickets that data archiving is in progress.
   * 
   * @example
   * 2**
   */
  processingCount?: number;
  /**
   * @remarks
   * The number of tickets that data archiving is successful.
   * 
   * @example
   * 3**
   */
  successCount?: number;
  /**
   * @remarks
   * The total number of data archiving tickets.
   * 
   * @example
   * 6**
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      failCount: 'FailCount',
      processingCount: 'ProcessingCount',
      successCount: 'SuccessCount',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failCount: 'number',
      processingCount: 'number',
      successCount: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo extends $tea.Model {
  /**
   * @remarks
   * The ID of the user who created the task flow.
   * 
   * @example
   * 59****
   */
  creatorId?: string;
  /**
   * @remarks
   * The start time for scheduling. The task flow is not scheduled before this point in time.
   * 
   * @example
   * 1970-01-01
   */
  cronBeginDate?: string;
  /**
   * @remarks
   * The end time for scheduling. The task flow is not scheduled after this point in time.
   * 
   * @example
   * 9999-01-01
   */
  cronEndDate?: string;
  /**
   * @remarks
   * Indicates whether the archiving task is a scheduled task. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * false
   */
  cronTrigger?: boolean;
  /**
   * @remarks
   * Indicates whether the task is used to develop warehouses.
   * 
   * >  This field is a retained field that is not in use.
   * 
   * @example
   * false
   */
  DWDevelop?: boolean;
  /**
   * @remarks
   * The name of the workflow.
   * 
   * @example
   * data-archive-9099197
   */
  dagName?: string;
  /**
   * @remarks
   * The ID of the owner of the workflow.
   * 
   * @example
   * 13****
   */
  dagOwnerId?: string;
  /**
   * @remarks
   * The ID of the deployment record.
   * 
   * @example
   * 93***
   */
  deployId?: number;
  /**
   * @remarks
   * The description of the workflow.
   * 
   * @example
   * order id:9099197
   */
  description?: string;
  /**
   * @remarks
   * The ID of the editable workflow version.
   * 
   * @example
   * 24***
   */
  editDagId?: number;
  /**
   * @remarks
   * The time when the workflow was created.
   * 
   * @example
   * 2023-05-15 16:00:48
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The time when the workflow was last modified.
   * 
   * @example
   * 2023-06-15 16:00:48
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the task flow.
   * 
   * @example
   * 24***
   */
  id?: number;
  /**
   * @remarks
   * Indicates whether the workflow is public. Valid values:
   * 
   * *   **0**: not public.
   * *   **1**: public.
   * 
   * @example
   * 0
   */
  isPublic?: number;
  /**
   * @remarks
   * Indicates whether the task is a historical task. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * false
   */
  legacy?: boolean;
  /**
   * @remarks
   * Indicates whether the task was created by the system. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * false
   */
  system?: boolean;
  /**
   * @remarks
   * The tenant ID.
   * 
   * @example
   * 5***
   */
  tenantId?: string;
  /**
   * @remarks
   * Indicates whether the workflow is triggered to run once. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * false
   */
  triggerOnce?: boolean;
  static names(): { [key: string]: string } {
    return {
      creatorId: 'CreatorId',
      cronBeginDate: 'CronBeginDate',
      cronEndDate: 'CronEndDate',
      cronTrigger: 'CronTrigger',
      DWDevelop: 'DWDevelop',
      dagName: 'DagName',
      dagOwnerId: 'DagOwnerId',
      deployId: 'DeployId',
      description: 'Description',
      editDagId: 'EditDagId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      isPublic: 'IsPublic',
      legacy: 'Legacy',
      system: 'System',
      tenantId: 'TenantId',
      triggerOnce: 'TriggerOnce',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorId: 'string',
      cronBeginDate: 'string',
      cronEndDate: 'string',
      cronTrigger: 'boolean',
      DWDevelop: 'boolean',
      dagName: 'string',
      dagOwnerId: 'string',
      deployId: 'number',
      description: 'string',
      editDagId: 'number',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      isPublic: 'number',
      legacy: 'boolean',
      system: 'boolean',
      tenantId: 'string',
      triggerOnce: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup extends $tea.Model {
  /**
   * @remarks
   * The type of the instance engine. For information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
   * 
   * @example
   * MySQL
   */
  dbType?: string;
  /**
   * @remarks
   * The description of the security rule set.
   * 
   * @example
   * adb_mysql default
   */
  description?: string;
  /**
   * @remarks
   * Indicates whether the instance is managed in Flexible Management or Stable Change mode. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * false
   */
  freeOrStable?: boolean;
  /**
   * @remarks
   * The time when the security rule was created.
   * 
   * @example
   * 2020-05-24 14:12:32
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The time when the security rule was last modified.
   * 
   * @example
   * 2020-05-25 14:12:32
   */
  gmtModified?: string;
  /**
   * @remarks
   * The type of the control mode of the instance. Valid values:
   * 
   * *   **COMMON**: The instance is managed in Security Collaboration mode.
   * *   **NONE_CONTROL**: The instance is managed in Flexible Management mode.
   * *   **STABLE**: The instance is managed in Stable Change mode.
   * 
   * @example
   * COMMON
   */
  groupMode?: string;
  /**
   * @remarks
   * The name of the security rule that corresponds to the control mode.
   * 
   * @example
   * adb_mysql default
   */
  groupName?: string;
  /**
   * @remarks
   * The ID of the security rule.
   * 
   * @example
   * 24***
   */
  id?: number;
  /**
   * @remarks
   * The user ID of the last modified security rule.
   * 
   * @example
   * 12****
   */
  lastMenderId?: number;
  static names(): { [key: string]: string } {
    return {
      dbType: 'DbType',
      description: 'Description',
      freeOrStable: 'FreeOrStable',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      groupMode: 'GroupMode',
      groupName: 'GroupName',
      id: 'Id',
      lastMenderId: 'LastMenderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbType: 'string',
      description: 'string',
      freeOrStable: 'boolean',
      gmtCreate: 'string',
      gmtModified: 'string',
      groupMode: 'string',
      groupName: 'string',
      id: 'number',
      lastMenderId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo extends $tea.Model {
  /**
   * @remarks
   * The alias of the database instance.
   * 
   * @example
   * tf-testAccDMSEnterpriseLogicDatabase853****
   */
  alias?: string;
  /**
   * @remarks
   * The timeout period of queries on the database.
   * 
   * @example
   * 600
   */
  alterTimeout?: number;
  /**
   * @remarks
   * Indicates whether access control is enabled for data assets. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  assetControl?: boolean;
  /**
   * @remarks
   * The name of the instance in the instance list.
   * 
   * @example
   * test
   */
  catalogName?: string;
  /**
   * @remarks
   * Indicates whether the instance is added to the DMS whitelist.
   * 
   * @example
   * whitelist_done
   */
  clusterNode?: string;
  /**
   * @remarks
   * The ID of the database. You can call the [SearchDatabase](https://help.aliyun.com/document_detail/141876.html) operation to query the ID of the database.
   * 
   * >  You can call the [ListDatabases](https://help.aliyun.com/document_detail/141873.html) operation to query the ID of a physical database or the [ListLogicDatabases](https://help.aliyun.com/document_detail/141874.html) operation to query the ID of a logical database.
   * 
   * @example
   * 348****
   */
  dbId?: number;
  /**
   * @remarks
   * The type of the database. For information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
   * 
   * @example
   * MySQL
   */
  dbType?: string;
  /**
   * @remarks
   * The ID of the database administrator (DBA) of the instance.
   * 
   * @example
   * 16****
   */
  dbaId?: number;
  /**
   * @remarks
   * The nickname of the DBA of the instance.
   * 
   * @example
   * DBA
   */
  dbaName?: string;
  /**
   * @remarks
   * The complete endpoint of the database.
   * 
   * @example
   * test@rm-2ze756u8837****.mysql.rds.aliyuncs.com:3306 [test]
   */
  description?: string;
  /**
   * @remarks
   * The encoding format of the database.
   * 
   * @example
   * utf8
   */
  encoding?: string;
  /**
   * @remarks
   * The type of the environment to which the database belongs. Valid values:
   * 
   * *   **product**: production environment
   * *   **dev**: development environment
   * *   **pre**: staging environment
   * *   **test**: test environment
   * *   **sit**: system integration testing (SIT) environment
   * *   **uat**: user acceptance testing (UAT) environment
   * *   **pet**: stress testing environment
   * *   **stag**: STAG environment
   * 
   * @example
   * product
   */
  envType?: string;
  /**
   * @remarks
   * Indicates whether the instance needs special attention. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * false
   */
  follow?: boolean;
  /**
   * @remarks
   * The endpoint that is used to connect to the database.
   * 
   * @example
   * rm-2ze756u8837****.mysql.rds.aliyuncs.com
   */
  host?: string;
  /**
   * @remarks
   * The region in which the database instance resides.
   * 
   * @example
   * cn-beijing
   */
  idc?: string;
  /**
   * @remarks
   * The name of the region in which the database instance resides.
   * 
   * @example
   * cn-beijing
   */
  idcTitle?: string;
  /**
   * @remarks
   * The ID of the instance to which the database belongs.
   * 
   * @example
   * 175****
   */
  instanceId?: number;
  /**
   * @remarks
   * The source of the database instance.Valid values:
   * 
   * *   **RDS**: an ApsaraDB RDS instance.
   * *   **ECS_OWN**: a self-managed database deployed on an Elastic Compute Service (ECS) instance.
   * *   **PUBLIC_OWN**: a self-managed database instance that is connected over the Internet.
   * *   **VPC_ID**: a self-managed database instance in a virtual private cloud (VPC) that is connected over Express Connect circuits.
   * *   **GATEWAY**: a database instance connected by using a database gateway.
   * 
   * @example
   * RDS
   */
  instanceSource?: string;
  /**
   * @remarks
   * The time when the database information was last obtained.
   * 
   * @example
   * 2023-05-14 18:34:45
   */
  lastSyncTime?: string;
  /**
   * @remarks
   * The instance level.
   * 
   * @example
   * medium
   */
  level?: string;
  /**
   * @remarks
   * Indicates whether the database is logical. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The IDs of the owners of the databases, which are stored as an array. You can call the [GetUser](https://help.aliyun.com/document_detail/147098.html) or [ListUsers](https://help.aliyun.com/document_detail/141938.html) operation to query the IDs of the owners.
   * 
   * >  The value of OwnerIds is the same as the value of UserId
   */
  ownerIds?: number[];
  /**
   * @remarks
   * The usernames of the database owners.
   */
  ownerNames?: string[];
  /**
   * @remarks
   * The port that is used to connect to the database.
   * 
   * @example
   * 3306
   */
  port?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * test
   */
  schemaName?: string;
  /**
   * @remarks
   * The name that is used to search for the database.
   * 
   * @example
   * test@rm-2ze756u8837****.mysql.rds.aliyuncs.com:3306 [test]
   */
  searchName?: string;
  /**
   * @remarks
   * The details of the control mode of the instance.
   */
  standardGroup?: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup;
  /**
   * @remarks
   * The status of the database. Valid values:
   * 
   * *   **NORMAL**: The database is running as expected.
   * *   **DISABLE**: The database is disabled.
   * *   **OFFLINE**: The database is unpublished.
   * *   **NOT_EXIST**: The database does not exist.
   * 
   * @example
   * NORMAL
   */
  state?: string;
  /**
   * @remarks
   * The number of tables.
   * 
   * @example
   * 201
   */
  tableCount?: number;
  /**
   * @remarks
   * The name of TNS.
   * 
   * @example
   * TNS_4010
   */
  tnsName?: string;
  /**
   * @remarks
   * The unit type.
   * 
   * @example
   * -1
   */
  unitType?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      alterTimeout: 'AlterTimeout',
      assetControl: 'AssetControl',
      catalogName: 'CatalogName',
      clusterNode: 'ClusterNode',
      dbId: 'DbId',
      dbType: 'DbType',
      dbaId: 'DbaId',
      dbaName: 'DbaName',
      description: 'Description',
      encoding: 'Encoding',
      envType: 'EnvType',
      follow: 'Follow',
      host: 'Host',
      idc: 'Idc',
      idcTitle: 'IdcTitle',
      instanceId: 'InstanceId',
      instanceSource: 'InstanceSource',
      lastSyncTime: 'LastSyncTime',
      level: 'Level',
      logic: 'Logic',
      ownerIds: 'OwnerIds',
      ownerNames: 'OwnerNames',
      port: 'Port',
      schemaName: 'SchemaName',
      searchName: 'SearchName',
      standardGroup: 'StandardGroup',
      state: 'State',
      tableCount: 'TableCount',
      tnsName: 'TnsName',
      unitType: 'UnitType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      alterTimeout: 'number',
      assetControl: 'boolean',
      catalogName: 'string',
      clusterNode: 'string',
      dbId: 'number',
      dbType: 'string',
      dbaId: 'number',
      dbaName: 'string',
      description: 'string',
      encoding: 'string',
      envType: 'string',
      follow: 'boolean',
      host: 'string',
      idc: 'string',
      idcTitle: 'string',
      instanceId: 'number',
      instanceSource: 'string',
      lastSyncTime: 'string',
      level: 'string',
      logic: 'boolean',
      ownerIds: { 'type': 'array', 'itemType': 'number' },
      ownerNames: { 'type': 'array', 'itemType': 'string' },
      port: 'number',
      schemaName: 'string',
      searchName: 'string',
      standardGroup: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup,
      state: 'string',
      tableCount: 'number',
      tnsName: 'string',
      unitType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances extends $tea.Model {
  /**
   * @remarks
   * The business time of the task flow. The time is displayed in the yyyy-MM-DD HH:mm:ss format.
   * 
   * @example
   * 2023-05-14 16:00:57
   */
  businessTime?: string;
  /**
   * @remarks
   * The task flow ID. You can call the [ListTaskFlow](https://help.aliyun.com/document_detail/424565.html) or [ListLhTaskFlowAndScenario](https://help.aliyun.com/document_detail/426672.html) operation to obtain the value of this parameter.
   * 
   * @example
   * 37***
   */
  dagId?: number;
  /**
   * @remarks
   * The time when the task flow ended. The time is displayed in the yyyy-MM-DD HH:mm:ss format.
   * 
   * @example
   * 2022-06-04 15:14:00
   */
  endTime?: string;
  /**
   * @remarks
   * The time when the task flow was created.
   * 
   * @example
   * 2023-05-14 16:00:57
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The time when the task flow was last modified.
   * 
   * @example
   * 2023-05-14 16:00:57
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the historical task flow.
   * 
   * @example
   * 32***
   */
  historyDagId?: number;
  /**
   * @remarks
   * The ID of the instance in the task flow that is executed.
   * 
   * @example
   * 24***
   */
  id?: number;
  /**
   * @remarks
   * The context of the previous execution of the task flow.
   * 
   * @example
   * {
   *       "nodes": [
   *             48**
   *       ],
   *       "edges": {}
   * }
   */
  lastRunningContext?: string;
  /**
   * @remarks
   * The context of the current execution of the task flow.
   * 
   * @example
   * 2023-05-15 16:37:48[GMT+08:00] INFO - Resource Control is active!\\n2023-05-15 16:37:48[GMT+08:00] INFO - Starting job j_4834 at Mon May 15 16:37:48 CST 2023
   */
  msg?: string;
  /**
   * @remarks
   * The status of the task. Valid values:
   * 
   * *   **0**: The task is waiting for execution.
   * *   **1**: The task is in progress.
   * *   **2**: The task is suspended.
   * *   **3**: The task failed.
   * *   **4**: The task is successful.
   * *   **5**: The task is complete.
   * 
   * @example
   * 4
   */
  status?: number;
  /**
   * @remarks
   * The tenant ID.
   * 
   * @example
   * 5***
   */
  tenantId?: string;
  /**
   * @remarks
   * The mode in which the task flow was triggered. Valid values:
   * 
   * *   **0**: The task flow was triggered based on a schedule.
   * *   **1**: The task flow was manually triggered.
   * 
   * @example
   * 1
   */
  triggerType?: number;
  /**
   * @remarks
   * The version number.
   * 
   * @example
   * 1
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      businessTime: 'BusinessTime',
      dagId: 'DagId',
      endTime: 'EndTime',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      historyDagId: 'HistoryDagId',
      id: 'Id',
      lastRunningContext: 'LastRunningContext',
      msg: 'Msg',
      status: 'Status',
      tenantId: 'TenantId',
      triggerType: 'TriggerType',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessTime: 'string',
      dagId: 'number',
      endTime: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      historyDagId: 'number',
      id: 'number',
      lastRunningContext: 'string',
      msg: 'string',
      status: 'number',
      tenantId: 'string',
      triggerType: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataNextFireTimeResult extends $tea.Model {
  /**
   * @remarks
   * The type of scheduled triggering.
   * 
   * @example
   * NOT_SET
   */
  cronFireType?: string;
  static names(): { [key: string]: string } {
    return {
      cronFireType: 'CronFireType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cronFireType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData extends $tea.Model {
  /**
   * @remarks
   * The information about the workflow.
   */
  dagInfo?: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo;
  /**
   * @remarks
   * The database information related to data archiving tickets.
   */
  dbBaseInfo?: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo;
  /**
   * @remarks
   * The total number of archiving tasks.
   * 
   * @example
   * 2
   */
  instanceTotal?: number;
  /**
   * @remarks
   * The list of archiving tasks.
   */
  instances?: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances[];
  /**
   * @remarks
   * The time when the next task is triggered.
   */
  nextFireTimeResult?: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataNextFireTimeResult;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 10
   */
  pageIndex?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The name of the temporary table that is generated by the archiving task (indicated by the archiving task ID).
   * 
   * @example
   * {
   *       "803***": [
   *             "tmp_dms_21321_20230704144336_temp_test_check"
   *       ]
   * }
   */
  tempTableNameMap?: { [key: string]: any };
  static names(): { [key: string]: string } {
    return {
      dagInfo: 'DagInfo',
      dbBaseInfo: 'DbBaseInfo',
      instanceTotal: 'InstanceTotal',
      instances: 'Instances',
      nextFireTimeResult: 'NextFireTimeResult',
      pageIndex: 'PageIndex',
      pageSize: 'PageSize',
      tempTableNameMap: 'TempTableNameMap',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagInfo: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo,
      dbBaseInfo: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo,
      instanceTotal: 'number',
      instances: { 'type': 'array', 'itemType': GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances },
      nextFireTimeResult: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataNextFireTimeResult,
      pageIndex: 'number',
      pageSize: 'number',
      tempTableNameMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes extends $tea.Model {
  /**
   * @remarks
   * The table name.
   * 
   * @example
   * tm_insured_cb
   */
  tableName?: string;
  /**
   * @remarks
   * The filter condition.
   * 
   * @example
   * id<1000 or gmt_create<\\"2023-05-14 16:00:57\\"
   */
  tableWhere?: string;
  static names(): { [key: string]: string } {
    return {
      tableName: 'TableName',
      tableWhere: 'TableWhere',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tableName: 'string',
      tableWhere: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam extends $tea.Model {
  /**
   * @remarks
   * The type of the archiving destination.
   * 
   * @example
   * inner_oss
   */
  archiveMethod?: string;
  /**
   * @remarks
   * The schema of the database and table to be archived.
   * 
   * @example
   * test
   */
  dbSchema?: string;
  /**
   * @remarks
   * Indicates whether the database is logical.
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  logic?: boolean;
  /**
   * @remarks
   * The post behavior of archiving.
   */
  orderAfter?: string[];
  /**
   * @remarks
   * The running method, which indicates whether to run the task immediately or at a specific point in time.
   * 
   * @example
   * now
   */
  runMethod?: string;
  /**
   * @remarks
   * The ID of the source database.
   * 
   * @example
   * 12***
   */
  sourceDatabaseId?: number;
  /**
   * @remarks
   * The list of the archived tables and the filter conditions.
   */
  tableIncludes?: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes[];
  /**
   * @remarks
   * The mapping of schemas.
   */
  tableMapping?: string[];
  /**
   * @remarks
   * The ID of the destination instance.
   * 
   * @example
   * 12***
   */
  targetInstanceId?: string;
  /**
   * @remarks
   * The time variable defined for scheduled archiving.
   */
  variables?: string[];
  static names(): { [key: string]: string } {
    return {
      archiveMethod: 'ArchiveMethod',
      dbSchema: 'DbSchema',
      logic: 'Logic',
      orderAfter: 'OrderAfter',
      runMethod: 'RunMethod',
      sourceDatabaseId: 'SourceDatabaseId',
      tableIncludes: 'TableIncludes',
      tableMapping: 'TableMapping',
      targetInstanceId: 'TargetInstanceId',
      variables: 'Variables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      archiveMethod: 'string',
      dbSchema: 'string',
      logic: 'boolean',
      orderAfter: { 'type': 'array', 'itemType': 'string' },
      runMethod: 'string',
      sourceDatabaseId: 'number',
      tableIncludes: { 'type': 'array', 'itemType': GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes },
      tableMapping: { 'type': 'array', 'itemType': 'string' },
      targetInstanceId: 'string',
      variables: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail extends $tea.Model {
  /**
   * @remarks
   * The description of the data archiving tickets.
   * 
   * @example
   * Archiving of test results
   */
  comment?: string;
  /**
   * @remarks
   * The user who submitted the ticket.
   * 
   * @example
   * dmstest
   */
  committer?: string;
  /**
   * @remarks
   * The ID of the user who submitted the ticket. The ID is a user ID and not the ID of an Alibaba Cloud account.
   * 
   * @example
   * 26***
   */
  committerId?: number;
  /**
   * @remarks
   * The time when the ticket was created.
   * 
   * @example
   * 2023-05-15 16:00:48
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The time when the ticket was last modified.
   * 
   * @example
   * 2023-05-23 16:00:48
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of data archiving tickets.
   * 
   * @example
   * 868****
   */
  id?: number;
  /**
   * @remarks
   * The additional information about the ticket.
   */
  pluginExtraData?: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData;
  /**
   * @remarks
   * The ticket creation parameter. The value is a JSON string. For more information, see [PluginType parameter](https://help.aliyun.com/document_detail/429109.html).
   */
  pluginParam?: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam;
  /**
   * @remarks
   * The plug-in type that corresponds to the type of the ticket. The plug-in type for data archiving is DATA_ARCHIVE. For more information, see [PluginType parameter](https://help.aliyun.com/document_detail/429109.html).
   * 
   * @example
   * DATA_ARCHIVE
   */
  pluginType?: string;
  /**
   * @remarks
   * The user IDs related to the ticket.
   */
  relatedUserList?: number[];
  /**
   * @remarks
   * The nicknames of the users that are related to the ticket.
   */
  relatedUserNickList?: string[];
  /**
   * @remarks
   * The status code of the ticket. Valid values:
   * 
   * *   **new**: newly created.
   * *   **toaudit**: being reviewed.
   * *   **Approved**: approved.
   * *   **reject**: rejected.
   * *   **processing**: being executed.
   * *   **Success**: successful.
   * *   **closed**: disabled.
   * 
   * @example
   * processing
   */
  statusCode?: string;
  /**
   * @remarks
   * The status description of the ticket.
   * 
   * @example
   * a ticket task is being executed.
   */
  statusDesc?: string;
  /**
   * @remarks
   * The ID of the approval process. You can call the [GetOrderBaseInfo](https://help.aliyun.com/document_detail/144642.html) operation to obtain the ID of the approval process.
   * 
   * @example
   * 29****
   */
  workflowInstanceId?: number;
  /**
   * @remarks
   * The description of the approval process.
   * 
   * @example
   * approved
   */
  workflowStatusDesc?: string;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      committer: 'Committer',
      committerId: 'CommitterId',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      pluginExtraData: 'PluginExtraData',
      pluginParam: 'PluginParam',
      pluginType: 'PluginType',
      relatedUserList: 'RelatedUserList',
      relatedUserNickList: 'RelatedUserNickList',
      statusCode: 'StatusCode',
      statusDesc: 'StatusDesc',
      workflowInstanceId: 'WorkflowInstanceId',
      workflowStatusDesc: 'WorkflowStatusDesc',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      committer: 'string',
      committerId: 'number',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      pluginExtraData: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData,
      pluginParam: GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam,
      pluginType: 'string',
      relatedUserList: { 'type': 'array', 'itemType': 'number' },
      relatedUserNickList: { 'type': 'array', 'itemType': 'string' },
      statusCode: 'string',
      statusDesc: 'string',
      workflowInstanceId: 'number',
      workflowStatusDesc: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles extends $tea.Model {
  fileUrl?: string[];
  static names(): { [key: string]: string } {
    return {
      fileUrl: 'FileUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileUrl: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailConfigDetailCronExtConfig extends $tea.Model {
  currentClearTaskCount?: number;
  optimizeTableAfterEveryClearTimes?: number;
  static names(): { [key: string]: string } {
    return {
      currentClearTaskCount: 'CurrentClearTaskCount',
      optimizeTableAfterEveryClearTimes: 'OptimizeTableAfterEveryClearTimes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentClearTaskCount: 'number',
      optimizeTableAfterEveryClearTimes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailConfigDetailImportExtConfig extends $tea.Model {
  csvFirstRowIsColumnDef?: boolean;
  ignoreError?: boolean;
  importMode?: string;
  insertType?: string;
  static names(): { [key: string]: string } {
    return {
      csvFirstRowIsColumnDef: 'CsvFirstRowIsColumnDef',
      ignoreError: 'IgnoreError',
      importMode: 'ImportMode',
      insertType: 'InsertType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      csvFirstRowIsColumnDef: 'boolean',
      ignoreError: 'boolean',
      importMode: 'string',
      insertType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailConfigDetail extends $tea.Model {
  cron?: boolean;
  cronCallTimes?: number;
  cronExtConfig?: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailConfigDetailCronExtConfig;
  cronFormat?: string;
  cronLastCallStartTime?: string;
  cronNextCallTime?: string;
  cronStatus?: string;
  csvTableName?: string;
  currentTaskId?: number;
  detailType?: string;
  duration?: number;
  fileEncoding?: string;
  fileType?: string;
  importExtConfig?: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailConfigDetailImportExtConfig;
  static names(): { [key: string]: string } {
    return {
      cron: 'Cron',
      cronCallTimes: 'CronCallTimes',
      cronExtConfig: 'CronExtConfig',
      cronFormat: 'CronFormat',
      cronLastCallStartTime: 'CronLastCallStartTime',
      cronNextCallTime: 'CronNextCallTime',
      cronStatus: 'CronStatus',
      csvTableName: 'CsvTableName',
      currentTaskId: 'CurrentTaskId',
      detailType: 'DetailType',
      duration: 'Duration',
      fileEncoding: 'FileEncoding',
      fileType: 'FileType',
      importExtConfig: 'ImportExtConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cron: 'boolean',
      cronCallTimes: 'number',
      cronExtConfig: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailConfigDetailCronExtConfig,
      cronFormat: 'string',
      cronLastCallStartTime: 'string',
      cronNextCallTime: 'string',
      cronStatus: 'string',
      csvTableName: 'string',
      currentTaskId: 'number',
      detailType: 'string',
      duration: 'number',
      fileEncoding: 'string',
      fileType: 'string',
      importExtConfig: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailConfigDetailImportExtConfig,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase extends $tea.Model {
  /**
   * @remarks
   * The ID of the database.
   * 
   * @example
   * 1860****
   */
  dbId?: number;
  /**
   * @remarks
   * The engine of the database.
   * 
   * @example
   * mysql
   */
  dbType?: string;
  /**
   * @remarks
   * The type of the environment to which the database belongs. Valid values:
   * 
   * - product: production environment
   * - dev: development environment
   * - pre: staging environment
   * - test: test environment
   * - sit: system integration testing (SIT) environment
   * - uat: user acceptance testing (UAT) environment
   * - pet: stress testing environment
   * - stag: STAG environment
   * 
   * @example
   * product
   */
  envType?: string;
  /**
   * @remarks
   * Indicates whether the database is a logical database. Valid values:
   * 
   * - **true**: The database is a logical database.
   * - **false**: The database is a physical database.
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The name that is used to search for the database.
   * 
   * @example
   * xxx@xxx:3306
   */
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      dbType: 'DbType',
      envType: 'EnvType',
      logic: 'Logic',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      dbType: 'string',
      envType: 'string',
      logic: 'boolean',
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList extends $tea.Model {
  database?: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase[];
  static names(): { [key: string]: string } {
    return {
      database: 'Database',
    };
  }

  static types(): { [key: string]: any } {
    return {
      database: { 'type': 'array', 'itemType': GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail extends $tea.Model {
  /**
   * @remarks
   * The number of affected rows that is obtained by the precheck.
   * 
   * @example
   * 100
   */
  actualAffectRows?: number;
  /**
   * @remarks
   * The name of the attachment that contains the SQL statements used to change data.
   * 
   * @example
   * xxx
   */
  attachmentName?: string;
  /**
   * @remarks
   * The category of the reason for the data change.
   * 
   * @example
   * test
   */
  classify?: string;
  /**
   * @remarks
   * The estimated number of affected rows.
   * 
   * @example
   * 100
   */
  estimateAffectRows?: number;
  /**
   * @remarks
   * The executed SQL statements.
   * 
   * @example
   * update t1 set name = \\"xxx\\" where id <= 100
   */
  exeSQL?: string;
  /**
   * @remarks
   * Indicates whether the precheck result is ignored. Valid values:
   * 
   * - **true**: The precheck result is ignored.
   * - **false**: The precheck result is not ignored.
   * 
   * @example
   * false
   */
  ignoreAffectRows?: boolean;
  /**
   * @remarks
   * The reason why the precheck result is ignored.
   * 
   * @example
   * test
   */
  ignoreAffectRowsReason?: string;
  /**
   * @remarks
   * The name of the attachment that contains the SQL statements used to roll back the data change.
   * 
   * @example
   * test
   */
  rbAttachmentName?: string;
  /**
   * @remarks
   * The SQL statements used to roll back the data change.
   * 
   * @example
   * empty
   */
  rbSQL?: string;
  /**
   * @remarks
   * The format of the SQL statements used to roll back the data change. Valid values:
   * 
   * - **TEXT**: text
   * - **ATTACHMENT**: attachment
   * 
   * @example
   * text
   */
  rbSQLType?: string;
  /**
   * @remarks
   * The format of the SQL statements used to change data. Valid values:
   * 
   * - **TEXT**: text
   * - **ATTACHMENT**: attachment
   * 
   * @example
   * text
   */
  sqlType?: string;
  static names(): { [key: string]: string } {
    return {
      actualAffectRows: 'ActualAffectRows',
      attachmentName: 'AttachmentName',
      classify: 'Classify',
      estimateAffectRows: 'EstimateAffectRows',
      exeSQL: 'ExeSQL',
      ignoreAffectRows: 'IgnoreAffectRows',
      ignoreAffectRowsReason: 'IgnoreAffectRowsReason',
      rbAttachmentName: 'RbAttachmentName',
      rbSQL: 'RbSQL',
      rbSQLType: 'RbSQLType',
      sqlType: 'SqlType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actualAffectRows: 'number',
      attachmentName: 'string',
      classify: 'string',
      estimateAffectRows: 'number',
      exeSQL: 'string',
      ignoreAffectRows: 'boolean',
      ignoreAffectRowsReason: 'string',
      rbAttachmentName: 'string',
      rbSQL: 'string',
      rbSQLType: 'string',
      sqlType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO extends $tea.Model {
  /**
   * @remarks
   * The status of the precheck. Valid values:
   * 
   * *   **WAITING**: The ticket is pending precheck.
   * *   **RUNNING**: The ticket is being prechecked.
   * *   **SUCCESS**: The ticket passes the precheck.
   * *   **FAIL**: The ticket fails the precheck.
   * 
   * @example
   * SUCCESS
   */
  checkStatus?: string;
  /**
   * @remarks
   * The check step of the precheck. Valid values:
   * 
   * *   **SQL_PARSE**: The system checks the syntax of the SQL statement.
   * *   **SQL_TYPE_CHECK**: The system checks the type of the SQL statement.
   * *   **PERMISSION_CHECK**: The system checks the permissions required for the data change.
   * *   **ROW_CHECK**: The system checks the number of affected rows.
   * 
   * @example
   * PERMISSION_CHECK
   */
  checkStep?: string;
  /**
   * @remarks
   * The message that indicates a check step.
   * 
   * @example
   * tip messsage
   */
  userTip?: string;
  static names(): { [key: string]: string } {
    return {
      checkStatus: 'CheckStatus',
      checkStep: 'CheckStep',
      userTip: 'UserTip',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkStatus: 'string',
      checkStep: 'string',
      userTip: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail extends $tea.Model {
  taskCheckDO?: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO[];
  static names(): { [key: string]: string } {
    return {
      taskCheckDO: 'TaskCheckDO',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskCheckDO: { 'type': 'array', 'itemType': GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail extends $tea.Model {
  configDetail?: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailConfigDetail;
  /**
   * @remarks
   * The information about the database in which data is changed.
   */
  databaseList?: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList;
  /**
   * @remarks
   * The execution mode of the ticket after the ticket is approved. Valid values:
   * 
   * - **COMMITOR**: The data change is performed by the user who submits the ticket.
   * - **AUTO**: The data change is automatically performed after the ticket is approved.
   * - **LAST_AUDITOR**: The data change is performed by the last approver of the ticket.
   * 
   * @example
   * COMMITOR
   */
  execMode?: string;
  /**
   * @remarks
   * The details of the ticket.
   */
  orderDetail?: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail;
  /**
   * @remarks
   * The precheck details of the ticket.
   */
  preCheckDetail?: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail;
  /**
   * @remarks
   * The status of the ticket. Valid values:
   * 
   * - **new**: The ticket is created.
   * - **precheck**: The ticket is being prechecked.
   * - **precheck_fail**: The ticket fails the precheck.
   * - **precheck_success**: The ticket passes the precheck and waits to be submitted for approval.
   * - **toaudit**: The ticket is being reviewed.
   * - **Approved**: The ticket is approved.
   * - **reject**: The ticket is rejected.
   * - **waiting**: The ticket is submitted and waits to be scheduled.
   * - **processing**: The ticket is being executed.
   * - **success**: The ticket is executed.
   * - **closed**: The ticket is closed.
   * 
   * @example
   * approved
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      configDetail: 'ConfigDetail',
      databaseList: 'DatabaseList',
      execMode: 'ExecMode',
      orderDetail: 'OrderDetail',
      preCheckDetail: 'PreCheckDetail',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configDetail: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailConfigDetail,
      databaseList: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList,
      execMode: 'string',
      orderDetail: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail,
      preCheckDetail: GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail,
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail extends $tea.Model {
  /**
   * @remarks
   * The number of rows affected by the SQL statement.
   * 
   * @example
   * 1
   */
  actualAffectRows?: number;
  /**
   * @remarks
   * The time when the task was created.
   * 
   * @example
   * 2021-03-05 15:08:55
   */
  createTime?: string;
  /**
   * @remarks
   * The ID of the SQL task group.
   * 
   * @example
   * 1234235
   */
  DBTaskGroupId?: number;
  /**
   * @remarks
   * The state of the SQL task. Valid values:
   * 
   * *   **INIT**: The SQL task was initialized.
   * *   **PENDING**: The SQL task waited to be run.
   * *   **BE_SCHEDULED**: The SQL task waited to be scheduled.
   * *   **FAIL**: The SQL task failed.
   * *   **SUCCESS**: The SQL task was successful.
   * *   **PAUSE**: The SQL task was paused.
   * *   **DELETE**: The SQL task was deleted.
   * *   **RUNNING**: The SQL task was being run.
   * 
   * @example
   * SUCCESS
   */
  jobStatus?: string;
  static names(): { [key: string]: string } {
    return {
      actualAffectRows: 'ActualAffectRows',
      createTime: 'CreateTime',
      DBTaskGroupId: 'DBTaskGroupId',
      jobStatus: 'jobStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actualAffectRows: 'number',
      createTime: 'string',
      DBTaskGroupId: 'number',
      jobStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCronClearConfigResponseBodyDataCronClearConfig extends $tea.Model {
  /**
   * @remarks
   * The number of times that the task is run.
   * 
   * @example
   * 2
   */
  cronCallTimes?: string;
  /**
   * @remarks
   * The crontab expression that you can use to run the task at a specified time. For more information, see [Crontab expression](https://help.aliyun.com/document_detail/206581.html).
   * 
   * @example
   * 0 0 23 ? * 7,1
   */
  cronFormat?: string;
  /**
   * @remarks
   * The time when the task was last run.
   * 
   * @example
   * 2022-11-18 00:00:00
   */
  cronLastCallStartTime?: string;
  /**
   * @remarks
   * The time when the task is run next time. This parameter is displayed only when the status of the scheduled task is SUCCESS.
   * 
   * @example
   * 2022-11-19 00:00:00
   */
  cronNextCallTime?: string;
  /**
   * @remarks
   * The status of the scheduled task. If this parameter is empty, it indicates the task is not run. Valid values:
   * 
   * *   PAUSE: The task is suspended.
   * *   WAITING: The task is waiting to be run.
   * *   SUCCESS: The task is complete.
   * 
   * @example
   * PAUSE
   */
  cronStatus?: string;
  /**
   * @remarks
   * The number of times that the Optimize Table statement is automatically exeuted. This parameter is valid only when the value of the OptimizeTableAfterEveryClearTimes parameter is greater than 0.
   * 
   * @example
   * 0
   */
  currentClearTaskCount?: number;
  /**
   * @remarks
   * The execution duration of the task. Unit: hours. If the value is 0, it indicates the duration is not specified.
   * 
   * @example
   * 1
   */
  duration?: string;
  /**
   * @remarks
   * Specifies whether to enable automatic execution of the OPTIMIZE TABLE statement. Valid values:
   * 
   * *   0: disables automatic execution
   * *   A number greater than 0: enables automatic execution. The number specifies the number of times that cleanup operations must be performed before the OPTIMIZE TABLE statement is automatically executed.
   * 
   * @example
   * 0
   */
  optimizeTableAfterEveryClearTimes?: number;
  static names(): { [key: string]: string } {
    return {
      cronCallTimes: 'CronCallTimes',
      cronFormat: 'CronFormat',
      cronLastCallStartTime: 'CronLastCallStartTime',
      cronNextCallTime: 'CronNextCallTime',
      cronStatus: 'CronStatus',
      currentClearTaskCount: 'CurrentClearTaskCount',
      duration: 'Duration',
      optimizeTableAfterEveryClearTimes: 'OptimizeTableAfterEveryClearTimes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cronCallTimes: 'string',
      cronFormat: 'string',
      cronLastCallStartTime: 'string',
      cronNextCallTime: 'string',
      cronStatus: 'string',
      currentClearTaskCount: 'number',
      duration: 'string',
      optimizeTableAfterEveryClearTimes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList extends $tea.Model {
  /**
   * @remarks
   * The number of rows affected by the SQL task.
   * 
   * @example
   * 1
   */
  actualAffectRows?: number;
  /**
   * @remarks
   * The time when the SQL task was created.
   * 
   * @example
   * 2021-01-14 10:00:00
   */
  createTime?: string;
  /**
   * @remarks
   * The ID of the SQL task group.
   * 
   * @example
   * 432523
   */
  DBTaskGroupId?: number;
  /**
   * @remarks
   * The state of the SQL task. Valid values:
   * 
   * *   **INIT**: The SQL task was initialized.
   * *   **PENDING**: The SQL task waited to be run.
   * *   **BE_SCHEDULED**: The SQL task waited to be scheduled.
   * *   **FAIL**: The SQL task failed.
   * *   **SUCCESS**: The SQL task was successful.
   * *   **PAUSE**: The SQL task was paused.
   * *   **DELETE**: The SQL task was deleted.
   * *   **RUNNING**: The SQL task was being run.
   * 
   * @example
   * SUCCESS
   */
  jobStatus?: string;
  static names(): { [key: string]: string } {
    return {
      actualAffectRows: 'ActualAffectRows',
      createTime: 'CreateTime',
      DBTaskGroupId: 'DBTaskGroupId',
      jobStatus: 'jobStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actualAffectRows: 'number',
      createTime: 'string',
      DBTaskGroupId: 'number',
      jobStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportDownloadURLResponseBodyDownloadURLResult extends $tea.Model {
  /**
   * @remarks
   * Indicates whether export results are available for download. Valid values:
   * 
   * *   **true**: Export results are available for download.
   * *   **false**: No export results are available for download.
   * 
   * @example
   * true
   */
  hasResult?: boolean;
  /**
   * @remarks
   * The message that indicates an exception.
   * 
   * @example
   * tip message
   */
  tipMessage?: string;
  /**
   * @remarks
   * The download URL of the file that records the export results for the ticket.
   * 
   * @example
   * https://dms-idb-hangzhou.oss-cn-hangzhou.aliyuncs.com/xxx.zip
   */
  URL?: string;
  static names(): { [key: string]: string } {
    return {
      hasResult: 'HasResult',
      tipMessage: 'TipMessage',
      URL: 'URL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hasResult: 'boolean',
      tipMessage: 'string',
      URL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo extends $tea.Model {
  /**
   * @remarks
   * The state of the data export ticket. Valid values:
   * 
   * *   **PRE_CHECKING**: The ticket was being prechecked.
   * *   **PRE_CHECK_SUCCESS**: The ticket passed the precheck.
   * *   **PRE_CHECK_FAIL**: The ticket failed to pass the prechecked.
   * *   **WAITING_APPLY_AUDIT**: The ticket was to be submitted for approval.
   * *   **APPLY_AUDIT_SUCCESS**: The ticket was submitted for approval.
   * *   **ENABLE_EXPORT**: The ticket was approved. Data can be exported.
   * *   **WAITING_EXPORT**: Data was to be scheduled for export.
   * *   **DOING_EXPORT**: Data was being exported.
   * *   **EXPORT_FAIL**: Data failed to be exported.
   * *   **EXPORT_SUCCESS**: Data was exported.
   * 
   * @example
   * EXPORT_SUCCESS
   */
  jobStatus?: string;
  /**
   * @remarks
   * The precheck ID.
   * 
   * @example
   * 123
   */
  preCheckId?: number;
  static names(): { [key: string]: string } {
    return {
      jobStatus: 'JobStatus',
      preCheckId: 'PreCheckId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobStatus: 'string',
      preCheckId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail extends $tea.Model {
  /**
   * @remarks
   * The number of rows that were affected by the SQL statement.
   * 
   * @example
   * 1
   */
  actualAffectRows?: number;
  /**
   * @remarks
   * The category of the reason for the data export.
   * 
   * @example
   * text
   */
  classify?: string;
  /**
   * @remarks
   * The name of the database from which data was exported.
   * 
   * @example
   * xxx@xxx:3306
   */
  database?: string;
  /**
   * @remarks
   * The ID of the database from which data was exported.
   * 
   * @example
   * 123
   */
  dbId?: number;
  /**
   * @remarks
   * The type of the environment to which the database belongs.
   * 
   * @example
   * test
   */
  envType?: string;
  /**
   * @remarks
   * The SQL statement that was executed to export data.
   * 
   * @example
   * select 1
   */
  exeSQL?: string;
  /**
   * @remarks
   * Indicates whether the affected rows are skipped.
   * 
   * @example
   * false
   */
  ignoreAffectRows?: boolean;
  /**
   * @remarks
   * The reason why the affected rows are skipped.
   * 
   * @example
   * empty
   */
  ignoreAffectRowsReason?: string;
  /**
   * @remarks
   * Indicates whether the database is a logical database.
   * 
   * @example
   * false
   */
  logic?: boolean;
  static names(): { [key: string]: string } {
    return {
      actualAffectRows: 'ActualAffectRows',
      classify: 'Classify',
      database: 'Database',
      dbId: 'DbId',
      envType: 'EnvType',
      exeSQL: 'ExeSQL',
      ignoreAffectRows: 'IgnoreAffectRows',
      ignoreAffectRowsReason: 'IgnoreAffectRowsReason',
      logic: 'Logic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actualAffectRows: 'number',
      classify: 'string',
      database: 'string',
      dbId: 'number',
      envType: 'string',
      exeSQL: 'string',
      ignoreAffectRows: 'boolean',
      ignoreAffectRowsReason: 'string',
      logic: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportOrderDetailResponseBodyDataExportOrderDetail extends $tea.Model {
  /**
   * @remarks
   * The information about the ticket.
   */
  keyInfo?: GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo;
  /**
   * @remarks
   * The details of the ticket.
   */
  orderDetail?: GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail;
  static names(): { [key: string]: string } {
    return {
      keyInfo: 'KeyInfo',
      orderDetail: 'OrderDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keyInfo: GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo,
      orderDetail: GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList extends $tea.Model {
  /**
   * @remarks
   * The estimated number of data rows to be affected.
   * 
   * @example
   * 1
   */
  affectRows?: number;
  /**
   * @remarks
   * The SQL statement.
   * 
   * @example
   * SELECT * FROM tmp_table LIMIT 1
   */
  SQL?: string;
  static names(): { [key: string]: string } {
    return {
      affectRows: 'AffectRows',
      SQL: 'SQL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affectRows: 'number',
      SQL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailList extends $tea.Model {
  preCheckDetailList?: GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList[];
  static names(): { [key: string]: string } {
    return {
      preCheckDetailList: 'PreCheckDetailList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      preCheckDetailList: { 'type': 'array', 'itemType': GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataExportPreCheckDetailResponseBodyPreCheckResult extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to skip verification. Valid values:
   * 
   * - true
   * - false
   * 
   * @example
   * true
   */
  ignoreAffectRows?: boolean;
  /**
   * @remarks
   * The list of pre-check details.
   */
  preCheckDetailList?: GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailList;
  static names(): { [key: string]: string } {
    return {
      ignoreAffectRows: 'IgnoreAffectRows',
      preCheckDetailList: 'PreCheckDetailList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ignoreAffectRows: 'boolean',
      preCheckDetailList: GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataImportSQLResponseBodySQLDetail extends $tea.Model {
  /**
   * @remarks
   * The SQL script.
   * 
   * @example
   * insert into t1 values (1);
   */
  execSql?: string;
  static names(): { [key: string]: string } {
    return {
      execSql: 'ExecSql',
    };
  }

  static types(): { [key: string]: any } {
    return {
      execSql: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataTrackJobDegreeResponseBodyJobDegree extends $tea.Model {
  /**
   * @remarks
   * The progress of binary log download. Valid values: 0 to 1. A value of 1 indicates that binary log download is complete.
   * 
   * @example
   * 1
   */
  downloadCompletionDegree?: number;
  /**
   * @remarks
   * The progress of binary log parsing. Valid values: 0 to 1. A value of 1 indicates that binary log parsing is complete.
   * 
   * @example
   * 1
   */
  filterCompletionDegree?: number;
  /**
   * @remarks
   * The status of the data tracking task. Valid values:
   * 
   * *   **INIT**: The task is being initialized.
   * *   **LISTING**: The binary logs are being obtained.
   * *   **LIST_SUCCESS**: The binary logs are successfully obtained.
   * *   **DOWNLOADING**: The binary logs are being downloaded.
   * *   **DOWNLOAD_FAIL**: The binary logs failed to be downloaded.
   * *   **DOWNLOAD_SUCCESS**: The binary logs are successfully downloaded.
   * *   **FILTERING**: The binary logs are being parsed.
   * *   **FILTER_FAIL**: The binary logs failed to be parsed.
   * *   **FILTER_SUCCESS**: The binary logs are successfully parsed.
   * 
   * @example
   * FILTER_SUCCESS
   */
  jobStatus?: string;
  /**
   * @remarks
   * The progress of binary log obtaining. Valid values: 0 to 1. A value of 1 indicates that binary log obtaining is complete.
   * 
   * @example
   * 1
   */
  listCompletionDegree?: number;
  /**
   * @remarks
   * The description of the task status.
   * 
   * @example
   * searching success
   */
  statusDesc?: string;
  static names(): { [key: string]: string } {
    return {
      downloadCompletionDegree: 'DownloadCompletionDegree',
      filterCompletionDegree: 'FilterCompletionDegree',
      jobStatus: 'JobStatus',
      listCompletionDegree: 'ListCompletionDegree',
      statusDesc: 'StatusDesc',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadCompletionDegree: 'number',
      filterCompletionDegree: 'number',
      jobStatus: 'string',
      listCompletionDegree: 'number',
      statusDesc: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataTrackJobTableMetaResponseBodyTableMetaListColumns extends $tea.Model {
  /**
   * @remarks
   * The name of the character set.
   * 
   * @example
   * utf8mb4
   */
  charset?: string;
  /**
   * @remarks
   * The name of the column.
   * 
   * @example
   * claimantno
   */
  columnName?: string;
  /**
   * @remarks
   * The position of the column.
   * 
   * @example
   * 1
   */
  columnPosition?: number;
  /**
   * @remarks
   * The data type of the column. Examples: BIGINT, INT, and VARCHAR.
   * 
   * @example
   * BIGINT
   */
  columnType?: string;
  /**
   * @remarks
   * Indicates whether the column is a virtual column. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * false
   */
  fictive?: boolean;
  static names(): { [key: string]: string } {
    return {
      charset: 'Charset',
      columnName: 'ColumnName',
      columnPosition: 'ColumnPosition',
      columnType: 'ColumnType',
      fictive: 'Fictive',
    };
  }

  static types(): { [key: string]: any } {
    return {
      charset: 'string',
      columnName: 'string',
      columnPosition: 'number',
      columnType: 'string',
      fictive: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataTrackJobTableMetaResponseBodyTableMetaList extends $tea.Model {
  /**
   * @remarks
   * The information about columns.
   */
  columns?: GetDataTrackJobTableMetaResponseBodyTableMetaListColumns[];
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * DB165
   */
  schemaName?: string;
  /**
   * @remarks
   * The name of the table.
   * 
   * @example
   * live_stat
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      columns: 'Columns',
      schemaName: 'SchemaName',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columns: { 'type': 'array', 'itemType': GetDataTrackJobTableMetaResponseBodyTableMetaListColumns },
      schemaName: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail extends $tea.Model {
  /**
   * @remarks
   * The name that is used to search for the database.
   * 
   * @example
   * xxx@yyy:3306
   */
  databaseSearchName?: string;
  /**
   * @remarks
   * The ID of the database.
   * 
   * @example
   * 3431****
   */
  dbId?: number;
  /**
   * @remarks
   * The end time of the time range in which data operations are tracked. The time is in the yyyy-MM-dd HH:mm:ss format.
   * 
   * @example
   * 2023-04-23 10:00:00
   */
  jobEndTime?: string;
  /**
   * @remarks
   * The start time of the time range in which data operations are tracked. The time is in the yyyy-MM-dd HH:mm:ss format.
   * 
   * @example
   * 2023-04-23 00:00:00
   */
  jobStartTime?: string;
  /**
   * @remarks
   * The status of the data tracking task. Valid values:
   * 
   * *   **INIT**: The task is being initialized.
   * *   **LISTING**: The binary logs are being obtained.
   * *   **LIST_SUCCESS**: The binary logs are successfully obtained.
   * *   **DOWNLOADING**: The binary logs are being downloaded.
   * *   **DOWNLOAD_FAIL**: The binary logs failed to be downloaded.
   * *   **DOWNLOAD_SUCCESS**: The binary logs are successfully downloaded.
   * *   **FILTERING**: The binary logs are being parsed.
   * *   **FILTER_FAIL**: The binary logs failed to be parsed.
   * *   **FILTER_SUCCESS**: The binary logs are successfully parsed.
   * 
   * @example
   * FILTER_SUCCESS
   */
  jobStatus?: string;
  /**
   * @remarks
   * Indicates whether the database is a logical database. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * as_task
   */
  schemaName?: string;
  /**
   * @remarks
   * The description of the task status.
   * 
   * @example
   * searching success
   */
  statusDesc?: string;
  /**
   * @remarks
   * The names of the tables for which data operations are tracked.
   */
  tableNames?: string[];
  /**
   * @remarks
   * The types of data operations that are tracked.
   */
  trackTypes?: string[];
  static names(): { [key: string]: string } {
    return {
      databaseSearchName: 'DatabaseSearchName',
      dbId: 'DbId',
      jobEndTime: 'JobEndTime',
      jobStartTime: 'JobStartTime',
      jobStatus: 'JobStatus',
      logic: 'Logic',
      schemaName: 'SchemaName',
      statusDesc: 'StatusDesc',
      tableNames: 'TableNames',
      trackTypes: 'TrackTypes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseSearchName: 'string',
      dbId: 'number',
      jobEndTime: 'string',
      jobStartTime: 'string',
      jobStatus: 'string',
      logic: 'boolean',
      schemaName: 'string',
      statusDesc: 'string',
      tableNames: { 'type': 'array', 'itemType': 'string' },
      trackTypes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseResponseBodyDatabaseOwnerIdList extends $tea.Model {
  ownerIds?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerIds: 'OwnerIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseResponseBodyDatabaseOwnerNameList extends $tea.Model {
  ownerNames?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerNames: 'OwnerNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseResponseBodyDatabase extends $tea.Model {
  /**
   * @remarks
   * The name of the catalog to which the database belongs.
   * 
   * @example
   * def
   */
  catalogName?: string;
  /**
   * @remarks
   * The ID of the database.
   * 
   * @example
   * 984****
   */
  databaseId?: string;
  /**
   * @remarks
   * The type of the database. For more information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
   * 
   * @example
   * mysql
   */
  dbType?: string;
  /**
   * @remarks
   * The ID of the database administrator (DBA).
   * 
   * @example
   * 27****
   */
  dbaId?: string;
  /**
   * @remarks
   * The nickname of the DBA.
   * 
   * @example
   * dba_name
   */
  dbaName?: string;
  /**
   * @remarks
   * The encoding format of the database.
   * 
   * @example
   * utf8mb4
   */
  encoding?: string;
  /**
   * @remarks
   * The type of the environment to which the database belongs. Valid values:
   * 
   * *   **product**: production environment
   * *   **dev**: development environment
   * *   **pre**: staging environment
   * *   **test**: test environment
   * *   **sit**: SIT environment
   * *   **uat**: user acceptance testing (UAT) environment
   * *   **pet**: stress testing environment
   * *   **stag**: STAG environment
   * 
   * @example
   * product
   */
  envType?: string;
  /**
   * @remarks
   * The endpoint that is used to connect to the database.
   * 
   * @example
   * 192.168.XX.XX
   */
  host?: string;
  /**
   * @remarks
   * The alias of the instance.
   * 
   * @example
   * test
   */
  instanceAlias?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * 149****
   */
  instanceId?: string;
  /**
   * @remarks
   * The IDs of the owners of the database.
   */
  ownerIdList?: GetDatabaseResponseBodyDatabaseOwnerIdList;
  /**
   * @remarks
   * The names of the owners of the database.
   */
  ownerNameList?: GetDatabaseResponseBodyDatabaseOwnerNameList;
  /**
   * @remarks
   * The port that is used to connect to the database.
   * 
   * @example
   * 3306
   */
  port?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * mysql
   */
  schemaName?: string;
  /**
   * @remarks
   * The keyword that is used to search for the database.
   * 
   * @example
   * mysql@192.168.XX.XX:3306
   */
  searchName?: string;
  /**
   * @remarks
   * The SID of the database.
   * 
   * >  The value of the parameter is returned only for Oracle databases.
   * 
   * @example
   * test_sid
   */
  sid?: string;
  /**
   * @remarks
   * The status of the database. Valid values:
   * 
   * *   **NORMAL**: The database is running as expected.
   * *   **DISABLE**: The database is disabled.
   * *   **OFFLINE**: The database is unpublished.
   * *   **NOT_EXIST**: The database does not exist.
   * 
   * @example
   * NORMAL
   */
  state?: string;
  static names(): { [key: string]: string } {
    return {
      catalogName: 'CatalogName',
      databaseId: 'DatabaseId',
      dbType: 'DbType',
      dbaId: 'DbaId',
      dbaName: 'DbaName',
      encoding: 'Encoding',
      envType: 'EnvType',
      host: 'Host',
      instanceAlias: 'InstanceAlias',
      instanceId: 'InstanceId',
      ownerIdList: 'OwnerIdList',
      ownerNameList: 'OwnerNameList',
      port: 'Port',
      schemaName: 'SchemaName',
      searchName: 'SearchName',
      sid: 'Sid',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      catalogName: 'string',
      databaseId: 'string',
      dbType: 'string',
      dbaId: 'string',
      dbaName: 'string',
      encoding: 'string',
      envType: 'string',
      host: 'string',
      instanceAlias: 'string',
      instanceId: 'string',
      ownerIdList: GetDatabaseResponseBodyDatabaseOwnerIdList,
      ownerNameList: GetDatabaseResponseBodyDatabaseOwnerNameList,
      port: 'number',
      schemaName: 'string',
      searchName: 'string',
      sid: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigExportTypes extends $tea.Model {
  exportTypes?: string[];
  static names(): { [key: string]: string } {
    return {
      exportTypes: 'ExportTypes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      exportTypes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSQLExtOption extends $tea.Model {
  SQLExtOption?: string[];
  static names(): { [key: string]: string } {
    return {
      SQLExtOption: 'SQLExtOption',
    };
  }

  static types(): { [key: string]: any } {
    return {
      SQLExtOption: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSelectedTables extends $tea.Model {
  selectedTables?: string[];
  static names(): { [key: string]: string } {
    return {
      selectedTables: 'SelectedTables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      selectedTables: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig extends $tea.Model {
  /**
   * @remarks
   * The database name.
   * 
   * @example
   * dmstest
   */
  dbName?: string;
  /**
   * @remarks
   * The type of data that was exported. Valid values:
   * 
   * *   **DATA**: The data of the database was exported.
   * *   **STRUCT**: The schema of the database was exported.
   * *   **DATA_STRUCT**: The data and schema of the database were exported.
   * 
   * @example
   * DATA
   */
  exportContent?: string;
  /**
   * @remarks
   * The type of schema that was exported.
   */
  exportTypes?: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigExportTypes;
  /**
   * @remarks
   * The extension options of the SQL script.
   */
  SQLExtOption?: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSQLExtOption;
  /**
   * @remarks
   * The tables that were exported from the database.
   */
  selectedTables?: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSelectedTables;
  /**
   * @remarks
   * The format in which the database was exported. Valid values:
   * 
   * *   **SQL**
   * *   **CSV**
   * *   **XLSX**
   * 
   * @example
   * SQL
   */
  targetOption?: string;
  static names(): { [key: string]: string } {
    return {
      dbName: 'DbName',
      exportContent: 'ExportContent',
      exportTypes: 'ExportTypes',
      SQLExtOption: 'SQLExtOption',
      selectedTables: 'SelectedTables',
      targetOption: 'TargetOption',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbName: 'string',
      exportContent: 'string',
      exportTypes: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigExportTypes,
      SQLExtOption: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSQLExtOption,
      selectedTables: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSelectedTables,
      targetOption: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo extends $tea.Model {
  /**
   * @remarks
   * The time when the ticket was submitted.
   * 
   * @example
   * 2023-04-13 13:44:59
   */
  auditDate?: string;
  /**
   * @remarks
   * The configuration information about the ticket.
   */
  config?: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig;
  /**
   * @remarks
   * The database ID.
   * 
   * @example
   * 2583****
   */
  dbId?: number;
  /**
   * @remarks
   * The URL that is used to download the export result.
   * 
   * @example
   * https://oss.xxx.com
   */
  downloadURL?: string;
  static names(): { [key: string]: string } {
    return {
      auditDate: 'AuditDate',
      config: 'Config',
      dbId: 'DbId',
      downloadURL: 'DownloadURL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      auditDate: 'string',
      config: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig,
      dbId: 'number',
      downloadURL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail extends $tea.Model {
  /**
   * @remarks
   * The business background information of the database export ticket.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * The user who submitted the ticket.
   * 
   * @example
   * dmsuser
   */
  committer?: string;
  /**
   * @remarks
   * The ID of the user who submitted the ticket. This ID is a user ID and is not the ID of an Alibaba Cloud account.
   * 
   * @example
   * 12***
   */
  committerId?: string;
  /**
   * @remarks
   * The ticket ID.
   * 
   * @example
   * 821****
   */
  id?: number;
  /**
   * @remarks
   * The key information about the ticket.
   */
  keyInfo?: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo;
  /**
   * @remarks
   * The execution logs.
   * 
   * @example
   * 2023-04-12 14:58:32:015 Database Dump Start.
   * 2023-04-12 14:58:32:096 set server side query timeout, sql : set max_execution_time = 0
   */
  log?: string;
  /**
   * @remarks
   * The name that is used to search for the database.
   * 
   * @example
   * test@xxx.xxx.xxx.xxx:3306
   */
  searchName?: string;
  /**
   * @remarks
   * The status description of the ticket.
   * 
   * @example
   * ticket approval
   */
  statusDesc?: string;
  /**
   * @remarks
   * The status description of the workflow.
   * 
   * @example
   * ticket approval
   */
  workflowStatusDesc?: string;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      committer: 'Committer',
      committerId: 'CommitterId',
      id: 'Id',
      keyInfo: 'KeyInfo',
      log: 'Log',
      searchName: 'SearchName',
      statusDesc: 'StatusDesc',
      workflowStatusDesc: 'WorkflowStatusDesc',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      committer: 'string',
      committerId: 'string',
      id: 'number',
      keyInfo: GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo,
      log: 'string',
      searchName: 'string',
      statusDesc: 'string',
      workflowStatusDesc: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDbExportDownloadURLResponseBodyDownloadURLResult extends $tea.Model {
  /**
   * @example
   * true
   */
  hasResult?: boolean;
  /**
   * @example
   * tip message
   */
  tipMessage?: string;
  /**
   * @example
   * https://dms-idb-hangzhou.oss-cn-hangzhou.aliyuncs.com/xxx.zip
   */
  URL?: string;
  static names(): { [key: string]: string } {
    return {
      hasResult: 'HasResult',
      tipMessage: 'TipMessage',
      URL: 'URL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hasResult: 'boolean',
      tipMessage: 'string',
      URL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceResponseBodyInstanceOwnerIdList extends $tea.Model {
  ownerIds?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerIds: 'OwnerIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceResponseBodyInstanceOwnerNameList extends $tea.Model {
  ownerNames?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerNames: 'OwnerNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceResponseBodyInstanceStandardGroup extends $tea.Model {
  /**
   * @remarks
   * The type of the control mode. Valid values:
   * 
   * *   **COMMON**: Security Collaboration
   * *   **NONE_CONTROL**: Flexible Management
   * *   **STABLE**: Stable Change
   * 
   * @example
   * NONE_CONTROL
   */
  groupMode?: string;
  /**
   * @remarks
   * The name of the security rule set corresponding to the control mode.
   * 
   * @example
   * test group name
   */
  groupName?: string;
  static names(): { [key: string]: string } {
    return {
      groupMode: 'GroupMode',
      groupName: 'GroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupMode: 'string',
      groupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceResponseBodyInstance extends $tea.Model {
  /**
   * @remarks
   * The name of the database link for the database instance.
   * 
   * @example
   * test
   */
  dataLinkName?: string;
  /**
   * @remarks
   * The password that is used to log on to the database.
   * 
   * @example
   * ******
   */
  databasePassword?: string;
  /**
   * @remarks
   * The account that is used to log on to the database instance.
   * 
   * @example
   * dbuser
   */
  databaseUser?: string;
  /**
   * @remarks
   * The ID of the database administrator (DBA) for the database instance.
   * 
   * @example
   * 29****
   */
  dbaId?: string;
  /**
   * @remarks
   * The nickname of the DBA for the database instance.
   * 
   * @example
   * dbaname
   */
  dbaNickName?: string;
  /**
   * @remarks
   * Indicates whether the lock-free schema change feature is enabled for the database instance.
   * 
   * @example
   * 0
   */
  ddlOnline?: number;
  /**
   * @remarks
   * The ID of the Elastic Compute Service (ECS) instance on which the database instance is deployed.
   * 
   * @example
   * i-bp124ldpklqz59y3****
   */
  ecsInstanceId?: string;
  /**
   * @remarks
   * The ID of the region in which the database instance resides.
   * 
   * @example
   * cn-beijing
   */
  ecsRegion?: string;
  /**
   * @remarks
   * The type of the environment to which the database instance belongs. Valid values:
   * 
   * *   **product**: production environment
   * *   **dev**: development environment
   * *   **pre**: staging environment
   * *   **test**: test environment
   * *   **sit**: system integration testing (SIT) environment
   * *   **uat**: user acceptance testing (UAT) environment
   * *   **pet**: stress testing environment
   * *   **stag**: STAG environment
   * 
   * @example
   * test
   */
  envType?: string;
  /**
   * @remarks
   * The timeout period for exporting data from the database instance.
   * 
   * @example
   * 86400
   */
  exportTimeout?: number;
  /**
   * @remarks
   * The host address that is used to connect to the database instance.
   * 
   * @example
   * 192.168.XXX.XXX
   */
  host?: string;
  /**
   * @remarks
   * The alias of the database instance.
   * 
   * @example
   * test
   */
  instanceAlias?: string;
  /**
   * @remarks
   * The ID of the database instance.
   * 
   * @example
   * 188****
   */
  instanceId?: string;
  /**
   * @remarks
   * The source of the database instance.
   * 
   * @example
   * ECS_OWN
   */
  instanceSource?: string;
  /**
   * @remarks
   * The type of the database instance.
   * 
   * @example
   * postgresql
   */
  instanceType?: string;
  /**
   * @remarks
   * The IDs of the owners for the database instance.
   */
  ownerIdList?: GetInstanceResponseBodyInstanceOwnerIdList;
  /**
   * @remarks
   * The nicknames of the owners for the database instance.
   */
  ownerNameList?: GetInstanceResponseBodyInstanceOwnerNameList;
  /**
   * @remarks
   * The port number that is used to connect to the database instance.
   * 
   * @example
   * 5432
   */
  port?: number;
  /**
   * @remarks
   * The timeout period for querying data in the database instance.
   * 
   * @example
   * 7200
   */
  queryTimeout?: number;
  /**
   * @remarks
   * The ID of the security rule set for the database instance.
   * 
   * @example
   * 3****
   */
  safeRuleId?: string;
  /**
   * @remarks
   * Whether sensitive data protection is enabled.  Valid values:
   * 
   * - **true**: Enable.
   * 
   * - **false**: Close.
   * 
   * @example
   * false
   */
  sellSitd?: string;
  /**
   * @remarks
   * The SID of the database instance.
   * 
   * @example
   * test
   */
  sid?: string;
  /**
   * @remarks
   * The control mode of the database instance.
   */
  standardGroup?: GetInstanceResponseBodyInstanceStandardGroup;
  /**
   * @remarks
   * The status of the database instance. Valid values:
   * 
   * *   **NORMAL**: normal
   * *   **DISABLE**: disabled
   * 
   * @example
   * NORMAL
   */
  state?: string;
  /**
   * @remarks
   * Indicates whether the cross-database query feature is enabled for the database instance. Valid values:
   * 
   * *   **0**: disabled
   * *   **1**: enabled
   * 
   * @example
   * 0
   */
  useDsql?: number;
  /**
   * @remarks
   * The ID of the virtual private cloud (VPC) to which the database instance belongs.
   * 
   * @example
   * vpc-o6wrloqsdqc9io3mg****
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      dataLinkName: 'DataLinkName',
      databasePassword: 'DatabasePassword',
      databaseUser: 'DatabaseUser',
      dbaId: 'DbaId',
      dbaNickName: 'DbaNickName',
      ddlOnline: 'DdlOnline',
      ecsInstanceId: 'EcsInstanceId',
      ecsRegion: 'EcsRegion',
      envType: 'EnvType',
      exportTimeout: 'ExportTimeout',
      host: 'Host',
      instanceAlias: 'InstanceAlias',
      instanceId: 'InstanceId',
      instanceSource: 'InstanceSource',
      instanceType: 'InstanceType',
      ownerIdList: 'OwnerIdList',
      ownerNameList: 'OwnerNameList',
      port: 'Port',
      queryTimeout: 'QueryTimeout',
      safeRuleId: 'SafeRuleId',
      sellSitd: 'SellSitd',
      sid: 'Sid',
      standardGroup: 'StandardGroup',
      state: 'State',
      useDsql: 'UseDsql',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataLinkName: 'string',
      databasePassword: 'string',
      databaseUser: 'string',
      dbaId: 'string',
      dbaNickName: 'string',
      ddlOnline: 'number',
      ecsInstanceId: 'string',
      ecsRegion: 'string',
      envType: 'string',
      exportTimeout: 'number',
      host: 'string',
      instanceAlias: 'string',
      instanceId: 'string',
      instanceSource: 'string',
      instanceType: 'string',
      ownerIdList: GetInstanceResponseBodyInstanceOwnerIdList,
      ownerNameList: GetInstanceResponseBodyInstanceOwnerNameList,
      port: 'number',
      queryTimeout: 'number',
      safeRuleId: 'string',
      sellSitd: 'string',
      sid: 'string',
      standardGroup: GetInstanceResponseBodyInstanceStandardGroup,
      state: 'string',
      useDsql: 'number',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLhSpaceByNameResponseBodyLakehouseSpace extends $tea.Model {
  /**
   * @remarks
   * The ID of the user who creates the workspace.
   * 
   * @example
   * 51***
   */
  creatorId?: string;
  /**
   * @remarks
   * The description of the workspace.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The ID of the development database.
   * 
   * @example
   * 2435****
   */
  devDbId?: number;
  /**
   * @remarks
   * The type of the database. Valid values:
   * 
   * *   **14**: AnalyticDB for MySQL
   * *   **18**: AnalyticDB for PostgreSQL
   * 
   * @example
   * 14
   */
  dwDbType?: string;
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @remarks
   * Indicates whether the workspace is deleted. Valid values:
   * 
   * *   **true**: The workspace is deleted.
   * *   **false**: The workspace is not deleted.
   * 
   * @example
   * false
   */
  isDeleted?: boolean;
  /**
   * @remarks
   * The mode in which the workspace runs. Valid values:
   * 
   * *   **0**: basic mode
   * *   **1**: standard mode
   * 
   * @example
   * 1
   */
  mode?: number;
  /**
   * @remarks
   * The ID of the production database.
   * 
   * @example
   * 2442****
   */
  prodDbId?: number;
  /**
   * @remarks
   * The configuration of the workspace. Valid values:
   * 
   * *   **skipManualRunCheck**: No security rule check is required in the trial run phase.
   * *   **skipPublishApprove**: No approval is required for publishing and O\\&M.
   * 
   * @example
   * {\\"skipManualRunCheck\\":true,\\"skipPublishApprove\\":true}
   */
  spaceConfig?: string;
  /**
   * @remarks
   * The name of the workspace.
   * 
   * @example
   * test_space
   */
  spaceName?: string;
  /**
   * @remarks
   * The ID of the tenant to which the workspace belongs.
   * 
   * @example
   * 3***
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      creatorId: 'CreatorId',
      description: 'Description',
      devDbId: 'DevDbId',
      dwDbType: 'DwDbType',
      id: 'Id',
      isDeleted: 'IsDeleted',
      mode: 'Mode',
      prodDbId: 'ProdDbId',
      spaceConfig: 'SpaceConfig',
      spaceName: 'SpaceName',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorId: 'string',
      description: 'string',
      devDbId: 'number',
      dwDbType: 'string',
      id: 'number',
      isDeleted: 'boolean',
      mode: 'number',
      prodDbId: 'number',
      spaceConfig: 'string',
      spaceName: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds extends $tea.Model {
  databaseIds?: number[];
  static names(): { [key: string]: string } {
    return {
      databaseIds: 'DatabaseIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseIds: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList extends $tea.Model {
  ownerIds?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerIds: 'OwnerIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList extends $tea.Model {
  ownerNames?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerNames: 'OwnerNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLogicDatabaseResponseBodyLogicDatabase extends $tea.Model {
  /**
   * @remarks
   * The alias of the logical database.
   * 
   * @example
   * test_logic_alias
   */
  alias?: string;
  /**
   * @remarks
   * The ID of the logical database.
   * 
   * @example
   * 1***
   */
  databaseId?: string;
  /**
   * @remarks
   * The IDs of database shards of the logical database.
   */
  databaseIds?: GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds;
  /**
   * @remarks
   * The database engine. For more information about the valid values of the DbType parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
   * 
   * @example
   * POLARDB
   */
  dbType?: string;
  /**
   * @remarks
   * The type of the environment to which the database belongs. Valid values:
   * 
   * *   product: production environment
   * *   dev: development environment
   * *   pre: pre-release environment
   * *   test: test environment
   * *   sit: system integration testing (SIT) environment
   * *   uat: user acceptance testing (UAT) environment
   * *   pet: stress testing environment
   * *   stag: staging environment
   * 
   * @example
   * dev
   */
  envType?: string;
  /**
   * @remarks
   * Indicates whether the database is a logical database. The return value is true.
   * 
   * @example
   * true
   */
  logic?: boolean;
  /**
   * @remarks
   * The IDs of the owners of the logical database.
   */
  ownerIdList?: GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList;
  /**
   * @remarks
   * The names of the owners of the logical database.
   */
  ownerNameList?: GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList;
  /**
   * @remarks
   * The name of the logical database.
   * 
   * @example
   * test_logic_db
   */
  schemaName?: string;
  /**
   * @remarks
   * The name that is used to search for the logical database.
   * 
   * @example
   * test_logic_db[test_logic_alias]
   */
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      databaseId: 'DatabaseId',
      databaseIds: 'DatabaseIds',
      dbType: 'DbType',
      envType: 'EnvType',
      logic: 'Logic',
      ownerIdList: 'OwnerIdList',
      ownerNameList: 'OwnerNameList',
      schemaName: 'SchemaName',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      databaseId: 'string',
      databaseIds: GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds,
      dbType: 'string',
      envType: 'string',
      logic: 'boolean',
      ownerIdList: GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList,
      ownerNameList: GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList,
      schemaName: 'string',
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableColumnResponseBodyColumnList extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the column is an auto-increment column. Valid values:
   * 
   * *   **true**: The column is an auto-increment column.
   * *   **false**: The column is not an auto-increment column.
   * 
   * @example
   * false
   */
  autoIncrement?: boolean;
  /**
   * @remarks
   * The ID of the column.
   * 
   * @example
   * 63513****
   */
  columnId?: string;
  /**
   * @remarks
   * The name of the column.
   * 
   * @example
   * has_promotion
   */
  columnName?: string;
  /**
   * @remarks
   * The data type of the column.
   * 
   * > The return value of a column is not unique, such as **bigint** or **int**.
   * 
   * @example
   * bigint(1)
   */
  columnType?: string;
  /**
   * @remarks
   * The length of the field.
   * 
   * @example
   * 0
   */
  dataLength?: number;
  /**
   * @remarks
   * The precision of the field.
   * 
   * @example
   * 19
   */
  dataPrecision?: number;
  /**
   * @remarks
   * The number of decimal places for the field.
   * 
   * @example
   * 0
   */
  dataScale?: number;
  /**
   * @remarks
   * The description of the column.
   * 
   * @example
   * Whether discounts are provided
   */
  description?: string;
  /**
   * @remarks
   * Indicates whether the field can be empty. Valid values:
   * 
   * *   **true**: The field can be empty.
   * *   **false**: The field cannot be empty.
   * 
   * @example
   * false
   */
  nullable?: boolean;
  /**
   * @remarks
   * The position of the field in the table.
   * 
   * @example
   * 1
   */
  position?: number;
  /**
   * @remarks
   * Indicates whether the field is the primary key. Valid values:
   * 
   * *   **true**: The field is the primary key.
   * *   **false**: The field is not the primary key.
   * 
   * @example
   * true
   */
  primaryKey?: string;
  /**
   * @remarks
   * The sensitivity level of the column. Valid values:
   * 
   * *   **INNER**: The column is not sensitive.
   * *   **SENSITIVE**: The column is sensitive.
   * *   **CONFIDENTIAL**: The column is confidential.
   * 
   * > For more information, see [Sensitivity levels of columns](https://help.aliyun.com/document_detail/66091.html).
   * 
   * @example
   * INNER
   */
  securityLevel?: string;
  static names(): { [key: string]: string } {
    return {
      autoIncrement: 'AutoIncrement',
      columnId: 'ColumnId',
      columnName: 'ColumnName',
      columnType: 'ColumnType',
      dataLength: 'DataLength',
      dataPrecision: 'DataPrecision',
      dataScale: 'DataScale',
      description: 'Description',
      nullable: 'Nullable',
      position: 'Position',
      primaryKey: 'PrimaryKey',
      securityLevel: 'SecurityLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoIncrement: 'boolean',
      columnId: 'string',
      columnName: 'string',
      columnType: 'string',
      dataLength: 'number',
      dataPrecision: 'number',
      dataScale: 'number',
      description: 'string',
      nullable: 'boolean',
      position: 'number',
      primaryKey: 'string',
      securityLevel: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableDetailInfoResponseBodyDetailInfoColumnList extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the column is an auto-increment column. Valid values:
   * 
   * *   true: The column is an auto-increment column.
   * *   false: The column is not an auto-increment column.
   * 
   * @example
   * true
   */
  autoIncrement?: boolean;
  /**
   * @remarks
   * The ID of the column.
   * 
   * @example
   * 191234849
   */
  columnId?: string;
  /**
   * @remarks
   * The name of the column.
   * 
   * @example
   * id
   */
  columnName?: string;
  /**
   * @remarks
   * The data type of the column. Examples: Bigint, Int, and Varchar.
   * 
   * @example
   * bigint(20) unsigned
   */
  columnType?: string;
  /**
   * @remarks
   * The length of the field.
   * 
   * @example
   * 0
   */
  dataLength?: number;
  /**
   * @remarks
   * The precision of the field.
   * 
   * @example
   * 0
   */
  dataPrecision?: number;
  /**
   * @remarks
   * The scale of the column.
   * 
   * @example
   * 0
   */
  dataScale?: number;
  /**
   * @remarks
   * The description of the column.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * Indicates whether the column is nullable. Valid values:
   * 
   * *   true: The column is nullable.
   * *   false: The column is not nullable.
   * 
   * @example
   * false
   */
  nullable?: boolean;
  /**
   * @remarks
   * The position of the field in the table.
   * 
   * @example
   * 1
   */
  position?: string;
  static names(): { [key: string]: string } {
    return {
      autoIncrement: 'AutoIncrement',
      columnId: 'ColumnId',
      columnName: 'ColumnName',
      columnType: 'ColumnType',
      dataLength: 'DataLength',
      dataPrecision: 'DataPrecision',
      dataScale: 'DataScale',
      description: 'Description',
      nullable: 'Nullable',
      position: 'Position',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoIncrement: 'boolean',
      columnId: 'string',
      columnName: 'string',
      columnType: 'string',
      dataLength: 'number',
      dataPrecision: 'number',
      dataScale: 'number',
      description: 'string',
      nullable: 'boolean',
      position: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableDetailInfoResponseBodyDetailInfoIndexList extends $tea.Model {
  /**
   * @remarks
   * The index column.
   */
  indexColumns?: string[];
  /**
   * @remarks
   * The ID of the index.
   * 
   * @example
   * 123
   */
  indexId?: string;
  /**
   * @remarks
   * The name of the index.
   * 
   * @example
   * PRIMARY
   */
  indexName?: string;
  /**
   * @remarks
   * The type of the index. Examples: Primary, Unique, and Normal.
   * 
   * @example
   * Primary
   */
  indexType?: string;
  /**
   * @remarks
   * Indicates whether the index is unique. Valid values:
   * 
   * *   true: The index is unique.
   * *   false: The index is not unique.
   * 
   * @example
   * false
   */
  unique?: boolean;
  static names(): { [key: string]: string } {
    return {
      indexColumns: 'IndexColumns',
      indexId: 'IndexId',
      indexName: 'IndexName',
      indexType: 'IndexType',
      unique: 'Unique',
    };
  }

  static types(): { [key: string]: any } {
    return {
      indexColumns: { 'type': 'array', 'itemType': 'string' },
      indexId: 'string',
      indexName: 'string',
      indexType: 'string',
      unique: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableDetailInfoResponseBodyDetailInfo extends $tea.Model {
  /**
   * @remarks
   * The columns in the table.
   */
  columnList?: GetMetaTableDetailInfoResponseBodyDetailInfoColumnList[];
  /**
   * @remarks
   * The list of indexes.
   */
  indexList?: GetMetaTableDetailInfoResponseBodyDetailInfoIndexList[];
  static names(): { [key: string]: string } {
    return {
      columnList: 'ColumnList',
      indexList: 'IndexList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnList: { 'type': 'array', 'itemType': GetMetaTableDetailInfoResponseBodyDetailInfoColumnList },
      indexList: { 'type': 'array', 'itemType': GetMetaTableDetailInfoResponseBodyDetailInfoIndexList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail extends $tea.Model {
  /**
   * @remarks
   * The cleanup policy of the original table after the cut-over. Valid values:
   * 
   * *   **DROP**: Invalid original tables are deleted.
   * *   **MOVE**: Invalid original tables are moved to the test database. You can delete the tables manually.
   * *   **NOTHING**: Invalid original tables are retained in the original database. You can delete the tables manually.
   * 
   * @example
   * DROP
   */
  cleanStrategy?: string;
  /**
   * @remarks
   * The policy of full replication. Valid values:
   * 
   * *   **AUTO**: DMS dynamically adjusts the chunk size based on the performance of the database. Tables are locked for less than 1.5 seconds during a single replication operation.
   * *   **RUNNING**: DMS uses the specified value of the CopyChunkSize parameter. The valid value of the CopyChunkSize parameter ranges from 1 to 60000. If you set this parameter to RUNNING, you must specify the CopyChunkSize parameter.
   * 
   * @example
   * AUTO
   */
  copyChunkMode?: string;
  /**
   * @remarks
   * The size of each chunk that is used to replicate data. This parameter is used to specify the size of each chunk. A larger chunk size increases the replication efficiency and decreases the business performance.
   * 
   * > During full replication, the original table is divided into N small chunks and each chunk is replicated to the temporary table one by one. By default, DMS dynamically adjusts the size of each chunk.
   * 
   * @example
   * 1000
   */
  copyChunkSize?: number;
  /**
   * @remarks
   * The actual amount of data replicated from the original table in the lock-free change operation.
   * 
   * @example
   * 9
   */
  copyCount?: number;
  /**
   * @remarks
   * The estimated total number of rows of the data. The value is obtained from the statistical data in the information_schema database. In most cases, the estimated total number of rows is smaller than the actual number of rows in a table.
   * 
   * @example
   * 10
   */
  copyTotal?: number;
  /**
   * @remarks
   * The number of retries when the cut-over fails.
   * 
   * @example
   * 3
   */
  cutoverFailRetryTimes?: number;
  /**
   * @remarks
   * The maximum period of time that a table can be locked during cut-over. Unit: seconds.
   * 
   * @example
   * 2
   */
  cutoverLockTimeSeconds?: number;
  /**
   * @remarks
   * The end of the time window of the cut-over operation. This value is at least 30 minutes later than the CutoverWindowStartTime parameter. Default value: 23:59:59
   * 
   * @example
   * 13:00:00
   */
  cutoverWindowEndTime?: string;
  /**
   * @remarks
   * The beginning of the time window of the cut-over operation. Default value: 00:00:00. This parameter controls the time window of the cut-over. Cut-over can be performed only when the cut-over conditions are met and the time is within the specified time window. If the time is not within the time window, the cut-over operation is not performed until the time reaches the beginning of the time window.
   * 
   * @example
   * 12:00:00
   */
  cutoverWindowStartTime?: string;
  /**
   * @remarks
   * The replay latency of DMS. Unit: seconds. The replay latency is the period of time that is taken to replay the binary logs of the table to the temporary table. The latency does not indicate the data migration latency between a primary database and a secondary database.
   * 
   * @example
   * 0
   */
  delaySeconds?: number;
  /**
   * @remarks
   * The state of the task. Valid values:
   * 
   * *   **INIT**: The task is being initialized.
   * *   **SUCCESS**: The task is complete.
   * *   **RUNNING**: The task is being executed.
   * *   **WAITING_CUTOVER**: The task is waiting for cut-over.
   * *   **RESTARTING**: The task is restarting.
   * *   **PAUSE**: The task is suspended.
   * *   **UNSUPPORTED**: The task is not supported.
   * *   **CANCELED**: The task is canceled.
   * *   **FAIL**: The task failed.
   * *   **INTERRUPT**: The task is interrupted.
   * 
   * @example
   * SUCCESS
   */
  jobStatus?: string;
  /**
   * @remarks
   * The estimated execution progress. The actual progress is subject to the task status.
   * 
   * @example
   * 90%
   */
  progressRatio?: string;
  /**
   * @remarks
   * The description of the task status.
   * 
   * @example
   * Success
   */
  statusDesc?: string;
  static names(): { [key: string]: string } {
    return {
      cleanStrategy: 'CleanStrategy',
      copyChunkMode: 'CopyChunkMode',
      copyChunkSize: 'CopyChunkSize',
      copyCount: 'CopyCount',
      copyTotal: 'CopyTotal',
      cutoverFailRetryTimes: 'CutoverFailRetryTimes',
      cutoverLockTimeSeconds: 'CutoverLockTimeSeconds',
      cutoverWindowEndTime: 'CutoverWindowEndTime',
      cutoverWindowStartTime: 'CutoverWindowStartTime',
      delaySeconds: 'DelaySeconds',
      jobStatus: 'JobStatus',
      progressRatio: 'ProgressRatio',
      statusDesc: 'StatusDesc',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cleanStrategy: 'string',
      copyChunkMode: 'string',
      copyChunkSize: 'number',
      copyCount: 'number',
      copyTotal: 'number',
      cutoverFailRetryTimes: 'number',
      cutoverLockTimeSeconds: 'number',
      cutoverWindowEndTime: 'string',
      cutoverWindowStartTime: 'string',
      delaySeconds: 'number',
      jobStatus: 'string',
      progressRatio: 'string',
      statusDesc: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpLogResponseBodyOpLogDetailsOpLogDetail extends $tea.Model {
  /**
   * @remarks
   * The endpoint of the database instance.
   * 
   * > 
   * 
   * *   This parameter is valid only for database instances of the LocalInstance type.
   * 
   * *   This parameter is valid only for operations on the functional modules related to tasks.
   * 
   * @example
   * dmstest_prod_database@dmstest.rds... [Test instance]
   */
  database?: string;
  /**
   * @remarks
   * The functional module for which the operation log is queried.
   * 
   * @example
   * SECURITY_RULE
   */
  module?: string;
  /**
   * @remarks
   * The details of the operation.
   * 
   * @example
   * SELECT * FROM `orders` \\n LIMIT 20
   */
  opContent?: string;
  /**
   * @remarks
   * The time when the operation was performed.
   * 
   * @example
   * 2022-03-28 16:45:19
   */
  opTime?: string;
  /**
   * @remarks
   * The ID of the user who performed the operation.
   * 
   * @example
   * 51****
   */
  opUserId?: number;
  /**
   * @remarks
   * The ID of the ticket or task.
   * 
   * >  This parameter is valid only for operations on the functional modules related to tasks and the task management module in system management.
   * 
   * @example
   * 509****
   */
  orderId?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 22275482072787****
   */
  userId?: string;
  /**
   * @remarks
   * The display name of the user.
   * 
   * @example
   * test_name
   */
  userNick?: string;
  static names(): { [key: string]: string } {
    return {
      database: 'Database',
      module: 'Module',
      opContent: 'OpContent',
      opTime: 'OpTime',
      opUserId: 'OpUserId',
      orderId: 'OrderId',
      userId: 'UserId',
      userNick: 'UserNick',
    };
  }

  static types(): { [key: string]: any } {
    return {
      database: 'string',
      module: 'string',
      opContent: 'string',
      opTime: 'string',
      opUserId: 'number',
      orderId: 'number',
      userId: 'string',
      userNick: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpLogResponseBodyOpLogDetails extends $tea.Model {
  opLogDetail?: GetOpLogResponseBodyOpLogDetailsOpLogDetail[];
  static names(): { [key: string]: string } {
    return {
      opLogDetail: 'OpLogDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      opLogDetail: { 'type': 'array', 'itemType': GetOpLogResponseBodyOpLogDetailsOpLogDetail },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList extends $tea.Model {
  userIds?: string[];
  static names(): { [key: string]: string } {
    return {
      userIds: 'UserIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList extends $tea.Model {
  userNicks?: string[];
  static names(): { [key: string]: string } {
    return {
      userNicks: 'UserNicks',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userNicks: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOrderBaseInfoResponseBodyOrderBaseInfo extends $tea.Model {
  /**
   * @remarks
   * The Key of the ticket attachment. This information is returned only when an attachment is uploaded when a ticket is created.
   * 
   * @example
   * upload_order_info_856887_f356366f-f0f8-42fc-ba57-4a509303e814_18072d8a9bce876e3073bc655c2865f.png
   */
  attachmentKey?: string;
  /**
   * @remarks
   * The remarks of the ticket.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * The applicant.
   * 
   * @example
   * xxx
   */
  committer?: string;
  /**
   * @remarks
   * The ID of the applicant. Note: The ID is different from the Alibaba Cloud account ID of the applicant.
   * 
   * @example
   * 1
   */
  committerId?: number;
  /**
   * @remarks
   * The time when the ticket was created.
   * 
   * @example
   * 2019-10-10 00:00:00
   */
  createTime?: string;
  /**
   * @remarks
   * The time when the ticket was last modified.
   * 
   * @example
   * 2019-10-10 00:00:00
   */
  lastModifyTime?: string;
  /**
   * @remarks
   * The ID of the ticket.
   * 
   * @example
   * 12345
   */
  orderId?: number;
  /**
   * @remarks
   * The original file name of the ticket attachment. This information is returned only when an attachment is uploaded when a ticket is created.
   * 
   * @example
   * 18072d8a9bce876e3073bc655c2865f.png
   */
  originAttachmentName?: string;
  /**
   * @remarks
   * The type of the ticket. For more information about the value of this parameter, see the request parameters of the [CreateOrder](https://help.aliyun.com/document_detail/465865.html) operation.
   * 
   * @example
   * DC_COMMON
   */
  pluginType?: string;
  /**
   * @remarks
   * The IDs of the operators that are related to the ticket.
   */
  relatedUserList?: GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList;
  /**
   * @remarks
   * The nicknames of the operators that are related to the ticket.
   */
  relatedUserNickList?: GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList;
  /**
   * @remarks
   * The status code of the ticket. Valid values:
   * 
   * *   **new**: The ticket is created.
   * *   **toaudit**: The ticket is being reviewed.
   * *   **Approved**: The ticket is approved.
   * *   **reject**: The ticket is rejected.
   * *   **processing**: The ticket is being executed.
   * *   **success**: The ticket is executed.
   * *   **closed**: The ticket is closed.
   * 
   * @example
   * success
   */
  statusCode?: string;
  /**
   * @remarks
   * The description of the status.
   * 
   * @example
   * success
   */
  statusDesc?: string;
  /**
   * @remarks
   * The ID of the approval process.
   * 
   * @example
   * 1
   */
  workflowInstanceId?: number;
  /**
   * @remarks
   * The description of the approval process.
   * 
   * @example
   * approved
   */
  workflowStatusDesc?: string;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      comment: 'Comment',
      committer: 'Committer',
      committerId: 'CommitterId',
      createTime: 'CreateTime',
      lastModifyTime: 'LastModifyTime',
      orderId: 'OrderId',
      originAttachmentName: 'OriginAttachmentName',
      pluginType: 'PluginType',
      relatedUserList: 'RelatedUserList',
      relatedUserNickList: 'RelatedUserNickList',
      statusCode: 'StatusCode',
      statusDesc: 'StatusDesc',
      workflowInstanceId: 'WorkflowInstanceId',
      workflowStatusDesc: 'WorkflowStatusDesc',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      comment: 'string',
      committer: 'string',
      committerId: 'number',
      createTime: 'string',
      lastModifyTime: 'string',
      orderId: 'number',
      originAttachmentName: 'string',
      pluginType: 'string',
      relatedUserList: GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList,
      relatedUserNickList: GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList,
      statusCode: 'string',
      statusDesc: 'string',
      workflowInstanceId: 'number',
      workflowStatusDesc: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail extends $tea.Model {
  /**
   * @remarks
   * The type of the database engine.
   * 
   * @example
   * MYSQL
   */
  dbType?: string;
  /**
   * @remarks
   * The type of the environment to which the instance belongs. For more information, see [Change the environment type of an instance](https://help.aliyun.com/document_detail/163309.html).
   * 
   * @example
   * PRODUCT
   */
  envType?: string;
  /**
   * @remarks
   * The IDs of the original owners.
   */
  ownerIds?: number[];
  /**
   * @remarks
   * The nicknames of the owners.
   */
  ownerNickNames?: string[];
  /**
   * @remarks
   * The search name of the resource.
   * 
   * @example
   * yuyangtest
   */
  searchName?: string;
  /**
   * @remarks
   * The name of the table.
   * 
   * > : This parameter is returned when you submit a Database-OWNER ticket.
   * 
   * @example
   * test
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      dbType: 'DbType',
      envType: 'EnvType',
      ownerIds: 'OwnerIds',
      ownerNickNames: 'OwnerNickNames',
      searchName: 'SearchName',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbType: 'string',
      envType: 'string',
      ownerIds: { 'type': 'array', 'itemType': 'number' },
      ownerNickNames: { 'type': 'array', 'itemType': 'string' },
      searchName: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the database is a logical database. Valid values:
   * 
   * *   **true**: The instance is a logical database.
   * *   **false**: The instance is not a logical database.
   * 
   * @example
   * true
   */
  logic?: boolean;
  /**
   * @remarks
   * The details of the resource.
   */
  resourceDetail?: GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail;
  /**
   * @remarks
   * The ID of the resource.
   * 
   * @example
   * 12345
   */
  targetId?: string;
  static names(): { [key: string]: string } {
    return {
      logic: 'Logic',
      resourceDetail: 'ResourceDetail',
      targetId: 'TargetId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logic: 'boolean',
      resourceDetail: GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail,
      targetId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail extends $tea.Model {
  /**
   * @remarks
   * The type of the submitted ticket. Valid values:
   * 
   * *   **INSTANCE**: the ticket that applies for the permissions to be an instance owner
   * *   **DB**: the ticket that applies for the permissions to be a database owner
   * *   **TABLE**: the ticket that applies for the permissions to be a table owner
   * 
   * @example
   * DB
   */
  applyType?: string;
  /**
   * @remarks
   * The details of the requested resource.
   */
  resources?: GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources[];
  static names(): { [key: string]: string } {
    return {
      applyType: 'ApplyType',
      resources: 'Resources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyType: 'string',
      resources: { 'type': 'array', 'itemType': GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPagedInstanceResponseBodyDataInstance extends $tea.Model {
  /**
   * @example
   * 2023-05-14 16:00:57
   */
  businessTime?: string;
  /**
   * @example
   * 3
   */
  checkStatus?: number;
  /**
   * @example
   * 33753
   */
  dagId?: number;
  /**
   * @example
   * false
   */
  delete?: string;
  /**
   * @example
   * 2023-04-23 10:23:20
   */
  endTime?: string;
  /**
   * @example
   * 2023-03-28 10:50:45
   */
  gmtCreate?: string;
  /**
   * @example
   * 2023-04-18 15:28:16
   */
  gmtModified?: string;
  /**
   * @example
   * 6851
   */
  historyDagId?: number;
  /**
   * @example
   * 24271
   */
  id?: number;
  /**
   * @example
   * {nodes":[11694,11695]"}
   */
  lastRunningContext?: string;
  msg?: string;
  /**
   * @example
   * 1
   */
  status?: number;
  /**
   * @example
   * 1
   */
  taskType?: number;
  /**
   * @example
   * 3406
   */
  tenantId?: string;
  /**
   * @example
   * 1
   */
  triggerType?: number;
  /**
   * @example
   * 1
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      businessTime: 'BusinessTime',
      checkStatus: 'CheckStatus',
      dagId: 'DagId',
      delete: 'Delete',
      endTime: 'EndTime',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      historyDagId: 'HistoryDagId',
      id: 'Id',
      lastRunningContext: 'LastRunningContext',
      msg: 'Msg',
      status: 'Status',
      taskType: 'TaskType',
      tenantId: 'TenantId',
      triggerType: 'TriggerType',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessTime: 'string',
      checkStatus: 'number',
      dagId: 'number',
      delete: 'string',
      endTime: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      historyDagId: 'number',
      id: 'number',
      lastRunningContext: 'string',
      msg: 'string',
      status: 'number',
      taskType: 'number',
      tenantId: 'string',
      triggerType: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPagedInstanceResponseBodyData extends $tea.Model {
  instance?: GetPagedInstanceResponseBodyDataInstance[];
  static names(): { [key: string]: string } {
    return {
      instance: 'Instance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instance: { 'type': 'array', 'itemType': GetPagedInstanceResponseBodyDataInstance },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo extends $tea.Model {
  /**
   * @remarks
   * The name of the column.
   * 
   * @example
   * test_col
   */
  columnName?: string;
  /**
   * @remarks
   * The name of the table.
   * 
   * @example
   * test_tb
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo extends $tea.Model {
  /**
   * @remarks
   * The database ID.
   * 
   * @example
   * 12345
   */
  dbId?: number;
  /**
   * @remarks
   * The type of the database engine.
   * 
   * @example
   * MySQL
   */
  dbType?: string;
  /**
   * @remarks
   * The type of the environment to which the instance belongs. For more information, see [Change the environment type of an instance](https://help.aliyun.com/document_detail/163309.html).
   * 
   * @example
   * product
   */
  envType?: string;
  /**
   * @remarks
   * Indicates whether the database is a logical database. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The IDs of the owners of the database.
   */
  ownerIds?: number[];
  /**
   * @remarks
   * The nicknames of the owners of the database.
   */
  ownerNickNames?: string[];
  /**
   * @remarks
   * The name that is used to search for the database.
   * 
   * @example
   * test@xxxx:3306test
   */
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      dbType: 'DbType',
      envType: 'EnvType',
      logic: 'Logic',
      ownerIds: 'OwnerIds',
      ownerNickNames: 'OwnerNickNames',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      dbType: 'string',
      envType: 'string',
      logic: 'boolean',
      ownerIds: { 'type': 'array', 'itemType': 'number' },
      ownerNickNames: { 'type': 'array', 'itemType': 'string' },
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo extends $tea.Model {
  /**
   * @remarks
   * The type of the database engine.
   * 
   * @example
   * MySQL
   */
  dbType?: string;
  /**
   * @remarks
   * The ID of the database administrator (DBA) of the instance.
   * 
   * @example
   * 12345
   */
  dbaId?: number;
  /**
   * @remarks
   * The nickname of the DBA of the instance.
   * 
   * @example
   * test_dba
   */
  dbaNickName?: string;
  /**
   * @remarks
   * The type of the environment to which the instance belongs. For more information, see [Change the environment type of an instance](https://help.aliyun.com/document_detail/163309.html).
   * 
   * @example
   * product
   */
  envType?: string;
  /**
   * @remarks
   * The endpoint of the instance.
   * 
   * @example
   * xxxx
   */
  host?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * 12345
   */
  instanceId?: string;
  /**
   * @remarks
   * The IDs of the owners of the instance.
   */
  ownerIds?: number[];
  /**
   * @remarks
   * The nicknames of the owners of the instance.
   */
  ownerNickName?: string[];
  /**
   * @remarks
   * The port that is used to connect to the instance.
   * 
   * @example
   * 3306
   */
  port?: number;
  /**
   * @remarks
   * The name that is used to search for the instance.
   * 
   * @example
   * xxxx:3306
   */
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      dbType: 'DbType',
      dbaId: 'DbaId',
      dbaNickName: 'DbaNickName',
      envType: 'EnvType',
      host: 'Host',
      instanceId: 'InstanceId',
      ownerIds: 'OwnerIds',
      ownerNickName: 'OwnerNickName',
      port: 'Port',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbType: 'string',
      dbaId: 'number',
      dbaNickName: 'string',
      envType: 'string',
      host: 'string',
      instanceId: 'string',
      ownerIds: { 'type': 'array', 'itemType': 'number' },
      ownerNickName: { 'type': 'array', 'itemType': 'string' },
      port: 'number',
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo extends $tea.Model {
  /**
   * @remarks
   * The name of the table.
   * 
   * @example
   * test_tb
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources extends $tea.Model {
  /**
   * @remarks
   * The information about the column.
   */
  columnInfo?: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo;
  /**
   * @remarks
   * The information about the database.
   */
  databaseInfo?: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo;
  /**
   * @remarks
   * The information about the instance.
   */
  instanceInfo?: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo;
  /**
   * @remarks
   * The information about the table.
   */
  tableInfo?: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo;
  static names(): { [key: string]: string } {
    return {
      columnInfo: 'ColumnInfo',
      databaseInfo: 'DatabaseInfo',
      instanceInfo: 'InstanceInfo',
      tableInfo: 'TableInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnInfo: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo,
      databaseInfo: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo,
      instanceInfo: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo,
      tableInfo: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail extends $tea.Model {
  /**
   * @remarks
   * The type of objects on which you apply for permissions. Valid values:
   * 
   * *   **DB**: database
   * *   **TAB**: table
   * *   **COL**: column
   * *   **INSTANT**: instance
   * 
   * @example
   * DB
   */
  applyType?: string;
  /**
   * @remarks
   * The type of the permissions that you apply for. Valid values:
   * 
   * *   **1**: the permissions to query information.
   * *   **2**: the permissions to export information.
   * *   **3**: the permissions to query and export information.
   * *   **4**: the permissions to modify information.
   * *   **5**: the permissions to query and modify information.
   * *   **6**: the permissions to export and modify information.
   * *   **7**: the permissions to query, export, and modify information.
   * *   **8**: the permissions to log on to the database.
   * 
   * @example
   * 7
   */
  permType?: number;
  /**
   * @remarks
   * The list of resources.
   */
  resources?: GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources[];
  /**
   * @remarks
   * The validity duration of the permissions. Unit: seconds.
   * 
   * @example
   * 3600
   */
  seconds?: number;
  static names(): { [key: string]: string } {
    return {
      applyType: 'ApplyType',
      permType: 'PermType',
      resources: 'Resources',
      seconds: 'Seconds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyType: 'string',
      permType: 'number',
      resources: { 'type': 'array', 'itemType': GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources },
      seconds: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList extends $tea.Model {
  ownerIds?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerIds: 'OwnerIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList extends $tea.Model {
  ownerNames?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerNames: 'OwnerNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPhysicalDatabaseResponseBodyDatabase extends $tea.Model {
  /**
   * @remarks
   * The name of the catalog to which the database belongs.
   * 
   * > : If the database is a PostgreSQL database, the name of the database is displayed.
   * 
   * @example
   * def
   */
  catalogName?: string;
  /**
   * @remarks
   * The ID of the physical database.
   * 
   * @example
   * 43125312
   */
  databaseId?: string;
  /**
   * @remarks
   * The type of the database engine.
   * 
   * @example
   * mysql
   */
  dbType?: string;
  /**
   * @remarks
   * The user ID of the DBA in the destination database.
   * 
   * @example
   * 43253
   */
  dbaId?: string;
  /**
   * @remarks
   * The nickname of the database administrator (DBA) in the destination database.
   * 
   * @example
   * dmstest
   */
  dbaName?: string;
  /**
   * @remarks
   * The encoding format of the database.
   * 
   * @example
   * utf8mb4
   */
  encoding?: string;
  /**
   * @remarks
   * The type of the environment to which the database belongs. For more information, see [Change the environment type of an instance](https://help.aliyun.com/document_detail/163309.html).
   * 
   * @example
   * product
   */
  envType?: string;
  /**
   * @remarks
   * The endpoint that is used to connect to the database.
   * 
   * @example
   * rm-xxxab3r272.mysql.rds.aliyuncs.com
   */
  host?: string;
  /**
   * @remarks
   * The alias of the database instance.
   * 
   * @example
   * test
   */
  instanceAlias?: string;
  /**
   * @remarks
   * The instance ID of the destination database.
   * 
   * @example
   * 43215325
   */
  instanceId?: string;
  /**
   * @remarks
   * The user IDs of the database owners.
   */
  ownerIdList?: GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList;
  /**
   * @remarks
   * The nicknames of the database owners.
   */
  ownerNameList?: GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList;
  /**
   * @remarks
   * The port that is used to connect to the database.
   * 
   * @example
   * 3306
   */
  port?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * > : If the database is a PostgreSQL database, the name of the mode is displayed.
   * 
   * @example
   * dmstest
   */
  schemaName?: string;
  /**
   * @remarks
   * The name that is used for searching the database.
   * 
   * @example
   * dmstest@rm-xxxab3r272.mysql.rds.aliyuncs.com:3306
   */
  searchName?: string;
  /**
   * @remarks
   * The system ID (SID) of the database.
   * 
   * > : The value of the parameter is returned only for Oracle databases.
   * 
   * @example
   * def
   */
  sid?: string;
  /**
   * @remarks
   * The state of the database. Valid values:
   * 
   * *   **NORMAL**: The database is normal.
   * *   **DISABLE**: The database is disabled.
   * *   **OFFLINE**: The database is unpublished.
   * *   **NOT_EXIST**: The database does not exist.
   * 
   * @example
   * NORMAL
   */
  state?: string;
  static names(): { [key: string]: string } {
    return {
      catalogName: 'CatalogName',
      databaseId: 'DatabaseId',
      dbType: 'DbType',
      dbaId: 'DbaId',
      dbaName: 'DbaName',
      encoding: 'Encoding',
      envType: 'EnvType',
      host: 'Host',
      instanceAlias: 'InstanceAlias',
      instanceId: 'InstanceId',
      ownerIdList: 'OwnerIdList',
      ownerNameList: 'OwnerNameList',
      port: 'Port',
      schemaName: 'SchemaName',
      searchName: 'SearchName',
      sid: 'Sid',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      catalogName: 'string',
      databaseId: 'string',
      dbType: 'string',
      dbaId: 'string',
      dbaName: 'string',
      encoding: 'string',
      envType: 'string',
      host: 'string',
      instanceAlias: 'string',
      instanceId: 'string',
      ownerIdList: GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList,
      ownerNameList: GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList,
      port: 'number',
      schemaName: 'string',
      searchName: 'string',
      sid: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProxyAccessResponseBodyProxyAccess extends $tea.Model {
  /**
   * @remarks
   * The username of the database account that is authorized to enable the secure access proxy feature for an instance.
   * 
   * @example
   * hObpgEXoca42q***
   */
  accessId?: string;
  /**
   * @remarks
   * The time when the user is authorized to enable the secure access proxy feature for an instance.
   * 
   * @example
   * 1643034647
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The username of the independent database account.
   * 
   * @example
   * ***
   */
  indepAccount?: string;
  /**
   * @remarks
   * The ID of the instance for which the secure access proxy feature is enabled.
   * 
   * @example
   * 1922545
   */
  instanceId?: number;
  /**
   * @remarks
   * The method that is used to authorize the user to enable the secure access proxy feature for an instance. Valid values:
   * 
   * *   **Authorization by the Alibaba Cloud Account ()**: The information in the parentheses () indicates the ID of the Alibaba Cloud account.
   * *   **Authorization by submitting the ticket ()**:The information in the parentheses () indicates the number of the ticket that the user submits to apply for permissions.
   * 
   * @example
   * Authorization by the Alibaba Cloud account (29490401597700\\*\\*\\*\\*)
   */
  originInfo?: string;
  /**
   * @remarks
   * The ID that DMS generates after the user is authorized to enable the secure access proxy feature for an instance. The ID is unique in DMS. You can call the [ListProxyAccesses](https://help.aliyun.com/document_detail/295386.html) operation to query the ID.
   * 
   * @example
   * 2002
   */
  proxyAccessId?: number;
  /**
   * @remarks
   * The ID of the secure access proxy.
   * 
   * >  You can call the [ListProxies](https://help.aliyun.com/document_detail/295371.html) operation to query the ID of the secure access proxy.
   * 
   * @example
   * 1905
   */
  proxyId?: number;
  /**
   * @remarks
   * The ID of the user.
   * 
   * @example
   * 12***
   */
  userId?: number;
  /**
   * @remarks
   * The nickname of the user.
   * 
   * @example
   * user
   */
  userName?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 25936669186260****
   */
  userUid?: string;
  static names(): { [key: string]: string } {
    return {
      accessId: 'AccessId',
      gmtCreate: 'GmtCreate',
      indepAccount: 'IndepAccount',
      instanceId: 'InstanceId',
      originInfo: 'OriginInfo',
      proxyAccessId: 'ProxyAccessId',
      proxyId: 'ProxyId',
      userId: 'UserId',
      userName: 'UserName',
      userUid: 'UserUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessId: 'string',
      gmtCreate: 'string',
      indepAccount: 'string',
      instanceId: 'number',
      originInfo: 'string',
      proxyAccessId: 'number',
      proxyId: 'number',
      userId: 'number',
      userName: 'string',
      userUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult extends $tea.Model {
  /**
   * @remarks
   * The number of SQL statements that failed to pass the review.
   * 
   * @example
   * 1
   */
  checkNotPass?: number;
  /**
   * @remarks
   * The number of SQL statements that passed the review.
   * 
   * @example
   * 8
   */
  checkPass?: number;
  /**
   * @remarks
   * The number of SQL statements that failed to pass the manual review.
   * 
   * @example
   * 0
   */
  forceNotPass?: number;
  /**
   * @remarks
   * The number of SQL statements that passed the manual review.
   * 
   * @example
   * 1
   */
  forcePass?: number;
  /**
   * @remarks
   * The number of SQL statements to be reviewed.
   * 
   * @example
   * 0
   */
  new?: number;
  /**
   * @remarks
   * The number of abnormal SQL statements.
   * 
   * @example
   * 0
   */
  unknown?: number;
  static names(): { [key: string]: string } {
    return {
      checkNotPass: 'CheckNotPass',
      checkPass: 'CheckPass',
      forceNotPass: 'ForceNotPass',
      forcePass: 'ForcePass',
      new: 'New',
      unknown: 'Unknown',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkNotPass: 'number',
      checkPass: 'number',
      forceNotPass: 'number',
      forcePass: 'number',
      new: 'number',
      unknown: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult extends $tea.Model {
  /**
   * @remarks
   * The number of SQL statements that must be modified.
   * 
   * @example
   * 1
   */
  mustImprove?: number;
  /**
   * @remarks
   * The number of SQL statements that have potential issues.
   * 
   * @example
   * 0
   */
  potentialIssue?: number;
  /**
   * @remarks
   * The number of SQL statements that can be modified.
   * 
   * @example
   * 3
   */
  suggestImprove?: number;
  /**
   * @remarks
   * The number of SQL statements that can use indexes.
   * 
   * @example
   * 2
   */
  tableIndexSuggest?: number;
  /**
   * @remarks
   * The number of SQL statements that can be used for lock-free data changes.
   * 
   * @example
   * 0
   */
  useDmsDmlUnlock?: number;
  /**
   * @remarks
   * The number of SQL statements that can be used for lock-free schema changes.
   * 
   * @example
   * 0
   */
  useDmsToolkit?: number;
  static names(): { [key: string]: string } {
    return {
      mustImprove: 'MustImprove',
      potentialIssue: 'PotentialIssue',
      suggestImprove: 'SuggestImprove',
      tableIndexSuggest: 'TableIndexSuggest',
      useDmsDmlUnlock: 'UseDmsDmlUnlock',
      useDmsToolkit: 'UseDmsToolkit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mustImprove: 'number',
      potentialIssue: 'number',
      suggestImprove: 'number',
      tableIndexSuggest: 'number',
      useDmsDmlUnlock: 'number',
      useDmsToolkit: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus extends $tea.Model {
  /**
   * @remarks
   * The result of the SQL status check.
   */
  checkStatusResult?: GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult;
  /**
   * @remarks
   * The number of SQL statements that were reviewed.
   * 
   * @example
   * 10
   */
  checkedCount?: number;
  /**
   * @remarks
   * The optimization suggestion for SQL statements.
   */
  SQLReviewResult?: GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult;
  /**
   * @remarks
   * The total number of SQL statements.
   * 
   * @example
   * 10
   */
  totalSQLCount?: number;
  static names(): { [key: string]: string } {
    return {
      checkStatusResult: 'CheckStatusResult',
      checkedCount: 'CheckedCount',
      SQLReviewResult: 'SQLReviewResult',
      totalSQLCount: 'TotalSQLCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkStatusResult: GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult,
      checkedCount: 'number',
      SQLReviewResult: GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult,
      totalSQLCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts extends $tea.Model {
  /**
   * @remarks
   * The content of the SQL script.
   * 
   * @example
   * alter table xxx add index idx_xx(yyy);
   */
  content?: string;
  /**
   * @remarks
   * The purpose of the SQL script. The value is set to AddIndex.
   * 
   * @example
   * AddIndex
   */
  opType?: string;
  /**
   * @remarks
   * The name of the table.
   * 
   * @example
   * xxx
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      opType: 'OpType',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      opType: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults extends $tea.Model {
  /**
   * @remarks
   * The comment that is specified when you create the SQL review rule. For more information, see [SQL review optimization](https://help.aliyun.com/document_detail/194114.html).
   * 
   * @example
   * xxx business rule: the query must have a where condition.
   */
  comments?: string;
  /**
   * @remarks
   * The optimization suggestion for the SQL statement. Valid values:
   * 
   * *   **MUST_IMPROVE**: The SQL statement must be improved.
   * *   **POTENTIAL_ISSUE**: The SQL statement contains potential issues.
   * *   **SUGGEST_IMPROVE**: We recommend that you improve the SQL statement.
   * *   **USEDMSTOOLKIT**: We recommend that you change schemas without locking tables.
   * *   **USEDMSDML_UNLOCK**: We recommend that you change data without locking tables.
   * *   **TABLEINDEXSUGGEST**: We recommend that you use SQL statements that use indexes.
   * 
   * @example
   * MUST_IMPROVE
   */
  feedback?: string;
  /**
   * @remarks
   * The review results.
   */
  messages?: string[];
  /**
   * @remarks
   * The name of the rule. For more information, see [SQL review optimization](https://help.aliyun.com/document_detail/194114.html).
   * 
   * @example
   * SELECT_SUGGEST_ASSIGN_WHERE
   */
  ruleName?: string;
  /**
   * @remarks
   * The type of the SQL review rule. Valid values:
   * 
   * *   **REVIEW**: a rule that is used to review SQL statements based on standards.
   * *   **OPTIMIZE**: a rule that is used to provide optimization suggestions.
   * 
   * @example
   * REVIEW
   */
  ruleType?: string;
  /**
   * @remarks
   * The SQL script for data changes.
   */
  scripts?: GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts[];
  static names(): { [key: string]: string } {
    return {
      comments: 'Comments',
      feedback: 'Feedback',
      messages: 'Messages',
      ruleName: 'RuleName',
      ruleType: 'RuleType',
      scripts: 'Scripts',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comments: 'string',
      feedback: 'string',
      messages: { 'type': 'array', 'itemType': 'string' },
      ruleName: 'string',
      ruleType: 'string',
      scripts: { 'type': 'array', 'itemType': GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult extends $tea.Model {
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * syntax error
   */
  errorMessage?: string;
  /**
   * @remarks
   * Indicates whether an error occurs. Valid values:
   * 
   * *   **true**: An error occurs.
   * *   **false**: No error occurs.
   * 
   * @example
   * false
   */
  occurError?: boolean;
  /**
   * @remarks
   * The review results based on rules.
   */
  results?: GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults[];
  static names(): { [key: string]: string } {
    return {
      errorMessage: 'ErrorMessage',
      occurError: 'OccurError',
      results: 'Results',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorMessage: 'string',
      occurError: 'boolean',
      results: { 'type': 'array', 'itemType': GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail extends $tea.Model {
  /**
   * @remarks
   * The ID of the database.
   * 
   * @example
   * 111222
   */
  dbId?: number;
  /**
   * @remarks
   * The ID of the instance to which the database belongs.
   * 
   * @example
   * 123321
   */
  instanceId?: number;
  /**
   * @remarks
   * The quality of the SQL statement.
   */
  qualityResult?: GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult;
  /**
   * @remarks
   * The key that is used to query the details of optimization suggestions.
   * 
   * @example
   * a57e54ec5433475ea3082d882fdb****
   */
  queryKey?: string;
  /**
   * @remarks
   * The type of the SQL statement. Valid values: DELETE, UPDATE, and ALTER_TABLE.
   * 
   * @example
   * UPDATE
   */
  sqlType?: string;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      instanceId: 'InstanceId',
      qualityResult: 'QualityResult',
      queryKey: 'QueryKey',
      sqlType: 'SqlType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      instanceId: 'number',
      qualityResult: GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult,
      queryKey: 'string',
      sqlType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStandardGroupResponseBodyStandardGroup extends $tea.Model {
  /**
   * @example
   * mysql
   */
  dbType?: string;
  description?: string;
  /**
   * @example
   * 41****
   */
  groupId?: number;
  /**
   * @example
   * COMMON
   */
  groupMode?: string;
  /**
   * @example
   * poc_test
   */
  groupName?: string;
  /**
   * @example
   * 51****
   */
  lastMenderId?: number;
  static names(): { [key: string]: string } {
    return {
      dbType: 'DbType',
      description: 'Description',
      groupId: 'GroupId',
      groupMode: 'GroupMode',
      groupName: 'GroupName',
      lastMenderId: 'LastMenderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbType: 'string',
      description: 'string',
      groupId: 'number',
      groupMode: 'string',
      groupName: 'string',
      lastMenderId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail extends $tea.Model {
  /**
   * @remarks
   * The SQL statements that are executed.
   */
  execSql?: string;
  /**
   * @remarks
   * The total number of SQL statements.
   * 
   * @example
   * 1
   */
  totalSqlCount?: number;
  static names(): { [key: string]: string } {
    return {
      execSql: 'ExecSql',
      totalSqlCount: 'TotalSqlCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      execSql: 'string',
      totalSqlCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList extends $tea.Model {
  /**
   * @remarks
   * The SQL script.
   */
  script?: string;
  /**
   * @remarks
   * The name of the source table.
   * 
   * @example
   * helloz_bak
   */
  sourceTableName?: string;
  /**
   * @remarks
   * The name of the destination table.
   * 
   * @example
   * helloz_bak
   */
  targetTableName?: string;
  static names(): { [key: string]: string } {
    return {
      script: 'Script',
      sourceTableName: 'SourceTableName',
      targetTableName: 'TargetTableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      script: 'string',
      sourceTableName: 'string',
      targetTableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList extends $tea.Model {
  /**
   * @remarks
   * The type of the comparison. Valid values:
   * 
   * *   **CREATE_TABLE**: compares the created tables.
   * *   **ALTER_TABLE**: compares the modified tables.
   * *   **EQUAL_TABLE**: compares the identical tables.
   * *   **PASS_TABLE**: compares the tables that are skipped during schema synchronization.
   * *   **NOT_COMPARE**: does not compare tables.
   * 
   * @example
   * CREATE_TABLE
   */
  compareType?: string;
  /**
   * @remarks
   * The number of tables.
   * 
   * @example
   * 1
   */
  count?: number;
  static names(): { [key: string]: string } {
    return {
      compareType: 'CompareType',
      count: 'Count',
    };
  }

  static types(): { [key: string]: any } {
    return {
      compareType: 'string',
      count: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult extends $tea.Model {
  /**
   * @remarks
   * The details of the analysis results.
   */
  resultList?: GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList[];
  /**
   * @remarks
   * The statistics on the analysis results.
   */
  summaryList?: GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList[];
  static names(): { [key: string]: string } {
    return {
      resultList: 'ResultList',
      summaryList: 'SummaryList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resultList: { 'type': 'array', 'itemType': GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList },
      summaryList: { 'type': 'array', 'itemType': GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncJobDetailResponseBodyStructSyncJobDetail extends $tea.Model {
  /**
   * @remarks
   * The ID of the SQL task group.
   * 
   * @example
   * 12345
   */
  DBTaskGroupId?: number;
  /**
   * @remarks
   * The number of SQL statements that have been executed.
   * 
   * @example
   * 1
   */
  executeCount?: number;
  /**
   * @remarks
   * The status of the task. Valid values:
   * 
   * *   **NEW**: The task was created.
   * *   **COMPARING**: The schemas of tables were being compared.
   * *   **COMPARE_BREAK**: The schema comparison was interrupted.
   * *   **COMPARE_FINISH**: The comparison was finished.
   * *   **NOT_SCRIPTS**: The comparison was finished but no executable script was available.
   * *   **SUBMITED_DBTASK**: The task was submitted.
   * *   **DBTASK_SUCCESS**: The task was complete.
   * *   **SUBMITED_WORKFLOW**: The ticket was submitted.
   * *   **WORKFLOW_SUCCESS**: The ticket was approved.
   * 
   * @example
   * DBTASK_SUCCESS
   */
  jobStatus?: string;
  /**
   * @remarks
   * The description of the task.
   * 
   * @example
   * test
   */
  message?: string;
  /**
   * @remarks
   * The type of security rule. Valid values:
   * 
   * *   **CANNOT_SYNC**: Synchronization cannot be performed.
   * *   **WITH_APPROVE**: The schema synchronization can be performed after the ticket is approved. You can call the [SubmitStructSyncOrderApproval](https://help.aliyun.com/document_detail/206166.html) operation to submit the ticket for approval.
   * *   **WITHOUT_APPROVE**: The schema synchronization can be performed without approval.
   * 
   * @example
   * WITHOUT_APPROVE
   */
  securityRule?: string;
  /**
   * @remarks
   * The total number of SQL statements.
   * 
   * @example
   * 1
   */
  sqlCount?: number;
  /**
   * @remarks
   * The number of tables that have been analyzed.
   * 
   * @example
   * 2
   */
  tableAnalyzed?: number;
  /**
   * @remarks
   * The total number of tables.
   * 
   * @example
   * 2
   */
  tableCount?: number;
  static names(): { [key: string]: string } {
    return {
      DBTaskGroupId: 'DBTaskGroupId',
      executeCount: 'ExecuteCount',
      jobStatus: 'JobStatus',
      message: 'Message',
      securityRule: 'SecurityRule',
      sqlCount: 'SqlCount',
      tableAnalyzed: 'TableAnalyzed',
      tableCount: 'TableCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DBTaskGroupId: 'number',
      executeCount: 'number',
      jobStatus: 'string',
      message: 'string',
      securityRule: 'string',
      sqlCount: 'number',
      tableAnalyzed: 'number',
      tableCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo extends $tea.Model {
  /**
   * @remarks
   * The ID of the source database.
   * 
   * @example
   * 432532
   */
  dbId?: number;
  /**
   * @remarks
   * The type of the database engine.
   * 
   * @example
   * MySQL
   */
  dbType?: string;
  /**
   * @remarks
   * The type of the environment to which the database instance belongs. For more information, see [Change the environment type of an instance](https://help.aliyun.com/document_detail/163309.html).
   * 
   * @example
   * dev
   */
  envType?: string;
  /**
   * @remarks
   * Indicates whether the database is a logical database. Valid values:
   * 
   * *   **true**: The database is a logical database.
   * *   **false**: The database is not a logical database
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The name that is used to search for the database.
   * 
   * @example
   * test
   */
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      dbType: 'DbType',
      envType: 'EnvType',
      logic: 'Logic',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      dbType: 'string',
      envType: 'string',
      logic: 'boolean',
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo extends $tea.Model {
  /**
   * @remarks
   * The version number.
   * 
   * @example
   * e179bbb8163dcdcfacda24858bedb4d8006ae2b8
   */
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      versionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList extends $tea.Model {
  /**
   * @remarks
   * The name of the table whose schema you want to synchronize.
   * 
   * @example
   * test_tbl
   */
  sourceTableName?: string;
  /**
   * @remarks
   * The name of the table to which you want to synchronize the schema of a table.
   * 
   * @example
   * test_tbl
   */
  targetTableName?: string;
  static names(): { [key: string]: string } {
    return {
      sourceTableName: 'SourceTableName',
      targetTableName: 'TargetTableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sourceTableName: 'string',
      targetTableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo extends $tea.Model {
  /**
   * @remarks
   * The ID of the destination database.
   * 
   * @example
   * 432543
   */
  dbId?: number;
  /**
   * @remarks
   * The type of the database engine.
   * 
   * @example
   * MySQL
   */
  dbType?: string;
  /**
   * @remarks
   * The type of the environment to which the database instance belongs. For more information, see [Change the environment type of an instance](https://help.aliyun.com/document_detail/163309.html).
   * 
   * @example
   * dev
   */
  envType?: string;
  /**
   * @remarks
   * Indicates whether the database is a logical database. Valid values:
   * 
   * *   **true**: The database is a logical database.
   * *   **false**: The database is not a logical database
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The name that is used to search for the database.
   * 
   * @example
   * test
   */
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      dbType: 'DbType',
      envType: 'EnvType',
      logic: 'Logic',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      dbType: 'string',
      envType: 'string',
      logic: 'boolean',
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo extends $tea.Model {
  /**
   * @remarks
   * The version number.
   * 
   * @example
   * e179bbb8163dcdcfacda24858bedb4d8006ae2b8
   */
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      versionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail extends $tea.Model {
  /**
   * @remarks
   * Indicates whether to skip errors. Valid values:
   * 
   * *   **true**: skips the error and continues to execute SQL statements.
   * *   **false**: stops executing SQL statements.
   * 
   * @example
   * false
   */
  ignoreError?: boolean;
  /**
   * @remarks
   * The information about the source database.
   */
  sourceDatabaseInfo?: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo;
  /**
   * @remarks
   * The schema version of the source database. Valid values:
   * 
   * *   **DATASOURCE**: the default latest version of the system
   * *   **VERSION**: a previous schema version that you manually specify
   * 
   * @example
   * VERSION
   */
  sourceType?: string;
  /**
   * @remarks
   * The version information about the source instance.
   * 
   * > This parameter is displayed only when the value of the **SourceType** parameter is **VERSION**.
   */
  sourceVersionInfo?: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo;
  /**
   * @remarks
   * The information about the table whose schema you want to synchronize.
   */
  tableInfoList?: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList[];
  /**
   * @remarks
   * The information about the destination database.
   */
  targetDatabaseInfo?: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo;
  /**
   * @remarks
   * The schema version of the destination database. Valid values:
   * 
   * *   **DATASOURCE**: the default latest version of the system
   * *   **VERSION**: a previous schema version that you manually specify
   * 
   * @example
   * DATASOURCE
   */
  targetType?: string;
  /**
   * @remarks
   * The version information about the destination instance.
   * 
   * > This parameter is displayed only when the value of the **SourceType** parameter is **VERSION**.
   */
  targetVersionInfo?: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo;
  static names(): { [key: string]: string } {
    return {
      ignoreError: 'IgnoreError',
      sourceDatabaseInfo: 'SourceDatabaseInfo',
      sourceType: 'SourceType',
      sourceVersionInfo: 'SourceVersionInfo',
      tableInfoList: 'TableInfoList',
      targetDatabaseInfo: 'TargetDatabaseInfo',
      targetType: 'TargetType',
      targetVersionInfo: 'TargetVersionInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ignoreError: 'boolean',
      sourceDatabaseInfo: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo,
      sourceType: 'string',
      sourceVersionInfo: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo,
      tableInfoList: { 'type': 'array', 'itemType': GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList },
      targetDatabaseInfo: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo,
      targetType: 'string',
      targetVersionInfo: GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList extends $tea.Model {
  /**
   * @remarks
   * The ID of the table.
   * 
   * @example
   * NORMAL
   */
  tableId?: string;
  /**
   * @remarks
   * The name of the physical table.
   * 
   * @example
   * 151977812
   */
  tableName?: string;
  /**
   * @remarks
   * The type of the table. This is a reserved parameter.
   * 
   * @example
   * yuyang_test_0000
   */
  tableType?: string;
  static names(): { [key: string]: string } {
    return {
      tableId: 'TableId',
      tableName: 'TableName',
      tableType: 'TableType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tableId: 'string',
      tableName: 'string',
      tableType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList extends $tea.Model {
  /**
   * @remarks
   * The ID of the database.
   * 
   * @example
   * 489347
   */
  dbId?: string;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * db-test
   */
  dbName?: string;
  /**
   * @remarks
   * The type of the database. For more information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
   * 
   * @example
   * MySQL
   */
  dbType?: string;
  /**
   * @remarks
   * The type of the environment to which the database belongs. Valid values:
   * 
   * *   **product**: production environment
   * *   **dev**: development environment
   * *   **pre**: pre-release environment
   * *   **test**: test environment
   * *   **sit**: system integration testing (SIT) environment
   * *   **uat**: user acceptance testing (UAT) environment
   * *   **pet**: stress testing environment
   * *   **stag**: staging environment
   * 
   * > For more information, see [Change the environment type of an instance](https://help.aliyun.com/document_detail/163309.html).
   * 
   * @example
   * pre
   */
  envType?: string;
  /**
   * @remarks
   * The physical tables.
   */
  tableList?: GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList[];
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      dbName: 'DbName',
      dbType: 'DbType',
      envType: 'EnvType',
      tableList: 'TableList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'string',
      dbName: 'string',
      dbType: 'string',
      envType: 'string',
      tableList: { 'type': 'array', 'itemType': GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDBTopologyResponseBodyDBTopologyDataSourceList extends $tea.Model {
  /**
   * @remarks
   * The physical databases.
   */
  databaseList?: GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList[];
  /**
   * @remarks
   * The type of the database. For more information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
   * 
   * @example
   * MySQL
   */
  dbType?: string;
  /**
   * @remarks
   * The endpoint of the data source.
   * 
   * @example
   * xxx.mysql.polardb.rds.aliyuncs.com
   */
  host?: string;
  /**
   * @remarks
   * The port that is used to connect to the data source.
   * 
   * @example
   * 3306
   */
  port?: number;
  /**
   * @remarks
   * The system ID (SID) of the data source.
   * 
   * @example
   * def
   */
  sid?: string;
  static names(): { [key: string]: string } {
    return {
      databaseList: 'DatabaseList',
      dbType: 'DbType',
      host: 'Host',
      port: 'Port',
      sid: 'Sid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseList: { 'type': 'array', 'itemType': GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList },
      dbType: 'string',
      host: 'string',
      port: 'number',
      sid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDBTopologyResponseBodyDBTopology extends $tea.Model {
  /**
   * @remarks
   * The data sources.
   */
  dataSourceList?: GetTableDBTopologyResponseBodyDBTopologyDataSourceList[];
  /**
   * @remarks
   * The GUID of the table in DMS.
   * 
   * @example
   * IDB_L_9032.db-test.yuyang_test
   */
  tableGuid?: string;
  /**
   * @remarks
   * The name of the table.
   * 
   * > 
   * 
   * *   If a logical table is queried, the name of the logical table is returned.
   * 
   * *   If a physical table is queried, the name of the physical table is returned.
   * 
   * @example
   * yuyang_test
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      dataSourceList: 'DataSourceList',
      tableGuid: 'TableGuid',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceList: { 'type': 'array', 'itemType': GetTableDBTopologyResponseBodyDBTopologyDataSourceList },
      tableGuid: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDesignProjectFlowResponseBodyProjectFlowFlowNodeArray extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the ticket can be returned to the schema design node. Valid values:
   * 
   * *   **1**: The ticket can be returned to the schema design node.
   * *   **0**: The ticket cannot be returned to the schema design node. This value can be returned only for the PUBLISH node.
   * 
   * @example
   * 1
   */
  backToDesign?: boolean;
  /**
   * @remarks
   * Indicates whether the current node can be skipped. Valid values:
   * 
   * *   **1**: The current node can be skipped.
   * *   **0**: The current node cannot be skipped. This value can be returned only for the PUBLISH node.
   * 
   * @example
   * 0
   */
  canSkip?: boolean;
  /**
   * @remarks
   * The role of the node in the process.
   * 
   * *   START: The ticket was created.
   * *   DESIGN: The schema is being created.
   * *   PUBLISH: The schema is published.
   * *   END: The ticket is complete.
   * 
   * @example
   * DESIGN
   */
  nodeRole?: string;
  /**
   * @remarks
   * The title of the node.
   */
  nodeTitle?: string;
  /**
   * @remarks
   * The position of the node in the process. The value starts from 1.
   * 
   * @example
   * 1
   */
  position?: number;
  /**
   * @remarks
   * Indicates whether the node is the anchor node. A schema design process has only one anchor node, on which the schema is published. After the schema is published on the anchor node, a post-publish image is generated and the DDL metadata lock is released.
   * 
   * @example
   * false
   */
  publishAnchor?: boolean;
  /**
   * @remarks
   * The available publishing strategies.
   */
  publishStrategies?: string[];
  static names(): { [key: string]: string } {
    return {
      backToDesign: 'BackToDesign',
      canSkip: 'CanSkip',
      nodeRole: 'NodeRole',
      nodeTitle: 'NodeTitle',
      position: 'Position',
      publishAnchor: 'PublishAnchor',
      publishStrategies: 'PublishStrategies',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backToDesign: 'boolean',
      canSkip: 'boolean',
      nodeRole: 'string',
      nodeTitle: 'string',
      position: 'number',
      publishAnchor: 'boolean',
      publishStrategies: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDesignProjectFlowResponseBodyProjectFlow extends $tea.Model {
  /**
   * @remarks
   * The position of the current node in the process.
   * 
   * @example
   * 2
   */
  currentPosition?: number;
  /**
   * @remarks
   * The nodes in the process.
   */
  flowNodeArray?: GetTableDesignProjectFlowResponseBodyProjectFlowFlowNodeArray[];
  /**
   * @remarks
   * The description of the security rule set that is applied to the schema design ticket.
   * 
   * @example
   * mysq_test
   */
  ruleComment?: string;
  /**
   * @remarks
   * The name of the security rule set that is applied to the schema design ticket.
   * 
   * @example
   * mysql default
   */
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      currentPosition: 'CurrentPosition',
      flowNodeArray: 'FlowNodeArray',
      ruleComment: 'RuleComment',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPosition: 'number',
      flowNodeArray: { 'type': 'array', 'itemType': GetTableDesignProjectFlowResponseBodyProjectFlowFlowNodeArray },
      ruleComment: 'string',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDesignProjectInfoResponseBodyProjectInfoBaseDatabase extends $tea.Model {
  /**
   * @remarks
   * The alias of the database instance.
   * 
   * @example
   * poc_test
   */
  alias?: string;
  /**
   * @remarks
   * The database ID.
   * 
   * @example
   * 11****
   */
  dbId?: number;
  /**
   * @remarks
   * The type of the database. For more information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
   * 
   * @example
   * POLARDB
   */
  dbType?: string;
  /**
   * @remarks
   * The type of the environment in which the database instance is deployed. Valid values:
   * 
   * *   **product**: production environment.
   * *   **dev**: development environment.
   * *   **pre**: pre-release environment.
   * *   **test**: test environment.
   * *   **sit**: system integration testing (SIT) environment.
   * *   **uat**: user acceptance testing (UAT) environment.
   * *   **pet**: stress testing environment.
   * *   **stag**: staging environment.
   * 
   * @example
   * dev
   */
  envType?: string;
  /**
   * @remarks
   * Indicates whether the database is a logical database. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The database name.
   * 
   * @example
   * bk_atc020
   */
  schemaName?: string;
  /**
   * @remarks
   * The name that is used to search for the database.
   * 
   * @example
   * schema_name@127.0.XX.XX
   */
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      dbId: 'DbId',
      dbType: 'DbType',
      envType: 'EnvType',
      logic: 'Logic',
      schemaName: 'SchemaName',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      dbId: 'number',
      dbType: 'string',
      envType: 'string',
      logic: 'boolean',
      schemaName: 'string',
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableDesignProjectInfoResponseBodyProjectInfo extends $tea.Model {
  /**
   * @remarks
   * The information about the change base database of the schema design ticket.
   */
  baseDatabase?: GetTableDesignProjectInfoResponseBodyProjectInfoBaseDatabase;
  /**
   * @remarks
   * The ID of the user who created the ticket.
   * 
   * @example
   * 71****
   */
  creatorId?: number;
  /**
   * @remarks
   * The description of the schema design project.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The time when the ticket was created.
   * 
   * @example
   * 2024-04-23 02:57:01
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The time when the ticket was last modified.
   * 
   * @example
   * 2024-04-23 02:57:01
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ticket ID.
   * 
   * @example
   * 95****
   */
  orderId?: number;
  /**
   * @remarks
   * The project ID.
   * 
   * @example
   * 12****
   */
  projectId?: number;
  /**
   * @remarks
   * The state of the schema design project. Valid values:
   * 
   * *   **DESIGN**: The schema is being designed.
   * *   **PUBLISHED**: The schema is published.
   * *   **CLOSE**: The ticket is closed.
   * 
   * @example
   * DESIGN
   */
  status?: string;
  /**
   * @remarks
   * The name of the schema design project.
   * 
   * @example
   * test
   */
  title?: string;
  static names(): { [key: string]: string } {
    return {
      baseDatabase: 'BaseDatabase',
      creatorId: 'CreatorId',
      description: 'Description',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      orderId: 'OrderId',
      projectId: 'ProjectId',
      status: 'Status',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baseDatabase: GetTableDesignProjectInfoResponseBodyProjectInfoBaseDatabase,
      creatorId: 'number',
      description: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      orderId: 'number',
      projectId: 'number',
      status: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList extends $tea.Model {
  /**
   * @remarks
   * The ID of the physical database.
   * 
   * @example
   * 43215
   */
  dbId?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * yuyang_test
   */
  dbName?: string;
  /**
   * @remarks
   * The name that is used to search for the database.
   * > We recommend that you do not use this parameter for business development. The format of the parameter value may be modified in later versions.
   * 
   * @example
   * yuyang_test@localhost:3306
   * [yuyang_test_dev]
   */
  dbSearchName?: string;
  /**
   * @remarks
   * The database engine.
   * 
   * @example
   * mysql
   */
  dbType?: string;
  /**
   * @remarks
   * The ID of the instance to which the physical database belongs.
   * 
   * @example
   * 4325325
   */
  instanceId?: number;
  /**
   * @remarks
   * The ID of the resource related to the instance. The resource corresponds with the database instance type returned in the InstanceSource parameter.
   * 
   * *   **RDS**:The ID of the ApsaraDB RDS instance.
   * *   **ECS_OWN**: The ID of the Elastic Compute Service (ECS) instance.
   * *   **PUBLIC_OWN**: This parameter is left empty for self-managed database instances that are connected over the Internet.
   * *   **VPC_ID**:The ID of the virtual private cloud (VPC).
   * *   **GATEWAY**: The ID of the database gateway.
   * 
   * @example
   * rm-xxx
   */
  instanceResourceId?: string;
  /**
   * @remarks
   * The type of the database instance. Valid values:
   * 
   * *   **RDS**: an ApsaraDB RDS instance.
   * *   **ECS_OWN**: a self-managed database that is deployed on an ECS instance
   * *   **PUBLIC_OWN**: a self-managed database instance that is connected over the Internet.
   * *   **VPC_ID**: a self-managed database instance in a VPC that is connected over Express Connect circuits.
   * *   **GATEWAY**: a database instance connected by using a database gateway.
   * 
   * @example
   * RDS
   */
  instanceSource?: string;
  /**
   * @remarks
   * The region ID of the instance.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The number of tables.
   * 
   * @example
   * 6
   */
  tableCount?: number;
  /**
   * @remarks
   * The expression of the names of logical tables.
   * 
   * **
   * 
   * **Description** This parameter is not returned for physical tables.
   * 
   * @example
   * test_ch_[0000-0005]
   */
  tableNameExpr?: string;
  /**
   * @remarks
   * The names of tables.
   * 
   * > The table names are separated by commas (,).
   * 
   * @example
   * test_ch_0000,test_ch_0001,test_ch_0002,test_ch_0003,test_ch_0004,test_ch_0005
   */
  tableNameList?: string;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      dbName: 'DbName',
      dbSearchName: 'DbSearchName',
      dbType: 'DbType',
      instanceId: 'InstanceId',
      instanceResourceId: 'InstanceResourceId',
      instanceSource: 'InstanceSource',
      regionId: 'RegionId',
      tableCount: 'TableCount',
      tableNameExpr: 'TableNameExpr',
      tableNameList: 'TableNameList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      dbName: 'string',
      dbSearchName: 'string',
      dbType: 'string',
      instanceId: 'number',
      instanceResourceId: 'string',
      instanceSource: 'string',
      regionId: 'string',
      tableCount: 'number',
      tableNameExpr: 'string',
      tableNameList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTableTopologyResponseBodyTableTopology extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the table is a logical table. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  logic?: boolean;
  /**
   * @remarks
   * The GUID of the table in DMS.
   * 
   * @example
   * IDB_L_308302.yuyang_test.test_ch
   */
  tableGuid?: string;
  /**
   * @remarks
   * The name of the table.
   * 
   * @example
   * test_ch
   */
  tableName?: string;
  /**
   * @remarks
   * Information of the topology of the table.
   */
  tableTopologyInfoList?: GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList[];
  static names(): { [key: string]: string } {
    return {
      logic: 'Logic',
      tableGuid: 'TableGuid',
      tableName: 'TableName',
      tableTopologyInfoList: 'TableTopologyInfoList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logic: 'boolean',
      tableGuid: 'string',
      tableName: 'string',
      tableTopologyInfoList: { 'type': 'array', 'itemType': GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskResponseBodyTask extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow to which the node belongs.
   * 
   * @example
   * 7321
   */
  dagId?: number;
  /**
   * @remarks
   * The position of the node on the Directed Acyclic Graph (DAG).
   * 
   * @example
   * {"{\\"x\\":0,\\"y\\":0,\\"layoutType\\":\\"Horizontal\\"}",  "id": 51***}
   */
  graphParam?: string;
  /**
   * @remarks
   * The advanced configuration for the node.
   */
  nodeConfig?: string;
  /**
   * @remarks
   * The configuration for the node.
   * 
   * @example
   * {\\"dbList\\":[{\\"instanceId\\":177****}"   }
   */
  nodeContent?: string;
  /**
   * @remarks
   * The name of the node.
   * 
   * @example
   * Cross-database Spark SQL-1
   */
  nodeName?: string;
  /**
   * @remarks
   * The output variables for the node. This parameter is available only for some types of nodes.
   * 
   * @example
   * { "outputs":[ "extractMethod":"json" , "variableName":"var",   "description":"demo desc" } ] }
   */
  nodeOutput?: string;
  /**
   * @remarks
   * The type of the node. For more information about the valid values for this parameter, see [NodeType parameter](https://help.aliyun.com/document_detail/424705.html).
   * 
   * @example
   * SPARK_SQL
   */
  nodeType?: string;
  /**
   * @remarks
   * The time variables configured for the node.
   * 
   * @example
   * {\\"variables\\":[{\\"name\\":\\"Today\\",\\"pattern\\":\\"yyyy-MM-dd|+1d\\"}]}
   */
  timeVariables?: string;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      graphParam: 'GraphParam',
      nodeConfig: 'NodeConfig',
      nodeContent: 'NodeContent',
      nodeName: 'NodeName',
      nodeOutput: 'NodeOutput',
      nodeType: 'NodeType',
      timeVariables: 'TimeVariables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      graphParam: 'string',
      nodeConfig: 'string',
      nodeContent: 'string',
      nodeName: 'string',
      nodeOutput: 'string',
      nodeType: 'string',
      timeVariables: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow.
   * 
   * @example
   * 15***
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the task flow edge.
   * 
   * @example
   * 24***
   */
  id?: number;
  /**
   * @remarks
   * The ID of the end node on the edge.
   * 
   * @example
   * 44***
   */
  nodeEnd?: number;
  /**
   * @remarks
   * The ID of the start node on the edge.
   * 
   * @example
   * 44***
   */
  nodeFrom?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      id: 'Id',
      nodeEnd: 'NodeEnd',
      nodeFrom: 'NodeFrom',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      id: 'number',
      nodeEnd: 'number',
      nodeFrom: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskFlowGraphResponseBodyTaskFlowGraphEdges extends $tea.Model {
  edge?: GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge[];
  static names(): { [key: string]: string } {
    return {
      edge: 'Edge',
    };
  }

  static types(): { [key: string]: any } {
    return {
      edge: { 'type': 'array', 'itemType': GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow.
   * 
   * @example
   * 15***
   */
  dagId?: number;
  /**
   * @remarks
   * The position of the node in the DAG.
   * 
   * @example
   * {\\"x\\":541,\\"y\\":322,\\"layoutType\\":\\"Horizontal\\"}
   */
  graphParam?: string;
  /**
   * @remarks
   * The advanced configuration of the node.
   */
  nodeConfig?: string;
  /**
   * @remarks
   * The configuration of the node.
   * 
   * @example
   * {ODI3OTNRVC****UHVFT29"}
   */
  nodeContent?: string;
  /**
   * @remarks
   * The ID of the node.
   * 
   * @example
   * 44***
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the node.
   * 
   * @example
   * test
   */
  nodeName?: string;
  /**
   * @remarks
   * The type of the node. For more information about the valid values for this parameter, see [NodeType parameter](https://help.aliyun.com/document_detail/424705.html).
   * 
   * @example
   * 36
   */
  nodeType?: number;
  /**
   * @remarks
   * The time variables for the node.
   * 
   * @example
   * {\\"variables\\":[{\\"name\\":\\"Today\\",\\"pattern\\":\\"yyyy-MM-dd|+1d\\"}]}
   */
  timeVariables?: string;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      graphParam: 'GraphParam',
      nodeConfig: 'NodeConfig',
      nodeContent: 'NodeContent',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      nodeType: 'NodeType',
      timeVariables: 'TimeVariables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      graphParam: 'string',
      nodeConfig: 'string',
      nodeContent: 'string',
      nodeId: 'number',
      nodeName: 'string',
      nodeType: 'number',
      timeVariables: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskFlowGraphResponseBodyTaskFlowGraphNodes extends $tea.Model {
  node?: GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode[];
  static names(): { [key: string]: string } {
    return {
      node: 'Node',
    };
  }

  static types(): { [key: string]: any } {
    return {
      node: { 'type': 'array', 'itemType': GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskFlowGraphResponseBodyTaskFlowGraph extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the task flow is editable. Valid values:
   * 
   * - **true**: editable
   * - **false**: non-editable
   * 
   * @example
   * true
   */
  canEdit?: boolean;
  /**
   * @remarks
   * The name of the task flow.
   * 
   * @example
   * test
   */
  dagName?: string;
  /**
   * @remarks
   * The list of task flow edges.
   */
  edges?: GetTaskFlowGraphResponseBodyTaskFlowGraphEdges;
  /**
   * @remarks
   * The node list of the task flow.
   */
  nodes?: GetTaskFlowGraphResponseBodyTaskFlowGraphNodes;
  /**
   * @remarks
   * The status of the task flow. Valid values:
   * 
   * - **0**: invalid
   * - **1**: not scheduled
   * - **2**: to be scheduled
   * 
   * @example
   * 2
   */
  status?: number;
  static names(): { [key: string]: string } {
    return {
      canEdit: 'CanEdit',
      dagName: 'DagName',
      edges: 'Edges',
      nodes: 'Nodes',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canEdit: 'boolean',
      dagName: 'string',
      edges: GetTaskFlowGraphResponseBodyTaskFlowGraphEdges,
      nodes: GetTaskFlowGraphResponseBodyTaskFlowGraphNodes,
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskFlowNotificationResponseBodyNotification extends $tea.Model {
  /**
   * @remarks
   * Indicates whether notifications for failed task flows are enabled. Valid values:
   * 
   * *   **true**: enabled
   * *   **false**: disabled
   * 
   * @example
   * true
   */
  dagNotificationFail?: boolean;
  /**
   * @remarks
   * Indicates whether service level agreement (SLA) global notifications for task flows are enabled. Valid values:
   * 
   * *   **true**: enabled
   * *   **false**: disabled
   * 
   * @example
   * true
   */
  dagNotificationSla?: boolean;
  /**
   * @remarks
   * Indicates whether notifications for successful task flows are enabled. Valid values:
   * 
   * *   **true**: enabled
   * *   **false**: disabled
   * 
   * @example
   * true
   */
  dagNotificationSuccess?: boolean;
  static names(): { [key: string]: string } {
    return {
      dagNotificationFail: 'DagNotificationFail',
      dagNotificationSla: 'DagNotificationSla',
      dagNotificationSuccess: 'DagNotificationSuccess',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagNotificationFail: 'boolean',
      dagNotificationSla: 'boolean',
      dagNotificationSuccess: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskInstanceRelationResponseBodyNodeListNode extends $tea.Model {
  /**
   * @remarks
   * The business time of the node.
   * 
   * @example
   * 2021-11-09 14:37:26
   */
  businessTime?: string;
  /**
   * @remarks
   * The time when the execution of the task flow was complete. The time is displayed in the yyyy-MM-DD HH:mm:ss format.
   * 
   * @example
   * 2021-11-11 14:38:57
   */
  endTime?: string;
  /**
   * @remarks
   * The amount of time consumed for running the node. Unit: milliseconds.
   * 
   * @example
   * 170655
   */
  executeTime?: number;
  /**
   * @remarks
   * The ID of the execution record of the task flow.
   * 
   * @example
   * 14059
   */
  id?: number;
  /**
   * @remarks
   * The description of the task.
   * 
   * @example
   * test
   */
  message?: string;
  /**
   * @remarks
   * The ID of the node.
   * 
   * @example
   * 14059
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the node.
   * 
   * @example
   * Spark SQL-1
   */
  nodeName?: string;
  /**
   * @remarks
   * The type of the node. For more information about the valid values for this parameter, see [NodeType parameter](https://help.aliyun.com/document_detail/424705.html).
   * 
   * @example
   * 36
   */
  nodeType?: number;
  /**
   * @remarks
   * The status of the node. Valid values:
   * 
   * *   **0**: The node is waiting to be scheduled.
   * *   **1**: The node is running.
   * *   **2**: The node is suspended.
   * *   **3**: The node failed to run.
   * *   **4**: The node is run.
   * *   **5**: The node is complete.
   * 
   * @example
   * 4
   */
  status?: number;
  static names(): { [key: string]: string } {
    return {
      businessTime: 'BusinessTime',
      endTime: 'EndTime',
      executeTime: 'ExecuteTime',
      id: 'Id',
      message: 'Message',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      nodeType: 'NodeType',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessTime: 'string',
      endTime: 'string',
      executeTime: 'number',
      id: 'number',
      message: 'string',
      nodeId: 'number',
      nodeName: 'string',
      nodeType: 'number',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTaskInstanceRelationResponseBodyNodeList extends $tea.Model {
  node?: GetTaskInstanceRelationResponseBodyNodeListNode[];
  static names(): { [key: string]: string } {
    return {
      node: 'Node',
    };
  }

  static types(): { [key: string]: any } {
    return {
      node: { 'type': 'array', 'itemType': GetTaskInstanceRelationResponseBodyNodeListNode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserResponseBodyUserRoleIdList extends $tea.Model {
  roleIds?: number[];
  static names(): { [key: string]: string } {
    return {
      roleIds: 'RoleIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleIds: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserResponseBodyUserRoleNameList extends $tea.Model {
  roleNames?: string[];
  static names(): { [key: string]: string } {
    return {
      roleNames: 'RoleNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserResponseBodyUser extends $tea.Model {
  /**
   * @remarks
   * The number of queries that are performed on the current day.
   * 
   * @example
   * 3
   */
  curExecuteCount?: number;
  /**
   * @remarks
   * The number of rows that are queried on the current day.
   * 
   * @example
   * 28
   */
  curResultCount?: number;
  /**
   * @remarks
   * The DingTalk chatbot URL that is used to receive notifications.
   * 
   * > 
   * 
   * *   The system returns this parameter if the user has set a DingTalk chatbot URL in the console. To set a DingTalk chatbot URL in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
   * 
   * *   The system does not return this parameter if the user has not set a DingTalk chatbot URL.
   * 
   * @example
   * https://XXX.dingtalk.com/robot/send?access_token=***
   */
  dingRobot?: string;
  /**
   * @remarks
   * The email address that is used to receive notifications.
   * 
   * > 
   * 
   * *   The system returns this parameter if the user has set an email address in the console. To set an email address in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
   * 
   * *   The system does not return this parameter if the user has not set an email address.
   * 
   * @example
   * Uesr_email
   */
  email?: string;
  /**
   * @remarks
   * The last point in time when the user logged on to the console.
   * 
   * @example
   * 2021-11-08 11:26:21
   */
  lastLoginTime?: string;
  /**
   * @remarks
   * The maximum number of queries that can be performed on the current day.
   * 
   * @example
   * 2000
   */
  maxExecuteCount?: number;
  /**
   * @remarks
   * The maximum number of rows that can be queried on the current day.
   * 
   * @example
   * 10000
   */
  maxResultCount?: number;
  /**
   * @remarks
   * The mobile number of the user.
   * 
   * > 
   * 
   * *   The system returns this parameter if the user has set a mobile phone number in the console. To set a mobile phone number in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
   * 
   * *   The system does not return this parameter if the user has not set a mobile phone number.
   * 
   * @example
   * 1389223****
   */
  mobile?: string;
  /**
   * @remarks
   * The nickname of the user.
   * 
   * @example
   * User_NickName
   */
  nickName?: string;
  /**
   * @remarks
   * The notification method. The system returns one or more values. Valid values:
   * 
   * *   **SMS**: text message
   * *   **EMAIL**: email.
   * *   **DINGDING**: DingTalk.
   * *   **DINGROBOT**: DingTalk chatbot.
   * *   **WEBHOOK**: webhook.
   * 
   * @example
   * EMAIL
   */
  notificationMode?: string;
  /**
   * @remarks
   * The UID of the Alibaba Cloud account of the user.
   * 
   * > An Alibaba Cloud account can contain one or more RAM users.
   * 
   * @example
   * 140692647406****
   */
  parentUid?: number;
  /**
   * @remarks
   * The list of role IDs.
   */
  roleIdList?: GetUserResponseBodyUserRoleIdList;
  /**
   * @remarks
   * The list of role names.
   */
  roleNameList?: GetUserResponseBodyUserRoleNameList;
  /**
   * @remarks
   * The signature method that is used to secure connections when a webhook URL is used. Valid values:
   * 
   * *   **NONE**: no signature.
   * *   **HMAC_SHA1**: HMAC_SHA1.
   * 
   * @example
   * NONE
   */
  signatureMethod?: string;
  /**
   * @remarks
   * The status of the user. Valid values:
   * 
   * *   **NORMAL**: The user is normal.
   * *   **DISABLE**: The user is disabled.
   * *   **DELETE**: The user is deleted.
   * 
   * @example
   * NORMAL
   */
  state?: string;
  /**
   * @remarks
   * The UID of the user.
   * 
   * @example
   * 22275482072787****
   */
  uid?: string;
  /**
   * @remarks
   * The ID of the user.
   * 
   * @example
   * 51****
   */
  userId?: string;
  /**
   * @remarks
   * The webhook URL that is used to receive notifications.
   * 
   * > 
   * 
   * *   If the user has set a webhook URL, DMS sends notifications to the specified URL.
   * 
   * *   The system does not return this parameter if the user has not set a webhook URL.
   * 
   * @example
   * http://dms-XXX.aliyun.com:8***
   */
  webhook?: string;
  static names(): { [key: string]: string } {
    return {
      curExecuteCount: 'CurExecuteCount',
      curResultCount: 'CurResultCount',
      dingRobot: 'DingRobot',
      email: 'Email',
      lastLoginTime: 'LastLoginTime',
      maxExecuteCount: 'MaxExecuteCount',
      maxResultCount: 'MaxResultCount',
      mobile: 'Mobile',
      nickName: 'NickName',
      notificationMode: 'NotificationMode',
      parentUid: 'ParentUid',
      roleIdList: 'RoleIdList',
      roleNameList: 'RoleNameList',
      signatureMethod: 'SignatureMethod',
      state: 'State',
      uid: 'Uid',
      userId: 'UserId',
      webhook: 'Webhook',
    };
  }

  static types(): { [key: string]: any } {
    return {
      curExecuteCount: 'number',
      curResultCount: 'number',
      dingRobot: 'string',
      email: 'string',
      lastLoginTime: 'string',
      maxExecuteCount: 'number',
      maxResultCount: 'number',
      mobile: 'string',
      nickName: 'string',
      notificationMode: 'string',
      parentUid: 'number',
      roleIdList: GetUserResponseBodyUserRoleIdList,
      roleNameList: GetUserResponseBodyUserRoleNameList,
      signatureMethod: 'string',
      state: 'string',
      uid: 'string',
      userId: 'string',
      webhook: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserActiveTenantResponseBodyTenant extends $tea.Model {
  /**
   * @remarks
   * The status of the tenant. Valid values:
   * 
   * *   **ACTIVE**: The tenant is used to access DMS.
   * *   **IN_ACTIVE**: The tenant is not used.
   * 
   * @example
   * ACTIVE
   */
  status?: string;
  /**
   * @remarks
   * The name of the tenant.
   * 
   * @example
   * test_name
   */
  tenantName?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      tenantName: 'TenantName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      tenantName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam extends $tea.Model {
  /**
   * @remarks
   * The name of the OSS bucket.
   * 
   * @example
   * test_bucket
   */
  bucketName?: string;
  /**
   * @remarks
   * The endpoint of the OSS bucket.
   * 
   * @example
   * http://oss-cn-hangzhou.aliyuncs.com
   */
  endpoint?: string;
  /**
   * @remarks
   * The name of the OSS object.
   * 
   * @example
   * test.sql
   */
  objectName?: string;
  static names(): { [key: string]: string } {
    return {
      bucketName: 'BucketName',
      endpoint: 'Endpoint',
      objectName: 'ObjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bucketName: 'string',
      endpoint: 'string',
      objectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserUploadFileJobResponseBodyUploadFileJobDetail extends $tea.Model {
  /**
   * @remarks
   * The key of the file that is returned after the file is uploaded. You can use this key when you upload the file as an attachment in a ticket.
   * 
   * @example
   * upload_3c7edea3-e4c3-4403-857d-737043036f69_test.sql
   */
  attachmentKey?: string;
  /**
   * @remarks
   * The name of the file.
   * 
   * @example
   * test.sql
   */
  fileName?: string;
  /**
   * @remarks
   * The size of the file. Unit: byte.
   * 
   * @example
   * 2968269
   */
  fileSize?: number;
  /**
   * @remarks
   * The purpose of the uploaded file. Valid values:
   * 
   * *   **datacorrect**: The file is uploaded to change data.
   * *   **order_info_attachment**: The file is uploaded as an attachment in a ticket.
   * *   **big-file**: The file is uploaded to import multiple data records at a time.
   * *   **sqlreview**: The file is uploaded for SQL review.
   * 
   * @example
   * datacorrect
   */
  fileSource?: string;
  /**
   * @remarks
   * The key of the file upload task.
   * 
   * @example
   * 65254a4c1614235217749100e
   */
  jobKey?: string;
  /**
   * @remarks
   * The status of the file upload task. Valid values:
   * 
   * *   **INIT**: The file upload task was initialized.
   * *   **PENDING**: The file upload task waited to be run.
   * *   **BE_SCHEDULED**: The file upload task waited to be scheduled.
   * *   **FAIL**: The file upload task failed.
   * *   **SUCCESS**: The file upload task was successful.
   * *   **RUNNING**: The file upload task was being run.
   * 
   * @example
   * SUCCESS
   */
  jobStatus?: string;
  /**
   * @remarks
   * The information about the status of the file upload task.
   * 
   * @example
   * success
   */
  jobStatusDesc?: string;
  /**
   * @remarks
   * The information about the Object Storage Service (OSS) bucket from which the file is uploaded.
   * 
   * > This parameter is returned if the value of **UploadType** is **OSS**.
   */
  uploadOSSParam?: GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam;
  /**
   * @remarks
   * The method used to upload the file. Valid values:
   * 
   * *   **URL**
   * *   **OSS**
   * 
   * @example
   * URL
   */
  uploadType?: string;
  /**
   * @remarks
   * The URL of the file.
   * 
   * > This parameter is returned if the value of **UploadType** is **URL**.
   * 
   * @example
   * http://xxxx/test.sql
   */
  uploadURL?: string;
  /**
   * @remarks
   * The size of the uploaded file. Unit: byte.
   * 
   * @example
   * 2968269
   */
  uploadedSize?: number;
  static names(): { [key: string]: string } {
    return {
      attachmentKey: 'AttachmentKey',
      fileName: 'FileName',
      fileSize: 'FileSize',
      fileSource: 'FileSource',
      jobKey: 'JobKey',
      jobStatus: 'JobStatus',
      jobStatusDesc: 'JobStatusDesc',
      uploadOSSParam: 'UploadOSSParam',
      uploadType: 'UploadType',
      uploadURL: 'UploadURL',
      uploadedSize: 'UploadedSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachmentKey: 'string',
      fileName: 'string',
      fileSize: 'number',
      fileSource: 'string',
      jobKey: 'string',
      jobStatus: 'string',
      jobStatusDesc: 'string',
      uploadOSSParam: GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam,
      uploadType: 'string',
      uploadURL: 'string',
      uploadedSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView extends $tea.Model {
  /**
   * @example
   * 2023-10-26 11:37:47
   */
  createTime?: string;
  /**
   * @example
   * 522****
   */
  creatorId?: number;
  description?: string;
  name?: string;
  /**
   * @example
   * 2592
   */
  templateId?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      creatorId: 'CreatorId',
      description: 'Description',
      name: 'Name',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      creatorId: 'number',
      description: 'string',
      name: 'string',
      templateId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAuthorityTemplateResponseBodyAuthorityTemplateViewList extends $tea.Model {
  authorityTemplateView?: ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView[];
  static names(): { [key: string]: string } {
    return {
      authorityTemplateView: 'AuthorityTemplateView',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorityTemplateView: { 'type': 'array', 'itemType': ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClassificationTemplatesResponseBodyTemplateList extends $tea.Model {
  /**
   * @remarks
   * The name of the classification template.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The remarks.
   * 
   * @example
   * test
   */
  remark?: string;
  /**
   * @remarks
   * The ID of the classification template.
   * 
   * @example
   * 3**
   */
  templateId?: number;
  /**
   * @remarks
   * The type of the classification template. Valid values:
   * 
   * *   **INNER**: built-in template
   * *   **USER_DEFINE**: custom template
   * 
   * @example
   * USER_DEFINE
   */
  templateType?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      remark: 'Remark',
      templateId: 'TemplateId',
      templateType: 'TemplateType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      remark: 'string',
      templateId: 'number',
      templateType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListColumnsResponseBodyColumnListColumn extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the column is an auto-increment column. Valid values:
   * 
   * *   true: The column is an auto-increment column.
   * *   false: The column is not an auto-increment column.
   * 
   * @example
   * false
   */
  autoIncrement?: boolean;
  /**
   * @remarks
   * The ID of the column.
   * 
   * @example
   * 62589****
   */
  columnId?: string;
  /**
   * @remarks
   * The name of the column.
   * 
   * @example
   * name
   */
  columnName?: string;
  /**
   * @remarks
   * The data type of the column.
   * 
   * @example
   * varchar
   */
  columnType?: string;
  /**
   * @remarks
   * The length of the field.
   * 
   * @example
   * 4
   */
  dataLength?: number;
  /**
   * @remarks
   * The number of valid digits for the field.
   * 
   * @example
   * 0
   */
  dataPrecision?: number;
  /**
   * @remarks
   * The number of decimal places for the field.
   * 
   * @example
   * 0
   */
  dataScale?: number;
  /**
   * @remarks
   * The default value of the column.
   * 
   * @example
   * def_value
   */
  defaultValue?: string;
  /**
   * @remarks
   * The description of the column.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The type of the masking algorithm that is used for the field. Valid values:
   * 
   * *   null: No masking algorithm is used.
   * *   DEFAULT: A full masking algorithm is used.
   * *   FIX_POS: The fixed position is masked.
   * *   FIX_CHAR: The fixed characters are replaced.
   * 
   * @example
   * DEFAULT
   */
  functionType?: string;
  /**
   * @remarks
   * Indicates whether the column can be empty. Valid values:
   * 
   * *   **true**: The column can be empty.
   * *   **false**: The column cannot be empty.
   * 
   * @example
   * false
   */
  nullable?: boolean;
  /**
   * @remarks
   * The security level of the column. Valid values:
   * 
   * *   INNER: The column is an internal column but not sensitive.
   * *   SENSITIVE: The column is a sensitive column.
   * *   CONFIDENTIAL: The column is a confidential column.
   * 
   * > For more information, see [Sensitivity levels of fields](https://help.aliyun.com/document_detail/66091.html).
   * 
   * @example
   * INNER
   */
  securityLevel?: string;
  /**
   * @remarks
   * Indicates whether the column is a sensitive column. Valid values:
   * 
   * *   **true**: The column is a sensitive column.
   * *   **false**: The column is not a sensitive column.
   * 
   * @example
   * false
   */
  sensitive?: boolean;
  static names(): { [key: string]: string } {
    return {
      autoIncrement: 'AutoIncrement',
      columnId: 'ColumnId',
      columnName: 'ColumnName',
      columnType: 'ColumnType',
      dataLength: 'DataLength',
      dataPrecision: 'DataPrecision',
      dataScale: 'DataScale',
      defaultValue: 'DefaultValue',
      description: 'Description',
      functionType: 'FunctionType',
      nullable: 'Nullable',
      securityLevel: 'SecurityLevel',
      sensitive: 'Sensitive',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoIncrement: 'boolean',
      columnId: 'string',
      columnName: 'string',
      columnType: 'string',
      dataLength: 'number',
      dataPrecision: 'number',
      dataScale: 'number',
      defaultValue: 'string',
      description: 'string',
      functionType: 'string',
      nullable: 'boolean',
      securityLevel: 'string',
      sensitive: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListColumnsResponseBodyColumnList extends $tea.Model {
  column?: ListColumnsResponseBodyColumnListColumn[];
  static names(): { [key: string]: string } {
    return {
      column: 'Column',
    };
  }

  static types(): { [key: string]: any } {
    return {
      column: { 'type': 'array', 'itemType': ListColumnsResponseBodyColumnListColumn },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDAGVersionsResponseBodyDagVersionListDagVersion extends $tea.Model {
  /**
   * @remarks
   * The name of the task flow.
   * 
   * @example
   * Spark SQL
   */
  dagName?: string;
  /**
   * @remarks
   * The ID of the task flow owner.
   * 
   * @example
   * 51****
   */
  dagOwnerId?: string;
  /**
   * @remarks
   * The name of the task flow owner.
   * 
   * @example
   * name
   */
  dagOwnerNickName?: string;
  /**
   * @remarks
   * The ID of the previously published version.
   * 
   * @example
   * 2****
   */
  lastVersionId?: number;
  /**
   * @remarks
   * The description of the version.
   * 
   * @example
   * test_OSS
   */
  versionComments?: string;
  /**
   * @remarks
   * The ID of the version.
   * 
   * @example
   * 2****
   */
  versionId?: number;
  static names(): { [key: string]: string } {
    return {
      dagName: 'DagName',
      dagOwnerId: 'DagOwnerId',
      dagOwnerNickName: 'DagOwnerNickName',
      lastVersionId: 'LastVersionId',
      versionComments: 'VersionComments',
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagName: 'string',
      dagOwnerId: 'string',
      dagOwnerNickName: 'string',
      lastVersionId: 'number',
      versionComments: 'string',
      versionId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDAGVersionsResponseBodyDagVersionList extends $tea.Model {
  dagVersion?: ListDAGVersionsResponseBodyDagVersionListDagVersion[];
  static names(): { [key: string]: string } {
    return {
      dagVersion: 'DagVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagVersion: { 'type': 'array', 'itemType': ListDAGVersionsResponseBodyDagVersionListDagVersion },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDBTaskSQLJobResponseBodyDBTaskSQLJobList extends $tea.Model {
  /**
   * @remarks
   * The description of the SQL task.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * The time when the SQL task was created.
   * 
   * @example
   * 2021-02-18 17:49:20
   */
  createTime?: string;
  /**
   * @remarks
   * The ID of the database.
   * 
   * @example
   * 43214523
   */
  dbId?: number;
  /**
   * @remarks
   * The name that is used to search for the database.
   * 
   * @example
   * test@xxx:3306test
   */
  dbSearchName?: string;
  /**
   * @remarks
   * The ID of the SQL task group.
   * 
   * @example
   * 4324132
   */
  dbTaskGroupId?: number;
  /**
   * @remarks
   * The ID of the SQL task.
   * 
   * @example
   * 123435
   */
  jobId?: number;
  /**
   * @remarks
   * The type of the SQL task.
   * 
   * @example
   * STRUCT_SYNC
   */
  jobType?: string;
  /**
   * @remarks
   * The time when the SQL task was last executed.
   * 
   * @example
   * 2021-02-18 17:49:31
   */
  lastExecTime?: string;
  /**
   * @remarks
   * Indicates whether the database is a logical database. Valid values:
   * 
   * *   **true**: The database is a logical database.
   * *   **false**: The database is a logical database.
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The state of the SQL task. Valid values:
   * 
   * *   **INIT**: The SQL task was initialized.
   * *   **PENDING**: The SQL task waited to be run.
   * *   **BE_SCHEDULED**: The SQL task waited to be scheduled.
   * *   **FAIL**: The SQL task failed.
   * *   **SUCCESS**: The SQL task was successful.
   * *   **PAUSE**: The SQL task was paused.
   * *   **DELETE**: The SQL task was deleted.
   * *   **RUNNING**: The SQL task was being run.
   * 
   * @example
   * SUCCESS
   */
  status?: string;
  /**
   * @remarks
   * Indicates whether the SQL task is executed as a transaction. Valid values:
   * 
   * *   **true**: The SQL task is executed as a transaction.
   * *   **false**: The SQL task is not executed as a transaction.
   * 
   * @example
   * false
   */
  transactional?: boolean;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      createTime: 'CreateTime',
      dbId: 'DbId',
      dbSearchName: 'DbSearchName',
      dbTaskGroupId: 'DbTaskGroupId',
      jobId: 'JobId',
      jobType: 'JobType',
      lastExecTime: 'LastExecTime',
      logic: 'Logic',
      status: 'Status',
      transactional: 'Transactional',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      createTime: 'string',
      dbId: 'number',
      dbSearchName: 'string',
      dbTaskGroupId: 'number',
      jobId: 'number',
      jobType: 'string',
      lastExecTime: 'string',
      logic: 'boolean',
      status: 'string',
      transactional: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList extends $tea.Model {
  /**
   * @remarks
   * The number of rows affected by the SQL task.
   * 
   * @example
   * 0
   */
  affectRows?: number;
  /**
   * @remarks
   * The SQL statement that was executed in the SQL task.
   * 
   * @example
   * update a set id = 1 where id  = 1;
   */
  currentSql?: string;
  /**
   * @remarks
   * The ID of the physical database.
   * 
   * @example
   * 1988****
   */
  dbId?: number;
  /**
   * @remarks
   * The point in time when the SQL task ended.
   * 
   * @example
   * 2021-12-16 00:00:01
   */
  endTime?: string;
  /**
   * @remarks
   * The number of times that the SQL statement was executed.
   * 
   * @example
   * 1
   */
  executeCount?: number;
  /**
   * @remarks
   * The ID of the details of the SQL task.
   * 
   * @example
   * 24723****
   */
  jobDetailId?: number;
  /**
   * @remarks
   * The ID of the SQL task.
   * 
   * @example
   * 1276****
   */
  jobId?: number;
  /**
   * @remarks
   * The details of the operational log.
   * 
   * @example
   * log_info
   */
  log?: string;
  /**
   * @remarks
   * Indicates whether the database is a logical database. Valid values:
   * 
   * *   **true**: The database is a logical database.
   * *   **false**: The database is a physical database.
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * Indicates whether the SQL statement was skipped. Valid values:
   * 
   * *   **true**: The SQL statement was skipped.
   * *   **false**: The SQL statement was not skipped.
   * 
   * @example
   * false
   */
  skip?: boolean;
  /**
   * @remarks
   * The type of the SQL statement, such as DELETE, UPDATE, or ALTER_TABLE.
   * 
   * @example
   * CREATE_TABLE
   */
  sqlType?: string;
  /**
   * @remarks
   * The point in time when the SQL task started.
   * 
   * @example
   * 2021-12-16 00:00:00
   */
  startTime?: string;
  /**
   * @remarks
   * The status of the SQL task. Valid values:
   * 
   * *   **INIT**: The SQL task was initialized.
   * *   **PENDING**: The SQL task waited to be run.
   * *   **BE_SCHEDULED**: The SQL task waited to be scheduled.
   * *   **FAIL**: The SQL task failed.
   * *   **SUCCESS**: The SQL task was successful.
   * *   **PAUSE**: The SQL task was paused.
   * *   **DELETE**: The SQL task was deleted.
   * *   **RUNNING**: The SQL task was being run.
   * 
   * @example
   * SUCCESS
   */
  status?: string;
  /**
   * @remarks
   * The duration of the SQL task. Unit: milliseconds.
   * 
   * @example
   * 38
   */
  timeDelay?: number;
  static names(): { [key: string]: string } {
    return {
      affectRows: 'AffectRows',
      currentSql: 'CurrentSql',
      dbId: 'DbId',
      endTime: 'EndTime',
      executeCount: 'ExecuteCount',
      jobDetailId: 'JobDetailId',
      jobId: 'JobId',
      log: 'Log',
      logic: 'Logic',
      skip: 'Skip',
      sqlType: 'SqlType',
      startTime: 'StartTime',
      status: 'Status',
      timeDelay: 'TimeDelay',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affectRows: 'number',
      currentSql: 'string',
      dbId: 'number',
      endTime: 'string',
      executeCount: 'number',
      jobDetailId: 'number',
      jobId: 'number',
      log: 'string',
      logic: 'boolean',
      skip: 'boolean',
      sqlType: 'string',
      startTime: 'string',
      status: 'string',
      timeDelay: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList extends $tea.Model {
  /**
   * @remarks
   * The ID of the SQL task group.
   * 
   * @example
   * 423515
   */
  DBTaskGroupId?: number;
  /**
   * @remarks
   * The number of SQL statements that are executed.
   * 
   * @example
   * 0
   */
  executeCount?: number;
  /**
   * @remarks
   * The script for data changes.
   * 
   * @example
   * ALTER TABLE test_toolkit_rename_table_after_rename MODIFY COLUMN gmt_modified datetime NOT NULL
   */
  scripts?: string;
  /**
   * @remarks
   * The description of the state.
   * 
   * @example
   * NONE
   */
  statusDesc?: string;
  /**
   * @remarks
   * The name of the table after the change.
   * 
   * @example
   * test_toolkit_rename_table_after_rename
   */
  tableName?: string;
  /**
   * @remarks
   * The state of the publishing task. Valid values:
   * 
   * *   **NONE**: The state of the task is unknown.
   * *   **SUCCESS**: The task is successful.
   * *   **FAIL**: The task fails.
   * 
   * @example
   * NONE
   */
  taskJobStatus?: string;
  static names(): { [key: string]: string } {
    return {
      DBTaskGroupId: 'DBTaskGroupId',
      executeCount: 'ExecuteCount',
      scripts: 'Scripts',
      statusDesc: 'StatusDesc',
      tableName: 'TableName',
      taskJobStatus: 'TaskJobStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DBTaskGroupId: 'number',
      executeCount: 'number',
      scripts: 'string',
      statusDesc: 'string',
      tableName: 'string',
      taskJobStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList extends $tea.Model {
  /**
   * @remarks
   * The ID of the database.
   * 
   * @example
   * 4325
   */
  dbId?: number;
  /**
   * @remarks
   * Indicates whether the database is a logical database. Valid values:
   * 
   * *   **true**: The database is a logical database.
   * *   **false**: the database is not a logical database.
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The time to publish the ticket.
   * 
   * @example
   * 2020-12-14 20:52:38
   */
  planTime?: string;
  /**
   * @remarks
   * The list of the publishing tasks.
   */
  publishJobList?: ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList[];
  /**
   * @remarks
   * The publishing policy. Valid values:
   * 
   * *   **IMMEDIATELY**: immediately publishes the ticket.
   * *   **REGULARLY**: publishes the ticket at a scheduled time.
   * 
   * @example
   * IMMEDIATELY
   */
  publishStrategy?: string;
  /**
   * @remarks
   * The description of the state.
   * 
   * @example
   * NONE
   */
  statusDesc?: string;
  /**
   * @remarks
   * The state of the task.
   * 
   * @example
   * NONE
   */
  taskJobStatus?: string;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      logic: 'Logic',
      planTime: 'PlanTime',
      publishJobList: 'PublishJobList',
      publishStrategy: 'PublishStrategy',
      statusDesc: 'StatusDesc',
      taskJobStatus: 'TaskJobStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      logic: 'boolean',
      planTime: 'string',
      publishJobList: { 'type': 'array', 'itemType': ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList },
      publishStrategy: 'string',
      statusDesc: 'string',
      taskJobStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDDLPublishRecordsResponseBodyDDLPublishRecordList extends $tea.Model {
  /**
   * @remarks
   * The time when the approval expires.
   * 
   * @example
   * 2020-12-14 20:52:38
   */
  auditExpireTime?: string;
  /**
   * @remarks
   * The approval state of the ticket. Valid values:
   * 
   * *   **EXEMPT_PASS**: The ticket passes without approval.
   * *   **TO_AUDIT**: The ticket is pending for approval.
   * *   **CANCEL**: The ticket is canceled.
   * *   **SUCCESS**: The ticket is approved.
   * *   **FAIL**: The ticket fails to pass the approval.
   * 
   * @example
   * CANCEL
   */
  auditStatus?: string;
  /**
   * @remarks
   * Release remarks.
   * 
   * @example
   * Release remarks
   */
  comment?: string;
  /**
   * @remarks
   * The ID of the user who creates the ticket. You can obtain the user ID by calling the [GetUser](https://help.aliyun.com/document_detail/147098.html) operation and querying the value of the UserId parameter. The value is not the unique ID (UID) of the Alibaba Cloud account.
   * 
   * @example
   * 1423
   */
  creatorId?: number;
  /**
   * @remarks
   * Indicates whether the approval is terminated. Valid values:
   * 
   * *   **true**: The approval is terminated.
   * *   **false**: The approval is not terminated.
   * 
   * > Multiple reasons can terminate the approval. For example, you withdraw the application or your ticket is not approved before the specified time.
   * 
   * @example
   * true
   */
  finality?: boolean;
  /**
   * @remarks
   * The reason for the termination.
   * 
   * @example
   * CANCEL
   */
  finalityReason?: string;
  /**
   * @remarks
   * The publishing state of the ticket. Valid values:
   * 
   * *   **START**: The ticket is created.
   * *   **ANALYZE**: The ticket is under analysis.
   * *   **AUDIT**: The ticket is under approval.
   * *   **DISPATCH**: A task is generated for the ticket.
   * *   **SUCCESS**: The task is successful.
   * 
   * @example
   * AUDIT
   */
  publishStatus?: string;
  /**
   * @remarks
   * The list of publishing tasks.
   */
  publishTaskInfoList?: ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList[];
  /**
   * @remarks
   * The risk level of the operation. Valid values:
   * 
   * *   **NONE_RISK**: The operation does not have risks.
   * *   **LOW_RISK**: The operation is at low risk.
   * *   **MIDDLE_RISK**: The operation is at medium risk.
   * *   **HIGH_RISK**: The operation is at high risk.
   * 
   * @example
   * LOW_RISK
   */
  riskLevel?: string;
  /**
   * @remarks
   * The description of the publishing state.
   * 
   * @example
   * CANCEL
   */
  statusDesc?: string;
  /**
   * @remarks
   * The ID of the approval process.
   * 
   * @example
   * 432153
   */
  workflowInstanceId?: number;
  static names(): { [key: string]: string } {
    return {
      auditExpireTime: 'AuditExpireTime',
      auditStatus: 'AuditStatus',
      comment: 'Comment',
      creatorId: 'CreatorId',
      finality: 'Finality',
      finalityReason: 'FinalityReason',
      publishStatus: 'PublishStatus',
      publishTaskInfoList: 'PublishTaskInfoList',
      riskLevel: 'RiskLevel',
      statusDesc: 'StatusDesc',
      workflowInstanceId: 'WorkflowInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      auditExpireTime: 'string',
      auditStatus: 'string',
      comment: 'string',
      creatorId: 'number',
      finality: 'boolean',
      finalityReason: 'string',
      publishStatus: 'string',
      publishTaskInfoList: { 'type': 'array', 'itemType': ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList },
      riskLevel: 'string',
      statusDesc: 'string',
      workflowInstanceId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataCorrectPreCheckDBResponseBodyPreCheckDBList extends $tea.Model {
  /**
   * @remarks
   * The ID of the database.
   * 
   * @example
   * 43***
   */
  dbId?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * test@localhost:3306
   */
  searchName?: string;
  /**
   * @remarks
   * The number of SQL statements.
   * 
   * @example
   * 1
   */
  sqlNum?: number;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      searchName: 'SearchName',
      sqlNum: 'SqlNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      searchName: 'string',
      sqlNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList extends $tea.Model {
  /**
   * @remarks
   * The estimated number of affected rows.
   * 
   * @example
   * 0
   */
  affectRows?: number;
  /**
   * @remarks
   * The SQL statement.
   * 
   * @example
   * OPTIMIZE TABLE `Text_TableNames`
   */
  checkSQL?: string;
  /**
   * @remarks
   * The ID of the database.
   * 
   * @example
   * 1930****
   */
  dbId?: number;
  /**
   * @remarks
   * The key that is used to query the details of optimization suggestions. You can call the [GetSQLReviewOptimizeDetail](https://help.aliyun.com/document_detail/265977.html) operation to query the details of optimization suggestions based on the key.
   * 
   * @example
   * b9e771fc6ec247dea6d06a32c777****
   */
  SQLReviewQueryKey?: string;
  /**
   * @remarks
   * The review status of the SQL statement. Valid values:
   * 
   * *   **WAITING**: The SQL statement is pending for review.
   * *   **RUNNING**: The SQL statement is being reviewed.
   * *   **IGNORE**: The SQL statement review is skipped.
   * *   **PASS**: The SQL statement passed the review.
   * *   **BLOCK**: The SQL statement failed the review.
   * 
   * @example
   * WAITING
   */
  sqlReviewStatus?: string;
  /**
   * @remarks
   * The type of the SQL statement, such as DELETE, UPDATE, or ALTER_TABLE.
   * 
   * @example
   * OPTIMIZE
   */
  sqlType?: string;
  /**
   * @remarks
   * The name of the table whose data is changed.
   * 
   * @example
   * Text_TableNames
   */
  tableNames?: string;
  static names(): { [key: string]: string } {
    return {
      affectRows: 'AffectRows',
      checkSQL: 'CheckSQL',
      dbId: 'DbId',
      SQLReviewQueryKey: 'SQLReviewQueryKey',
      sqlReviewStatus: 'SqlReviewStatus',
      sqlType: 'SqlType',
      tableNames: 'TableNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affectRows: 'number',
      checkSQL: 'string',
      dbId: 'number',
      SQLReviewQueryKey: 'string',
      sqlReviewStatus: 'string',
      sqlType: 'string',
      tableNames: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the precheck of the SQL statement was skipped. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  skip?: boolean;
  /**
   * @remarks
   * The SQL ID, which indicates the sequence number of the SQL statement. The number starts with 1.
   * 
   * @example
   * 1
   */
  sqlId?: number;
  /**
   * @remarks
   * The type of the SQL statement, such as DELETE, UPDATE, or ALTER_TABLE.
   * 
   * @example
   * INSERT
   */
  sqlType?: string;
  /**
   * @remarks
   * The state of the ticket. Valid values:
   * 
   * *   **INIT**: The ticket was being initialized.
   * *   **RUNNING**: The ticket was in progress.
   * *   **SUCCESS**: The ticket was complete.
   * *   **TIMEOUT**: The ticket was skipped due to timeout.
   * *   **FAIL**: The ticket failed.
   * 
   * @example
   * SUCCESS
   */
  statusCode?: string;
  static names(): { [key: string]: string } {
    return {
      skip: 'Skip',
      sqlId: 'SqlId',
      sqlType: 'SqlType',
      statusCode: 'StatusCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      skip: 'boolean',
      sqlId: 'number',
      sqlType: 'string',
      statusCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail extends $tea.Model {
  /**
   * @remarks
   * The time when the permission was created.
   * 
   * @example
   * 2019-12-12 00:00:00
   */
  createDate?: string;
  /**
   * @remarks
   * The time when the permissions expire.
   * 
   * @example
   * 2020-12-12 00:00:00
   */
  expireDate?: string;
  /**
   * @remarks
   * The extra information. This parameter is reserved.
   * 
   * @example
   * DEFAULT
   */
  extraData?: string;
  /**
   * @remarks
   * The description of the entity that authorizes the permission.
   * 
   * @example
   * xxx grant
   */
  originFrom?: string;
  /**
   * @remarks
   * The type of the permission. Valid values:
   * 
   * *   QUERY: the query permissions
   * *   EXPORT: the export permissions
   * *   CORRECT: the change permissions
   * 
   * @example
   * QUERY
   */
  permType?: string;
  /**
   * @remarks
   * The ID of the authorization record.
   * 
   * @example
   * 13434
   */
  userAccessId?: string;
  static names(): { [key: string]: string } {
    return {
      createDate: 'CreateDate',
      expireDate: 'ExpireDate',
      extraData: 'ExtraData',
      originFrom: 'OriginFrom',
      permType: 'PermType',
      userAccessId: 'UserAccessId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createDate: 'string',
      expireDate: 'string',
      extraData: 'string',
      originFrom: 'string',
      permType: 'string',
      userAccessId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails extends $tea.Model {
  permDetail?: ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail[];
  static names(): { [key: string]: string } {
    return {
      permDetail: 'PermDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      permDetail: { 'type': 'array', 'itemType': ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission extends $tea.Model {
  /**
   * @remarks
   * The alias of the database instance.
   * 
   * @example
   * instance_alias
   */
  alias?: string;
  /**
   * @remarks
   * The name of a column.
   * 
   * @example
   * column_name
   */
  columnName?: string;
  /**
   * @remarks
   * The ID of the database.
   * 
   * @example
   * 1234
   */
  dbId?: string;
  /**
   * @remarks
   * The type of the database engine.
   * 
   * @example
   * mysql
   */
  dbType?: string;
  /**
   * @remarks
   * The type of resources on which the user has permissions.
   * 
   * @example
   * DATABASE
   */
  dsType?: string;
  /**
   * @remarks
   * The type of the environment to which the database belongs.
   * 
   * @example
   * product
   */
  envType?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * 1443
   */
  instanceId?: string;
  /**
   * @remarks
   * Indicates whether the database is a logical database.
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The details of user permissions.
   */
  permDetails?: ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * xxx@xxxx:3306
   */
  schemaName?: string;
  /**
   * @remarks
   * The name that is used to search for the database.
   * 
   * @example
   * xxx
   */
  searchName?: string;
  /**
   * @remarks
   * The ID of the table.
   * 
   * @example
   * 42345
   */
  tableId?: string;
  /**
   * @remarks
   * The name of the table.
   * 
   * @example
   * table_name
   */
  tableName?: string;
  /**
   * @remarks
   * The ID of the user.
   * 
   * @example
   * 14324
   */
  userId?: string;
  /**
   * @remarks
   * The nickname of the user.
   * 
   * @example
   * user_nick_name
   */
  userNickName?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      columnName: 'ColumnName',
      dbId: 'DbId',
      dbType: 'DbType',
      dsType: 'DsType',
      envType: 'EnvType',
      instanceId: 'InstanceId',
      logic: 'Logic',
      permDetails: 'PermDetails',
      schemaName: 'SchemaName',
      searchName: 'SearchName',
      tableId: 'TableId',
      tableName: 'TableName',
      userId: 'UserId',
      userNickName: 'UserNickName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      columnName: 'string',
      dbId: 'string',
      dbType: 'string',
      dsType: 'string',
      envType: 'string',
      instanceId: 'string',
      logic: 'boolean',
      permDetails: ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails,
      schemaName: 'string',
      searchName: 'string',
      tableId: 'string',
      tableName: 'string',
      userId: 'string',
      userNickName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabaseUserPermssionsResponseBodyUserPermissions extends $tea.Model {
  userPermission?: ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission[];
  static names(): { [key: string]: string } {
    return {
      userPermission: 'UserPermission',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userPermission: { 'type': 'array', 'itemType': ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList extends $tea.Model {
  ownerIds?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerIds: 'OwnerIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList extends $tea.Model {
  ownerNames?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerNames: 'OwnerNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabasesResponseBodyDatabaseListDatabase extends $tea.Model {
  /**
   * @remarks
   * The name of the catalog to which the database belongs.
   * 
   * @example
   * 1
   */
  catalogName?: string;
  /**
   * @remarks
   * The ID of the database.
   * 
   * @example
   * 1
   */
  databaseId?: string;
  /**
   * @remarks
   * The type of the database engine.
   * 
   * @example
   * mysql
   */
  dbType?: string;
  /**
   * @remarks
   * The ID of the DBA.
   * 
   * @example
   * 1
   */
  dbaId?: string;
  /**
   * @remarks
   * The nickname of the Database administrator (DBA) to which the database belongs.
   * 
   * @example
   * dba_user
   */
  dbaName?: string;
  /**
   * @remarks
   * The encoding format of the database.
   * 
   * @example
   * utf-8
   */
  encoding?: string;
  /**
   * @remarks
   * The type of the environment to which the database belongs.
   * 
   * @example
   * dev
   */
  envType?: string;
  /**
   * @remarks
   * The endpoint of the instance to which the database belongs.
   * 
   * @example
   * xxx.xxx.xxx.xxx
   */
  host?: string;
  /**
   * @remarks
   * The ID of the instance to which the database belongs.
   * 
   * @example
   * 1
   */
  instanceId?: string;
  /**
   * @remarks
   * The IDs of the owners of the database.
   */
  ownerIdList?: ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList;
  /**
   * @remarks
   * The nicknames of the database owners.
   */
  ownerNameList?: ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList;
  /**
   * @remarks
   * The connection port of the instance to which the database belongs.
   * 
   * @example
   * 3306
   */
  port?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * test
   */
  schemaName?: string;
  /**
   * @remarks
   * The name that is used for searching the database.
   * 
   * @example
   * test@xxx.xxx.xxx.xxx:3306
   */
  searchName?: string;
  /**
   * @remarks
   * The system ID (SID) of the instance to which the database belongs.
   * 
   * @example
   * test
   */
  sid?: string;
  /**
   * @remarks
   * The state of the database. Valid values:
   * 
   * *   NORMAL: The database is normal.
   * *   DISABLE: The database is disabled.
   * *   OFFLINE: The database is unpublished.
   * *   NOT_EXIST: The database does not exist.
   * 
   * @example
   * NORMAL
   */
  state?: string;
  static names(): { [key: string]: string } {
    return {
      catalogName: 'CatalogName',
      databaseId: 'DatabaseId',
      dbType: 'DbType',
      dbaId: 'DbaId',
      dbaName: 'DbaName',
      encoding: 'Encoding',
      envType: 'EnvType',
      host: 'Host',
      instanceId: 'InstanceId',
      ownerIdList: 'OwnerIdList',
      ownerNameList: 'OwnerNameList',
      port: 'Port',
      schemaName: 'SchemaName',
      searchName: 'SearchName',
      sid: 'Sid',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      catalogName: 'string',
      databaseId: 'string',
      dbType: 'string',
      dbaId: 'string',
      dbaName: 'string',
      encoding: 'string',
      envType: 'string',
      host: 'string',
      instanceId: 'string',
      ownerIdList: ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList,
      ownerNameList: ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList,
      port: 'number',
      schemaName: 'string',
      searchName: 'string',
      sid: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDatabasesResponseBodyDatabaseList extends $tea.Model {
  database?: ListDatabasesResponseBodyDatabaseListDatabase[];
  static names(): { [key: string]: string } {
    return {
      database: 'Database',
    };
  }

  static types(): { [key: string]: any } {
    return {
      database: { 'type': 'array', 'itemType': ListDatabasesResponseBodyDatabaseListDatabase },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDefaultSLARulesResponseBodySLARuleListSLARule extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow.
   * 
   * @example
   * 0
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the SLA rule.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @remarks
   * The timeout period. Unit: minutes.
   * 
   * @example
   * 1080
   */
  intervalMinutes?: number;
  /**
   * @remarks
   * The ID of the task node.
   * 
   * @example
   * 0
   */
  nodeId?: number;
  /**
   * @remarks
   * The type of the rule. Valid values:
   * 
   * *   **0**: an SLA rule for a task flow
   * *   **1**: an SLA rule for a task node
   * 
   * @example
   * 0
   */
  ruleType?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      id: 'Id',
      intervalMinutes: 'IntervalMinutes',
      nodeId: 'NodeId',
      ruleType: 'RuleType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      id: 'number',
      intervalMinutes: 'number',
      nodeId: 'number',
      ruleType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDefaultSLARulesResponseBodySLARuleList extends $tea.Model {
  SLARule?: ListDefaultSLARulesResponseBodySLARuleListSLARule[];
  static names(): { [key: string]: string } {
    return {
      SLARule: 'SLARule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      SLARule: { 'type': 'array', 'itemType': ListDefaultSLARulesResponseBodySLARuleListSLARule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDesensitizationRuleResponseBodyDesensitizationRuleList extends $tea.Model {
  /**
   * @remarks
   * The parameter.
   * 
   * @example
   * {paramName: salt, paramValue: 1}
   */
  funcParams?: string;
  /**
   * @remarks
   * The example.
   * 
   * @example
   * [{paramName: testStr, paramValue: 1}]
   */
  funcSample?: string;
  /**
   * @remarks
   * The algorithm type.
   * 
   * @example
   * MD5
   */
  functionType?: string;
  /**
   * @remarks
   * The ID of the user who last modified the masking rule.
   * 
   * @example
   * 2
   */
  lastModifierId?: string;
  /**
   * @remarks
   * The name of the user who last modified the masking rule.
   * 
   * @example
   * test user
   */
  lastModifierName?: string;
  /**
   * @remarks
   * The number of times that the masking was used.
   * 
   * @example
   * 1
   */
  referenceCount?: number;
  /**
   * @remarks
   * The description of the rule.
   * 
   * @example
   * hash desensitization algorithm
   */
  ruleDesc?: string;
  /**
   * @remarks
   * The ID of the masking rule.
   * 
   * @example
   * 23
   */
  ruleId?: number;
  /**
   * @remarks
   * The name of the masking rule.
   * 
   * @example
   * default desensitization rule test
   */
  ruleName?: string;
  /**
   * @remarks
   * The algorithm used for masking.
   * 
   * @example
   * HASH
   */
  ruleType?: string;
  static names(): { [key: string]: string } {
    return {
      funcParams: 'FuncParams',
      funcSample: 'FuncSample',
      functionType: 'FunctionType',
      lastModifierId: 'LastModifierId',
      lastModifierName: 'LastModifierName',
      referenceCount: 'ReferenceCount',
      ruleDesc: 'RuleDesc',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      ruleType: 'RuleType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      funcParams: 'string',
      funcSample: 'string',
      functionType: 'string',
      lastModifierId: 'string',
      lastModifierName: 'string',
      referenceCount: 'number',
      ruleDesc: 'string',
      ruleId: 'number',
      ruleName: 'string',
      ruleType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEffectiveOrdersResponseBodyOrderSummaryOrderList extends $tea.Model {
  /**
   * @remarks
   * The UID of the user who placed the order.
   * 
   * @example
   * 2698420314****
   */
  buyerId?: string;
  /**
   * @remarks
   * The time when the instance expires.
   * 
   * @example
   * 2022-11-24 00:00:00
   */
  endTime?: string;
  /**
   * @remarks
   * The maximum number of database instances that you can use DMS to manage.
   * 
   * @example
   * 7
   */
  insNum?: string;
  /**
   * @remarks
   * The ID of the instance for the purchased service.
   * 
   * @example
   * rm-bp1xd1v866****
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the order.
   * 
   * @example
   * 2190037****
   */
  orderId?: string;
  /**
   * @remarks
   * The time when the instance is started.
   * 
   * @example
   * 2022-10-24 00:00:00
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      buyerId: 'BuyerId',
      endTime: 'EndTime',
      insNum: 'InsNum',
      instanceId: 'InstanceId',
      orderId: 'OrderId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      buyerId: 'string',
      endTime: 'string',
      insNum: 'string',
      instanceId: 'string',
      orderId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEffectiveOrdersResponseBodyOrderSummary extends $tea.Model {
  /**
   * @remarks
   * The commodity code of DMS.
   * 
   * *   dms_pre_public_cn: DMS that uses the subscription billing method
   * *   dms_post_public_cn: DMS that uses the pay-as-you-go billing method
   * 
   * @example
   * dms_pre_public_cn
   */
  commodityCode?: string;
  /**
   * @remarks
   * The type of the service.
   * 
   * *   **VersionType**: DMS that supports control modes
   * *   **SensitiveDataProtection**: DMS that supports sensitive data protection
   * 
   * @example
   * VersionType
   */
  commodityType?: string;
  /**
   * @remarks
   * Details about the orders.
   */
  orderList?: ListEffectiveOrdersResponseBodyOrderSummaryOrderList[];
  /**
   * @remarks
   * The sum of the number of instances that you can use DMS to manage in all orders.
   * 
   * @example
   * 12
   */
  totalQuota?: number;
  /**
   * @remarks
   * The control mode of DMS. Valid values:
   * 
   * *   **stand**: Stable Change
   * *   **safety**: Security Collaboration
   * 
   * @example
   * safety
   */
  versionType?: string;
  static names(): { [key: string]: string } {
    return {
      commodityCode: 'CommodityCode',
      commodityType: 'CommodityType',
      orderList: 'OrderList',
      totalQuota: 'TotalQuota',
      versionType: 'VersionType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commodityCode: 'string',
      commodityType: 'string',
      orderList: { 'type': 'array', 'itemType': ListEffectiveOrdersResponseBodyOrderSummaryOrderList },
      totalQuota: 'number',
      versionType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListIndexesResponseBodyIndexListIndex extends $tea.Model {
  /**
   * @remarks
   * The description of the index.
   * 
   * @example
   * test
   */
  indexComment?: string;
  /**
   * @remarks
   * The ID of the index.
   * 
   * @example
   * 1
   */
  indexId?: string;
  /**
   * @remarks
   * The name of the index.
   * 
   * @example
   * idx_test
   */
  indexName?: string;
  /**
   * @remarks
   * The type of the index. Valid values:
   * 
   * *   Primary
   * *   Unique
   * *   Normal
   * *   FullText
   * *   Spatial
   * 
   * @example
   * Primary
   */
  indexType?: string;
  /**
   * @remarks
   * The ID of the table.
   * 
   * @example
   * 1
   */
  tableId?: string;
  static names(): { [key: string]: string } {
    return {
      indexComment: 'IndexComment',
      indexId: 'IndexId',
      indexName: 'IndexName',
      indexType: 'IndexType',
      tableId: 'TableId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      indexComment: 'string',
      indexId: 'string',
      indexName: 'string',
      indexType: 'string',
      tableId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListIndexesResponseBodyIndexList extends $tea.Model {
  index?: ListIndexesResponseBodyIndexListIndex[];
  static names(): { [key: string]: string } {
    return {
      index: 'Index',
    };
  }

  static types(): { [key: string]: any } {
    return {
      index: { 'type': 'array', 'itemType': ListIndexesResponseBodyIndexListIndex },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog extends $tea.Model {
  /**
   * @remarks
   * The database account that is used to log on to the instance.
   * 
   * @example
   * test_User
   */
  dbUser?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * 177****
   */
  instanceId?: number;
  /**
   * @remarks
   * The name of the instance.
   * 
   * @example
   * rm-bp144d5ky4l4rli0417****.mysql.rds.aliyuncs.com:3306[rm-bp144d5ky4l4r****]
   */
  instanceName?: string;
  /**
   * @remarks
   * The time when the user performed an operation on the instance.
   * 
   * @example
   * 2021-11-18 11:13:26
   */
  opTime?: string;
  /**
   * @remarks
   * The source IP address of the request.
   * 
   * @example
   * 117.36.XX.XX,100.104.XX.XX
   */
  requestIp?: string;
  /**
   * @remarks
   * The ID of the user.
   * 
   * @example
   * 12****
   */
  userId?: number;
  /**
   * @remarks
   * The alias of the user.
   * 
   * @example
   * test_UserName
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      dbUser: 'DbUser',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      opTime: 'OpTime',
      requestIp: 'RequestIp',
      userId: 'UserId',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbUser: 'string',
      instanceId: 'number',
      instanceName: 'string',
      opTime: 'string',
      requestIp: 'string',
      userId: 'number',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList extends $tea.Model {
  instanceLoginAuditLog?: ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog[];
  static names(): { [key: string]: string } {
    return {
      instanceLoginAuditLog: 'InstanceLoginAuditLog',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceLoginAuditLog: { 'type': 'array', 'itemType': ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail extends $tea.Model {
  /**
   * @remarks
   * The time when the permissions were granted.
   * 
   * @example
   * 2019-12-12 00:00:00
   */
  createDate?: string;
  /**
   * @remarks
   * The time when the permissions expire.
   * 
   * @example
   * 2020-12-12 00:00:00
   */
  expireDate?: string;
  /**
   * @remarks
   * This parameter is reserved.
   * 
   * @example
   * XXX
   */
  extraData?: string;
  /**
   * @remarks
   * The user who grants the permissions.
   * 
   * @example
   * xxx authorization
   */
  originFrom?: string;
  /**
   * @remarks
   * The type of the permissions. Valid values:
   * 
   * *   LOGIN: the logon permissions
   * *   PERF: the query permissions on the instance
   * 
   * @example
   * LOGIN
   */
  permType?: string;
  /**
   * @remarks
   * The ID of the authorization record.
   * 
   * @example
   * 773****
   */
  userAccessId?: string;
  static names(): { [key: string]: string } {
    return {
      createDate: 'CreateDate',
      expireDate: 'ExpireDate',
      extraData: 'ExtraData',
      originFrom: 'OriginFrom',
      permType: 'PermType',
      userAccessId: 'UserAccessId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createDate: 'string',
      expireDate: 'string',
      extraData: 'string',
      originFrom: 'string',
      permType: 'string',
      userAccessId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails extends $tea.Model {
  permDetail?: ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail[];
  static names(): { [key: string]: string } {
    return {
      permDetail: 'PermDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      permDetail: { 'type': 'array', 'itemType': ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * 174****
   */
  instanceId?: string;
  /**
   * @remarks
   * The details of permissions.
   */
  permDetails?: ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails;
  /**
   * @remarks
   * The ID of the user.
   * 
   * @example
   * 51****
   */
  userId?: string;
  /**
   * @remarks
   * The nickname of the user.
   * 
   * @example
   * test_nick_name
   */
  userNickName?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      permDetails: 'PermDetails',
      userId: 'UserId',
      userNickName: 'UserNickName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      permDetails: ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails,
      userId: 'string',
      userNickName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceUserPermissionsResponseBodyUserPermissions extends $tea.Model {
  userPermission?: ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission[];
  static names(): { [key: string]: string } {
    return {
      userPermission: 'UserPermission',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userPermission: { 'type': 'array', 'itemType': ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstancesResponseBodyInstanceListInstanceOwnerIdList extends $tea.Model {
  ownerIds?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerIds: 'OwnerIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstancesResponseBodyInstanceListInstanceOwnerNameList extends $tea.Model {
  ownerNames?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerNames: 'OwnerNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstancesResponseBodyInstanceListInstanceStandardGroup extends $tea.Model {
  /**
   * @remarks
   * The type of the control mode. Valid values:
   * 
   * *   **COMMON**: Security Collaboration
   * *   **NONE_CONTROL**: Flexible Management
   * *   **STABLE**: Stable Change
   * 
   * @example
   * COMMON
   */
  groupMode?: string;
  /**
   * @remarks
   * The name of the security rule corresponding to the control mode.
   * 
   * @example
   * test
   */
  groupName?: string;
  static names(): { [key: string]: string } {
    return {
      groupMode: 'GroupMode',
      groupName: 'GroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupMode: 'string',
      groupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstancesResponseBodyInstanceListInstance extends $tea.Model {
  /**
   * @remarks
   * The name of the database link for the database instance.
   * 
   * @example
   * dblink_test
   */
  dataLinkName?: string;
  /**
   * @remarks
   * The password that is used to log on to the database instance.
   * 
   * @example
   * ******
   */
  databasePassword?: string;
  /**
   * @remarks
   * The account that is used to log on to the database.
   * 
   * @example
   * dbUser
   */
  databaseUser?: string;
  /**
   * @remarks
   * The ID of the database administrator (DBA) of the database instance.
   * 
   * @example
   * 31****
   */
  dbaId?: string;
  /**
   * @remarks
   * The nickname of the DBA of the instance.
   * 
   * @example
   * dbaName
   */
  dbaNickName?: string;
  /**
   * @remarks
   * Indicates whether the lock-free schema change feature is enabled for the database instance.
   * 
   * @example
   * 1
   */
  ddlOnline?: number;
  /**
   * @remarks
   * The ID of the ECS instance on which the database instance is deployed.
   * 
   * @example
   * 150****
   */
  ecsInstanceId?: string;
  /**
   * @remarks
   * The ID of the region in which the database instance resides.
   * 
   * @example
   * cn-hangzhou
   */
  ecsRegion?: string;
  /**
   * @remarks
   * The type of the environment to which the database instance belongs. Valid values:
   * 
   * *   **product:** production environment
   * *   **dev**: development environment
   * *   **pre**: pre-release environment
   * *   **test**: test environment
   * *   **sit**: SIT environment
   * *   **uat**: UAT environment
   * *   **pet**: stress testing environment
   * *   **stag:** staging environment
   * 
   * @example
   * product
   */
  envType?: string;
  /**
   * @remarks
   * The timeout period for exporting data from the database instance.
   * 
   * @example
   * 86400
   */
  exportTimeout?: number;
  /**
   * @remarks
   * The host address that is used to connect to the database instance.
   * 
   * @example
   * ****.mysql.rds.aliyuncs.com
   */
  host?: string;
  /**
   * @remarks
   * The alias of the database instance.
   * 
   * @example
   * test
   */
  instanceAlias?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * 150***
   */
  instanceId?: string;
  /**
   * @remarks
   * The source of the database instance.
   * 
   * @example
   * RDS
   */
  instanceSource?: string;
  /**
   * @remarks
   * The type of the database instance.
   * 
   * @example
   * mysql
   */
  instanceType?: string;
  /**
   * @remarks
   * The IDs of the owners of the database instance.
   */
  ownerIdList?: ListInstancesResponseBodyInstanceListInstanceOwnerIdList;
  /**
   * @remarks
   * The nicknames of the owners of the database instance.
   */
  ownerNameList?: ListInstancesResponseBodyInstanceListInstanceOwnerNameList;
  /**
   * @remarks
   * The port number that is used to connect to the database instance.
   * 
   * @example
   * 3306
   */
  port?: number;
  /**
   * @remarks
   * The timeout period for querying data in the database instance.
   * 
   * @example
   * 60
   */
  queryTimeout?: number;
  /**
   * @remarks
   * The ID of the security rule set of the database instance.
   * 
   * @example
   * 1
   */
  safeRuleId?: string;
  /**
   * @remarks
   * Indicates whether the sensitive data protection feature is enabled. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  sellSitd?: boolean;
  /**
   * @remarks
   * The system ID (SID) of the database instance.
   * 
   * @example
   * test
   */
  sid?: string;
  /**
   * @remarks
   * The control mode of the database instance.
   */
  standardGroup?: ListInstancesResponseBodyInstanceListInstanceStandardGroup;
  /**
   * @remarks
   * The status of the database instance.
   * 
   * @example
   * NORMAL
   */
  state?: string;
  /**
   * @remarks
   * Indicates whether the cross-database query feature is enabled for the database instance. Valid values:
   * 
   * *   **0**: disabled
   * *   **1:**: enabled
   * 
   * @example
   * 1
   */
  useDsql?: number;
  /**
   * @remarks
   * The ID of the VPC to which the database instance belongs.
   * 
   * @example
   * vpc-o6wrloqsdqc9io3mg****
   */
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      dataLinkName: 'DataLinkName',
      databasePassword: 'DatabasePassword',
      databaseUser: 'DatabaseUser',
      dbaId: 'DbaId',
      dbaNickName: 'DbaNickName',
      ddlOnline: 'DdlOnline',
      ecsInstanceId: 'EcsInstanceId',
      ecsRegion: 'EcsRegion',
      envType: 'EnvType',
      exportTimeout: 'ExportTimeout',
      host: 'Host',
      instanceAlias: 'InstanceAlias',
      instanceId: 'InstanceId',
      instanceSource: 'InstanceSource',
      instanceType: 'InstanceType',
      ownerIdList: 'OwnerIdList',
      ownerNameList: 'OwnerNameList',
      port: 'Port',
      queryTimeout: 'QueryTimeout',
      safeRuleId: 'SafeRuleId',
      sellSitd: 'SellSitd',
      sid: 'Sid',
      standardGroup: 'StandardGroup',
      state: 'State',
      useDsql: 'UseDsql',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataLinkName: 'string',
      databasePassword: 'string',
      databaseUser: 'string',
      dbaId: 'string',
      dbaNickName: 'string',
      ddlOnline: 'number',
      ecsInstanceId: 'string',
      ecsRegion: 'string',
      envType: 'string',
      exportTimeout: 'number',
      host: 'string',
      instanceAlias: 'string',
      instanceId: 'string',
      instanceSource: 'string',
      instanceType: 'string',
      ownerIdList: ListInstancesResponseBodyInstanceListInstanceOwnerIdList,
      ownerNameList: ListInstancesResponseBodyInstanceListInstanceOwnerNameList,
      port: 'number',
      queryTimeout: 'number',
      safeRuleId: 'string',
      sellSitd: 'boolean',
      sid: 'string',
      standardGroup: ListInstancesResponseBodyInstanceListInstanceStandardGroup,
      state: 'string',
      useDsql: 'number',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstancesResponseBodyInstanceList extends $tea.Model {
  instance?: ListInstancesResponseBodyInstanceListInstance[];
  static names(): { [key: string]: string } {
    return {
      instance: 'Instance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instance: { 'type': 'array', 'itemType': ListInstancesResponseBodyInstanceListInstance },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the task flow can be modified. Valid values:
   * 
   * *   **true**: The task flow can be modified.
   * *   **false**: The task flow cannot be modified.
   * 
   * @example
   * true
   */
  canEdit?: boolean;
  /**
   * @remarks
   * The ID of the user who creates the task flow.
   * 
   * @example
   * 51****
   */
  creatorId?: string;
  /**
   * @remarks
   * The name of the user who creates the workspace.
   * 
   * @example
   * Creator_Name
   */
  creatorNickName?: string;
  /**
   * @remarks
   * The name of the task flow.
   * 
   * @example
   * Dag_Name
   */
  dagName?: string;
  /**
   * @remarks
   * The user ID of the task flow owner.
   * 
   * @example
   * 51****
   */
  dagOwnerId?: string;
  /**
   * @remarks
   * The name of the task flow owner.
   * 
   * @example
   * Owner_Name
   */
  dagOwnerNickName?: string;
  /**
   * @remarks
   * The extended field. No meaning is specified for this field.
   * 
   * @example
   * -
   */
  dataFlowId?: number;
  /**
   * @remarks
   * The extended field. No meaning is specified for this field.
   * 
   * @example
   * -
   */
  demoId?: string;
  /**
   * @remarks
   * The ID of the latest deployment record.
   * 
   * @example
   * 12**
   */
  deployId?: number;
  /**
   * @remarks
   * The ID of the task flow.
   * 
   * @example
   * 134137****
   */
  id?: number;
  /**
   * @remarks
   * Indicates whether the task flow is deleted. Valid values:
   * 
   * *   **true**: deleted
   * *   **false**: not deleted
   * 
   * @example
   * false
   */
  isDeleted?: boolean;
  /**
   * @remarks
   * The status of the latest execution. Valid values:
   * 
   * *   **0**: invalid
   * *   **1**: scheduling disabled
   * *   **2**: waiting to be scheduled
   * 
   * @example
   * 0
   */
  latestInstanceStatus?: number;
  /**
   * @remarks
   * The time when the latest execution record was generated.
   * 
   * @example
   * 2022-04-14
   */
  latestInstanceTime?: number;
  /**
   * @remarks
   * The ID of the business scenario.
   * 
   * @example
   * 2**
   */
  scenarioId?: number;
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * @example
   * 1
   */
  spaceId?: number;
  /**
   * @remarks
   * The status of the task flow. Valid values:
   * 
   * *   **0**: invalid
   * *   **1**: scheduling disabled
   * *   **2**: waiting to be scheduled
   * 
   * @example
   * 2
   */
  status?: number;
  static names(): { [key: string]: string } {
    return {
      canEdit: 'CanEdit',
      creatorId: 'CreatorId',
      creatorNickName: 'CreatorNickName',
      dagName: 'DagName',
      dagOwnerId: 'DagOwnerId',
      dagOwnerNickName: 'DagOwnerNickName',
      dataFlowId: 'DataFlowId',
      demoId: 'DemoId',
      deployId: 'DeployId',
      id: 'Id',
      isDeleted: 'IsDeleted',
      latestInstanceStatus: 'LatestInstanceStatus',
      latestInstanceTime: 'LatestInstanceTime',
      scenarioId: 'ScenarioId',
      spaceId: 'SpaceId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canEdit: 'boolean',
      creatorId: 'string',
      creatorNickName: 'string',
      dagName: 'string',
      dagOwnerId: 'string',
      dagOwnerNickName: 'string',
      dataFlowId: 'number',
      demoId: 'string',
      deployId: 'number',
      id: 'number',
      isDeleted: 'boolean',
      latestInstanceStatus: 'number',
      latestInstanceTime: 'number',
      scenarioId: 'number',
      spaceId: 'number',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLhTaskFlowAndScenarioResponseBodyRawDAGList extends $tea.Model {
  dag?: ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag[];
  static names(): { [key: string]: string } {
    return {
      dag: 'Dag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dag: { 'type': 'array', 'itemType': ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the task flow can be modified. Valid values:
   * 
   * - **true**: The task flow can be modified.
   * - **false**: The task flow cannot be modified.
   * 
   * @example
   * true
   */
  canEdit?: boolean;
  /**
   * @remarks
   * The ID of the user who creates the task flow.
   * 
   * @example
   * 51****
   */
  creatorId?: string;
  /**
   * @remarks
   * The name of the user who creates the workspace.
   * 
   * @example
   * Creator_Name
   */
  creatorNickName?: string;
  /**
   * @remarks
   * The name of the task flow.
   * 
   * @example
   * Dag_Name
   */
  dagName?: string;
  /**
   * @remarks
   * The user ID of the task flow owner.
   * 
   * @example
   * 51****
   */
  dagOwnerId?: string;
  /**
   * @remarks
   * The name of the task flow owner.
   * 
   * @example
   * Owner_Name
   */
  dagOwnerNickName?: string;
  /**
   * @remarks
   * The extended field. No meaning is specified for this field.
   * 
   * @example
   * -
   */
  dataFlowId?: number;
  /**
   * @remarks
   * The extended field. No meaning is specified for this field.
   * 
   * @example
   * -
   */
  demoId?: string;
  /**
   * @remarks
   * The ID of the latest deployment record.
   * 
   * @example
   * 12**
   */
  deployId?: number;
  /**
   * @remarks
   * The ID of the task flow.
   * 
   * @example
   * 9***
   */
  id?: number;
  /**
   * @remarks
   * Indicates whether the task flow is deleted. Valid values:
   * 
   * - **true**: deleted
   * - **false**: not deleted
   * 
   * @example
   * false
   */
  isDeleted?: boolean;
  /**
   * @remarks
   * The status of the latest execution. Valid values:
   * 
   * - 0: invalid
   * - 1: scheduling disabled
   * - 2: waiting to be scheduled
   * 
   * @example
   * 1
   */
  latestInstanceStatus?: number;
  /**
   * @remarks
   * The time when the latest execution record was generated.
   * 
   * @example
   * 2022-04-14
   */
  latestInstanceTime?: number;
  /**
   * @remarks
   * The ID of the business scenario.
   * 
   * @example
   * 2**
   */
  scenarioId?: number;
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * @example
   * 1
   */
  spaceId?: number;
  /**
   * @remarks
   * The status of the task flow. Valid values:
   * 
   * - **0**: invalid
   * - **1**: scheduling disabled
   * - **2**: waiting to be scheduled
   * 
   * @example
   * 1
   */
  status?: number;
  static names(): { [key: string]: string } {
    return {
      canEdit: 'CanEdit',
      creatorId: 'CreatorId',
      creatorNickName: 'CreatorNickName',
      dagName: 'DagName',
      dagOwnerId: 'DagOwnerId',
      dagOwnerNickName: 'DagOwnerNickName',
      dataFlowId: 'DataFlowId',
      demoId: 'DemoId',
      deployId: 'DeployId',
      id: 'Id',
      isDeleted: 'IsDeleted',
      latestInstanceStatus: 'LatestInstanceStatus',
      latestInstanceTime: 'LatestInstanceTime',
      scenarioId: 'ScenarioId',
      spaceId: 'SpaceId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canEdit: 'boolean',
      creatorId: 'string',
      creatorNickName: 'string',
      dagName: 'string',
      dagOwnerId: 'string',
      dagOwnerNickName: 'string',
      dataFlowId: 'number',
      demoId: 'string',
      deployId: 'number',
      id: 'number',
      isDeleted: 'boolean',
      latestInstanceStatus: 'number',
      latestInstanceTime: 'number',
      scenarioId: 'number',
      spaceId: 'number',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList extends $tea.Model {
  dag?: ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag[];
  static names(): { [key: string]: string } {
    return {
      dag: 'Dag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dag: { 'type': 'array', 'itemType': ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario extends $tea.Model {
  /**
   * @remarks
   * The ID of the user who creates the business scenario.
   * 
   * @example
   * 51****
   */
  creatorId?: string;
  /**
   * @remarks
   * The description of the business scenario.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The name of the business scenario.
   * 
   * @example
   * Scenario_2
   */
  scenarioName?: string;
  static names(): { [key: string]: string } {
    return {
      creatorId: 'CreatorId',
      description: 'Description',
      scenarioName: 'ScenarioName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorId: 'string',
      description: 'string',
      scenarioName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG extends $tea.Model {
  /**
   * @remarks
   * The list of task flows.
   */
  dagList?: ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList;
  /**
   * @remarks
   * The information about the business scenario.
   */
  scenario?: ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario;
  static names(): { [key: string]: string } {
    return {
      dagList: 'DagList',
      scenario: 'Scenario',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagList: ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList,
      scenario: ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList extends $tea.Model {
  scenarioDAG?: ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG[];
  static names(): { [key: string]: string } {
    return {
      scenarioDAG: 'ScenarioDAG',
    };
  }

  static types(): { [key: string]: any } {
    return {
      scenarioDAG: { 'type': 'array', 'itemType': ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds extends $tea.Model {
  databaseIds?: number[];
  static names(): { [key: string]: string } {
    return {
      databaseIds: 'DatabaseIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseIds: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList extends $tea.Model {
  ownerIds?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerIds: 'OwnerIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList extends $tea.Model {
  ownerNames?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerNames: 'OwnerNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase extends $tea.Model {
  /**
   * @remarks
   * The alias of the logical database.
   * 
   * @example
   * logic_db_alias
   */
  alias?: string;
  /**
   * @remarks
   * The ID of the logical database.
   * 
   * @example
   * 1***
   */
  databaseId?: string;
  /**
   * @remarks
   * Logical database sub-ID list.
   */
  databaseIds?: ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds;
  /**
   * @remarks
   * The type of the logical database. For more information about the valid values of this parameter, see [DbType parameter](https://www.alibabacloud.com/help/en/data-management-service/latest/dbtype-parameter).
   * 
   * @example
   * polardb
   */
  dbType?: string;
  /**
   * @remarks
   * The type of the environment to which the logical database belongs. Valid values:
   * 
   * - **product**: production environment
   * - **dev**: development environment
   * - **pre**: staging environment
   * - **test**: test environment
   * - **sit**: system integration testing (SIT) environment
   * - **uat**: user acceptance testing (UAT) environment
   * - **pet**: stress testing environment
   * - **stag**: STAG environment
   * 
   * @example
   * test
   */
  envType?: string;
  /**
   * @remarks
   * Indicates whether the database is a logical database. The return value is true.
   * 
   * @example
   * true
   */
  logic?: boolean;
  /**
   * @remarks
   * The IDs of the owners of the logical database.
   */
  ownerIdList?: ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList;
  /**
   * @remarks
   * The names of the owners of the logical database.
   */
  ownerNameList?: ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList;
  /**
   * @remarks
   * The name of the logical database.
   * 
   * @example
   * logic_db
   */
  schemaName?: string;
  /**
   * @remarks
   * The name that is used to search for the logical database.
   * 
   * > We recommend that you do not use this parameter for business development. The format of the parameter value may be modified in later versions.
   * 
   * @example
   * logic_db[logic_db_alias]
   */
  searchName?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      databaseId: 'DatabaseId',
      databaseIds: 'DatabaseIds',
      dbType: 'DbType',
      envType: 'EnvType',
      logic: 'Logic',
      ownerIdList: 'OwnerIdList',
      ownerNameList: 'OwnerNameList',
      schemaName: 'SchemaName',
      searchName: 'SearchName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      databaseId: 'string',
      databaseIds: ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds,
      dbType: 'string',
      envType: 'string',
      logic: 'boolean',
      ownerIdList: ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList,
      ownerNameList: ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList,
      schemaName: 'string',
      searchName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicDatabasesResponseBodyLogicDatabaseList extends $tea.Model {
  logicDatabase?: ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase[];
  static names(): { [key: string]: string } {
    return {
      logicDatabase: 'LogicDatabase',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logicDatabase: { 'type': 'array', 'itemType': ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig extends $tea.Model {
  /**
   * @remarks
   * The routing algorithm expression.
   * 
   * @example
   * #id#%16\\t
   */
  routeExpr?: string;
  /**
   * @remarks
   * The unique key of the routing algorithm.
   * 
   * @example
   * 1
   */
  routeKey?: string;
  /**
   * @remarks
   * The ID of the logical table.
   * 
   * @example
   * 4****
   */
  tableId?: number;
  static names(): { [key: string]: string } {
    return {
      routeExpr: 'RouteExpr',
      routeKey: 'RouteKey',
      tableId: 'TableId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      routeExpr: 'string',
      routeKey: 'string',
      tableId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList extends $tea.Model {
  logicTableRouteConfig?: ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig[];
  static names(): { [key: string]: string } {
    return {
      logicTableRouteConfig: 'LogicTableRouteConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logicTableRouteConfig: { 'type': 'array', 'itemType': ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList extends $tea.Model {
  ownerIds?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerIds: 'OwnerIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList extends $tea.Model {
  ownerNames?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerNames: 'OwnerNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicTablesResponseBodyLogicTableListLogicTable extends $tea.Model {
  /**
   * @remarks
   * The ID of the logical database.
   * 
   * @example
   * 1
   */
  databaseId?: string;
  /**
   * @remarks
   * Indicates whether the table is a logical table. The value is fixed to true.
   * 
   * @example
   * true
   */
  logic?: boolean;
  /**
   * @remarks
   * The IDs of the owners of the logical tables.
   */
  ownerIdList?: ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList;
  /**
   * @remarks
   * The nicknames of the owners of the logical tables.
   */
  ownerNameList?: ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList;
  /**
   * @remarks
   * The logical database to which the logical table belongs.
   * 
   * @example
   * yuyang_test
   */
  schemaName?: string;
  /**
   * @remarks
   * The number of logical tables.
   * 
   * @example
   * 4
   */
  tableCount?: string;
  /**
   * @remarks
   * The expression of the logical table.
   * 
   * @example
   * test[1-4]
   */
  tableExpr?: string;
  /**
   * @remarks
   * The GUID of the logical table.
   * 
   * @example
   * IDB_L_308302.yuyang_test.test_ch
   */
  tableGuid?: string;
  /**
   * @remarks
   * The ID of the logical table.
   * 
   * @example
   * 1
   */
  tableId?: string;
  /**
   * @remarks
   * The name of the logical table.
   * 
   * @example
   * test
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      databaseId: 'DatabaseId',
      logic: 'Logic',
      ownerIdList: 'OwnerIdList',
      ownerNameList: 'OwnerNameList',
      schemaName: 'SchemaName',
      tableCount: 'TableCount',
      tableExpr: 'TableExpr',
      tableGuid: 'TableGuid',
      tableId: 'TableId',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseId: 'string',
      logic: 'boolean',
      ownerIdList: ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList,
      ownerNameList: ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList,
      schemaName: 'string',
      tableCount: 'string',
      tableExpr: 'string',
      tableGuid: 'string',
      tableId: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLogicTablesResponseBodyLogicTableList extends $tea.Model {
  logicTable?: ListLogicTablesResponseBodyLogicTableListLogicTable[];
  static names(): { [key: string]: string } {
    return {
      logicTable: 'LogicTable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logicTable: { 'type': 'array', 'itemType': ListLogicTablesResponseBodyLogicTableListLogicTable },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrdersResponseBodyOrdersOrder extends $tea.Model {
  /**
   * @remarks
   * The remarks of the ticket.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * The user who submitted the ticket.
   * 
   * @example
   * test
   */
  committer?: string;
  /**
   * @remarks
   * The ID of the user who submitted the ticket.
   * 
   * @example
   * 51****
   */
  committerId?: number;
  /**
   * @remarks
   * The time when the ticket was created.
   * 
   * @example
   * 2022-04-08 11:15:46
   */
  createTime?: string;
  /**
   * @remarks
   * The time when the ticket was last modified.
   * 
   * @example
   * 2022-04-08 11:27:45
   */
  lastModifyTime?: string;
  /**
   * @remarks
   * The ID of the ticket.
   * 
   * @example
   * 51****
   */
  orderId?: number;
  /**
   * @remarks
   * The type of the ticket.
   * 
   * @example
   * DC_COMMON
   */
  pluginType?: string;
  /**
   * @remarks
   * The status code of the ticket. Valid values:
   * 
   * *   **fail**: The ticket fails to be executed.
   * *   **toaudit**: The ticket is waiting for approval.
   * *   **cancel**: The ticket is cancelled.
   * *   **processing**: The ticket is being executed.
   * *   **approved**: The ticket is approved.
   * *   **reject**: The ticket is rejected.
   * *   **success**: The ticket is executed.
   * *   **closed**: The ticket is closed.
   * 
   * @example
   * success
   */
  statusCode?: string;
  /**
   * @remarks
   * The status description of the ticket.
   * 
   * @example
   * changed successfully
   */
  statusDesc?: string;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      committer: 'Committer',
      committerId: 'CommitterId',
      createTime: 'CreateTime',
      lastModifyTime: 'LastModifyTime',
      orderId: 'OrderId',
      pluginType: 'PluginType',
      statusCode: 'StatusCode',
      statusDesc: 'StatusDesc',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      committer: 'string',
      committerId: 'number',
      createTime: 'string',
      lastModifyTime: 'string',
      orderId: 'number',
      pluginType: 'string',
      statusCode: 'string',
      statusDesc: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOrdersResponseBodyOrders extends $tea.Model {
  order?: ListOrdersResponseBodyOrdersOrder[];
  static names(): { [key: string]: string } {
    return {
      order: 'Order',
    };
  }

  static types(): { [key: string]: any } {
    return {
      order: { 'type': 'array', 'itemType': ListOrdersResponseBodyOrdersOrder },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProxiesResponseBodyProxyList extends $tea.Model {
  /**
   * @remarks
   * The ID of the user who enabled the secure access proxy feature.
   * 
   * @example
   * 12****
   */
  creatorId?: number;
  /**
   * @remarks
   * The nickname of the user who enabled the secure access proxy feature.
   * 
   * @example
   * test_name
   */
  creatorName?: string;
  /**
   * @remarks
   * The number of the port that was used by HTTPS clients to connect to the database instance.
   * 
   * @example
   * 443
   */
  httpsPort?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * 183****
   */
  instanceId?: number;
  /**
   * @remarks
   * Indicates whether the internal endpoint is enabled. Default value: **true**.
   * 
   * @example
   * true
   */
  privateEnable?: boolean;
  /**
   * @remarks
   * The internal endpoint.
   * 
   * @example
   * dphzmy-5j8oimjsz6ze****.proxy.dms.aliyuncs.com
   */
  privateHost?: string;
  /**
   * @remarks
   * The number of the port that is used to connect the database instance.
   * 
   * @example
   * 3306
   */
  protocolPort?: number;
  /**
   * @remarks
   * The type of the database. Example: MYSQL.
   * 
   * @example
   * MYSQL
   */
  protocolType?: string;
  /**
   * @remarks
   * The ID of the secure access proxy.
   * 
   * @example
   * 4**
   */
  proxyId?: number;
  /**
   * @remarks
   * Indicates whether the public endpoint is enabled. Valid values:
   * 
   * *   **true**: The public endpoint is enabled.
   * *   **false**: The public endpoint is disabled.
   * 
   * @example
   * false
   */
  publicEnable?: boolean;
  /**
   * @remarks
   * The public endpoint. A public endpoint is returned no matter whether the public endpoint is enabled or disabled.
   * 
   * > 
   * 
   * *   If the value of the PublicEnable parameter is **true**, a valid public endpoint that can be resolved by using Alibaba Cloud DNS (DNS) is returned.
   * 
   * *   If the value of the PublicEnable parameter is **false**, an invalid public endpoint that cannot be resolved by using DNS is returned.
   * 
   * @example
   * dphzmy-5j8oimjsz6ze****-pub.proxy.dms.aliyuncs.com
   */
  publicHost?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      creatorId: 'CreatorId',
      creatorName: 'CreatorName',
      httpsPort: 'HttpsPort',
      instanceId: 'InstanceId',
      privateEnable: 'PrivateEnable',
      privateHost: 'PrivateHost',
      protocolPort: 'ProtocolPort',
      protocolType: 'ProtocolType',
      proxyId: 'ProxyId',
      publicEnable: 'PublicEnable',
      publicHost: 'PublicHost',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorId: 'number',
      creatorName: 'string',
      httpsPort: 'number',
      instanceId: 'number',
      privateEnable: 'boolean',
      privateHost: 'string',
      protocolPort: 'number',
      protocolType: 'string',
      proxyId: 'number',
      publicEnable: 'boolean',
      publicHost: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProxyAccessesResponseBodyProxyAccessList extends $tea.Model {
  /**
   * @remarks
   * The username of the database account that is authorized to access the database instance by using the secure access proxy feature.
   * 
   * @example
   * MXPL8HalI22m****
   */
  accessId?: string;
  /**
   * @remarks
   * The time when the user is authorized to access the database instance by using the secure access proxy feature.
   * 
   * @example
   * 2021-03-31 10:34:18
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The username of the independent database account.
   * 
   * @example
   * ****
   */
  indepAccount?: string;
  /**
   * @remarks
   * The ID of the database instance.
   * 
   * @example
   * 164****
   */
  instanceId?: number;
  /**
   * @remarks
   * The method that is used to authorize the user to access the database instance by using the secure access proxy feature. Valid values: 
   * 
   * - **Authorization by the Alibaba Cloud Account ()**: The information in the parentheses () indicates the user ID (UID) of the Alibaba Cloud account.
   * - **Authorization by submitting the ticket ()**:The information in the parentheses () indicates the number of the ticket that the user submits to apply for permissions.
   * 
   * @example
   * Authorization by the Alibaba Cloud Account(29490401597700****)
   */
  originInfo?: string;
  /**
   * @remarks
   * The ID that DMS generates after the user is authorized to access the database instance by using the secure access proxy feature. The ID is unique in DMS.
   * 
   * @example
   * ****
   */
  proxyAccessId?: number;
  /**
   * @remarks
   * The ID of the secure access proxy.
   * 
   * @example
   * 47
   */
  proxyId?: number;
  /**
   * @remarks
   * The ID of the user.
   * 
   * @example
   * 26****
   */
  userId?: number;
  /**
   * @remarks
   * The nickname of the user.
   * 
   * @example
   * user
   */
  userName?: string;
  /**
   * @remarks
   * The UID of the Alibaba Cloud account.
   * 
   * @example
   * 25936669186260****
   */
  userUid?: string;
  static names(): { [key: string]: string } {
    return {
      accessId: 'AccessId',
      gmtCreate: 'GmtCreate',
      indepAccount: 'IndepAccount',
      instanceId: 'InstanceId',
      originInfo: 'OriginInfo',
      proxyAccessId: 'ProxyAccessId',
      proxyId: 'ProxyId',
      userId: 'UserId',
      userName: 'UserName',
      userUid: 'UserUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessId: 'string',
      gmtCreate: 'string',
      indepAccount: 'string',
      instanceId: 'number',
      originInfo: 'string',
      proxyAccessId: 'number',
      proxyId: 'number',
      userId: 'number',
      userName: 'string',
      userUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog extends $tea.Model {
  /**
   * @remarks
   * Indicates the total number of rows returned after the SQL statement was executed. If an SELECT SQL statement is executed, the return value of this parameter indicates the total number of the queried data rows.
   * 
   * @example
   * 1
   */
  affectRows?: number;
  /**
   * @remarks
   * The amount of time that is consumed to execute the SQL statement. Unit: milliseconds.
   * 
   * @example
   * 1324
   */
  elapsedTime?: number;
  /**
   * @remarks
   * The execution status of the SQL statement. Valid values:
   * 
   * *   **FAIL**: The execution of the SQL statement fails.
   * *   **CANCEL**: The execution of the SQL statement is canceled.
   * *   **SUCCESS**: The SQL statement is executed.
   * 
   * @example
   * SUCCESS
   */
  execState?: string;
  /**
   * @remarks
   * The ID of the database instance.
   * 
   * @example
   * 4***
   */
  instanceId?: number;
  /**
   * @remarks
   * The name of the database instance.
   * 
   * @example
   * pc-uf662nrg017c6****.mysql.polardb.rds.aliyuncs.com:3306test
   */
  instanceName?: string;
  /**
   * @remarks
   * The time at which the user executes the SQL statement on the database instance. The value of this parameter must be a timestamp that follows the UNIX time format.
   * 
   * @example
   * 1636876446000
   */
  opTime?: string;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * success
   */
  remark?: string;
  /**
   * @remarks
   * The SQL statement that was executed.
   * 
   * @example
   * select 1;
   */
  SQL?: string;
  /**
   * @remarks
   * The type of the SQL statement. Valid values:
   * 
   * *   **SELECT**
   * *   **INSERT**
   * *   **DELETE**
   * *   **CREATE_TABLE**
   * 
   * >  You can choose Operation Audit > Secure Access Proxy in the top navigation bar of the DMS console to view more types of SQL statements.
   * 
   * @example
   * SELECT
   */
  SQLType?: string;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * test_db
   */
  schemaName?: string;
  /**
   * @remarks
   * The ID of the user.
   * 
   * @example
   * 4****
   */
  userId?: number;
  /**
   * @remarks
   * The nickname of the user.
   * 
   * @example
   * testNickName
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      affectRows: 'AffectRows',
      elapsedTime: 'ElapsedTime',
      execState: 'ExecState',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      opTime: 'OpTime',
      remark: 'Remark',
      SQL: 'SQL',
      SQLType: 'SQLType',
      schemaName: 'SchemaName',
      userId: 'UserId',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affectRows: 'number',
      elapsedTime: 'number',
      execState: 'string',
      instanceId: 'number',
      instanceName: 'string',
      opTime: 'string',
      remark: 'string',
      SQL: 'string',
      SQLType: 'string',
      schemaName: 'string',
      userId: 'number',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList extends $tea.Model {
  proxySQLExecAuditLog?: ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog[];
  static names(): { [key: string]: string } {
    return {
      proxySQLExecAuditLog: 'ProxySQLExecAuditLog',
    };
  }

  static types(): { [key: string]: any } {
    return {
      proxySQLExecAuditLog: { 'type': 'array', 'itemType': ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSLARulesResponseBodySLARuleListSLARule extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow.
   * 
   * @example
   * 11****
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the SLA rule.
   * 
   * @example
   * 2
   */
  id?: number;
  /**
   * @remarks
   * The timeout period. Unit: minutes.
   * 
   * @example
   * 1080
   */
  intervalMinutes?: number;
  /**
   * @remarks
   * The ID of the task node.
   * 
   * @example
   * 1
   */
  nodeId?: number;
  /**
   * @remarks
   * The type of the rule. Valid values:
   * 
   * *   **0**: an SLA rule for a task flow
   * *   **1**: an SLA rule for a task node
   * 
   * @example
   * 0
   */
  ruleType?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      id: 'Id',
      intervalMinutes: 'IntervalMinutes',
      nodeId: 'NodeId',
      ruleType: 'RuleType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      id: 'number',
      intervalMinutes: 'number',
      nodeId: 'number',
      ruleType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSLARulesResponseBodySLARuleList extends $tea.Model {
  SLARule?: ListSLARulesResponseBodySLARuleListSLARule[];
  static names(): { [key: string]: string } {
    return {
      SLARule: 'SLARule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      SLARule: { 'type': 'array', 'itemType': ListSLARulesResponseBodySLARuleListSLARule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog extends $tea.Model {
  /**
   * @remarks
   * The number of rows affected by the SQL statement. For example, if you execute an SQL statement to query data, the number of retrieved rows is returned.
   * 
   * @example
   * 2
   */
  affectRows?: number;
  /**
   * @remarks
   * The ID of the database.
   * 
   * @example
   * 2157****
   */
  dbId?: number;
  /**
   * @remarks
   * The amount of time consumed by the execution of the SQL statement. Unit: milliseconds.
   * 
   * @example
   * 18
   */
  elapsedTime?: number;
  /**
   * @remarks
   * The execution status of the SQL statement. Valid values:
   * 
   * *   **FAIL**: The SQL statement fails to be executed.
   * *   **NOEXE**: The SQL statement has not been executed.
   * *   **RUNNING**: The SQL statement is being executed.
   * *   **CANCEL**: The execution of the SQL statement is canceled.
   * *   **SUCCESS**: The SQL statement is executed.
   * 
   * @example
   * SUCCESS
   */
  execState?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * 185***
   */
  instanceId?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * >  If the SQL statement takes effect on an instance, the name of the instance is returned.
   * 
   * @example
   * polar123@pc-bp1h9tgq4st9g****.mysql.polardb.rds.aliyuncs.com:3306[polar_qw_test]
   */
  instanceName?: string;
  /**
   * @remarks
   * Indicates whether the database is a logical database. Valid values:
   * 
   * *   **true**: The database is a logical database.
   * *   **false**: The database is a physical database.
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The time when the operation specified by the SQL statement was performed on the instance or database.
   * 
   * @example
   * 2021-11-08 11:04:27
   */
  opTime?: string;
  /**
   * @remarks
   * The comment on the SQL statement.
   * 
   * @example
   * success
   */
  remark?: string;
  /**
   * @remarks
   * The SQL statement that was written.
   * 
   * @example
   * SELECT * FROM `polar123`.`p_qw` ORDER BY `id` DESC
   */
  SQL?: string;
  /**
   * @remarks
   * The type of the SQL statement. Valid values:
   * 
   * *   **SELECT**: the SQL statement that is used to query data.
   * *   **INSERT**: the SQL statement that is used to insert data.
   * *   **DELETE**: the SQL statement that is used to delete data.
   * *   **CREATE_TABLE**: the SQL statement that is used to create tables.
   * 
   * >  To view more types of SQL statements, log on to the DMS console and click Security and Specifications. In the left-side navigation pane, click **Operation Audit**. Then, you can view all supported types of SQL statements from the **SQL type** drop-down list.
   * 
   * @example
   * SELECT
   */
  SQLType?: string;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * polar123
   */
  schemaName?: string;
  /**
   * @remarks
   * The ID of the user who wrote the SQL statement.
   * 
   * @example
   * 12****
   */
  userId?: number;
  /**
   * @remarks
   * The nickname of the user who wrote the SQL statement.
   * 
   * @example
   * test_UserName
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      affectRows: 'AffectRows',
      dbId: 'DbId',
      elapsedTime: 'ElapsedTime',
      execState: 'ExecState',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      logic: 'Logic',
      opTime: 'OpTime',
      remark: 'Remark',
      SQL: 'SQL',
      SQLType: 'SQLType',
      schemaName: 'SchemaName',
      userId: 'UserId',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affectRows: 'number',
      dbId: 'number',
      elapsedTime: 'number',
      execState: 'string',
      instanceId: 'number',
      instanceName: 'string',
      logic: 'boolean',
      opTime: 'string',
      remark: 'string',
      SQL: 'string',
      SQLType: 'string',
      schemaName: 'string',
      userId: 'number',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSQLExecAuditLogResponseBodySQLExecAuditLogList extends $tea.Model {
  SQLExecAuditLog?: ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog[];
  static names(): { [key: string]: string } {
    return {
      SQLExecAuditLog: 'SQLExecAuditLog',
    };
  }

  static types(): { [key: string]: any } {
    return {
      SQLExecAuditLog: { 'type': 'array', 'itemType': ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSQLReviewOriginSQLRequestOrderActionDetailPage extends $tea.Model {
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSQLReviewOriginSQLRequestOrderActionDetail extends $tea.Model {
  /**
   * @remarks
   * The review status of the SQL statement. Valid values:
   * 
   * *   **new**: The SQL statement is pending for analysis.
   * *   **unknown**: The SQL statement failed to be parsed.
   * *   **check_not_pass**: The SQL statement failed the review.
   * *   **check_pass**: The SQL statement passed the review.
   * *   **force_pass**: The SQL statement passed the review by manual effort.
   * *   **force_not_pass**: The SQL statement failed the review by manual effort.
   * 
   * @example
   * check_not_pass
   */
  checkStatusResult?: string;
  /**
   * @remarks
   * The ID of the file.
   * 
   * @example
   * 123345
   */
  fileId?: number;
  /**
   * @remarks
   * The paging settings.
   */
  page?: ListSQLReviewOriginSQLRequestOrderActionDetailPage;
  /**
   * @remarks
   * The optimization suggestion for the SQL statement. Valid values:
   * 
   * *   **MUST_IMPROVE**: The SQL statement must be improved.
   * *   **POTENTIAL_ISSUE**: The SQL statement contains potential issues.
   * *   **SUGGEST_IMPROVE**: We recommend that you improve the SQL statement.
   * *   **USE_DMS_TOOLKIT**: We recommend that you change schemas without locking tables.
   * *   **USE_DMS_DML_UNLOCK**: We recommend that you change data without locking tables.
   * *   **TABLE_INDEX_SUGGEST**: We recommend that you use SQL statements that use indexes.
   * 
   * @example
   * MUST_IMPROVE
   */
  SQLReviewResult?: string;
  static names(): { [key: string]: string } {
    return {
      checkStatusResult: 'CheckStatusResult',
      fileId: 'FileId',
      page: 'Page',
      SQLReviewResult: 'SQLReviewResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkStatusResult: 'string',
      fileId: 'number',
      page: ListSQLReviewOriginSQLRequestOrderActionDetailPage,
      SQLReviewResult: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSQLReviewOriginSQLResponseBodyOriginSQLList extends $tea.Model {
  /**
   * @remarks
   * The review status of the SQL statement. Valid values:
   * 
   * *   **new**: The SQL statement is pending for analysis.
   * *   **unknown**: The SQL statement failed to be parsed.
   * *   **check_not_pass**: The SQL statement failed the review.
   * *   **check_pass**: The SQL statement passed the review.
   * *   **force_pass**: The SQL statement passed the review by manual effort.
   * *   **force_not_pass**: The SQL statement failed the review by manual effort.
   * 
   * @example
   * check_pass
   */
  checkStatus?: string;
  /**
   * @remarks
   * The time when the SQL statement is reviewed.
   * 
   * @example
   * 2021-06-09 21:07:00
   */
  checkedTime?: string;
  /**
   * @remarks
   * The ID of the file.
   * 
   * @example
   * 123321
   */
  fileId?: number;
  /**
   * @remarks
   * The name of the file.
   * 
   * @example
   * test.sql
   */
  fileName?: string;
  /**
   * @remarks
   * The statistics of optimization suggestions for SQL statements. The value is a JSON string. The following optimization suggestions are involved:
   * 
   * *   **MUST_IMPROVE**: The SQL statement must be improved.
   * *   **POTENTIAL_ISSUE**: The SQL statement contains potential issues.
   * *   **SUGGEST_IMPROVE**: We recommend that you improve the SQL statement.
   * *   **USEDMSTOOLKIT**: We recommend that you change schemas without locking tables.
   * *   **USEDMSDML_UNLOCK**: We recommend that you change data without locking tables.
   * *   **TABLEINDEXSUGGEST**: We recommend that you use SQL statements that use indexes.
   * 
   * @example
   * {"POTENTIAL_ISSUE":1,"SUGGEST_IMPROVE":1}
   */
  reviewSummary?: string;
  /**
   * @remarks
   * The SQL statement.
   * 
   * @example
   * select id from table_name
   */
  SQLContent?: string;
  /**
   * @remarks
   * The ID of the SQL statement.
   * 
   * @example
   * 1111
   */
  SQLId?: number;
  /**
   * @remarks
   * SQLName.
   * 
   * @example
   * getByPk
   */
  SQLName?: string;
  /**
   * @remarks
   * The key that is used to query the details of optimization suggestions. You can call the [GetSQLReviewOptimizeDetail](https://icms.alibaba-inc.com/content/dms/doc?l=1\\&m=61777\\&n=2712723\\&spm) operation to query the details of optimization suggestions based on the key.
   * 
   * @example
   * a57e54ec5433475ea3082d882fdb89c5
   */
  SQLReviewQueryKey?: string;
  /**
   * @remarks
   * The MD5 hash value of the SQL statement.
   * 
   * @example
   * 95adb6e77a0884d9e50232cb8c5c969d
   */
  sqlHash?: string;
  /**
   * @remarks
   * The description of the review status.
   * 
   * @example
   * passed the test
   */
  statusDesc?: string;
  static names(): { [key: string]: string } {
    return {
      checkStatus: 'CheckStatus',
      checkedTime: 'CheckedTime',
      fileId: 'FileId',
      fileName: 'FileName',
      reviewSummary: 'ReviewSummary',
      SQLContent: 'SQLContent',
      SQLId: 'SQLId',
      SQLName: 'SQLName',
      SQLReviewQueryKey: 'SQLReviewQueryKey',
      sqlHash: 'SqlHash',
      statusDesc: 'StatusDesc',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkStatus: 'string',
      checkedTime: 'string',
      fileId: 'number',
      fileName: 'string',
      reviewSummary: 'string',
      SQLContent: 'string',
      SQLId: 'number',
      SQLName: 'string',
      SQLReviewQueryKey: 'string',
      sqlHash: 'string',
      statusDesc: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScenariosResponseBodyScenarioList extends $tea.Model {
  /**
   * @remarks
   * The ID of the user who created the business scenario.
   * 
   * @example
   * 23***
   */
  creatorId?: string;
  /**
   * @remarks
   * The description of the business scenario.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The ID of the business scenario.
   * 
   * @example
   * 41***
   */
  id?: number;
  /**
   * @remarks
   * The name of the business scenario.
   * 
   * @example
   * test
   */
  scenarioName?: string;
  static names(): { [key: string]: string } {
    return {
      creatorId: 'CreatorId',
      description: 'Description',
      id: 'Id',
      scenarioName: 'ScenarioName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorId: 'string',
      description: 'string',
      id: 'number',
      scenarioName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnDefaultDesensitizationRule extends $tea.Model {
  /**
   * @example
   * 101**
   */
  ruleId?: number;
  /**
   * @example
   * test
   */
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      ruleId: 'RuleId',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleId: 'number',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleListSemiDesensitizationRule extends $tea.Model {
  /**
   * @example
   * 10***
   */
  ruleId?: number;
  /**
   * @example
   * test01
   */
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      ruleId: 'RuleId',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleId: 'number',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleList extends $tea.Model {
  semiDesensitizationRule?: ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleListSemiDesensitizationRule[];
  static names(): { [key: string]: string } {
    return {
      semiDesensitizationRule: 'SemiDesensitizationRule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      semiDesensitizationRule: { 'type': 'array', 'itemType': ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleListSemiDesensitizationRule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumn extends $tea.Model {
  categoryName?: string;
  /**
   * @example
   * test_column
   */
  columnName?: string;
  defaultDesensitizationRule?: ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnDefaultDesensitizationRule;
  /**
   * @example
   * 183****
   */
  instanceId?: number;
  /**
   * @example
   * False
   */
  isPlain?: boolean;
  sampleData?: string;
  /**
   * @example
   * test_schema
   */
  schemaName?: string;
  securityLevel?: string;
  semiDesensitizationRuleList?: ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleList;
  /**
   * @example
   * test_table
   */
  tableName?: string;
  /**
   * @example
   * S1
   */
  userSensitivityLevel?: string;
  static names(): { [key: string]: string } {
    return {
      categoryName: 'CategoryName',
      columnName: 'ColumnName',
      defaultDesensitizationRule: 'DefaultDesensitizationRule',
      instanceId: 'InstanceId',
      isPlain: 'IsPlain',
      sampleData: 'SampleData',
      schemaName: 'SchemaName',
      securityLevel: 'SecurityLevel',
      semiDesensitizationRuleList: 'SemiDesensitizationRuleList',
      tableName: 'TableName',
      userSensitivityLevel: 'UserSensitivityLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryName: 'string',
      columnName: 'string',
      defaultDesensitizationRule: ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnDefaultDesensitizationRule,
      instanceId: 'number',
      isPlain: 'boolean',
      sampleData: 'string',
      schemaName: 'string',
      securityLevel: 'string',
      semiDesensitizationRuleList: ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumnSemiDesensitizationRuleList,
      tableName: 'string',
      userSensitivityLevel: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnInfoResponseBodySensitiveColumnList extends $tea.Model {
  sensitiveColumn?: ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumn[];
  static names(): { [key: string]: string } {
    return {
      sensitiveColumn: 'SensitiveColumn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sensitiveColumn: { 'type': 'array', 'itemType': ListSensitiveColumnInfoResponseBodySensitiveColumnListSensitiveColumn },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn extends $tea.Model {
  /**
   * @remarks
   * The number of sensitive fields.
   * 
   * @example
   * 1
   */
  columnCount?: number;
  /**
   * @remarks
   * The name of the field.
   * 
   * @example
   * test_column
   */
  columnName?: string;
  /**
   * @remarks
   * The type of the de-identification algorithm. Valid values:
   * 
   * *   DEFAULT: All characters are masked. This is the default value.
   * *   FIX_POS: The characters at specific positions are masked.
   * *   FIX_CHAR: Specific characters are masked.
   * 
   * @example
   * DEFAULT
   */
  functionType?: string;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * test_schema
   */
  schemaName?: string;
  /**
   * @remarks
   * The sensitivity level of the field. Valid values:
   * 
   * *   SENSITIVE
   * *   CONFIDENTIAL
   * 
   * @example
   * SENSITIVE
   */
  securityLevel?: string;
  /**
   * @remarks
   * The name of the table.
   * 
   * @example
   * test_table
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      columnCount: 'ColumnCount',
      columnName: 'ColumnName',
      functionType: 'FunctionType',
      schemaName: 'SchemaName',
      securityLevel: 'SecurityLevel',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnCount: 'number',
      columnName: 'string',
      functionType: 'string',
      schemaName: 'string',
      securityLevel: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnsResponseBodySensitiveColumnList extends $tea.Model {
  sensitiveColumn?: ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn[];
  static names(): { [key: string]: string } {
    return {
      sensitiveColumn: 'SensitiveColumn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sensitiveColumn: { 'type': 'array', 'itemType': ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail extends $tea.Model {
  /**
   * @remarks
   * The description of the field.
   * 
   * @example
   * test
   */
  columnDescription?: string;
  /**
   * @remarks
   * The name of the field.
   * 
   * @example
   * ColumnName_test
   */
  columnName?: string;
  /**
   * @remarks
   * The data type of the field.
   * 
   * @example
   * varchar(32)
   */
  columnType?: string;
  /**
   * @remarks
   * The ID of the database.
   * 
   * @example
   * 1860****
   */
  dbId?: number;
  /**
   * @remarks
   * The type of the database.
   * 
   * @example
   * mysql
   */
  dbType?: string;
  /**
   * @remarks
   * The type of the environment to which the database belongs.
   * 
   * @example
   * product
   */
  envType?: string;
  /**
   * @remarks
   * Indicates whether the database is a logical database. Valid values:
   * 
   * *   **true**: The database is a logical database.
   * *   **false**: The database is not a logical database.
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * SchemaName_test
   */
  schemaName?: string;
  /**
   * @remarks
   * The name that is used to search for the database.
   * 
   * @example
   * test@xxx:3306
   */
  searchName?: string;
  /**
   * @remarks
   * The name of the table.
   * 
   * @example
   * test
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      columnDescription: 'ColumnDescription',
      columnName: 'ColumnName',
      columnType: 'ColumnType',
      dbId: 'DbId',
      dbType: 'DbType',
      envType: 'EnvType',
      logic: 'Logic',
      schemaName: 'SchemaName',
      searchName: 'SearchName',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnDescription: 'string',
      columnName: 'string',
      columnType: 'string',
      dbId: 'number',
      dbType: 'string',
      envType: 'string',
      logic: 'boolean',
      schemaName: 'string',
      searchName: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList extends $tea.Model {
  sensitiveColumnsDetail?: ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail[];
  static names(): { [key: string]: string } {
    return {
      sensitiveColumnsDetail: 'SensitiveColumnsDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sensitiveColumnsDetail: { 'type': 'array', 'itemType': ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog extends $tea.Model {
  /**
   * @remarks
   * The name of the column that contains sensitive data.
   * 
   * @example
   * ExampleColumnName
   */
  columnName?: string;
  /**
   * @remarks
   * The permission that the user has on the column. Valid values:
   * 
   * *   **No permission**
   * *   **Partial redaction**
   * *   **Plaintext**
   * *   **Change**
   * *   **Enable data masking**
   * *   **Disable data masking**
   * 
   * @example
   * Change
   */
  columnPermissionType?: string;
  /**
   * @remarks
   * The algorithm used for data masking.
   * 
   * @example
   * Default - Full redaction
   */
  desensitizationRule?: string;
  /**
   * @remarks
   * The sensitivity level of the data. Valid values:
   * 
   * *   **Low**
   * *   **Medium**
   * *   **High**
   * 
   * @example
   * Low
   */
  securityLevel?: string;
  /**
   * @remarks
   * The name of the table that stores the sensitive data.
   * 
   * @example
   * ExampleTableName
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      columnPermissionType: 'ColumnPermissionType',
      desensitizationRule: 'DesensitizationRule',
      securityLevel: 'SecurityLevel',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      columnPermissionType: 'string',
      desensitizationRule: 'string',
      securityLevel: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList extends $tea.Model {
  /**
   * @remarks
   * The name of the database that stores the sensitive data.
   * 
   * @example
   * ExampleDbName@xxx.xxx.xxx.xxx:3306
   */
  dbDisplayName?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * 12****
   */
  instanceId?: number;
  /**
   * @remarks
   * The name of the function module whose audit logs were queried.
   * 
   * @example
   * SQL_CONSOLE
   */
  moduleName?: string;
  /**
   * @remarks
   * The time when the operation was performed. The time is in the yyyy-MM-DD HH:mm:ss format.
   * 
   * @example
   * 2022-11-18 10:01:00
   */
  opTime?: string;
  /**
   * @remarks
   * The logs for sensitive data.
   */
  sensitiveDataLog?: ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog[];
  /**
   * @remarks
   * The details of the object on which the operation was performed. The value of this parameter is in one of the following formats:
   * 
   * *   Object name - object ID
   * *   Object name (object ID)
   * 
   * @example
   * Ticket - 1\\*\\*\\*\\*
   */
  targetName?: string;
  /**
   * @remarks
   * The user ID of the requester.
   * 
   * @example
   * 1**
   */
  userId?: number;
  /**
   * @remarks
   * The username of the requester.
   * 
   * @example
   * ExampleUserName
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      dbDisplayName: 'DbDisplayName',
      instanceId: 'InstanceId',
      moduleName: 'ModuleName',
      opTime: 'OpTime',
      sensitiveDataLog: 'SensitiveDataLog',
      targetName: 'TargetName',
      userId: 'UserId',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbDisplayName: 'string',
      instanceId: 'number',
      moduleName: 'string',
      opTime: 'string',
      sensitiveDataLog: { 'type': 'array', 'itemType': ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog },
      targetName: 'string',
      userId: 'number',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSensitivityLevelResponseBodySensitivityLevelList extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the fields of the sensitive level are displayed in plaintext.
   * 
   * @example
   * true
   */
  isPlain?: boolean;
  /**
   * @remarks
   * The name of the sensitive level.
   * 
   * @example
   * S2
   */
  name?: string;
  /**
   * @remarks
   * The ID of the classification template.
   * 
   * @example
   * 1070
   */
  templateId?: string;
  /**
   * @remarks
   * The type of the classification template. Valid values:
   * 
   * *   **INNER**: a built-in template.
   * *   **USER_DEFINE**: a custom template.
   * 
   * @example
   * INNER
   */
  templateType?: string;
  static names(): { [key: string]: string } {
    return {
      isPlain: 'IsPlain',
      name: 'Name',
      templateId: 'TemplateId',
      templateType: 'TemplateType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isPlain: 'boolean',
      name: 'string',
      templateId: 'string',
      templateType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListStandardGroupsResponseBodyStandardGroupList extends $tea.Model {
  /**
   * @remarks
   * The type of the database engine. For more information about the valid values of this parameter, see [DbType parameter](https://help.aliyun.com/document_detail/198106.html).
   * 
   * @example
   * mysql
   */
  dbType?: string;
  /**
   * @remarks
   * The description of the security rule set.
   * 
   * @example
   * test_rule
   */
  description?: string;
  /**
   * @remarks
   * The ID of the security rule set.
   * 
   * @example
   * 41****
   */
  groupId?: number;
  /**
   * @remarks
   * The control mode. Valid values:
   * 
   * *   **NONE_CONTROL**: Flexible Management
   * *   **STABLE**: Stable Change
   * *   **COMMON**: Security Collaboration
   * 
   * @example
   * COMMON
   */
  groupMode?: string;
  /**
   * @remarks
   * The name of the security rule set.
   * 
   * @example
   * test_group
   */
  groupName?: string;
  /**
   * @remarks
   * The ID of the user who queries the security sets.
   * 
   * @example
   * 51****
   */
  lastMenderId?: number;
  static names(): { [key: string]: string } {
    return {
      dbType: 'DbType',
      description: 'Description',
      groupId: 'GroupId',
      groupMode: 'GroupMode',
      groupName: 'GroupName',
      lastMenderId: 'LastMenderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbType: 'string',
      description: 'string',
      groupId: 'number',
      groupMode: 'string',
      groupName: 'string',
      lastMenderId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTablesResponseBodyTableListTableOwnerIdList extends $tea.Model {
  ownerIds?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerIds: 'OwnerIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTablesResponseBodyTableListTableOwnerNameList extends $tea.Model {
  ownerNames?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerNames: 'OwnerNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTablesResponseBodyTableListTable extends $tea.Model {
  /**
   * @remarks
   * The ID of the physical database.
   * 
   * @example
   * 1860****
   */
  databaseId?: string;
  /**
   * @remarks
   * The description of the table.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The encoding format of the table.
   * 
   * @example
   * utf8
   */
  encoding?: string;
  /**
   * @remarks
   * The engine of the table.
   * 
   * @example
   * InnoDB
   */
  engine?: string;
  /**
   * @remarks
   * The number of rows in the table. This is a statistical value and does not indicate the actual number of rows.
   * 
   * @example
   * 10085
   */
  numRows?: number;
  /**
   * @remarks
   * The ID list of the table owners.
   */
  ownerIdList?: ListTablesResponseBodyTableListTableOwnerIdList;
  /**
   * @remarks
   * The nickname list of the table owners.
   */
  ownerNameList?: ListTablesResponseBodyTableListTableOwnerNameList;
  /**
   * @remarks
   * The storage space that is occupied by the table. This is a statistical value and does not indicate the accurate storage space. Unit: MB.
   * 
   * @example
   * 1024
   */
  storeCapacity?: number;
  /**
   * @remarks
   * The GUID of the table in DMS.
   * 
   * @example
   * IDB_44743****.qntest.consumption_records
   */
  tableGuid?: string;
  /**
   * @remarks
   * The ID of the table.
   * 
   * @example
   * 44743****
   */
  tableId?: string;
  /**
   * @remarks
   * The table name.
   * 
   * @example
   * consumption_records
   */
  tableName?: string;
  /**
   * @remarks
   * The database in which the table resides.
   * 
   * @example
   * qntest
   */
  tableSchemaName?: string;
  /**
   * @remarks
   * The type of the table. Default value: NORMAL.
   * 
   * @example
   * NORMAL
   */
  tableType?: string;
  static names(): { [key: string]: string } {
    return {
      databaseId: 'DatabaseId',
      description: 'Description',
      encoding: 'Encoding',
      engine: 'Engine',
      numRows: 'NumRows',
      ownerIdList: 'OwnerIdList',
      ownerNameList: 'OwnerNameList',
      storeCapacity: 'StoreCapacity',
      tableGuid: 'TableGuid',
      tableId: 'TableId',
      tableName: 'TableName',
      tableSchemaName: 'TableSchemaName',
      tableType: 'TableType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseId: 'string',
      description: 'string',
      encoding: 'string',
      engine: 'string',
      numRows: 'number',
      ownerIdList: ListTablesResponseBodyTableListTableOwnerIdList,
      ownerNameList: ListTablesResponseBodyTableListTableOwnerNameList,
      storeCapacity: 'number',
      tableGuid: 'string',
      tableId: 'string',
      tableName: 'string',
      tableSchemaName: 'string',
      tableType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTablesResponseBodyTableList extends $tea.Model {
  table?: ListTablesResponseBodyTableListTable[];
  static names(): { [key: string]: string } {
    return {
      table: 'Table',
    };
  }

  static types(): { [key: string]: any } {
    return {
      table: { 'type': 'array', 'itemType': ListTablesResponseBodyTableListTable },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowResponseBodyTaskFlowListTaskFlow extends $tea.Model {
  /**
   * @remarks
   * The ID of the user who creates the task flow.
   * 
   * @example
   * 51****
   */
  creatorId?: string;
  /**
   * @remarks
   * The name of the user who creates the task flow.
   * 
   * @example
   * Creator_NickName
   */
  creatorNickName?: string;
  /**
   * @remarks
   * The name of the task flow owner.
   * 
   * @example
   * Owner_NickName
   */
  dagOwnerNickName?: string;
  /**
   * @remarks
   * The ID of the latest deployment record.
   * 
   * @example
   * 12**
   */
  deployId?: number;
  /**
   * @remarks
   * The ID of the task flow.
   * 
   * @example
   * 134137****
   */
  id?: number;
  /**
   * @remarks
   * The status of the latest execution. Valid values:
   * 
   * *   **0**: invalid.
   * *   **1**: scheduling disabled.
   * *   **2**: waiting to be scheduled.
   * 
   * @example
   * 0
   */
  latestInstanceStatus?: number;
  /**
   * @remarks
   * The time when the latest execution record was generated.
   * 
   * @example
   * 2022-04-13
   */
  latestInstanceTime?: string;
  /**
   * @remarks
   * The status of the task flow. Valid values:
   * 
   * *   **0**: The task flow is invalid.
   * *   **1**: Scheduling is disabled for the task flow.
   * *   **2**: The task flow is waiting to be scheduled.
   * 
   * @example
   * 2
   */
  status?: number;
  static names(): { [key: string]: string } {
    return {
      creatorId: 'CreatorId',
      creatorNickName: 'CreatorNickName',
      dagOwnerNickName: 'DagOwnerNickName',
      deployId: 'DeployId',
      id: 'Id',
      latestInstanceStatus: 'LatestInstanceStatus',
      latestInstanceTime: 'LatestInstanceTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorId: 'string',
      creatorNickName: 'string',
      dagOwnerNickName: 'string',
      deployId: 'number',
      id: 'number',
      latestInstanceStatus: 'number',
      latestInstanceTime: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowResponseBodyTaskFlowList extends $tea.Model {
  taskFlow?: ListTaskFlowResponseBodyTaskFlowListTaskFlow[];
  static names(): { [key: string]: string } {
    return {
      taskFlow: 'TaskFlow',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskFlow: { 'type': 'array', 'itemType': ListTaskFlowResponseBodyTaskFlowListTaskFlow },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowConstantsResponseBodyDagConstantsDagConstant extends $tea.Model {
  /**
   * @remarks
   * The constant key.
   * 
   * @example
   * example
   */
  key?: string;
  /**
   * @remarks
   * The constant value.
   * 
   * @example
   * 0
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowConstantsResponseBodyDagConstants extends $tea.Model {
  dagConstant?: ListTaskFlowConstantsResponseBodyDagConstantsDagConstant[];
  static names(): { [key: string]: string } {
    return {
      dagConstant: 'DagConstant',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagConstant: { 'type': 'array', 'itemType': ListTaskFlowConstantsResponseBodyDagConstantsDagConstant },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator extends $tea.Model {
  /**
   * @remarks
   * The email address of the user.
   * 
   * @example
   * test@XX.com
   */
  email?: string;
  /**
   * @remarks
   * The username.
   * 
   * @example
   * name
   */
  loginName?: string;
  /**
   * @remarks
   * The alias of the user.
   * 
   * @example
   * name
   */
  nickName?: string;
  /**
   * @remarks
   * userId.
   * 
   * @example
   * 123
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      email: 'Email',
      loginName: 'LoginName',
      nickName: 'NickName',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      email: 'string',
      loginName: 'string',
      nickName: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowCooperatorsResponseBodyCooperatorList extends $tea.Model {
  cooperator?: ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator[];
  static names(): { [key: string]: string } {
    return {
      cooperator: 'Cooperator',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cooperator: { 'type': 'array', 'itemType': ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowEdgesByConditionResponseBodyEdgesEdge extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow edge.
   * 
   * @example
   * 24***
   */
  id?: number;
  /**
   * @remarks
   * The ID of the end node on the edge.
   * 
   * @example
   * 44***
   */
  nodeEnd?: number;
  /**
   * @remarks
   * The ID of the start node on the edge.
   * 
   * @example
   * 44***
   */
  nodeFrom?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      nodeEnd: 'NodeEnd',
      nodeFrom: 'NodeFrom',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      nodeEnd: 'number',
      nodeFrom: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowEdgesByConditionResponseBodyEdges extends $tea.Model {
  edge?: ListTaskFlowEdgesByConditionResponseBodyEdgesEdge[];
  static names(): { [key: string]: string } {
    return {
      edge: 'Edge',
    };
  }

  static types(): { [key: string]: any } {
    return {
      edge: { 'type': 'array', 'itemType': ListTaskFlowEdgesByConditionResponseBodyEdgesEdge },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance extends $tea.Model {
  /**
   * @remarks
   * The business time of the task flow. The time is displayed in the yyyy-MM-DD HH:mm:ss format.
   * 
   * @example
   * 2021-11-10 14:37:26
   */
  businessTime?: string;
  /**
   * @remarks
   * The ID of the task flow.
   * 
   * @example
   * 7***
   */
  dagId?: string;
  /**
   * @remarks
   * The name of the task flow.
   * 
   * @example
   * Spark_SQL_test
   */
  dagName?: string;
  /**
   * @remarks
   * The version of the task flow.
   * 
   * @example
   * []
   */
  dagVersion?: string;
  /**
   * @remarks
   * The time when the execution of the task flow was complete. The time is displayed in the yyyy-MM-DD HH:mm:ss format.
   * 
   * @example
   * 2021-11-11 14:38:57
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the previously published version of the task flow.
   * 
   * @example
   * 2****
   */
  historyDagId?: number;
  /**
   * @remarks
   * The ID of the execution record.
   * 
   * @example
   * 9234
   */
  id?: number;
  /**
   * @remarks
   * The description of the task.
   * 
   * @example
   * test
   */
  message?: string;
  /**
   * @remarks
   * The name of the task flow owner.
   * 
   * @example
   * test_name
   */
  ownerName?: string;
  /**
   * @remarks
   * The status of the task flow. Valid values:
   * 
   * *   **0**: The task flow is waiting to be scheduled.
   * *   **1**: The task flow is being executed.
   * *   **2**: The task flow is paused.
   * *   **3**: The task flow failed.
   * *   **4**: The task flow is executed.
   * *   **5**: The task flow is complete.
   * 
   * @example
   * 4
   */
  status?: number;
  /**
   * @remarks
   * The mode in which the task flow is triggered. Valid values:
   * 
   * *   **0**: The task flow is automatically triggered based on periodic scheduling.
   * *   **1**: The task flow is manually triggered.
   * 
   * @example
   * 1
   */
  triggerType?: number;
  /**
   * @remarks
   * The time when the execution of the task flow was start. The time is displayed in the yyyy-MM-DD HH:mm:ss format.
   * 
   * @example
   * 2021-11-11 14:35:57
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      businessTime: 'BusinessTime',
      dagId: 'DagId',
      dagName: 'DagName',
      dagVersion: 'DagVersion',
      endTime: 'EndTime',
      historyDagId: 'HistoryDagId',
      id: 'Id',
      message: 'Message',
      ownerName: 'OwnerName',
      status: 'Status',
      triggerType: 'TriggerType',
      startTime: 'startTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessTime: 'string',
      dagId: 'string',
      dagName: 'string',
      dagVersion: 'string',
      endTime: 'string',
      historyDagId: 'number',
      id: 'number',
      message: 'string',
      ownerName: 'string',
      status: 'number',
      triggerType: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowInstanceResponseBodyDAGInstanceList extends $tea.Model {
  DAGInstance?: ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance[];
  static names(): { [key: string]: string } {
    return {
      DAGInstance: 'DAGInstance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DAGInstance: { 'type': 'array', 'itemType': ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable extends $tea.Model {
  /**
   * @remarks
   * The name of the time variable.
   * 
   * @example
   * time_test
   */
  name?: string;
  /**
   * @remarks
   * The format of the time variable.
   * 
   * @example
   * 2018-09-26|+7h
   */
  pattern?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      pattern: 'Pattern',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      pattern: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowTimeVariablesResponseBodyTimeVariables extends $tea.Model {
  timeVariable?: ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable[];
  static names(): { [key: string]: string } {
    return {
      timeVariable: 'TimeVariable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeVariable: { 'type': 'array', 'itemType': ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow extends $tea.Model {
  /**
   * @remarks
   * The ID of the user who created the task flow.
   * 
   * @example
   * 51****
   */
  creatorId?: string;
  /**
   * @remarks
   * The username of the user who created the task flow.
   * 
   * @example
   * Creator_NickName
   */
  creatorNickName?: string;
  /**
   * @remarks
   * The start time of scheduled scheduling. The task flow is not scheduled before this point in time.
   * 
   * @example
   * 1970-01-01
   */
  cronBeginDate?: string;
  /**
   * @remarks
   * The end time of scheduled scheduling. The task flow is not scheduled after this point in time.
   * 
   * @example
   * 2023-01-01
   */
  cronEndDate?: string;
  /**
   * @remarks
   * Scheduled Cron.
   * 
   * @example
   * 0 0 1 * * ? *
   */
  cronStr?: string;
  /**
   * @remarks
   * Whether to enable scheduled scheduling.
   * 
   * @example
   * false
   */
  cronSwitch?: boolean;
  /**
   * @remarks
   * Scheduling cycle type. Valid values:
   * - **2**: Hourly scheduling
   * - **3**: Daily scheduling
   * - **4**: Weekly scheduling
   * - **5**: Monthly scheduling
   * 
   * @example
   * 2
   */
  cronType?: number;
  /**
   * @remarks
   * The name of the task flow.
   * 
   * @example
   * poc_task_test
   */
  dagName?: string;
  /**
   * @remarks
   * The user ID of the task flow owner.
   * 
   * @example
   * 12***89
   */
  dagOwnerId?: string;
  /**
   * @remarks
   * The username of the owner of the task flow.
   * 
   * @example
   * Owner_NickName
   */
  dagOwnerNickName?: string;
  /**
   * @remarks
   * The ID of the last deployment record of the task flow.
   * 
   * @example
   * 65***
   */
  deployId?: number;
  /**
   * @remarks
   * The description of the task flow.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The ID of the task flow.
   * 
   * @example
   * 7***
   */
  id?: number;
  /**
   * @remarks
   * The status of the last execution of the task flow. Valid values:
   * 
   * *   **0**: invalid
   * *   **1**: scheduling disabled
   * *   **2**: waiting to be scheduled
   * 
   * @example
   * 0
   */
  latestInstanceStatus?: number;
  /**
   * @remarks
   * The time when the last execution record was created.
   * 
   * @example
   * 2022-04-13
   */
  latestInstanceTime?: string;
  /**
   * @remarks
   * The ID of the application scenario.
   * 
   * @example
   * 1245
   */
  scenarioId?: string;
  /**
   * @remarks
   * Event scheduling configuration, JSON string format.
   * 
   * @example
   * {\\"triggerType\\":\\"1\\",\\"specificTime\\":\\"2022-11-15 11:59\\"}
   */
  scheduleParam?: string;
  /**
   * @remarks
   * The status of the task flow. Valid values:
   * 
   * *   **0**: invalid
   * *   **1**: scheduling disabled
   * *   **2**: waiting to be scheduled
   * 
   * @example
   * 1
   */
  status?: number;
  /**
   * @remarks
   * Time zone setting. Default value: East 8(Asia/Shanghai).
   * 
   * @example
   * Asia/Shanghai
   */
  timeZoneId?: string;
  /**
   * @remarks
   * The trigger type. Valid values:
   * - **0**: Periodic scheduling
   * - **1**: Run manually
   * 
   * @example
   * 0
   */
  triggerType?: number;
  static names(): { [key: string]: string } {
    return {
      creatorId: 'CreatorId',
      creatorNickName: 'CreatorNickName',
      cronBeginDate: 'CronBeginDate',
      cronEndDate: 'CronEndDate',
      cronStr: 'CronStr',
      cronSwitch: 'CronSwitch',
      cronType: 'CronType',
      dagName: 'DagName',
      dagOwnerId: 'DagOwnerId',
      dagOwnerNickName: 'DagOwnerNickName',
      deployId: 'DeployId',
      description: 'Description',
      id: 'Id',
      latestInstanceStatus: 'LatestInstanceStatus',
      latestInstanceTime: 'LatestInstanceTime',
      scenarioId: 'ScenarioId',
      scheduleParam: 'ScheduleParam',
      status: 'Status',
      timeZoneId: 'TimeZoneId',
      triggerType: 'TriggerType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorId: 'string',
      creatorNickName: 'string',
      cronBeginDate: 'string',
      cronEndDate: 'string',
      cronStr: 'string',
      cronSwitch: 'boolean',
      cronType: 'number',
      dagName: 'string',
      dagOwnerId: 'string',
      dagOwnerNickName: 'string',
      deployId: 'number',
      description: 'string',
      id: 'number',
      latestInstanceStatus: 'number',
      latestInstanceTime: 'string',
      scenarioId: 'string',
      scheduleParam: 'string',
      status: 'number',
      timeZoneId: 'string',
      triggerType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTaskFlowsByPageResponseBodyTaskFlowList extends $tea.Model {
  taskFlow?: ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow[];
  static names(): { [key: string]: string } {
    return {
      taskFlow: 'TaskFlow',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskFlow: { 'type': 'array', 'itemType': ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTasksInTaskFlowResponseBodyTasksTask extends $tea.Model {
  /**
   * @remarks
   * The position of the node on the Directed Acyclic Graph (DAG).
   * 
   * @example
   * {\\"x\\":435,\\"y\\":192,\\"layoutType\\":\\"Horizontal\\"}
   */
  graphParam?: string;
  /**
   * @remarks
   * The advanced configuration for the node.
   * 
   * @example
   * {     "rerun":{    "rerunEnable":true,      "rerunCount":1,   "rerunInterval":10 //  }}
   */
  nodeConfig?: string;
  /**
   * @remarks
   * The configuration for the node.
   * 
   * @example
   * {     "dbId":123***,  "sql":"",    "dbType":"polardb" }
   */
  nodeContent?: string;
  /**
   * @remarks
   * The ID of the node.
   * 
   * @example
   * 92***
   */
  nodeId?: string;
  /**
   * @remarks
   * The name of the node.
   * 
   * @example
   * Cross-Database Spark SQL-1
   */
  nodeName?: string;
  /**
   * @remarks
   * The output variables for the task.
   * 
   * @example
   * {  "outputs":[{ { "row":0, "column":-1,                  "combiner":"," }            "extractMethod":"{\\"row\\":0,\\"column\\":-1,\\"combiner\\":\\",\\"}",         "variableName":"var",    "description":"For demo"} ] }
   */
  nodeOutput?: string;
  /**
   * @remarks
   * The type of the node. For more information about the valid values for this parameter, see [NodeType parameter](https://help.aliyun.com/document_detail/424705.html).
   * 
   * @example
   * SPARK_SQL
   */
  nodeType?: string;
  /**
   * @remarks
   * The time variables configured for the node.
   * 
   * @example
   * {\\"variables\\":[{\\"name\\":\\"test1\\",\\"pattern\\":\\"yyyy-MM-dd
   */
  timeVariables?: string;
  static names(): { [key: string]: string } {
    return {
      graphParam: 'GraphParam',
      nodeConfig: 'NodeConfig',
      nodeContent: 'NodeContent',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      nodeOutput: 'NodeOutput',
      nodeType: 'NodeType',
      timeVariables: 'TimeVariables',
    };
  }

  static types(): { [key: string]: any } {
    return {
      graphParam: 'string',
      nodeConfig: 'string',
      nodeContent: 'string',
      nodeId: 'string',
      nodeName: 'string',
      nodeOutput: 'string',
      nodeType: 'string',
      timeVariables: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTasksInTaskFlowResponseBodyTasks extends $tea.Model {
  task?: ListTasksInTaskFlowResponseBodyTasksTask[];
  static names(): { [key: string]: string } {
    return {
      task: 'Task',
    };
  }

  static types(): { [key: string]: any } {
    return {
      task: { 'type': 'array', 'itemType': ListTasksInTaskFlowResponseBodyTasksTask },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail extends $tea.Model {
  /**
   * @remarks
   * The time when the permissions were granted.
   * 
   * @example
   * 2019-12-12 00:00:00
   */
  createDate?: string;
  /**
   * @remarks
   * The time when the permissions expire.
   * 
   * @example
   * 2020-12-12 00:00:00
   */
  expireDate?: string;
  /**
   * @remarks
   * This parameter is reserved.
   * 
   * @example
   * xxx
   */
  extraData?: string;
  /**
   * @remarks
   * The user who grants the permissions.
   * 
   * @example
   * xxx authorization
   */
  originFrom?: string;
  /**
   * @remarks
   * The type of the permissions. Valid values:
   * 
   * *   QUERY: the query permissions
   * *   EXPORT: the export permissions
   * *   CORRECT: the change permissions
   * 
   * @example
   * QUERY
   */
  permType?: string;
  /**
   * @remarks
   * The ID of the authorization record.
   * 
   * @example
   * 758****
   */
  userAccessId?: string;
  static names(): { [key: string]: string } {
    return {
      createDate: 'CreateDate',
      expireDate: 'ExpireDate',
      extraData: 'ExtraData',
      originFrom: 'OriginFrom',
      permType: 'PermType',
      userAccessId: 'UserAccessId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createDate: 'string',
      expireDate: 'string',
      extraData: 'string',
      originFrom: 'string',
      permType: 'string',
      userAccessId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails extends $tea.Model {
  permDetail?: ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail[];
  static names(): { [key: string]: string } {
    return {
      permDetail: 'PermDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      permDetail: { 'type': 'array', 'itemType': ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserPermissionsResponseBodyUserPermissionsUserPermission extends $tea.Model {
  /**
   * @remarks
   * The alias of the instance.
   * 
   * @example
   * instance_alias
   */
  alias?: string;
  /**
   * @remarks
   * The name of the field.
   * 
   * @example
   * column_name
   */
  columnName?: string;
  /**
   * @remarks
   * The ID of the database.
   * 
   * @example
   * 1860****
   */
  dbId?: string;
  /**
   * @remarks
   * The type of the database. For more information about the valid values of this parameter, see [DbType parameter](https://www.alibabacloud.com/help/en/data-management-service/latest/dbtype-parameter).
   * 
   * @example
   * polardb
   */
  dbType?: string;
  /**
   * @remarks
   * The permissions on a specific type of objects that are granted to the user. Valid values: 
   * 
   * - DATABASE: permissions on physical databases
   * - LOGIC_DATABASE: permissions on logical databases
   * - TABLE: permissions on physical tables
   * - LOGIC_TABLE: permissions on logical tables
   * 
   * @example
   * DATABASE
   */
  dsType?: string;
  /**
   * @remarks
   * The type of the environment to which the database belongs. Valid values:
   * 
   * - product: production environment
   * - dev: development environment
   * - pre: staging environment
   * - test: test environment
   * - sit: SIT environment
   * - uat: UAT environment
   * - pet: stress testing environment
   * - stag: STAG environment
   * 
   * @example
   * dev
   */
  envType?: string;
  /**
   * @remarks
   * The endpoint that is used to connect the database.
   * 
   * @example
   * rm-bp144d5ky4l4r****
   */
  host?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * 174****
   */
  instanceId?: string;
  /**
   * @remarks
   * Indicates whether the database is a logical database. Valid values:
   * 
   * *   true: The database is a logical database.
   * *   false: The database is a physical database.
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The details of permissions.
   */
  permDetails?: ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails;
  /**
   * @remarks
   * The port that is used to connect to the instance.
   * 
   * @example
   * 3306
   */
  port?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * test_db
   */
  schemaName?: string;
  /**
   * @remarks
   * The name that is used to search for the database.
   * 
   * @example
   * test_db@xxx:3306
   */
  searchName?: string;
  /**
   * @remarks
   * The ID of the table.
   * 
   * @example
   * 13434
   */
  tableId?: string;
  /**
   * @remarks
   * The name of the table.
   * 
   * @example
   * test_table
   */
  tableName?: string;
  /**
   * @remarks
   * The ID of the user.
   * 
   * @example
   * 51****
   */
  userId?: string;
  /**
   * @remarks
   * The nickname of the user.
   * 
   * @example
   * nick_name
   */
  userNickName?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      columnName: 'ColumnName',
      dbId: 'DbId',
      dbType: 'DbType',
      dsType: 'DsType',
      envType: 'EnvType',
      host: 'Host',
      instanceId: 'InstanceId',
      logic: 'Logic',
      permDetails: 'PermDetails',
      port: 'Port',
      schemaName: 'SchemaName',
      searchName: 'SearchName',
      tableId: 'TableId',
      tableName: 'TableName',
      userId: 'UserId',
      userNickName: 'UserNickName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      columnName: 'string',
      dbId: 'string',
      dbType: 'string',
      dsType: 'string',
      envType: 'string',
      host: 'string',
      instanceId: 'string',
      logic: 'boolean',
      permDetails: ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails,
      port: 'number',
      schemaName: 'string',
      searchName: 'string',
      tableId: 'string',
      tableName: 'string',
      userId: 'string',
      userNickName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserPermissionsResponseBodyUserPermissions extends $tea.Model {
  userPermission?: ListUserPermissionsResponseBodyUserPermissionsUserPermission[];
  static names(): { [key: string]: string } {
    return {
      userPermission: 'UserPermission',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userPermission: { 'type': 'array', 'itemType': ListUserPermissionsResponseBodyUserPermissionsUserPermission },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserTenantsResponseBodyTenantList extends $tea.Model {
  /**
   * @remarks
   * The status of the tenant. Valid values:
   * 
   * *   **ACTIVE**: The tenant is used to access DMS.
   * *   **IN_ACTIVE**: The tenant is not used.
   * 
   * @example
   * ACTIVE
   */
  status?: string;
  /**
   * @remarks
   * The name of the tenant.
   * 
   * @example
   * test_name
   */
  tenantName?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * 3***
   */
  tid?: number;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      tenantName: 'TenantName',
      tid: 'Tid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      tenantName: 'string',
      tid: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUsersResponseBodyUserListUserRoleIdList extends $tea.Model {
  roleIds?: number[];
  static names(): { [key: string]: string } {
    return {
      roleIds: 'RoleIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleIds: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUsersResponseBodyUserListUserRoleNameList extends $tea.Model {
  roleNames?: string[];
  static names(): { [key: string]: string } {
    return {
      roleNames: 'RoleNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      roleNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUsersResponseBodyUserListUser extends $tea.Model {
  /**
   * @remarks
   * The number of queries that were performed on the current day.
   * 
   * @example
   * 0
   */
  curExecuteCount?: number;
  /**
   * @remarks
   * The number of rows that were queried on the current day.
   * 
   * @example
   * 0
   */
  curResultCount?: number;
  /**
   * @remarks
   * The DingTalk chatbot URL that is used to receive notifications.
   * 
   * > 
   * 
   * *   The system returns this parameter if you have set a DingTalk chatbot URL in the console. To set a DingTalk chatbot URL in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
   * 
   * *   The system does not return this parameter if you have not set a DingTalk chatbot URL.
   * 
   * @example
   * https://XXX.dingtalk.com/robot/send?access_token=9b7a4a562cbe7fcdea9962afac7b9d7b4504d564948083419750f9cafa78e4ef
   */
  dingRobot?: string;
  /**
   * @remarks
   * The email address that is used to receive notifications.
   * 
   * > 
   * 
   * *   The system returns this parameter if you have set an email address in the console. To set an email address in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
   * 
   * *   The system does not return this parameter if you have not set an email address.
   * 
   * @example
   * username@example.com
   */
  email?: string;
  /**
   * @remarks
   * The time when the user last logged on to the console.
   * 
   * @example
   * 2021-11-08 13:43:43
   */
  lastLoginTime?: string;
  /**
   * @remarks
   * The maximum number of queries that can be performed on the current day.
   * 
   * @example
   * 2000
   */
  maxExecuteCount?: number;
  /**
   * @remarks
   * The maximum number of rows that can be queried on the current day.
   * 
   * @example
   * 50000
   */
  maxResultCount?: number;
  /**
   * @remarks
   * The mobile phone number of the user.
   * 
   * > 
   * 
   * *   The system returns this parameter if you have set a mobile phone number in the console. To set a mobile phone number in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
   * 
   * *   The system does not return this parameter if you have not set a mobile phone number.
   * 
   * @example
   * 1389999****
   */
  mobile?: string;
  /**
   * @remarks
   * The nickname of the user.
   * 
   * @example
   * test_NickName
   */
  nickName?: string;
  /**
   * @remarks
   * The notification method. The system returns one or more values. Valid values:
   * 
   * *   **SMS**: text message
   * *   **EMAIL**: email.
   * *   **DINGDING**: DingTalk.
   * *   **DINGROBOT**: DingTalk chatbot.
   * *   **WEBHOOK**: webhook.
   * 
   * @example
   * DINGROBOT
   */
  notificationMode?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account of the user.
   * 
   * @example
   * 140692647406****
   */
  parentUid?: string;
  /**
   * @remarks
   * The IDs of the roles.
   */
  roleIdList?: ListUsersResponseBodyUserListUserRoleIdList;
  /**
   * @remarks
   * The names of roles.
   */
  roleNameList?: ListUsersResponseBodyUserListUserRoleNameList;
  /**
   * @remarks
   * The signature method that is used to secure connections when a webhook URL is used. Valid values:
   * 
   * *   **NONE**: no signature.
   * *   **HMAC_SHA1**: HMAC_SHA1.
   * 
   * @example
   * HMAC_SHA1
   */
  signatureMethod?: string;
  /**
   * @remarks
   * The status of the user. Valid values:
   * 
   * *   **NORMAL**: The user is normal.
   * *   **DISABLE**: The user is disabled.
   * *   **DELETE**: The user is deleted.
   * 
   * @example
   * NORMAL
   */
  state?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 167382665015****
   */
  uid?: string;
  /**
   * @remarks
   * The ID of the user.
   * 
   * @example
   * 8****
   */
  userId?: string;
  /**
   * @remarks
   * The webhook URL that is used to receive notifications.
   * 
   * > 
   * 
   * *   If you have set a webhook URL, DMS sends notifications to the specified URL.
   * 
   * *   The system does not return this parameter if you have not set a webhook URL.
   * 
   * @example
   * http://dms-XXX.aliyun.com:8***
   */
  webhook?: string;
  static names(): { [key: string]: string } {
    return {
      curExecuteCount: 'CurExecuteCount',
      curResultCount: 'CurResultCount',
      dingRobot: 'DingRobot',
      email: 'Email',
      lastLoginTime: 'LastLoginTime',
      maxExecuteCount: 'MaxExecuteCount',
      maxResultCount: 'MaxResultCount',
      mobile: 'Mobile',
      nickName: 'NickName',
      notificationMode: 'NotificationMode',
      parentUid: 'ParentUid',
      roleIdList: 'RoleIdList',
      roleNameList: 'RoleNameList',
      signatureMethod: 'SignatureMethod',
      state: 'State',
      uid: 'Uid',
      userId: 'UserId',
      webhook: 'Webhook',
    };
  }

  static types(): { [key: string]: any } {
    return {
      curExecuteCount: 'number',
      curResultCount: 'number',
      dingRobot: 'string',
      email: 'string',
      lastLoginTime: 'string',
      maxExecuteCount: 'number',
      maxResultCount: 'number',
      mobile: 'string',
      nickName: 'string',
      notificationMode: 'string',
      parentUid: 'string',
      roleIdList: ListUsersResponseBodyUserListUserRoleIdList,
      roleNameList: ListUsersResponseBodyUserListUserRoleNameList,
      signatureMethod: 'string',
      state: 'string',
      uid: 'string',
      userId: 'string',
      webhook: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUsersResponseBodyUserList extends $tea.Model {
  user?: ListUsersResponseBodyUserListUser[];
  static names(): { [key: string]: string } {
    return {
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      user: { 'type': 'array', 'itemType': ListUsersResponseBodyUserListUser },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser extends $tea.Model {
  /**
   * @remarks
   * The nickname of the approver.
   * 
   * @example
   * test
   */
  nickName?: string;
  /**
   * @remarks
   * The real name of the approver.
   * 
   * @example
   * test
   */
  realName?: string;
  /**
   * @remarks
   * The ID of the approver. The ID is different from the ID of the Alibaba Cloud account of the approver.
   * 
   * @example
   * 123
   */
  userId?: number;
  static names(): { [key: string]: string } {
    return {
      nickName: 'NickName',
      realName: 'RealName',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nickName: 'string',
      realName: 'string',
      userId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers extends $tea.Model {
  auditUser?: ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser[];
  static names(): { [key: string]: string } {
    return {
      auditUser: 'AuditUser',
    };
  }

  static types(): { [key: string]: any } {
    return {
      auditUser: { 'type': 'array', 'itemType': ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode extends $tea.Model {
  /**
   * @remarks
   * The details about approvers.
   */
  auditUsers?: ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers;
  /**
   * @remarks
   * The description of the approval template.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * The ID of the creator. This ID is different from the ID of the Alibaba Cloud account of the creator.
   * 
   * @example
   * 123
   */
  createUserId?: number;
  /**
   * @remarks
   * The name of the user who creates the approval node.
   * 
   * @example
   * test
   */
  createUserNickName?: string;
  /**
   * @remarks
   * The ID of the approval node.
   * 
   * @example
   * 123
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the approval node.
   * 
   * @example
   * test
   */
  nodeName?: string;
  /**
   * @remarks
   * The type of the approval node. Valid values:
   * 
   * *   SYS: The approval node is predefined by the system.
   * *   USER_LIST: The approval node is created by a user.
   * 
   * @example
   * SYS
   */
  nodeType?: string;
  static names(): { [key: string]: string } {
    return {
      auditUsers: 'AuditUsers',
      comment: 'Comment',
      createUserId: 'CreateUserId',
      createUserNickName: 'CreateUserNickName',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      nodeType: 'NodeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      auditUsers: ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers,
      comment: 'string',
      createUserId: 'number',
      createUserNickName: 'string',
      nodeId: 'number',
      nodeName: 'string',
      nodeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowNodesResponseBodyWorkflowNodes extends $tea.Model {
  workflowNode?: ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode[];
  static names(): { [key: string]: string } {
    return {
      workflowNode: 'WorkflowNode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      workflowNode: { 'type': 'array', 'itemType': ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode extends $tea.Model {
  /**
   * @remarks
   * The description of the approval node.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * The ID of the creator.
   * 
   * @example
   * 1234
   */
  createUserId?: number;
  /**
   * @remarks
   * The ID of the approval node.
   * 
   * @example
   * 123
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the approval node.
   * 
   * @example
   * test
   */
  nodeName?: string;
  /**
   * @remarks
   * The type of the approval node. Valid values:
   * 
   * *   SYS: The approval node is predefined by the system.
   * *   USER_LIST: The approval node is created by a user.
   * 
   * @example
   * SYS
   */
  nodeType?: string;
  /**
   * @remarks
   * The position of the approval node.
   * 
   * @example
   * 1
   */
  position?: number;
  /**
   * @remarks
   * The ID of the template.
   * 
   * @example
   * 12345
   */
  templateId?: number;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      createUserId: 'CreateUserId',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      nodeType: 'NodeType',
      position: 'Position',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      createUserId: 'number',
      nodeId: 'number',
      nodeName: 'string',
      nodeType: 'string',
      position: 'number',
      templateId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes extends $tea.Model {
  workflowNode?: ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode[];
  static names(): { [key: string]: string } {
    return {
      workflowNode: 'WorkflowNode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      workflowNode: { 'type': 'array', 'itemType': ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate extends $tea.Model {
  /**
   * @remarks
   * The description of the approval template.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * The ID of the creator.
   * 
   * @example
   * 1234
   */
  createUserId?: number;
  /**
   * @remarks
   * Indicates whether the approval template is enabled. Valid values:
   * 
   * *   Y: The approval template is enabled.
   * *   N: The approval template is disabled.
   * 
   * @example
   * Y
   */
  enabled?: string;
  /**
   * @remarks
   * Indicates whether the approval template is predefined by the system. Valid values:
   * 
   * *   1: The approval template is predefined by the system.
   * *   0: The approval template is not predefined by the system.
   * 
   * @example
   * 1
   */
  isSystem?: number;
  /**
   * @remarks
   * The ID of the approval template.
   * 
   * @example
   * 12345
   */
  templateId?: number;
  /**
   * @remarks
   * The name of the approval template.
   * 
   * @example
   * Admin
   */
  templateName?: string;
  /**
   * @remarks
   * The details of approval nodes.
   */
  workflowNodes?: ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      createUserId: 'CreateUserId',
      enabled: 'Enabled',
      isSystem: 'IsSystem',
      templateId: 'TemplateId',
      templateName: 'TemplateName',
      workflowNodes: 'WorkflowNodes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      createUserId: 'number',
      enabled: 'string',
      isSystem: 'number',
      templateId: 'number',
      templateName: 'string',
      workflowNodes: ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWorkFlowTemplatesResponseBodyWorkFlowTemplates extends $tea.Model {
  workFlowTemplate?: ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate[];
  static names(): { [key: string]: string } {
    return {
      workFlowTemplate: 'WorkFlowTemplate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      workFlowTemplate: { 'type': 'array', 'itemType': ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser extends $tea.Model {
  /**
   * @example
   * Owner
   */
  nickName?: string;
  /**
   * @example
   * db_test
   */
  realName?: string;
  /**
   * @example
   * 16***
   */
  userId?: number;
  static names(): { [key: string]: string } {
    return {
      nickName: 'NickName',
      realName: 'RealName',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nickName: 'string',
      realName: 'string',
      userId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserList extends $tea.Model {
  auditUser?: PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser[];
  static names(): { [key: string]: string } {
    return {
      auditUser: 'AuditUser',
    };
  }

  static types(): { [key: string]: any } {
    return {
      auditUser: { 'type': 'array', 'itemType': PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode extends $tea.Model {
  auditUserList?: PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserList;
  comment?: string;
  /**
   * @example
   * Owner
   */
  nodeName?: string;
  /**
   * @example
   * SYS
   */
  nodeType?: string;
  static names(): { [key: string]: string } {
    return {
      auditUserList: 'AuditUserList',
      comment: 'Comment',
      nodeName: 'NodeName',
      nodeType: 'NodeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      auditUserList: PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserList,
      comment: 'string',
      nodeName: 'string',
      nodeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeList extends $tea.Model {
  workflowNode?: PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode[];
  static names(): { [key: string]: string } {
    return {
      workflowNode: 'WorkflowNode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      workflowNode: { 'type': 'array', 'itemType': PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreviewWorkflowResponseBodyWorkflowDetail extends $tea.Model {
  comment?: string;
  wfCateName?: string;
  workflowNodeList?: PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeList;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      wfCateName: 'WfCateName',
      workflowNodeList: 'WorkflowNodeList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      wfCateName: 'string',
      workflowNodeList: PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDataTrackResultDownloadStatusResponseBodyStatusResult extends $tea.Model {
  /**
   * @remarks
   * The status of the download task. Valid values:
   * 
   * *   **INIT**: The download task is being initialized.
   * *   **LISTING**: The download task is in a transient intermediate state during the initialization.
   * *   **DOWNLOADING**: The download task is being processed.
   * *   **DOWNLOAD_SUCCESS**: The download task was successfully processed.
   * *   **DOWNLOAD_FAIL**: The download task failed.
   * 
   * @example
   * DOWNLOAD_SUCCESS
   */
  downloadStatus?: string;
  /**
   * @remarks
   * The URL that is used to download data tracking logs. This parameter is returned only when the value of DownloadStatus is DOWNLOAD_SUCCESS.
   * 
   * @example
   * https://idbsaasstore.oss-cn-zhangjiakou.aliyuncs.com/****_REDO_31201_207.zip?Expires=1682239593&OSSAccessKeyId=****&Signature=****
   */
  downloadUrl?: string;
  /**
   * @remarks
   * The description of the state.
   * 
   * @example
   * SUCCESS
   */
  statusDesc?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 69
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      downloadStatus: 'DownloadStatus',
      downloadUrl: 'DownloadUrl',
      statusDesc: 'StatusDesc',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadStatus: 'string',
      downloadUrl: 'string',
      statusDesc: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDataTrackResultRequestColumnFilter extends $tea.Model {
  /**
   * @remarks
   * The end value of the range used in the filter condition. This parameter takes effect only when Operator is set to BETWEEN.
   * 
   * @example
   * 10
   */
  betweenEnd?: string;
  /**
   * @remarks
   * The start value of the range used in the filter condition. This parameter takes effect only when Operator is set to BETWEEN.
   * 
   * @example
   * 1
   */
  betweenStart?: string;
  /**
   * @remarks
   * The name of the column.
   * 
   * @example
   * c_payer_name
   */
  columnName?: string;
  /**
   * @remarks
   * The IN list used in the filter condition. This parameter takes effect only when Operator is set to IN or NOT_IN.
   */
  inList?: string[];
  /**
   * @remarks
   * The type of the operator used to configure the filter condition. Valid values:
   * 
   * *   **EQUAL**: retrieves the column whose value is equal to the specified value.
   * *   **NOT_EQUAL**: retrieves the column whose value is not equal to the specified value.
   * *   **IN**: retrieves the column whose value is in the IN list.
   * *   **BETWEEN**: retrieves the column whose value is in the specified range.
   * *   **LESS**: retrieves the column whose value is less than the specified value.
   * *   **MORE**: retrieves the column whose value is greater than the specified value.
   * *   **NOT_IN**: retrieves the column whose value is not in the IN list.
   * 
   * @example
   * EQUAL
   */
  operator?: string;
  /**
   * @remarks
   * The value used in the filter condition.
   * 
   * @example
   * 1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      betweenEnd: 'BetweenEnd',
      betweenStart: 'BetweenStart',
      columnName: 'ColumnName',
      inList: 'InList',
      operator: 'Operator',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      betweenEnd: 'string',
      betweenStart: 'string',
      columnName: 'string',
      inList: { 'type': 'array', 'itemType': 'string' },
      operator: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDataTrackResultResponseBodyTrackResultEventList extends $tea.Model {
  /**
   * @remarks
   * The data records after you perform data operations in the database.
   */
  dataAfter?: string[];
  /**
   * @remarks
   * The data records before you perform data operations in the database.
   */
  dataBefore?: string[];
  /**
   * @remarks
   * The ID of the event.
   * 
   * @example
   * 1
   */
  eventId?: number;
  /**
   * @remarks
   * The length of the event content. Unit: bytes.
   * 
   * @example
   * 4324
   */
  eventLength?: number;
  /**
   * @remarks
   * The event time.
   * 
   * @example
   * 2023-04-23 10:25:47
   */
  eventTimestamp?: string;
  /**
   * @remarks
   * The type of the event. Valid values:
   * 
   * *   **WRITE_ROWS**: indicates an INSERT operation.
   * *   **UPDATE_ROWS**: indicates an UPDATE operation.
   * *   **DELETE_ROWS**: indicates a DELETE operation.
   * *   **EXT_WRITE_ROWS**: indicates an INSERT operation, which is equivalent to WRITE_ROWS.
   * *   **EXT_UPDATE_ROWS**: indicates an UPDATE operation, which is equivalent to UPDATE_ROWS.
   * *   **EXT_DELETE_ROWS**: indicates a DELETE operation, which is equivalent to DELETE_ROWS.
   * 
   * @example
   * UPDATE_ROWS
   */
  eventType?: string;
  /**
   * @remarks
   * The SQL statements used to roll back the data change.
   * 
   * @example
   * -- Timestamp:2023-04-23 10:25:47 #1\\r\\nUPDATE `dc_test`.`tb_chunk_dml` SET `id`=1 , `gmt_create`=\\"2021-09-30T00:00:00\\" , `content`=\\"2023-03-30 14:51:50\\" , `c1`=\\"2023-04-17 13:42:03\\" , `c_id`=1 , `c13425`=\\"b\\\\\\"\\" , `c432532535`= null , `c1432`= null , `c143243253`= null , `c1432535`= null , `c43125325`= null , `c3425325`= null WHERE  (`id`=1)"
   */
  rollSQL?: string;
  static names(): { [key: string]: string } {
    return {
      dataAfter: 'DataAfter',
      dataBefore: 'DataBefore',
      eventId: 'EventId',
      eventLength: 'EventLength',
      eventTimestamp: 'EventTimestamp',
      eventType: 'EventType',
      rollSQL: 'RollSQL',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataAfter: { 'type': 'array', 'itemType': 'string' },
      dataBefore: { 'type': 'array', 'itemType': 'string' },
      eventId: 'number',
      eventLength: 'number',
      eventTimestamp: 'string',
      eventType: 'string',
      rollSQL: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns extends $tea.Model {
  /**
   * @remarks
   * The name of the column.
   * 
   * @example
   * basic_platform
   */
  columnName?: string;
  /**
   * @remarks
   * The position of the column.
   * 
   * @example
   * 1
   */
  columnPosition?: number;
  /**
   * @remarks
   * The data type of the column. Examples: BIGINT, INT, and VARCHAR.
   * 
   * @example
   * BIGINT
   */
  columnType?: string;
  /**
   * @remarks
   * Indicates whether the column is a virtual column. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  fictive?: boolean;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      columnPosition: 'ColumnPosition',
      columnType: 'ColumnType',
      fictive: 'Fictive',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      columnPosition: 'number',
      columnType: 'string',
      fictive: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDataTrackResultResponseBodyTrackResultTableInfoList extends $tea.Model {
  /**
   * @remarks
   * The information about columns.
   */
  columns?: SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns[];
  /**
   * @remarks
   * The description of the column.
   * 
   * @example
   * auto-description
   */
  description?: string;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * prod_eb_vas
   */
  schemaName?: string;
  /**
   * @remarks
   * The name of the table.
   * 
   * @example
   * import_table_test1
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      columns: 'Columns',
      description: 'Description',
      schemaName: 'SchemaName',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columns: { 'type': 'array', 'itemType': SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns },
      description: 'string',
      schemaName: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDataTrackResultResponseBodyTrackResult extends $tea.Model {
  /**
   * @remarks
   * The details of the event logs.
   */
  eventList?: SearchDataTrackResultResponseBodyTrackResultEventList[];
  /**
   * @remarks
   * The metadata of tables for which you track data operations.
   */
  tableInfoList?: SearchDataTrackResultResponseBodyTrackResultTableInfoList[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 109
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      eventList: 'EventList',
      tableInfoList: 'TableInfoList',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventList: { 'type': 'array', 'itemType': SearchDataTrackResultResponseBodyTrackResultEventList },
      tableInfoList: { 'type': 'array', 'itemType': SearchDataTrackResultResponseBodyTrackResultTableInfoList },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList extends $tea.Model {
  ownerIds?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerIds: 'OwnerIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList extends $tea.Model {
  ownerNames?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerNames: 'OwnerNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDatabaseResponseBodySearchDatabaseListSearchDatabase extends $tea.Model {
  /**
   * @remarks
   * The alias of the database.
   * 
   * @example
   * test_rds
   */
  alias?: string;
  /**
   * @remarks
   * The name of the catalog to which the database belongs.
   * 
   * > If the type of the database engine is PostgreSQL, the name of the database is displayed.
   * 
   * @example
   * dmstest
   */
  catalogName?: string;
  /**
   * @remarks
   * The ID of the database.
   * 
   * @example
   * 2528****
   */
  databaseId?: string;
  /**
   * @remarks
   * The name of the data link for cross-database queries.
   * 
   * @example
   * datalink_name
   */
  datalinkName?: string;
  /**
   * @remarks
   * The type of the database engine.
   * 
   * @example
   * mysql
   */
  dbType?: string;
  /**
   * @remarks
   * The ID of the user who assumes the database administrator (DBA) role.
   * 
   * @example
   * 10****
   */
  dbaId?: string;
  /**
   * @remarks
   * The encoding method of the database.
   * 
   * @example
   * utf8
   */
  encoding?: string;
  /**
   * @remarks
   * The environment type of the database. For more information, see [Change the environment type of an instance](https://help.aliyun.com/document_detail/163309.html).
   * 
   * @example
   * test
   */
  envType?: string;
  /**
   * @remarks
   * The endpoint of the instance in which the database resides.
   * 
   * @example
   * rm-xxxx.mysql.rds.aliyuncs.com
   */
  host?: string;
  /**
   * @remarks
   * Indicates whether the database is a logical database. Valid values:
   * 
   * *   **true**: The database is a logical database.
   * *   **false**: The database is not a logical database.
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The IDs of the owners of the databases.
   */
  ownerIdList?: SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList;
  /**
   * @remarks
   * The nicknames of the database owners.
   */
  ownerNameList?: SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList;
  /**
   * @remarks
   * The port of the instance in which the database resides.
   * 
   * @example
   * 3306
   */
  port?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * test
   */
  schemaName?: string;
  /**
   * @remarks
   * The name that is used to search for the database.
   * 
   * @example
   * test@xxx.xxx.xxx.xxx:3306
   */
  searchName?: string;
  /**
   * @remarks
   * The system ID (SID) of the instance in which the database resides.
   * 
   * @example
   * testSid
   */
  sid?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      catalogName: 'CatalogName',
      databaseId: 'DatabaseId',
      datalinkName: 'DatalinkName',
      dbType: 'DbType',
      dbaId: 'DbaId',
      encoding: 'Encoding',
      envType: 'EnvType',
      host: 'Host',
      logic: 'Logic',
      ownerIdList: 'OwnerIdList',
      ownerNameList: 'OwnerNameList',
      port: 'Port',
      schemaName: 'SchemaName',
      searchName: 'SearchName',
      sid: 'Sid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      catalogName: 'string',
      databaseId: 'string',
      datalinkName: 'string',
      dbType: 'string',
      dbaId: 'string',
      encoding: 'string',
      envType: 'string',
      host: 'string',
      logic: 'boolean',
      ownerIdList: SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList,
      ownerNameList: SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList,
      port: 'number',
      schemaName: 'string',
      searchName: 'string',
      sid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchDatabaseResponseBodySearchDatabaseList extends $tea.Model {
  searchDatabase?: SearchDatabaseResponseBodySearchDatabaseListSearchDatabase[];
  static names(): { [key: string]: string } {
    return {
      searchDatabase: 'SearchDatabase',
    };
  }

  static types(): { [key: string]: any } {
    return {
      searchDatabase: { 'type': 'array', 'itemType': SearchDatabaseResponseBodySearchDatabaseListSearchDatabase },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTableResponseBodySearchTableListSearchTableOwnerIdList extends $tea.Model {
  ownerIds?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerIds: 'OwnerIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTableResponseBodySearchTableListSearchTableOwnerNameList extends $tea.Model {
  ownerNames?: string[];
  static names(): { [key: string]: string } {
    return {
      ownerNames: 'OwnerNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTableResponseBodySearchTableListSearchTable extends $tea.Model {
  /**
   * @remarks
   * The name that is used to search for the database to which the table belongs.
   * 
   * @example
   * test
   */
  DBSearchName?: string;
  /**
   * @remarks
   * The ID of the database to which the table belongs.
   * 
   * @example
   * 1
   */
  databaseId?: string;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * test
   */
  dbName?: string;
  /**
   * @remarks
   * The type of the database. Valid values:
   * 
   * *   **MySQL**
   * *   **SQLServer**
   * *   **PostgreSQL**
   * *   **Oracle**
   * *   **DRDS**
   * *   **OceanBase**
   * *   **Mongo**
   * *   **Redis**
   * 
   * @example
   * mysql
   */
  dbType?: string;
  /**
   * @remarks
   * The description of the table.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The encoding format of the table.
   * 
   * @example
   * utf8
   */
  encoding?: string;
  /**
   * @remarks
   * The engine of the table.
   * 
   * @example
   * innodb
   */
  engine?: string;
  /**
   * @remarks
   * The type of the environment to which the database belongs.
   * 
   * @example
   * test
   */
  envType?: string;
  /**
   * @remarks
   * Indicates whether the table is a logical table. Valid values:
   * 
   * *   **true**: The table is a logical table.
   * *   **false**: The table is not a logical table.
   * 
   * @example
   * false
   */
  logic?: boolean;
  /**
   * @remarks
   * The IDs of the table owners.
   */
  ownerIdList?: SearchTableResponseBodySearchTableListSearchTableOwnerIdList;
  /**
   * @remarks
   * The nicknames of the table owners.
   */
  ownerNameList?: SearchTableResponseBodySearchTableListSearchTableOwnerNameList;
  /**
   * @remarks
   * The GUID of the table.
   * 
   * @example
   * IDB_L_9032.db-test.yuyang_test
   */
  tableGuid?: string;
  /**
   * @remarks
   * The ID of the table.
   * 
   * @example
   * 1
   */
  tableId?: string;
  /**
   * @remarks
   * The name of the table.
   * 
   * @example
   * test_table
   */
  tableName?: string;
  /**
   * @remarks
   * The name of the database to which the table belongs.
   * 
   * @example
   * test@xxx.xxx.xxx.xxx:3306
   */
  tableSchemaName?: string;
  static names(): { [key: string]: string } {
    return {
      DBSearchName: 'DBSearchName',
      databaseId: 'DatabaseId',
      dbName: 'DbName',
      dbType: 'DbType',
      description: 'Description',
      encoding: 'Encoding',
      engine: 'Engine',
      envType: 'EnvType',
      logic: 'Logic',
      ownerIdList: 'OwnerIdList',
      ownerNameList: 'OwnerNameList',
      tableGuid: 'TableGuid',
      tableId: 'TableId',
      tableName: 'TableName',
      tableSchemaName: 'TableSchemaName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DBSearchName: 'string',
      databaseId: 'string',
      dbName: 'string',
      dbType: 'string',
      description: 'string',
      encoding: 'string',
      engine: 'string',
      envType: 'string',
      logic: 'boolean',
      ownerIdList: SearchTableResponseBodySearchTableListSearchTableOwnerIdList,
      ownerNameList: SearchTableResponseBodySearchTableListSearchTableOwnerNameList,
      tableGuid: 'string',
      tableId: 'string',
      tableName: 'string',
      tableSchemaName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchTableResponseBodySearchTableList extends $tea.Model {
  searchTable?: SearchTableResponseBodySearchTableListSearchTable[];
  static names(): { [key: string]: string } {
    return {
      searchTable: 'SearchTable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      searchTable: { 'type': 'array', 'itemType': SearchTableResponseBodySearchTableListSearchTable },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAuthorityTemplateResponseBodyAuthorityTemplateView extends $tea.Model {
  /**
   * @remarks
   * The ID of the user who created the permission template.
   * 
   * @example
   * 12***
   */
  creatorId?: number;
  /**
   * @remarks
   * The description of the permission template.
   * 
   * @example
   * This template is used for business testing.
   */
  description?: string;
  /**
   * @remarks
   * The name of the permission template.
   * 
   * @example
   * Test template.
   */
  name?: string;
  /**
   * @remarks
   * The ID of the permission template.
   * 
   * @example
   * 1563
   */
  templateId?: number;
  static names(): { [key: string]: string } {
    return {
      creatorId: 'CreatorId',
      description: 'Description',
      name: 'Name',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorId: 'number',
      description: 'string',
      name: 'string',
      templateId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSLARulesRequestSlaRuleList extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow.
   * 
   * This parameter is required.
   * 
   * @example
   * 15***
   */
  dagId?: number;
  /**
   * @remarks
   * The timeout period. Unit: minutes.
   * 
   * This parameter is required.
   * 
   * @example
   * 1080
   */
  intervalMinutes?: number;
  /**
   * @remarks
   * The ID of the task node.
   * 
   * @example
   * 0
   */
  nodeId?: number;
  /**
   * @remarks
   * The rule type. Valid values:
   * 
   * *   **0**: SLA rules for task flows
   * *   **1**: SLA rules for nodes
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  type?: number;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      intervalMinutes: 'IntervalMinutes',
      nodeId: 'NodeId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      intervalMinutes: 'number',
      nodeId: 'number',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateStandardGroupResponseBodyStandardGroup extends $tea.Model {
  /**
   * @remarks
   * The type of the database for which the security rules are used.
   * 
   * @example
   * mysql
   */
  dbType?: string;
  /**
   * @remarks
   * The description of the security rule set.
   * 
   * @example
   * Production Environment test rules
   */
  description?: string;
  /**
   * @remarks
   * The security rule set ID.
   * 
   * @example
   * 41****
   */
  groupId?: number;
  /**
   * @remarks
   * The control mode. Valid values:
   * 
   * *   **NONE_CONTROL**: Flexible Management
   * *   **STABLE**: Stable Change
   * *   **COMMON**: Security Collaboration
   * 
   * @example
   * COMMON
   */
  groupMode?: string;
  /**
   * @remarks
   * The name of the security rule set.
   * 
   * @example
   * poc_test
   */
  groupName?: string;
  /**
   * @remarks
   * The ID of the user who last modified the security rules.
   * 
   * @example
   * 51****
   */
  lastMenderId?: number;
  static names(): { [key: string]: string } {
    return {
      dbType: 'DbType',
      description: 'Description',
      groupId: 'GroupId',
      groupMode: 'GroupMode',
      groupName: 'GroupName',
      lastMenderId: 'LastMenderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbType: 'string',
      description: 'string',
      groupId: 'number',
      groupMode: 'string',
      groupName: 'string',
      lastMenderId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowConstantsRequestDagConstants extends $tea.Model {
  /**
   * @remarks
   * The key name of a constant for the task flow.
   * 
   * @example
   * poc_test
   */
  key?: string;
  /**
   * @remarks
   * The key value of a constant for the task flow.
   * 
   * @example
   * poc_test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowEdgesRequestEdges extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow edge.
   * 
   * This parameter is required.
   * 
   * @example
   * 24***
   */
  id?: number;
  /**
   * @remarks
   * The ID of the end node of the edge.
   * 
   * This parameter is required.
   * 
   * @example
   * 44***
   */
  nodeEnd?: number;
  /**
   * @remarks
   * The ID of the start node of the edge.
   * 
   * This parameter is required.
   * 
   * @example
   * 44***
   */
  nodeFrom?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      nodeEnd: 'NodeEnd',
      nodeFrom: 'NodeFrom',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      nodeEnd: 'number',
      nodeFrom: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTaskFlowRelationsRequestEdges extends $tea.Model {
  /**
   * @remarks
   * The ID of the task flow edge.
   * 
   * @example
   * 24***
   */
  id?: number;
  /**
   * @remarks
   * The ID of the end node on the edge.
   * 
   * @example
   * 44***
   */
  nodeEnd?: number;
  /**
   * @remarks
   * The ID of the start node on the edge.
   * 
   * @example
   * 44***
   */
  nodeFrom?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      nodeEnd: 'NodeEnd',
      nodeFrom: 'NodeFrom',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      nodeEnd: 'number',
      nodeFrom: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends OpenApi {

  constructor(config: $OpenApi.Config) {
    super(config);
    this._endpointRule = "central";
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("dms-enterprise", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!Util.empty(endpoint)) {
      return endpoint;
    }

    if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  /**
   * Adds a masking rule.
   * 
   * @param request - AddDesensitizationRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddDesensitizationRuleResponse
   */
  async addDesensitizationRuleWithOptions(request: AddDesensitizationRuleRequest, runtime: $Util.RuntimeOptions): Promise<AddDesensitizationRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.functionType)) {
      query["FunctionType"] = request.functionType;
    }

    if (!Util.isUnset(request.ruleDescription)) {
      query["RuleDescription"] = request.ruleDescription;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.ruleType)) {
      query["RuleType"] = request.ruleType;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let body : {[key: string ]: any} = { };
    let bodyFlat : {[key: string ]: any} = { };
    if (!Util.isUnset(request.functionParams)) {
      bodyFlat["FunctionParams"] = request.functionParams;
    }

    body = {
      ...body,
      ...OpenApiUtil.query(bodyFlat),
    };
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "AddDesensitizationRule",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddDesensitizationRuleResponse>(await this.callApi(params, req, runtime), new AddDesensitizationRuleResponse({}));
  }

  /**
   * Adds a masking rule.
   * 
   * @param request - AddDesensitizationRuleRequest
   * @returns AddDesensitizationRuleResponse
   */
  async addDesensitizationRule(request: AddDesensitizationRuleRequest): Promise<AddDesensitizationRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addDesensitizationRuleWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - AddInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddInstanceResponse
   */
  async addInstanceWithOptions(request: AddInstanceRequest, runtime: $Util.RuntimeOptions): Promise<AddInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dataLinkName)) {
      query["DataLinkName"] = request.dataLinkName;
    }

    if (!Util.isUnset(request.databasePassword)) {
      query["DatabasePassword"] = request.databasePassword;
    }

    if (!Util.isUnset(request.databaseUser)) {
      query["DatabaseUser"] = request.databaseUser;
    }

    if (!Util.isUnset(request.dbaId)) {
      query["DbaId"] = request.dbaId;
    }

    if (!Util.isUnset(request.ddlOnline)) {
      query["DdlOnline"] = request.ddlOnline;
    }

    if (!Util.isUnset(request.ecsInstanceId)) {
      query["EcsInstanceId"] = request.ecsInstanceId;
    }

    if (!Util.isUnset(request.ecsRegion)) {
      query["EcsRegion"] = request.ecsRegion;
    }

    if (!Util.isUnset(request.enableSellCommon)) {
      query["EnableSellCommon"] = request.enableSellCommon;
    }

    if (!Util.isUnset(request.enableSellSitd)) {
      query["EnableSellSitd"] = request.enableSellSitd;
    }

    if (!Util.isUnset(request.enableSellStable)) {
      query["EnableSellStable"] = request.enableSellStable;
    }

    if (!Util.isUnset(request.enableSellTrust)) {
      query["EnableSellTrust"] = request.enableSellTrust;
    }

    if (!Util.isUnset(request.envType)) {
      query["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.exportTimeout)) {
      query["ExportTimeout"] = request.exportTimeout;
    }

    if (!Util.isUnset(request.host)) {
      query["Host"] = request.host;
    }

    if (!Util.isUnset(request.instanceAlias)) {
      query["InstanceAlias"] = request.instanceAlias;
    }

    if (!Util.isUnset(request.instanceSource)) {
      query["InstanceSource"] = request.instanceSource;
    }

    if (!Util.isUnset(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!Util.isUnset(request.networkType)) {
      query["NetworkType"] = request.networkType;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.queryTimeout)) {
      query["QueryTimeout"] = request.queryTimeout;
    }

    if (!Util.isUnset(request.safeRule)) {
      query["SafeRule"] = request.safeRule;
    }

    if (!Util.isUnset(request.sid)) {
      query["Sid"] = request.sid;
    }

    if (!Util.isUnset(request.skipTest)) {
      query["SkipTest"] = request.skipTest;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.templateType)) {
      query["TemplateType"] = request.templateType;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.useDsql)) {
      query["UseDsql"] = request.useDsql;
    }

    if (!Util.isUnset(request.useSsl)) {
      query["UseSsl"] = request.useSsl;
    }

    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddInstance",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddInstanceResponse>(await this.callApi(params, req, runtime), new AddInstanceResponse({}));
  }

  /**
   * 
   * 
   * @param request - AddInstanceRequest
   * @returns AddInstanceResponse
   */
  async addInstance(request: AddInstanceRequest): Promise<AddInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addInstanceWithOptions(request, runtime);
  }

  /**
   * Adds a workspace administrator, a workspace member, or a task flow developer in Data Management (DMS).
   * 
   * @remarks
   * You must call this operation as a DMS administrator, a database administrator (DBA), or a workspace administrator.
   * Usage notes:
   * *   Before you call this operation to add a user as a task flow developer, make sure that you have added the user as a workspace member.
   * *   You cannot call this operation to transfer the ownership of a task flow. To transfer the ownership of a task flow, call the [ChangLhDagOwner](https://help.aliyun.com/document_detail/424761.html) operation.
   * *   For more information about workspace roles and permissions, see [Manage permissions on a workspace](https://help.aliyun.com/document_detail/410893.html).
   * 
   * @param tmpReq - AddLhMembersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddLhMembersResponse
   */
  async addLhMembersWithOptions(tmpReq: AddLhMembersRequest, runtime: $Util.RuntimeOptions): Promise<AddLhMembersResponse> {
    Util.validateModel(tmpReq);
    let request = new AddLhMembersShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.members)) {
      request.membersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.members, "Members", "json");
    }

    let query = { };
    if (!Util.isUnset(request.membersShrink)) {
      query["Members"] = request.membersShrink;
    }

    if (!Util.isUnset(request.objectId)) {
      query["ObjectId"] = request.objectId;
    }

    if (!Util.isUnset(request.objectType)) {
      query["ObjectType"] = request.objectType;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddLhMembers",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddLhMembersResponse>(await this.callApi(params, req, runtime), new AddLhMembersResponse({}));
  }

  /**
   * Adds a workspace administrator, a workspace member, or a task flow developer in Data Management (DMS).
   * 
   * @remarks
   * You must call this operation as a DMS administrator, a database administrator (DBA), or a workspace administrator.
   * Usage notes:
   * *   Before you call this operation to add a user as a task flow developer, make sure that you have added the user as a workspace member.
   * *   You cannot call this operation to transfer the ownership of a task flow. To transfer the ownership of a task flow, call the [ChangLhDagOwner](https://help.aliyun.com/document_detail/424761.html) operation.
   * *   For more information about workspace roles and permissions, see [Manage permissions on a workspace](https://help.aliyun.com/document_detail/410893.html).
   * 
   * @param request - AddLhMembersRequest
   * @returns AddLhMembersResponse
   */
  async addLhMembers(request: AddLhMembersRequest): Promise<AddLhMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addLhMembersWithOptions(request, runtime);
  }

  /**
   * Adds a routing algorithm to a logical table.
   * 
   * @param request - AddLogicTableRouteConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddLogicTableRouteConfigResponse
   */
  async addLogicTableRouteConfigWithOptions(request: AddLogicTableRouteConfigRequest, runtime: $Util.RuntimeOptions): Promise<AddLogicTableRouteConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.routeExpr)) {
      query["RouteExpr"] = request.routeExpr;
    }

    if (!Util.isUnset(request.routeKey)) {
      query["RouteKey"] = request.routeKey;
    }

    if (!Util.isUnset(request.tableId)) {
      query["TableId"] = request.tableId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddLogicTableRouteConfig",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddLogicTableRouteConfigResponse>(await this.callApi(params, req, runtime), new AddLogicTableRouteConfigResponse({}));
  }

  /**
   * Adds a routing algorithm to a logical table.
   * 
   * @param request - AddLogicTableRouteConfigRequest
   * @returns AddLogicTableRouteConfigResponse
   */
  async addLogicTableRouteConfig(request: AddLogicTableRouteConfigRequest): Promise<AddLogicTableRouteConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addLogicTableRouteConfigWithOptions(request, runtime);
  }

  /**
   * Adds directed edges for an existing task node.
   * 
   * @remarks
   * When you add directed edges for a task node, take note of the following limits:
   * 1. The endpoints of the specified edge exist in the Directed Acyclic Graph (DAG) of the task flow specified by DagId.
   * 2. After a backward edge is added, the DAG does not contain loops.
   * 
   * @param tmpReq - AddTaskFlowEdgesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddTaskFlowEdgesResponse
   */
  async addTaskFlowEdgesWithOptions(tmpReq: AddTaskFlowEdgesRequest, runtime: $Util.RuntimeOptions): Promise<AddTaskFlowEdgesResponse> {
    Util.validateModel(tmpReq);
    let request = new AddTaskFlowEdgesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.edges)) {
      request.edgesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.edges, "Edges", "json");
    }

    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.edgesShrink)) {
      query["Edges"] = request.edgesShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddTaskFlowEdges",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddTaskFlowEdgesResponse>(await this.callApi(params, req, runtime), new AddTaskFlowEdgesResponse({}));
  }

  /**
   * Adds directed edges for an existing task node.
   * 
   * @remarks
   * When you add directed edges for a task node, take note of the following limits:
   * 1. The endpoints of the specified edge exist in the Directed Acyclic Graph (DAG) of the task flow specified by DagId.
   * 2. After a backward edge is added, the DAG does not contain loops.
   * 
   * @param request - AddTaskFlowEdgesRequest
   * @returns AddTaskFlowEdgesResponse
   */
  async addTaskFlowEdges(request: AddTaskFlowEdgesRequest): Promise<AddTaskFlowEdgesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addTaskFlowEdgesWithOptions(request, runtime);
  }

  /**
   * Analyzes the lineage (dependencies and influence) between tables and between fields in SQL statements.
   * 
   * @remarks
   * The following conditions must be met before you call this API operation.
   * *   The database instance is of one of the following types: ApsaraDB RDS for MySQL, PolarDB for MySQL, AnalyticDB for MySQL, ApsaraDB RDS for PostgreSQL, PolarDB for PostgreSQL, AnalyticDB for PostgreSQL, Oracle, and openGauss.
   * *   A database instance is managed in Security Collaboration mode. For more information about control modes, see [Control modes](https://help.aliyun.com/document_detail/151629.html).
   * 
   * @param request - AnalyzeSQLLineageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AnalyzeSQLLineageResponse
   */
  async analyzeSQLLineageWithOptions(request: AnalyzeSQLLineageRequest, runtime: $Util.RuntimeOptions): Promise<AnalyzeSQLLineageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.sqlContent)) {
      query["SqlContent"] = request.sqlContent;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AnalyzeSQLLineage",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AnalyzeSQLLineageResponse>(await this.callApi(params, req, runtime), new AnalyzeSQLLineageResponse({}));
  }

  /**
   * Analyzes the lineage (dependencies and influence) between tables and between fields in SQL statements.
   * 
   * @remarks
   * The following conditions must be met before you call this API operation.
   * *   The database instance is of one of the following types: ApsaraDB RDS for MySQL, PolarDB for MySQL, AnalyticDB for MySQL, ApsaraDB RDS for PostgreSQL, PolarDB for PostgreSQL, AnalyticDB for PostgreSQL, Oracle, and openGauss.
   * *   A database instance is managed in Security Collaboration mode. For more information about control modes, see [Control modes](https://help.aliyun.com/document_detail/151629.html).
   * 
   * @param request - AnalyzeSQLLineageRequest
   * @returns AnalyzeSQLLineageResponse
   */
  async analyzeSQLLineage(request: AnalyzeSQLLineageRequest): Promise<AnalyzeSQLLineageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.analyzeSQLLineageWithOptions(request, runtime);
  }

  /**
   * Reviews a ticket.
   * 
   * @param request - ApproveOrderRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ApproveOrderResponse
   */
  async approveOrderWithOptions(request: ApproveOrderRequest, runtime: $Util.RuntimeOptions): Promise<ApproveOrderResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.approvalNodeId)) {
      query["ApprovalNodeId"] = request.approvalNodeId;
    }

    if (!Util.isUnset(request.approvalNodePos)) {
      query["ApprovalNodePos"] = request.approvalNodePos;
    }

    if (!Util.isUnset(request.approvalType)) {
      query["ApprovalType"] = request.approvalType;
    }

    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.newApprover)) {
      query["NewApprover"] = request.newApprover;
    }

    if (!Util.isUnset(request.newApproverList)) {
      query["NewApproverList"] = request.newApproverList;
    }

    if (!Util.isUnset(request.oldApprover)) {
      query["OldApprover"] = request.oldApprover;
    }

    if (!Util.isUnset(request.realLoginUserUid)) {
      query["RealLoginUserUid"] = request.realLoginUserUid;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.workflowInstanceId)) {
      query["WorkflowInstanceId"] = request.workflowInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ApproveOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ApproveOrderResponse>(await this.callApi(params, req, runtime), new ApproveOrderResponse({}));
  }

  /**
   * Reviews a ticket.
   * 
   * @param request - ApproveOrderRequest
   * @returns ApproveOrderResponse
   */
  async approveOrder(request: ApproveOrderRequest): Promise<ApproveOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.approveOrderWithOptions(request, runtime);
  }

  /**
   * Backfills data for task orchestration.
   * 
   * @remarks
   * During a data backfill, task flows are run in sequence based on their dates. You can specify whether task flows are run in chronological or reverse chronological order. After the data backfill is complete, you can specify a date or date range, and a node range to run task flows.
   * 
   * @param tmpReq - BackFillRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BackFillResponse
   */
  async backFillWithOptions(tmpReq: BackFillRequest, runtime: $Util.RuntimeOptions): Promise<BackFillResponse> {
    Util.validateModel(tmpReq);
    let request = new BackFillShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.filterNodeIds)) {
      request.filterNodeIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterNodeIds, "FilterNodeIds", "json");
    }

    if (!Util.isUnset(tmpReq.startNodeIds)) {
      request.startNodeIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.startNodeIds, "StartNodeIds", "json");
    }

    let query = { };
    if (!Util.isUnset(request.asc)) {
      query["Asc"] = request.asc;
    }

    if (!Util.isUnset(request.backFillDate)) {
      query["BackFillDate"] = request.backFillDate;
    }

    if (!Util.isUnset(request.backFillDateBegin)) {
      query["BackFillDateBegin"] = request.backFillDateBegin;
    }

    if (!Util.isUnset(request.backFillDateEnd)) {
      query["BackFillDateEnd"] = request.backFillDateEnd;
    }

    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.filterNodeIdsShrink)) {
      query["FilterNodeIds"] = request.filterNodeIdsShrink;
    }

    if (!Util.isUnset(request.historyDagId)) {
      query["HistoryDagId"] = request.historyDagId;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.isTriggerSubTree)) {
      query["IsTriggerSubTree"] = request.isTriggerSubTree;
    }

    if (!Util.isUnset(request.startNodeIdsShrink)) {
      query["StartNodeIds"] = request.startNodeIdsShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BackFill",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BackFillResponse>(await this.callApi(params, req, runtime), new BackFillResponse({}));
  }

  /**
   * Backfills data for task orchestration.
   * 
   * @remarks
   * During a data backfill, task flows are run in sequence based on their dates. You can specify whether task flows are run in chronological or reverse chronological order. After the data backfill is complete, you can specify a date or date range, and a node range to run task flows.
   * 
   * @param request - BackFillRequest
   * @returns BackFillResponse
   */
  async backFill(request: BackFillRequest): Promise<BackFillResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.backFillWithOptions(request, runtime);
  }

  /**
   * Purchases a pay-as-you-go Data Management (DMS) resource.
   * 
   * @param request - BuyPayAsYouGoOrderRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BuyPayAsYouGoOrderResponse
   */
  async buyPayAsYouGoOrderWithOptions(request: BuyPayAsYouGoOrderRequest, runtime: $Util.RuntimeOptions): Promise<BuyPayAsYouGoOrderResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.commodityType)) {
      query["CommodityType"] = request.commodityType;
    }

    if (!Util.isUnset(request.insNum)) {
      query["InsNum"] = request.insNum;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.versionType)) {
      query["VersionType"] = request.versionType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BuyPayAsYouGoOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BuyPayAsYouGoOrderResponse>(await this.callApi(params, req, runtime), new BuyPayAsYouGoOrderResponse({}));
  }

  /**
   * Purchases a pay-as-you-go Data Management (DMS) resource.
   * 
   * @param request - BuyPayAsYouGoOrderRequest
   * @returns BuyPayAsYouGoOrderResponse
   */
  async buyPayAsYouGoOrder(request: BuyPayAsYouGoOrderRequest): Promise<BuyPayAsYouGoOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.buyPayAsYouGoOrderWithOptions(request, runtime);
  }

  /**
   * Adjusts the sensitivity level of one or more fields.
   * 
   * @param request - ChangeColumnSecLevelRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ChangeColumnSecLevelResponse
   */
  async changeColumnSecLevelWithOptions(request: ChangeColumnSecLevelRequest, runtime: $Util.RuntimeOptions): Promise<ChangeColumnSecLevelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.columnName)) {
      query["ColumnName"] = request.columnName;
    }

    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.isLogic)) {
      query["IsLogic"] = request.isLogic;
    }

    if (!Util.isUnset(request.newLevel)) {
      query["NewLevel"] = request.newLevel;
    }

    if (!Util.isUnset(request.schemaName)) {
      query["SchemaName"] = request.schemaName;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ChangeColumnSecLevel",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ChangeColumnSecLevelResponse>(await this.callApi(params, req, runtime), new ChangeColumnSecLevelResponse({}));
  }

  /**
   * Adjusts the sensitivity level of one or more fields.
   * 
   * @param request - ChangeColumnSecLevelRequest
   * @returns ChangeColumnSecLevelResponse
   */
  async changeColumnSecLevel(request: ChangeColumnSecLevelRequest): Promise<ChangeColumnSecLevelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.changeColumnSecLevelWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - ChangeColumnSecurityLevelRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ChangeColumnSecurityLevelResponse
   */
  async changeColumnSecurityLevelWithOptions(request: ChangeColumnSecurityLevelRequest, runtime: $Util.RuntimeOptions): Promise<ChangeColumnSecurityLevelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.columnName)) {
      query["ColumnName"] = request.columnName;
    }

    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.isLogic)) {
      query["IsLogic"] = request.isLogic;
    }

    if (!Util.isUnset(request.newSensitivityLevel)) {
      query["NewSensitivityLevel"] = request.newSensitivityLevel;
    }

    if (!Util.isUnset(request.schemaName)) {
      query["SchemaName"] = request.schemaName;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ChangeColumnSecurityLevel",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ChangeColumnSecurityLevelResponse>(await this.callApi(params, req, runtime), new ChangeColumnSecurityLevelResponse({}));
  }

  /**
   * 
   * 
   * @param request - ChangeColumnSecurityLevelRequest
   * @returns ChangeColumnSecurityLevelResponse
   */
  async changeColumnSecurityLevel(request: ChangeColumnSecurityLevelRequest): Promise<ChangeColumnSecurityLevelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.changeColumnSecurityLevelWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @remarks
   * Usage notes:
   * *   If you call this operation to transfer the ownership of a published task flow, the ownership transfer does not take effect.
   * *   You can call the [ReDeployLhDagVersion](https://help.aliyun.com/document_detail/424712.html) operation to redeploy a published version of a task flow.
   * 
   * @param request - ChangeLhDagOwnerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ChangeLhDagOwnerResponse
   */
  async changeLhDagOwnerWithOptions(request: ChangeLhDagOwnerRequest, runtime: $Util.RuntimeOptions): Promise<ChangeLhDagOwnerResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.ownerUserId)) {
      query["OwnerUserId"] = request.ownerUserId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ChangeLhDagOwner",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ChangeLhDagOwnerResponse>(await this.callApi(params, req, runtime), new ChangeLhDagOwnerResponse({}));
  }

  /**
   * 
   * 
   * @remarks
   * Usage notes:
   * *   If you call this operation to transfer the ownership of a published task flow, the ownership transfer does not take effect.
   * *   You can call the [ReDeployLhDagVersion](https://help.aliyun.com/document_detail/424712.html) operation to redeploy a published version of a task flow.
   * 
   * @param request - ChangeLhDagOwnerRequest
   * @returns ChangeLhDagOwnerResponse
   */
  async changeLhDagOwner(request: ChangeLhDagOwnerRequest): Promise<ChangeLhDagOwnerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.changeLhDagOwnerWithOptions(request, runtime);
  }

  /**
   * Closes a ticket.
   * 
   * @param request - CloseOrderRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CloseOrderResponse
   */
  async closeOrderWithOptions(request: CloseOrderRequest, runtime: $Util.RuntimeOptions): Promise<CloseOrderResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.closeReason)) {
      query["CloseReason"] = request.closeReason;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CloseOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CloseOrderResponse>(await this.callApi(params, req, runtime), new CloseOrderResponse({}));
  }

  /**
   * Closes a ticket.
   * 
   * @param request - CloseOrderRequest
   * @returns CloseOrderResponse
   */
  async closeOrder(request: CloseOrderRequest): Promise<CloseOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.closeOrderWithOptions(request, runtime);
  }

  /**
   * Creates a permission template
   * 
   * @remarks
   * You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
   * 
   * @param request - CreateAuthorityTemplateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateAuthorityTemplateResponse
   */
  async createAuthorityTemplateWithOptions(request: CreateAuthorityTemplateRequest, runtime: $Util.RuntimeOptions): Promise<CreateAuthorityTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateAuthorityTemplate",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateAuthorityTemplateResponse>(await this.callApi(params, req, runtime), new CreateAuthorityTemplateResponse({}));
  }

  /**
   * Creates a permission template
   * 
   * @remarks
   * You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
   * 
   * @param request - CreateAuthorityTemplateRequest
   * @returns CreateAuthorityTemplateResponse
   */
  async createAuthorityTemplate(request: CreateAuthorityTemplateRequest): Promise<CreateAuthorityTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createAuthorityTemplateWithOptions(request, runtime);
  }

  /**
   * Creates a data archiving ticket to archive data to destinations such as dedicated storage space or ApsaraDB RDS for MySQL instances.
   * 
   * @remarks
   * You can call this API operation only for database instances that are managed in Security Collaboration mode.
   * 
   * @param tmpReq - CreateDataArchiveOrderRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDataArchiveOrderResponse
   */
  async createDataArchiveOrderWithOptions(tmpReq: CreateDataArchiveOrderRequest, runtime: $Util.RuntimeOptions): Promise<CreateDataArchiveOrderResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateDataArchiveOrderShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.param)) {
      request.paramShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.param, "Param", "json");
    }

    if (!Util.isUnset(tmpReq.relatedUserList)) {
      request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, "RelatedUserList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.paramShrink)) {
      query["Param"] = request.paramShrink;
    }

    if (!Util.isUnset(request.parentId)) {
      query["ParentId"] = request.parentId;
    }

    if (!Util.isUnset(request.pluginType)) {
      query["PluginType"] = request.pluginType;
    }

    if (!Util.isUnset(request.relatedUserListShrink)) {
      query["RelatedUserList"] = request.relatedUserListShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDataArchiveOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDataArchiveOrderResponse>(await this.callApi(params, req, runtime), new CreateDataArchiveOrderResponse({}));
  }

  /**
   * Creates a data archiving ticket to archive data to destinations such as dedicated storage space or ApsaraDB RDS for MySQL instances.
   * 
   * @remarks
   * You can call this API operation only for database instances that are managed in Security Collaboration mode.
   * 
   * @param request - CreateDataArchiveOrderRequest
   * @returns CreateDataArchiveOrderResponse
   */
  async createDataArchiveOrder(request: CreateDataArchiveOrderRequest): Promise<CreateDataArchiveOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDataArchiveOrderWithOptions(request, runtime);
  }

  /**
   * Creates a ticket for changing data in Data Management (DMS).
   * 
   * @remarks
   * For more information about the Normal Data Modify feature, see [Change regular data](https://help.aliyun.com/document_detail/58419.html).
   * 
   * @param tmpReq - CreateDataCorrectOrderRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDataCorrectOrderResponse
   */
  async createDataCorrectOrderWithOptions(tmpReq: CreateDataCorrectOrderRequest, runtime: $Util.RuntimeOptions): Promise<CreateDataCorrectOrderResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateDataCorrectOrderShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.param)) {
      request.paramShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.param, "Param", "json");
    }

    if (!Util.isUnset(tmpReq.relatedUserList)) {
      request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, "RelatedUserList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.attachmentKey)) {
      query["AttachmentKey"] = request.attachmentKey;
    }

    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.paramShrink)) {
      query["Param"] = request.paramShrink;
    }

    if (!Util.isUnset(request.realLoginUserUid)) {
      query["RealLoginUserUid"] = request.realLoginUserUid;
    }

    if (!Util.isUnset(request.relatedUserListShrink)) {
      query["RelatedUserList"] = request.relatedUserListShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDataCorrectOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDataCorrectOrderResponse>(await this.callApi(params, req, runtime), new CreateDataCorrectOrderResponse({}));
  }

  /**
   * Creates a ticket for changing data in Data Management (DMS).
   * 
   * @remarks
   * For more information about the Normal Data Modify feature, see [Change regular data](https://help.aliyun.com/document_detail/58419.html).
   * 
   * @param request - CreateDataCorrectOrderRequest
   * @returns CreateDataCorrectOrderResponse
   */
  async createDataCorrectOrder(request: CreateDataCorrectOrderRequest): Promise<CreateDataCorrectOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDataCorrectOrderWithOptions(request, runtime);
  }

  /**
   * Creates a ticket for clearing historical data.
   * 
   * @remarks
   * For more information about the historical data cleaning, see [Clear historical data](https://help.aliyun.com/document_detail/162507.html).
   * This operation can be used only for MySQL databases.
   * 
   * @param tmpReq - CreateDataCronClearOrderRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDataCronClearOrderResponse
   */
  async createDataCronClearOrderWithOptions(tmpReq: CreateDataCronClearOrderRequest, runtime: $Util.RuntimeOptions): Promise<CreateDataCronClearOrderResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateDataCronClearOrderShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.param)) {
      request.paramShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.param, "Param", "json");
    }

    if (!Util.isUnset(tmpReq.relatedUserList)) {
      request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, "RelatedUserList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.attachmentKey)) {
      query["AttachmentKey"] = request.attachmentKey;
    }

    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.paramShrink)) {
      query["Param"] = request.paramShrink;
    }

    if (!Util.isUnset(request.relatedUserListShrink)) {
      query["RelatedUserList"] = request.relatedUserListShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDataCronClearOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDataCronClearOrderResponse>(await this.callApi(params, req, runtime), new CreateDataCronClearOrderResponse({}));
  }

  /**
   * Creates a ticket for clearing historical data.
   * 
   * @remarks
   * For more information about the historical data cleaning, see [Clear historical data](https://help.aliyun.com/document_detail/162507.html).
   * This operation can be used only for MySQL databases.
   * 
   * @param request - CreateDataCronClearOrderRequest
   * @returns CreateDataCronClearOrderResponse
   */
  async createDataCronClearOrder(request: CreateDataCronClearOrderRequest): Promise<CreateDataCronClearOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDataCronClearOrderWithOptions(request, runtime);
  }

  /**
   * Creates a ticket to export an SQL result set.
   * 
   * @param tmpReq - CreateDataExportOrderRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDataExportOrderResponse
   */
  async createDataExportOrderWithOptions(tmpReq: CreateDataExportOrderRequest, runtime: $Util.RuntimeOptions): Promise<CreateDataExportOrderResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateDataExportOrderShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.pluginParam)) {
      request.pluginParamShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.pluginParam, "PluginParam", "json");
    }

    if (!Util.isUnset(tmpReq.relatedUserList)) {
      request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, "RelatedUserList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.attachmentKey)) {
      query["AttachmentKey"] = request.attachmentKey;
    }

    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.parentId)) {
      query["ParentId"] = request.parentId;
    }

    if (!Util.isUnset(request.pluginParamShrink)) {
      query["PluginParam"] = request.pluginParamShrink;
    }

    if (!Util.isUnset(request.realLoginUserUid)) {
      query["RealLoginUserUid"] = request.realLoginUserUid;
    }

    if (!Util.isUnset(request.relatedUserListShrink)) {
      query["RelatedUserList"] = request.relatedUserListShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDataExportOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDataExportOrderResponse>(await this.callApi(params, req, runtime), new CreateDataExportOrderResponse({}));
  }

  /**
   * Creates a ticket to export an SQL result set.
   * 
   * @param request - CreateDataExportOrderRequest
   * @returns CreateDataExportOrderResponse
   */
  async createDataExportOrder(request: CreateDataExportOrderRequest): Promise<CreateDataExportOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDataExportOrderWithOptions(request, runtime);
  }

  /**
   * Creates a ticket for importing data to Data Management (DMS).
   * 
   * @remarks
   * For more information about the Large Data Import feature, see [Import data](https://help.aliyun.com/document_detail/161439.html).
   * 
   * @param tmpReq - CreateDataImportOrderRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDataImportOrderResponse
   */
  async createDataImportOrderWithOptions(tmpReq: CreateDataImportOrderRequest, runtime: $Util.RuntimeOptions): Promise<CreateDataImportOrderResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateDataImportOrderShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.param)) {
      request.paramShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.param, "Param", "json");
    }

    if (!Util.isUnset(tmpReq.relatedUserList)) {
      request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, "RelatedUserList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.attachmentKey)) {
      query["AttachmentKey"] = request.attachmentKey;
    }

    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.paramShrink)) {
      query["Param"] = request.paramShrink;
    }

    if (!Util.isUnset(request.relatedUserListShrink)) {
      query["RelatedUserList"] = request.relatedUserListShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDataImportOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDataImportOrderResponse>(await this.callApi(params, req, runtime), new CreateDataImportOrderResponse({}));
  }

  /**
   * Creates a ticket for importing data to Data Management (DMS).
   * 
   * @remarks
   * For more information about the Large Data Import feature, see [Import data](https://help.aliyun.com/document_detail/161439.html).
   * 
   * @param request - CreateDataImportOrderRequest
   * @returns CreateDataImportOrderResponse
   */
  async createDataImportOrder(request: CreateDataImportOrderRequest): Promise<CreateDataImportOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDataImportOrderWithOptions(request, runtime);
  }

  /**
   * Creates a data tracking ticket.
   * 
   * @remarks
   * This operation is available only for instances that are managed in Security Collaboration mode.
   * 
   * @param tmpReq - CreateDataTrackOrderRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDataTrackOrderResponse
   */
  async createDataTrackOrderWithOptions(tmpReq: CreateDataTrackOrderRequest, runtime: $Util.RuntimeOptions): Promise<CreateDataTrackOrderResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateDataTrackOrderShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.param)) {
      request.paramShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.param, "Param", "json");
    }

    if (!Util.isUnset(tmpReq.relatedUserList)) {
      request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, "RelatedUserList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.paramShrink)) {
      query["Param"] = request.paramShrink;
    }

    if (!Util.isUnset(request.relatedUserListShrink)) {
      query["RelatedUserList"] = request.relatedUserListShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDataTrackOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDataTrackOrderResponse>(await this.callApi(params, req, runtime), new CreateDataTrackOrderResponse({}));
  }

  /**
   * Creates a data tracking ticket.
   * 
   * @remarks
   * This operation is available only for instances that are managed in Security Collaboration mode.
   * 
   * @param request - CreateDataTrackOrderRequest
   * @returns CreateDataTrackOrderResponse
   */
  async createDataTrackOrder(request: CreateDataTrackOrderRequest): Promise<CreateDataTrackOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDataTrackOrderWithOptions(request, runtime);
  }

  /**
   * Creates a database export ticket.
   * 
   * @param tmpReq - CreateDatabaseExportOrderRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDatabaseExportOrderResponse
   */
  async createDatabaseExportOrderWithOptions(tmpReq: CreateDatabaseExportOrderRequest, runtime: $Util.RuntimeOptions): Promise<CreateDatabaseExportOrderResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateDatabaseExportOrderShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.pluginParam)) {
      request.pluginParamShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.pluginParam, "PluginParam", "json");
    }

    if (!Util.isUnset(tmpReq.relatedUserList)) {
      request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, "RelatedUserList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.attachmentKey)) {
      query["AttachmentKey"] = request.attachmentKey;
    }

    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.parentId)) {
      query["ParentId"] = request.parentId;
    }

    if (!Util.isUnset(request.pluginParamShrink)) {
      query["PluginParam"] = request.pluginParamShrink;
    }

    if (!Util.isUnset(request.relatedUserListShrink)) {
      query["RelatedUserList"] = request.relatedUserListShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDatabaseExportOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDatabaseExportOrderResponse>(await this.callApi(params, req, runtime), new CreateDatabaseExportOrderResponse({}));
  }

  /**
   * Creates a database export ticket.
   * 
   * @param request - CreateDatabaseExportOrderRequest
   * @returns CreateDatabaseExportOrderResponse
   */
  async createDatabaseExportOrder(request: CreateDatabaseExportOrderRequest): Promise<CreateDatabaseExportOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDatabaseExportOrderWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @remarks
   * For more information about the lock-free change feature, see [Overview](https://help.aliyun.com/document_detail/207847.html).
   * This operation can be used only for instances that are managed in Stable Change or Security Collaboration mode. For more information, see [Change data without the need to lock tables](https://help.aliyun.com/document_detail/96145.html) and [Change schemas without locking tables](https://help.aliyun.com/document_detail/98373.html).
   * 
   * @param tmpReq - CreateFreeLockCorrectOrderRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateFreeLockCorrectOrderResponse
   */
  async createFreeLockCorrectOrderWithOptions(tmpReq: CreateFreeLockCorrectOrderRequest, runtime: $Util.RuntimeOptions): Promise<CreateFreeLockCorrectOrderResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateFreeLockCorrectOrderShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.param)) {
      request.paramShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.param, "Param", "json");
    }

    if (!Util.isUnset(tmpReq.relatedUserList)) {
      request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, "RelatedUserList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.attachmentKey)) {
      query["AttachmentKey"] = request.attachmentKey;
    }

    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.paramShrink)) {
      query["Param"] = request.paramShrink;
    }

    if (!Util.isUnset(request.relatedUserListShrink)) {
      query["RelatedUserList"] = request.relatedUserListShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateFreeLockCorrectOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateFreeLockCorrectOrderResponse>(await this.callApi(params, req, runtime), new CreateFreeLockCorrectOrderResponse({}));
  }

  /**
   * 
   * 
   * @remarks
   * For more information about the lock-free change feature, see [Overview](https://help.aliyun.com/document_detail/207847.html).
   * This operation can be used only for instances that are managed in Stable Change or Security Collaboration mode. For more information, see [Change data without the need to lock tables](https://help.aliyun.com/document_detail/96145.html) and [Change schemas without locking tables](https://help.aliyun.com/document_detail/98373.html).
   * 
   * @param request - CreateFreeLockCorrectOrderRequest
   * @returns CreateFreeLockCorrectOrderResponse
   */
  async createFreeLockCorrectOrder(request: CreateFreeLockCorrectOrderRequest): Promise<CreateFreeLockCorrectOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createFreeLockCorrectOrderWithOptions(request, runtime);
  }

  /**
   * Creates a workspace for data warehouse development in Data Management (DMS).
   * 
   * @remarks
   *   The workspace name must be unique within a tenant. If a workspace with the same name already exists within the tenant, the call may fail.
   * *   You can call the [GetLhSpaceByName](https://help.aliyun.com/document_detail/424379.html) operation to query whether a workspace with a specific name already exists as a DMS administrator or database administrator (DBA).
   * 
   * @param request - CreateLakeHouseSpaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateLakeHouseSpaceResponse
   */
  async createLakeHouseSpaceWithOptions(request: CreateLakeHouseSpaceRequest, runtime: $Util.RuntimeOptions): Promise<CreateLakeHouseSpaceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.devDbId)) {
      query["DevDbId"] = request.devDbId;
    }

    if (!Util.isUnset(request.dwDbType)) {
      query["DwDbType"] = request.dwDbType;
    }

    if (!Util.isUnset(request.mode)) {
      query["Mode"] = request.mode;
    }

    if (!Util.isUnset(request.prodDbId)) {
      query["ProdDbId"] = request.prodDbId;
    }

    if (!Util.isUnset(request.spaceConfig)) {
      query["SpaceConfig"] = request.spaceConfig;
    }

    if (!Util.isUnset(request.spaceName)) {
      query["SpaceName"] = request.spaceName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateLakeHouseSpace",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateLakeHouseSpaceResponse>(await this.callApi(params, req, runtime), new CreateLakeHouseSpaceResponse({}));
  }

  /**
   * Creates a workspace for data warehouse development in Data Management (DMS).
   * 
   * @remarks
   *   The workspace name must be unique within a tenant. If a workspace with the same name already exists within the tenant, the call may fail.
   * *   You can call the [GetLhSpaceByName](https://help.aliyun.com/document_detail/424379.html) operation to query whether a workspace with a specific name already exists as a DMS administrator or database administrator (DBA).
   * 
   * @param request - CreateLakeHouseSpaceRequest
   * @returns CreateLakeHouseSpaceResponse
   */
  async createLakeHouseSpace(request: CreateLakeHouseSpaceRequest): Promise<CreateLakeHouseSpaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createLakeHouseSpaceWithOptions(request, runtime);
  }

  /**
   * Creates a logical database in Database Management (DMS).
   * 
   * @param tmpReq - CreateLogicDatabaseRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateLogicDatabaseResponse
   */
  async createLogicDatabaseWithOptions(tmpReq: CreateLogicDatabaseRequest, runtime: $Util.RuntimeOptions): Promise<CreateLogicDatabaseResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateLogicDatabaseShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.databaseIds)) {
      request.databaseIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.databaseIds, "DatabaseIds", "json");
    }

    let query = { };
    if (!Util.isUnset(request.alias)) {
      query["Alias"] = request.alias;
    }

    if (!Util.isUnset(request.databaseIdsShrink)) {
      query["DatabaseIds"] = request.databaseIdsShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateLogicDatabase",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateLogicDatabaseResponse>(await this.callApi(params, req, runtime), new CreateLogicDatabaseResponse({}));
  }

  /**
   * Creates a logical database in Database Management (DMS).
   * 
   * @param request - CreateLogicDatabaseRequest
   * @returns CreateLogicDatabaseResponse
   */
  async createLogicDatabase(request: CreateLogicDatabaseRequest): Promise<CreateLogicDatabaseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createLogicDatabaseWithOptions(request, runtime);
  }

  /**
   * Creates a ticket in Data Management (DMS).
   * 
   * @remarks
   * To facilitate ticket creation, you can call the following dedicated operations to create some types of tickets:
   * *   [CreateDataCorrectOrder](https://help.aliyun.com/document_detail/208388.html): creates a regular data change ticket.
   * *   [CreateDataCronClearOrder](https://help.aliyun.com/document_detail/208385.html): creates a ticket to clear historical data.
   * *   [CreateDataImportOrder](https://help.aliyun.com/document_detail/208387.html): creates a data import ticket.
   * *   [CreateFreeLockCorrectOrder](https://help.aliyun.com/document_detail/208386.html): creates a lock-free change ticket.
   * 
   * @param tmpReq - CreateOrderRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateOrderResponse
   */
  async createOrderWithOptions(tmpReq: CreateOrderRequest, runtime: $Util.RuntimeOptions): Promise<CreateOrderResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateOrderShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.pluginParam)) {
      request.pluginParamShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.pluginParam, "PluginParam", "json");
    }

    let query = { };
    if (!Util.isUnset(request.attachmentKey)) {
      query["AttachmentKey"] = request.attachmentKey;
    }

    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.pluginType)) {
      query["PluginType"] = request.pluginType;
    }

    if (!Util.isUnset(request.relatedUserList)) {
      query["RelatedUserList"] = request.relatedUserList;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.pluginParamShrink)) {
      body["PluginParam"] = request.pluginParamShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOrderResponse>(await this.callApi(params, req, runtime), new CreateOrderResponse({}));
  }

  /**
   * Creates a ticket in Data Management (DMS).
   * 
   * @remarks
   * To facilitate ticket creation, you can call the following dedicated operations to create some types of tickets:
   * *   [CreateDataCorrectOrder](https://help.aliyun.com/document_detail/208388.html): creates a regular data change ticket.
   * *   [CreateDataCronClearOrder](https://help.aliyun.com/document_detail/208385.html): creates a ticket to clear historical data.
   * *   [CreateDataImportOrder](https://help.aliyun.com/document_detail/208387.html): creates a data import ticket.
   * *   [CreateFreeLockCorrectOrder](https://help.aliyun.com/document_detail/208386.html): creates a lock-free change ticket.
   * 
   * @param request - CreateOrderRequest
   * @returns CreateOrderResponse
   */
  async createOrder(request: CreateOrderRequest): Promise<CreateOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOrderWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param tmpReq - CreateProcCorrectOrderRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateProcCorrectOrderResponse
   */
  async createProcCorrectOrderWithOptions(tmpReq: CreateProcCorrectOrderRequest, runtime: $Util.RuntimeOptions): Promise<CreateProcCorrectOrderResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateProcCorrectOrderShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.param)) {
      request.paramShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.param, "Param", "json");
    }

    if (!Util.isUnset(tmpReq.relatedUserList)) {
      request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, "RelatedUserList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.attachmentKey)) {
      query["AttachmentKey"] = request.attachmentKey;
    }

    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.paramShrink)) {
      query["Param"] = request.paramShrink;
    }

    if (!Util.isUnset(request.relatedUserListShrink)) {
      query["RelatedUserList"] = request.relatedUserListShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateProcCorrectOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateProcCorrectOrderResponse>(await this.callApi(params, req, runtime), new CreateProcCorrectOrderResponse({}));
  }

  /**
   * 
   * 
   * @param request - CreateProcCorrectOrderRequest
   * @returns CreateProcCorrectOrderResponse
   */
  async createProcCorrectOrder(request: CreateProcCorrectOrderRequest): Promise<CreateProcCorrectOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createProcCorrectOrderWithOptions(request, runtime);
  }

  /**
   * Enables the secure access proxy feature for a database instance.
   * 
   * @remarks
   * - The database instance runs the MySQL or MariaDB database engine. For example, the database instance can be an ApsaraDB RDS for MySQL instance, a PolarDB for MySQL cluster, a Distributed Relational Database Service (DRDS) cluster, or an AnalyticDB for MySQL cluster. The database instance can also be a self-managed MySQL or MariaDB database, or a MySQL or MariaDB database in a third-party cloud.
   * - The database instance resides in the China (Hangzhou) or China (Beijing) region.
   * - You are a Data Management (DMS) administrator, a database administrator (DBA), or the owner of the database instance.
   * 
   * @param request - CreateProxyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateProxyResponse
   */
  async createProxyWithOptions(request: CreateProxyRequest, runtime: $Util.RuntimeOptions): Promise<CreateProxyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.password)) {
      query["Password"] = request.password;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.username)) {
      query["Username"] = request.username;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateProxy",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateProxyResponse>(await this.callApi(params, req, runtime), new CreateProxyResponse({}));
  }

  /**
   * Enables the secure access proxy feature for a database instance.
   * 
   * @remarks
   * - The database instance runs the MySQL or MariaDB database engine. For example, the database instance can be an ApsaraDB RDS for MySQL instance, a PolarDB for MySQL cluster, a Distributed Relational Database Service (DRDS) cluster, or an AnalyticDB for MySQL cluster. The database instance can also be a self-managed MySQL or MariaDB database, or a MySQL or MariaDB database in a third-party cloud.
   * - The database instance resides in the China (Hangzhou) or China (Beijing) region.
   * - You are a Data Management (DMS) administrator, a database administrator (DBA), or the owner of the database instance.
   * 
   * @param request - CreateProxyRequest
   * @returns CreateProxyResponse
   */
  async createProxy(request: CreateProxyRequest): Promise<CreateProxyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createProxyWithOptions(request, runtime);
  }

  /**
   * You can call the CreateProxyAccess to authorize users to access the DB instance through the Data Security Protection agent.
   * 
   * @remarks
   * - The data security protection feature is enabled for the instance.
   * - Your user role is the administrator role, DBA role, or the owner of data security protection for the current instance.
   * 
   * @param request - CreateProxyAccessRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateProxyAccessResponse
   */
  async createProxyAccessWithOptions(request: CreateProxyAccessRequest, runtime: $Util.RuntimeOptions): Promise<CreateProxyAccessResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.indepAccount)) {
      query["IndepAccount"] = request.indepAccount;
    }

    if (!Util.isUnset(request.indepPassword)) {
      query["IndepPassword"] = request.indepPassword;
    }

    if (!Util.isUnset(request.proxyId)) {
      query["ProxyId"] = request.proxyId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.userId)) {
      query["UserId"] = request.userId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateProxyAccess",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateProxyAccessResponse>(await this.callApi(params, req, runtime), new CreateProxyAccessResponse({}));
  }

  /**
   * You can call the CreateProxyAccess to authorize users to access the DB instance through the Data Security Protection agent.
   * 
   * @remarks
   * - The data security protection feature is enabled for the instance.
   * - Your user role is the administrator role, DBA role, or the owner of data security protection for the current instance.
   * 
   * @param request - CreateProxyAccessRequest
   * @returns CreateProxyAccessResponse
   */
  async createProxyAccess(request: CreateProxyAccessRequest): Promise<CreateProxyAccessResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createProxyAccessWithOptions(request, runtime);
  }

  /**
   * Executes a schema design ticket.
   * 
   * @param request - CreatePublishGroupTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreatePublishGroupTaskResponse
   */
  async createPublishGroupTaskWithOptions(request: CreatePublishGroupTaskRequest, runtime: $Util.RuntimeOptions): Promise<CreatePublishGroupTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.logic)) {
      query["Logic"] = request.logic;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.planTime)) {
      query["PlanTime"] = request.planTime;
    }

    if (!Util.isUnset(request.publishStrategy)) {
      query["PublishStrategy"] = request.publishStrategy;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreatePublishGroupTask",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreatePublishGroupTaskResponse>(await this.callApi(params, req, runtime), new CreatePublishGroupTaskResponse({}));
  }

  /**
   * Executes a schema design ticket.
   * 
   * @param request - CreatePublishGroupTaskRequest
   * @returns CreatePublishGroupTaskResponse
   */
  async createPublishGroupTask(request: CreatePublishGroupTaskRequest): Promise<CreatePublishGroupTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createPublishGroupTaskWithOptions(request, runtime);
  }

  /**
   * Creates a SQL review ticket.
   * 
   * @remarks
   * You can call this operation only for database instances that are managed in Security Collaboration mode.
   * For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
   * 
   * @param tmpReq - CreateSQLReviewOrderRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateSQLReviewOrderResponse
   */
  async createSQLReviewOrderWithOptions(tmpReq: CreateSQLReviewOrderRequest, runtime: $Util.RuntimeOptions): Promise<CreateSQLReviewOrderResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateSQLReviewOrderShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.param)) {
      request.paramShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.param, "Param", "json");
    }

    if (!Util.isUnset(tmpReq.relatedUserList)) {
      request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, "RelatedUserList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.paramShrink)) {
      query["Param"] = request.paramShrink;
    }

    if (!Util.isUnset(request.relatedUserListShrink)) {
      query["RelatedUserList"] = request.relatedUserListShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateSQLReviewOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSQLReviewOrderResponse>(await this.callApi(params, req, runtime), new CreateSQLReviewOrderResponse({}));
  }

  /**
   * Creates a SQL review ticket.
   * 
   * @remarks
   * You can call this operation only for database instances that are managed in Security Collaboration mode.
   * For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
   * 
   * @param request - CreateSQLReviewOrderRequest
   * @returns CreateSQLReviewOrderResponse
   */
  async createSQLReviewOrder(request: CreateSQLReviewOrderRequest): Promise<CreateSQLReviewOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSQLReviewOrderWithOptions(request, runtime);
  }

  /**
   * Creates a business scenario to group task flows by business scenario.
   * 
   * @param request - CreateScenarioRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateScenarioResponse
   */
  async createScenarioWithOptions(request: CreateScenarioRequest, runtime: $Util.RuntimeOptions): Promise<CreateScenarioResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.scenarioName)) {
      query["ScenarioName"] = request.scenarioName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateScenario",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateScenarioResponse>(await this.callApi(params, req, runtime), new CreateScenarioResponse({}));
  }

  /**
   * Creates a business scenario to group task flows by business scenario.
   * 
   * @param request - CreateScenarioRequest
   * @returns CreateScenarioResponse
   */
  async createScenario(request: CreateScenarioRequest): Promise<CreateScenarioResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createScenarioWithOptions(request, runtime);
  }

  /**
   * Creates a security rule set.
   * 
   * @param request - CreateStandardGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateStandardGroupResponse
   */
  async createStandardGroupWithOptions(request: CreateStandardGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateStandardGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbType)) {
      query["DbType"] = request.dbType;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateStandardGroup",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateStandardGroupResponse>(await this.callApi(params, req, runtime), new CreateStandardGroupResponse({}));
  }

  /**
   * Creates a security rule set.
   * 
   * @param request - CreateStandardGroupRequest
   * @returns CreateStandardGroupResponse
   */
  async createStandardGroup(request: CreateStandardGroupRequest): Promise<CreateStandardGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createStandardGroupWithOptions(request, runtime);
  }

  /**
   * Creates a schema synchronization ticket.
   * 
   * @param tmpReq - CreateStructSyncOrderRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateStructSyncOrderResponse
   */
  async createStructSyncOrderWithOptions(tmpReq: CreateStructSyncOrderRequest, runtime: $Util.RuntimeOptions): Promise<CreateStructSyncOrderResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateStructSyncOrderShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.param)) {
      request.paramShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.param, "Param", "json");
    }

    if (!Util.isUnset(tmpReq.relatedUserList)) {
      request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, "RelatedUserList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.attachmentKey)) {
      query["AttachmentKey"] = request.attachmentKey;
    }

    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.paramShrink)) {
      query["Param"] = request.paramShrink;
    }

    if (!Util.isUnset(request.relatedUserListShrink)) {
      query["RelatedUserList"] = request.relatedUserListShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateStructSyncOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateStructSyncOrderResponse>(await this.callApi(params, req, runtime), new CreateStructSyncOrderResponse({}));
  }

  /**
   * Creates a schema synchronization ticket.
   * 
   * @param request - CreateStructSyncOrderRequest
   * @returns CreateStructSyncOrderResponse
   */
  async createStructSyncOrder(request: CreateStructSyncOrderRequest): Promise<CreateStructSyncOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createStructSyncOrderWithOptions(request, runtime);
  }

  /**
   * Creates a task node for a task flow.
   * 
   * @param request - CreateTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateTaskResponse
   */
  async createTaskWithOptions(request: CreateTaskRequest, runtime: $Util.RuntimeOptions): Promise<CreateTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.graphParam)) {
      query["GraphParam"] = request.graphParam;
    }

    if (!Util.isUnset(request.nodeContent)) {
      query["NodeContent"] = request.nodeContent;
    }

    if (!Util.isUnset(request.nodeName)) {
      query["NodeName"] = request.nodeName;
    }

    if (!Util.isUnset(request.nodeOutput)) {
      query["NodeOutput"] = request.nodeOutput;
    }

    if (!Util.isUnset(request.nodeType)) {
      query["NodeType"] = request.nodeType;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.timeVariables)) {
      query["TimeVariables"] = request.timeVariables;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateTask",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateTaskResponse>(await this.callApi(params, req, runtime), new CreateTaskResponse({}));
  }

  /**
   * Creates a task node for a task flow.
   * 
   * @param request - CreateTaskRequest
   * @returns CreateTaskResponse
   */
  async createTask(request: CreateTaskRequest): Promise<CreateTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createTaskWithOptions(request, runtime);
  }

  /**
   * Creates a task flow.
   * 
   * @param request - CreateTaskFlowRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateTaskFlowResponse
   */
  async createTaskFlowWithOptions(request: CreateTaskFlowRequest, runtime: $Util.RuntimeOptions): Promise<CreateTaskFlowResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagName)) {
      query["DagName"] = request.dagName;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.scenarioId)) {
      query["ScenarioId"] = request.scenarioId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateTaskFlow",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateTaskFlowResponse>(await this.callApi(params, req, runtime), new CreateTaskFlowResponse({}));
  }

  /**
   * Creates a task flow.
   * 
   * @param request - CreateTaskFlowRequest
   * @returns CreateTaskFlowResponse
   */
  async createTaskFlow(request: CreateTaskFlowRequest): Promise<CreateTaskFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createTaskFlowWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - CreateUploadFileJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateUploadFileJobResponse
   */
  async createUploadFileJobWithOptions(request: CreateUploadFileJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateUploadFileJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.fileName)) {
      query["FileName"] = request.fileName;
    }

    if (!Util.isUnset(request.fileSource)) {
      query["FileSource"] = request.fileSource;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.uploadURL)) {
      query["UploadURL"] = request.uploadURL;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateUploadFileJob",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateUploadFileJobResponse>(await this.callApi(params, req, runtime), new CreateUploadFileJobResponse({}));
  }

  /**
   * 
   * 
   * @param request - CreateUploadFileJobRequest
   * @returns CreateUploadFileJobResponse
   */
  async createUploadFileJob(request: CreateUploadFileJobRequest): Promise<CreateUploadFileJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createUploadFileJobWithOptions(request, runtime);
  }

  /**
   * Creates a task to upload an Object Storage Service (OSS) file and obtain the key of the task.
   * 
   * @param tmpReq - CreateUploadOSSFileJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateUploadOSSFileJobResponse
   */
  async createUploadOSSFileJobWithOptions(tmpReq: CreateUploadOSSFileJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateUploadOSSFileJobResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateUploadOSSFileJobShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.uploadTarget)) {
      request.uploadTargetShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.uploadTarget, "UploadTarget", "json");
    }

    let query = { };
    if (!Util.isUnset(request.fileName)) {
      query["FileName"] = request.fileName;
    }

    if (!Util.isUnset(request.fileSource)) {
      query["FileSource"] = request.fileSource;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.uploadTargetShrink)) {
      query["UploadTarget"] = request.uploadTargetShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateUploadOSSFileJob",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateUploadOSSFileJobResponse>(await this.callApi(params, req, runtime), new CreateUploadOSSFileJobResponse({}));
  }

  /**
   * Creates a task to upload an Object Storage Service (OSS) file and obtain the key of the task.
   * 
   * @param request - CreateUploadOSSFileJobRequest
   * @returns CreateUploadOSSFileJobResponse
   */
  async createUploadOSSFileJob(request: CreateUploadOSSFileJobRequest): Promise<CreateUploadOSSFileJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createUploadOSSFileJobWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - DeleteAuthorityTemplateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteAuthorityTemplateResponse
   */
  async deleteAuthorityTemplateWithOptions(request: DeleteAuthorityTemplateRequest, runtime: $Util.RuntimeOptions): Promise<DeleteAuthorityTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteAuthorityTemplate",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteAuthorityTemplateResponse>(await this.callApi(params, req, runtime), new DeleteAuthorityTemplateResponse({}));
  }

  /**
   * 
   * 
   * @param request - DeleteAuthorityTemplateRequest
   * @returns DeleteAuthorityTemplateResponse
   */
  async deleteAuthorityTemplate(request: DeleteAuthorityTemplateRequest): Promise<DeleteAuthorityTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteAuthorityTemplateWithOptions(request, runtime);
  }

  /**
   * Removes a database instance from Data Management (DMS).
   * 
   * @remarks
   * Note: You can call this operation only to remove a database instance from the instance list of DMS. The instance is not deleted or shut down.
   * 
   * @param request - DeleteInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteInstanceResponse
   */
  async deleteInstanceWithOptions(request: DeleteInstanceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.host)) {
      query["Host"] = request.host;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.sid)) {
      query["Sid"] = request.sid;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteInstance",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteInstanceResponse>(await this.callApi(params, req, runtime), new DeleteInstanceResponse({}));
  }

  /**
   * Removes a database instance from Data Management (DMS).
   * 
   * @remarks
   * Note: You can call this operation only to remove a database instance from the instance list of DMS. The instance is not deleted or shut down.
   * 
   * @param request - DeleteInstanceRequest
   * @returns DeleteInstanceResponse
   */
  async deleteInstance(request: DeleteInstanceRequest): Promise<DeleteInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteInstanceWithOptions(request, runtime);
  }

  /**
   * Deletes a workspace.
   * 
   * @param request - DeleteLakeHouseSpaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteLakeHouseSpaceResponse
   */
  async deleteLakeHouseSpaceWithOptions(request: DeleteLakeHouseSpaceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLakeHouseSpaceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.spaceId)) {
      query["SpaceId"] = request.spaceId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLakeHouseSpace",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLakeHouseSpaceResponse>(await this.callApi(params, req, runtime), new DeleteLakeHouseSpaceResponse({}));
  }

  /**
   * Deletes a workspace.
   * 
   * @param request - DeleteLakeHouseSpaceRequest
   * @returns DeleteLakeHouseSpaceResponse
   */
  async deleteLakeHouseSpace(request: DeleteLakeHouseSpaceRequest): Promise<DeleteLakeHouseSpaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLakeHouseSpaceWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @remarks
   * You must call this operation as a DMS administrator, a database administrator (DBA), or a workspace administrator.
   * You cannot call this operation to transfer the ownership of a task flow. To transfer the ownership of a task flow, call the [ChangLhDagOwner](https://help.aliyun.com/document_detail/424761.html) operation.
   * 
   * @param tmpReq - DeleteLhMembersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteLhMembersResponse
   */
  async deleteLhMembersWithOptions(tmpReq: DeleteLhMembersRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLhMembersResponse> {
    Util.validateModel(tmpReq);
    let request = new DeleteLhMembersShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.memberIds)) {
      request.memberIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.memberIds, "MemberIds", "json");
    }

    let query = { };
    if (!Util.isUnset(request.memberIdsShrink)) {
      query["MemberIds"] = request.memberIdsShrink;
    }

    if (!Util.isUnset(request.objectId)) {
      query["ObjectId"] = request.objectId;
    }

    if (!Util.isUnset(request.objectType)) {
      query["ObjectType"] = request.objectType;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLhMembers",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLhMembersResponse>(await this.callApi(params, req, runtime), new DeleteLhMembersResponse({}));
  }

  /**
   * 
   * 
   * @remarks
   * You must call this operation as a DMS administrator, a database administrator (DBA), or a workspace administrator.
   * You cannot call this operation to transfer the ownership of a task flow. To transfer the ownership of a task flow, call the [ChangLhDagOwner](https://help.aliyun.com/document_detail/424761.html) operation.
   * 
   * @param request - DeleteLhMembersRequest
   * @returns DeleteLhMembersResponse
   */
  async deleteLhMembers(request: DeleteLhMembersRequest): Promise<DeleteLhMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLhMembersWithOptions(request, runtime);
  }

  /**
   * Deletes a logical database in Database Management (DMS). This operation only deletes the specified logical database but does not delete physical databases.
   * 
   * @param request - DeleteLogicDatabaseRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteLogicDatabaseResponse
   */
  async deleteLogicDatabaseWithOptions(request: DeleteLogicDatabaseRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLogicDatabaseResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.logicDbId)) {
      query["LogicDbId"] = request.logicDbId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLogicDatabase",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLogicDatabaseResponse>(await this.callApi(params, req, runtime), new DeleteLogicDatabaseResponse({}));
  }

  /**
   * Deletes a logical database in Database Management (DMS). This operation only deletes the specified logical database but does not delete physical databases.
   * 
   * @param request - DeleteLogicDatabaseRequest
   * @returns DeleteLogicDatabaseResponse
   */
  async deleteLogicDatabase(request: DeleteLogicDatabaseRequest): Promise<DeleteLogicDatabaseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLogicDatabaseWithOptions(request, runtime);
  }

  /**
   * Deletes the routing algorithm of a logical table.
   * 
   * @param request - DeleteLogicTableRouteConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteLogicTableRouteConfigResponse
   */
  async deleteLogicTableRouteConfigWithOptions(request: DeleteLogicTableRouteConfigRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLogicTableRouteConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.routeKey)) {
      query["RouteKey"] = request.routeKey;
    }

    if (!Util.isUnset(request.tableId)) {
      query["TableId"] = request.tableId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLogicTableRouteConfig",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLogicTableRouteConfigResponse>(await this.callApi(params, req, runtime), new DeleteLogicTableRouteConfigResponse({}));
  }

  /**
   * Deletes the routing algorithm of a logical table.
   * 
   * @param request - DeleteLogicTableRouteConfigRequest
   * @returns DeleteLogicTableRouteConfigResponse
   */
  async deleteLogicTableRouteConfig(request: DeleteLogicTableRouteConfigRequest): Promise<DeleteLogicTableRouteConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLogicTableRouteConfigWithOptions(request, runtime);
  }

  /**
   * You can call this operation to disable the data security protection proxy of a DB instance.
   * 
   * @remarks
   * After you disable this feature, your DB instance loses the JDBC protocol. All authorization information is recycled.
   * 
   * @param request - DeleteProxyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteProxyResponse
   */
  async deleteProxyWithOptions(request: DeleteProxyRequest, runtime: $Util.RuntimeOptions): Promise<DeleteProxyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.proxyId)) {
      query["ProxyId"] = request.proxyId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteProxy",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteProxyResponse>(await this.callApi(params, req, runtime), new DeleteProxyResponse({}));
  }

  /**
   * You can call this operation to disable the data security protection proxy of a DB instance.
   * 
   * @remarks
   * After you disable this feature, your DB instance loses the JDBC protocol. All authorization information is recycled.
   * 
   * @param request - DeleteProxyRequest
   * @returns DeleteProxyResponse
   */
  async deleteProxy(request: DeleteProxyRequest): Promise<DeleteProxyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteProxyWithOptions(request, runtime);
  }

  /**
   * You can call this operation to DeleteProxyAccess reclaim the data security protection authorization of the target user.
   * 
   * @param request - DeleteProxyAccessRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteProxyAccessResponse
   */
  async deleteProxyAccessWithOptions(request: DeleteProxyAccessRequest, runtime: $Util.RuntimeOptions): Promise<DeleteProxyAccessResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.proxyAccessId)) {
      query["ProxyAccessId"] = request.proxyAccessId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteProxyAccess",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteProxyAccessResponse>(await this.callApi(params, req, runtime), new DeleteProxyAccessResponse({}));
  }

  /**
   * You can call this operation to DeleteProxyAccess reclaim the data security protection authorization of the target user.
   * 
   * @param request - DeleteProxyAccessRequest
   * @returns DeleteProxyAccessResponse
   */
  async deleteProxyAccess(request: DeleteProxyAccessRequest): Promise<DeleteProxyAccessResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteProxyAccessWithOptions(request, runtime);
  }

  /**
   * Deletes a business scenario.
   * 
   * @remarks
   * When you call this operation, make sure that no task flow is specified in the business scenario.
   * 
   * @param request - DeleteScenarioRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteScenarioResponse
   */
  async deleteScenarioWithOptions(request: DeleteScenarioRequest, runtime: $Util.RuntimeOptions): Promise<DeleteScenarioResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.scenarioId)) {
      query["ScenarioId"] = request.scenarioId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteScenario",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteScenarioResponse>(await this.callApi(params, req, runtime), new DeleteScenarioResponse({}));
  }

  /**
   * Deletes a business scenario.
   * 
   * @remarks
   * When you call this operation, make sure that no task flow is specified in the business scenario.
   * 
   * @param request - DeleteScenarioRequest
   * @returns DeleteScenarioResponse
   */
  async deleteScenario(request: DeleteScenarioRequest): Promise<DeleteScenarioResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteScenarioWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - DeleteStandardGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteStandardGroupResponse
   */
  async deleteStandardGroupWithOptions(request: DeleteStandardGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteStandardGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteStandardGroup",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteStandardGroupResponse>(await this.callApi(params, req, runtime), new DeleteStandardGroupResponse({}));
  }

  /**
   * 
   * 
   * @param request - DeleteStandardGroupRequest
   * @returns DeleteStandardGroupResponse
   */
  async deleteStandardGroup(request: DeleteStandardGroupRequest): Promise<DeleteStandardGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteStandardGroupWithOptions(request, runtime);
  }

  /**
   * Deletes a task in a specified task flow.
   * 
   * @param request - DeleteTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteTaskResponse
   */
  async deleteTaskWithOptions(request: DeleteTaskRequest, runtime: $Util.RuntimeOptions): Promise<DeleteTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.nodeId)) {
      query["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTask",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteTaskResponse>(await this.callApi(params, req, runtime), new DeleteTaskResponse({}));
  }

  /**
   * Deletes a task in a specified task flow.
   * 
   * @param request - DeleteTaskRequest
   * @returns DeleteTaskResponse
   */
  async deleteTask(request: DeleteTaskRequest): Promise<DeleteTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteTaskWithOptions(request, runtime);
  }

  /**
   * Deletes a task flow.
   * 
   * @param request - DeleteTaskFlowRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteTaskFlowResponse
   */
  async deleteTaskFlowWithOptions(request: DeleteTaskFlowRequest, runtime: $Util.RuntimeOptions): Promise<DeleteTaskFlowResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTaskFlow",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteTaskFlowResponse>(await this.callApi(params, req, runtime), new DeleteTaskFlowResponse({}));
  }

  /**
   * Deletes a task flow.
   * 
   * @param request - DeleteTaskFlowRequest
   * @returns DeleteTaskFlowResponse
   */
  async deleteTaskFlow(request: DeleteTaskFlowRequest): Promise<DeleteTaskFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteTaskFlowWithOptions(request, runtime);
  }

  /**
   * Deletes task flow edges based on multiple conditions.
   * 
   * @remarks
   * This operation is used for multi-condition query. You can call it to delete the edges of a specified task flow that meet all specified conditions.
   * 
   * @param request - DeleteTaskFlowEdgesByConditionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteTaskFlowEdgesByConditionResponse
   */
  async deleteTaskFlowEdgesByConditionWithOptions(request: DeleteTaskFlowEdgesByConditionRequest, runtime: $Util.RuntimeOptions): Promise<DeleteTaskFlowEdgesByConditionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.nodeEnd)) {
      query["NodeEnd"] = request.nodeEnd;
    }

    if (!Util.isUnset(request.nodeFrom)) {
      query["NodeFrom"] = request.nodeFrom;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTaskFlowEdgesByCondition",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteTaskFlowEdgesByConditionResponse>(await this.callApi(params, req, runtime), new DeleteTaskFlowEdgesByConditionResponse({}));
  }

  /**
   * Deletes task flow edges based on multiple conditions.
   * 
   * @remarks
   * This operation is used for multi-condition query. You can call it to delete the edges of a specified task flow that meet all specified conditions.
   * 
   * @param request - DeleteTaskFlowEdgesByConditionRequest
   * @returns DeleteTaskFlowEdgesByConditionResponse
   */
  async deleteTaskFlowEdgesByCondition(request: DeleteTaskFlowEdgesByConditionRequest): Promise<DeleteTaskFlowEdgesByConditionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteTaskFlowEdgesByConditionWithOptions(request, runtime);
  }

  /**
   * Deletes an Alibaba Cloud account that is no longer used.
   * 
   * @remarks
   * The effect of deleting a user by calling this operation is the same as that of deleting a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to delete a user that is no longer used from DMS Enterprise. After the user is deleted, the data source permission, data owner configuration, and database administrator (DBA) configuration of the corresponding Alibaba Cloud account or Resource Access Management (RAM) user are revoked and become invalid.
   * >  This operation only removes the association of the Alibaba Cloud account or RAM user with DMS Enterprise of the enterprise, rather than actually deleting the Alibaba Cloud account or RAM user. After the user is deleted, the Alibaba Cloud account or RAM user cannot log on to DMS Enterprise, unless the user is added to DMS Enterprise again.
   * 
   * @param request - DeleteUserRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteUserResponse
   */
  async deleteUserWithOptions(request: DeleteUserRequest, runtime: $Util.RuntimeOptions): Promise<DeleteUserResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.uid)) {
      query["Uid"] = request.uid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteUser",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteUserResponse>(await this.callApi(params, req, runtime), new DeleteUserResponse({}));
  }

  /**
   * Deletes an Alibaba Cloud account that is no longer used.
   * 
   * @remarks
   * The effect of deleting a user by calling this operation is the same as that of deleting a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to delete a user that is no longer used from DMS Enterprise. After the user is deleted, the data source permission, data owner configuration, and database administrator (DBA) configuration of the corresponding Alibaba Cloud account or Resource Access Management (RAM) user are revoked and become invalid.
   * >  This operation only removes the association of the Alibaba Cloud account or RAM user with DMS Enterprise of the enterprise, rather than actually deleting the Alibaba Cloud account or RAM user. After the user is deleted, the Alibaba Cloud account or RAM user cannot log on to DMS Enterprise, unless the user is added to DMS Enterprise again.
   * 
   * @param request - DeleteUserRequest
   * @returns DeleteUserResponse
   */
  async deleteUser(request: DeleteUserRequest): Promise<DeleteUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteUserWithOptions(request, runtime);
  }

  /**
   * You can call this operation to disable a user that is temporarily not used in Data Management (DMS) Enterprise.
   * 
   * @remarks
   * The effect of disabling a user by calling this operation is the same as that of disabling a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to disable a user that is temporarily not used in DMS Enterprise. After the user is disabled, the data source permission, data owner configuration, and database administrator (DBA) configuration of the corresponding Alibaba Cloud account or Resource Access Management (RAM) user are revoked and become invalid.
   * >  This operation only stops the Alibaba Cloud account or RAM user from logging on to DMS Enterprise of the enterprise, rather than actually disabling the Alibaba Cloud account or RAM user. After the user is disabled, the Alibaba Cloud account or RAM user cannot log on to DMS Enterprise, unless the user is enabled again. The disabled user, however, still exists in DMS Enterprise.
   * 
   * @param request - DisableUserRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DisableUserResponse
   */
  async disableUserWithOptions(request: DisableUserRequest, runtime: $Util.RuntimeOptions): Promise<DisableUserResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.uid)) {
      query["Uid"] = request.uid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DisableUser",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DisableUserResponse>(await this.callApi(params, req, runtime), new DisableUserResponse({}));
  }

  /**
   * You can call this operation to disable a user that is temporarily not used in Data Management (DMS) Enterprise.
   * 
   * @remarks
   * The effect of disabling a user by calling this operation is the same as that of disabling a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to disable a user that is temporarily not used in DMS Enterprise. After the user is disabled, the data source permission, data owner configuration, and database administrator (DBA) configuration of the corresponding Alibaba Cloud account or Resource Access Management (RAM) user are revoked and become invalid.
   * >  This operation only stops the Alibaba Cloud account or RAM user from logging on to DMS Enterprise of the enterprise, rather than actually disabling the Alibaba Cloud account or RAM user. After the user is disabled, the Alibaba Cloud account or RAM user cannot log on to DMS Enterprise, unless the user is enabled again. The disabled user, however, still exists in DMS Enterprise.
   * 
   * @param request - DisableUserRequest
   * @returns DisableUserResponse
   */
  async disableUser(request: DisableUserRequest): Promise<DisableUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableUserWithOptions(request, runtime);
  }

  /**
   * Downloads the parsing result of a data tracking task.
   * 
   * @param tmpReq - DownloadDataTrackResultRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DownloadDataTrackResultResponse
   */
  async downloadDataTrackResultWithOptions(tmpReq: DownloadDataTrackResultRequest, runtime: $Util.RuntimeOptions): Promise<DownloadDataTrackResultResponse> {
    Util.validateModel(tmpReq);
    let request = new DownloadDataTrackResultShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.columnFilter)) {
      request.columnFilterShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.columnFilter, "ColumnFilter", "json");
    }

    if (!Util.isUnset(tmpReq.eventIdList)) {
      request.eventIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.eventIdList, "EventIdList", "json");
    }

    if (!Util.isUnset(tmpReq.filterTableList)) {
      request.filterTableListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterTableList, "FilterTableList", "json");
    }

    if (!Util.isUnset(tmpReq.filterTypeList)) {
      request.filterTypeListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterTypeList, "FilterTypeList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.columnFilterShrink)) {
      query["ColumnFilter"] = request.columnFilterShrink;
    }

    if (!Util.isUnset(request.eventIdListShrink)) {
      query["EventIdList"] = request.eventIdListShrink;
    }

    if (!Util.isUnset(request.filterEndTime)) {
      query["FilterEndTime"] = request.filterEndTime;
    }

    if (!Util.isUnset(request.filterStartTime)) {
      query["FilterStartTime"] = request.filterStartTime;
    }

    if (!Util.isUnset(request.filterTableListShrink)) {
      query["FilterTableList"] = request.filterTableListShrink;
    }

    if (!Util.isUnset(request.filterTypeListShrink)) {
      query["FilterTypeList"] = request.filterTypeListShrink;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.rollbackSQLType)) {
      query["RollbackSQLType"] = request.rollbackSQLType;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DownloadDataTrackResult",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DownloadDataTrackResultResponse>(await this.callApi(params, req, runtime), new DownloadDataTrackResultResponse({}));
  }

  /**
   * Downloads the parsing result of a data tracking task.
   * 
   * @param request - DownloadDataTrackResultRequest
   * @returns DownloadDataTrackResultResponse
   */
  async downloadDataTrackResult(request: DownloadDataTrackResultRequest): Promise<DownloadDataTrackResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.downloadDataTrackResultWithOptions(request, runtime);
  }

  /**
   * Modifies the information about a logical database.
   * 
   * @param tmpReq - EditLogicDatabaseRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EditLogicDatabaseResponse
   */
  async editLogicDatabaseWithOptions(tmpReq: EditLogicDatabaseRequest, runtime: $Util.RuntimeOptions): Promise<EditLogicDatabaseResponse> {
    Util.validateModel(tmpReq);
    let request = new EditLogicDatabaseShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.databaseIds)) {
      request.databaseIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.databaseIds, "DatabaseIds", "json");
    }

    let query = { };
    if (!Util.isUnset(request.alias)) {
      query["Alias"] = request.alias;
    }

    if (!Util.isUnset(request.databaseIdsShrink)) {
      query["DatabaseIds"] = request.databaseIdsShrink;
    }

    if (!Util.isUnset(request.logicDbId)) {
      query["LogicDbId"] = request.logicDbId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EditLogicDatabase",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EditLogicDatabaseResponse>(await this.callApi(params, req, runtime), new EditLogicDatabaseResponse({}));
  }

  /**
   * Modifies the information about a logical database.
   * 
   * @param request - EditLogicDatabaseRequest
   * @returns EditLogicDatabaseResponse
   */
  async editLogicDatabase(request: EditLogicDatabaseRequest): Promise<EditLogicDatabaseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.editLogicDatabaseWithOptions(request, runtime);
  }

  /**
   * You can call this operation to enable a user that has been disabled in Data Management (DMS) Enterprise.
   * 
   * @remarks
   * The effect of enabling a user by calling this operation is the same as that of enabling a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to enable a user that has been disabled in DMS Enterprise. After the user is enabled, the corresponding Alibaba Cloud account or Resource Access Management (RAM) user can continue to log on to DMS Enterprise and perform relevant operations.
   * >  This operation only enables the Alibaba Cloud account or RAM user to log on to DMS Enterprise of the enterprise and perform relevant operations, rather than granting other permissions to the Alibaba Cloud account or RAM user.
   * 
   * @param request - EnableUserRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EnableUserResponse
   */
  async enableUserWithOptions(request: EnableUserRequest, runtime: $Util.RuntimeOptions): Promise<EnableUserResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.uid)) {
      query["Uid"] = request.uid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableUser",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EnableUserResponse>(await this.callApi(params, req, runtime), new EnableUserResponse({}));
  }

  /**
   * You can call this operation to enable a user that has been disabled in Data Management (DMS) Enterprise.
   * 
   * @remarks
   * The effect of enabling a user by calling this operation is the same as that of enabling a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to enable a user that has been disabled in DMS Enterprise. After the user is enabled, the corresponding Alibaba Cloud account or Resource Access Management (RAM) user can continue to log on to DMS Enterprise and perform relevant operations.
   * >  This operation only enables the Alibaba Cloud account or RAM user to log on to DMS Enterprise of the enterprise and perform relevant operations, rather than granting other permissions to the Alibaba Cloud account or RAM user.
   * 
   * @param request - EnableUserRequest
   * @returns EnableUserResponse
   */
  async enableUser(request: EnableUserRequest): Promise<EnableUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableUserWithOptions(request, runtime);
  }

  /**
   * Submits a ticket for data change.
   * 
   * @param tmpReq - ExecuteDataCorrectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ExecuteDataCorrectResponse
   */
  async executeDataCorrectWithOptions(tmpReq: ExecuteDataCorrectRequest, runtime: $Util.RuntimeOptions): Promise<ExecuteDataCorrectResponse> {
    Util.validateModel(tmpReq);
    let request = new ExecuteDataCorrectShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.actionDetail)) {
      request.actionDetailShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.actionDetail, "ActionDetail", "json");
    }

    let query = { };
    if (!Util.isUnset(request.actionDetailShrink)) {
      query["ActionDetail"] = request.actionDetailShrink;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.realLoginUserUid)) {
      query["RealLoginUserUid"] = request.realLoginUserUid;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ExecuteDataCorrect",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ExecuteDataCorrectResponse>(await this.callApi(params, req, runtime), new ExecuteDataCorrectResponse({}));
  }

  /**
   * Submits a ticket for data change.
   * 
   * @param request - ExecuteDataCorrectRequest
   * @returns ExecuteDataCorrectResponse
   */
  async executeDataCorrect(request: ExecuteDataCorrectRequest): Promise<ExecuteDataCorrectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.executeDataCorrectWithOptions(request, runtime);
  }

  /**
   * Executes a data export ticket.
   * 
   * @param tmpReq - ExecuteDataExportRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ExecuteDataExportResponse
   */
  async executeDataExportWithOptions(tmpReq: ExecuteDataExportRequest, runtime: $Util.RuntimeOptions): Promise<ExecuteDataExportResponse> {
    Util.validateModel(tmpReq);
    let request = new ExecuteDataExportShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.actionDetail)) {
      request.actionDetailShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.actionDetail, "ActionDetail", "json");
    }

    let query = { };
    if (!Util.isUnset(request.actionDetailShrink)) {
      query["ActionDetail"] = request.actionDetailShrink;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.realLoginUserUid)) {
      query["RealLoginUserUid"] = request.realLoginUserUid;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ExecuteDataExport",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ExecuteDataExportResponse>(await this.callApi(params, req, runtime), new ExecuteDataExportResponse({}));
  }

  /**
   * Executes a data export ticket.
   * 
   * @param request - ExecuteDataExportRequest
   * @returns ExecuteDataExportResponse
   */
  async executeDataExport(request: ExecuteDataExportRequest): Promise<ExecuteDataExportResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.executeDataExportWithOptions(request, runtime);
  }

  /**
   * Executes SQL statements.
   * 
   * @remarks
   * You can call this operation only for instances that are managed in Security Collaboration mode.
   * 
   * @param request - ExecuteScriptRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ExecuteScriptResponse
   */
  async executeScriptWithOptions(request: ExecuteScriptRequest, runtime: $Util.RuntimeOptions): Promise<ExecuteScriptResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.logic)) {
      query["Logic"] = request.logic;
    }

    if (!Util.isUnset(request.script)) {
      query["Script"] = request.script;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ExecuteScript",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ExecuteScriptResponse>(await this.callApi(params, req, runtime), new ExecuteScriptResponse({}));
  }

  /**
   * Executes SQL statements.
   * 
   * @remarks
   * You can call this operation only for instances that are managed in Security Collaboration mode.
   * 
   * @param request - ExecuteScriptRequest
   * @returns ExecuteScriptResponse
   */
  async executeScript(request: ExecuteScriptRequest): Promise<ExecuteScriptResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.executeScriptWithOptions(request, runtime);
  }

  /**
   * Executes a schema synchronization task.
   * 
   * @remarks
   * If the security rules of an instance indicate that a ticket must be approved before you perform schema synchronization, you can call the [SubmitStructSyncOrderApproval](https://help.aliyun.com/document_detail/206166.html) operation to submit the ticket for approval.
   * >  You can call the [GetStructSyncJobDetail](https://help.aliyun.com/document_detail/206160.html) operation to query whether you need to submit a ticket for approval.
   * 
   * @param request - ExecuteStructSyncRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ExecuteStructSyncResponse
   */
  async executeStructSyncWithOptions(request: ExecuteStructSyncRequest, runtime: $Util.RuntimeOptions): Promise<ExecuteStructSyncResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ExecuteStructSync",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ExecuteStructSyncResponse>(await this.callApi(params, req, runtime), new ExecuteStructSyncResponse({}));
  }

  /**
   * Executes a schema synchronization task.
   * 
   * @remarks
   * If the security rules of an instance indicate that a ticket must be approved before you perform schema synchronization, you can call the [SubmitStructSyncOrderApproval](https://help.aliyun.com/document_detail/206166.html) operation to submit the ticket for approval.
   * >  You can call the [GetStructSyncJobDetail](https://help.aliyun.com/document_detail/206160.html) operation to query whether you need to submit a ticket for approval.
   * 
   * @param request - ExecuteStructSyncRequest
   * @returns ExecuteStructSyncResponse
   */
  async executeStructSync(request: ExecuteStructSyncRequest): Promise<ExecuteStructSyncResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.executeStructSyncWithOptions(request, runtime);
  }

  /**
   * Queries the approval details of a ticket.
   * 
   * @param request - GetApprovalDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetApprovalDetailResponse
   */
  async getApprovalDetailWithOptions(request: GetApprovalDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetApprovalDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.workflowInstanceId)) {
      query["WorkflowInstanceId"] = request.workflowInstanceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetApprovalDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetApprovalDetailResponse>(await this.callApi(params, req, runtime), new GetApprovalDetailResponse({}));
  }

  /**
   * Queries the approval details of a ticket.
   * 
   * @param request - GetApprovalDetailRequest
   * @returns GetApprovalDetailResponse
   */
  async getApprovalDetail(request: GetApprovalDetailRequest): Promise<GetApprovalDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getApprovalDetailWithOptions(request, runtime);
  }

  /**
   * Queries the information about a permission template.
   * 
   * @remarks
   * You must be a Data Management (DMS) administrator or a database administrator (DBA). For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
   * 
   * @param request - GetAuthorityTemplateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetAuthorityTemplateResponse
   */
  async getAuthorityTemplateWithOptions(request: GetAuthorityTemplateRequest, runtime: $Util.RuntimeOptions): Promise<GetAuthorityTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetAuthorityTemplate",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetAuthorityTemplateResponse>(await this.callApi(params, req, runtime), new GetAuthorityTemplateResponse({}));
  }

  /**
   * Queries the information about a permission template.
   * 
   * @remarks
   * You must be a Data Management (DMS) administrator or a database administrator (DBA). For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
   * 
   * @param request - GetAuthorityTemplateRequest
   * @returns GetAuthorityTemplateResponse
   */
  async getAuthorityTemplate(request: GetAuthorityTemplateRequest): Promise<GetAuthorityTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getAuthorityTemplateWithOptions(request, runtime);
  }

  /**
   * Queries the resources in a permission template.
   * 
   * @remarks
   * You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
   * 
   * @param request - GetAuthorityTemplateItemRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetAuthorityTemplateItemResponse
   */
  async getAuthorityTemplateItemWithOptions(request: GetAuthorityTemplateItemRequest, runtime: $Util.RuntimeOptions): Promise<GetAuthorityTemplateItemResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetAuthorityTemplateItem",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetAuthorityTemplateItemResponse>(await this.callApi(params, req, runtime), new GetAuthorityTemplateItemResponse({}));
  }

  /**
   * Queries the resources in a permission template.
   * 
   * @remarks
   * You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
   * 
   * @param request - GetAuthorityTemplateItemRequest
   * @returns GetAuthorityTemplateItemResponse
   */
  async getAuthorityTemplateItem(request: GetAuthorityTemplateItemRequest): Promise<GetAuthorityTemplateItemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getAuthorityTemplateItemWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - GetClassificationTemplateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetClassificationTemplateResponse
   */
  async getClassificationTemplateWithOptions(request: GetClassificationTemplateRequest, runtime: $Util.RuntimeOptions): Promise<GetClassificationTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetClassificationTemplate",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetClassificationTemplateResponse>(await this.callApi(params, req, runtime), new GetClassificationTemplateResponse({}));
  }

  /**
   * 
   * 
   * @param request - GetClassificationTemplateRequest
   * @returns GetClassificationTemplateResponse
   */
  async getClassificationTemplate(request: GetClassificationTemplateRequest): Promise<GetClassificationTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getClassificationTemplateWithOptions(request, runtime);
  }

  /**
   * Queries the log that records the scheduling details of an SQL task.
   * 
   * @param request - GetDBTaskSQLJobLogRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDBTaskSQLJobLogResponse
   */
  async getDBTaskSQLJobLogWithOptions(request: GetDBTaskSQLJobLogRequest, runtime: $Util.RuntimeOptions): Promise<GetDBTaskSQLJobLogResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDBTaskSQLJobLog",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDBTaskSQLJobLogResponse>(await this.callApi(params, req, runtime), new GetDBTaskSQLJobLogResponse({}));
  }

  /**
   * Queries the log that records the scheduling details of an SQL task.
   * 
   * @param request - GetDBTaskSQLJobLogRequest
   * @returns GetDBTaskSQLJobLogResponse
   */
  async getDBTaskSQLJobLog(request: GetDBTaskSQLJobLogRequest): Promise<GetDBTaskSQLJobLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDBTaskSQLJobLogWithOptions(request, runtime);
  }

  /**
   * Queries the topologies of a logical database and its physical database shards.
   * 
   * @param request - GetDBTopologyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDBTopologyResponse
   */
  async getDBTopologyWithOptions(request: GetDBTopologyRequest, runtime: $Util.RuntimeOptions): Promise<GetDBTopologyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.logicDbId)) {
      query["LogicDbId"] = request.logicDbId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDBTopology",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDBTopologyResponse>(await this.callApi(params, req, runtime), new GetDBTopologyResponse({}));
  }

  /**
   * Queries the topologies of a logical database and its physical database shards.
   * 
   * @param request - GetDBTopologyRequest
   * @returns GetDBTopologyResponse
   */
  async getDBTopology(request: GetDBTopologyRequest): Promise<GetDBTopologyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDBTopologyWithOptions(request, runtime);
  }

  /**
   * Queries the statistics on the number of data archiving tickets, including the number of tickets of successful data archiving, failed data archiving,and in-progress data archiving, and the total number of data archiving tickets.
   * 
   * @param request - GetDataArchiveCountRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDataArchiveCountResponse
   */
  async getDataArchiveCountWithOptions(request: GetDataArchiveCountRequest, runtime: $Util.RuntimeOptions): Promise<GetDataArchiveCountResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderResultType)) {
      query["OrderResultType"] = request.orderResultType;
    }

    if (!Util.isUnset(request.pluginType)) {
      query["PluginType"] = request.pluginType;
    }

    if (!Util.isUnset(request.searchDateType)) {
      query["SearchDateType"] = request.searchDateType;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataArchiveCount",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataArchiveCountResponse>(await this.callApi(params, req, runtime), new GetDataArchiveCountResponse({}));
  }

  /**
   * Queries the statistics on the number of data archiving tickets, including the number of tickets of successful data archiving, failed data archiving,and in-progress data archiving, and the total number of data archiving tickets.
   * 
   * @param request - GetDataArchiveCountRequest
   * @returns GetDataArchiveCountResponse
   */
  async getDataArchiveCount(request: GetDataArchiveCountRequest): Promise<GetDataArchiveCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataArchiveCountWithOptions(request, runtime);
  }

  /**
   * Queries the details of a data archiving ticket, including the time when the ticket was created, the scheduling information of the data archiving task, the logs of the data archiving task, and the database to which data is archived.
   * 
   * @param request - GetDataArchiveOrderDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDataArchiveOrderDetailResponse
   */
  async getDataArchiveOrderDetailWithOptions(request: GetDataArchiveOrderDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetDataArchiveOrderDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataArchiveOrderDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataArchiveOrderDetailResponse>(await this.callApi(params, req, runtime), new GetDataArchiveOrderDetailResponse({}));
  }

  /**
   * Queries the details of a data archiving ticket, including the time when the ticket was created, the scheduling information of the data archiving task, the logs of the data archiving task, and the database to which data is archived.
   * 
   * @param request - GetDataArchiveOrderDetailRequest
   * @returns GetDataArchiveOrderDetailResponse
   */
  async getDataArchiveOrderDetail(request: GetDataArchiveOrderDetailRequest): Promise<GetDataArchiveOrderDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataArchiveOrderDetailWithOptions(request, runtime);
  }

  /**
   * Queries the download URL of the backup file for a data change ticket in Data Management (DMS).
   * 
   * @param tmpReq - GetDataCorrectBackupFilesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDataCorrectBackupFilesResponse
   */
  async getDataCorrectBackupFilesWithOptions(tmpReq: GetDataCorrectBackupFilesRequest, runtime: $Util.RuntimeOptions): Promise<GetDataCorrectBackupFilesResponse> {
    Util.validateModel(tmpReq);
    let request = new GetDataCorrectBackupFilesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.actionDetail)) {
      request.actionDetailShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.actionDetail, "ActionDetail", "json");
    }

    let query = { };
    if (!Util.isUnset(request.actionDetailShrink)) {
      query["ActionDetail"] = request.actionDetailShrink;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataCorrectBackupFiles",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataCorrectBackupFilesResponse>(await this.callApi(params, req, runtime), new GetDataCorrectBackupFilesResponse({}));
  }

  /**
   * Queries the download URL of the backup file for a data change ticket in Data Management (DMS).
   * 
   * @param request - GetDataCorrectBackupFilesRequest
   * @returns GetDataCorrectBackupFilesResponse
   */
  async getDataCorrectBackupFiles(request: GetDataCorrectBackupFilesRequest): Promise<GetDataCorrectBackupFilesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataCorrectBackupFilesWithOptions(request, runtime);
  }

  /**
   * Queries the information about a data change ticket in Data Management (DMS).
   * 
   * @param request - GetDataCorrectOrderDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDataCorrectOrderDetailResponse
   */
  async getDataCorrectOrderDetailWithOptions(request: GetDataCorrectOrderDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetDataCorrectOrderDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataCorrectOrderDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataCorrectOrderDetailResponse>(await this.callApi(params, req, runtime), new GetDataCorrectOrderDetailResponse({}));
  }

  /**
   * Queries the information about a data change ticket in Data Management (DMS).
   * 
   * @param request - GetDataCorrectOrderDetailRequest
   * @returns GetDataCorrectOrderDetailResponse
   */
  async getDataCorrectOrderDetail(request: GetDataCorrectOrderDetailRequest): Promise<GetDataCorrectOrderDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataCorrectOrderDetailWithOptions(request, runtime);
  }

  /**
   * Queries the download URL of the rollback attachment submitted along with a data change ticket.
   * 
   * @param request - GetDataCorrectRollbackFileRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDataCorrectRollbackFileResponse
   */
  async getDataCorrectRollbackFileWithOptions(request: GetDataCorrectRollbackFileRequest, runtime: $Util.RuntimeOptions): Promise<GetDataCorrectRollbackFileResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataCorrectRollbackFile",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataCorrectRollbackFileResponse>(await this.callApi(params, req, runtime), new GetDataCorrectRollbackFileResponse({}));
  }

  /**
   * Queries the download URL of the rollback attachment submitted along with a data change ticket.
   * 
   * @param request - GetDataCorrectRollbackFileRequest
   * @returns GetDataCorrectRollbackFileResponse
   */
  async getDataCorrectRollbackFile(request: GetDataCorrectRollbackFileRequest): Promise<GetDataCorrectRollbackFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataCorrectRollbackFileWithOptions(request, runtime);
  }

  /**
   * Queries the download URL of the SQL script for a data change task.
   * 
   * @remarks
   * This operation applies to [regular data change](https://help.aliyun.com/document_detail/58419.html) and [batch data import](https://help.aliyun.com/document_detail/144643.html).
   * 
   * @param request - GetDataCorrectSQLFileRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDataCorrectSQLFileResponse
   */
  async getDataCorrectSQLFileWithOptions(request: GetDataCorrectSQLFileRequest, runtime: $Util.RuntimeOptions): Promise<GetDataCorrectSQLFileResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataCorrectSQLFile",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataCorrectSQLFileResponse>(await this.callApi(params, req, runtime), new GetDataCorrectSQLFileResponse({}));
  }

  /**
   * Queries the download URL of the SQL script for a data change task.
   * 
   * @remarks
   * This operation applies to [regular data change](https://help.aliyun.com/document_detail/58419.html) and [batch data import](https://help.aliyun.com/document_detail/144643.html).
   * 
   * @param request - GetDataCorrectSQLFileRequest
   * @returns GetDataCorrectSQLFileResponse
   */
  async getDataCorrectSQLFile(request: GetDataCorrectSQLFileRequest): Promise<GetDataCorrectSQLFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataCorrectSQLFileWithOptions(request, runtime);
  }

  /**
   * Queries the information about a data change, lock-free data change, or data import task.
   * 
   * @param request - GetDataCorrectTaskDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDataCorrectTaskDetailResponse
   */
  async getDataCorrectTaskDetailWithOptions(request: GetDataCorrectTaskDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetDataCorrectTaskDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataCorrectTaskDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataCorrectTaskDetailResponse>(await this.callApi(params, req, runtime), new GetDataCorrectTaskDetailResponse({}));
  }

  /**
   * Queries the information about a data change, lock-free data change, or data import task.
   * 
   * @param request - GetDataCorrectTaskDetailRequest
   * @returns GetDataCorrectTaskDetailResponse
   */
  async getDataCorrectTaskDetail(request: GetDataCorrectTaskDetailRequest): Promise<GetDataCorrectTaskDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataCorrectTaskDetailWithOptions(request, runtime);
  }

  /**
   * Queries the scheduling configuration of a ticket for cleaning up historical data.
   * 
   * @param request - GetDataCronClearConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDataCronClearConfigResponse
   */
  async getDataCronClearConfigWithOptions(request: GetDataCronClearConfigRequest, runtime: $Util.RuntimeOptions): Promise<GetDataCronClearConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataCronClearConfig",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataCronClearConfigResponse>(await this.callApi(params, req, runtime), new GetDataCronClearConfigResponse({}));
  }

  /**
   * Queries the scheduling configuration of a ticket for cleaning up historical data.
   * 
   * @param request - GetDataCronClearConfigRequest
   * @returns GetDataCronClearConfigResponse
   */
  async getDataCronClearConfig(request: GetDataCronClearConfigRequest): Promise<GetDataCronClearConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataCronClearConfigWithOptions(request, runtime);
  }

  /**
   * Queries the details of a historical data cleansing ticket.
   * 
   * @param request - GetDataCronClearTaskDetailListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDataCronClearTaskDetailListResponse
   */
  async getDataCronClearTaskDetailListWithOptions(request: GetDataCronClearTaskDetailListRequest, runtime: $Util.RuntimeOptions): Promise<GetDataCronClearTaskDetailListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataCronClearTaskDetailList",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataCronClearTaskDetailListResponse>(await this.callApi(params, req, runtime), new GetDataCronClearTaskDetailListResponse({}));
  }

  /**
   * Queries the details of a historical data cleansing ticket.
   * 
   * @param request - GetDataCronClearTaskDetailListRequest
   * @returns GetDataCronClearTaskDetailListResponse
   */
  async getDataCronClearTaskDetailList(request: GetDataCronClearTaskDetailListRequest): Promise<GetDataCronClearTaskDetailListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataCronClearTaskDetailListWithOptions(request, runtime);
  }

  /**
   * Queries the download URL of the file that records the export results for a data export ticket in Data Management (DMS).
   * 
   * @param request - GetDataExportDownloadURLRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDataExportDownloadURLResponse
   */
  async getDataExportDownloadURLWithOptions(request: GetDataExportDownloadURLRequest, runtime: $Util.RuntimeOptions): Promise<GetDataExportDownloadURLResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.realLoginUserUid)) {
      query["RealLoginUserUid"] = request.realLoginUserUid;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataExportDownloadURL",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataExportDownloadURLResponse>(await this.callApi(params, req, runtime), new GetDataExportDownloadURLResponse({}));
  }

  /**
   * Queries the download URL of the file that records the export results for a data export ticket in Data Management (DMS).
   * 
   * @param request - GetDataExportDownloadURLRequest
   * @returns GetDataExportDownloadURLResponse
   */
  async getDataExportDownloadURL(request: GetDataExportDownloadURLRequest): Promise<GetDataExportDownloadURLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataExportDownloadURLWithOptions(request, runtime);
  }

  /**
   * Queries the information about a data export ticket.
   * 
   * @param request - GetDataExportOrderDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDataExportOrderDetailResponse
   */
  async getDataExportOrderDetailWithOptions(request: GetDataExportOrderDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetDataExportOrderDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.orderId)) {
      body["OrderId"] = request.orderId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetDataExportOrderDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataExportOrderDetailResponse>(await this.callApi(params, req, runtime), new GetDataExportOrderDetailResponse({}));
  }

  /**
   * Queries the information about a data export ticket.
   * 
   * @param request - GetDataExportOrderDetailRequest
   * @returns GetDataExportOrderDetailResponse
   */
  async getDataExportOrderDetail(request: GetDataExportOrderDetailRequest): Promise<GetDataExportOrderDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataExportOrderDetailWithOptions(request, runtime);
  }

  /**
   * Queries the precheck details of an SQL result set export ticket.
   * 
   * @param request - GetDataExportPreCheckDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDataExportPreCheckDetailResponse
   */
  async getDataExportPreCheckDetailWithOptions(request: GetDataExportPreCheckDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetDataExportPreCheckDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataExportPreCheckDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataExportPreCheckDetailResponse>(await this.callApi(params, req, runtime), new GetDataExportPreCheckDetailResponse({}));
  }

  /**
   * Queries the precheck details of an SQL result set export ticket.
   * 
   * @param request - GetDataExportPreCheckDetailRequest
   * @returns GetDataExportPreCheckDetailResponse
   */
  async getDataExportPreCheckDetail(request: GetDataExportPreCheckDetailRequest): Promise<GetDataExportPreCheckDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataExportPreCheckDetailWithOptions(request, runtime);
  }

  /**
   * Queries the SQL statements used for data import in a ticket.
   * 
   * @remarks
   * You can call this operation only if the data is imported in security mode in your data import ticket.
   * 
   * @param request - GetDataImportSQLRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDataImportSQLResponse
   */
  async getDataImportSQLWithOptions(request: GetDataImportSQLRequest, runtime: $Util.RuntimeOptions): Promise<GetDataImportSQLResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.sqlId)) {
      query["SqlId"] = request.sqlId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataImportSQL",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataImportSQLResponse>(await this.callApi(params, req, runtime), new GetDataImportSQLResponse({}));
  }

  /**
   * Queries the SQL statements used for data import in a ticket.
   * 
   * @remarks
   * You can call this operation only if the data is imported in security mode in your data import ticket.
   * 
   * @param request - GetDataImportSQLRequest
   * @returns GetDataImportSQLResponse
   */
  async getDataImportSQL(request: GetDataImportSQLRequest): Promise<GetDataImportSQLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataImportSQLWithOptions(request, runtime);
  }

  /**
   * Queries the progress of a data tracking task.
   * 
   * @param request - GetDataTrackJobDegreeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDataTrackJobDegreeResponse
   */
  async getDataTrackJobDegreeWithOptions(request: GetDataTrackJobDegreeRequest, runtime: $Util.RuntimeOptions): Promise<GetDataTrackJobDegreeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataTrackJobDegree",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataTrackJobDegreeResponse>(await this.callApi(params, req, runtime), new GetDataTrackJobDegreeResponse({}));
  }

  /**
   * Queries the progress of a data tracking task.
   * 
   * @param request - GetDataTrackJobDegreeRequest
   * @returns GetDataTrackJobDegreeResponse
   */
  async getDataTrackJobDegree(request: GetDataTrackJobDegreeRequest): Promise<GetDataTrackJobDegreeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataTrackJobDegreeWithOptions(request, runtime);
  }

  /**
   * Queries the metadata of tables involved in a data tracking task.
   * 
   * @param request - GetDataTrackJobTableMetaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDataTrackJobTableMetaResponse
   */
  async getDataTrackJobTableMetaWithOptions(request: GetDataTrackJobTableMetaRequest, runtime: $Util.RuntimeOptions): Promise<GetDataTrackJobTableMetaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataTrackJobTableMeta",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataTrackJobTableMetaResponse>(await this.callApi(params, req, runtime), new GetDataTrackJobTableMetaResponse({}));
  }

  /**
   * Queries the metadata of tables involved in a data tracking task.
   * 
   * @param request - GetDataTrackJobTableMetaRequest
   * @returns GetDataTrackJobTableMetaResponse
   */
  async getDataTrackJobTableMeta(request: GetDataTrackJobTableMetaRequest): Promise<GetDataTrackJobTableMetaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataTrackJobTableMetaWithOptions(request, runtime);
  }

  /**
   * Queries the details of a data tracking ticket.
   * 
   * @param request - GetDataTrackOrderDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDataTrackOrderDetailResponse
   */
  async getDataTrackOrderDetailWithOptions(request: GetDataTrackOrderDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetDataTrackOrderDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataTrackOrderDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataTrackOrderDetailResponse>(await this.callApi(params, req, runtime), new GetDataTrackOrderDetailResponse({}));
  }

  /**
   * Queries the details of a data tracking ticket.
   * 
   * @param request - GetDataTrackOrderDetailRequest
   * @returns GetDataTrackOrderDetailResponse
   */
  async getDataTrackOrderDetail(request: GetDataTrackOrderDetailRequest): Promise<GetDataTrackOrderDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataTrackOrderDetailWithOptions(request, runtime);
  }

  /**
   * Queries details of a specific database.
   * 
   * @param request - GetDatabaseRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDatabaseResponse
   */
  async getDatabaseWithOptions(request: GetDatabaseRequest, runtime: $Util.RuntimeOptions): Promise<GetDatabaseResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.host)) {
      query["Host"] = request.host;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.schemaName)) {
      query["SchemaName"] = request.schemaName;
    }

    if (!Util.isUnset(request.sid)) {
      query["Sid"] = request.sid;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDatabase",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDatabaseResponse>(await this.callApi(params, req, runtime), new GetDatabaseResponse({}));
  }

  /**
   * Queries details of a specific database.
   * 
   * @param request - GetDatabaseRequest
   * @returns GetDatabaseResponse
   */
  async getDatabase(request: GetDatabaseRequest): Promise<GetDatabaseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDatabaseWithOptions(request, runtime);
  }

  /**
   * Queries the details of a database export ticket.
   * 
   * @param request - GetDatabaseExportOrderDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDatabaseExportOrderDetailResponse
   */
  async getDatabaseExportOrderDetailWithOptions(request: GetDatabaseExportOrderDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetDatabaseExportOrderDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.orderId)) {
      body["OrderId"] = request.orderId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetDatabaseExportOrderDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDatabaseExportOrderDetailResponse>(await this.callApi(params, req, runtime), new GetDatabaseExportOrderDetailResponse({}));
  }

  /**
   * Queries the details of a database export ticket.
   * 
   * @param request - GetDatabaseExportOrderDetailRequest
   * @returns GetDatabaseExportOrderDetailResponse
   */
  async getDatabaseExportOrderDetail(request: GetDatabaseExportOrderDetailRequest): Promise<GetDatabaseExportOrderDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDatabaseExportOrderDetailWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - GetDbExportDownloadURLRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDbExportDownloadURLResponse
   */
  async getDbExportDownloadURLWithOptions(request: GetDbExportDownloadURLRequest, runtime: $Util.RuntimeOptions): Promise<GetDbExportDownloadURLResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDbExportDownloadURL",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDbExportDownloadURLResponse>(await this.callApi(params, req, runtime), new GetDbExportDownloadURLResponse({}));
  }

  /**
   * 
   * 
   * @param request - GetDbExportDownloadURLRequest
   * @returns GetDbExportDownloadURLResponse
   */
  async getDbExportDownloadURL(request: GetDbExportDownloadURLRequest): Promise<GetDbExportDownloadURLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDbExportDownloadURLWithOptions(request, runtime);
  }

  /**
   * Queries the details of a database instance.
   * 
   * @param request - GetInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetInstanceResponse
   */
  async getInstanceWithOptions(request: GetInstanceRequest, runtime: $Util.RuntimeOptions): Promise<GetInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.host)) {
      query["Host"] = request.host;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.sid)) {
      query["Sid"] = request.sid;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetInstance",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetInstanceResponse>(await this.callApi(params, req, runtime), new GetInstanceResponse({}));
  }

  /**
   * Queries the details of a database instance.
   * 
   * @param request - GetInstanceRequest
   * @returns GetInstanceResponse
   */
  async getInstance(request: GetInstanceRequest): Promise<GetInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getInstanceWithOptions(request, runtime);
  }

  /**
   * Queries the minimum scheduling cycle of a task flow when a service level agreement (SLA) timeout rule is configured for the task flow.
   * 
   * @remarks
   * The scheduling cycle of a task flow must be greater than the minimum scheduling cycle configured in the SLA rule for the task flow.
   * 
   * @param request - GetIntervalLimitOfSLARequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetIntervalLimitOfSLAResponse
   */
  async getIntervalLimitOfSLAWithOptions(request: GetIntervalLimitOfSLARequest, runtime: $Util.RuntimeOptions): Promise<GetIntervalLimitOfSLAResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetIntervalLimitOfSLA",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetIntervalLimitOfSLAResponse>(await this.callApi(params, req, runtime), new GetIntervalLimitOfSLAResponse({}));
  }

  /**
   * Queries the minimum scheduling cycle of a task flow when a service level agreement (SLA) timeout rule is configured for the task flow.
   * 
   * @remarks
   * The scheduling cycle of a task flow must be greater than the minimum scheduling cycle configured in the SLA rule for the task flow.
   * 
   * @param request - GetIntervalLimitOfSLARequest
   * @returns GetIntervalLimitOfSLAResponse
   */
  async getIntervalLimitOfSLA(request: GetIntervalLimitOfSLARequest): Promise<GetIntervalLimitOfSLAResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getIntervalLimitOfSLAWithOptions(request, runtime);
  }

  /**
   * Queries the information about a workspace based on the workspace name in Data Management (DMS).
   * 
   * @remarks
   * You are a DMS administrator or a database administrator (DBA).
   * 
   * @param request - GetLhSpaceByNameRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetLhSpaceByNameResponse
   */
  async getLhSpaceByNameWithOptions(request: GetLhSpaceByNameRequest, runtime: $Util.RuntimeOptions): Promise<GetLhSpaceByNameResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.spaceName)) {
      query["SpaceName"] = request.spaceName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetLhSpaceByName",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetLhSpaceByNameResponse>(await this.callApi(params, req, runtime), new GetLhSpaceByNameResponse({}));
  }

  /**
   * Queries the information about a workspace based on the workspace name in Data Management (DMS).
   * 
   * @remarks
   * You are a DMS administrator or a database administrator (DBA).
   * 
   * @param request - GetLhSpaceByNameRequest
   * @returns GetLhSpaceByNameResponse
   */
  async getLhSpaceByName(request: GetLhSpaceByNameRequest): Promise<GetLhSpaceByNameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getLhSpaceByNameWithOptions(request, runtime);
  }

  /**
   * Queries the details of a logical database.
   * 
   * @param request - GetLogicDatabaseRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetLogicDatabaseResponse
   */
  async getLogicDatabaseWithOptions(request: GetLogicDatabaseRequest, runtime: $Util.RuntimeOptions): Promise<GetLogicDatabaseResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetLogicDatabase",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetLogicDatabaseResponse>(await this.callApi(params, req, runtime), new GetLogicDatabaseResponse({}));
  }

  /**
   * Queries the details of a logical database.
   * 
   * @param request - GetLogicDatabaseRequest
   * @returns GetLogicDatabaseResponse
   */
  async getLogicDatabase(request: GetLogicDatabaseRequest): Promise<GetLogicDatabaseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getLogicDatabaseWithOptions(request, runtime);
  }

  /**
   * Queries the details of columns in a table.
   * 
   * @remarks
   * You can call this operation only for database instances whose control mode is Security Collaboration.
   * 
   * @param request - GetMetaTableColumnRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetMetaTableColumnResponse
   */
  async getMetaTableColumnWithOptions(request: GetMetaTableColumnRequest, runtime: $Util.RuntimeOptions): Promise<GetMetaTableColumnResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tableGuid)) {
      query["TableGuid"] = request.tableGuid;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMetaTableColumn",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMetaTableColumnResponse>(await this.callApi(params, req, runtime), new GetMetaTableColumnResponse({}));
  }

  /**
   * Queries the details of columns in a table.
   * 
   * @remarks
   * You can call this operation only for database instances whose control mode is Security Collaboration.
   * 
   * @param request - GetMetaTableColumnRequest
   * @returns GetMetaTableColumnResponse
   */
  async getMetaTableColumn(request: GetMetaTableColumnRequest): Promise<GetMetaTableColumnResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMetaTableColumnWithOptions(request, runtime);
  }

  /**
   * Queries the details of columns and indexes in a table.
   * 
   * @remarks
   * You can call this operation only for database instances whose control mode is Security Collaboration.
   * 
   * @param request - GetMetaTableDetailInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetMetaTableDetailInfoResponse
   */
  async getMetaTableDetailInfoWithOptions(request: GetMetaTableDetailInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetMetaTableDetailInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tableGuid)) {
      query["TableGuid"] = request.tableGuid;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMetaTableDetailInfo",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMetaTableDetailInfoResponse>(await this.callApi(params, req, runtime), new GetMetaTableDetailInfoResponse({}));
  }

  /**
   * Queries the details of columns and indexes in a table.
   * 
   * @remarks
   * You can call this operation only for database instances whose control mode is Security Collaboration.
   * 
   * @param request - GetMetaTableDetailInfoRequest
   * @returns GetMetaTableDetailInfoResponse
   */
  async getMetaTableDetailInfo(request: GetMetaTableDetailInfoRequest): Promise<GetMetaTableDetailInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMetaTableDetailInfoWithOptions(request, runtime);
  }

  /**
   * Queries the details and progress of an OnlineDDL task.
   * 
   * @param request - GetOnlineDDLProgressRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetOnlineDDLProgressResponse
   */
  async getOnlineDDLProgressWithOptions(request: GetOnlineDDLProgressRequest, runtime: $Util.RuntimeOptions): Promise<GetOnlineDDLProgressResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.jobDetailId)) {
      query["JobDetailId"] = request.jobDetailId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetOnlineDDLProgress",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOnlineDDLProgressResponse>(await this.callApi(params, req, runtime), new GetOnlineDDLProgressResponse({}));
  }

  /**
   * Queries the details and progress of an OnlineDDL task.
   * 
   * @param request - GetOnlineDDLProgressRequest
   * @returns GetOnlineDDLProgressResponse
   */
  async getOnlineDDLProgress(request: GetOnlineDDLProgressRequest): Promise<GetOnlineDDLProgressResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getOnlineDDLProgressWithOptions(request, runtime);
  }

  /**
   * Queries the details of operation logs that are generated in a specified period of time.
   * 
   * @remarks
   * Prerequisites: You are an administrator of Data Management (DMS) or a security administrator. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to obtain your user role from the RoleIdList parameter that is returned.
   * 
   * @param request - GetOpLogRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetOpLogResponse
   */
  async getOpLogWithOptions(request: GetOpLogRequest, runtime: $Util.RuntimeOptions): Promise<GetOpLogResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.databaseName)) {
      query["DatabaseName"] = request.databaseName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.module)) {
      query["Module"] = request.module;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.userNick)) {
      query["UserNick"] = request.userNick;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetOpLog",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOpLogResponse>(await this.callApi(params, req, runtime), new GetOpLogResponse({}));
  }

  /**
   * Queries the details of operation logs that are generated in a specified period of time.
   * 
   * @remarks
   * Prerequisites: You are an administrator of Data Management (DMS) or a security administrator. You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to obtain your user role from the RoleIdList parameter that is returned.
   * 
   * @param request - GetOpLogRequest
   * @returns GetOpLogResponse
   */
  async getOpLog(request: GetOpLogRequest): Promise<GetOpLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getOpLogWithOptions(request, runtime);
  }

  /**
   * Queries the download URL of the attachment of a ticket.
   * 
   * @param request - GetOrderAttachmentFileRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetOrderAttachmentFileResponse
   */
  async getOrderAttachmentFileWithOptions(request: GetOrderAttachmentFileRequest, runtime: $Util.RuntimeOptions): Promise<GetOrderAttachmentFileResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetOrderAttachmentFile",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOrderAttachmentFileResponse>(await this.callApi(params, req, runtime), new GetOrderAttachmentFileResponse({}));
  }

  /**
   * Queries the download URL of the attachment of a ticket.
   * 
   * @param request - GetOrderAttachmentFileRequest
   * @returns GetOrderAttachmentFileResponse
   */
  async getOrderAttachmentFile(request: GetOrderAttachmentFileRequest): Promise<GetOrderAttachmentFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getOrderAttachmentFileWithOptions(request, runtime);
  }

  /**
   * Queries the basic information about a ticket.
   * 
   * @param request - GetOrderBaseInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetOrderBaseInfoResponse
   */
  async getOrderBaseInfoWithOptions(request: GetOrderBaseInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetOrderBaseInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetOrderBaseInfo",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOrderBaseInfoResponse>(await this.callApi(params, req, runtime), new GetOrderBaseInfoResponse({}));
  }

  /**
   * Queries the basic information about a ticket.
   * 
   * @param request - GetOrderBaseInfoRequest
   * @returns GetOrderBaseInfoResponse
   */
  async getOrderBaseInfo(request: GetOrderBaseInfoRequest): Promise<GetOrderBaseInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getOrderBaseInfoWithOptions(request, runtime);
  }

  /**
   * Queries the details of the Database-OWNER, Table-OWNER, and Instance-OWNER tickets.
   * 
   * @param request - GetOwnerApplyOrderDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetOwnerApplyOrderDetailResponse
   */
  async getOwnerApplyOrderDetailWithOptions(request: GetOwnerApplyOrderDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetOwnerApplyOrderDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetOwnerApplyOrderDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOwnerApplyOrderDetailResponse>(await this.callApi(params, req, runtime), new GetOwnerApplyOrderDetailResponse({}));
  }

  /**
   * Queries the details of the Database-OWNER, Table-OWNER, and Instance-OWNER tickets.
   * 
   * @param request - GetOwnerApplyOrderDetailRequest
   * @returns GetOwnerApplyOrderDetailResponse
   */
  async getOwnerApplyOrderDetail(request: GetOwnerApplyOrderDetailRequest): Promise<GetOwnerApplyOrderDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getOwnerApplyOrderDetailWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - GetPagedInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetPagedInstanceResponse
   */
  async getPagedInstanceWithOptions(request: GetPagedInstanceRequest, runtime: $Util.RuntimeOptions): Promise<GetPagedInstanceResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetPagedInstance",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetPagedInstanceResponse>(await this.callApi(params, req, runtime), new GetPagedInstanceResponse({}));
  }

  /**
   * 
   * 
   * @param request - GetPagedInstanceRequest
   * @returns GetPagedInstanceResponse
   */
  async getPagedInstance(request: GetPagedInstanceRequest): Promise<GetPagedInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getPagedInstanceWithOptions(request, runtime);
  }

  /**
   * Queries the details of a ticket that applies for permissions.
   * 
   * @remarks
   * You can call this operation to query the information about tickets that apply for permissions on databases, tables, and sensitive columns.
   * 
   * @param request - GetPermApplyOrderDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetPermApplyOrderDetailResponse
   */
  async getPermApplyOrderDetailWithOptions(request: GetPermApplyOrderDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetPermApplyOrderDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetPermApplyOrderDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetPermApplyOrderDetailResponse>(await this.callApi(params, req, runtime), new GetPermApplyOrderDetailResponse({}));
  }

  /**
   * Queries the details of a ticket that applies for permissions.
   * 
   * @remarks
   * You can call this operation to query the information about tickets that apply for permissions on databases, tables, and sensitive columns.
   * 
   * @param request - GetPermApplyOrderDetailRequest
   * @returns GetPermApplyOrderDetailResponse
   */
  async getPermApplyOrderDetail(request: GetPermApplyOrderDetailRequest): Promise<GetPermApplyOrderDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getPermApplyOrderDetailWithOptions(request, runtime);
  }

  /**
   * Queries the details of a physical database.
   * 
   * @param request - GetPhysicalDatabaseRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetPhysicalDatabaseResponse
   */
  async getPhysicalDatabaseWithOptions(request: GetPhysicalDatabaseRequest, runtime: $Util.RuntimeOptions): Promise<GetPhysicalDatabaseResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetPhysicalDatabase",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetPhysicalDatabaseResponse>(await this.callApi(params, req, runtime), new GetPhysicalDatabaseResponse({}));
  }

  /**
   * Queries the details of a physical database.
   * 
   * @param request - GetPhysicalDatabaseRequest
   * @returns GetPhysicalDatabaseResponse
   */
  async getPhysicalDatabase(request: GetPhysicalDatabaseRequest): Promise<GetPhysicalDatabaseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getPhysicalDatabaseWithOptions(request, runtime);
  }

  /**
   * Queries the details of a secure access proxy.
   * 
   * @param request - GetProxyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetProxyResponse
   */
  async getProxyWithOptions(request: GetProxyRequest, runtime: $Util.RuntimeOptions): Promise<GetProxyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.proxyId)) {
      query["ProxyId"] = request.proxyId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetProxy",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetProxyResponse>(await this.callApi(params, req, runtime), new GetProxyResponse({}));
  }

  /**
   * Queries the details of a secure access proxy.
   * 
   * @param request - GetProxyRequest
   * @returns GetProxyResponse
   */
  async getProxy(request: GetProxyRequest): Promise<GetProxyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getProxyWithOptions(request, runtime);
  }

  /**
   * Queries the authorization information about the secure access proxy feature.
   * 
   * @param request - GetProxyAccessRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetProxyAccessResponse
   */
  async getProxyAccessWithOptions(request: GetProxyAccessRequest, runtime: $Util.RuntimeOptions): Promise<GetProxyAccessResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.proxyAccessId)) {
      query["ProxyAccessId"] = request.proxyAccessId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetProxyAccess",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetProxyAccessResponse>(await this.callApi(params, req, runtime), new GetProxyAccessResponse({}));
  }

  /**
   * Queries the authorization information about the secure access proxy feature.
   * 
   * @param request - GetProxyAccessRequest
   * @returns GetProxyAccessResponse
   */
  async getProxyAccess(request: GetProxyAccessRequest): Promise<GetProxyAccessResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getProxyAccessWithOptions(request, runtime);
  }

  /**
   * Queries the maximum number of custom service-level agreement (SLA) rules for task orchestration.
   * 
   * @param request - GetRuleNumLimitOfSLARequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRuleNumLimitOfSLAResponse
   */
  async getRuleNumLimitOfSLAWithOptions(request: GetRuleNumLimitOfSLARequest, runtime: $Util.RuntimeOptions): Promise<GetRuleNumLimitOfSLAResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetRuleNumLimitOfSLA",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetRuleNumLimitOfSLAResponse>(await this.callApi(params, req, runtime), new GetRuleNumLimitOfSLAResponse({}));
  }

  /**
   * Queries the maximum number of custom service-level agreement (SLA) rules for task orchestration.
   * 
   * @param request - GetRuleNumLimitOfSLARequest
   * @returns GetRuleNumLimitOfSLAResponse
   */
  async getRuleNumLimitOfSLA(request: GetRuleNumLimitOfSLARequest): Promise<GetRuleNumLimitOfSLAResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getRuleNumLimitOfSLAWithOptions(request, runtime);
  }

  /**
   * Queries the result of an SQL review.
   * 
   * @remarks
   * For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
   * 
   * @param request - GetSQLReviewCheckResultStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetSQLReviewCheckResultStatusResponse
   */
  async getSQLReviewCheckResultStatusWithOptions(request: GetSQLReviewCheckResultStatusRequest, runtime: $Util.RuntimeOptions): Promise<GetSQLReviewCheckResultStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetSQLReviewCheckResultStatus",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetSQLReviewCheckResultStatusResponse>(await this.callApi(params, req, runtime), new GetSQLReviewCheckResultStatusResponse({}));
  }

  /**
   * Queries the result of an SQL review.
   * 
   * @remarks
   * For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
   * 
   * @param request - GetSQLReviewCheckResultStatusRequest
   * @returns GetSQLReviewCheckResultStatusResponse
   */
  async getSQLReviewCheckResultStatus(request: GetSQLReviewCheckResultStatusRequest): Promise<GetSQLReviewCheckResultStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSQLReviewCheckResultStatusWithOptions(request, runtime);
  }

  /**
   * Queries the details of optimization suggestions. The operation applies only to the tickets for the data changes and SQL review.
   * 
   * @remarks
   * For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
   * 
   * @param request - GetSQLReviewOptimizeDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetSQLReviewOptimizeDetailResponse
   */
  async getSQLReviewOptimizeDetailWithOptions(request: GetSQLReviewOptimizeDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetSQLReviewOptimizeDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.SQLReviewQueryKey)) {
      query["SQLReviewQueryKey"] = request.SQLReviewQueryKey;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetSQLReviewOptimizeDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetSQLReviewOptimizeDetailResponse>(await this.callApi(params, req, runtime), new GetSQLReviewOptimizeDetailResponse({}));
  }

  /**
   * Queries the details of optimization suggestions. The operation applies only to the tickets for the data changes and SQL review.
   * 
   * @remarks
   * For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
   * 
   * @param request - GetSQLReviewOptimizeDetailRequest
   * @returns GetSQLReviewOptimizeDetailResponse
   */
  async getSQLReviewOptimizeDetail(request: GetSQLReviewOptimizeDetailRequest): Promise<GetSQLReviewOptimizeDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSQLReviewOptimizeDetailWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - GetStandardGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetStandardGroupResponse
   */
  async getStandardGroupWithOptions(request: GetStandardGroupRequest, runtime: $Util.RuntimeOptions): Promise<GetStandardGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetStandardGroup",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetStandardGroupResponse>(await this.callApi(params, req, runtime), new GetStandardGroupResponse({}));
  }

  /**
   * 
   * 
   * @param request - GetStandardGroupRequest
   * @returns GetStandardGroupResponse
   */
  async getStandardGroup(request: GetStandardGroupRequest): Promise<GetStandardGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getStandardGroupWithOptions(request, runtime);
  }

  /**
   * Queries the SQL statements that are involved in a schema synchronization ticket.
   * 
   * @param request - GetStructSyncExecSqlDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetStructSyncExecSqlDetailResponse
   */
  async getStructSyncExecSqlDetailWithOptions(request: GetStructSyncExecSqlDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetStructSyncExecSqlDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetStructSyncExecSqlDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetStructSyncExecSqlDetailResponse>(await this.callApi(params, req, runtime), new GetStructSyncExecSqlDetailResponse({}));
  }

  /**
   * Queries the SQL statements that are involved in a schema synchronization ticket.
   * 
   * @param request - GetStructSyncExecSqlDetailRequest
   * @returns GetStructSyncExecSqlDetailResponse
   */
  async getStructSyncExecSqlDetail(request: GetStructSyncExecSqlDetailRequest): Promise<GetStructSyncExecSqlDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getStructSyncExecSqlDetailWithOptions(request, runtime);
  }

  /**
   * Queries the analysis result of a schema synchronization task.
   * 
   * @param request - GetStructSyncJobAnalyzeResultRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetStructSyncJobAnalyzeResultResponse
   */
  async getStructSyncJobAnalyzeResultWithOptions(request: GetStructSyncJobAnalyzeResultRequest, runtime: $Util.RuntimeOptions): Promise<GetStructSyncJobAnalyzeResultResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.compareType)) {
      query["CompareType"] = request.compareType;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetStructSyncJobAnalyzeResult",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetStructSyncJobAnalyzeResultResponse>(await this.callApi(params, req, runtime), new GetStructSyncJobAnalyzeResultResponse({}));
  }

  /**
   * Queries the analysis result of a schema synchronization task.
   * 
   * @param request - GetStructSyncJobAnalyzeResultRequest
   * @returns GetStructSyncJobAnalyzeResultResponse
   */
  async getStructSyncJobAnalyzeResult(request: GetStructSyncJobAnalyzeResultRequest): Promise<GetStructSyncJobAnalyzeResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getStructSyncJobAnalyzeResultWithOptions(request, runtime);
  }

  /**
   * Queries the information of a schema synchronization task.
   * 
   * @param request - GetStructSyncJobDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetStructSyncJobDetailResponse
   */
  async getStructSyncJobDetailWithOptions(request: GetStructSyncJobDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetStructSyncJobDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetStructSyncJobDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetStructSyncJobDetailResponse>(await this.callApi(params, req, runtime), new GetStructSyncJobDetailResponse({}));
  }

  /**
   * Queries the information of a schema synchronization task.
   * 
   * @param request - GetStructSyncJobDetailRequest
   * @returns GetStructSyncJobDetailResponse
   */
  async getStructSyncJobDetail(request: GetStructSyncJobDetailRequest): Promise<GetStructSyncJobDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getStructSyncJobDetailWithOptions(request, runtime);
  }

  /**
   * Queries the details of a schema synchronization ticket.
   * 
   * @param request - GetStructSyncOrderDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetStructSyncOrderDetailResponse
   */
  async getStructSyncOrderDetailWithOptions(request: GetStructSyncOrderDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetStructSyncOrderDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetStructSyncOrderDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetStructSyncOrderDetailResponse>(await this.callApi(params, req, runtime), new GetStructSyncOrderDetailResponse({}));
  }

  /**
   * Queries the details of a schema synchronization ticket.
   * 
   * @param request - GetStructSyncOrderDetailRequest
   * @returns GetStructSyncOrderDetailResponse
   */
  async getStructSyncOrderDetail(request: GetStructSyncOrderDetailRequest): Promise<GetStructSyncOrderDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getStructSyncOrderDetailWithOptions(request, runtime);
  }

  /**
   * Queries the topology of a data table.
   * 
   * @param request - GetTableDBTopologyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetTableDBTopologyResponse
   */
  async getTableDBTopologyWithOptions(request: GetTableDBTopologyRequest, runtime: $Util.RuntimeOptions): Promise<GetTableDBTopologyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tableGuid)) {
      query["TableGuid"] = request.tableGuid;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetTableDBTopology",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetTableDBTopologyResponse>(await this.callApi(params, req, runtime), new GetTableDBTopologyResponse({}));
  }

  /**
   * Queries the topology of a data table.
   * 
   * @param request - GetTableDBTopologyRequest
   * @returns GetTableDBTopologyResponse
   */
  async getTableDBTopology(request: GetTableDBTopologyRequest): Promise<GetTableDBTopologyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getTableDBTopologyWithOptions(request, runtime);
  }

  /**
   * Queries the information about a schema design ticket, such as the current node of the ticket, whether the ticket can be returned to the schema design node, and the publishing strategy.
   * 
   * @param request - GetTableDesignProjectFlowRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetTableDesignProjectFlowResponse
   */
  async getTableDesignProjectFlowWithOptions(request: GetTableDesignProjectFlowRequest, runtime: $Util.RuntimeOptions): Promise<GetTableDesignProjectFlowResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetTableDesignProjectFlow",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetTableDesignProjectFlowResponse>(await this.callApi(params, req, runtime), new GetTableDesignProjectFlowResponse({}));
  }

  /**
   * Queries the information about a schema design ticket, such as the current node of the ticket, whether the ticket can be returned to the schema design node, and the publishing strategy.
   * 
   * @param request - GetTableDesignProjectFlowRequest
   * @returns GetTableDesignProjectFlowResponse
   */
  async getTableDesignProjectFlow(request: GetTableDesignProjectFlowRequest): Promise<GetTableDesignProjectFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getTableDesignProjectFlowWithOptions(request, runtime);
  }

  /**
   * Queries the information about the project and change base database of a schema design ticket, such as the state of the ticket, the ID of the user who created the ticket, and the name and ID of the change base database.
   * 
   * @param request - GetTableDesignProjectInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetTableDesignProjectInfoResponse
   */
  async getTableDesignProjectInfoWithOptions(request: GetTableDesignProjectInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetTableDesignProjectInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetTableDesignProjectInfo",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetTableDesignProjectInfoResponse>(await this.callApi(params, req, runtime), new GetTableDesignProjectInfoResponse({}));
  }

  /**
   * Queries the information about the project and change base database of a schema design ticket, such as the state of the ticket, the ID of the user who created the ticket, and the name and ID of the change base database.
   * 
   * @param request - GetTableDesignProjectInfoRequest
   * @returns GetTableDesignProjectInfoResponse
   */
  async getTableDesignProjectInfo(request: GetTableDesignProjectInfoRequest): Promise<GetTableDesignProjectInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getTableDesignProjectInfoWithOptions(request, runtime);
  }

  /**
   * Queries the topology of a table.
   * 
   * @param request - GetTableTopologyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetTableTopologyResponse
   */
  async getTableTopologyWithOptions(request: GetTableTopologyRequest, runtime: $Util.RuntimeOptions): Promise<GetTableTopologyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tableGuid)) {
      query["TableGuid"] = request.tableGuid;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetTableTopology",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetTableTopologyResponse>(await this.callApi(params, req, runtime), new GetTableTopologyResponse({}));
  }

  /**
   * Queries the topology of a table.
   * 
   * @param request - GetTableTopologyRequest
   * @returns GetTableTopologyResponse
   */
  async getTableTopology(request: GetTableTopologyRequest): Promise<GetTableTopologyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getTableTopologyWithOptions(request, runtime);
  }

  /**
   * Queries the configurations, including time variables, of a specified task node based on the task node ID.
   * 
   * @param request - GetTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetTaskResponse
   */
  async getTaskWithOptions(request: GetTaskRequest, runtime: $Util.RuntimeOptions): Promise<GetTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.nodeId)) {
      query["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetTask",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetTaskResponse>(await this.callApi(params, req, runtime), new GetTaskResponse({}));
  }

  /**
   * Queries the configurations, including time variables, of a specified task node based on the task node ID.
   * 
   * @param request - GetTaskRequest
   * @returns GetTaskResponse
   */
  async getTask(request: GetTaskRequest): Promise<GetTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getTaskWithOptions(request, runtime);
  }

  /**
   * Queries the Directed Acyclic Graph (DAG) of a task flow.
   * 
   * @param request - GetTaskFlowGraphRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetTaskFlowGraphResponse
   */
  async getTaskFlowGraphWithOptions(request: GetTaskFlowGraphRequest, runtime: $Util.RuntimeOptions): Promise<GetTaskFlowGraphResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetTaskFlowGraph",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetTaskFlowGraphResponse>(await this.callApi(params, req, runtime), new GetTaskFlowGraphResponse({}));
  }

  /**
   * Queries the Directed Acyclic Graph (DAG) of a task flow.
   * 
   * @param request - GetTaskFlowGraphRequest
   * @returns GetTaskFlowGraphResponse
   */
  async getTaskFlowGraph(request: GetTaskFlowGraphRequest): Promise<GetTaskFlowGraphResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getTaskFlowGraphWithOptions(request, runtime);
  }

  /**
   * Queries the notification settings for task flows.
   * 
   * @param request - GetTaskFlowNotificationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetTaskFlowNotificationResponse
   */
  async getTaskFlowNotificationWithOptions(request: GetTaskFlowNotificationRequest, runtime: $Util.RuntimeOptions): Promise<GetTaskFlowNotificationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetTaskFlowNotification",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetTaskFlowNotificationResponse>(await this.callApi(params, req, runtime), new GetTaskFlowNotificationResponse({}));
  }

  /**
   * Queries the notification settings for task flows.
   * 
   * @param request - GetTaskFlowNotificationRequest
   * @returns GetTaskFlowNotificationResponse
   */
  async getTaskFlowNotification(request: GetTaskFlowNotificationRequest): Promise<GetTaskFlowNotificationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getTaskFlowNotificationWithOptions(request, runtime);
  }

  /**
   * Queries the information about the nodes in an execution record of a task flow.
   * 
   * @param request - GetTaskInstanceRelationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetTaskInstanceRelationResponse
   */
  async getTaskInstanceRelationWithOptions(request: GetTaskInstanceRelationRequest, runtime: $Util.RuntimeOptions): Promise<GetTaskInstanceRelationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.dagInstanceId)) {
      query["DagInstanceId"] = request.dagInstanceId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetTaskInstanceRelation",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetTaskInstanceRelationResponse>(await this.callApi(params, req, runtime), new GetTaskInstanceRelationResponse({}));
  }

  /**
   * Queries the information about the nodes in an execution record of a task flow.
   * 
   * @param request - GetTaskInstanceRelationRequest
   * @returns GetTaskInstanceRelationResponse
   */
  async getTaskInstanceRelation(request: GetTaskInstanceRelationRequest): Promise<GetTaskInstanceRelationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getTaskInstanceRelationWithOptions(request, runtime);
  }

  /**
   * Queries the information about a user.
   * 
   * @param request - GetUserRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetUserResponse
   */
  async getUserWithOptions(request: GetUserRequest, runtime: $Util.RuntimeOptions): Promise<GetUserResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.uid)) {
      query["Uid"] = request.uid;
    }

    if (!Util.isUnset(request.userId)) {
      query["UserId"] = request.userId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetUser",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetUserResponse>(await this.callApi(params, req, runtime), new GetUserResponse({}));
  }

  /**
   * Queries the information about a user.
   * 
   * @param request - GetUserRequest
   * @returns GetUserResponse
   */
  async getUser(request: GetUserRequest): Promise<GetUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getUserWithOptions(request, runtime);
  }

  /**
   * Queries details of the active tenant.
   * 
   * @param request - GetUserActiveTenantRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetUserActiveTenantResponse
   */
  async getUserActiveTenantWithOptions(request: GetUserActiveTenantRequest, runtime: $Util.RuntimeOptions): Promise<GetUserActiveTenantResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetUserActiveTenant",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetUserActiveTenantResponse>(await this.callApi(params, req, runtime), new GetUserActiveTenantResponse({}));
  }

  /**
   * Queries details of the active tenant.
   * 
   * @param request - GetUserActiveTenantRequest
   * @returns GetUserActiveTenantResponse
   */
  async getUserActiveTenant(request: GetUserActiveTenantRequest): Promise<GetUserActiveTenantResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getUserActiveTenantWithOptions(request, runtime);
  }

  /**
   * Obtains the information of a file upload task.
   * 
   * @param request - GetUserUploadFileJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetUserUploadFileJobResponse
   */
  async getUserUploadFileJobWithOptions(request: GetUserUploadFileJobRequest, runtime: $Util.RuntimeOptions): Promise<GetUserUploadFileJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.jobKey)) {
      query["JobKey"] = request.jobKey;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetUserUploadFileJob",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetUserUploadFileJobResponse>(await this.callApi(params, req, runtime), new GetUserUploadFileJobResponse({}));
  }

  /**
   * Obtains the information of a file upload task.
   * 
   * @param request - GetUserUploadFileJobRequest
   * @returns GetUserUploadFileJobResponse
   */
  async getUserUploadFileJob(request: GetUserUploadFileJobRequest): Promise<GetUserUploadFileJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getUserUploadFileJobWithOptions(request, runtime);
  }

  /**
   * Grants permissions on resources to users by using a permission template.
   * 
   * @remarks
   * You must be a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
   * 
   * @param request - GrantTemplateAuthorityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GrantTemplateAuthorityResponse
   */
  async grantTemplateAuthorityWithOptions(request: GrantTemplateAuthorityRequest, runtime: $Util.RuntimeOptions): Promise<GrantTemplateAuthorityResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.expireDate)) {
      query["ExpireDate"] = request.expireDate;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.userIds)) {
      query["UserIds"] = request.userIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GrantTemplateAuthority",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GrantTemplateAuthorityResponse>(await this.callApi(params, req, runtime), new GrantTemplateAuthorityResponse({}));
  }

  /**
   * Grants permissions on resources to users by using a permission template.
   * 
   * @remarks
   * You must be a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
   * 
   * @param request - GrantTemplateAuthorityRequest
   * @returns GrantTemplateAuthorityResponse
   */
  async grantTemplateAuthority(request: GrantTemplateAuthorityRequest): Promise<GrantTemplateAuthorityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.grantTemplateAuthorityWithOptions(request, runtime);
  }

  /**
   * Grants permissions on an instance, a database, or a table to a user.
   * 
   * @param request - GrantUserPermissionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GrantUserPermissionResponse
   */
  async grantUserPermissionWithOptions(request: GrantUserPermissionRequest, runtime: $Util.RuntimeOptions): Promise<GrantUserPermissionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.dsType)) {
      query["DsType"] = request.dsType;
    }

    if (!Util.isUnset(request.expireDate)) {
      query["ExpireDate"] = request.expireDate;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.logic)) {
      query["Logic"] = request.logic;
    }

    if (!Util.isUnset(request.permTypes)) {
      query["PermTypes"] = request.permTypes;
    }

    if (!Util.isUnset(request.tableId)) {
      query["TableId"] = request.tableId;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.userId)) {
      query["UserId"] = request.userId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GrantUserPermission",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GrantUserPermissionResponse>(await this.callApi(params, req, runtime), new GrantUserPermissionResponse({}));
  }

  /**
   * Grants permissions on an instance, a database, or a table to a user.
   * 
   * @param request - GrantUserPermissionRequest
   * @returns GrantUserPermissionResponse
   */
  async grantUserPermission(request: GrantUserPermissionRequest): Promise<GrantUserPermissionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.grantUserPermissionWithOptions(request, runtime);
  }

  /**
   * You can call this operation to obtain the authorization password of the security protection agent InspectProxyAccessSecret.
   * 
   * @param request - InspectProxyAccessSecretRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns InspectProxyAccessSecretResponse
   */
  async inspectProxyAccessSecretWithOptions(request: InspectProxyAccessSecretRequest, runtime: $Util.RuntimeOptions): Promise<InspectProxyAccessSecretResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.proxyAccessId)) {
      query["ProxyAccessId"] = request.proxyAccessId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "InspectProxyAccessSecret",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<InspectProxyAccessSecretResponse>(await this.callApi(params, req, runtime), new InspectProxyAccessSecretResponse({}));
  }

  /**
   * You can call this operation to obtain the authorization password of the security protection agent InspectProxyAccessSecret.
   * 
   * @param request - InspectProxyAccessSecretRequest
   * @returns InspectProxyAccessSecretResponse
   */
  async inspectProxyAccessSecret(request: InspectProxyAccessSecretRequest): Promise<InspectProxyAccessSecretResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.inspectProxyAccessSecretWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - ListAuthorityTemplateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListAuthorityTemplateResponse
   */
  async listAuthorityTemplateWithOptions(request: ListAuthorityTemplateRequest, runtime: $Util.RuntimeOptions): Promise<ListAuthorityTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchKey)) {
      query["SearchKey"] = request.searchKey;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListAuthorityTemplate",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListAuthorityTemplateResponse>(await this.callApi(params, req, runtime), new ListAuthorityTemplateResponse({}));
  }

  /**
   * 
   * 
   * @param request - ListAuthorityTemplateRequest
   * @returns ListAuthorityTemplateResponse
   */
  async listAuthorityTemplate(request: ListAuthorityTemplateRequest): Promise<ListAuthorityTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAuthorityTemplateWithOptions(request, runtime);
  }

  /**
   * Queries the classification templates.
   * 
   * @param request - ListClassificationTemplatesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListClassificationTemplatesResponse
   */
  async listClassificationTemplatesWithOptions(request: ListClassificationTemplatesRequest, runtime: $Util.RuntimeOptions): Promise<ListClassificationTemplatesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListClassificationTemplates",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListClassificationTemplatesResponse>(await this.callApi(params, req, runtime), new ListClassificationTemplatesResponse({}));
  }

  /**
   * Queries the classification templates.
   * 
   * @param request - ListClassificationTemplatesRequest
   * @returns ListClassificationTemplatesResponse
   */
  async listClassificationTemplates(request: ListClassificationTemplatesRequest): Promise<ListClassificationTemplatesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClassificationTemplatesWithOptions(request, runtime);
  }

  /**
   * Returns the column information of a table.
   * 
   * @remarks
   * You can call this operation only for database instances whose control mode is Security Collaboration.
   * 
   * @param request - ListColumnsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListColumnsResponse
   */
  async listColumnsWithOptions(request: ListColumnsRequest, runtime: $Util.RuntimeOptions): Promise<ListColumnsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.logic)) {
      query["Logic"] = request.logic;
    }

    if (!Util.isUnset(request.tableId)) {
      query["TableId"] = request.tableId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListColumns",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListColumnsResponse>(await this.callApi(params, req, runtime), new ListColumnsResponse({}));
  }

  /**
   * Returns the column information of a table.
   * 
   * @remarks
   * You can call this operation only for database instances whose control mode is Security Collaboration.
   * 
   * @param request - ListColumnsRequest
   * @returns ListColumnsResponse
   */
  async listColumns(request: ListColumnsRequest): Promise<ListColumnsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listColumnsWithOptions(request, runtime);
  }

  /**
   * Queries the published versions of a task flow.
   * 
   * @param request - ListDAGVersionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDAGVersionsResponse
   */
  async listDAGVersionsWithOptions(request: ListDAGVersionsRequest, runtime: $Util.RuntimeOptions): Promise<ListDAGVersionsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.pageIndex)) {
      query["PageIndex"] = request.pageIndex;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDAGVersions",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDAGVersionsResponse>(await this.callApi(params, req, runtime), new ListDAGVersionsResponse({}));
  }

  /**
   * Queries the published versions of a task flow.
   * 
   * @param request - ListDAGVersionsRequest
   * @returns ListDAGVersionsResponse
   */
  async listDAGVersions(request: ListDAGVersionsRequest): Promise<ListDAGVersionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDAGVersionsWithOptions(request, runtime);
  }

  /**
   * Queries a list of SQL tasks.
   * 
   * @param request - ListDBTaskSQLJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDBTaskSQLJobResponse
   */
  async listDBTaskSQLJobWithOptions(request: ListDBTaskSQLJobRequest, runtime: $Util.RuntimeOptions): Promise<ListDBTaskSQLJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.DBTaskGroupId)) {
      query["DBTaskGroupId"] = request.DBTaskGroupId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDBTaskSQLJob",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDBTaskSQLJobResponse>(await this.callApi(params, req, runtime), new ListDBTaskSQLJobResponse({}));
  }

  /**
   * Queries a list of SQL tasks.
   * 
   * @param request - ListDBTaskSQLJobRequest
   * @returns ListDBTaskSQLJobResponse
   */
  async listDBTaskSQLJob(request: ListDBTaskSQLJobRequest): Promise<ListDBTaskSQLJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDBTaskSQLJobWithOptions(request, runtime);
  }

  /**
   * Queries the details of an SQL task.
   * 
   * @param request - ListDBTaskSQLJobDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDBTaskSQLJobDetailResponse
   */
  async listDBTaskSQLJobDetailWithOptions(request: ListDBTaskSQLJobDetailRequest, runtime: $Util.RuntimeOptions): Promise<ListDBTaskSQLJobDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDBTaskSQLJobDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDBTaskSQLJobDetailResponse>(await this.callApi(params, req, runtime), new ListDBTaskSQLJobDetailResponse({}));
  }

  /**
   * Queries the details of an SQL task.
   * 
   * @param request - ListDBTaskSQLJobDetailRequest
   * @returns ListDBTaskSQLJobDetailResponse
   */
  async listDBTaskSQLJobDetail(request: ListDBTaskSQLJobDetailRequest): Promise<ListDBTaskSQLJobDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDBTaskSQLJobDetailWithOptions(request, runtime);
  }

  /**
   * Queries the publishing details of a schema design ticket.
   * 
   * @param request - ListDDLPublishRecordsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDDLPublishRecordsResponse
   */
  async listDDLPublishRecordsWithOptions(request: ListDDLPublishRecordsRequest, runtime: $Util.RuntimeOptions): Promise<ListDDLPublishRecordsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDDLPublishRecords",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDDLPublishRecordsResponse>(await this.callApi(params, req, runtime), new ListDDLPublishRecordsResponse({}));
  }

  /**
   * Queries the publishing details of a schema design ticket.
   * 
   * @param request - ListDDLPublishRecordsRequest
   * @returns ListDDLPublishRecordsResponse
   */
  async listDDLPublishRecords(request: ListDDLPublishRecordsRequest): Promise<ListDDLPublishRecordsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDDLPublishRecordsWithOptions(request, runtime);
  }

  /**
   * Queries the databases that are involved in the precheck of a data change ticket.
   * 
   * @remarks
   * For more information about the Normal Data Modify feature, see [Change regular data](https://help.aliyun.com/document_detail/58419.html).
   * 
   * @param request - ListDataCorrectPreCheckDBRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDataCorrectPreCheckDBResponse
   */
  async listDataCorrectPreCheckDBWithOptions(request: ListDataCorrectPreCheckDBRequest, runtime: $Util.RuntimeOptions): Promise<ListDataCorrectPreCheckDBResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDataCorrectPreCheckDB",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDataCorrectPreCheckDBResponse>(await this.callApi(params, req, runtime), new ListDataCorrectPreCheckDBResponse({}));
  }

  /**
   * Queries the databases that are involved in the precheck of a data change ticket.
   * 
   * @remarks
   * For more information about the Normal Data Modify feature, see [Change regular data](https://help.aliyun.com/document_detail/58419.html).
   * 
   * @param request - ListDataCorrectPreCheckDBRequest
   * @returns ListDataCorrectPreCheckDBResponse
   */
  async listDataCorrectPreCheckDB(request: ListDataCorrectPreCheckDBRequest): Promise<ListDataCorrectPreCheckDBResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDataCorrectPreCheckDBWithOptions(request, runtime);
  }

  /**
   * Queries the precheck information about an SQL statement that is specified in a data change ticket.
   * 
   * @remarks
   * For more information about the Normal Data Modify feature, see [Change regular data](https://help.aliyun.com/document_detail/58419.html).
   * 
   * @param request - ListDataCorrectPreCheckSQLRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDataCorrectPreCheckSQLResponse
   */
  async listDataCorrectPreCheckSQLWithOptions(request: ListDataCorrectPreCheckSQLRequest, runtime: $Util.RuntimeOptions): Promise<ListDataCorrectPreCheckSQLResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDataCorrectPreCheckSQL",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDataCorrectPreCheckSQLResponse>(await this.callApi(params, req, runtime), new ListDataCorrectPreCheckSQLResponse({}));
  }

  /**
   * Queries the precheck information about an SQL statement that is specified in a data change ticket.
   * 
   * @remarks
   * For more information about the Normal Data Modify feature, see [Change regular data](https://help.aliyun.com/document_detail/58419.html).
   * 
   * @param request - ListDataCorrectPreCheckSQLRequest
   * @returns ListDataCorrectPreCheckSQLResponse
   */
  async listDataCorrectPreCheckSQL(request: ListDataCorrectPreCheckSQLRequest): Promise<ListDataCorrectPreCheckSQLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDataCorrectPreCheckSQLWithOptions(request, runtime);
  }

  /**
   * Queries the precheck information of SQL statements used for data import in a ticket.
   * 
   * @remarks
   * You can call this operation only if the data is imported in security mode in your data import ticket.
   * 
   * @param request - ListDataImportSQLPreCheckDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDataImportSQLPreCheckDetailResponse
   */
  async listDataImportSQLPreCheckDetailWithOptions(request: ListDataImportSQLPreCheckDetailRequest, runtime: $Util.RuntimeOptions): Promise<ListDataImportSQLPreCheckDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.pageNumer)) {
      query["PageNumer"] = request.pageNumer;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.sqlType)) {
      query["SqlType"] = request.sqlType;
    }

    if (!Util.isUnset(request.statusCode)) {
      query["StatusCode"] = request.statusCode;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDataImportSQLPreCheckDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDataImportSQLPreCheckDetailResponse>(await this.callApi(params, req, runtime), new ListDataImportSQLPreCheckDetailResponse({}));
  }

  /**
   * Queries the precheck information of SQL statements used for data import in a ticket.
   * 
   * @remarks
   * You can call this operation only if the data is imported in security mode in your data import ticket.
   * 
   * @param request - ListDataImportSQLPreCheckDetailRequest
   * @returns ListDataImportSQLPreCheckDetailResponse
   */
  async listDataImportSQLPreCheckDetail(request: ListDataImportSQLPreCheckDetailRequest): Promise<ListDataImportSQLPreCheckDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDataImportSQLPreCheckDetailWithOptions(request, runtime);
  }

  /**
   * Queries the types of SQL statements used for data import in a ticket.
   * 
   * @remarks
   * You can call this operation only if the data is imported in security mode in your data import ticket.
   * 
   * @param request - ListDataImportSQLTypeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDataImportSQLTypeResponse
   */
  async listDataImportSQLTypeWithOptions(request: ListDataImportSQLTypeRequest, runtime: $Util.RuntimeOptions): Promise<ListDataImportSQLTypeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDataImportSQLType",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDataImportSQLTypeResponse>(await this.callApi(params, req, runtime), new ListDataImportSQLTypeResponse({}));
  }

  /**
   * Queries the types of SQL statements used for data import in a ticket.
   * 
   * @remarks
   * You can call this operation only if the data is imported in security mode in your data import ticket.
   * 
   * @param request - ListDataImportSQLTypeRequest
   * @returns ListDataImportSQLTypeResponse
   */
  async listDataImportSQLType(request: ListDataImportSQLTypeRequest): Promise<ListDataImportSQLTypeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDataImportSQLTypeWithOptions(request, runtime);
  }

  /**
   * Queries the permissions of users on a database.
   * 
   * @param request - ListDatabaseUserPermssionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDatabaseUserPermssionsResponse
   */
  async listDatabaseUserPermssionsWithOptions(request: ListDatabaseUserPermssionsRequest, runtime: $Util.RuntimeOptions): Promise<ListDatabaseUserPermssionsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.logic)) {
      query["Logic"] = request.logic;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.permType)) {
      query["PermType"] = request.permType;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.userName)) {
      query["UserName"] = request.userName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDatabaseUserPermssions",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDatabaseUserPermssionsResponse>(await this.callApi(params, req, runtime), new ListDatabaseUserPermssionsResponse({}));
  }

  /**
   * Queries the permissions of users on a database.
   * 
   * @param request - ListDatabaseUserPermssionsRequest
   * @returns ListDatabaseUserPermssionsResponse
   */
  async listDatabaseUserPermssions(request: ListDatabaseUserPermssionsRequest): Promise<ListDatabaseUserPermssionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDatabaseUserPermssionsWithOptions(request, runtime);
  }

  /**
   * Queries the databases in a database instance.
   * 
   * @param request - ListDatabasesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDatabasesResponse
   */
  async listDatabasesWithOptions(request: ListDatabasesRequest, runtime: $Util.RuntimeOptions): Promise<ListDatabasesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDatabases",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDatabasesResponse>(await this.callApi(params, req, runtime), new ListDatabasesResponse({}));
  }

  /**
   * Queries the databases in a database instance.
   * 
   * @param request - ListDatabasesRequest
   * @returns ListDatabasesResponse
   */
  async listDatabases(request: ListDatabasesRequest): Promise<ListDatabasesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDatabasesWithOptions(request, runtime);
  }

  /**
   * Queries the default service level agreement (SLA) timeout rules.
   * 
   * @param request - ListDefaultSLARulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDefaultSLARulesResponse
   */
  async listDefaultSLARulesWithOptions(request: ListDefaultSLARulesRequest, runtime: $Util.RuntimeOptions): Promise<ListDefaultSLARulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDefaultSLARules",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDefaultSLARulesResponse>(await this.callApi(params, req, runtime), new ListDefaultSLARulesResponse({}));
  }

  /**
   * Queries the default service level agreement (SLA) timeout rules.
   * 
   * @param request - ListDefaultSLARulesRequest
   * @returns ListDefaultSLARulesResponse
   */
  async listDefaultSLARules(request: ListDefaultSLARulesRequest): Promise<ListDefaultSLARulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDefaultSLARulesWithOptions(request, runtime);
  }

  /**
   * Queries masking rules.
   * 
   * @param request - ListDesensitizationRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDesensitizationRuleResponse
   */
  async listDesensitizationRuleWithOptions(request: ListDesensitizationRuleRequest, runtime: $Util.RuntimeOptions): Promise<ListDesensitizationRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.funcType)) {
      query["FuncType"] = request.funcType;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.ruleType)) {
      query["RuleType"] = request.ruleType;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDesensitizationRule",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDesensitizationRuleResponse>(await this.callApi(params, req, runtime), new ListDesensitizationRuleResponse({}));
  }

  /**
   * Queries masking rules.
   * 
   * @param request - ListDesensitizationRuleRequest
   * @returns ListDesensitizationRuleResponse
   */
  async listDesensitizationRule(request: ListDesensitizationRuleRequest): Promise<ListDesensitizationRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDesensitizationRuleWithOptions(request, runtime);
  }

  /**
   * Queries valid orders.
   * 
   * @param request - ListEffectiveOrdersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEffectiveOrdersResponse
   */
  async listEffectiveOrdersWithOptions(request: ListEffectiveOrdersRequest, runtime: $Util.RuntimeOptions): Promise<ListEffectiveOrdersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListEffectiveOrders",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListEffectiveOrdersResponse>(await this.callApi(params, req, runtime), new ListEffectiveOrdersResponse({}));
  }

  /**
   * Queries valid orders.
   * 
   * @param request - ListEffectiveOrdersRequest
   * @returns ListEffectiveOrdersResponse
   */
  async listEffectiveOrders(request: ListEffectiveOrdersRequest): Promise<ListEffectiveOrdersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listEffectiveOrdersWithOptions(request, runtime);
  }

  /**
   * Queries the indexes of a table.
   * 
   * @param request - ListIndexesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListIndexesResponse
   */
  async listIndexesWithOptions(request: ListIndexesRequest, runtime: $Util.RuntimeOptions): Promise<ListIndexesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.logic)) {
      query["Logic"] = request.logic;
    }

    if (!Util.isUnset(request.tableId)) {
      query["TableId"] = request.tableId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListIndexes",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListIndexesResponse>(await this.callApi(params, req, runtime), new ListIndexesResponse({}));
  }

  /**
   * Queries the indexes of a table.
   * 
   * @param request - ListIndexesRequest
   * @returns ListIndexesResponse
   */
  async listIndexes(request: ListIndexesRequest): Promise<ListIndexesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listIndexesWithOptions(request, runtime);
  }

  /**
   * Queries the logon records of an instance.
   * 
   * @param request - ListInstanceLoginAuditLogRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListInstanceLoginAuditLogResponse
   */
  async listInstanceLoginAuditLogWithOptions(request: ListInstanceLoginAuditLogRequest, runtime: $Util.RuntimeOptions): Promise<ListInstanceLoginAuditLogResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.opUserName)) {
      query["OpUserName"] = request.opUserName;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchName)) {
      query["SearchName"] = request.searchName;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListInstanceLoginAuditLog",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListInstanceLoginAuditLogResponse>(await this.callApi(params, req, runtime), new ListInstanceLoginAuditLogResponse({}));
  }

  /**
   * Queries the logon records of an instance.
   * 
   * @param request - ListInstanceLoginAuditLogRequest
   * @returns ListInstanceLoginAuditLogResponse
   */
  async listInstanceLoginAuditLog(request: ListInstanceLoginAuditLogRequest): Promise<ListInstanceLoginAuditLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listInstanceLoginAuditLogWithOptions(request, runtime);
  }

  /**
   * Queries the permissions of a user on a specific instance.
   * 
   * @param request - ListInstanceUserPermissionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListInstanceUserPermissionsResponse
   */
  async listInstanceUserPermissionsWithOptions(request: ListInstanceUserPermissionsRequest, runtime: $Util.RuntimeOptions): Promise<ListInstanceUserPermissionsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.userName)) {
      query["UserName"] = request.userName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListInstanceUserPermissions",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListInstanceUserPermissionsResponse>(await this.callApi(params, req, runtime), new ListInstanceUserPermissionsResponse({}));
  }

  /**
   * Queries the permissions of a user on a specific instance.
   * 
   * @param request - ListInstanceUserPermissionsRequest
   * @returns ListInstanceUserPermissionsResponse
   */
  async listInstanceUserPermissions(request: ListInstanceUserPermissionsRequest): Promise<ListInstanceUserPermissionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listInstanceUserPermissionsWithOptions(request, runtime);
  }

  /**
   * Queries the information about database instances.
   * 
   * @param request - ListInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListInstancesResponse
   */
  async listInstancesWithOptions(request: ListInstancesRequest, runtime: $Util.RuntimeOptions): Promise<ListInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbType)) {
      query["DbType"] = request.dbType;
    }

    if (!Util.isUnset(request.envType)) {
      query["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.instanceSource)) {
      query["InstanceSource"] = request.instanceSource;
    }

    if (!Util.isUnset(request.instanceState)) {
      query["InstanceState"] = request.instanceState;
    }

    if (!Util.isUnset(request.netType)) {
      query["NetType"] = request.netType;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchKey)) {
      query["SearchKey"] = request.searchKey;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListInstances",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListInstancesResponse>(await this.callApi(params, req, runtime), new ListInstancesResponse({}));
  }

  /**
   * Queries the information about database instances.
   * 
   * @param request - ListInstancesRequest
   * @returns ListInstancesResponse
   */
  async listInstances(request: ListInstancesRequest): Promise<ListInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listInstancesWithOptions(request, runtime);
  }

  /**
   * Queries the task flows corresponding to a specific business scenario in a workspace in Data Management (DMS).
   * 
   * @remarks
   *   Before you call this operation, make sure that you have the access permissions on the workspace. If you do not have the access permissions on the workspace, you can contact a DMS administrator, database administrator (DBA), or workspace administrator to add you as a member of the workspace. The [AddLhMembers](https://help.aliyun.com/document_detail/424759.html) operation can be called to add a workspace member.
   * *   If you are a DMS administrator or a workspace administrator, you can query the business scenarios and task flows related to a user in a workspace based on the user ID.
   * 
   * @param request - ListLhTaskFlowAndScenarioRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListLhTaskFlowAndScenarioResponse
   */
  async listLhTaskFlowAndScenarioWithOptions(request: ListLhTaskFlowAndScenarioRequest, runtime: $Util.RuntimeOptions): Promise<ListLhTaskFlowAndScenarioResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.spaceId)) {
      query["SpaceId"] = request.spaceId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.userId)) {
      query["UserId"] = request.userId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListLhTaskFlowAndScenario",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListLhTaskFlowAndScenarioResponse>(await this.callApi(params, req, runtime), new ListLhTaskFlowAndScenarioResponse({}));
  }

  /**
   * Queries the task flows corresponding to a specific business scenario in a workspace in Data Management (DMS).
   * 
   * @remarks
   *   Before you call this operation, make sure that you have the access permissions on the workspace. If you do not have the access permissions on the workspace, you can contact a DMS administrator, database administrator (DBA), or workspace administrator to add you as a member of the workspace. The [AddLhMembers](https://help.aliyun.com/document_detail/424759.html) operation can be called to add a workspace member.
   * *   If you are a DMS administrator or a workspace administrator, you can query the business scenarios and task flows related to a user in a workspace based on the user ID.
   * 
   * @param request - ListLhTaskFlowAndScenarioRequest
   * @returns ListLhTaskFlowAndScenarioResponse
   */
  async listLhTaskFlowAndScenario(request: ListLhTaskFlowAndScenarioRequest): Promise<ListLhTaskFlowAndScenarioResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listLhTaskFlowAndScenarioWithOptions(request, runtime);
  }

  /**
   * Queries the details of logical databases.
   * 
   * @param request - ListLogicDatabasesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListLogicDatabasesResponse
   */
  async listLogicDatabasesWithOptions(request: ListLogicDatabasesRequest, runtime: $Util.RuntimeOptions): Promise<ListLogicDatabasesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListLogicDatabases",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListLogicDatabasesResponse>(await this.callApi(params, req, runtime), new ListLogicDatabasesResponse({}));
  }

  /**
   * Queries the details of logical databases.
   * 
   * @param request - ListLogicDatabasesRequest
   * @returns ListLogicDatabasesResponse
   */
  async listLogicDatabases(request: ListLogicDatabasesRequest): Promise<ListLogicDatabasesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listLogicDatabasesWithOptions(request, runtime);
  }

  /**
   * Queries the routing algorithms of a logical table.
   * 
   * @param request - ListLogicTableRouteConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListLogicTableRouteConfigResponse
   */
  async listLogicTableRouteConfigWithOptions(request: ListLogicTableRouteConfigRequest, runtime: $Util.RuntimeOptions): Promise<ListLogicTableRouteConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tableId)) {
      query["TableId"] = request.tableId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListLogicTableRouteConfig",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListLogicTableRouteConfigResponse>(await this.callApi(params, req, runtime), new ListLogicTableRouteConfigResponse({}));
  }

  /**
   * Queries the routing algorithms of a logical table.
   * 
   * @param request - ListLogicTableRouteConfigRequest
   * @returns ListLogicTableRouteConfigResponse
   */
  async listLogicTableRouteConfig(request: ListLogicTableRouteConfigRequest): Promise<ListLogicTableRouteConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listLogicTableRouteConfigWithOptions(request, runtime);
  }

  /**
   * Queries the details of the logical tables in a logical database.
   * 
   * @param request - ListLogicTablesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListLogicTablesResponse
   */
  async listLogicTablesWithOptions(request: ListLogicTablesRequest, runtime: $Util.RuntimeOptions): Promise<ListLogicTablesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.databaseId)) {
      query["DatabaseId"] = request.databaseId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.returnGuid)) {
      query["ReturnGuid"] = request.returnGuid;
    }

    if (!Util.isUnset(request.searchName)) {
      query["SearchName"] = request.searchName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListLogicTables",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListLogicTablesResponse>(await this.callApi(params, req, runtime), new ListLogicTablesResponse({}));
  }

  /**
   * Queries the details of the logical tables in a logical database.
   * 
   * @param request - ListLogicTablesRequest
   * @returns ListLogicTablesResponse
   */
  async listLogicTables(request: ListLogicTablesRequest): Promise<ListLogicTablesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listLogicTablesWithOptions(request, runtime);
  }

  /**
   * Queries tickets in Data Management (DMS).
   * 
   * @param request - ListOrdersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListOrdersResponse
   */
  async listOrdersWithOptions(request: ListOrdersRequest, runtime: $Util.RuntimeOptions): Promise<ListOrdersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.orderResultType)) {
      query["OrderResultType"] = request.orderResultType;
    }

    if (!Util.isUnset(request.orderStatus)) {
      query["OrderStatus"] = request.orderStatus;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.pluginType)) {
      query["PluginType"] = request.pluginType;
    }

    if (!Util.isUnset(request.searchContent)) {
      query["SearchContent"] = request.searchContent;
    }

    if (!Util.isUnset(request.searchDateType)) {
      query["SearchDateType"] = request.searchDateType;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListOrders",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListOrdersResponse>(await this.callApi(params, req, runtime), new ListOrdersResponse({}));
  }

  /**
   * Queries tickets in Data Management (DMS).
   * 
   * @param request - ListOrdersRequest
   * @returns ListOrdersResponse
   */
  async listOrders(request: ListOrdersRequest): Promise<ListOrdersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listOrdersWithOptions(request, runtime);
  }

  /**
   * Queries the proxies that are generated by the secure access proxy feature.
   * 
   * @param request - ListProxiesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListProxiesResponse
   */
  async listProxiesWithOptions(request: ListProxiesRequest, runtime: $Util.RuntimeOptions): Promise<ListProxiesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListProxies",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListProxiesResponse>(await this.callApi(params, req, runtime), new ListProxiesResponse({}));
  }

  /**
   * Queries the proxies that are generated by the secure access proxy feature.
   * 
   * @param request - ListProxiesRequest
   * @returns ListProxiesResponse
   */
  async listProxies(request: ListProxiesRequest): Promise<ListProxiesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listProxiesWithOptions(request, runtime);
  }

  /**
   * Queries information about users that are authorized to access a database instance by using the secure access proxy feature.
   * 
   * @param request - ListProxyAccessesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListProxyAccessesResponse
   */
  async listProxyAccessesWithOptions(request: ListProxyAccessesRequest, runtime: $Util.RuntimeOptions): Promise<ListProxyAccessesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.proxyId)) {
      query["ProxyId"] = request.proxyId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListProxyAccesses",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListProxyAccessesResponse>(await this.callApi(params, req, runtime), new ListProxyAccessesResponse({}));
  }

  /**
   * Queries information about users that are authorized to access a database instance by using the secure access proxy feature.
   * 
   * @param request - ListProxyAccessesRequest
   * @returns ListProxyAccessesResponse
   */
  async listProxyAccesses(request: ListProxyAccessesRequest): Promise<ListProxyAccessesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listProxyAccessesWithOptions(request, runtime);
  }

  /**
   * -SQL
   * 
   * @param request - ListProxySQLExecAuditLogRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListProxySQLExecAuditLogResponse
   */
  async listProxySQLExecAuditLogWithOptions(request: ListProxySQLExecAuditLogRequest, runtime: $Util.RuntimeOptions): Promise<ListProxySQLExecAuditLogResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.execState)) {
      query["ExecState"] = request.execState;
    }

    if (!Util.isUnset(request.opUserName)) {
      query["OpUserName"] = request.opUserName;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.SQLType)) {
      query["SQLType"] = request.SQLType;
    }

    if (!Util.isUnset(request.searchName)) {
      query["SearchName"] = request.searchName;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListProxySQLExecAuditLog",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListProxySQLExecAuditLogResponse>(await this.callApi(params, req, runtime), new ListProxySQLExecAuditLogResponse({}));
  }

  /**
   * -SQL
   * 
   * @param request - ListProxySQLExecAuditLogRequest
   * @returns ListProxySQLExecAuditLogResponse
   */
  async listProxySQLExecAuditLog(request: ListProxySQLExecAuditLogRequest): Promise<ListProxySQLExecAuditLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listProxySQLExecAuditLogWithOptions(request, runtime);
  }

  /**
   * Queries the custom service level agreement (SLA) rules.
   * 
   * @param request - ListSLARulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListSLARulesResponse
   */
  async listSLARulesWithOptions(request: ListSLARulesRequest, runtime: $Util.RuntimeOptions): Promise<ListSLARulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSLARules",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSLARulesResponse>(await this.callApi(params, req, runtime), new ListSLARulesResponse({}));
  }

  /**
   * Queries the custom service level agreement (SLA) rules.
   * 
   * @param request - ListSLARulesRequest
   * @returns ListSLARulesResponse
   */
  async listSLARules(request: ListSLARulesRequest): Promise<ListSLARulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSLARulesWithOptions(request, runtime);
  }

  /**
   * Queries SQL statements that were written on the SQLConsole tab.
   * 
   * @param request - ListSQLExecAuditLogRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListSQLExecAuditLogResponse
   */
  async listSQLExecAuditLogWithOptions(request: ListSQLExecAuditLogRequest, runtime: $Util.RuntimeOptions): Promise<ListSQLExecAuditLogResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.execState)) {
      query["ExecState"] = request.execState;
    }

    if (!Util.isUnset(request.opUserName)) {
      query["OpUserName"] = request.opUserName;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchName)) {
      query["SearchName"] = request.searchName;
    }

    if (!Util.isUnset(request.sqlType)) {
      query["SqlType"] = request.sqlType;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSQLExecAuditLog",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSQLExecAuditLogResponse>(await this.callApi(params, req, runtime), new ListSQLExecAuditLogResponse({}));
  }

  /**
   * Queries SQL statements that were written on the SQLConsole tab.
   * 
   * @param request - ListSQLExecAuditLogRequest
   * @returns ListSQLExecAuditLogResponse
   */
  async listSQLExecAuditLog(request: ListSQLExecAuditLogRequest): Promise<ListSQLExecAuditLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSQLExecAuditLogWithOptions(request, runtime);
  }

  /**
   * Queries the details of the SQL statements that are involved in an SQL review ticket.
   * 
   * @remarks
   * For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
   * 
   * @param tmpReq - ListSQLReviewOriginSQLRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListSQLReviewOriginSQLResponse
   */
  async listSQLReviewOriginSQLWithOptions(tmpReq: ListSQLReviewOriginSQLRequest, runtime: $Util.RuntimeOptions): Promise<ListSQLReviewOriginSQLResponse> {
    Util.validateModel(tmpReq);
    let request = new ListSQLReviewOriginSQLShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.orderActionDetail)) {
      request.orderActionDetailShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.orderActionDetail, "OrderActionDetail", "json");
    }

    let query = { };
    if (!Util.isUnset(request.orderActionDetailShrink)) {
      query["OrderActionDetail"] = request.orderActionDetailShrink;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSQLReviewOriginSQL",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSQLReviewOriginSQLResponse>(await this.callApi(params, req, runtime), new ListSQLReviewOriginSQLResponse({}));
  }

  /**
   * Queries the details of the SQL statements that are involved in an SQL review ticket.
   * 
   * @remarks
   * For more information about the SQL review feature, see [SQL review](https://help.aliyun.com/document_detail/60374.html).
   * 
   * @param request - ListSQLReviewOriginSQLRequest
   * @returns ListSQLReviewOriginSQLResponse
   */
  async listSQLReviewOriginSQL(request: ListSQLReviewOriginSQLRequest): Promise<ListSQLReviewOriginSQLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSQLReviewOriginSQLWithOptions(request, runtime);
  }

  /**
   * Queries business scenarios.
   * 
   * @param request - ListScenariosRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListScenariosResponse
   */
  async listScenariosWithOptions(request: ListScenariosRequest, runtime: $Util.RuntimeOptions): Promise<ListScenariosResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListScenarios",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListScenariosResponse>(await this.callApi(params, req, runtime), new ListScenariosResponse({}));
  }

  /**
   * Queries business scenarios.
   * 
   * @param request - ListScenariosRequest
   * @returns ListScenariosResponse
   */
  async listScenarios(request: ListScenariosRequest): Promise<ListScenariosResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listScenariosWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - ListSensitiveColumnInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListSensitiveColumnInfoResponse
   */
  async listSensitiveColumnInfoWithOptions(request: ListSensitiveColumnInfoRequest, runtime: $Util.RuntimeOptions): Promise<ListSensitiveColumnInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.columnName)) {
      query["ColumnName"] = request.columnName;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.schemaName)) {
      query["SchemaName"] = request.schemaName;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSensitiveColumnInfo",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSensitiveColumnInfoResponse>(await this.callApi(params, req, runtime), new ListSensitiveColumnInfoResponse({}));
  }

  /**
   * 
   * 
   * @param request - ListSensitiveColumnInfoRequest
   * @returns ListSensitiveColumnInfoResponse
   */
  async listSensitiveColumnInfo(request: ListSensitiveColumnInfoRequest): Promise<ListSensitiveColumnInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSensitiveColumnInfoWithOptions(request, runtime);
  }

  /**
   * Queries sensitive fields in a table of a database.
   * 
   * @param request - ListSensitiveColumnsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListSensitiveColumnsResponse
   */
  async listSensitiveColumnsWithOptions(request: ListSensitiveColumnsRequest, runtime: $Util.RuntimeOptions): Promise<ListSensitiveColumnsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.columnName)) {
      query["ColumnName"] = request.columnName;
    }

    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.logic)) {
      query["Logic"] = request.logic;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.schemaName)) {
      query["SchemaName"] = request.schemaName;
    }

    if (!Util.isUnset(request.securityLevel)) {
      query["SecurityLevel"] = request.securityLevel;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSensitiveColumns",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSensitiveColumnsResponse>(await this.callApi(params, req, runtime), new ListSensitiveColumnsResponse({}));
  }

  /**
   * Queries sensitive fields in a table of a database.
   * 
   * @param request - ListSensitiveColumnsRequest
   * @returns ListSensitiveColumnsResponse
   */
  async listSensitiveColumns(request: ListSensitiveColumnsRequest): Promise<ListSensitiveColumnsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSensitiveColumnsWithOptions(request, runtime);
  }

  /**
   * Queries the details of a sensitive field.
   * 
   * @param request - ListSensitiveColumnsDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListSensitiveColumnsDetailResponse
   */
  async listSensitiveColumnsDetailWithOptions(request: ListSensitiveColumnsDetailRequest, runtime: $Util.RuntimeOptions): Promise<ListSensitiveColumnsDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.columnName)) {
      query["ColumnName"] = request.columnName;
    }

    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.logic)) {
      query["Logic"] = request.logic;
    }

    if (!Util.isUnset(request.schemaName)) {
      query["SchemaName"] = request.schemaName;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSensitiveColumnsDetail",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSensitiveColumnsDetailResponse>(await this.callApi(params, req, runtime), new ListSensitiveColumnsDetailResponse({}));
  }

  /**
   * Queries the details of a sensitive field.
   * 
   * @param request - ListSensitiveColumnsDetailRequest
   * @returns ListSensitiveColumnsDetailResponse
   */
  async listSensitiveColumnsDetail(request: ListSensitiveColumnsDetailRequest): Promise<ListSensitiveColumnsDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSensitiveColumnsDetailWithOptions(request, runtime);
  }

  /**
   * Queries the audit logs for sensitive information.
   * 
   * @param request - ListSensitiveDataAuditLogRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListSensitiveDataAuditLogResponse
   */
  async listSensitiveDataAuditLogWithOptions(request: ListSensitiveDataAuditLogRequest, runtime: $Util.RuntimeOptions): Promise<ListSensitiveDataAuditLogResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.columnName)) {
      query["ColumnName"] = request.columnName;
    }

    if (!Util.isUnset(request.dbName)) {
      query["DbName"] = request.dbName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.moduleName)) {
      query["ModuleName"] = request.moduleName;
    }

    if (!Util.isUnset(request.opUserName)) {
      query["OpUserName"] = request.opUserName;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSensitiveDataAuditLog",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSensitiveDataAuditLogResponse>(await this.callApi(params, req, runtime), new ListSensitiveDataAuditLogResponse({}));
  }

  /**
   * Queries the audit logs for sensitive information.
   * 
   * @param request - ListSensitiveDataAuditLogRequest
   * @returns ListSensitiveDataAuditLogResponse
   */
  async listSensitiveDataAuditLog(request: ListSensitiveDataAuditLogRequest): Promise<ListSensitiveDataAuditLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSensitiveDataAuditLogWithOptions(request, runtime);
  }

  /**
   * Queries the sensitivity levels of a classification template.
   * 
   * @param request - ListSensitivityLevelRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListSensitivityLevelResponse
   */
  async listSensitivityLevelWithOptions(request: ListSensitivityLevelRequest, runtime: $Util.RuntimeOptions): Promise<ListSensitivityLevelResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSensitivityLevel",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSensitivityLevelResponse>(await this.callApi(params, req, runtime), new ListSensitivityLevelResponse({}));
  }

  /**
   * Queries the sensitivity levels of a classification template.
   * 
   * @param request - ListSensitivityLevelRequest
   * @returns ListSensitivityLevelResponse
   */
  async listSensitivityLevel(request: ListSensitivityLevelRequest): Promise<ListSensitivityLevelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSensitivityLevelWithOptions(request, runtime);
  }

  /**
   * Queries security rule sets.
   * 
   * @param request - ListStandardGroupsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListStandardGroupsResponse
   */
  async listStandardGroupsWithOptions(request: ListStandardGroupsRequest, runtime: $Util.RuntimeOptions): Promise<ListStandardGroupsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListStandardGroups",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListStandardGroupsResponse>(await this.callApi(params, req, runtime), new ListStandardGroupsResponse({}));
  }

  /**
   * Queries security rule sets.
   * 
   * @param request - ListStandardGroupsRequest
   * @returns ListStandardGroupsResponse
   */
  async listStandardGroups(request: ListStandardGroupsRequest): Promise<ListStandardGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listStandardGroupsWithOptions(request, runtime);
  }

  /**
   * Queries the tables in a database.
   * 
   * @remarks
   * You can call this operation only for database instances whose control mode is Security Collaboration.
   * 
   * @param request - ListTablesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListTablesResponse
   */
  async listTablesWithOptions(request: ListTablesRequest, runtime: $Util.RuntimeOptions): Promise<ListTablesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.databaseId)) {
      query["DatabaseId"] = request.databaseId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.returnGuid)) {
      query["ReturnGuid"] = request.returnGuid;
    }

    if (!Util.isUnset(request.searchName)) {
      query["SearchName"] = request.searchName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTables",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTablesResponse>(await this.callApi(params, req, runtime), new ListTablesResponse({}));
  }

  /**
   * Queries the tables in a database.
   * 
   * @remarks
   * You can call this operation only for database instances whose control mode is Security Collaboration.
   * 
   * @param request - ListTablesRequest
   * @returns ListTablesResponse
   */
  async listTables(request: ListTablesRequest): Promise<ListTablesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTablesWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - ListTaskFlowRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListTaskFlowResponse
   */
  async listTaskFlowWithOptions(request: ListTaskFlowRequest, runtime: $Util.RuntimeOptions): Promise<ListTaskFlowResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTaskFlow",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTaskFlowResponse>(await this.callApi(params, req, runtime), new ListTaskFlowResponse({}));
  }

  /**
   * 
   * 
   * @param request - ListTaskFlowRequest
   * @returns ListTaskFlowResponse
   */
  async listTaskFlow(request: ListTaskFlowRequest): Promise<ListTaskFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTaskFlowWithOptions(request, runtime);
  }

  /**
   * Queries the constants for a task flow.
   * 
   * @param request - ListTaskFlowConstantsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListTaskFlowConstantsResponse
   */
  async listTaskFlowConstantsWithOptions(request: ListTaskFlowConstantsRequest, runtime: $Util.RuntimeOptions): Promise<ListTaskFlowConstantsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTaskFlowConstants",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTaskFlowConstantsResponse>(await this.callApi(params, req, runtime), new ListTaskFlowConstantsResponse({}));
  }

  /**
   * Queries the constants for a task flow.
   * 
   * @param request - ListTaskFlowConstantsRequest
   * @returns ListTaskFlowConstantsResponse
   */
  async listTaskFlowConstants(request: ListTaskFlowConstantsRequest): Promise<ListTaskFlowConstantsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTaskFlowConstantsWithOptions(request, runtime);
  }

  /**
   * Queries the users that are involved in a specified task flow.
   * 
   * @param request - ListTaskFlowCooperatorsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListTaskFlowCooperatorsResponse
   */
  async listTaskFlowCooperatorsWithOptions(request: ListTaskFlowCooperatorsRequest, runtime: $Util.RuntimeOptions): Promise<ListTaskFlowCooperatorsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTaskFlowCooperators",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTaskFlowCooperatorsResponse>(await this.callApi(params, req, runtime), new ListTaskFlowCooperatorsResponse({}));
  }

  /**
   * Queries the users that are involved in a specified task flow.
   * 
   * @param request - ListTaskFlowCooperatorsRequest
   * @returns ListTaskFlowCooperatorsResponse
   */
  async listTaskFlowCooperators(request: ListTaskFlowCooperatorsRequest): Promise<ListTaskFlowCooperatorsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTaskFlowCooperatorsWithOptions(request, runtime);
  }

  /**
   * Queries the edges of the directed acyclic graph (DAG) for a specified task flow based on multiple conditions.
   * 
   * @remarks
   * This operation is used for multi-condition query. You can call this operation to query the edges of a specified task flow that meet all specified conditions.
   * 
   * @param request - ListTaskFlowEdgesByConditionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListTaskFlowEdgesByConditionResponse
   */
  async listTaskFlowEdgesByConditionWithOptions(request: ListTaskFlowEdgesByConditionRequest, runtime: $Util.RuntimeOptions): Promise<ListTaskFlowEdgesByConditionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.nodeEnd)) {
      query["NodeEnd"] = request.nodeEnd;
    }

    if (!Util.isUnset(request.nodeFrom)) {
      query["NodeFrom"] = request.nodeFrom;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTaskFlowEdgesByCondition",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTaskFlowEdgesByConditionResponse>(await this.callApi(params, req, runtime), new ListTaskFlowEdgesByConditionResponse({}));
  }

  /**
   * Queries the edges of the directed acyclic graph (DAG) for a specified task flow based on multiple conditions.
   * 
   * @remarks
   * This operation is used for multi-condition query. You can call this operation to query the edges of a specified task flow that meet all specified conditions.
   * 
   * @param request - ListTaskFlowEdgesByConditionRequest
   * @returns ListTaskFlowEdgesByConditionResponse
   */
  async listTaskFlowEdgesByCondition(request: ListTaskFlowEdgesByConditionRequest): Promise<ListTaskFlowEdgesByConditionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTaskFlowEdgesByConditionWithOptions(request, runtime);
  }

  /**
   * Queries the execution records of a task flow.
   * 
   * @param request - ListTaskFlowInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListTaskFlowInstanceResponse
   */
  async listTaskFlowInstanceWithOptions(request: ListTaskFlowInstanceRequest, runtime: $Util.RuntimeOptions): Promise<ListTaskFlowInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.pageIndex)) {
      query["PageIndex"] = request.pageIndex;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTimeBegin)) {
      query["StartTimeBegin"] = request.startTimeBegin;
    }

    if (!Util.isUnset(request.startTimeEnd)) {
      query["StartTimeEnd"] = request.startTimeEnd;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.triggerType)) {
      query["TriggerType"] = request.triggerType;
    }

    if (!Util.isUnset(request.useBizDate)) {
      query["UseBizDate"] = request.useBizDate;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTaskFlowInstance",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTaskFlowInstanceResponse>(await this.callApi(params, req, runtime), new ListTaskFlowInstanceResponse({}));
  }

  /**
   * Queries the execution records of a task flow.
   * 
   * @param request - ListTaskFlowInstanceRequest
   * @returns ListTaskFlowInstanceResponse
   */
  async listTaskFlowInstance(request: ListTaskFlowInstanceRequest): Promise<ListTaskFlowInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTaskFlowInstanceWithOptions(request, runtime);
  }

  /**
   * Queries the time variables for a task flow.
   * 
   * @param request - ListTaskFlowTimeVariablesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListTaskFlowTimeVariablesResponse
   */
  async listTaskFlowTimeVariablesWithOptions(request: ListTaskFlowTimeVariablesRequest, runtime: $Util.RuntimeOptions): Promise<ListTaskFlowTimeVariablesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTaskFlowTimeVariables",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTaskFlowTimeVariablesResponse>(await this.callApi(params, req, runtime), new ListTaskFlowTimeVariablesResponse({}));
  }

  /**
   * Queries the time variables for a task flow.
   * 
   * @param request - ListTaskFlowTimeVariablesRequest
   * @returns ListTaskFlowTimeVariablesResponse
   */
  async listTaskFlowTimeVariables(request: ListTaskFlowTimeVariablesRequest): Promise<ListTaskFlowTimeVariablesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTaskFlowTimeVariablesWithOptions(request, runtime);
  }

  /**
   * Queries task flows by page.
   * 
   * @param tmpReq - ListTaskFlowsByPageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListTaskFlowsByPageResponse
   */
  async listTaskFlowsByPageWithOptions(tmpReq: ListTaskFlowsByPageRequest, runtime: $Util.RuntimeOptions): Promise<ListTaskFlowsByPageResponse> {
    Util.validateModel(tmpReq);
    let request = new ListTaskFlowsByPageShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.dagIdList)) {
      request.dagIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dagIdList, "DagIdList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.dagIdListShrink)) {
      query["DagIdList"] = request.dagIdListShrink;
    }

    if (!Util.isUnset(request.pageIndex)) {
      query["PageIndex"] = request.pageIndex;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.scenarioId)) {
      query["ScenarioId"] = request.scenarioId;
    }

    if (!Util.isUnset(request.searchKey)) {
      query["SearchKey"] = request.searchKey;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTaskFlowsByPage",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTaskFlowsByPageResponse>(await this.callApi(params, req, runtime), new ListTaskFlowsByPageResponse({}));
  }

  /**
   * Queries task flows by page.
   * 
   * @param request - ListTaskFlowsByPageRequest
   * @returns ListTaskFlowsByPageResponse
   */
  async listTaskFlowsByPage(request: ListTaskFlowsByPageRequest): Promise<ListTaskFlowsByPageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTaskFlowsByPageWithOptions(request, runtime);
  }

  /**
   * Queries the tasks in a specified task flow.
   * 
   * @param request - ListTasksInTaskFlowRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListTasksInTaskFlowResponse
   */
  async listTasksInTaskFlowWithOptions(request: ListTasksInTaskFlowRequest, runtime: $Util.RuntimeOptions): Promise<ListTasksInTaskFlowResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTasksInTaskFlow",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTasksInTaskFlowResponse>(await this.callApi(params, req, runtime), new ListTasksInTaskFlowResponse({}));
  }

  /**
   * Queries the tasks in a specified task flow.
   * 
   * @param request - ListTasksInTaskFlowRequest
   * @returns ListTasksInTaskFlowResponse
   */
  async listTasksInTaskFlow(request: ListTasksInTaskFlowRequest): Promise<ListTasksInTaskFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTasksInTaskFlowWithOptions(request, runtime);
  }

  /**
   * Queries the permissions of a specific user on a database or a table.
   * 
   * @param request - ListUserPermissionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListUserPermissionsResponse
   */
  async listUserPermissionsWithOptions(request: ListUserPermissionsRequest, runtime: $Util.RuntimeOptions): Promise<ListUserPermissionsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.databaseName)) {
      query["DatabaseName"] = request.databaseName;
    }

    if (!Util.isUnset(request.dbType)) {
      query["DbType"] = request.dbType;
    }

    if (!Util.isUnset(request.envType)) {
      query["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.logic)) {
      query["Logic"] = request.logic;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.permType)) {
      query["PermType"] = request.permType;
    }

    if (!Util.isUnset(request.searchKey)) {
      query["SearchKey"] = request.searchKey;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.userId)) {
      query["UserId"] = request.userId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListUserPermissions",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListUserPermissionsResponse>(await this.callApi(params, req, runtime), new ListUserPermissionsResponse({}));
  }

  /**
   * Queries the permissions of a specific user on a database or a table.
   * 
   * @param request - ListUserPermissionsRequest
   * @returns ListUserPermissionsResponse
   */
  async listUserPermissions(request: ListUserPermissionsRequest): Promise<ListUserPermissionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listUserPermissionsWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - ListUserTenantsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListUserTenantsResponse
   */
  async listUserTenantsWithOptions(request: ListUserTenantsRequest, runtime: $Util.RuntimeOptions): Promise<ListUserTenantsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListUserTenants",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListUserTenantsResponse>(await this.callApi(params, req, runtime), new ListUserTenantsResponse({}));
  }

  /**
   * 
   * 
   * @param request - ListUserTenantsRequest
   * @returns ListUserTenantsResponse
   */
  async listUserTenants(request: ListUserTenantsRequest): Promise<ListUserTenantsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listUserTenantsWithOptions(request, runtime);
  }

  /**
   * Queries the details of users.
   * 
   * @param request - ListUsersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListUsersResponse
   */
  async listUsersWithOptions(request: ListUsersRequest, runtime: $Util.RuntimeOptions): Promise<ListUsersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.role)) {
      query["Role"] = request.role;
    }

    if (!Util.isUnset(request.searchKey)) {
      query["SearchKey"] = request.searchKey;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.userState)) {
      query["UserState"] = request.userState;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListUsers",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListUsersResponse>(await this.callApi(params, req, runtime), new ListUsersResponse({}));
  }

  /**
   * Queries the details of users.
   * 
   * @param request - ListUsersRequest
   * @returns ListUsersResponse
   */
  async listUsers(request: ListUsersRequest): Promise<ListUsersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listUsersWithOptions(request, runtime);
  }

  /**
   * Queries approval nodes.
   * 
   * @param request - ListWorkFlowNodesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListWorkFlowNodesResponse
   */
  async listWorkFlowNodesWithOptions(request: ListWorkFlowNodesRequest, runtime: $Util.RuntimeOptions): Promise<ListWorkFlowNodesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.searchName)) {
      query["SearchName"] = request.searchName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListWorkFlowNodes",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListWorkFlowNodesResponse>(await this.callApi(params, req, runtime), new ListWorkFlowNodesResponse({}));
  }

  /**
   * Queries approval nodes.
   * 
   * @param request - ListWorkFlowNodesRequest
   * @returns ListWorkFlowNodesResponse
   */
  async listWorkFlowNodes(request: ListWorkFlowNodesRequest): Promise<ListWorkFlowNodesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listWorkFlowNodesWithOptions(request, runtime);
  }

  /**
   * Queries approval templates.
   * 
   * @param request - ListWorkFlowTemplatesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListWorkFlowTemplatesResponse
   */
  async listWorkFlowTemplatesWithOptions(request: ListWorkFlowTemplatesRequest, runtime: $Util.RuntimeOptions): Promise<ListWorkFlowTemplatesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.searchName)) {
      query["SearchName"] = request.searchName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListWorkFlowTemplates",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListWorkFlowTemplatesResponse>(await this.callApi(params, req, runtime), new ListWorkFlowTemplatesResponse({}));
  }

  /**
   * Queries approval templates.
   * 
   * @param request - ListWorkFlowTemplatesRequest
   * @returns ListWorkFlowTemplatesResponse
   */
  async listWorkFlowTemplates(request: ListWorkFlowTemplatesRequest): Promise<ListWorkFlowTemplatesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listWorkFlowTemplatesWithOptions(request, runtime);
  }

  /**
   * Sets the status of a task flow to "Successful".
   * 
   * @param request - MakeTaskFlowInstanceSuccessRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns MakeTaskFlowInstanceSuccessResponse
   */
  async makeTaskFlowInstanceSuccessWithOptions(request: MakeTaskFlowInstanceSuccessRequest, runtime: $Util.RuntimeOptions): Promise<MakeTaskFlowInstanceSuccessResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.dagInstanceId)) {
      query["DagInstanceId"] = request.dagInstanceId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "MakeTaskFlowInstanceSuccess",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<MakeTaskFlowInstanceSuccessResponse>(await this.callApi(params, req, runtime), new MakeTaskFlowInstanceSuccessResponse({}));
  }

  /**
   * Sets the status of a task flow to "Successful".
   * 
   * @param request - MakeTaskFlowInstanceSuccessRequest
   * @returns MakeTaskFlowInstanceSuccessResponse
   */
  async makeTaskFlowInstanceSuccess(request: MakeTaskFlowInstanceSuccessRequest): Promise<MakeTaskFlowInstanceSuccessResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.makeTaskFlowInstanceSuccessWithOptions(request, runtime);
  }

  /**
   * Modifies the SQL script that is submitted by using a data change ticket.
   * 
   * @param request - ModifyDataCorrectExecSQLRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyDataCorrectExecSQLResponse
   */
  async modifyDataCorrectExecSQLWithOptions(request: ModifyDataCorrectExecSQLRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDataCorrectExecSQLResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.execSQL)) {
      query["ExecSQL"] = request.execSQL;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyDataCorrectExecSQL",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyDataCorrectExecSQLResponse>(await this.callApi(params, req, runtime), new ModifyDataCorrectExecSQLResponse({}));
  }

  /**
   * Modifies the SQL script that is submitted by using a data change ticket.
   * 
   * @param request - ModifyDataCorrectExecSQLRequest
   * @returns ModifyDataCorrectExecSQLResponse
   */
  async modifyDataCorrectExecSQL(request: ModifyDataCorrectExecSQLRequest): Promise<ModifyDataCorrectExecSQLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDataCorrectExecSQLWithOptions(request, runtime);
  }

  /**
   * Modifies the masking rule bound to a specified field.
   * 
   * @param request - ModifyDesensitizationStrategyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyDesensitizationStrategyResponse
   */
  async modifyDesensitizationStrategyWithOptions(request: ModifyDesensitizationStrategyRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDesensitizationStrategyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.columnName)) {
      query["ColumnName"] = request.columnName;
    }

    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.isDefault)) {
      query["IsDefault"] = request.isDefault;
    }

    if (!Util.isUnset(request.isLogic)) {
      query["IsLogic"] = request.isLogic;
    }

    if (!Util.isUnset(request.isReset)) {
      query["IsReset"] = request.isReset;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.schemaName)) {
      query["SchemaName"] = request.schemaName;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyDesensitizationStrategy",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyDesensitizationStrategyResponse>(await this.callApi(params, req, runtime), new ModifyDesensitizationStrategyResponse({}));
  }

  /**
   * Modifies the masking rule bound to a specified field.
   * 
   * @param request - ModifyDesensitizationStrategyRequest
   * @returns ModifyDesensitizationStrategyResponse
   */
  async modifyDesensitizationStrategy(request: ModifyDesensitizationStrategyRequest): Promise<ModifyDesensitizationStrategyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDesensitizationStrategyWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - ModifyInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyInstanceResponse
   */
  async modifyInstanceWithOptions(request: ModifyInstanceRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dataLinkName)) {
      query["DataLinkName"] = request.dataLinkName;
    }

    if (!Util.isUnset(request.databasePassword)) {
      query["DatabasePassword"] = request.databasePassword;
    }

    if (!Util.isUnset(request.databaseUser)) {
      query["DatabaseUser"] = request.databaseUser;
    }

    if (!Util.isUnset(request.dbaId)) {
      query["DbaId"] = request.dbaId;
    }

    if (!Util.isUnset(request.ddlOnline)) {
      query["DdlOnline"] = request.ddlOnline;
    }

    if (!Util.isUnset(request.ecsInstanceId)) {
      query["EcsInstanceId"] = request.ecsInstanceId;
    }

    if (!Util.isUnset(request.ecsRegion)) {
      query["EcsRegion"] = request.ecsRegion;
    }

    if (!Util.isUnset(request.enableSellCommon)) {
      query["EnableSellCommon"] = request.enableSellCommon;
    }

    if (!Util.isUnset(request.enableSellSitd)) {
      query["EnableSellSitd"] = request.enableSellSitd;
    }

    if (!Util.isUnset(request.enableSellStable)) {
      query["EnableSellStable"] = request.enableSellStable;
    }

    if (!Util.isUnset(request.enableSellTrust)) {
      query["EnableSellTrust"] = request.enableSellTrust;
    }

    if (!Util.isUnset(request.envType)) {
      query["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.exportTimeout)) {
      query["ExportTimeout"] = request.exportTimeout;
    }

    if (!Util.isUnset(request.host)) {
      query["Host"] = request.host;
    }

    if (!Util.isUnset(request.instanceAlias)) {
      query["InstanceAlias"] = request.instanceAlias;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.instanceSource)) {
      query["InstanceSource"] = request.instanceSource;
    }

    if (!Util.isUnset(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!Util.isUnset(request.networkType)) {
      query["NetworkType"] = request.networkType;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.queryTimeout)) {
      query["QueryTimeout"] = request.queryTimeout;
    }

    if (!Util.isUnset(request.safeRule)) {
      query["SafeRule"] = request.safeRule;
    }

    if (!Util.isUnset(request.sid)) {
      query["Sid"] = request.sid;
    }

    if (!Util.isUnset(request.skipTest)) {
      query["SkipTest"] = request.skipTest;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.templateType)) {
      query["TemplateType"] = request.templateType;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.useDsql)) {
      query["UseDsql"] = request.useDsql;
    }

    if (!Util.isUnset(request.useSsl)) {
      query["UseSsl"] = request.useSsl;
    }

    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyInstance",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyInstanceResponse>(await this.callApi(params, req, runtime), new ModifyInstanceResponse({}));
  }

  /**
   * 
   * 
   * @param request - ModifyInstanceRequest
   * @returns ModifyInstanceResponse
   */
  async modifyInstance(request: ModifyInstanceRequest): Promise<ModifyInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceWithOptions(request, runtime);
  }

  /**
   * Migrates a task flow to a specified business scenario.
   * 
   * @param request - MoveTaskFlowToScenarioRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns MoveTaskFlowToScenarioResponse
   */
  async moveTaskFlowToScenarioWithOptions(request: MoveTaskFlowToScenarioRequest, runtime: $Util.RuntimeOptions): Promise<MoveTaskFlowToScenarioResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.scenarioId)) {
      query["ScenarioId"] = request.scenarioId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "MoveTaskFlowToScenario",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<MoveTaskFlowToScenarioResponse>(await this.callApi(params, req, runtime), new MoveTaskFlowToScenarioResponse({}));
  }

  /**
   * Migrates a task flow to a specified business scenario.
   * 
   * @param request - MoveTaskFlowToScenarioRequest
   * @returns MoveTaskFlowToScenarioResponse
   */
  async moveTaskFlowToScenario(request: MoveTaskFlowToScenarioRequest): Promise<MoveTaskFlowToScenarioResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.moveTaskFlowToScenarioWithOptions(request, runtime);
  }

  /**
   * Unpublishes a published task flow.
   * 
   * @param request - OfflineTaskFlowRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns OfflineTaskFlowResponse
   */
  async offlineTaskFlowWithOptions(request: OfflineTaskFlowRequest, runtime: $Util.RuntimeOptions): Promise<OfflineTaskFlowResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "OfflineTaskFlow",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<OfflineTaskFlowResponse>(await this.callApi(params, req, runtime), new OfflineTaskFlowResponse({}));
  }

  /**
   * Unpublishes a published task flow.
   * 
   * @param request - OfflineTaskFlowRequest
   * @returns OfflineTaskFlowResponse
   */
  async offlineTaskFlow(request: OfflineTaskFlowRequest): Promise<OfflineTaskFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.offlineTaskFlowWithOptions(request, runtime);
  }

  /**
   * Pauses a SQL task for data change.
   * 
   * @remarks
   * You can call this operation only for database instances that are managed in Security Collaboration mode.
   * 
   * @param request - PauseDataCorrectSQLJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PauseDataCorrectSQLJobResponse
   */
  async pauseDataCorrectSQLJobWithOptions(request: PauseDataCorrectSQLJobRequest, runtime: $Util.RuntimeOptions): Promise<PauseDataCorrectSQLJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PauseDataCorrectSQLJob",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PauseDataCorrectSQLJobResponse>(await this.callApi(params, req, runtime), new PauseDataCorrectSQLJobResponse({}));
  }

  /**
   * Pauses a SQL task for data change.
   * 
   * @remarks
   * You can call this operation only for database instances that are managed in Security Collaboration mode.
   * 
   * @param request - PauseDataCorrectSQLJobRequest
   * @returns PauseDataCorrectSQLJobResponse
   */
  async pauseDataCorrectSQLJob(request: PauseDataCorrectSQLJobRequest): Promise<PauseDataCorrectSQLJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.pauseDataCorrectSQLJobWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - PreviewWorkflowRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PreviewWorkflowResponse
   */
  async previewWorkflowWithOptions(request: PreviewWorkflowRequest, runtime: $Util.RuntimeOptions): Promise<PreviewWorkflowResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PreviewWorkflow",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PreviewWorkflowResponse>(await this.callApi(params, req, runtime), new PreviewWorkflowResponse({}));
  }

  /**
   * 
   * 
   * @param request - PreviewWorkflowRequest
   * @returns PreviewWorkflowResponse
   */
  async previewWorkflow(request: PreviewWorkflowRequest): Promise<PreviewWorkflowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.previewWorkflowWithOptions(request, runtime);
  }

  /**
   * Publishes and deploys a task flow.
   * 
   * @param request - PublishAndDeployTaskFlowRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PublishAndDeployTaskFlowResponse
   */
  async publishAndDeployTaskFlowWithOptions(request: PublishAndDeployTaskFlowRequest, runtime: $Util.RuntimeOptions): Promise<PublishAndDeployTaskFlowResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.versionComments)) {
      query["VersionComments"] = request.versionComments;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PublishAndDeployTaskFlow",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PublishAndDeployTaskFlowResponse>(await this.callApi(params, req, runtime), new PublishAndDeployTaskFlowResponse({}));
  }

  /**
   * Publishes and deploys a task flow.
   * 
   * @param request - PublishAndDeployTaskFlowRequest
   * @returns PublishAndDeployTaskFlowResponse
   */
  async publishAndDeployTaskFlow(request: PublishAndDeployTaskFlowRequest): Promise<PublishAndDeployTaskFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.publishAndDeployTaskFlowWithOptions(request, runtime);
  }

  /**
   * Queries the download and parsing progress of data tracking logs.
   * 
   * @param request - QueryDataTrackResultDownloadStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryDataTrackResultDownloadStatusResponse
   */
  async queryDataTrackResultDownloadStatusWithOptions(request: QueryDataTrackResultDownloadStatusRequest, runtime: $Util.RuntimeOptions): Promise<QueryDataTrackResultDownloadStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.downloadKeyId)) {
      query["DownloadKeyId"] = request.downloadKeyId;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDataTrackResultDownloadStatus",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDataTrackResultDownloadStatusResponse>(await this.callApi(params, req, runtime), new QueryDataTrackResultDownloadStatusResponse({}));
  }

  /**
   * Queries the download and parsing progress of data tracking logs.
   * 
   * @param request - QueryDataTrackResultDownloadStatusRequest
   * @returns QueryDataTrackResultDownloadStatusResponse
   */
  async queryDataTrackResultDownloadStatus(request: QueryDataTrackResultDownloadStatusRequest): Promise<QueryDataTrackResultDownloadStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDataTrackResultDownloadStatusWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - ReDeployLhDagVersionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ReDeployLhDagVersionResponse
   */
  async reDeployLhDagVersionWithOptions(request: ReDeployLhDagVersionRequest, runtime: $Util.RuntimeOptions): Promise<ReDeployLhDagVersionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.dagVersion)) {
      query["DagVersion"] = request.dagVersion;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ReDeployLhDagVersion",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ReDeployLhDagVersionResponse>(await this.callApi(params, req, runtime), new ReDeployLhDagVersionResponse({}));
  }

  /**
   * 
   * 
   * @param request - ReDeployLhDagVersionRequest
   * @returns ReDeployLhDagVersionResponse
   */
  async reDeployLhDagVersion(request: ReDeployLhDagVersionRequest): Promise<ReDeployLhDagVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.reDeployLhDagVersionWithOptions(request, runtime);
  }

  /**
   * Reruns a task flow instance.
   * 
   * @param request - ReRunTaskFlowInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ReRunTaskFlowInstanceResponse
   */
  async reRunTaskFlowInstanceWithOptions(request: ReRunTaskFlowInstanceRequest, runtime: $Util.RuntimeOptions): Promise<ReRunTaskFlowInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.dagInstanceId)) {
      query["DagInstanceId"] = request.dagInstanceId;
    }

    if (!Util.isUnset(request.dagVersion)) {
      query["DagVersion"] = request.dagVersion;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ReRunTaskFlowInstance",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ReRunTaskFlowInstanceResponse>(await this.callApi(params, req, runtime), new ReRunTaskFlowInstanceResponse({}));
  }

  /**
   * Reruns a task flow instance.
   * 
   * @param request - ReRunTaskFlowInstanceRequest
   * @returns ReRunTaskFlowInstanceResponse
   */
  async reRunTaskFlowInstance(request: ReRunTaskFlowInstanceRequest): Promise<ReRunTaskFlowInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.reRunTaskFlowInstanceWithOptions(request, runtime);
  }

  /**
   * Unsubscribes from a pay-as-you-go Data Management (DMS) resource.
   * 
   * @param request - RefundPayAsYouGoOrderRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RefundPayAsYouGoOrderResponse
   */
  async refundPayAsYouGoOrderWithOptions(request: RefundPayAsYouGoOrderRequest, runtime: $Util.RuntimeOptions): Promise<RefundPayAsYouGoOrderResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RefundPayAsYouGoOrder",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RefundPayAsYouGoOrderResponse>(await this.callApi(params, req, runtime), new RefundPayAsYouGoOrderResponse({}));
  }

  /**
   * Unsubscribes from a pay-as-you-go Data Management (DMS) resource.
   * 
   * @param request - RefundPayAsYouGoOrderRequest
   * @returns RefundPayAsYouGoOrderResponse
   */
  async refundPayAsYouGoOrder(request: RefundPayAsYouGoOrderRequest): Promise<RefundPayAsYouGoOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.refundPayAsYouGoOrderWithOptions(request, runtime);
  }

  /**
   * Registers a database instance in Data Management (DMS).
   * 
   * @remarks
   * Prerequisites: You are a DMS administrator or a database administrator (DBA). You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to query your user role from the RoleIdList parameter that is returned.
   * 
   * @param request - RegisterInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RegisterInstanceResponse
   */
  async registerInstanceWithOptions(request: RegisterInstanceRequest, runtime: $Util.RuntimeOptions): Promise<RegisterInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dataLinkName)) {
      query["DataLinkName"] = request.dataLinkName;
    }

    if (!Util.isUnset(request.databasePassword)) {
      query["DatabasePassword"] = request.databasePassword;
    }

    if (!Util.isUnset(request.databaseUser)) {
      query["DatabaseUser"] = request.databaseUser;
    }

    if (!Util.isUnset(request.dbaUid)) {
      query["DbaUid"] = request.dbaUid;
    }

    if (!Util.isUnset(request.dbaUidByString)) {
      query["DbaUidByString"] = request.dbaUidByString;
    }

    if (!Util.isUnset(request.ddlOnline)) {
      query["DdlOnline"] = request.ddlOnline;
    }

    if (!Util.isUnset(request.ecsInstanceId)) {
      query["EcsInstanceId"] = request.ecsInstanceId;
    }

    if (!Util.isUnset(request.ecsRegion)) {
      query["EcsRegion"] = request.ecsRegion;
    }

    if (!Util.isUnset(request.enableSellSitd)) {
      query["EnableSellSitd"] = request.enableSellSitd;
    }

    if (!Util.isUnset(request.envType)) {
      query["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.exportTimeout)) {
      query["ExportTimeout"] = request.exportTimeout;
    }

    if (!Util.isUnset(request.host)) {
      query["Host"] = request.host;
    }

    if (!Util.isUnset(request.instanceAlias)) {
      query["InstanceAlias"] = request.instanceAlias;
    }

    if (!Util.isUnset(request.instanceSource)) {
      query["InstanceSource"] = request.instanceSource;
    }

    if (!Util.isUnset(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!Util.isUnset(request.networkType)) {
      query["NetworkType"] = request.networkType;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.queryTimeout)) {
      query["QueryTimeout"] = request.queryTimeout;
    }

    if (!Util.isUnset(request.safeRule)) {
      query["SafeRule"] = request.safeRule;
    }

    if (!Util.isUnset(request.sid)) {
      query["Sid"] = request.sid;
    }

    if (!Util.isUnset(request.skipTest)) {
      query["SkipTest"] = request.skipTest;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.templateType)) {
      query["TemplateType"] = request.templateType;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.useDsql)) {
      query["UseDsql"] = request.useDsql;
    }

    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RegisterInstance",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RegisterInstanceResponse>(await this.callApi(params, req, runtime), new RegisterInstanceResponse({}));
  }

  /**
   * Registers a database instance in Data Management (DMS).
   * 
   * @remarks
   * Prerequisites: You are a DMS administrator or a database administrator (DBA). You can call the [ListUsers](https://help.aliyun.com/document_detail/141938.html) or [GetUser](https://help.aliyun.com/document_detail/147098.html) operation to query your user role from the RoleIdList parameter that is returned.
   * 
   * @param request - RegisterInstanceRequest
   * @returns RegisterInstanceResponse
   */
  async registerInstance(request: RegisterInstanceRequest): Promise<RegisterInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.registerInstanceWithOptions(request, runtime);
  }

  /**
   * Registers a user for your enterprise.
   * 
   * @remarks
   * If you are an **administrator** in Data Management (DMS), you can call this operation to register a user for your enterprise. To view users that are assigned the administrator role, perform the following steps: Log on to the DMS console. In the top navigation bar, click O&M. In the left-side navigation pane, click User.
   * 
   * @param request - RegisterUserRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RegisterUserResponse
   */
  async registerUserWithOptions(request: RegisterUserRequest, runtime: $Util.RuntimeOptions): Promise<RegisterUserResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.mobile)) {
      query["Mobile"] = request.mobile;
    }

    if (!Util.isUnset(request.roleNames)) {
      query["RoleNames"] = request.roleNames;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.uid)) {
      query["Uid"] = request.uid;
    }

    if (!Util.isUnset(request.userNick)) {
      query["UserNick"] = request.userNick;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RegisterUser",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RegisterUserResponse>(await this.callApi(params, req, runtime), new RegisterUserResponse({}));
  }

  /**
   * Registers a user for your enterprise.
   * 
   * @remarks
   * If you are an **administrator** in Data Management (DMS), you can call this operation to register a user for your enterprise. To view users that are assigned the administrator role, perform the following steps: Log on to the DMS console. In the top navigation bar, click O&M. In the left-side navigation pane, click User.
   * 
   * @param request - RegisterUserRequest
   * @returns RegisterUserResponse
   */
  async registerUser(request: RegisterUserRequest): Promise<RegisterUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.registerUserWithOptions(request, runtime);
  }

  /**
   * Reruns a failed SQL task for data change.
   * 
   * @param request - RestartDataCorrectSQLJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RestartDataCorrectSQLJobResponse
   */
  async restartDataCorrectSQLJobWithOptions(request: RestartDataCorrectSQLJobRequest, runtime: $Util.RuntimeOptions): Promise<RestartDataCorrectSQLJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.jobId)) {
      query["JobId"] = request.jobId;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RestartDataCorrectSQLJob",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RestartDataCorrectSQLJobResponse>(await this.callApi(params, req, runtime), new RestartDataCorrectSQLJobResponse({}));
  }

  /**
   * Reruns a failed SQL task for data change.
   * 
   * @param request - RestartDataCorrectSQLJobRequest
   * @returns RestartDataCorrectSQLJobResponse
   */
  async restartDataCorrectSQLJob(request: RestartDataCorrectSQLJobRequest): Promise<RestartDataCorrectSQLJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.restartDataCorrectSQLJobWithOptions(request, runtime);
  }

  /**
   * Resumes a suspended task flow.
   * 
   * @remarks
   * You can call this operation only for task flows that are suspended.
   * 
   * @param request - ResumeTaskFlowInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ResumeTaskFlowInstanceResponse
   */
  async resumeTaskFlowInstanceWithOptions(request: ResumeTaskFlowInstanceRequest, runtime: $Util.RuntimeOptions): Promise<ResumeTaskFlowInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.dagInstanceId)) {
      query["DagInstanceId"] = request.dagInstanceId;
    }

    if (!Util.isUnset(request.dagVersion)) {
      query["DagVersion"] = request.dagVersion;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ResumeTaskFlowInstance",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ResumeTaskFlowInstanceResponse>(await this.callApi(params, req, runtime), new ResumeTaskFlowInstanceResponse({}));
  }

  /**
   * Resumes a suspended task flow.
   * 
   * @remarks
   * You can call this operation only for task flows that are suspended.
   * 
   * @param request - ResumeTaskFlowInstanceRequest
   * @returns ResumeTaskFlowInstanceResponse
   */
  async resumeTaskFlowInstance(request: ResumeTaskFlowInstanceRequest): Promise<ResumeTaskFlowInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.resumeTaskFlowInstanceWithOptions(request, runtime);
  }

  /**
   * Reruns the precheck for a data change ticket.
   * 
   * @param request - RetryDataCorrectPreCheckRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RetryDataCorrectPreCheckResponse
   */
  async retryDataCorrectPreCheckWithOptions(request: RetryDataCorrectPreCheckRequest, runtime: $Util.RuntimeOptions): Promise<RetryDataCorrectPreCheckResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RetryDataCorrectPreCheck",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RetryDataCorrectPreCheckResponse>(await this.callApi(params, req, runtime), new RetryDataCorrectPreCheckResponse({}));
  }

  /**
   * Reruns the precheck for a data change ticket.
   * 
   * @param request - RetryDataCorrectPreCheckRequest
   * @returns RetryDataCorrectPreCheckResponse
   */
  async retryDataCorrectPreCheck(request: RetryDataCorrectPreCheckRequest): Promise<RetryDataCorrectPreCheckResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.retryDataCorrectPreCheckWithOptions(request, runtime);
  }

  /**
   * Revokes permissions on resources from Data Management (DMS) users by using a permission template.
   * 
   * @remarks
   * You must be a database administrator (DBA) or a DMS administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
   * 
   * @param request - RevokeTemplateAuthorityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RevokeTemplateAuthorityResponse
   */
  async revokeTemplateAuthorityWithOptions(request: RevokeTemplateAuthorityRequest, runtime: $Util.RuntimeOptions): Promise<RevokeTemplateAuthorityResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.userIds)) {
      query["UserIds"] = request.userIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RevokeTemplateAuthority",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RevokeTemplateAuthorityResponse>(await this.callApi(params, req, runtime), new RevokeTemplateAuthorityResponse({}));
  }

  /**
   * Revokes permissions on resources from Data Management (DMS) users by using a permission template.
   * 
   * @remarks
   * You must be a database administrator (DBA) or a DMS administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
   * 
   * @param request - RevokeTemplateAuthorityRequest
   * @returns RevokeTemplateAuthorityResponse
   */
  async revokeTemplateAuthority(request: RevokeTemplateAuthorityRequest): Promise<RevokeTemplateAuthorityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.revokeTemplateAuthorityWithOptions(request, runtime);
  }

  /**
   * Revokes a permission on a resource from a user.
   * 
   * @param request - RevokeUserPermissionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RevokeUserPermissionResponse
   */
  async revokeUserPermissionWithOptions(request: RevokeUserPermissionRequest, runtime: $Util.RuntimeOptions): Promise<RevokeUserPermissionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.dsType)) {
      query["DsType"] = request.dsType;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.logic)) {
      query["Logic"] = request.logic;
    }

    if (!Util.isUnset(request.permTypes)) {
      query["PermTypes"] = request.permTypes;
    }

    if (!Util.isUnset(request.tableId)) {
      query["TableId"] = request.tableId;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.userAccessId)) {
      query["UserAccessId"] = request.userAccessId;
    }

    if (!Util.isUnset(request.userId)) {
      query["UserId"] = request.userId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RevokeUserPermission",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RevokeUserPermissionResponse>(await this.callApi(params, req, runtime), new RevokeUserPermissionResponse({}));
  }

  /**
   * Revokes a permission on a resource from a user.
   * 
   * @param request - RevokeUserPermissionRequest
   * @returns RevokeUserPermissionResponse
   */
  async revokeUserPermission(request: RevokeUserPermissionRequest): Promise<RevokeUserPermissionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.revokeUserPermissionWithOptions(request, runtime);
  }

  /**
   * Searches for the parsing result of a data tracking task.
   * 
   * @param tmpReq - SearchDataTrackResultRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SearchDataTrackResultResponse
   */
  async searchDataTrackResultWithOptions(tmpReq: SearchDataTrackResultRequest, runtime: $Util.RuntimeOptions): Promise<SearchDataTrackResultResponse> {
    Util.validateModel(tmpReq);
    let request = new SearchDataTrackResultShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.columnFilter)) {
      request.columnFilterShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.columnFilter, "ColumnFilter", "json");
    }

    if (!Util.isUnset(tmpReq.filterTableList)) {
      request.filterTableListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterTableList, "FilterTableList", "json");
    }

    if (!Util.isUnset(tmpReq.filterTypeList)) {
      request.filterTypeListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterTypeList, "FilterTypeList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.columnFilterShrink)) {
      query["ColumnFilter"] = request.columnFilterShrink;
    }

    if (!Util.isUnset(request.filterEndTime)) {
      query["FilterEndTime"] = request.filterEndTime;
    }

    if (!Util.isUnset(request.filterStartTime)) {
      query["FilterStartTime"] = request.filterStartTime;
    }

    if (!Util.isUnset(request.filterTableListShrink)) {
      query["FilterTableList"] = request.filterTableListShrink;
    }

    if (!Util.isUnset(request.filterTypeListShrink)) {
      query["FilterTypeList"] = request.filterTypeListShrink;
    }

    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SearchDataTrackResult",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SearchDataTrackResultResponse>(await this.callApi(params, req, runtime), new SearchDataTrackResultResponse({}));
  }

  /**
   * Searches for the parsing result of a data tracking task.
   * 
   * @param request - SearchDataTrackResultRequest
   * @returns SearchDataTrackResultResponse
   */
  async searchDataTrackResult(request: SearchDataTrackResultRequest): Promise<SearchDataTrackResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchDataTrackResultWithOptions(request, runtime);
  }

  /**
   * Queries the details of the databases.
   * 
   * @param request - SearchDatabaseRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SearchDatabaseResponse
   */
  async searchDatabaseWithOptions(request: SearchDatabaseRequest, runtime: $Util.RuntimeOptions): Promise<SearchDatabaseResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbType)) {
      query["DbType"] = request.dbType;
    }

    if (!Util.isUnset(request.envType)) {
      query["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchKey)) {
      query["SearchKey"] = request.searchKey;
    }

    if (!Util.isUnset(request.searchRange)) {
      query["SearchRange"] = request.searchRange;
    }

    if (!Util.isUnset(request.searchTarget)) {
      query["SearchTarget"] = request.searchTarget;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SearchDatabase",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SearchDatabaseResponse>(await this.callApi(params, req, runtime), new SearchDatabaseResponse({}));
  }

  /**
   * Queries the details of the databases.
   * 
   * @param request - SearchDatabaseRequest
   * @returns SearchDatabaseResponse
   */
  async searchDatabase(request: SearchDatabaseRequest): Promise<SearchDatabaseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchDatabaseWithOptions(request, runtime);
  }

  /**
   * Queries detailed information about tables.
   * 
   * @remarks
   * You can call this operation only for database instances that are managed in Security Collaboration mode.
   * 
   * @param request - SearchTableRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SearchTableResponse
   */
  async searchTableWithOptions(request: SearchTableRequest, runtime: $Util.RuntimeOptions): Promise<SearchTableResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbType)) {
      query["DbType"] = request.dbType;
    }

    if (!Util.isUnset(request.envType)) {
      query["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.returnGuid)) {
      query["ReturnGuid"] = request.returnGuid;
    }

    if (!Util.isUnset(request.searchKey)) {
      query["SearchKey"] = request.searchKey;
    }

    if (!Util.isUnset(request.searchRange)) {
      query["SearchRange"] = request.searchRange;
    }

    if (!Util.isUnset(request.searchTarget)) {
      query["SearchTarget"] = request.searchTarget;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SearchTable",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SearchTableResponse>(await this.callApi(params, req, runtime), new SearchTableResponse({}));
  }

  /**
   * Queries detailed information about tables.
   * 
   * @remarks
   * You can call this operation only for database instances that are managed in Security Collaboration mode.
   * 
   * @param request - SearchTableRequest
   * @returns SearchTableResponse
   */
  async searchTable(request: SearchTableRequest): Promise<SearchTableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchTableWithOptions(request, runtime);
  }

  /**
   * Configures the owner of an instance, a database, or a table.
   * 
   * @param request - SetOwnersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetOwnersResponse
   */
  async setOwnersWithOptions(request: SetOwnersRequest, runtime: $Util.RuntimeOptions): Promise<SetOwnersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerIds)) {
      query["OwnerIds"] = request.ownerIds;
    }

    if (!Util.isUnset(request.ownerType)) {
      query["OwnerType"] = request.ownerType;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetOwners",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetOwnersResponse>(await this.callApi(params, req, runtime), new SetOwnersResponse({}));
  }

  /**
   * Configures the owner of an instance, a database, or a table.
   * 
   * @param request - SetOwnersRequest
   * @returns SetOwnersResponse
   */
  async setOwners(request: SetOwnersRequest): Promise<SetOwnersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setOwnersWithOptions(request, runtime);
  }

  /**
   * Skips the verification on the number of rows in the precheck for data change.
   * 
   * @param request - SkipDataCorrectRowCheckRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SkipDataCorrectRowCheckResponse
   */
  async skipDataCorrectRowCheckWithOptions(request: SkipDataCorrectRowCheckRequest, runtime: $Util.RuntimeOptions): Promise<SkipDataCorrectRowCheckResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.reason)) {
      query["Reason"] = request.reason;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SkipDataCorrectRowCheck",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SkipDataCorrectRowCheckResponse>(await this.callApi(params, req, runtime), new SkipDataCorrectRowCheckResponse({}));
  }

  /**
   * Skips the verification on the number of rows in the precheck for data change.
   * 
   * @param request - SkipDataCorrectRowCheckRequest
   * @returns SkipDataCorrectRowCheckResponse
   */
  async skipDataCorrectRowCheck(request: SkipDataCorrectRowCheckRequest): Promise<SkipDataCorrectRowCheckResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.skipDataCorrectRowCheckWithOptions(request, runtime);
  }

  /**
   * Stops a task flow instance.
   * 
   * @param request - StopTaskFlowInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StopTaskFlowInstanceResponse
   */
  async stopTaskFlowInstanceWithOptions(request: StopTaskFlowInstanceRequest, runtime: $Util.RuntimeOptions): Promise<StopTaskFlowInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.dagInstanceId)) {
      query["DagInstanceId"] = request.dagInstanceId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StopTaskFlowInstance",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StopTaskFlowInstanceResponse>(await this.callApi(params, req, runtime), new StopTaskFlowInstanceResponse({}));
  }

  /**
   * Stops a task flow instance.
   * 
   * @param request - StopTaskFlowInstanceRequest
   * @returns StopTaskFlowInstanceResponse
   */
  async stopTaskFlowInstance(request: StopTaskFlowInstanceRequest): Promise<StopTaskFlowInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopTaskFlowInstanceWithOptions(request, runtime);
  }

  /**
   * Submits a ticket for approval.
   * 
   * @param request - SubmitOrderApprovalRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SubmitOrderApprovalResponse
   */
  async submitOrderApprovalWithOptions(request: SubmitOrderApprovalRequest, runtime: $Util.RuntimeOptions): Promise<SubmitOrderApprovalResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.realLoginUserUid)) {
      query["RealLoginUserUid"] = request.realLoginUserUid;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SubmitOrderApproval",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SubmitOrderApprovalResponse>(await this.callApi(params, req, runtime), new SubmitOrderApprovalResponse({}));
  }

  /**
   * Submits a ticket for approval.
   * 
   * @param request - SubmitOrderApprovalRequest
   * @returns SubmitOrderApprovalResponse
   */
  async submitOrderApproval(request: SubmitOrderApprovalRequest): Promise<SubmitOrderApprovalResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitOrderApprovalWithOptions(request, runtime);
  }

  /**
   * Submits a schema synchronization ticket for approval.
   * 
   * @param request - SubmitStructSyncOrderApprovalRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SubmitStructSyncOrderApprovalResponse
   */
  async submitStructSyncOrderApprovalWithOptions(request: SubmitStructSyncOrderApprovalRequest, runtime: $Util.RuntimeOptions): Promise<SubmitStructSyncOrderApprovalResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.orderId)) {
      query["OrderId"] = request.orderId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SubmitStructSyncOrderApproval",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SubmitStructSyncOrderApprovalResponse>(await this.callApi(params, req, runtime), new SubmitStructSyncOrderApprovalResponse({}));
  }

  /**
   * Submits a schema synchronization ticket for approval.
   * 
   * @param request - SubmitStructSyncOrderApprovalRequest
   * @returns SubmitStructSyncOrderApprovalResponse
   */
  async submitStructSyncOrderApproval(request: SubmitStructSyncOrderApprovalRequest): Promise<SubmitStructSyncOrderApprovalResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitStructSyncOrderApprovalWithOptions(request, runtime);
  }

  /**
   * Suspends a task flow instance.
   * 
   * @param request - SuspendTaskFlowInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SuspendTaskFlowInstanceResponse
   */
  async suspendTaskFlowInstanceWithOptions(request: SuspendTaskFlowInstanceRequest, runtime: $Util.RuntimeOptions): Promise<SuspendTaskFlowInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.dagInstanceId)) {
      query["DagInstanceId"] = request.dagInstanceId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SuspendTaskFlowInstance",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SuspendTaskFlowInstanceResponse>(await this.callApi(params, req, runtime), new SuspendTaskFlowInstanceResponse({}));
  }

  /**
   * Suspends a task flow instance.
   * 
   * @param request - SuspendTaskFlowInstanceRequest
   * @returns SuspendTaskFlowInstanceResponse
   */
  async suspendTaskFlowInstance(request: SuspendTaskFlowInstanceRequest): Promise<SuspendTaskFlowInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.suspendTaskFlowInstanceWithOptions(request, runtime);
  }

  /**
   * Synchronizes the metadata of a database.
   * 
   * @param request - SyncDatabaseMetaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SyncDatabaseMetaResponse
   */
  async syncDatabaseMetaWithOptions(request: SyncDatabaseMetaRequest, runtime: $Util.RuntimeOptions): Promise<SyncDatabaseMetaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dbId)) {
      query["DbId"] = request.dbId;
    }

    if (!Util.isUnset(request.logic)) {
      query["Logic"] = request.logic;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SyncDatabaseMeta",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SyncDatabaseMetaResponse>(await this.callApi(params, req, runtime), new SyncDatabaseMetaResponse({}));
  }

  /**
   * Synchronizes the metadata of a database.
   * 
   * @param request - SyncDatabaseMetaRequest
   * @returns SyncDatabaseMetaResponse
   */
  async syncDatabaseMeta(request: SyncDatabaseMetaRequest): Promise<SyncDatabaseMetaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.syncDatabaseMetaWithOptions(request, runtime);
  }

  /**
   * Synchronizes the metadata of all databases in a database instance.
   * 
   * @remarks
   * You can call this operation only for database instances whose control mode is Security Collaboration.
   * 
   * @param request - SyncInstanceMetaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SyncInstanceMetaResponse
   */
  async syncInstanceMetaWithOptions(request: SyncInstanceMetaRequest, runtime: $Util.RuntimeOptions): Promise<SyncInstanceMetaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ignoreTable)) {
      query["IgnoreTable"] = request.ignoreTable;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SyncInstanceMeta",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SyncInstanceMetaResponse>(await this.callApi(params, req, runtime), new SyncInstanceMetaResponse({}));
  }

  /**
   * Synchronizes the metadata of all databases in a database instance.
   * 
   * @remarks
   * You can call this operation only for database instances whose control mode is Security Collaboration.
   * 
   * @param request - SyncInstanceMetaRequest
   * @returns SyncInstanceMetaResponse
   */
  async syncInstanceMeta(request: SyncInstanceMetaRequest): Promise<SyncInstanceMetaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.syncInstanceMetaWithOptions(request, runtime);
  }

  /**
   * Modifies a permission template.
   * 
   * @remarks
   * You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
   * 
   * @param request - UpdateAuthorityTemplateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateAuthorityTemplateResponse
   */
  async updateAuthorityTemplateWithOptions(request: UpdateAuthorityTemplateRequest, runtime: $Util.RuntimeOptions): Promise<UpdateAuthorityTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateAuthorityTemplate",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateAuthorityTemplateResponse>(await this.callApi(params, req, runtime), new UpdateAuthorityTemplateResponse({}));
  }

  /**
   * Modifies a permission template.
   * 
   * @remarks
   * You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](https://help.aliyun.com/document_detail/324212.html).
   * 
   * @param request - UpdateAuthorityTemplateRequest
   * @returns UpdateAuthorityTemplateResponse
   */
  async updateAuthorityTemplate(request: UpdateAuthorityTemplateRequest): Promise<UpdateAuthorityTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateAuthorityTemplateWithOptions(request, runtime);
  }

  /**
   * Updates the information about a database instance and checks the connectivity of the database instance.
   * 
   * @remarks
   * Before you call the UpdateInstance operation, call the [GetInstance](https://help.aliyun.com/document_detail/141567.html) or [ListInstances](https://help.aliyun.com/document_detail/141936.html) operation to obtain the complete information about the instance.
   * 
   * @param request - UpdateInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateInstanceResponse
   */
  async updateInstanceWithOptions(request: UpdateInstanceRequest, runtime: $Util.RuntimeOptions): Promise<UpdateInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dataLinkName)) {
      query["DataLinkName"] = request.dataLinkName;
    }

    if (!Util.isUnset(request.databasePassword)) {
      query["DatabasePassword"] = request.databasePassword;
    }

    if (!Util.isUnset(request.databaseUser)) {
      query["DatabaseUser"] = request.databaseUser;
    }

    if (!Util.isUnset(request.dbaId)) {
      query["DbaId"] = request.dbaId;
    }

    if (!Util.isUnset(request.ddlOnline)) {
      query["DdlOnline"] = request.ddlOnline;
    }

    if (!Util.isUnset(request.ecsInstanceId)) {
      query["EcsInstanceId"] = request.ecsInstanceId;
    }

    if (!Util.isUnset(request.ecsRegion)) {
      query["EcsRegion"] = request.ecsRegion;
    }

    if (!Util.isUnset(request.enableSellSitd)) {
      query["EnableSellSitd"] = request.enableSellSitd;
    }

    if (!Util.isUnset(request.envType)) {
      query["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.exportTimeout)) {
      query["ExportTimeout"] = request.exportTimeout;
    }

    if (!Util.isUnset(request.host)) {
      query["Host"] = request.host;
    }

    if (!Util.isUnset(request.instanceAlias)) {
      query["InstanceAlias"] = request.instanceAlias;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.instanceSource)) {
      query["InstanceSource"] = request.instanceSource;
    }

    if (!Util.isUnset(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.queryTimeout)) {
      query["QueryTimeout"] = request.queryTimeout;
    }

    if (!Util.isUnset(request.safeRuleId)) {
      query["SafeRuleId"] = request.safeRuleId;
    }

    if (!Util.isUnset(request.sid)) {
      query["Sid"] = request.sid;
    }

    if (!Util.isUnset(request.skipTest)) {
      query["SkipTest"] = request.skipTest;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.templateType)) {
      query["TemplateType"] = request.templateType;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.useDsql)) {
      query["UseDsql"] = request.useDsql;
    }

    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateInstance",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateInstanceResponse>(await this.callApi(params, req, runtime), new UpdateInstanceResponse({}));
  }

  /**
   * Updates the information about a database instance and checks the connectivity of the database instance.
   * 
   * @remarks
   * Before you call the UpdateInstance operation, call the [GetInstance](https://help.aliyun.com/document_detail/141567.html) or [ListInstances](https://help.aliyun.com/document_detail/141936.html) operation to obtain the complete information about the instance.
   * 
   * @param request - UpdateInstanceRequest
   * @returns UpdateInstanceResponse
   */
  async updateInstance(request: UpdateInstanceRequest): Promise<UpdateInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateInstanceWithOptions(request, runtime);
  }

  /**
   * Updates the service level agreement (SLA) timeout reminder for a task flow.
   * 
   * @remarks
   * SLA rules take effect after task flows are deployed and published.
   * 
   * @param tmpReq - UpdateSLARulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateSLARulesResponse
   */
  async updateSLARulesWithOptions(tmpReq: UpdateSLARulesRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSLARulesResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateSLARulesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.slaRuleList)) {
      request.slaRuleListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.slaRuleList, "SlaRuleList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.slaRuleListShrink)) {
      query["SlaRuleList"] = request.slaRuleListShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateSLARules",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateSLARulesResponse>(await this.callApi(params, req, runtime), new UpdateSLARulesResponse({}));
  }

  /**
   * Updates the service level agreement (SLA) timeout reminder for a task flow.
   * 
   * @remarks
   * SLA rules take effect after task flows are deployed and published.
   * 
   * @param request - UpdateSLARulesRequest
   * @returns UpdateSLARulesResponse
   */
  async updateSLARules(request: UpdateSLARulesRequest): Promise<UpdateSLARulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSLARulesWithOptions(request, runtime);
  }

  /**
   * Updates the name and description of the business scenario for a specified task flow.
   * 
   * @param request - UpdateScenarioRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateScenarioResponse
   */
  async updateScenarioWithOptions(request: UpdateScenarioRequest, runtime: $Util.RuntimeOptions): Promise<UpdateScenarioResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.scenarioId)) {
      query["ScenarioId"] = request.scenarioId;
    }

    if (!Util.isUnset(request.scenarioName)) {
      query["ScenarioName"] = request.scenarioName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateScenario",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateScenarioResponse>(await this.callApi(params, req, runtime), new UpdateScenarioResponse({}));
  }

  /**
   * Updates the name and description of the business scenario for a specified task flow.
   * 
   * @param request - UpdateScenarioRequest
   * @returns UpdateScenarioResponse
   */
  async updateScenario(request: UpdateScenarioRequest): Promise<UpdateScenarioResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateScenarioWithOptions(request, runtime);
  }

  /**
   * Modifies the name and description of a specific security rule set.
   * 
   * @param request - UpdateStandardGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateStandardGroupResponse
   */
  async updateStandardGroupWithOptions(request: UpdateStandardGroupRequest, runtime: $Util.RuntimeOptions): Promise<UpdateStandardGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateStandardGroup",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateStandardGroupResponse>(await this.callApi(params, req, runtime), new UpdateStandardGroupResponse({}));
  }

  /**
   * Modifies the name and description of a specific security rule set.
   * 
   * @param request - UpdateStandardGroupRequest
   * @returns UpdateStandardGroupResponse
   */
  async updateStandardGroup(request: UpdateStandardGroupRequest): Promise<UpdateStandardGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateStandardGroupWithOptions(request, runtime);
  }

  /**
   * Updates the advanced configuration of a task node.
   * 
   * @remarks
   * You can call this operation to configure a failed task or rerun a task.
   * 
   * @param request - UpdateTaskConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateTaskConfigResponse
   */
  async updateTaskConfigWithOptions(request: UpdateTaskConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.nodeConfig)) {
      query["NodeConfig"] = request.nodeConfig;
    }

    if (!Util.isUnset(request.nodeId)) {
      query["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskConfig",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskConfigResponse>(await this.callApi(params, req, runtime), new UpdateTaskConfigResponse({}));
  }

  /**
   * Updates the advanced configuration of a task node.
   * 
   * @remarks
   * You can call this operation to configure a failed task or rerun a task.
   * 
   * @param request - UpdateTaskConfigRequest
   * @returns UpdateTaskConfigResponse
   */
  async updateTaskConfig(request: UpdateTaskConfigRequest): Promise<UpdateTaskConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskConfigWithOptions(request, runtime);
  }

  /**
   * Updates tasks in a task flow.
   * 
   * @remarks
   * You can call this operation to modify node configurations.
   * 
   * @param request - UpdateTaskContentRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateTaskContentResponse
   */
  async updateTaskContentWithOptions(request: UpdateTaskContentRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskContentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.nodeContent)) {
      query["NodeContent"] = request.nodeContent;
    }

    if (!Util.isUnset(request.nodeId)) {
      query["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskContent",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskContentResponse>(await this.callApi(params, req, runtime), new UpdateTaskContentResponse({}));
  }

  /**
   * Updates tasks in a task flow.
   * 
   * @remarks
   * You can call this operation to modify node configurations.
   * 
   * @param request - UpdateTaskContentRequest
   * @returns UpdateTaskContentResponse
   */
  async updateTaskContent(request: UpdateTaskContentRequest): Promise<UpdateTaskContentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskContentWithOptions(request, runtime);
  }

  /**
   * Updates the constants for a specified task flow.
   * 
   * @param tmpReq - UpdateTaskFlowConstantsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateTaskFlowConstantsResponse
   */
  async updateTaskFlowConstantsWithOptions(tmpReq: UpdateTaskFlowConstantsRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskFlowConstantsResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateTaskFlowConstantsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.dagConstants)) {
      request.dagConstantsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dagConstants, "DagConstants", "json");
    }

    let query = { };
    if (!Util.isUnset(request.dagConstantsShrink)) {
      query["DagConstants"] = request.dagConstantsShrink;
    }

    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskFlowConstants",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskFlowConstantsResponse>(await this.callApi(params, req, runtime), new UpdateTaskFlowConstantsResponse({}));
  }

  /**
   * Updates the constants for a specified task flow.
   * 
   * @param request - UpdateTaskFlowConstantsRequest
   * @returns UpdateTaskFlowConstantsResponse
   */
  async updateTaskFlowConstants(request: UpdateTaskFlowConstantsRequest): Promise<UpdateTaskFlowConstantsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskFlowConstantsWithOptions(request, runtime);
  }

  /**
   * Updates the IDs of the users who are involved in the task flow.
   * 
   * @param tmpReq - UpdateTaskFlowCooperatorsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateTaskFlowCooperatorsResponse
   */
  async updateTaskFlowCooperatorsWithOptions(tmpReq: UpdateTaskFlowCooperatorsRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskFlowCooperatorsResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateTaskFlowCooperatorsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.cooperatorIds)) {
      request.cooperatorIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.cooperatorIds, "CooperatorIds", "json");
    }

    let query = { };
    if (!Util.isUnset(request.cooperatorIdsShrink)) {
      query["CooperatorIds"] = request.cooperatorIdsShrink;
    }

    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskFlowCooperators",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskFlowCooperatorsResponse>(await this.callApi(params, req, runtime), new UpdateTaskFlowCooperatorsResponse({}));
  }

  /**
   * Updates the IDs of the users who are involved in the task flow.
   * 
   * @param request - UpdateTaskFlowCooperatorsRequest
   * @returns UpdateTaskFlowCooperatorsResponse
   */
  async updateTaskFlowCooperators(request: UpdateTaskFlowCooperatorsRequest): Promise<UpdateTaskFlowCooperatorsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskFlowCooperatorsWithOptions(request, runtime);
  }

  /**
   * Updates the start node and end node of multiple edges at a time for a task flow.
   * 
   * @remarks
   * ###
   * The edges can be updated only when the following conditions are met:
   * 1.  The specified edge exists in the directed acyclic graph (DAG) of the task flow specified by DagId.
   * 2.  The specified edge nodes exist in the DAG of the task flow specified by DagId.
   * 3.  After the update, rings do not exist in the DAG.
   * 
   * @param tmpReq - UpdateTaskFlowEdgesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateTaskFlowEdgesResponse
   */
  async updateTaskFlowEdgesWithOptions(tmpReq: UpdateTaskFlowEdgesRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskFlowEdgesResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateTaskFlowEdgesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.edges)) {
      request.edgesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.edges, "Edges", "json");
    }

    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.edgesShrink)) {
      query["Edges"] = request.edgesShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskFlowEdges",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskFlowEdgesResponse>(await this.callApi(params, req, runtime), new UpdateTaskFlowEdgesResponse({}));
  }

  /**
   * Updates the start node and end node of multiple edges at a time for a task flow.
   * 
   * @remarks
   * ###
   * The edges can be updated only when the following conditions are met:
   * 1.  The specified edge exists in the directed acyclic graph (DAG) of the task flow specified by DagId.
   * 2.  The specified edge nodes exist in the DAG of the task flow specified by DagId.
   * 3.  After the update, rings do not exist in the DAG.
   * 
   * @param request - UpdateTaskFlowEdgesRequest
   * @returns UpdateTaskFlowEdgesResponse
   */
  async updateTaskFlowEdges(request: UpdateTaskFlowEdgesRequest): Promise<UpdateTaskFlowEdgesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskFlowEdgesWithOptions(request, runtime);
  }

  /**
   * Updates the name and description of a task flow.
   * 
   * @param request - UpdateTaskFlowNameAndDescRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateTaskFlowNameAndDescResponse
   */
  async updateTaskFlowNameAndDescWithOptions(request: UpdateTaskFlowNameAndDescRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskFlowNameAndDescResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.dagName)) {
      query["DagName"] = request.dagName;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskFlowNameAndDesc",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskFlowNameAndDescResponse>(await this.callApi(params, req, runtime), new UpdateTaskFlowNameAndDescResponse({}));
  }

  /**
   * Updates the name and description of a task flow.
   * 
   * @param request - UpdateTaskFlowNameAndDescRequest
   * @returns UpdateTaskFlowNameAndDescResponse
   */
  async updateTaskFlowNameAndDesc(request: UpdateTaskFlowNameAndDescRequest): Promise<UpdateTaskFlowNameAndDescResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskFlowNameAndDescWithOptions(request, runtime);
  }

  /**
   * Updates the notification settings for task flows.
   * 
   * @param request - UpdateTaskFlowNotificationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateTaskFlowNotificationResponse
   */
  async updateTaskFlowNotificationWithOptions(request: UpdateTaskFlowNotificationRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskFlowNotificationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.dagNotificationFail)) {
      query["DagNotificationFail"] = request.dagNotificationFail;
    }

    if (!Util.isUnset(request.dagNotificationSla)) {
      query["DagNotificationSla"] = request.dagNotificationSla;
    }

    if (!Util.isUnset(request.dagNotificationSuccess)) {
      query["DagNotificationSuccess"] = request.dagNotificationSuccess;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskFlowNotification",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskFlowNotificationResponse>(await this.callApi(params, req, runtime), new UpdateTaskFlowNotificationResponse({}));
  }

  /**
   * Updates the notification settings for task flows.
   * 
   * @param request - UpdateTaskFlowNotificationRequest
   * @returns UpdateTaskFlowNotificationResponse
   */
  async updateTaskFlowNotification(request: UpdateTaskFlowNotificationRequest): Promise<UpdateTaskFlowNotificationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskFlowNotificationWithOptions(request, runtime);
  }

  /**
   * Changes the owner of a task flow.
   * 
   * @remarks
   * Note: The new owner of the task flow must belong to the same tenant as the previous owner.
   * 
   * @param request - UpdateTaskFlowOwnerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateTaskFlowOwnerResponse
   */
  async updateTaskFlowOwnerWithOptions(request: UpdateTaskFlowOwnerRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskFlowOwnerResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.newOwnerId)) {
      query["NewOwnerId"] = request.newOwnerId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskFlowOwner",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskFlowOwnerResponse>(await this.callApi(params, req, runtime), new UpdateTaskFlowOwnerResponse({}));
  }

  /**
   * Changes the owner of a task flow.
   * 
   * @remarks
   * Note: The new owner of the task flow must belong to the same tenant as the previous owner.
   * 
   * @param request - UpdateTaskFlowOwnerRequest
   * @returns UpdateTaskFlowOwnerResponse
   */
  async updateTaskFlowOwner(request: UpdateTaskFlowOwnerRequest): Promise<UpdateTaskFlowOwnerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskFlowOwnerWithOptions(request, runtime);
  }

  /**
   * Fully updates the edges of a task flow.
   * 
   * @remarks
   * You can call this operation to perform a full update. For incremental updates, see AddTaskFlowEdges, UpdateTaskFlowEdges, and DeleteTaskFlowEdgesByMultiCondition.
   * 
   * @param tmpReq - UpdateTaskFlowRelationsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateTaskFlowRelationsResponse
   */
  async updateTaskFlowRelationsWithOptions(tmpReq: UpdateTaskFlowRelationsRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskFlowRelationsResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateTaskFlowRelationsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.edges)) {
      request.edgesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.edges, "Edges", "json");
    }

    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.edgesShrink)) {
      query["Edges"] = request.edgesShrink;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskFlowRelations",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskFlowRelationsResponse>(await this.callApi(params, req, runtime), new UpdateTaskFlowRelationsResponse({}));
  }

  /**
   * Fully updates the edges of a task flow.
   * 
   * @remarks
   * You can call this operation to perform a full update. For incremental updates, see AddTaskFlowEdges, UpdateTaskFlowEdges, and DeleteTaskFlowEdgesByMultiCondition.
   * 
   * @param request - UpdateTaskFlowRelationsRequest
   * @returns UpdateTaskFlowRelationsResponse
   */
  async updateTaskFlowRelations(request: UpdateTaskFlowRelationsRequest): Promise<UpdateTaskFlowRelationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskFlowRelationsWithOptions(request, runtime);
  }

  /**
   * Updates the scheduling properties for a task flow.
   * 
   * @remarks
   * You can call this operation to update the scheduling properties for a task flow in the editing state. You can configure a **timed scheduling** task flow or an **event scheduling** task flow. When you configure a **timed scheduling** task flow, you can choose from one-time scheduling or periodic scheduling. When you configure an **event scheduling** task flow, you can subscribe to task flows or task flow nodes.****\\
   * After you update the scheduling properties, you need to publish and deploy the task flow again. The new task flow instance will run based on the updated scheduling properties.
   * 
   * @param request - UpdateTaskFlowScheduleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateTaskFlowScheduleResponse
   */
  async updateTaskFlowScheduleWithOptions(request: UpdateTaskFlowScheduleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskFlowScheduleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.cronBeginDate)) {
      query["CronBeginDate"] = request.cronBeginDate;
    }

    if (!Util.isUnset(request.cronEndDate)) {
      query["CronEndDate"] = request.cronEndDate;
    }

    if (!Util.isUnset(request.cronStr)) {
      query["CronStr"] = request.cronStr;
    }

    if (!Util.isUnset(request.cronType)) {
      query["CronType"] = request.cronType;
    }

    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.scheduleParam)) {
      query["ScheduleParam"] = request.scheduleParam;
    }

    if (!Util.isUnset(request.scheduleSwitch)) {
      query["ScheduleSwitch"] = request.scheduleSwitch;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.timeZoneId)) {
      query["TimeZoneId"] = request.timeZoneId;
    }

    if (!Util.isUnset(request.triggerType)) {
      query["TriggerType"] = request.triggerType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskFlowSchedule",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskFlowScheduleResponse>(await this.callApi(params, req, runtime), new UpdateTaskFlowScheduleResponse({}));
  }

  /**
   * Updates the scheduling properties for a task flow.
   * 
   * @remarks
   * You can call this operation to update the scheduling properties for a task flow in the editing state. You can configure a **timed scheduling** task flow or an **event scheduling** task flow. When you configure a **timed scheduling** task flow, you can choose from one-time scheduling or periodic scheduling. When you configure an **event scheduling** task flow, you can subscribe to task flows or task flow nodes.****\\
   * After you update the scheduling properties, you need to publish and deploy the task flow again. The new task flow instance will run based on the updated scheduling properties.
   * 
   * @param request - UpdateTaskFlowScheduleRequest
   * @returns UpdateTaskFlowScheduleResponse
   */
  async updateTaskFlowSchedule(request: UpdateTaskFlowScheduleRequest): Promise<UpdateTaskFlowScheduleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskFlowScheduleWithOptions(request, runtime);
  }

  /**
   * Updates the time variables for a task flow.
   * 
   * @param request - UpdateTaskFlowTimeVariablesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateTaskFlowTimeVariablesResponse
   */
  async updateTaskFlowTimeVariablesWithOptions(request: UpdateTaskFlowTimeVariablesRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskFlowTimeVariablesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dagId)) {
      query["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.timeVariables)) {
      query["TimeVariables"] = request.timeVariables;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskFlowTimeVariables",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskFlowTimeVariablesResponse>(await this.callApi(params, req, runtime), new UpdateTaskFlowTimeVariablesResponse({}));
  }

  /**
   * Updates the time variables for a task flow.
   * 
   * @param request - UpdateTaskFlowTimeVariablesRequest
   * @returns UpdateTaskFlowTimeVariablesResponse
   */
  async updateTaskFlowTimeVariables(request: UpdateTaskFlowTimeVariablesRequest): Promise<UpdateTaskFlowTimeVariablesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskFlowTimeVariablesWithOptions(request, runtime);
  }

  /**
   * Updates the name of a specified task.
   * 
   * @param request - UpdateTaskNameRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateTaskNameResponse
   */
  async updateTaskNameWithOptions(request: UpdateTaskNameRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskNameResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.nodeId)) {
      query["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.nodeName)) {
      query["NodeName"] = request.nodeName;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskName",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskNameResponse>(await this.callApi(params, req, runtime), new UpdateTaskNameResponse({}));
  }

  /**
   * Updates the name of a specified task.
   * 
   * @param request - UpdateTaskNameRequest
   * @returns UpdateTaskNameResponse
   */
  async updateTaskName(request: UpdateTaskNameRequest): Promise<UpdateTaskNameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskNameWithOptions(request, runtime);
  }

  /**
   * Updates the output variables for a specified task node.
   * 
   * @remarks
   * Only nodes of single-instance SQL assignment, script code, and ECS remote command have output variables.
   * 
   * @param request - UpdateTaskOutputRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateTaskOutputResponse
   */
  async updateTaskOutputWithOptions(request: UpdateTaskOutputRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskOutputResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.nodeId)) {
      query["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.nodeOutput)) {
      query["NodeOutput"] = request.nodeOutput;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskOutput",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskOutputResponse>(await this.callApi(params, req, runtime), new UpdateTaskOutputResponse({}));
  }

  /**
   * Updates the output variables for a specified task node.
   * 
   * @remarks
   * Only nodes of single-instance SQL assignment, script code, and ECS remote command have output variables.
   * 
   * @param request - UpdateTaskOutputRequest
   * @returns UpdateTaskOutputResponse
   */
  async updateTaskOutput(request: UpdateTaskOutputRequest): Promise<UpdateTaskOutputResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskOutputWithOptions(request, runtime);
  }

  /**
   * Updates time variables for a task.
   * 
   * @param request - UpdateTaskTimeVariablesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateTaskTimeVariablesResponse
   */
  async updateTaskTimeVariablesWithOptions(request: UpdateTaskTimeVariablesRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTaskTimeVariablesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.nodeId)) {
      query["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.timeVariables)) {
      query["TimeVariables"] = request.timeVariables;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTaskTimeVariables",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTaskTimeVariablesResponse>(await this.callApi(params, req, runtime), new UpdateTaskTimeVariablesResponse({}));
  }

  /**
   * Updates time variables for a task.
   * 
   * @param request - UpdateTaskTimeVariablesRequest
   * @returns UpdateTaskTimeVariablesResponse
   */
  async updateTaskTimeVariables(request: UpdateTaskTimeVariablesRequest): Promise<UpdateTaskTimeVariablesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTaskTimeVariablesWithOptions(request, runtime);
  }

  /**
   * Updates user information.
   * 
   * @param request - UpdateUserRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateUserResponse
   */
  async updateUserWithOptions(request: UpdateUserRequest, runtime: $Util.RuntimeOptions): Promise<UpdateUserResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.maxExecuteCount)) {
      query["MaxExecuteCount"] = request.maxExecuteCount;
    }

    if (!Util.isUnset(request.maxResultCount)) {
      query["MaxResultCount"] = request.maxResultCount;
    }

    if (!Util.isUnset(request.mobile)) {
      query["Mobile"] = request.mobile;
    }

    if (!Util.isUnset(request.roleNames)) {
      query["RoleNames"] = request.roleNames;
    }

    if (!Util.isUnset(request.tid)) {
      query["Tid"] = request.tid;
    }

    if (!Util.isUnset(request.uid)) {
      query["Uid"] = request.uid;
    }

    if (!Util.isUnset(request.userNick)) {
      query["UserNick"] = request.userNick;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateUser",
      version: "2018-11-01",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateUserResponse>(await this.callApi(params, req, runtime), new UpdateUserResponse({}));
  }

  /**
   * Updates user information.
   * 
   * @param request - UpdateUserRequest
   * @returns UpdateUserResponse
   */
  async updateUser(request: UpdateUserRequest): Promise<UpdateUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateUserWithOptions(request, runtime);
  }

}
