// This file is auto-generated, don't edit it
/**
 */
import Util, * as $Util from '@alicloud/tea-util';
import OpenApi, * as $OpenApi from '@alicloud/openapi-client';
import OpenApiUtil from '@alicloud/openapi-util';
import EndpointUtil from '@alicloud/endpoint-util';
import * as $tea from '@alicloud/tea-typescript';

export class AckConfig extends $tea.Model {
  /**
   * @remarks
   * ack集群id
   */
  ackInstanceId?: string;
  customAnnotations?: Tag[];
  customLabels?: Tag[];
  dataDiskSize?: number;
  dataDiskStorageClass?: string;
  /**
   * @remarks
   * Pod的CPU限制值。
   */
  limitCpu?: number;
  /**
   * @remarks
   * Pod的内存限制值。
   */
  limitMemory?: number;
  mountHostCgroup?: boolean;
  /**
   * @remarks
   * ack 命名空间
   */
  namespace?: string;
  nodeAffinity?: string;
  /**
   * @remarks
   * ack的节点标签限制
   */
  nodeSelectors?: Tag[];
  podAffinity?: string;
  podAntiAffinity?: string;
  preStartCommand?: string[];
  pvcs?: AckConfigPvcs[];
  /**
   * @remarks
   * Pod的CPU请求值
   */
  requestCpu?: number;
  /**
   * @remarks
   * Pod的内存请求值。
   */
  requestMemory?: number;
  /**
   * @remarks
   * ack的节点污点容忍
   */
  tolerations?: Toleration[];
  volumeMounts?: AckConfigVolumeMounts[];
  volumes?: AckConfigVolumes[];
  static names(): { [key: string]: string } {
    return {
      ackInstanceId: 'AckInstanceId',
      customAnnotations: 'CustomAnnotations',
      customLabels: 'CustomLabels',
      dataDiskSize: 'DataDiskSize',
      dataDiskStorageClass: 'DataDiskStorageClass',
      limitCpu: 'LimitCpu',
      limitMemory: 'LimitMemory',
      mountHostCgroup: 'MountHostCgroup',
      namespace: 'Namespace',
      nodeAffinity: 'NodeAffinity',
      nodeSelectors: 'NodeSelectors',
      podAffinity: 'PodAffinity',
      podAntiAffinity: 'PodAntiAffinity',
      preStartCommand: 'PreStartCommand',
      pvcs: 'Pvcs',
      requestCpu: 'RequestCpu',
      requestMemory: 'RequestMemory',
      tolerations: 'Tolerations',
      volumeMounts: 'VolumeMounts',
      volumes: 'Volumes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ackInstanceId: 'string',
      customAnnotations: { 'type': 'array', 'itemType': Tag },
      customLabels: { 'type': 'array', 'itemType': Tag },
      dataDiskSize: 'number',
      dataDiskStorageClass: 'string',
      limitCpu: 'number',
      limitMemory: 'number',
      mountHostCgroup: 'boolean',
      namespace: 'string',
      nodeAffinity: 'string',
      nodeSelectors: { 'type': 'array', 'itemType': Tag },
      podAffinity: 'string',
      podAntiAffinity: 'string',
      preStartCommand: { 'type': 'array', 'itemType': 'string' },
      pvcs: { 'type': 'array', 'itemType': AckConfigPvcs },
      requestCpu: 'number',
      requestMemory: 'number',
      tolerations: { 'type': 'array', 'itemType': Toleration },
      volumeMounts: { 'type': 'array', 'itemType': AckConfigVolumeMounts },
      volumes: { 'type': 'array', 'itemType': AckConfigVolumes },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AckNode extends $tea.Model {
  /**
   * @remarks
   * 节点ID。
   * 
   * @example
   * i-bp1cudc25w2bfwl5****
   */
  nodeId?: string;
  /**
   * @remarks
   * ACK节点选择器。
   */
  nodeSelector?: AckNodeSelector;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      nodeSelector: 'NodeSelector',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'string',
      nodeSelector: AckNodeSelector,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AckNodePool extends $tea.Model {
  /**
   * @remarks
   * 节点池ID。
   * 
   * @example
   * npe76629caa1b14a73bf3e47c6d481****
   */
  nodePoolId?: string;
  /**
   * @remarks
   * ACK节点选择器。
   */
  nodeSelector?: AckNodeSelector;
  static names(): { [key: string]: string } {
    return {
      nodePoolId: 'NodePoolId',
      nodeSelector: 'NodeSelector',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodePoolId: 'string',
      nodeSelector: AckNodeSelector,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AckNodeSelector extends $tea.Model {
  /**
   * @remarks
   * 污点列表。
   */
  labels?: AckNodeSelectorLabels[];
  /**
   * @remarks
   * 污点列表。
   */
  taints?: AckNodeSelectorTaints[];
  static names(): { [key: string]: string } {
    return {
      labels: 'Labels',
      taints: 'Taints',
    };
  }

  static types(): { [key: string]: any } {
    return {
      labels: { 'type': 'array', 'itemType': AckNodeSelectorLabels },
      taints: { 'type': 'array', 'itemType': AckNodeSelectorTaints },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApiTemplate extends $tea.Model {
  /**
   * @remarks
   * 接口名。
   * 
   * @example
   * CreateCluster
   */
  apiName?: string;
  /**
   * @remarks
   * 模版接口参数。
   */
  content?: string;
  /**
   * @remarks
   * 区域ID。
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * 资源组ID。
   * 
   * @example
   * rg-acfmzabjyop****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * 模板状态。
   * 
   * @example
   * READY
   */
  status?: string;
  /**
   * @remarks
   * 模板ID。
   * 
   * @example
   * AT-Af***
   */
  templateId?: string;
  /**
   * @remarks
   * 模板ID。
   * 
   * @example
   * AT-Af***
   */
  templateName?: string;
  static names(): { [key: string]: string } {
    return {
      apiName: 'ApiName',
      content: 'Content',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      status: 'Status',
      templateId: 'TemplateId',
      templateName: 'TemplateName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiName: 'string',
      content: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      status: 'string',
      templateId: 'string',
      templateName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class Application extends $tea.Model {
  /**
   * @remarks
   * 应用名称。从EMR控制台集群创建页面可查看到指定发行版的应用名称列表。
   * 
   * This parameter is required.
   * 
   * @example
   * HDFS
   */
  applicationName?: string;
  static names(): { [key: string]: string } {
    return {
      applicationName: 'ApplicationName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplicationConfig extends $tea.Model {
  /**
   * @remarks
   * 应用名称。从EMR控制台集群创建页面可查看到指定发行版的应用名称列表。
   * 
   * This parameter is required.
   * 
   * @example
   * HDFS
   */
  applicationName?: string;
  /**
   * @remarks
   * 应用配置文件名。
   * 
   * This parameter is required.
   * 
   * @example
   * hdfs-site.xml
   */
  configFileName?: string;
  /**
   * @remarks
   * 配置项键。
   * 
   * This parameter is required.
   * 
   * @example
   * dfs.namenode.checkpoint.period
   */
  configItemKey?: string;
  /**
   * @remarks
   * 配置项值。
   * 
   * @example
   * 3600s
   */
  configItemValue?: string;
  /**
   * @remarks
   * 配置范围。取值范围：
   * - CLUSTER：集群级别。
   * - NODE_GROUP：节点组级别。
   * 
   * 默认值：CLUSTER。
   * 
   * @example
   * NODE_GROUP
   */
  configScope?: string;
  /**
   * @remarks
   * 节点组ID。ConfigScope取值NODE_GROUP时，该参数生效。NodeGroupId参数优先级高于NodeGroupName。
   * 
   * @example
   * ng-869471354ecd****
   */
  nodeGroupId?: string;
  /**
   * @remarks
   * 节点组名称。ConfigScope取值NODE_GROUP时，且参数NodeGroupId为空时生效，该参数生效。
   * 
   * @example
   * core-1
   */
  nodeGroupName?: string;
  static names(): { [key: string]: string } {
    return {
      applicationName: 'ApplicationName',
      configFileName: 'ConfigFileName',
      configItemKey: 'ConfigItemKey',
      configItemValue: 'ConfigItemValue',
      configScope: 'ConfigScope',
      nodeGroupId: 'NodeGroupId',
      nodeGroupName: 'NodeGroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationName: 'string',
      configFileName: 'string',
      configItemKey: 'string',
      configItemValue: 'string',
      configScope: 'string',
      nodeGroupId: 'string',
      nodeGroupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplicationConfigFile extends $tea.Model {
  /**
   * @remarks
   * 应用名称。
   * 
   * This parameter is required.
   * 
   * @example
   * HDFS
   */
  applicationName?: string;
  /**
   * @remarks
   * 配置文件名称。
   * 
   * This parameter is required.
   * 
   * @example
   * core-site.xml
   */
  configFileName?: string;
  static names(): { [key: string]: string } {
    return {
      applicationName: 'ApplicationName',
      configFileName: 'ConfigFileName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationName: 'string',
      configFileName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplicationConfigParam extends $tea.Model {
  /**
   * @example
   * DELETE
   */
  configAction?: string;
  /**
   * @example
   * hdfs-site.xml
   */
  configFileName?: string;
  /**
   * @example
   * namenode checkpoint period
   */
  configItemDescription?: string;
  /**
   * @example
   * dfs.namenode.checkpoint.period
   */
  configItemKey?: string;
  /**
   * @example
   * 3600s
   */
  configItemValue?: string;
  configScope?: string;
  /**
   * @example
   * RESTART
   */
  effectiveActions?: string;
  /**
   * @example
   * MANUAL
   */
  effectiveType?: string;
  /**
   * @example
   * G-DE1CF4661E09****
   */
  nodeGroupId?: string;
  /**
   * @example
   * i-bp10h9rezawz1i4o****
   */
  nodeId?: string;
  static names(): { [key: string]: string } {
    return {
      configAction: 'ConfigAction',
      configFileName: 'ConfigFileName',
      configItemDescription: 'ConfigItemDescription',
      configItemKey: 'ConfigItemKey',
      configItemValue: 'ConfigItemValue',
      configScope: 'ConfigScope',
      effectiveActions: 'EffectiveActions',
      effectiveType: 'EffectiveType',
      nodeGroupId: 'NodeGroupId',
      nodeId: 'NodeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configAction: 'string',
      configFileName: 'string',
      configItemDescription: 'string',
      configItemKey: 'string',
      configItemValue: 'string',
      configScope: 'string',
      effectiveActions: 'string',
      effectiveType: 'string',
      nodeGroupId: 'string',
      nodeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class Attribute extends $tea.Model {
  /**
   * @remarks
   * 键。
   * 
   * @example
   * currentYarnRangerPluginState
   */
  key?: string;
  /**
   * @remarks
   * 值。
   * 
   * @example
   * true
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AutoRenewInstance extends $tea.Model {
  /**
   * @remarks
   * 自动续费。
   * 
   * @example
   * true
   */
  autoRenew?: boolean;
  /**
   * @remarks
   * 自动续费时长。
   * 
   * @example
   * 12
   */
  autoRenewDuration?: number;
  /**
   * @remarks
   * 自动付费时长单位。
   * 
   * @example
   * Month
   */
  autoRenewDurationUnit?: string;
  /**
   * @remarks
   * emr实例自动续费时长。
   * 
   * @example
   * 12
   */
  emrAutoRenewDuration?: number;
  /**
   * @remarks
   * emr实例自动续费时长单位。
   * 
   * @example
   * Month
   */
  emrAutoRenewDurationUnit?: string;
  /**
   * @remarks
   * 节点ID。
   * 
   * This parameter is required.
   * 
   * @example
   * i-bp1cudc25w2bfwl5****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      autoRenew: 'AutoRenew',
      autoRenewDuration: 'AutoRenewDuration',
      autoRenewDurationUnit: 'AutoRenewDurationUnit',
      emrAutoRenewDuration: 'EmrAutoRenewDuration',
      emrAutoRenewDurationUnit: 'EmrAutoRenewDurationUnit',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRenew: 'boolean',
      autoRenewDuration: 'number',
      autoRenewDurationUnit: 'string',
      emrAutoRenewDuration: 'number',
      emrAutoRenewDurationUnit: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AutoRenewInstanceParam extends $tea.Model {
  autoRenew?: string;
  autoRenewDuration?: string;
  autoRenewDurationUnit?: string;
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      autoRenew: 'AutoRenew',
      autoRenewDuration: 'AutoRenewDuration',
      autoRenewDurationUnit: 'AutoRenewDurationUnit',
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRenew: 'string',
      autoRenewDuration: 'string',
      autoRenewDurationUnit: 'string',
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AutoScalingConstraints extends $tea.Model {
  /**
   * @remarks
   * 按负载伸缩指标单位描述。
   */
  autoScalingMetricUnits?: MetricUnitValue[];
  /**
   * @remarks
   * 默认按负载弹性伸缩规则列表
   */
  defaultMetricTriggeredRules?: ScalingRule[];
  /**
   * @remarks
   * 单次伸缩活动最大扩缩容节点数量。
   * 
   * @example
   * 1000
   */
  maxAdjustmentValue?: number;
  /**
   * @remarks
   * 按负载规则数量最大值。
   * 
   * @example
   * 10
   */
  maxByLoadRuleCount?: number;
  /**
   * @remarks
   * 按时间规则数量最大值。
   * 
   * @example
   * 10
   */
  maxByTimeRuleCount?: number;
  /**
   * @remarks
   * 支持的按负载弹性伸缩指标Tag列表。
   */
  supportMetricTags?: AutoScalingConstraintsSupportMetricTags[];
  /**
   * @remarks
   * 支持的按负载弹性伸缩指标列表。
   * 
   * @example
   * ["YarnRootAvailableMemoryUsage","YarnRootAvailableVcores"]
   */
  supportMetrics?: string[];
  /**
   * @remarks
   * 支持的弹性伸缩规则类型。
   * 
   * @example
   * ["TIME_TRIGGER","METRICS_TRIGGER"]
   */
  supportRuleTypes?: string[];
  static names(): { [key: string]: string } {
    return {
      autoScalingMetricUnits: 'AutoScalingMetricUnits',
      defaultMetricTriggeredRules: 'DefaultMetricTriggeredRules',
      maxAdjustmentValue: 'MaxAdjustmentValue',
      maxByLoadRuleCount: 'MaxByLoadRuleCount',
      maxByTimeRuleCount: 'MaxByTimeRuleCount',
      supportMetricTags: 'SupportMetricTags',
      supportMetrics: 'SupportMetrics',
      supportRuleTypes: 'SupportRuleTypes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoScalingMetricUnits: { 'type': 'array', 'itemType': MetricUnitValue },
      defaultMetricTriggeredRules: { 'type': 'array', 'itemType': ScalingRule },
      maxAdjustmentValue: 'number',
      maxByLoadRuleCount: 'number',
      maxByTimeRuleCount: 'number',
      supportMetricTags: { 'type': 'array', 'itemType': AutoScalingConstraintsSupportMetricTags },
      supportMetrics: { 'type': 'array', 'itemType': 'string' },
      supportRuleTypes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AutoScalingPolicy extends $tea.Model {
  constraints?: AutoScalingPolicyConstraints;
  scalingRules?: ScalingRule[];
  static names(): { [key: string]: string } {
    return {
      constraints: 'constraints',
      scalingRules: 'scalingRules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      constraints: AutoScalingPolicyConstraints,
      scalingRules: { 'type': 'array', 'itemType': ScalingRule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ByLoadScalingRule extends $tea.Model {
  /**
   * @remarks
   * 比较符。
   * 
   * This parameter is required.
   * 
   * @example
   * LT
   */
  comparisonOperator?: string;
  coolDownInterval?: number;
  /**
   * @remarks
   * 统计次数。
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  evaluationCount?: number;
  /**
   * @remarks
   * 指标名称。指标名称需要在 ListAutoScalingMetrics 接口返回的指标名称列表中。
   * 
   * This parameter is required.
   * 
   * @example
   * yarn_resourcemanager_root_availablememoryusage
   */
  metricName?: string;
  /**
   * @remarks
   * 统计量名称。
   * 
   * This parameter is required.
   * 
   * @example
   * AVG
   */
  statistics?: string;
  /**
   * @remarks
   * 阈值。
   * 
   * This parameter is required.
   * 
   * @example
   * 12.5
   */
  threshold?: number;
  /**
   * @remarks
   * 统计窗口。单位为秒。
   * 
   * This parameter is required.
   * 
   * @example
   * 30
   */
  timeWindow?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      coolDownInterval: 'CoolDownInterval',
      evaluationCount: 'EvaluationCount',
      metricName: 'MetricName',
      statistics: 'Statistics',
      threshold: 'Threshold',
      timeWindow: 'TimeWindow',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      coolDownInterval: 'number',
      evaluationCount: 'number',
      metricName: 'string',
      statistics: 'string',
      threshold: 'number',
      timeWindow: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ByLoadScalingRuleSpec extends $tea.Model {
  /**
   * @remarks
   * 比较符。
   * 
   * This parameter is required.
   * 
   * @example
   * LT
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * 统计次数。
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  evaluationCount?: number;
  /**
   * @remarks
   * 指标名称。指标名称需要在 ListAutoScalingMetrics 接口返回的指标名称列表中。
   * 
   * This parameter is required.
   * 
   * @example
   * yarn_resourcemanager_root_availablememoryusage
   */
  metricName?: string;
  /**
   * @remarks
   * 统计量名称。
   * 
   * This parameter is required.
   * 
   * @example
   * AVG
   */
  statistics?: string;
  /**
   * @remarks
   * 阈值。
   * 
   * This parameter is required.
   * 
   * @example
   * 12.5
   */
  threshold?: number;
  /**
   * @remarks
   * 统计窗口。单位为秒。
   * 
   * This parameter is required.
   * 
   * @example
   * 30
   */
  timeWindow?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      evaluationCount: 'EvaluationCount',
      metricName: 'MetricName',
      statistics: 'Statistics',
      threshold: 'Threshold',
      timeWindow: 'TimeWindow',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      evaluationCount: 'number',
      metricName: 'string',
      statistics: 'string',
      threshold: 'number',
      timeWindow: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ByTimeScalingRule extends $tea.Model {
  /**
   * @remarks
   * 重复执行定时任务的结束时间戳。单位为毫秒。
   * 
   * @example
   * 1639714800000
   */
  endTime?: number;
  /**
   * @remarks
   * 定时任务触发操作失败后，在此时间内重试。单位为秒，取值范围：0~3600。
   * 
   * @example
   * 600
   */
  launchExpirationTime?: number;
  /**
   * @remarks
   * 启动时间戳。单位为毫秒。
   * 
   * This parameter is required.
   * 
   * @example
   * 1639714634819
   */
  launchTime?: number;
  /**
   * @remarks
   * 指定时间规则的执行类型。
   * 
   * @example
   * WEEKLY
   */
  recurrenceType?: string;
  /**
   * @remarks
   * 重复执行定时任务的数值。具体取值取决于 recurrenceType 设置。
   * - recurrenceType 取 MINUTELY 时，只能填一个数值，取值范围：1~1440。
   * - recurrenceType 取 HOURLY 时，只能填一个数值，取值范围：1~24。
   * - recurrenceType 取 DAILY 时，只能填一个数值，取值范围：1~31。
   * - recurrenceType 取 WEEKLY 时，可以填入多个值，填多个值时使用英文逗号（,）分隔。周一到周天分别用MON，TUE，WED，THU，FRI，SAT，SUN代替。 比如 MON,FRI,SUN 代表周一、周五、周天。
   * - recurrenceType 取 MONTHLY 时，格式为A-B或者A,B。A、B的取值范围为1~31，如果使用A-B时B必须大于A。
   * 
   * @example
   * MON,FRI,SUN
   */
  recurrenceValue?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      launchExpirationTime: 'LaunchExpirationTime',
      launchTime: 'LaunchTime',
      recurrenceType: 'RecurrenceType',
      recurrenceValue: 'RecurrenceValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      launchExpirationTime: 'number',
      launchTime: 'number',
      recurrenceType: 'string',
      recurrenceValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ByTimeScalingRuleSpec extends $tea.Model {
  /**
   * @remarks
   * 重复执行定时任务的结束时间戳。单位为毫秒。
   * 
   * @example
   * 1639714800000
   */
  endTime?: number;
  /**
   * @remarks
   * 启动时间戳。单位为毫秒。
   * 
   * This parameter is required.
   * 
   * @example
   * 1639714634819
   */
  launchTime?: number;
  /**
   * @remarks
   * 指定时间规则的执行类型。
   * 
   * @example
   * WEEKLY
   */
  recurrenceType?: string;
  /**
   * @remarks
   * 重复执行定时任务的数值。具体取值取决于 recurrenceType 设置。
   * 
   * @example
   * MON,FRI,SUN
   */
  recurrenceValue?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      launchTime: 'LaunchTime',
      recurrenceType: 'RecurrenceType',
      recurrenceValue: 'RecurrenceValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      launchTime: 'number',
      recurrenceType: 'string',
      recurrenceValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClickhouseConf extends $tea.Model {
  initialReplica?: number;
  initialShard?: number;
  newNodeCount?: number;
  resizeType?: string;
  static names(): { [key: string]: string } {
    return {
      initialReplica: 'InitialReplica',
      initialShard: 'InitialShard',
      newNodeCount: 'NewNodeCount',
      resizeType: 'ResizeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      initialReplica: 'number',
      initialShard: 'number',
      newNodeCount: 'number',
      resizeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class Cluster extends $tea.Model {
  /**
   * @remarks
   * 集群ID。
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * 集群名称。
   * 
   * @example
   * emrtest
   */
  clusterName?: string;
  /**
   * @remarks
   * 集群状态。
   * 
   * @example
   * RUNNING
   */
  clusterState?: string;
  /**
   * @remarks
   * 集群类型。
   * 
   * @example
   * DATALAKE
   */
  clusterType?: string;
  /**
   * @remarks
   * 创建时间。
   * 
   * @example
   * 1592837465784
   */
  createTime?: number;
  /**
   * @remarks
   * 部署模式。
   * 
   * @example
   * HA
   */
  deployMode?: string;
  description?: string;
  /**
   * @remarks
   * EMR默认角色。
   * 
   * @example
   * AliyunEMRDefaultRole
   */
  emrDefaultRole?: string;
  /**
   * @remarks
   * 删除时间。
   * 
   * @example
   * 1592837465784
   */
  endTime?: number;
  /**
   * @remarks
   * 过期时间。
   * 
   * @example
   * 1592837465784
   */
  expireTime?: number;
  /**
   * @remarks
   * 节点属性。
   */
  nodeAttributes?: NodeAttributes;
  /**
   * @remarks
   * 付费类型。
   * 
   * @example
   * PayAsYouGo
   */
  paymentType?: string;
  /**
   * @remarks
   * 可用时间。
   * 
   * @example
   * 1592837465784
   */
  readyTime?: number;
  /**
   * @remarks
   * 地域ID。
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * EMR发行版。
   * 
   * @example
   * EMR-5.3.0
   */
  releaseVersion?: string;
  /**
   * @remarks
   * 资源组ID。
   * 
   * @example
   * rg-acfmzabjyop****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * Kerberos安全模式。
   * 
   * @example
   * NORMAL
   */
  securityMode?: string;
  stateChangeReason?: ClusterStateChangeReason;
  /**
   * @remarks
   * 预付费配置。
   */
  subscriptionConfig?: SubscriptionConfig;
  /**
   * @remarks
   * 集群标签。
   */
  tags?: Tag[];
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      clusterState: 'ClusterState',
      clusterType: 'ClusterType',
      createTime: 'CreateTime',
      deployMode: 'DeployMode',
      description: 'Description',
      emrDefaultRole: 'EmrDefaultRole',
      endTime: 'EndTime',
      expireTime: 'ExpireTime',
      nodeAttributes: 'NodeAttributes',
      paymentType: 'PaymentType',
      readyTime: 'ReadyTime',
      regionId: 'RegionId',
      releaseVersion: 'ReleaseVersion',
      resourceGroupId: 'ResourceGroupId',
      securityMode: 'SecurityMode',
      stateChangeReason: 'StateChangeReason',
      subscriptionConfig: 'SubscriptionConfig',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      clusterName: 'string',
      clusterState: 'string',
      clusterType: 'string',
      createTime: 'number',
      deployMode: 'string',
      description: 'string',
      emrDefaultRole: 'string',
      endTime: 'number',
      expireTime: 'number',
      nodeAttributes: NodeAttributes,
      paymentType: 'string',
      readyTime: 'number',
      regionId: 'string',
      releaseVersion: 'string',
      resourceGroupId: 'string',
      securityMode: 'string',
      stateChangeReason: ClusterStateChangeReason,
      subscriptionConfig: SubscriptionConfig,
      tags: { 'type': 'array', 'itemType': Tag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClusterScript extends $tea.Model {
  /**
   * @example
   * 取值:FAILED_CONTINUE, FAILED_BLOCKED
   */
  executionFailStrategy?: string;
  /**
   * @example
   * 取值:BEFORE_INSTALL, AFTER_STARTED
   */
  executionMoment?: string;
  nodeSelect?: NodeSelector;
  priority?: number;
  scriptArgs?: string;
  scriptName?: string;
  scriptPath?: string;
  static names(): { [key: string]: string } {
    return {
      executionFailStrategy: 'ExecutionFailStrategy',
      executionMoment: 'ExecutionMoment',
      nodeSelect: 'NodeSelect',
      priority: 'Priority',
      scriptArgs: 'ScriptArgs',
      scriptName: 'ScriptName',
      scriptPath: 'ScriptPath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      executionFailStrategy: 'string',
      executionMoment: 'string',
      nodeSelect: NodeSelector,
      priority: 'number',
      scriptArgs: 'string',
      scriptName: 'string',
      scriptPath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClusterStateChangeReason extends $tea.Model {
  /**
   * @remarks
   * 状态码。取值范围：
   * - UserRequest：用户请求。
   * - OutOfStock：请求的ECS实例类型无库存。
   * - NotAuthorized：无权限。
   * - QuotaExceeded：Quota超出。
   * - OperationDenied：操作被拒绝。
   * - AccountException：账号异常。
   * - NodeFailure：ECS节点异常。
   * - BootstrapFailure：引导失败。
   * - ValidationFail：业务逻辑校验失败。
   * - ServiceFailure：依赖的其他服务失败。
   * - InternalError：内部错误。
   * 
   * @example
   * OutOfStock
   */
  code?: string;
  /**
   * @remarks
   * 状态变化信息。
   * 
   * @example
   * The requested resource is sold out in the specified zone, try other types of resources or other regions and zones.
   */
  message?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClusterSummary extends $tea.Model {
  /**
   * @remarks
   * 集群ID。
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * 集群名称。
   * 
   * @example
   * emrtest
   */
  clusterName?: string;
  /**
   * @remarks
   * 集群状态。取值范围：
   * - STARTING：启动中。
   * - START_FAILED：启动失败。
   * - BOOTSTRAPPING：引导操作初始化。
   * - RUNNING：运行中。
   * - TERMINATING：终止中。
   * - TERMINATED：已终止。
   * - TERMINATED_WITH_ERRORS：发生异常导致终止。
   * - TERMINATE_FAILED：终止失败。
   * 
   * @example
   * RUNNING
   */
  clusterState?: string;
  /**
   * @remarks
   * 集群类型。取值范围：
   * - DATALAKE：新版数据湖。
   * - OLAP：数据分析。
   * - DATAFLOW：实时数据流。
   * - DATASERVING：数据服务。
   * 
   * @example
   * DATALAKE
   */
  clusterType?: string;
  /**
   * @remarks
   * 创建时间。
   * 
   * @example
   * 1592837465784
   */
  createTime?: number;
  description?: string;
  /**
   * @remarks
   * EMR服务角色。
   */
  emrDefaultRole?: string;
  /**
   * @remarks
   * 删除时间。
   * 
   * @example
   * 1592837465784
   */
  endTime?: number;
  /**
   * @remarks
   * 过期时间。
   * 
   * @example
   * 1592837465784
   */
  expireTime?: number;
  /**
   * @remarks
   * 付费类型。取值范围：
   * - PayAsYouGo：后付费。
   * - Subscription：预付费。
   * 
   * @example
   * PayAsYouGo
   */
  paymentType?: string;
  /**
   * @remarks
   * 可用时间。
   * 
   * @example
   * 1592837465784
   */
  readyTime?: number;
  /**
   * @remarks
   * EMR发行版。
   * 
   * @example
   * EMR-5.8.0
   */
  releaseVersion?: string;
  /**
   * @remarks
   * 资源组ID。
   * 
   * @example
   * rg-acfmzabjyop****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * 失败原因。
   */
  stateChangeReason?: ClusterStateChangeReason;
  /**
   * @remarks
   * 标签列表。
   */
  tags?: Tag[];
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      clusterState: 'ClusterState',
      clusterType: 'ClusterType',
      createTime: 'CreateTime',
      description: 'Description',
      emrDefaultRole: 'EmrDefaultRole',
      endTime: 'EndTime',
      expireTime: 'ExpireTime',
      paymentType: 'PaymentType',
      readyTime: 'ReadyTime',
      releaseVersion: 'ReleaseVersion',
      resourceGroupId: 'ResourceGroupId',
      stateChangeReason: 'StateChangeReason',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      clusterName: 'string',
      clusterState: 'string',
      clusterType: 'string',
      createTime: 'number',
      description: 'string',
      emrDefaultRole: 'string',
      endTime: 'number',
      expireTime: 'number',
      paymentType: 'string',
      readyTime: 'number',
      releaseVersion: 'string',
      resourceGroupId: 'string',
      stateChangeReason: ClusterStateChangeReason,
      tags: { 'type': 'array', 'itemType': Tag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ComponentInstanceSelector extends $tea.Model {
  /**
   * @deprecated
   */
  actionScope?: string;
  /**
   * @remarks
   * 应用名称。
   * 
   * @example
   * HDFS
   */
  applicationName?: string;
  /**
   * @remarks
   * 组件实例列表。actionScope为COPONENT_INSTANCE时使用。
   */
  componentInstances?: ComponentInstanceSelectorComponentInstances[];
  /**
   * @remarks
   * 组件列表。
   * actionScope为COPONENT时使用。
   */
  components?: ComponentInstanceSelectorComponents[];
  /**
   * @remarks
   * 动作执行范围。取值范围：
   * - APPLICATION：应用级别。
   * - COMPONENT：组件级别。
   * - COMPONENT_INSTANCE：组件实例级别。
   * 
   * This parameter is required.
   * 
   * @example
   * APPLICATION
   */
  runActionScope?: string;
  static names(): { [key: string]: string } {
    return {
      actionScope: 'ActionScope',
      applicationName: 'ApplicationName',
      componentInstances: 'ComponentInstances',
      components: 'Components',
      runActionScope: 'RunActionScope',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionScope: 'string',
      applicationName: 'string',
      componentInstances: { 'type': 'array', 'itemType': ComponentInstanceSelectorComponentInstances },
      components: { 'type': 'array', 'itemType': ComponentInstanceSelectorComponents },
      runActionScope: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ComponentLayout extends $tea.Model {
  /**
   * @remarks
   * 应用名称。
   * 
   * @example
   * HDFS
   */
  applicationName?: string;
  /**
   * @remarks
   * 组件名称。
   * 
   * @example
   * DataNode
   */
  componentName?: string;
  /**
   * @remarks
   * 节点选择器。
   */
  nodeSelector?: ComponentLayoutNodeSelector;
  static names(): { [key: string]: string } {
    return {
      applicationName: 'ApplicationName',
      componentName: 'ComponentName',
      nodeSelector: 'NodeSelector',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationName: 'string',
      componentName: 'string',
      nodeSelector: ComponentLayoutNodeSelector,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfigEffectActions extends $tea.Model {
  /**
   * @remarks
   * 配置生效动作。
   * 
   * @example
   * restart
   */
  configEffectAction?: string;
  /**
   * @remarks
   * 配置生效配置文件。
   * 
   * @example
   * null
   */
  configFiles?: string[];
  static names(): { [key: string]: string } {
    return {
      configEffectAction: 'ConfigEffectAction',
      configFiles: 'ConfigFiles',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configEffectAction: 'string',
      configFiles: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConvertNodeGroup extends $tea.Model {
  /**
   * @remarks
   * 节点组ID。
   * 
   * @example
   * ng-869471354ecd****
   */
  nodeGroupId?: string;
  /**
   * @remarks
   * 付费时长。
   * 
   * @example
   * 12
   */
  paymentDuration?: number;
  /**
   * @remarks
   * 付费时长单位。
   * 
   * @example
   * Month
   */
  paymentDurationUnit?: string;
  /**
   * @remarks
   * 付费类型。
   * 
   * @example
   * PayAsYouGo
   */
  paymentType?: string;
  static names(): { [key: string]: string } {
    return {
      nodeGroupId: 'NodeGroupId',
      paymentDuration: 'PaymentDuration',
      paymentDurationUnit: 'PaymentDurationUnit',
      paymentType: 'PaymentType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeGroupId: 'string',
      paymentDuration: 'number',
      paymentDurationUnit: 'string',
      paymentType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConvertNodeGroupParam extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  nodeGroupId?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  paymentDuration?: number;
  paymentDurationUnit?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  paymentType?: string;
  static names(): { [key: string]: string } {
    return {
      nodeGroupId: 'NodeGroupId',
      paymentDuration: 'PaymentDuration',
      paymentDurationUnit: 'PaymentDurationUnit',
      paymentType: 'PaymentType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeGroupId: 'string',
      paymentDuration: 'number',
      paymentDurationUnit: 'string',
      paymentType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CostOptimizedConfig extends $tea.Model {
  /**
   * @remarks
   * 按量实例个数的最小值。节点组所需要按量实例个数的最小值，取值范围：0~1000。当按量实例个数少于该值时，将优先创建按量实例。
   * 
   * This parameter is required.
   * 
   * @example
   * 80
   */
  onDemandBaseCapacity?: number;
  /**
   * @remarks
   * 节点组满足最小按量实例OnDemandBaseCapacity要求后，超出的实例中按量实例应占的比例，取值范围：0～100。
   * 
   * This parameter is required.
   * 
   * @example
   * 80
   */
  onDemandPercentageAboveBaseCapacity?: number;
  /**
   * @remarks
   * 指定可用实例规格的个数，伸缩组将按成本最低的多个规格均衡创建抢占式实例。取值范围：0~10。
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  spotInstancePools?: number;
  static names(): { [key: string]: string } {
    return {
      onDemandBaseCapacity: 'OnDemandBaseCapacity',
      onDemandPercentageAboveBaseCapacity: 'OnDemandPercentageAboveBaseCapacity',
      spotInstancePools: 'SpotInstancePools',
    };
  }

  static types(): { [key: string]: any } {
    return {
      onDemandBaseCapacity: 'number',
      onDemandPercentageAboveBaseCapacity: 'number',
      spotInstancePools: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNodeGroupParam extends $tea.Model {
  /**
   * @example
   * false
   */
  autoRenew?: boolean;
  /**
   * @example
   * 1
   */
  autoRenewDuration?: number;
  /**
   * @example
   * Monthly
   */
  autoRenewDurationUnit?: string;
  dataDisks?: DiskInfo[];
  instanceTypes?: string[];
  /**
   * @example
   * 2
   */
  nodeCount?: number;
  /**
   * @example
   * core-1
   */
  nodeGroupName?: string;
  /**
   * @example
   * CORE
   */
  nodeGroupType?: string;
  /**
   * @example
   * sshkey
   */
  nodeKeyPairName?: string;
  /**
   * @example
   * AliyunEmrEcsDefaultRole
   */
  nodeRamRole?: string;
  /**
   * @example
   * *******
   */
  nodeRootPassword?: string;
  /**
   * @example
   * 1
   */
  paymentDuration?: number;
  /**
   * @example
   * Monthly
   */
  paymentDurationUnit?: string;
  /**
   * @example
   * Subscription
   */
  paymentType?: string;
  /**
   * @example
   * sg-hp3abbae8lb6lmb1****
   */
  securityGroupId?: string;
  /**
   * @example
   * NoSpot
   */
  spotStrategy?: string;
  systemDisk?: SystemDiskParam;
  vSwitchIds?: string[];
  /**
   * @example
   * true
   */
  withPublicIp?: boolean;
  /**
   * @example
   * cn-hangzhou-e
   */
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      autoRenew: 'AutoRenew',
      autoRenewDuration: 'AutoRenewDuration',
      autoRenewDurationUnit: 'AutoRenewDurationUnit',
      dataDisks: 'DataDisks',
      instanceTypes: 'InstanceTypes',
      nodeCount: 'NodeCount',
      nodeGroupName: 'NodeGroupName',
      nodeGroupType: 'NodeGroupType',
      nodeKeyPairName: 'NodeKeyPairName',
      nodeRamRole: 'NodeRamRole',
      nodeRootPassword: 'NodeRootPassword',
      paymentDuration: 'PaymentDuration',
      paymentDurationUnit: 'PaymentDurationUnit',
      paymentType: 'PaymentType',
      securityGroupId: 'SecurityGroupId',
      spotStrategy: 'SpotStrategy',
      systemDisk: 'SystemDisk',
      vSwitchIds: 'VSwitchIds',
      withPublicIp: 'WithPublicIp',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRenew: 'boolean',
      autoRenewDuration: 'number',
      autoRenewDurationUnit: 'string',
      dataDisks: { 'type': 'array', 'itemType': DiskInfo },
      instanceTypes: { 'type': 'array', 'itemType': 'string' },
      nodeCount: 'number',
      nodeGroupName: 'string',
      nodeGroupType: 'string',
      nodeKeyPairName: 'string',
      nodeRamRole: 'string',
      nodeRootPassword: 'string',
      paymentDuration: 'number',
      paymentDurationUnit: 'string',
      paymentType: 'string',
      securityGroupId: 'string',
      spotStrategy: 'string',
      systemDisk: SystemDiskParam,
      vSwitchIds: { 'type': 'array', 'itemType': 'string' },
      withPublicIp: 'boolean',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DataDisk extends $tea.Model {
  /**
   * @remarks
   * 磁盘类型。
   * 
   * This parameter is required.
   * 
   * @example
   * cloud_essd
   */
  category?: string;
  /**
   * @remarks
   * 每个节点磁盘数量。
   * 
   * @example
   * 5
   */
  count?: number;
  /**
   * @remarks
   * 创建ESSD云盘作为数据盘使用时，设置云盘的性能等级。取值范围：
   * - PL0：单盘最高随机读写IOPS 1万。
   * - PL1（默认）：单盘最高随机读写IOPS 5万。
   * - PL2：单盘最高随机读写IOPS 10万。
   * - PL3：单盘最高随机读写IOPS 100万。
   * 
   * 默认值：PL1。
   * 
   * @example
   * PL1
   */
  performanceLevel?: string;
  /**
   * @remarks
   * 单位GB。
   * 
   * This parameter is required.
   * 
   * @example
   * 80
   */
  size?: number;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      count: 'Count',
      performanceLevel: 'PerformanceLevel',
      size: 'Size',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      count: 'number',
      performanceLevel: 'string',
      size: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DecreaseNodeGroupParam extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * G-21E39B11837E****
   */
  nodeGroupId?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  releaseInstanceIds?: string[];
  static names(): { [key: string]: string } {
    return {
      nodeGroupId: 'NodeGroupId',
      releaseInstanceIds: 'ReleaseInstanceIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeGroupId: 'string',
      releaseInstanceIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeploymentLayout extends $tea.Model {
  applicationName?: string;
  componentName?: string;
  nodeSelector?: NodeSelector;
  static names(): { [key: string]: string } {
    return {
      applicationName: 'ApplicationName',
      componentName: 'ComponentName',
      nodeSelector: 'NodeSelector',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationName: 'string',
      componentName: 'string',
      nodeSelector: NodeSelector,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeploymentSetConstraints extends $tea.Model {
  /**
   * @remarks
   * 默认值。
   * 
   * @example
   * CLUSTER
   */
  defaultValue?: string;
  /**
   * @example
   * 是否启用部署集限制策略
   */
  enableState?: string;
  /**
   * @remarks
   * 替换策略。
   */
  replacementStrategy?: ReplacementStrategy;
  /**
   * @remarks
   * 枚举值。
   * 
   * @example
   * ["CLUSTER","NODE_GROUP","NONE"]
   */
  values?: string[];
  static names(): { [key: string]: string } {
    return {
      defaultValue: 'DefaultValue',
      enableState: 'EnableState',
      replacementStrategy: 'ReplacementStrategy',
      values: 'Values',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultValue: 'string',
      enableState: 'string',
      replacementStrategy: ReplacementStrategy,
      values: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class Disk extends $tea.Model {
  /**
   * @remarks
   * 磁盘类型。
   * 
   * @example
   * cloud_essd
   */
  category?: string;
  /**
   * @remarks
   * 每个节点磁盘数量。
   * 
   * @example
   * 5
   */
  count?: number;
  /**
   * @remarks
   * 性能级别。
   * 
   * @example
   * S0
   */
  performanceLevel?: string;
  /**
   * @remarks
   * 单位GB。
   * 
   * @example
   * 80
   */
  size?: number;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      count: 'Count',
      performanceLevel: 'PerformanceLevel',
      size: 'Size',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      count: 'number',
      performanceLevel: 'string',
      size: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DiskConstraints extends $tea.Model {
  /**
   * @remarks
   * 支持的磁盘类型。
   * 
   * @example
   * ["cloud_efficiency","cloud_ssd","cloud_essd","local_disk"]
   */
  categories?: string[];
  /**
   * @remarks
   * 磁盘数量最小值。
   */
  countConstraint?: ValueConstraints;
  /**
   * @remarks
   * 磁盘容量限制。
   */
  sizeConstraint?: ValueConstraints;
  static names(): { [key: string]: string } {
    return {
      categories: 'Categories',
      countConstraint: 'CountConstraint',
      sizeConstraint: 'SizeConstraint',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categories: { 'type': 'array', 'itemType': 'string' },
      countConstraint: ValueConstraints,
      sizeConstraint: ValueConstraints,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DiskInfo extends $tea.Model {
  category?: string;
  count?: number;
  performanceLevel?: string;
  size?: number;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      count: 'Count',
      performanceLevel: 'PerformanceLevel',
      size: 'Size',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      count: 'number',
      performanceLevel: 'string',
      size: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DiskSize extends $tea.Model {
  /**
   * @remarks
   * 磁盘类型。
   * 
   * This parameter is required.
   * 
   * @example
   * cloud_essd
   */
  category?: string;
  /**
   * @remarks
   * 单位GB。
   * 
   * @example
   * 80
   */
  size?: number;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      size: 'Size',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      size: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FailedReason extends $tea.Model {
  /**
   * @remarks
   * 错误码。
   * 
   * @example
   * MissingParameter.InstanceType
   */
  errorCode?: string;
  /**
   * @remarks
   * 错误信息。
   * 
   * @example
   * The instance type is required.
   */
  errorMessage?: string;
  /**
   * @remarks
   * 请求ID。
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944abcd
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class HealthSummary extends $tea.Model {
  /**
   * @example
   * 2
   */
  badCount?: number;
  /**
   * @example
   * 2
   */
  goodCount?: number;
  /**
   * @example
   * 0
   */
  noneCount?: number;
  /**
   * @example
   * 2
   */
  stoppedCount?: number;
  /**
   * @example
   * 8
   */
  totalCount?: number;
  /**
   * @example
   * 0
   */
  unknownCount?: number;
  /**
   * @example
   * 2
   */
  warningCount?: number;
  static names(): { [key: string]: string } {
    return {
      badCount: 'BadCount',
      goodCount: 'GoodCount',
      noneCount: 'NoneCount',
      stoppedCount: 'StoppedCount',
      totalCount: 'TotalCount',
      unknownCount: 'UnknownCount',
      warningCount: 'WarningCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      badCount: 'number',
      goodCount: 'number',
      noneCount: 'number',
      stoppedCount: 'number',
      totalCount: 'number',
      unknownCount: 'number',
      warningCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class IncreaseNodeGroup extends $tea.Model {
  /**
   * @remarks
   * 描述。
   * 
   * @example
   * 描述
   */
  description?: string;
  /**
   * @remarks
   * 节点数量。
   * 
   * This parameter is required.
   * 
   * @example
   * 3
   */
  nodeCount?: number;
  /**
   * @remarks
   * 节点组ID。
   * 
   * This parameter is required.
   * 
   * @example
   * ng-869471354ecd****
   */
  nodeGroupId?: string;
  /**
   * @remarks
   * 付费时长。
   * 
   * @example
   * 12
   */
  paymentDuration?: number;
  /**
   * @remarks
   * 付费时长单位。
   * 
   * @example
   * Month
   */
  paymentDurationUnit?: string;
  /**
   * @remarks
   * 虚拟机交换机ID。
   * 
   * @example
   * vsw-hp35g7ya5ymw68mmg****
   */
  vSwitchId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      nodeCount: 'NodeCount',
      nodeGroupId: 'NodeGroupId',
      paymentDuration: 'PaymentDuration',
      paymentDurationUnit: 'PaymentDurationUnit',
      vSwitchId: 'VSwitchId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      nodeCount: 'number',
      nodeGroupId: 'string',
      paymentDuration: 'number',
      paymentDurationUnit: 'string',
      vSwitchId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class IncreaseNodeGroupParam extends $tea.Model {
  nodeCount?: number;
  nodeGroupId?: string;
  paymentDuration?: number;
  paymentDurationUnit?: string;
  vSwitchId?: string;
  static names(): { [key: string]: string } {
    return {
      nodeCount: 'NodeCount',
      nodeGroupId: 'NodeGroupId',
      paymentDuration: 'PaymentDuration',
      paymentDurationUnit: 'PaymentDurationUnit',
      vSwitchId: 'VSwitchId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeCount: 'number',
      nodeGroupId: 'string',
      paymentDuration: 'number',
      paymentDurationUnit: 'string',
      vSwitchId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstanceCategory extends $tea.Model {
  /**
   * @remarks
   * 默认值。
   * 
   * @example
   * CLUSTER
   */
  defaultValue?: string;
  /**
   * @example
   * null
   */
  keys?: string[];
  /**
   * @example
   * null
   */
  values?: string[];
  static names(): { [key: string]: string } {
    return {
      defaultValue: 'DefaultValue',
      keys: 'Keys',
      values: 'Values',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultValue: 'string',
      keys: { 'type': 'array', 'itemType': 'string' },
      values: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstanceType extends $tea.Model {
  /**
   * @remarks
   * cpu架构。
   * 
   * @example
   * X86
   */
  cpuArchitecture?: string;
  /**
   * @remarks
   * vCPU内核数目。
   * 
   * @example
   * 4
   */
  cpuCore?: number;
  /**
   * @remarks
   * 实例规格分类。取值范围：
   * - General-purpose： 通用型。
   * - Compute-optimized：计算型。
   * - Memory-optimized：内存型。
   * - Big data：大数据型。
   * - Local SSDs ：本地SSD型。
   * - High Clock Speed ：高主频型。
   * - Enhanced ：增强型。
   * - Shared：共享型。
   * - Compute-optimized with GPU ：GPU计算型。
   * - Visual Compute-optimized ：视觉计算型。
   * - Heterogeneous Service ：异构服务型。
   * - Compute-optimized with FPGA ：FPGA计算型。
   * - Compute-optimized with NPU ：NPU计算型。
   * - ECS Bare Metal ：弹性裸金属服务器。
   * - Super Computing Cluster：超级计算集群。
   * 
   * @example
   * Compute-optimized
   */
  instanceCategory?: string;
  /**
   * @remarks
   * 实例规格。
   * 
   * @example
   * ecs.g6.large
   */
  instanceType?: string;
  /**
   * @remarks
   * 实例规格所属的实例规格族。取值请参见DescribeInstanceTypeFamilies。
   * 
   * @example
   * ecs.g6
   */
  instanceTypeFamily?: string;
  /**
   * @remarks
   * 实例挂载的本地盘的数量。
   * 
   * @example
   * 8
   */
  localStorageAmount?: number;
  /**
   * @remarks
   * 实例挂载的本地盘的单盘容量。单位：GiB
   * 
   * @example
   * 40
   */
  localStorageCapacity?: number;
  /**
   * @remarks
   * 是否IO优化类型。
   * 
   * @example
   * true
   */
  optimized?: boolean;
  static names(): { [key: string]: string } {
    return {
      cpuArchitecture: 'CpuArchitecture',
      cpuCore: 'CpuCore',
      instanceCategory: 'InstanceCategory',
      instanceType: 'InstanceType',
      instanceTypeFamily: 'InstanceTypeFamily',
      localStorageAmount: 'LocalStorageAmount',
      localStorageCapacity: 'LocalStorageCapacity',
      optimized: 'Optimized',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpuArchitecture: 'string',
      cpuCore: 'number',
      instanceCategory: 'string',
      instanceType: 'string',
      instanceTypeFamily: 'string',
      localStorageAmount: 'number',
      localStorageCapacity: 'number',
      optimized: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class KeyValue extends $tea.Model {
  /**
   * @remarks
   * 键。
   * 
   * @example
   * key
   */
  key?: string;
  /**
   * @remarks
   * 值。
   * 
   * @example
   * value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApiTemplatesDTO extends $tea.Model {
  apiName?: string;
  content?: string;
  gmtCreate?: number;
  gmtModified?: number;
  id?: number;
  operatorId?: string;
  regionId?: string;
  resourceGroupId?: string;
  status?: string;
  templateId?: string;
  templateName?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      apiName: 'ApiName',
      content: 'Content',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      operatorId: 'OperatorId',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      status: 'Status',
      templateId: 'TemplateId',
      templateName: 'TemplateName',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiName: 'string',
      content: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      id: 'number',
      operatorId: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      status: 'string',
      templateId: 'string',
      templateName: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ManagedScalingConstraints extends $tea.Model {
  /**
   * @remarks
   * 最大值。
   * 
   * @example
   * 2000
   */
  maxCapacity?: number;
  /**
   * @remarks
   * 最大按量节点数量
   * 
   * @example
   * 0
   */
  maxOnDemandCapacity?: number;
  /**
   * @remarks
   * 最小值。
   * 
   * @example
   * 0
   */
  minCapacity?: number;
  static names(): { [key: string]: string } {
    return {
      maxCapacity: 'MaxCapacity',
      maxOnDemandCapacity: 'MaxOnDemandCapacity',
      minCapacity: 'MinCapacity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxCapacity: 'number',
      maxOnDemandCapacity: 'number',
      minCapacity: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MetaStoreConf extends $tea.Model {
  dbPassword?: string;
  dbUrl?: string;
  dbUserName?: string;
  static names(): { [key: string]: string } {
    return {
      dbPassword: 'DbPassword',
      dbUrl: 'DbUrl',
      dbUserName: 'DbUserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbPassword: 'string',
      dbUrl: 'string',
      dbUserName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MetricUnitValue extends $tea.Model {
  /**
   * @remarks
   * 指标名称。
   */
  metricName?: string;
  /**
   * @remarks
   * 指标单位。
   */
  metricUnit?: string;
  static names(): { [key: string]: string } {
    return {
      metricName: 'MetricName',
      metricUnit: 'MetricUnit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      metricName: 'string',
      metricUnit: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MetricsTrigger extends $tea.Model {
  /**
   * @remarks
   * 多指标逻辑关系。默认：Or。取值范围：
   * - And:与
   * - Or：或
   * 
   * @example
   * Or
   */
  conditionLogicOperator?: string;
  /**
   * @remarks
   * 指标触发条件列表。
   */
  conditions?: TriggerCondition[];
  /**
   * @remarks
   * 冷却时间。 单位为秒
   * 
   * @example
   * 300
   */
  coolDownInterval?: number;
  /**
   * @remarks
   * 统计次数。
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  evaluationCount?: number;
  /**
   * @remarks
   * 时间限制。
   */
  timeConstraints?: TimeConstraint[];
  /**
   * @remarks
   * 统计窗口。单位为秒。
   * 
   * This parameter is required.
   * 
   * @example
   * 30
   */
  timeWindow?: number;
  static names(): { [key: string]: string } {
    return {
      conditionLogicOperator: 'ConditionLogicOperator',
      conditions: 'Conditions',
      coolDownInterval: 'CoolDownInterval',
      evaluationCount: 'EvaluationCount',
      timeConstraints: 'TimeConstraints',
      timeWindow: 'TimeWindow',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conditionLogicOperator: 'string',
      conditions: { 'type': 'array', 'itemType': TriggerCondition },
      coolDownInterval: 'number',
      evaluationCount: 'number',
      timeConstraints: { 'type': 'array', 'itemType': TimeConstraint },
      timeWindow: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class Node extends $tea.Model {
  /**
   * @remarks
   * 节点是否自动续费。
   * 
   * @example
   * false
   */
  autoRenew?: boolean;
  /**
   * @remarks
   * 节点自动续费时长。
   * 
   * @example
   * 1
   */
  autoRenewDuration?: number;
  /**
   * @remarks
   * 节点自动续费时长单位。
   * 
   * @example
   * Month
   */
  autoRenewDurationUnit?: string;
  createTime?: number;
  /**
   * @remarks
   * 节点过期时间。
   * 
   * @example
   * 1603728394857
   */
  expireTime?: number;
  /**
   * @remarks
   * 实例类型。
   * 
   * @example
   * ecs.g6e.xlarge
   */
  instanceType?: string;
  /**
   * @remarks
   * 运维模式状态。取值范围：
   * - ON：处于运维模式。
   * - OFF：处于非运维模式。
   * 
   * 为空表示处于非运维模式。
   */
  maintenanceStatus?: string;
  /**
   * @remarks
   * 节点组ID。
   * 
   * @example
   * ng-869471354ecd****
   */
  nodeGroupId?: string;
  /**
   * @remarks
   * 节点组类型。
   * 
   * @example
   * CORE
   */
  nodeGroupType?: string;
  /**
   * @remarks
   * 节点ID。
   * 
   * @example
   * i-bp1cudc25w2bfwl5****
   */
  nodeId?: string;
  /**
   * @remarks
   * 节点名称。
   * 
   * @example
   * core1-1
   */
  nodeName?: string;
  /**
   * @remarks
   * 节点状态。取值范围：
   * - Pending：创建中。
   * - Starting：启动中。
   * - Running：运行中。
   * - Stopping：停止中。
   * - Stopped：已停止。
   * - Terminated：已终止。
   * 
   * @example
   * Running
   */
  nodeState?: string;
  /**
   * @remarks
   * 私网IP。
   * 
   * @example
   * 10.10.10.1
   */
  privateIp?: string;
  /**
   * @remarks
   * 公网IP。
   * 
   * @example
   * 42.120.75.***
   */
  publicIp?: string;
  /**
   * @remarks
   * 可用区ID。
   * 
   * @example
   * cn-beijing-h
   */
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      autoRenew: 'AutoRenew',
      autoRenewDuration: 'AutoRenewDuration',
      autoRenewDurationUnit: 'AutoRenewDurationUnit',
      createTime: 'CreateTime',
      expireTime: 'ExpireTime',
      instanceType: 'InstanceType',
      maintenanceStatus: 'MaintenanceStatus',
      nodeGroupId: 'NodeGroupId',
      nodeGroupType: 'NodeGroupType',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      nodeState: 'NodeState',
      privateIp: 'PrivateIp',
      publicIp: 'PublicIp',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRenew: 'boolean',
      autoRenewDuration: 'number',
      autoRenewDurationUnit: 'string',
      createTime: 'number',
      expireTime: 'number',
      instanceType: 'string',
      maintenanceStatus: 'string',
      nodeGroupId: 'string',
      nodeGroupType: 'string',
      nodeId: 'string',
      nodeName: 'string',
      nodeState: 'string',
      privateIp: 'string',
      publicIp: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NodeAttributes extends $tea.Model {
  /**
   * @remarks
   * ECS ssh登录秘钥。
   * 
   * @example
   * emr_login
   */
  keyPairName?: string;
  /**
   * @remarks
   * MASTER节点root密码。
   * 
   * @example
   * Adxefswfd****
   */
  masterRootPassword?: string;
  /**
   * @remarks
   * ECS访问资源绑定的角色。
   * 
   * @example
   * AliyunECSInstanceForEMRRole
   */
  ramRole?: string;
  /**
   * @remarks
   * 安全组ID。EMR只支持普通安全组，不支持企业安全组。
   * 
   * This parameter is required.
   * 
   * @example
   * sg-hp3abbae8lb6lmb1****
   */
  securityGroupId?: string;
  /**
   * @remarks
   * 专有网络ID。
   * 
   * This parameter is required.
   * 
   * @example
   * vpc-bp1tgey2p0ytxmdo5****
   */
  vpcId?: string;
  /**
   * @remarks
   * 可用区ID。
   * 
   * This parameter is required.
   * 
   * @example
   * cn-beijing-h
   */
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      keyPairName: 'KeyPairName',
      masterRootPassword: 'MasterRootPassword',
      ramRole: 'RamRole',
      securityGroupId: 'SecurityGroupId',
      vpcId: 'VpcId',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keyPairName: 'string',
      masterRootPassword: 'string',
      ramRole: 'string',
      securityGroupId: 'string',
      vpcId: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NodeCountConstraint extends $tea.Model {
  /**
   * @example
   * 100
   */
  max?: number;
  /**
   * @example
   * 1
   */
  min?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * range
   */
  type?: string;
  values?: number[];
  static names(): { [key: string]: string } {
    return {
      max: 'Max',
      min: 'Min',
      type: 'Type',
      values: 'Values',
    };
  }

  static types(): { [key: string]: any } {
    return {
      max: 'number',
      min: 'number',
      type: 'string',
      values: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NodeGroup extends $tea.Model {
  /**
   * @remarks
   * 安全组ID。
   * 
   * @example
   * ["sg-hp3abbae8lb6lmb1****"]
   */
  additionalSecurityGroupIds?: string[];
  /**
   * @remarks
   * 成本优化模式配置。
   */
  costOptimizedConfig?: CostOptimizedConfig;
  /**
   * @remarks
   * 数据盘列表。
   */
  dataDisks?: DataDisk[];
  /**
   * @remarks
   * 部署集策略。取值范围：
   * - NONE：不适用部署集。
   * - CLUSTER：使用集群级别部署集。
   * - NODE_GROUP：使用节点组级别部署集。
   * 
   * 默认值：NONE。
   * 
   * @example
   * NONE
   */
  deploymentSetStrategy?: string;
  /**
   * @remarks
   * 节点组上部署的组件是否开启优雅下线。取值范围：
   * - true：开启优雅下线。
   * - false：不开启优雅下线。
   * 
   * @example
   * false
   */
  gracefulShutdown?: boolean;
  /**
   * @remarks
   * 实例类型列表。
   * 
   * @example
   * ["ecs.g6.4xlarge"]
   */
  instanceTypes?: string[];
  /**
   * @remarks
   * 节点组ID。
   * 
   * @example
   * ng-869471354ecd****
   */
  nodeGroupId?: string;
  /**
   * @remarks
   * 节点组名称。最大长度128个字符。
   * 
   * @example
   * core-1
   */
  nodeGroupName?: string;
  /**
   * @remarks
   * 节点组状态。
   * 
   * @example
   * CREATED
   */
  nodeGroupState?: string;
  /**
   * @remarks
   * 节点组类型。取值范围：
   * - MASTER：管理类型节点组。
   * - CORE：存储类型节点组。
   * - TASK：计算类型节点组。
   * 
   * @example
   * CORE
   */
  nodeGroupType?: string;
  /**
   * @remarks
   * - COST_OPTIMIZED：成本优化策略。
   * - PRIORITY：优先级策略。
   * 
   * @example
   * PRIORITY
   */
  nodeResizeStrategy?: string;
  /**
   * @remarks
   * 节点组付费类型。取值范围：
   * - PayAsYouGo：后付费，按量付费。
   * - Subscription：预付费，包年包月。
   * 
   * @example
   * PayAsYouGo
   */
  paymentType?: string;
  /**
   * @remarks
   * 存活节点数量。
   * 
   * @example
   * 3
   */
  runningNodeCount?: number;
  spotBidPrices?: SpotBidPrice[];
  /**
   * @remarks
   * 开启补齐抢占式实例后，当收到抢占式实例将被回收的系统消息时，伸缩组将尝试创建新的实例，替换掉将被回收的抢占式实例。取值范围：
   * - true：开启补齐抢占式实例。
   * - false：不开启补齐抢占式实例。
   * 
   * 默认值：false。
   * 
   * @example
   * true
   */
  spotInstanceRemedy?: boolean;
  /**
   * @remarks
   * 是否支持竞价实例。
   * 
   * @example
   * NoSpot
   */
  spotStrategy?: string;
  /**
   * @remarks
   * 状态变化原因。
   */
  stateChangeReason?: NodeGroupStateChangeReason;
  /**
   * @remarks
   * 节点组状态，NodeGroupState别名。
   * 
   * @example
   * CREATED
   */
  status?: string;
  /**
   * @remarks
   * 系统盘信息。
   */
  systemDisk?: SystemDisk;
  /**
   * @remarks
   * 虚拟机交换机ID列表。
   * 
   * @example
   * ["vsw-hp35g7ya5ymw68mmg****"]
   */
  vSwitchIds?: string[];
  /**
   * @remarks
   * 是否开公网IP。取值范围：
   * - true：开公网。
   * - false：不开公网。
   * 
   * @example
   * false
   */
  withPublicIp?: boolean;
  /**
   * @remarks
   * 可用区ID。
   * 
   * @example
   * cn-beijing-h
   */
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      additionalSecurityGroupIds: 'AdditionalSecurityGroupIds',
      costOptimizedConfig: 'CostOptimizedConfig',
      dataDisks: 'DataDisks',
      deploymentSetStrategy: 'DeploymentSetStrategy',
      gracefulShutdown: 'GracefulShutdown',
      instanceTypes: 'InstanceTypes',
      nodeGroupId: 'NodeGroupId',
      nodeGroupName: 'NodeGroupName',
      nodeGroupState: 'NodeGroupState',
      nodeGroupType: 'NodeGroupType',
      nodeResizeStrategy: 'NodeResizeStrategy',
      paymentType: 'PaymentType',
      runningNodeCount: 'RunningNodeCount',
      spotBidPrices: 'SpotBidPrices',
      spotInstanceRemedy: 'SpotInstanceRemedy',
      spotStrategy: 'SpotStrategy',
      stateChangeReason: 'StateChangeReason',
      status: 'Status',
      systemDisk: 'SystemDisk',
      vSwitchIds: 'VSwitchIds',
      withPublicIp: 'WithPublicIp',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      additionalSecurityGroupIds: { 'type': 'array', 'itemType': 'string' },
      costOptimizedConfig: CostOptimizedConfig,
      dataDisks: { 'type': 'array', 'itemType': DataDisk },
      deploymentSetStrategy: 'string',
      gracefulShutdown: 'boolean',
      instanceTypes: { 'type': 'array', 'itemType': 'string' },
      nodeGroupId: 'string',
      nodeGroupName: 'string',
      nodeGroupState: 'string',
      nodeGroupType: 'string',
      nodeResizeStrategy: 'string',
      paymentType: 'string',
      runningNodeCount: 'number',
      spotBidPrices: { 'type': 'array', 'itemType': SpotBidPrice },
      spotInstanceRemedy: 'boolean',
      spotStrategy: 'string',
      stateChangeReason: NodeGroupStateChangeReason,
      status: 'string',
      systemDisk: SystemDisk,
      vSwitchIds: { 'type': 'array', 'itemType': 'string' },
      withPublicIp: 'boolean',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NodeGroupConfig extends $tea.Model {
  /**
   * @remarks
   * 附加安全组。除集群设置的安全组外，为节点组单独设置的附加安全组。数组元数个数N的取值范围：0~2。
   * 
   * @example
   * ["sg-hp3abbae8lb6lmb1****"]
   */
  additionalSecurityGroupIds?: string[];
  autoScalingPolicy?: AutoScalingPolicy;
  componentTags?: string[];
  /**
   * @remarks
   * 成本优化模式配置。
   */
  costOptimizedConfig?: CostOptimizedConfig;
  /**
   * @remarks
   * 数据盘。当前数据盘只支持一种磁盘类型，即数组元数个数N的取值范围：1~1。
   */
  dataDisks?: DataDisk[];
  /**
   * @remarks
   * 部署集策略。取值范围：
   * - NONE：不适用部署集。
   * - CLUSTER：使用集群级别部署集。
   * - NODE_GROUP：使用节点组级别部署集。
   * 
   * 默认值：NONE。
   * 
   * @example
   * NONE
   */
  deploymentSetStrategy?: string;
  /**
   * @remarks
   * 节点组上部署的组件是否开启优雅下线。取值范围：
   * - true：开启优雅下线。
   * - false：不开启优雅下线。
   * 
   * 默认值：false。
   * 
   * @example
   * false
   */
  gracefulShutdown?: boolean;
  /**
   * @remarks
   * 节点实例类型列表。数组元数个数N的取值范围：1~100。
   * 
   * @example
   * ["ecs.g6.xlarge"]
   */
  instanceTypes?: string[];
  /**
   * @remarks
   * 节点数量。取值范围：1~1000。
   * 
   * @example
   * 3
   */
  nodeCount?: number;
  /**
   * @remarks
   * 节点组名称。最大长度128个字符。集群内要求节点组名称唯一。
   * 
   * @example
   * core-1
   */
  nodeGroupName?: string;
  /**
   * @remarks
   * 节点组类型。取值范围：
   * - MASTER：管理类型节点组。
   * - CORE：存储类型节点组。
   * - TASK：计算类型节点组。
   * 
   * This parameter is required.
   * 
   * @example
   * CORE
   */
  nodeGroupType?: string;
  /**
   * @remarks
   * 节点扩容策略。取值范围：
   * - COST_OPTIMIZED：成本优化策略。
   * - PRIORITY：优先级策略。
   * 
   * 默认值：PRIORITY。
   * 
   * @example
   * PRIORITY
   */
  nodeResizeStrategy?: string;
  /**
   * @remarks
   * 节点组付费类型。不传入时默认和集群付费类型一致。取值范围：
   * - PayAsYouGo：后付费，按量付费。
   * - Subscription：预付费，包年包月。
   * 
   * 默认值：PayAsYouGo。
   * 
   * @example
   * PayAsYouGo
   */
  paymentType?: string;
  /**
   * @remarks
   * 抢占式Spot实例出价价格。参数SpotStrategy取值为SpotWithPriceLimit时生效。数组元数个数N的取值范围：0~100。
   */
  spotBidPrices?: SpotBidPrice[];
  /**
   * @remarks
   * 开启后，当收到抢占式实例将被回收的系统消息时，伸缩组将尝试创建新的实例，替换掉将被回收的抢占式实例。取值范围：
   * - true：开启补齐抢占式实例。
   * - false：不开启补齐抢占式实例。
   * 
   * 默认值：false。
   * 
   * @example
   * true
   */
  spotInstanceRemedy?: boolean;
  /**
   * @remarks
   * 抢占式Spot实例策略。取值范围：
   * - NoSpot：正常按量付费实例。
   * - SpotWithPriceLimit：设置最高出价的抢占式实例。
   * - SpotAsPriceGo：系统自动出价，最高按量付费价格的抢占式实例。
   * 
   * 默认值：NoSpot。
   * 
   * @example
   * NoSpot
   */
  spotStrategy?: string;
  /**
   * @remarks
   * 节点组预付费配置。不传入时默认和集群预付费配置一致。
   */
  subscriptionConfig?: SubscriptionConfig;
  /**
   * @remarks
   * 系统盘。
   */
  systemDisk?: SystemDisk;
  /**
   * @remarks
   * 虚拟机交换机ID列表。数组元数个数N的取值范围：1~20。
   * 
   * @example
   * ["vsw-hp35g7ya5ymw68mmg****"]
   */
  vSwitchIds?: string[];
  /**
   * @remarks
   * 是否开公网IP。取值范围：
   * - true：开公网。
   * - false：不开公网。
   * 
   * 默认值：false。
   * 
   * @example
   * false
   */
  withPublicIp?: boolean;
  static names(): { [key: string]: string } {
    return {
      additionalSecurityGroupIds: 'AdditionalSecurityGroupIds',
      autoScalingPolicy: 'AutoScalingPolicy',
      componentTags: 'ComponentTags',
      costOptimizedConfig: 'CostOptimizedConfig',
      dataDisks: 'DataDisks',
      deploymentSetStrategy: 'DeploymentSetStrategy',
      gracefulShutdown: 'GracefulShutdown',
      instanceTypes: 'InstanceTypes',
      nodeCount: 'NodeCount',
      nodeGroupName: 'NodeGroupName',
      nodeGroupType: 'NodeGroupType',
      nodeResizeStrategy: 'NodeResizeStrategy',
      paymentType: 'PaymentType',
      spotBidPrices: 'SpotBidPrices',
      spotInstanceRemedy: 'SpotInstanceRemedy',
      spotStrategy: 'SpotStrategy',
      subscriptionConfig: 'SubscriptionConfig',
      systemDisk: 'SystemDisk',
      vSwitchIds: 'VSwitchIds',
      withPublicIp: 'WithPublicIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      additionalSecurityGroupIds: { 'type': 'array', 'itemType': 'string' },
      autoScalingPolicy: AutoScalingPolicy,
      componentTags: { 'type': 'array', 'itemType': 'string' },
      costOptimizedConfig: CostOptimizedConfig,
      dataDisks: { 'type': 'array', 'itemType': DataDisk },
      deploymentSetStrategy: 'string',
      gracefulShutdown: 'boolean',
      instanceTypes: { 'type': 'array', 'itemType': 'string' },
      nodeCount: 'number',
      nodeGroupName: 'string',
      nodeGroupType: 'string',
      nodeResizeStrategy: 'string',
      paymentType: 'string',
      spotBidPrices: { 'type': 'array', 'itemType': SpotBidPrice },
      spotInstanceRemedy: 'boolean',
      spotStrategy: 'string',
      subscriptionConfig: SubscriptionConfig,
      systemDisk: SystemDisk,
      vSwitchIds: { 'type': 'array', 'itemType': 'string' },
      withPublicIp: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NodeGroupParam extends $tea.Model {
  autoPayOrder?: boolean;
  autoRenew?: boolean;
  autoRenewDuration?: number;
  autoRenewDurationUnit?: string;
  dataDisks?: DiskInfo[];
  description?: string;
  instanceTypes?: string[];
  nodeCount?: number;
  nodeGroupIndex?: number;
  nodeGroupName?: string;
  nodeGroupType?: string;
  paymentDuration?: number;
  paymentDurationUnit?: string;
  paymentType?: string;
  systemDisk?: SystemDiskParam;
  vSwitchIds?: string[];
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      autoPayOrder: 'AutoPayOrder',
      autoRenew: 'AutoRenew',
      autoRenewDuration: 'AutoRenewDuration',
      autoRenewDurationUnit: 'AutoRenewDurationUnit',
      dataDisks: 'DataDisks',
      description: 'Description',
      instanceTypes: 'InstanceTypes',
      nodeCount: 'NodeCount',
      nodeGroupIndex: 'NodeGroupIndex',
      nodeGroupName: 'NodeGroupName',
      nodeGroupType: 'NodeGroupType',
      paymentDuration: 'PaymentDuration',
      paymentDurationUnit: 'PaymentDurationUnit',
      paymentType: 'PaymentType',
      systemDisk: 'SystemDisk',
      vSwitchIds: 'VSwitchIds',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoPayOrder: 'boolean',
      autoRenew: 'boolean',
      autoRenewDuration: 'number',
      autoRenewDurationUnit: 'string',
      dataDisks: { 'type': 'array', 'itemType': DiskInfo },
      description: 'string',
      instanceTypes: { 'type': 'array', 'itemType': 'string' },
      nodeCount: 'number',
      nodeGroupIndex: 'number',
      nodeGroupName: 'string',
      nodeGroupType: 'string',
      paymentDuration: 'number',
      paymentDurationUnit: 'string',
      paymentType: 'string',
      systemDisk: SystemDiskParam,
      vSwitchIds: { 'type': 'array', 'itemType': 'string' },
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NodeGroupStateChangeReason extends $tea.Model {
  /**
   * @remarks
   * 状态码。
   * 
   * @example
   * MissingParameter
   */
  code?: string;
  /**
   * @remarks
   * 描述信息。
   * 
   * @example
   * The instance type is required.
   */
  message?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class NodeSelector extends $tea.Model {
  /**
   * @remarks
   * 节点组ID。当NodeSelectType取值NodeGroup时，该参数生效。
   * 
   * @example
   * ng-869471354ecd****
   * 
   * @deprecated
   */
  nodeGroupId?: string;
  nodeGroupIds?: string[];
  /**
   * @remarks
   * 节点组名称。当NodeSelectType取值NodeGroup，且参数NodeGroupId为空时生效，该参数生效。
   * 
   * @example
   * master-1
   * 
   * @deprecated
   */
  nodeGroupName?: string;
  nodeGroupNames?: string[];
  /**
   * @remarks
   * 节点组类型。当NodeSelectType取值NodeGroup，且参数NodeGroupId为空时生效。数组元数个数N取值范围：0~10。
   * 
   * @example
   * ["CORE","TASK"]
   */
  nodeGroupTypes?: string[];
  /**
   * @remarks
   * 节点名称列表。当NodeSelectType取值Node时，该参数生效。
   * 
   * @example
   * ["core1-1"]
   */
  nodeNames?: string[];
  /**
   * @remarks
   * 节点选择类型。取值范围：
   * - CLUSTER：集群。
   * - NODE_GROUP：节点组。
   * - NODE：节点。
   * 
   * This parameter is required.
   * 
   * @example
   * CLUSTER
   */
  nodeSelectType?: string;
  static names(): { [key: string]: string } {
    return {
      nodeGroupId: 'NodeGroupId',
      nodeGroupIds: 'NodeGroupIds',
      nodeGroupName: 'NodeGroupName',
      nodeGroupNames: 'NodeGroupNames',
      nodeGroupTypes: 'NodeGroupTypes',
      nodeNames: 'NodeNames',
      nodeSelectType: 'NodeSelectType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeGroupId: 'string',
      nodeGroupIds: { 'type': 'array', 'itemType': 'string' },
      nodeGroupName: 'string',
      nodeGroupNames: { 'type': 'array', 'itemType': 'string' },
      nodeGroupTypes: { 'type': 'array', 'itemType': 'string' },
      nodeNames: { 'type': 'array', 'itemType': 'string' },
      nodeSelectType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OSUser extends $tea.Model {
  /**
   * @remarks
   * 用户组。
   * 
   * @example
   * hadoop
   */
  group?: string;
  /**
   * @remarks
   * 用户密码。
   * 
   * @example
   * 12345****
   */
  password?: string;
  /**
   * @remarks
   * 用户名称。
   * 
   * @example
   * 王五
   */
  user?: string;
  static names(): { [key: string]: string } {
    return {
      group: 'Group',
      password: 'Password',
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      group: 'string',
      password: 'string',
      user: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OnKubeClusterResource extends $tea.Model {
  cpu?: string;
  memory?: string;
  static names(): { [key: string]: string } {
    return {
      cpu: 'Cpu',
      memory: 'Memory',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpu: 'string',
      memory: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class Operation extends $tea.Model {
  /**
   * @remarks
   * 集群ID。
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * 创建时间。
   * 
   * @example
   * 1628589439114
   */
  createTime?: number;
  /**
   * @remarks
   * 描述。
   * 
   * @example
   * start
   */
  description?: string;
  /**
   * @remarks
   * 结束时间。
   * 
   * @example
   * 1628589439114
   */
  endTime?: number;
  /**
   * @remarks
   * 操作ID。
   * 
   * @example
   * op-13c37a77c505****
   */
  operationId?: string;
  /**
   * @remarks
   * 操作状态。
   * 
   * @example
   * COMPLETED
   */
  operationState?: string;
  /**
   * @remarks
   * 操作类型。
   * 
   * @example
   * CLUSTER
   */
  operationType?: string;
  /**
   * @remarks
   * 开始时间。
   * 
   * @example
   * 1628589439114
   */
  startTime?: number;
  /**
   * @remarks
   * 状态转换原因。
   */
  stateChangeReason?: OperationStateChangeReason;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      createTime: 'CreateTime',
      description: 'Description',
      endTime: 'EndTime',
      operationId: 'OperationId',
      operationState: 'OperationState',
      operationType: 'OperationType',
      startTime: 'StartTime',
      stateChangeReason: 'StateChangeReason',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      createTime: 'number',
      description: 'string',
      endTime: 'number',
      operationId: 'string',
      operationState: 'string',
      operationType: 'string',
      startTime: 'number',
      stateChangeReason: OperationStateChangeReason,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperationData extends $tea.Model {
  actualDeliveredAmounts?: number;
  toBeDeliveredAmounts?: number;
  static names(): { [key: string]: string } {
    return {
      actualDeliveredAmounts: 'actualDeliveredAmounts',
      toBeDeliveredAmounts: 'toBeDeliveredAmounts',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actualDeliveredAmounts: 'number',
      toBeDeliveredAmounts: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperationStateChangeReason extends $tea.Model {
  /**
   * @remarks
   * 状态码。
   * 
   * @example
   * OutOfStock
   */
  code?: string;
  /**
   * @remarks
   * 状态变化信息。
   * 
   * @example
   * The requested resource is sold out in the specified zone, try other types of resources or other regions and zones.
   */
  message?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class Order extends $tea.Model {
  createTime?: string;
  orderId?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      orderId: 'OrderId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      orderId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class Page extends $tea.Model {
  items?: string[];
  maxResults?: number;
  nextToken?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': 'string' },
      maxResults: 'number',
      nextToken: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class Pod extends $tea.Model {
  message?: string;
  podName?: string;
  podStatus?: string;
  reason?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      podName: 'PodName',
      podStatus: 'PodStatus',
      reason: 'Reason',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      podName: 'string',
      podStatus: 'string',
      reason: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PriceInfo extends $tea.Model {
  currency?: string;
  discountPrice?: string;
  originalPrice?: string;
  payType?: string;
  promotionResults?: PromotionInfo[];
  resourceType?: string;
  spotInstanceTypeOriginalPrice?: string;
  spotInstanceTypePrice?: string;
  spotOriginalPrice?: string;
  spotPrice?: string;
  taxPrice?: string;
  tradePrice?: string;
  static names(): { [key: string]: string } {
    return {
      currency: 'Currency',
      discountPrice: 'DiscountPrice',
      originalPrice: 'OriginalPrice',
      payType: 'PayType',
      promotionResults: 'PromotionResults',
      resourceType: 'ResourceType',
      spotInstanceTypeOriginalPrice: 'SpotInstanceTypeOriginalPrice',
      spotInstanceTypePrice: 'SpotInstanceTypePrice',
      spotOriginalPrice: 'SpotOriginalPrice',
      spotPrice: 'SpotPrice',
      taxPrice: 'TaxPrice',
      tradePrice: 'TradePrice',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currency: 'string',
      discountPrice: 'string',
      originalPrice: 'string',
      payType: 'string',
      promotionResults: { 'type': 'array', 'itemType': PromotionInfo },
      resourceType: 'string',
      spotInstanceTypeOriginalPrice: 'string',
      spotInstanceTypePrice: 'string',
      spotOriginalPrice: 'string',
      spotPrice: 'string',
      taxPrice: 'string',
      tradePrice: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class Promotion extends $tea.Model {
  /**
   * @remarks
   * 产品码。
   * 
   * @example
   * ecs
   */
  productCode?: string;
  /**
   * @remarks
   * 优惠券描述。
   * 
   * @example
   * 5元优惠券（有效期至23年8月11日）
   */
  promotionDesc?: string;
  /**
   * @remarks
   * 优惠券名称。
   * 
   * @example
   * 5元优惠券
   */
  promotionName?: string;
  /**
   * @remarks
   * 优惠券码。
   * 
   * @example
   * youhui_quan
   */
  promotionOptionCode?: string;
  /**
   * @remarks
   * 优惠券号。
   * 
   * This parameter is required.
   * 
   * @example
   * ABC123
   */
  promotionOptionNo?: string;
  static names(): { [key: string]: string } {
    return {
      productCode: 'ProductCode',
      promotionDesc: 'PromotionDesc',
      promotionName: 'PromotionName',
      promotionOptionCode: 'PromotionOptionCode',
      promotionOptionNo: 'PromotionOptionNo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productCode: 'string',
      promotionDesc: 'string',
      promotionName: 'string',
      promotionOptionCode: 'string',
      promotionOptionNo: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PromotionInfo extends $tea.Model {
  canPromFee?: string;
  isSelected?: string;
  promotionDesc?: string;
  promotionName?: string;
  promotionOptionCode?: string;
  promotionOptionNo?: string;
  static names(): { [key: string]: string } {
    return {
      canPromFee: 'CanPromFee',
      isSelected: 'IsSelected',
      promotionDesc: 'PromotionDesc',
      promotionName: 'PromotionName',
      promotionOptionCode: 'PromotionOptionCode',
      promotionOptionNo: 'PromotionOptionNo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canPromFee: 'string',
      isSelected: 'string',
      promotionDesc: 'string',
      promotionName: 'string',
      promotionOptionCode: 'string',
      promotionOptionNo: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PromotionParam extends $tea.Model {
  productCode?: string;
  promotionOptionCode?: string;
  promotionOptionNo?: string;
  static names(): { [key: string]: string } {
    return {
      productCode: 'ProductCode',
      promotionOptionCode: 'PromotionOptionCode',
      promotionOptionNo: 'PromotionOptionNo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      productCode: 'string',
      promotionOptionCode: 'string',
      promotionOptionNo: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RecommendScalingRule extends $tea.Model {
  /**
   * @remarks
   * 伸缩活动类型。取值范围：
   * - SCALE_OUT：扩容。
   * - SCALE_IN：缩容。
   * 
   * This parameter is required.
   * 
   * @example
   * SCALE_IN
   */
  activityType?: string;
  /**
   * @remarks
   * 调整值。需要为正数，代表需要扩容或者缩容的实例数量。
   * 
   * This parameter is required.
   * 
   * @example
   * 100
   */
  adjustmentValue?: number;
  /**
   * @remarks
   * 推荐的规格类型。
   */
  instanceType?: string;
  /**
   * @remarks
   * 最大节约成本。
   * 
   * @example
   * 0.12
   */
  maxSave?: number;
  /**
   * @remarks
   * 按照负载伸缩描述。
   * <p>
   */
  metricsTrigger?: MetricsTrigger;
  /**
   * @remarks
   * 规则名称。
   * 
   * This parameter is required.
   * 
   * @example
   * scale-out-memory
   */
  ruleName?: string;
  /**
   * @remarks
   * 按照时间伸缩描述。
   * <p>
   */
  timeTrigger?: TimeTrigger;
  /**
   * @remarks
   * 伸缩规则类型。 取值范围：
   * - TIME_TRIGGER: 按时间伸缩。
   * - METRICS_TRIGGER: 按负载伸缩。
   * 
   * This parameter is required.
   * 
   * @example
   * TIME_TRIGGER
   */
  triggerType?: string;
  static names(): { [key: string]: string } {
    return {
      activityType: 'ActivityType',
      adjustmentValue: 'AdjustmentValue',
      instanceType: 'InstanceType',
      maxSave: 'MaxSave',
      metricsTrigger: 'MetricsTrigger',
      ruleName: 'RuleName',
      timeTrigger: 'TimeTrigger',
      triggerType: 'TriggerType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activityType: 'string',
      adjustmentValue: 'number',
      instanceType: 'string',
      maxSave: 'number',
      metricsTrigger: MetricsTrigger,
      ruleName: 'string',
      timeTrigger: TimeTrigger,
      triggerType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RenewInstance extends $tea.Model {
  /**
   * @remarks
   * emr实例续费时长。
   * 
   * @example
   * 12
   */
  emrRenewDuration?: number;
  /**
   * @remarks
   * emr实例续费时长单位。
   * 
   * @example
   * Month
   */
  emrRenewDurationUnit?: string;
  /**
   * @remarks
   * 节点ID。
   * 
   * This parameter is required.
   * 
   * @example
   * i-bp1cudc25w2bfwl5****
   */
  instanceId?: string;
  /**
   * @remarks
   * 续费时长。
   * 
   * @example
   * 12
   */
  renewDuration?: number;
  /**
   * @remarks
   * 付费时长单位。
   * 
   * @example
   * Month
   */
  renewDurationUnit?: string;
  static names(): { [key: string]: string } {
    return {
      emrRenewDuration: 'EmrRenewDuration',
      emrRenewDurationUnit: 'EmrRenewDurationUnit',
      instanceId: 'InstanceId',
      renewDuration: 'RenewDuration',
      renewDurationUnit: 'RenewDurationUnit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      emrRenewDuration: 'number',
      emrRenewDurationUnit: 'string',
      instanceId: 'string',
      renewDuration: 'number',
      renewDurationUnit: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RenewInstanceParam extends $tea.Model {
  instanceId?: string;
  renewDuration?: number;
  renewDurationUnit?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      renewDuration: 'RenewDuration',
      renewDurationUnit: 'RenewDurationUnit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      renewDuration: 'number',
      renewDurationUnit: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ReplacementStrategy extends $tea.Model {
  instanceCategories?: InstanceCategory[];
  static names(): { [key: string]: string } {
    return {
      instanceCategories: 'InstanceCategories',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceCategories: { 'type': 'array', 'itemType': InstanceCategory },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResizeDiskNodeGroupParam extends $tea.Model {
  dataDiskCapacity?: number;
  nodeGroupId?: string;
  rollingRestart?: boolean;
  static names(): { [key: string]: string } {
    return {
      dataDiskCapacity: 'DataDiskCapacity',
      nodeGroupId: 'NodeGroupId',
      rollingRestart: 'RollingRestart',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataDiskCapacity: 'number',
      nodeGroupId: 'string',
      rollingRestart: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ScalingActivity extends $tea.Model {
  cause?: string;
  description?: string;
  endTime?: number;
  essScalingRuleId?: string;
  expectNum?: number;
  hostGroupName?: string;
  id?: string;
  instanceIds?: string;
  scalingGroupId?: string;
  scalingRuleName?: string;
  startTime?: number;
  status?: string;
  totalCapacity?: number;
  transition?: string;
  static names(): { [key: string]: string } {
    return {
      cause: 'Cause',
      description: 'Description',
      endTime: 'EndTime',
      essScalingRuleId: 'EssScalingRuleId',
      expectNum: 'ExpectNum',
      hostGroupName: 'HostGroupName',
      id: 'Id',
      instanceIds: 'InstanceIds',
      scalingGroupId: 'ScalingGroupId',
      scalingRuleName: 'ScalingRuleName',
      startTime: 'StartTime',
      status: 'Status',
      totalCapacity: 'TotalCapacity',
      transition: 'Transition',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cause: 'string',
      description: 'string',
      endTime: 'number',
      essScalingRuleId: 'string',
      expectNum: 'number',
      hostGroupName: 'string',
      id: 'string',
      instanceIds: 'string',
      scalingGroupId: 'string',
      scalingRuleName: 'string',
      startTime: 'number',
      status: 'string',
      totalCapacity: 'number',
      transition: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ScalingActivityResult extends $tea.Model {
  /**
   * @remarks
   * 实例ID。
   * 
   * @example
   * i-bp1cudc25w2bfwl5****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ScalingActivityResultDTO extends $tea.Model {
  /**
   * @remarks
   * 实例ID。
   * 
   * @example
   * i-bp1cudc25w2bfwl5****
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ScalingAnalyzeResult extends $tea.Model {
  /**
   * @remarks
   * 实际资源利用率。
   * 
   * @example
   * 0.12
   */
  actualUsage?: number;
  /**
   * @remarks
   * 理想资源用量。
   * 
   * @example
   * 0.12
   */
  idealUsage?: number;
  /**
   * @remarks
   * 固定资源释放核数（非master）core。
   * 
   * @example
   * 1
   */
  releaseCores?: number;
  /**
   * @remarks
   * 固定资源保留核数（非master）core。
   * 
   * @example
   * 1
   */
  reservedCores?: number;
  static names(): { [key: string]: string } {
    return {
      actualUsage: 'ActualUsage',
      idealUsage: 'IdealUsage',
      releaseCores: 'ReleaseCores',
      reservedCores: 'ReservedCores',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actualUsage: 'number',
      idealUsage: 'number',
      releaseCores: 'number',
      reservedCores: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ScalingAnalyzeTimeRange extends $tea.Model {
  /**
   * @remarks
   * 结束时间。
   * 
   * @example
   * 1676441972000
   */
  endTime?: number;
  /**
   * @remarks
   * 起始时间。
   * 
   * @example
   * 1676441971000
   */
  startTime?: number;
  /**
   * @remarks
   * 峰谷类型。 peak/valley
   * 
   * @example
   * peak
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      startTime: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ScalingConstraints extends $tea.Model {
  /**
   * @remarks
   * 最大值。
   * 
   * @example
   * 2000
   */
  maxCapacity?: number;
  /**
   * @remarks
   * 最小值。
   * 
   * @example
   * 0
   */
  minCapacity?: number;
  static names(): { [key: string]: string } {
    return {
      maxCapacity: 'MaxCapacity',
      minCapacity: 'MinCapacity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxCapacity: 'number',
      minCapacity: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ScalingGroupConfig extends $tea.Model {
  /**
   * @remarks
   * 数据盘类型。
   * 
   * @example
   * cloud_essd
   */
  dataDiskCategory?: string;
  /**
   * @remarks
   * 数据盘个数。
   * 
   * @example
   * 4
   */
  dataDiskCount?: number;
  /**
   * @remarks
   * 数据盘大小,单位GB。
   * 
   * @example
   * 40
   */
  dataDiskSize?: number;
  /**
   * @remarks
   * 默认冷却时间。
   * 
   * @example
   * 0
   */
  defaultCoolDownTime?: number;
  /**
   * @remarks
   * 抢占实例列表。
   */
  instanceTypeList?: ScalingGroupConfigInstanceTypeList[];
  /**
   * @remarks
   * 资源可用性策略(成本优化参数)。
   */
  multiAvailablePolicy?: ScalingGroupConfigMultiAvailablePolicy;
  /**
   * @remarks
   * 节点下线策略。
   */
  nodeOfflinePolicy?: ScalingGroupConfigNodeOfflinePolicy;
  /**
   * @remarks
   * 私有池选项	。
   */
  privatePoolOptions?: ScalingGroupConfigPrivatePoolOptions;
  /**
   * @remarks
   * 伸缩组节点最大个数。
   * 
   * @example
   * 10
   */
  scalingMaxSize?: number;
  /**
   * @remarks
   * 伸缩组节点最小个数。
   * 
   * @example
   * 1
   */
  scalingMinSize?: number;
  /**
   * @remarks
   * 抢占式Spot实例策略。
   * 
   * @example
   * NoSpot
   */
  spotStrategy?: string;
  /**
   * @remarks
   * 系统盘类型。
   * 
   * @example
   * cloud_essd
   */
  sysDiskCategory?: string;
  /**
   * @remarks
   * 系统盘大小,单位GB。
   * 
   * @example
   * 80
   */
  sysDiskSize?: number;
  /**
   * @remarks
   * 伸缩活动触发模式。
   * 
   * @example
   * ByLoad
   */
  triggerMode?: string;
  static names(): { [key: string]: string } {
    return {
      dataDiskCategory: 'DataDiskCategory',
      dataDiskCount: 'DataDiskCount',
      dataDiskSize: 'DataDiskSize',
      defaultCoolDownTime: 'DefaultCoolDownTime',
      instanceTypeList: 'InstanceTypeList',
      multiAvailablePolicy: 'MultiAvailablePolicy',
      nodeOfflinePolicy: 'NodeOfflinePolicy',
      privatePoolOptions: 'PrivatePoolOptions',
      scalingMaxSize: 'ScalingMaxSize',
      scalingMinSize: 'ScalingMinSize',
      spotStrategy: 'SpotStrategy',
      sysDiskCategory: 'SysDiskCategory',
      sysDiskSize: 'SysDiskSize',
      triggerMode: 'TriggerMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataDiskCategory: 'string',
      dataDiskCount: 'number',
      dataDiskSize: 'number',
      defaultCoolDownTime: 'number',
      instanceTypeList: { 'type': 'array', 'itemType': ScalingGroupConfigInstanceTypeList },
      multiAvailablePolicy: ScalingGroupConfigMultiAvailablePolicy,
      nodeOfflinePolicy: ScalingGroupConfigNodeOfflinePolicy,
      privatePoolOptions: ScalingGroupConfigPrivatePoolOptions,
      scalingMaxSize: 'number',
      scalingMinSize: 'number',
      spotStrategy: 'string',
      sysDiskCategory: 'string',
      sysDiskSize: 'number',
      triggerMode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ScalingRule extends $tea.Model {
  /**
   * @remarks
   * 伸缩活动类型。取值范围：
   * - SCALE_OUT：扩容。
   * - SCALE_IN：缩容。
   * 
   * This parameter is required.
   * 
   * @example
   * SCALE_IN
   */
  activityType?: string;
  /**
   * @remarks
   * 调整值。需要为正数，代表需要扩容或者缩容的实例数量。
   * 
   * This parameter is required.
   * 
   * @example
   * 100
   */
  adjustmentValue?: number;
  /**
   * @remarks
   * 按照负载伸缩描述。
   * <p>
   */
  metricsTrigger?: MetricsTrigger;
  /**
   * @example
   * 1
   */
  minAdjustmentValue?: number;
  /**
   * @remarks
   * 规则名称。
   * 
   * This parameter is required.
   * 
   * @example
   * scale-out-memory
   */
  ruleName?: string;
  /**
   * @remarks
   * 按照时间伸缩描述。
   * <p>
   */
  timeTrigger?: TimeTrigger;
  /**
   * @remarks
   * 伸缩规则类型。 取值范围：
   * - TIME_TRIGGER: 按时间伸缩。
   * - METRICS_TRIGGER: 按负载伸缩。
   * 
   * This parameter is required.
   * 
   * @example
   * TIME_TRIGGER
   */
  triggerType?: string;
  static names(): { [key: string]: string } {
    return {
      activityType: 'ActivityType',
      adjustmentValue: 'AdjustmentValue',
      metricsTrigger: 'MetricsTrigger',
      minAdjustmentValue: 'MinAdjustmentValue',
      ruleName: 'RuleName',
      timeTrigger: 'TimeTrigger',
      triggerType: 'TriggerType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activityType: 'string',
      adjustmentValue: 'number',
      metricsTrigger: MetricsTrigger,
      minAdjustmentValue: 'number',
      ruleName: 'string',
      timeTrigger: TimeTrigger,
      triggerType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ScalingRuleSpec extends $tea.Model {
  /**
   * @remarks
   * 调整值。需要为正数，代表需要扩容或者缩容的实例数量。
   * 
   * This parameter is required.
   * 
   * @example
   * 100
   */
  adjustmentValue?: number;
  /**
   * @remarks
   * 按照负载伸缩描述。
   */
  byLoadScalingRuleSpec?: ScalingRuleSpecByLoadScalingRuleSpec;
  /**
   * @remarks
   * 按照时间伸缩描述。
   */
  byTimeScalingRuleSpec?: ScalingRuleSpecByTimeScalingRuleSpec;
  /**
   * @remarks
   * 冷却时间。单位为秒，取值范围在30~10800秒之间。
   * 
   * This parameter is required.
   * 
   * @example
   * 60
   */
  coolDownInterval?: number;
  /**
   * @remarks
   * 伸缩活动类型。
   * 
   * This parameter is required.
   * 
   * @example
   * SCALE_IN
   */
  scalingActivityType?: string;
  /**
   * @remarks
   * 规则名称。
   * 
   * This parameter is required.
   * 
   * @example
   * scale-out-memory
   */
  scalingRuleName?: string;
  /**
   * @remarks
   * 伸缩规则类型。
   * 
   * This parameter is required.
   * 
   * @example
   * BY_TIME
   */
  scalingRuleType?: string;
  static names(): { [key: string]: string } {
    return {
      adjustmentValue: 'AdjustmentValue',
      byLoadScalingRuleSpec: 'ByLoadScalingRuleSpec',
      byTimeScalingRuleSpec: 'ByTimeScalingRuleSpec',
      coolDownInterval: 'CoolDownInterval',
      scalingActivityType: 'ScalingActivityType',
      scalingRuleName: 'ScalingRuleName',
      scalingRuleType: 'ScalingRuleType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adjustmentValue: 'number',
      byLoadScalingRuleSpec: ScalingRuleSpecByLoadScalingRuleSpec,
      byTimeScalingRuleSpec: ScalingRuleSpecByTimeScalingRuleSpec,
      coolDownInterval: 'number',
      scalingActivityType: 'string',
      scalingRuleName: 'string',
      scalingRuleType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ScalingRuleV1 extends $tea.Model {
  /**
   * @remarks
   * 调整类型。
   * 
   * @example
   * QUANTITY_CHANGE_IN_CAPACITY
   */
  adjustmentType?: string;
  /**
   * @remarks
   * 调整值,正数为扩容,负数为缩容。
   * 
   * @example
   * 1
   */
  adjustmentValue?: number;
  /**
   * @remarks
   * 冷却时间,单位秒。
   * 
   * @example
   * 4
   */
  coolDownTime?: number;
  /**
   * @remarks
   * 规则名称。
   * 
   * @example
   * tule1
   */
  ruleName?: string;
  /**
   * @remarks
   * 规则参数。
   */
  ruleParam?: ScalingRuleV1RuleParam;
  /**
   * @remarks
   * 规则类型。
   * 
   * @example
   * BY_LOAD
   */
  ruleType?: string;
  /**
   * @remarks
   * 弹性规则配置ID。
   * 
   * @example
   * SCB-DCD96BCCFED1****
   */
  scalingConfigBizId?: string;
  static names(): { [key: string]: string } {
    return {
      adjustmentType: 'AdjustmentType',
      adjustmentValue: 'AdjustmentValue',
      coolDownTime: 'CoolDownTime',
      ruleName: 'RuleName',
      ruleParam: 'RuleParam',
      ruleType: 'RuleType',
      scalingConfigBizId: 'ScalingConfigBizId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adjustmentType: 'string',
      adjustmentValue: 'number',
      coolDownTime: 'number',
      ruleName: 'string',
      ruleParam: ScalingRuleV1RuleParam,
      ruleType: 'string',
      scalingConfigBizId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class Script extends $tea.Model {
  /**
   * @remarks
   * 执行失败策略。
   * 
   * @example
   * FAILED_CONTINUE
   */
  executionFailStrategy?: string;
  /**
   * @remarks
   * 脚本的执行时机。
   * 
   * @example
   * BEFORE_INSTALL
   */
  executionMoment?: string;
  /**
   * @remarks
   * 节点选择器。
   * 
   * This parameter is required.
   */
  nodeSelector?: NodeSelector;
  /**
   * @remarks
   * 脚本执行优先级。取值范围：1~100。
   * 
   * @example
   * 1
   * 
   * @deprecated
   */
  priority?: number;
  /**
   * @remarks
   * 脚本执行参数。
   * 
   * @example
   * -host 10.0.10.5 -m 30
   */
  scriptArgs?: string;
  /**
   * @remarks
   * 脚本名称。长度为1~64个字符，必须以大小字母或中文开头，不能以http://和https://开头。可以包含中文、英文、数字、下划线（_）、或者短划线（-）
   * 
   * This parameter is required.
   * 
   * @example
   * 脚本名-1
   */
  scriptName?: string;
  /**
   * @remarks
   * 脚本所在OSS路径。
   * 
   * This parameter is required.
   * 
   * @example
   * oss://bucket1/update_hosts.sh
   */
  scriptPath?: string;
  static names(): { [key: string]: string } {
    return {
      executionFailStrategy: 'ExecutionFailStrategy',
      executionMoment: 'ExecutionMoment',
      nodeSelector: 'NodeSelector',
      priority: 'Priority',
      scriptArgs: 'ScriptArgs',
      scriptName: 'ScriptName',
      scriptPath: 'ScriptPath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      executionFailStrategy: 'string',
      executionMoment: 'string',
      nodeSelector: NodeSelector,
      priority: 'number',
      scriptArgs: 'string',
      scriptName: 'string',
      scriptPath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SpotBidPrice extends $tea.Model {
  /**
   * @remarks
   * 实例的每小时最高出价。支持最大3位小数，参数SpotStrategy=SpotWithPriceLimit时，该参数生效。
   * 
   * @example
   * 1000.0
   */
  bidPrice?: number;
  /**
   * @remarks
   * 实例类型。
   * 
   * @example
   * ecs.g7.2xlarge
   */
  instanceType?: string;
  static names(): { [key: string]: string } {
    return {
      bidPrice: 'BidPrice',
      instanceType: 'InstanceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bidPrice: 'number',
      instanceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SpotPriceLimit extends $tea.Model {
  instanceType?: string;
  priceLimit?: number;
  static names(): { [key: string]: string } {
    return {
      instanceType: 'InstanceType',
      priceLimit: 'PriceLimit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceType: 'string',
      priceLimit: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StateChangeReason extends $tea.Model {
  /**
   * @remarks
   * 状态码。
   * 
   * @example
   * MissingParameter
   */
  code?: string;
  /**
   * @remarks
   * 描述信息。
   * 
   * @example
   * The instance type is required.
   */
  message?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubscriptionConfig extends $tea.Model {
  /**
   * @remarks
   * 自动续费。取值范围：
   * - true：开启启动续费。
   * - false：不开启自动续费。
   * 默认值：false。
   * 
   * @example
   * true
   */
  autoRenew?: boolean;
  /**
   * @remarks
   * 自动续费时长。当AutoRenew取值为true时生效。当AutoRenewDurationUnit取值为Month时，取值：1、2、3、4、5、6、7、8、9、12、24、36、48、60。
   * 
   * @example
   * 12
   */
  autoRenewDuration?: number;
  /**
   * @remarks
   * - Month：月。
   * 
   * @example
   * Month
   */
  autoRenewDurationUnit?: string;
  /**
   * @remarks
   * 付费时长。PaymentDurationUnit取值为Month时，取值：1、2、3、4、5、6、7、8、9、12、24、36、48、60。
   * 
   * This parameter is required.
   * 
   * @example
   * 12
   */
  paymentDuration?: number;
  /**
   * @remarks
   * 付费时长单位。取值范围：
   * - Month：月。
   * 
   * This parameter is required.
   * 
   * @example
   * Month
   */
  paymentDurationUnit?: string;
  static names(): { [key: string]: string } {
    return {
      autoRenew: 'AutoRenew',
      autoRenewDuration: 'AutoRenewDuration',
      autoRenewDurationUnit: 'AutoRenewDurationUnit',
      paymentDuration: 'PaymentDuration',
      paymentDurationUnit: 'PaymentDurationUnit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRenew: 'boolean',
      autoRenewDuration: 'number',
      autoRenewDurationUnit: 'string',
      paymentDuration: 'number',
      paymentDurationUnit: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SystemDisk extends $tea.Model {
  /**
   * @remarks
   * 磁盘类型。
   * 
   * This parameter is required.
   * 
   * @example
   * cloud_essd
   */
  category?: string;
  /**
   * @remarks
   * 每个节点系统盘数量，默认值为1。
   * 
   * @example
   * 1
   */
  count?: number;
  /**
   * @remarks
   * 创建ESSD云盘作为系统盘使用时，设置云盘的性能等级。取值范围：
   * - PL0：单盘最高随机读写IOPS 1万。
   * - PL1（默认）：单盘最高随机读写IOPS 5万。
   * - PL2：单盘最高随机读写IOPS 10万。
   * - PL3：单盘最高随机读写IOPS 100万。
   * 
   * 默认值：PL1。
   * 
   * @example
   * PL1
   */
  performanceLevel?: string;
  /**
   * @remarks
   * 单位GB。
   * 
   * This parameter is required.
   * 
   * @example
   * 60
   */
  size?: number;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      count: 'Count',
      performanceLevel: 'PerformanceLevel',
      size: 'Size',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      count: 'number',
      performanceLevel: 'string',
      size: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SystemDiskParam extends $tea.Model {
  category?: string;
  performanceLevel?: string;
  size?: number;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      performanceLevel: 'PerformanceLevel',
      size: 'Size',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      performanceLevel: 'string',
      size: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class Tag extends $tea.Model {
  /**
   * @remarks
   * 标签键。必填参数，不允许为空字符串。最多支持128个字符，不能以aliyun和acs:开头，不能包含http://或https://。
   * 
   * This parameter is required.
   * 
   * @example
   * department
   */
  key?: string;
  /**
   * @remarks
   * 标签值。非必填，可以为空字符串。最多支持128个字符，不能以acs:开头，不能包含http://或者https://。
   * 
   * @example
   * IT
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResource extends $tea.Model {
  resourceId?: string;
  resourceType?: string;
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceId: 'string',
      resourceType: 'string',
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TimeConstraint extends $tea.Model {
  /**
   * @remarks
   * 结束时间。取值范围：00:00:00至23:59:59
   * 
   * @example
   * 23:59:59
   */
  endTime?: string;
  /**
   * @remarks
   * 开始时间。取值范围：00:00:00至23:59:59
   * 
   * @example
   * 06:00:00
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TimeRange extends $tea.Model {
  /**
   * @remarks
   * 结束时间。
   * 
   * @example
   * 1676441972000
   */
  endTime?: string;
  /**
   * @remarks
   * 起始时间。
   * 
   * @example
   * 1676441971000
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TimeTrigger extends $tea.Model {
  /**
   * @remarks
   * 结束时间戳。单位为毫秒。
   * 
   * @example
   * 1639714800000
   */
  endTime?: number;
  /**
   * @remarks
   * 定时任务触发操作失败后，在此时间内重试。单位为秒，取值范围：0~3600。
   * 
   * @example
   * 600
   */
  launchExpirationTime?: number;
  /**
   * @remarks
   * 启动时间。
   * 
   * This parameter is required.
   */
  launchTime?: string;
  /**
   * @remarks
   * 指定时间规则的执行类型。
   * 
   * @example
   * WEEKLY
   */
  recurrenceType?: string;
  /**
   * @remarks
   * 重复执行定时任务的数值。具体取值取决于 recurrenceType 设置。
   * - recurrenceType 取 MINUTELY 时，只能填一个数值，取值范围：1~1440。
   * - recurrenceType 取 HOURLY 时，只能填一个数值，取值范围：1~24。
   * - recurrenceType 取 DAILY 时，只能填一个数值，取值范围：1~31。
   * - recurrenceType 取 WEEKLY 时，可以填入多个值，填多个值时使用英文逗号（,）分隔。周一到周天分别用MON，TUE，WED，THU，FRI，SAT，SUN代替。 比如 MON,FRI,SUN 代表周一、周五、周天。
   * - recurrenceType 取 MONTHLY 时，格式为A-B或者A,B。A、B的取值范围为1~31，如果使用A-B时B必须大于A。
   * 
   * @example
   * MON,FRI,SUN
   */
  recurrenceValue?: string;
  /**
   * @remarks
   * 开始时间戳。单位为毫秒。
   * 
   * @example
   * 1639714800000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      launchExpirationTime: 'LaunchExpirationTime',
      launchTime: 'LaunchTime',
      recurrenceType: 'RecurrenceType',
      recurrenceValue: 'RecurrenceValue',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      launchExpirationTime: 'number',
      launchTime: 'string',
      recurrenceType: 'string',
      recurrenceValue: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class Toleration extends $tea.Model {
  effect?: string;
  key?: string;
  operator?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      effect: 'Effect',
      key: 'Key',
      operator: 'Operator',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      effect: 'string',
      key: 'string',
      operator: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TriggerCondition extends $tea.Model {
  /**
   * @remarks
   * 比较符。取值范围：
   * - EQ:等于。
   * - NE:不等于。
   * - GT:大于。
   * - LT:小于。
   * - GE:大于等于。
   * - LE:小于等于。
   * 
   * This parameter is required.
   * 
   * @example
   * LT
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * 指标名称。指标名称需要在 ListAutoScalingMetrics 接口返回的指标名称列表中。
   * 
   * This parameter is required.
   * 
   * @example
   * yarn_resourcemanager_root_availablememoryusage
   */
  metricName?: string;
  /**
   * @remarks
   * 统计量名称。取值范围：
   * - MAX：最大值。
   * - MIN：最小值。
   * - AVG：平均值。
   * 
   * This parameter is required.
   * 
   * @example
   * AVG
   */
  statistics?: string;
  /**
   * @remarks
   * 指标Tag。
   */
  tags?: Tag[];
  /**
   * @remarks
   * 阈值。
   * 
   * This parameter is required.
   * 
   * @example
   * 12.5
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      metricName: 'MetricName',
      statistics: 'Statistics',
      tags: 'Tags',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      metricName: 'string',
      statistics: 'string',
      tags: { 'type': 'array', 'itemType': Tag },
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateApplicationConfig extends $tea.Model {
  /**
   * @remarks
   * 修改描述。
   * 
   * @example
   * dfs.namenode.checkpoint.period
   */
  configDescription?: string;
  /**
   * @remarks
   * 应用配置文件名。
   * 
   * @example
   * hdfs-site.xml
   */
  configFileName?: string;
  /**
   * @remarks
   * 配置项键。
   * 
   * @example
   * dfs.namenode.checkpoint.period
   */
  configItemKey?: string;
  /**
   * @remarks
   * 配置项值。
   * 
   * @example
   * 3600s
   */
  configItemValue?: string;
  static names(): { [key: string]: string } {
    return {
      configDescription: 'ConfigDescription',
      configFileName: 'ConfigFileName',
      configItemKey: 'ConfigItemKey',
      configItemValue: 'ConfigItemValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configDescription: 'string',
      configFileName: 'string',
      configItemKey: 'string',
      configItemValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSpecNodeGroup extends $tea.Model {
  /**
   * @remarks
   * 新实例类型。
   * 
   * This parameter is required.
   * 
   * @example
   * ecs.g7.xlarge
   */
  newInstanceType?: string;
  /**
   * @remarks
   * 节点组ID。
   * 
   * This parameter is required.
   * 
   * @example
   * ng-869471354ecd****
   */
  nodeGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      newInstanceType: 'NewInstanceType',
      nodeGroupId: 'NodeGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      newInstanceType: 'string',
      nodeGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSpecNodeGroupParam extends $tea.Model {
  newInstanceType?: string;
  nodeGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      newInstanceType: 'NewInstanceType',
      nodeGroupId: 'NodeGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      newInstanceType: 'string',
      nodeGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class User extends $tea.Model {
  /**
   * @remarks
   * 用户组。
   * 
   * @example
   * hadoop
   */
  group?: string;
  /**
   * @remarks
   * 用户密码。
   * 
   * This parameter is required.
   * 
   * @example
   * 12345****
   */
  password?: string;
  /**
   * @remarks
   * 用户ID。
   * 
   * This parameter is required.
   * 
   * @example
   * 1238539****
   */
  userId?: string;
  /**
   * @remarks
   * 用户名称。
   * 
   * This parameter is required.
   * 
   * @example
   * 王五
   */
  userName?: string;
  /**
   * @remarks
   * 用户类型。
   * 
   * @example
   * LDAP
   */
  userType?: string;
  static names(): { [key: string]: string } {
    return {
      group: 'Group',
      password: 'Password',
      userId: 'UserId',
      userName: 'UserName',
      userType: 'UserType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      group: 'string',
      password: 'string',
      userId: 'string',
      userName: 'string',
      userType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UserParam extends $tea.Model {
  password?: string;
  userId?: string;
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      password: 'Password',
      userId: 'UserId',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      password: 'string',
      userId: 'string',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ValueConstraints extends $tea.Model {
  /**
   * @remarks
   * 默认值。
   */
  defaultValue?: number;
  /**
   * @remarks
   * 结束值。
   */
  end?: number;
  /**
   * @remarks
   * 起始值。
   */
  start?: number;
  /**
   * @remarks
   * 步长。
   */
  step?: number;
  /**
   * @remarks
   * 值限制类型。
   */
  type?: string;
  /**
   * @remarks
   * 枚举值。
   * 
   * @example
   * null
   */
  values?: number[];
  static names(): { [key: string]: string } {
    return {
      defaultValue: 'DefaultValue',
      end: 'End',
      start: 'Start',
      step: 'Step',
      type: 'Type',
      values: 'Values',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultValue: 'number',
      end: 'number',
      start: 'number',
      step: 'number',
      type: 'string',
      values: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateApiTemplateRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the API operation. You can create only a cluster API operation template. Set the value to CreateCluster.
   * 
   * This parameter is required.
   * 
   * @example
   * CreateCluster
   */
  apiName?: string;
  /**
   * @remarks
   * The content of the cluster API operation template. Set the value to JSON strings of the request parameters of the [CreateCluster](https://help.aliyun.com/zh/emr/emr-on-ecs/developer-reference/api-emr-2021-03-20-createcluster) API operation for creating a cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * content
   */
  content?: string;
  /**
   * @remarks
   * 地域ID。
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * 资源组ID。
   * 
   * @example
   * rg-acfmzabjyop****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * 集群模板名字。
   * 
   * This parameter is required.
   * 
   * @example
   * DATALAKE模板
   */
  templateName?: string;
  static names(): { [key: string]: string } {
    return {
      apiName: 'ApiName',
      content: 'Content',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      templateName: 'TemplateName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiName: 'string',
      content: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      templateName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateApiTemplateResponseBody extends $tea.Model {
  /**
   * @remarks
   * 请求ID。
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  /**
   * @example
   * at-41b4c6a0fc63****
   */
  success?: string;
  /**
   * @example
   * at-41b4c6a0fc63****
   */
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateApiTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateApiTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateApiTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterRequest extends $tea.Model {
  /**
   * @remarks
   * The application configurations. You can specify a maximum of 1,000 items.
   */
  applicationConfigs?: ApplicationConfig[];
  /**
   * @remarks
   * The applications. You can specify a maximum of 100 items.
   * 
   * This parameter is required.
   */
  applications?: Application[];
  /**
   * @remarks
   * The bootstrap actions. You can specify a maximum of 10 items.
   */
  bootstrapScripts?: Script[];
  /**
   * @remarks
   * The idempotent client token. If you call the same ClientToken multiple times, the returned results are the same. Only one cluster can be created with the same ClientToken.
   * 
   * @example
   * A7D960FA-6DBA-5E07-8746-A63E3E4D****
   */
  clientToken?: string;
  /**
   * @remarks
   * The name of the cluster. The name must be 1 to 128 characters in length. It must start with a letter and cannot start with http:// or https://. It can contain letters, digits, colons (:), underscores (_), periods (.), and hyphens (-).
   * 
   * This parameter is required.
   * 
   * @example
   * emrtest
   */
  clusterName?: string;
  /**
   * @remarks
   * The type of the cluster. Valid values:
   * 
   * *   DATALAKE: data lake
   * *   OLAP: online analytical processing (OLAP)
   * *   DATAFLOW: Dataflow
   * *   DATASERVING: DataServing
   * *   CUSTOM: a custom hybrid cluster.
   * *   HADOOP: the old data lake. We recommend that you use the new data lake.
   * 
   * If you create an EMR cluster for the first time after 17:00 (UTC +8) on December 19, 2022, you cannot select the HADOOP, DATA_SCIENCE, PRESTO, or ZOOKEEPER cluster type.
   * 
   * This parameter is required.
   * 
   * @example
   * DATALAKE
   */
  clusterType?: string;
  /**
   * @remarks
   * The deployment mode of master nodes in the cluster. Valid values:
   * 
   * *   NORMAL: regular mode. This is the default value. A cluster that contains only one master node is created.
   * *   HA: high availability (HA) mode. A cluster that contains three master nodes is created.
   * 
   * @example
   * HA
   */
  deployMode?: string;
  description?: string;
  /**
   * @remarks
   * The attributes of all ECS instances.
   * 
   * This parameter is required.
   */
  nodeAttributes?: NodeAttributes;
  /**
   * @remarks
   * The node groups. You can specify a maximum of 100 items.
   * 
   * This parameter is required.
   * 
   * @example
   * NORMAL
   */
  nodeGroups?: NodeGroupConfig[];
  /**
   * @remarks
   * The billing cycle of the instance. Valid values:
   * 
   * *   PayAsYouGo: pay-as-you-go
   * *   Subscription: subscription
   * 
   * Default value: PayAsYouGo.
   * 
   * @example
   * PayAsYouGo
   */
  paymentType?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The version of EMR. You can view the EMR release version on the EMR cluster purchase page.
   * 
   * This parameter is required.
   * 
   * @example
   * EMR-5.8.0
   */
  releaseVersion?: string;
  /**
   * @remarks
   * The ID of the resource group to which to assign the ENI.
   * 
   * @example
   * rg-acfmzabjyop****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The security mode of the cluster. Valid values:
   * 
   * *   NORMAL: disables Kerberos authentication for the cluster. This is the default value.
   * *   KERBEROS: enables Kerberos authentication for the cluster.
   * 
   * @example
   * NORMAL
   */
  securityMode?: string;
  /**
   * @remarks
   * The subscription configurations. This parameter is required only if you set the PaymentType parameter to Subscription.
   */
  subscriptionConfig?: SubscriptionConfig;
  /**
   * @remarks
   * The tags. You can specify a maximum of 20 items.
   * 
   * @example
   * A7D960FA-6DBA-5E07-8746-A63E3E4D****
   */
  tags?: Tag[];
  static names(): { [key: string]: string } {
    return {
      applicationConfigs: 'ApplicationConfigs',
      applications: 'Applications',
      bootstrapScripts: 'BootstrapScripts',
      clientToken: 'ClientToken',
      clusterName: 'ClusterName',
      clusterType: 'ClusterType',
      deployMode: 'DeployMode',
      description: 'Description',
      nodeAttributes: 'NodeAttributes',
      nodeGroups: 'NodeGroups',
      paymentType: 'PaymentType',
      regionId: 'RegionId',
      releaseVersion: 'ReleaseVersion',
      resourceGroupId: 'ResourceGroupId',
      securityMode: 'SecurityMode',
      subscriptionConfig: 'SubscriptionConfig',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationConfigs: { 'type': 'array', 'itemType': ApplicationConfig },
      applications: { 'type': 'array', 'itemType': Application },
      bootstrapScripts: { 'type': 'array', 'itemType': Script },
      clientToken: 'string',
      clusterName: 'string',
      clusterType: 'string',
      deployMode: 'string',
      description: 'string',
      nodeAttributes: NodeAttributes,
      nodeGroups: { 'type': 'array', 'itemType': NodeGroupConfig },
      paymentType: 'string',
      regionId: 'string',
      releaseVersion: 'string',
      resourceGroupId: 'string',
      securityMode: 'string',
      subscriptionConfig: SubscriptionConfig,
      tags: { 'type': 'array', 'itemType': Tag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of cluster.
   * 
   * @example
   * c-b933c5aac7f7***
   */
  clusterId?: string;
  /**
   * @remarks
   * The ID of the operation.
   * 
   * @example
   * op-13c37a77c505****
   */
  operationId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      operationId: 'OperationId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      operationId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClusterResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNodeGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * C-E525E04F3914****
   */
  clusterId?: string;
  /**
   * @remarks
   * The information about the node group.
   * 
   * This parameter is required.
   */
  nodeGroup?: NodeGroupConfig;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      nodeGroup: 'NodeGroup',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      nodeGroup: NodeGroupConfig,
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNodeGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the machine group.
   * 
   * @example
   * G-21E39B11837E****
   */
  nodeGroupId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9E3A7161-EB7B-172B-8D18-FFB06BA3****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      nodeGroupId: 'NodeGroupId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeGroupId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNodeGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateNodeGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateNodeGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScriptRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The type of the script. Valid values:
   * 
   * *   BOOTSTRAP: indicates a bootstrap action of the Elastic Compute Service (ECS) instance.
   * *   NORMAL: indicates a common script.
   * 
   * This parameter is required.
   * 
   * @example
   * BOOTSTRAP
   */
  scriptType?: string;
  /**
   * @remarks
   * The scripts.
   * 
   * This parameter is required.
   */
  scripts?: Script[];
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
      scriptType: 'ScriptType',
      scripts: 'Scripts',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
      scriptType: 'string',
      scripts: { 'type': 'array', 'itemType': Script },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScriptResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  /**
   * @remarks
   * The script ID.
   * 
   * @example
   * cs-d6d6bc841c0d415fb81808bc6d09****
   */
  scriptId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      scriptId: 'ScriptId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      scriptId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScriptResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateScriptResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateScriptResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DecreaseNodesRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The number of nodes to scale in. The number of nodes to be scaled in. The value should be less than the number of surviving nodes in the current node group.
   * 
   * @example
   * 3
   */
  decreaseNodeCount?: number;
  /**
   * @remarks
   * The ID of the node group.
   * 
   * This parameter is required.
   * 
   * @example
   * ng-869471354ecd****
   */
  nodeGroupId?: string;
  /**
   * @remarks
   * The array of node IDs. Valid values of array element N: 1 to 500.
   * 
   * @example
   * ["i-bp1cudc25w2bfwl5****"]
   */
  nodeIds?: string[];
  /**
   * @remarks
   * The ID of the region in which you want to create the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      decreaseNodeCount: 'DecreaseNodeCount',
      nodeGroupId: 'NodeGroupId',
      nodeIds: 'NodeIds',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      decreaseNodeCount: 'number',
      nodeGroupId: 'string',
      nodeIds: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DecreaseNodesResponseBody extends $tea.Model {
  /**
   * @remarks
   * Operation ID.
   * 
   * @example
   * op-13c37a77c505****
   */
  operationId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 44430037-E59A-3E66-A2B0-97D155346F22
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      operationId: 'OperationId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operationId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DecreaseNodesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DecreaseNodesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DecreaseNodesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteApiTemplateRequest extends $tea.Model {
  /**
   * @remarks
   * 接口名。
   * 
   * This parameter is required.
   * 
   * @example
   * CreateCluster
   */
  apiName?: string;
  /**
   * @remarks
   * 区域ID。
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * 资源组ID。
   * 
   * @example
   * rg-acfmzabjyop****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * 集群模板id。
   * 
   * This parameter is required.
   * 
   * @example
   * at-****
   */
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      apiName: 'ApiName',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiName: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteApiTemplateResponseBody extends $tea.Model {
  /**
   * @remarks
   * 请求ID。
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  /**
   * @example
   * true
   * 
   * @deprecated
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteApiTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteApiTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteApiTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteClusterRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The ID of the region in which you want to create the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteClusterResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the operation.
   * 
   * @example
   * op-13c37a77c505****
   */
  operationId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      operationId: 'OperationId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operationId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteClusterResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScriptRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The script ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cs-da7476a7679a4d4c9cede62ebe09****
   */
  scriptId?: string;
  /**
   * @remarks
   * The type of the script. Valid values:
   * 
   * *   BOOTSTRAP: indicates a bootstrap action of the Elastic Compute Service (ECS) instance.
   * *   NORMAL: indicates a common script.
   * 
   * This parameter is required.
   * 
   * @example
   * BOOTSTRAP
   */
  scriptType?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
      scriptId: 'ScriptId',
      scriptType: 'ScriptType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
      scriptId: 'string',
      scriptType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScriptResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScriptResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteScriptResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteScriptResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApiTemplateRequest extends $tea.Model {
  /**
   * @remarks
   * 区域ID。
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * 集群模板id。
   * 
   * This parameter is required.
   * 
   * @example
   * at-41b4c6a0fc63****
   */
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApiTemplateResponseBody extends $tea.Model {
  /**
   * @remarks
   * The content of the API operation template.
   * 
   * @deprecated
   */
  data?: ApiTemplate;
  /**
   * @remarks
   * 请求ID。
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ApiTemplate,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApiTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetApiTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetApiTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApplicationRequest extends $tea.Model {
  /**
   * @remarks
   * 应用名称。
   * 
   * This parameter is required.
   * 
   * @example
   * HDFS
   */
  applicationName?: string;
  /**
   * @remarks
   * 集群ID。
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * 地域ID。
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      applicationName: 'ApplicationName',
      clusterId: 'ClusterId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationName: 'string',
      clusterId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApplicationResponseBody extends $tea.Model {
  application?: GetApplicationResponseBodyApplication;
  /**
   * @remarks
   * 请求ID。
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      application: 'Application',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      application: GetApplicationResponseBodyApplication,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApplicationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetApplicationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetApplicationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAutoScalingActivityRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the scaling activity.
   * 
   * This parameter is required.
   * 
   * @example
   * asa-36373b084d6b4b13aa50f4129a9e****
   */
  scalingActivityId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
      scalingActivityId: 'ScalingActivityId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
      scalingActivityId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAutoScalingActivityResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the scaling activity.
   */
  scalingActivity?: GetAutoScalingActivityResponseBodyScalingActivity;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      scalingActivity: 'ScalingActivity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      scalingActivity: GetAutoScalingActivityResponseBodyScalingActivity,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAutoScalingActivityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetAutoScalingActivityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetAutoScalingActivityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAutoScalingPolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The ID of the node group.
   * 
   * This parameter is required.
   * 
   * @example
   * ng-869471354ecd****
   */
  nodeGroupId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      nodeGroupId: 'NodeGroupId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      nodeGroupId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAutoScalingPolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the auto scaling policy.
   */
  scalingPolicy?: GetAutoScalingPolicyResponseBodyScalingPolicy;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      scalingPolicy: 'ScalingPolicy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      scalingPolicy: GetAutoScalingPolicyResponseBodyScalingPolicy,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAutoScalingPolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetAutoScalingPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetAutoScalingPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClusterRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClusterResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the cluster.
   */
  cluster?: Cluster;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      cluster: 'Cluster',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cluster: Cluster,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClusterResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClusterCloneMetaRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClusterCloneMetaResponseBody extends $tea.Model {
  /**
   * @remarks
   * The metadata of the cluster that you want to clone.
   */
  clusterCloneMeta?: GetClusterCloneMetaResponseBodyClusterCloneMeta;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterCloneMeta: 'ClusterCloneMeta',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterCloneMeta: GetClusterCloneMetaResponseBodyClusterCloneMeta,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClusterCloneMetaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetClusterCloneMetaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetClusterCloneMetaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorApplicationRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the job that is submitted to YARN.
   * 
   * This parameter is required.
   * 
   * @example
   * application_1542620905989_****
   */
  appId?: string;
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * Specify the date in the ISO 8601 standard. For example, 2023-01-01 represents January 1, 2023.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-01-01
   */
  dateTime?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      clusterId: 'ClusterId',
      dateTime: 'DateTime',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      clusterId: 'string',
      dateTime: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorApplicationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the job.
   */
  data?: GetDoctorApplicationResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetDoctorApplicationResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorApplicationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDoctorApplicationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDoctorApplicationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorComputeSummaryRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The resource information, which is used to filter the results.
   */
  componentInfo?: GetDoctorComputeSummaryRequestComponentInfo;
  /**
   * @remarks
   * Specify the date in the ISO 8601 standard. For example, 2023-01-01 represents January 1, 2023.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-01-01
   */
  dateTime?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      componentInfo: 'ComponentInfo',
      dateTime: 'DateTime',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      componentInfo: GetDoctorComputeSummaryRequestComponentInfo,
      dateTime: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorComputeSummaryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of resource usage.
   */
  data?: GetDoctorComputeSummaryResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetDoctorComputeSummaryResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorComputeSummaryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDoctorComputeSummaryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDoctorComputeSummaryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseClusterRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The date.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-01-01
   */
  dateTime?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dateTime: 'DateTime',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dateTime: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseClusterResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned data.
   */
  data?: GetDoctorHBaseClusterResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetDoctorHBaseClusterResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseClusterResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDoctorHBaseClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDoctorHBaseClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseRegionRequest extends $tea.Model {
  /**
   * @remarks
   * 集群ID。
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2023-01-01
   */
  dateTime?: string;
  /**
   * @remarks
   * Region ID。
   * 
   * This parameter is required.
   * 
   * @example
   * 67f6808f60a8c357103a3a95fe00610e
   */
  hbaseRegionId?: string;
  /**
   * @remarks
   * 区域ID。
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dateTime: 'DateTime',
      hbaseRegionId: 'HbaseRegionId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dateTime: 'string',
      hbaseRegionId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseRegionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned data.
   */
  data?: GetDoctorHBaseRegionResponseBodyData;
  /**
   * @remarks
   * 请求ID。
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetDoctorHBaseRegionResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseRegionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDoctorHBaseRegionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDoctorHBaseRegionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseRegionServerRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The date.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-01-01
   */
  dateTime?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The host of the region server.
   * 
   * This parameter is required.
   * 
   * @example
   * emr-worker-4.cluster-20****
   */
  regionServerHost?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dateTime: 'DateTime',
      regionId: 'RegionId',
      regionServerHost: 'RegionServerHost',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dateTime: 'string',
      regionId: 'string',
      regionServerHost: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseRegionServerResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned data.
   */
  data?: GetDoctorHBaseRegionServerResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetDoctorHBaseRegionServerResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseRegionServerResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDoctorHBaseRegionServerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDoctorHBaseRegionServerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableRequest extends $tea.Model {
  /**
   * @remarks
   * 集群ID。
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2023-01-01
   */
  dateTime?: string;
  /**
   * @remarks
   * 区域ID。
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * namespace1:tb_item
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dateTime: 'DateTime',
      regionId: 'RegionId',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dateTime: 'string',
      regionId: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned data.
   */
  data?: GetDoctorHBaseTableResponseBodyData;
  /**
   * @remarks
   * 请求ID。
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetDoctorHBaseTableResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDoctorHBaseTableResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDoctorHBaseTableResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * Specify the date in the ISO 8601 standard. For example, 2023-01-01 represents January 1, 2023.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-01-01
   */
  dateTime?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dateTime: 'DateTime',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dateTime: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBody extends $tea.Model {
  /**
   * @remarks
   * The HDFS analysis results.
   */
  data?: GetDoctorHDFSClusterResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetDoctorHDFSClusterResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDoctorHDFSClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDoctorHDFSClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * Specify the date in the ISO 8601 standard. For example, 2023-01-01 represents January 1, 2023.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-01-01
   */
  dateTime?: string;
  /**
   * @remarks
   * The directory name. The depth of the directory is not greater than five.
   * 
   * This parameter is required.
   * 
   * @example
   * /tmp/test
   */
  dirPath?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dateTime: 'DateTime',
      dirPath: 'DirPath',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dateTime: 'string',
      dirPath: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The analysis results of the HDFS directory.
   */
  data?: GetDoctorHDFSDirectoryResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetDoctorHDFSDirectoryResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDoctorHDFSDirectoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDoctorHDFSDirectoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSUGIRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * Specify the date in the ISO 8601 standard. For example, 2023-01-01 represents January 1, 2023.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-01-01
   */
  dateTime?: string;
  /**
   * @remarks
   * Set this parameter based on the value of Type.
   * 
   * This parameter is required.
   * 
   * @example
   * DW
   */
  name?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The filter condition. Valid values:
   * 
   * *   user
   * *   group
   * 
   * This parameter is required.
   * 
   * @example
   * user
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dateTime: 'DateTime',
      name: 'Name',
      regionId: 'RegionId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dateTime: 'string',
      name: 'string',
      regionId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSUGIResponseBody extends $tea.Model {
  /**
   * @remarks
   * The results of HDFS analysis.
   */
  data?: GetDoctorHDFSUGIResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetDoctorHDFSUGIResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSUGIResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDoctorHDFSUGIResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDoctorHDFSUGIResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * Specify the date in the ISO 8601 standard. For example, 2023-01-01 represents January 1, 2023.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-01-01
   */
  dateTime?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dateTime: 'DateTime',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dateTime: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBody extends $tea.Model {
  /**
   * @remarks
   * The analysis results of the Hive cluster.
   */
  data?: GetDoctorHiveClusterResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetDoctorHiveClusterResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDoctorHiveClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDoctorHiveClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The database name.
   * 
   * This parameter is required.
   * 
   * @example
   * db1
   */
  databaseName?: string;
  /**
   * @remarks
   * The query date.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-01-01
   */
  dateTime?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      databaseName: 'DatabaseName',
      dateTime: 'DateTime',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      databaseName: 'string',
      dateTime: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBody extends $tea.Model {
  /**
   * @remarks
   * The analysis results of the Hive database.
   */
  data?: GetDoctorHiveDatabaseResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetDoctorHiveDatabaseResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDoctorHiveDatabaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDoctorHiveDatabaseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * Specify the date in the ISO 8601 standard. For example, 2023-01-01 represents January 1, 2023.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-01-01
   */
  dateTime?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The table name. The table name must follow the rule in Hive. A name in the {database name.table identifier} format uniquely identifies a table.
   * 
   * This parameter is required.
   * 
   * @example
   * dw.dwd_creta_service_order_long_renew_long_da
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dateTime: 'DateTime',
      regionId: 'RegionId',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dateTime: 'string',
      regionId: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBody extends $tea.Model {
  /**
   * @remarks
   * The analysis results of the Hive table.
   */
  data?: GetDoctorHiveTableResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetDoctorHiveTableResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDoctorHiveTableResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDoctorHiveTableResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorJobRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the job that is submitted to YARN.
   * 
   * This parameter is required.
   * 
   * @example
   * application_1542620905989_****
   */
  appId?: string;
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      clusterId: 'ClusterId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      clusterId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorJobResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the job.
   */
  data?: GetDoctorJobResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetDoctorJobResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDoctorJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDoctorJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorReportComponentSummaryRequest extends $tea.Model {
  /**
   * @remarks
   * 集群ID。
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * component type
   * 
   * This parameter is required.
   * 
   * @example
   * compute
   */
  componentType?: string;
  /**
   * @remarks
   * dateTime for specify report
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-01-01
   */
  dateTime?: string;
  /**
   * @remarks
   * 区域ID。
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      componentType: 'ComponentType',
      dateTime: 'DateTime',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      componentType: 'string',
      dateTime: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorReportComponentSummaryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The content of the report.
   */
  data?: GetDoctorReportComponentSummaryResponseBodyData;
  /**
   * @remarks
   * 请求ID。
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetDoctorReportComponentSummaryResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorReportComponentSummaryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDoctorReportComponentSummaryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDoctorReportComponentSummaryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The ID of the node group.
   * 
   * This parameter is required.
   * 
   * @example
   * ng-869471354ecd****
   */
  nodeGroupId?: string;
  /**
   * @remarks
   * The ID of the region in which you want to create the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      nodeGroupId: 'NodeGroupId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      nodeGroupId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The node group.
   */
  nodeGroup?: NodeGroup;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      nodeGroup: 'NodeGroup',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeGroup: NodeGroup,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetNodeGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetNodeGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOperationRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the cluster that you want to query.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The operation ID.
   * 
   * References:
   * 
   * *   [CreateCluster](https://help.aliyun.com/document_detail/454393.html)
   * *   [IncreaseNodes](https://help.aliyun.com/document_detail/454397.html)
   * 
   * This parameter is required.
   * 
   * @example
   * op-13c37a77c505****
   */
  operationId?: string;
  /**
   * @remarks
   * The district ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      operationId: 'OperationId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      operationId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOperationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The operation that was performed.
   */
  operation?: Operation;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9E3A7161-EB7B-172B-8D18-FFB06BA3896A
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      operation: 'Operation',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operation: Operation,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOperationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetOperationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOperationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class IncreaseNodesRequest extends $tea.Model {
  /**
   * @remarks
   * The application configurations. You can specify a maximum of 1,000 items.
   * 
   * @example
   * Month
   */
  applicationConfigs?: ApplicationConfig[];
  /**
   * @remarks
   * Indicates whether to automatically pay for the orders involved in the scale-out operation. This parameter takes effect only when the PaymentType parameter is set to Subscription. Valid values:
   * 
   * *   true: automatically pays for the order involved in this operation.
   * *   false: does not automatically pay for the orders involved in this operation.
   * 
   * Default value: false
   * 
   * @example
   * false
   */
  autoPayOrder?: boolean;
  /**
   * @remarks
   * Specifies whether to enable auto-renewal for nodes. Valid values:
   * 
   * *   true
   * *   false (default value)
   * 
   * @example
   * false
   */
  autoRenew?: boolean;
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The number of nodes. The number of incremental nodes for this scale-out. Valid values: 1 to 500.
   * 
   * This parameter is required.
   * 
   * @example
   * 3
   */
  increaseNodeCount?: number;
  /**
   * @remarks
   * The minimum number of nodes that can be added. Valid values: 1 to 500.
   * 
   * *   If you configure this parameter, and the number of available Elastic Compute Service (ECS) instances is less than the value of the IncreaseNodeCount parameter, the system tries to add nodes based on the number specified by the `MinIncreaseNodeCount` parameter. If the minimum number of nodes are added, the scale-out status is `PARTIAL_COMPLETED`.
   * *   If you do not configure this parameter, and the number of available ECS instances is less than the value of the IncreaseNodeCount parameter, the scale-out process fails. The scale-out status is `FAILED`.
   */
  minIncreaseNodeCount?: number;
  /**
   * @remarks
   * The ID of the node group. The target node group to which you want to scale out the cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * ng-869471354ecd****
   */
  nodeGroupId?: string;
  /**
   * @remarks
   * The subscription duration. Valid values when the PaymentDurationUnit value is Month: 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 24, 36, 48, and 60.
   * 
   * @example
   * 12
   */
  paymentDuration?: number;
  /**
   * @remarks
   * The unit of the subscription duration. Valid values:
   * 
   * *   Month
   * 
   * @example
   * Month
   */
  paymentDurationUnit?: string;
  /**
   * @remarks
   * The ID of the region in which you want to create the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      applicationConfigs: 'ApplicationConfigs',
      autoPayOrder: 'AutoPayOrder',
      autoRenew: 'AutoRenew',
      clusterId: 'ClusterId',
      increaseNodeCount: 'IncreaseNodeCount',
      minIncreaseNodeCount: 'MinIncreaseNodeCount',
      nodeGroupId: 'NodeGroupId',
      paymentDuration: 'PaymentDuration',
      paymentDurationUnit: 'PaymentDurationUnit',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationConfigs: { 'type': 'array', 'itemType': ApplicationConfig },
      autoPayOrder: 'boolean',
      autoRenew: 'boolean',
      clusterId: 'string',
      increaseNodeCount: 'number',
      minIncreaseNodeCount: 'number',
      nodeGroupId: 'string',
      paymentDuration: 'number',
      paymentDurationUnit: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class IncreaseNodesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the operation.
   * 
   * @example
   * op-13c37a77c505****
   */
  operationId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      operationId: 'OperationId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operationId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class IncreaseNodesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: IncreaseNodesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: IncreaseNodesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinResourceGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the region in which you want to create the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * This parameter is required.
   * 
   * @example
   * rg-acfmzabjyop****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The ID of the resource.
   * 
   * This parameter is required.
   * 
   * @example
   * c-c95f0a39d8ff****
   */
  resourceId?: string;
  /**
   * @remarks
   * The type of the resource. Valid values:
   * 
   * *   cluster: cluster
   * 
   * This parameter is required.
   * 
   * @example
   * cluster
   */
  resourceType?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      resourceGroupId: 'string',
      resourceId: 'string',
      resourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinResourceGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9E3A7161-EB7B-172B-8D18-FFB06BA3****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinResourceGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: JoinResourceGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: JoinResourceGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApiTemplatesRequest extends $tea.Model {
  /**
   * @remarks
   * 接口名。
   * 
   * This parameter is required.
   * 
   * @example
   * CreateCluster
   */
  apiName?: string;
  /**
   * @remarks
   * 一次获取的最大记录数。
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * 标记当前开始读取的位置，置空表示从头开始。
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * 区域ID。
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * 资源组ID。
   * 
   * @example
   * rg-acfmzabjyop****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * 集群模板id。
   * 
   * @example
   * at-41b4c6a0fc63****
   */
  templateId?: string;
  /**
   * @remarks
   * 集群模板id列表。
   * 
   * @example
   * ["AT-****"]
   */
  templateIds?: string[];
  /**
   * @remarks
   * 集群模板名字。
   * 
   * @example
   * DATALAKE模板
   */
  templateName?: string;
  static names(): { [key: string]: string } {
    return {
      apiName: 'ApiName',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      templateId: 'TemplateId',
      templateIds: 'TemplateIds',
      templateName: 'TemplateName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiName: 'string',
      maxResults: 'number',
      nextToken: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      templateId: 'string',
      templateIds: { 'type': 'array', 'itemType': 'string' },
      templateName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApiTemplatesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The API operation templates.
   * 
   * @deprecated
   */
  apiTemplates?: ApiTemplate[];
  /**
   * @remarks
   * 本次请求所返回的最大记录条数。
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * 返回读取到的数据位置，空代表数据已经读取完毕。
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * 请求ID。
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  /**
   * @remarks
   * 本次请求条件下的数据总量。
   * 
   * @example
   * 200
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      apiTemplates: 'ApiTemplates',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiTemplates: { 'type': 'array', 'itemType': ApiTemplate },
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApiTemplatesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListApiTemplatesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListApiTemplatesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationConfigsRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * HDFS
   */
  applicationName?: string;
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-e6a9d46e9267****
   */
  clusterId?: string;
  /**
   * @remarks
   * The name of the configuration file.
   * 
   * @example
   * hdfs-site.xml
   */
  configFileName?: string;
  /**
   * @remarks
   * The name of the configuration item.
   * 
   * @example
   * dfs.replication
   */
  configItemKey?: string;
  /**
   * @remarks
   * The value of the configuration item.
   * 
   * @example
   * 2
   */
  configItemValue?: string;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 100
   */
  maxResults?: number;
  /**
   * @remarks
   * The page number of the next page returned.
   * 
   * @example
   * 1
   */
  nextToken?: string;
  /**
   * @remarks
   * The ID of the node group.
   * 
   * @example
   * ng-d555335ced5c****
   */
  nodeGroupId?: string;
  /**
   * @remarks
   * The node ID.
   * 
   * @example
   * i-bp10h9rezawz1i4o****
   */
  nodeId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      applicationName: 'ApplicationName',
      clusterId: 'ClusterId',
      configFileName: 'ConfigFileName',
      configItemKey: 'ConfigItemKey',
      configItemValue: 'ConfigItemValue',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      nodeGroupId: 'NodeGroupId',
      nodeId: 'NodeId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationName: 'string',
      clusterId: 'string',
      configFileName: 'string',
      configItemKey: 'string',
      configItemValue: 'string',
      maxResults: 'number',
      nextToken: 'string',
      nodeGroupId: 'string',
      nodeId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationConfigsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The application configurations.
   */
  applicationConfigs?: ListApplicationConfigsResponseBodyApplicationConfigs[];
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 100
   */
  maxResults?: number;
  /**
   * @remarks
   * The page number of the next page returned.
   * 
   * @example
   * 1
   */
  nextToken?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9E3A7161-EB7B-172B-8D18-FFB06BA3****
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      applicationConfigs: 'ApplicationConfigs',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationConfigs: { 'type': 'array', 'itemType': ListApplicationConfigsResponseBodyApplicationConfigs },
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationConfigsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListApplicationConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListApplicationConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationsRequest extends $tea.Model {
  /**
   * @remarks
   * The application names.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  applicationNames?: string[];
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-e6a9d46e92675****
   */
  clusterId?: string;
  /**
   * @remarks
   * The total number of pages.
   * 
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @remarks
   * The page number of the next page returned.
   * 
   * @example
   * 0
   */
  nextToken?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      applicationNames: 'ApplicationNames',
      clusterId: 'ClusterId',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationNames: { 'type': 'array', 'itemType': 'string' },
      clusterId: 'string',
      maxResults: 'number',
      nextToken: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The applications.
   */
  applications?: ListApplicationsResponseBodyApplications[];
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @remarks
   * The page number of the next page returned.
   * 
   * @example
   * 2
   */
  nextToken?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9E3A7161-EB7B-172B-8D18-FFB06BA3****
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of pages.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      applications: 'Applications',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applications: { 'type': 'array', 'itemType': ListApplicationsResponseBodyApplications },
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListApplicationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListApplicationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAutoScalingActivitiesRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The end of the time range to query. Unit: milliseconds.
   * 
   * @example
   * 1639718634819
   */
  endTime?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * The pagination token that is used in the request to retrieve a new page of results.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The ID of the node group.
   * 
   * @example
   * ng-869471354ecd****
   */
  nodeGroupId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The status of the scaling activity. Number of elements in the array: 1-20.
   * 
   * @example
   * ["REJECTED","SUCCESSFUL"]
   */
  scalingActivityStates?: string[];
  /**
   * @remarks
   * The type of the scaling activity. Valid values:
   * 
   * *   SCALE_OUT
   * *   SCALE_IN
   * 
   * @example
   * SCALE_IN
   */
  scalingActivityType?: string;
  /**
   * @remarks
   * The name of the scaling rule.
   * 
   * @example
   * scale-out-by-memroy
   */
  scalingRuleName?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Unit: milliseconds.
   * 
   * @example
   * 1639714634819
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      endTime: 'EndTime',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      nodeGroupId: 'NodeGroupId',
      regionId: 'RegionId',
      scalingActivityStates: 'ScalingActivityStates',
      scalingActivityType: 'ScalingActivityType',
      scalingRuleName: 'ScalingRuleName',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      endTime: 'number',
      maxResults: 'number',
      nextToken: 'string',
      nodeGroupId: 'string',
      regionId: 'string',
      scalingActivityStates: { 'type': 'array', 'itemType': 'string' },
      scalingActivityType: 'string',
      scalingRuleName: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAutoScalingActivitiesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The maximum number of entries returned.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * A pagination token.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  /**
   * @remarks
   * The scaling activities.
   */
  scalingActivities?: ListAutoScalingActivitiesResponseBodyScalingActivities[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 200
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      scalingActivities: 'ScalingActivities',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      scalingActivities: { 'type': 'array', 'itemType': ListAutoScalingActivitiesResponseBodyScalingActivities },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAutoScalingActivitiesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListAutoScalingActivitiesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAutoScalingActivitiesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClustersRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of the clusters. You can specify a maximum of 100 items.
   * 
   * @example
   * rg-acfmzabjyop****
   */
  clusterIds?: string[];
  /**
   * @remarks
   * The name of the cluster.
   * 
   * @example
   * emrtest
   */
  clusterName?: string;
  /**
   * @remarks
   * The states of clusters. You can specify a maximum of 100 items.
   * 
   * @example
   * ["HADOOP"]
   */
  clusterStates?: string[];
  /**
   * @remarks
   * The types of the clusters. You can specify a maximum of 100 items.
   * 
   * @example
   * ["c-b933c5aac8fe****"]
   */
  clusterTypes?: string[];
  /**
   * @remarks
   * The number of entries to return on each page. Valid values: 1 to 100.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * The starting point of the current query. If you do not configure this parameter, the query starts from the beginning.
   * 
   * @example
   * eyJlY21OZXh0VG9rZW4iOiIxIiwidGFpaGFvTmV4dFRva2VuIjoiNTYiLCJ0YWloYW9OZXh0VG9rZW5JbnQiOjU2LCJlY21OZXh0VG9rZW5JbnQiOjF9
   */
  nextToken?: string;
  /**
   * @remarks
   * The billing methods. You can specify a maximum of 2 items.
   * 
   * @example
   * ["ECS"]
   */
  paymentTypes?: string[];
  /**
   * @remarks
   * The region ID.
   * 
   * Valid values:
   * 
   * *   cn-qingdao
   * *   cn-beijing
   * *   cn-zhangjiakou
   * *   cn-huhehaote
   * *   cn-hangzhou
   * *   cn-shanghai
   * *   cn-shenzhen
   * *   cn-chengdu
   * *   cn-hongkong
   * *   cn-wulanchabu
   * *   cn-heyuan-acdr-1
   * *   cn-qingdao-acdr-ut-1
   * *   ap-northeast-1
   * *   ap-southeast-1
   * *   ap-southeast-2
   * *   ap-southeast-3
   * *   ap-southeast-5
   * *   ap-south-1
   * *   us-east-1
   * *   us-west-1
   * *   me-east-1
   * *   me-central-1
   * *   eu-central-1
   * *   eu-west-1
   * *   cn-north-2-gov-1
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfmzabjyop****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The tags. Number of elements in the array: 1 to 20.
   * 
   * @example
   * ["PayAsYouGo"]
   */
  tags?: Tag[];
  static names(): { [key: string]: string } {
    return {
      clusterIds: 'ClusterIds',
      clusterName: 'ClusterName',
      clusterStates: 'ClusterStates',
      clusterTypes: 'ClusterTypes',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      paymentTypes: 'PaymentTypes',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterIds: { 'type': 'array', 'itemType': 'string' },
      clusterName: 'string',
      clusterStates: { 'type': 'array', 'itemType': 'string' },
      clusterTypes: { 'type': 'array', 'itemType': 'string' },
      maxResults: 'number',
      nextToken: 'string',
      paymentTypes: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
      resourceGroupId: 'string',
      tags: { 'type': 'array', 'itemType': Tag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClustersResponseBody extends $tea.Model {
  /**
   * @remarks
   * The clusters.
   */
  clusters?: ClusterSummary[];
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * The page number of the next page returned.
   * 
   * @example
   * eyJlY21OZXh0VG9rZW4iOiIxIiwidGFpaGFvTmV4dFRva2VuIjoiNTYiLCJ0YWloYW9OZXh0VG9rZW5JbnQiOjU2LCJlY21OZXh0VG9rZW5JbnQiOjF9
   */
  nextToken?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9E3A7161-EB7B-172B-8D18-FFB06BA3896A
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of pages.
   * 
   * @example
   * 1000
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      clusters: 'Clusters',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusters: { 'type': 'array', 'itemType': ClusterSummary },
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClustersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListClustersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListClustersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListComponentInstancesRequest extends $tea.Model {
  /**
   * @remarks
   * 应用名称列表。
   * 
   * @example
   * ["HDFS"]
   */
  applicationNames?: string[];
  /**
   * @remarks
   * 集群ID。
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * 组件名称列表。
   * 
   * @example
   * ["DataNode"]
   */
  componentNames?: string[];
  /**
   * @example
   * null
   */
  componentStates?: string[];
  /**
   * @remarks
   * 一次获取的最大记录数。取值范围：1~100。
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * 标记当前开始读取的位置，置空表示从头开始。
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * 节点ID列表。
   * 
   * @example
   * ["i-bp1cudc25w2bfwl5****"]
   */
  nodeIds?: string[];
  /**
   * @remarks
   * 节点名称列表。
   * 
   * @example
   * ["core1-1"]
   */
  nodeNames?: string[];
  /**
   * @remarks
   * 地域ID。
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      applicationNames: 'ApplicationNames',
      clusterId: 'ClusterId',
      componentNames: 'ComponentNames',
      componentStates: 'ComponentStates',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      nodeIds: 'NodeIds',
      nodeNames: 'NodeNames',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationNames: { 'type': 'array', 'itemType': 'string' },
      clusterId: 'string',
      componentNames: { 'type': 'array', 'itemType': 'string' },
      componentStates: { 'type': 'array', 'itemType': 'string' },
      maxResults: 'number',
      nextToken: 'string',
      nodeIds: { 'type': 'array', 'itemType': 'string' },
      nodeNames: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListComponentInstancesResponseBody extends $tea.Model {
  componentInstances?: ListComponentInstancesResponseBodyComponentInstances[];
  /**
   * @remarks
   * 本次请求所返回的最大记录条数。
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * 返回读取到的数据位置，空代表数据已经读取完毕。
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * 请求ID。
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  /**
   * @remarks
   * 本次请求条件下的数据总量。
   * 
   * @example
   * 200
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      componentInstances: 'ComponentInstances',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      componentInstances: { 'type': 'array', 'itemType': ListComponentInstancesResponseBodyComponentInstances },
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListComponentInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListComponentInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListComponentInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListComponentsRequest extends $tea.Model {
  /**
   * @remarks
   * 应用名称列表。
   * 
   * @example
   * ["HDFS"]
   */
  applicationNames?: string[];
  /**
   * @remarks
   * 集群ID。
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * 组件名称列表。
   * 
   * @example
   * ["DataNode"]
   */
  componentNames?: string[];
  /**
   * @example
   * null
   */
  componentStates?: string[];
  /**
   * @remarks
   * 一次获取的最大记录数。取值范围：1~100。
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * 标记当前开始读取的位置，置空表示从头开始。
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * 地域ID。
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      applicationNames: 'ApplicationNames',
      clusterId: 'ClusterId',
      componentNames: 'ComponentNames',
      componentStates: 'ComponentStates',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationNames: { 'type': 'array', 'itemType': 'string' },
      clusterId: 'string',
      componentNames: { 'type': 'array', 'itemType': 'string' },
      componentStates: { 'type': 'array', 'itemType': 'string' },
      maxResults: 'number',
      nextToken: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListComponentsResponseBody extends $tea.Model {
  components?: ListComponentsResponseBodyComponents[];
  /**
   * @remarks
   * 本次请求所返回的最大记录条数。
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * 返回读取到的数据位置，空代表数据已经读取完毕。
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * 请求ID。
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  /**
   * @remarks
   * 本次请求条件下的数据总量。
   * 
   * @example
   * 200
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      components: 'Components',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      components: { 'type': 'array', 'itemType': ListComponentsResponseBodyComponents },
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListComponentsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListComponentsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListComponentsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorApplicationsRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of jobs that are submitted to YARN.
   * 
   * @example
   * null
   */
  appIds?: string[];
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * Specify the date in the ISO 8601 standard. For example, 2023-01-01 represents January 1, 2023.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-01-01
   */
  dateTime?: string;
  /**
   * @remarks
   * The maximum number of entries to return on each page.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * The pagination token that is used in the request to retrieve a new page of results.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The field that you use to sort the query results. Valid values:
   * 
   * 1.  startTime: the time when the job starts
   * 2.  endTime: the time when the job ends
   * 3.  vcoreUtilization: the vCPU utilization of the job
   * 4.  memUtilization: the memory usage of the job
   * 5.  vcoreSeconds: the aggregated number of vCPUs that are allocated to the job multiplied by the number of seconds the job has been running
   * 6.  memSeconds: the aggregated amount of memory that is allocated to the job multiplied by the number of seconds the job has been running
   * 7.  score: the score of the job
   * 
   * @example
   * score
   */
  orderBy?: string;
  /**
   * @remarks
   * The order in which you want to sort the query results. Valid values:
   * 
   * *   ASC: the ascending order
   * *   DESC: the descending order
   * 
   * @example
   * ASC
   */
  orderType?: string;
  /**
   * @remarks
   * The YARN queues to which the jobs are submitted.
   * 
   * @example
   * null
   */
  queues?: string[];
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The YARN engines to which the jobs are submitted.
   * 
   * @example
   * null
   */
  types?: string[];
  /**
   * @remarks
   * The users who submit the jobs.
   * 
   * @example
   * null
   */
  users?: string[];
  static names(): { [key: string]: string } {
    return {
      appIds: 'AppIds',
      clusterId: 'ClusterId',
      dateTime: 'DateTime',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      orderBy: 'OrderBy',
      orderType: 'OrderType',
      queues: 'Queues',
      regionId: 'RegionId',
      types: 'Types',
      users: 'Users',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appIds: { 'type': 'array', 'itemType': 'string' },
      clusterId: 'string',
      dateTime: 'string',
      maxResults: 'number',
      nextToken: 'string',
      orderBy: 'string',
      orderType: 'string',
      queues: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
      types: { 'type': 'array', 'itemType': 'string' },
      users: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorApplicationsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of jobs.
   */
  data?: ListDoctorApplicationsResponseBodyData[];
  /**
   * @remarks
   * The maximum number of entries returned.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * A pagination token.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 200
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListDoctorApplicationsResponseBodyData },
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorApplicationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDoctorApplicationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDoctorApplicationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorComputeSummaryRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The resource types, which are used to filter query results. Valid values:
   * 
   * *   engine: filters results by engine.
   * *   queue: filters results by queue.
   * *   cluster: displays the results at the cluster level.
   * 
   * If you do not specify this parameter, the information at the cluster level is displayed by default. Currently, only one resource type is supported. If you specify multiple resource types, the first resource type is used by default.
   * 
   * @example
   * null
   */
  componentTypes?: string[];
  /**
   * @remarks
   * Specify the date in the ISO 8601 standard. For example, 2023-01-01 represents January 1, 2023.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-01-01
   */
  dateTime?: string;
  /**
   * @remarks
   * The maximum number of entries to return on each page.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * The pagination token that is used in the request to retrieve a new page of results.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The basis on which you want to sort the query results. Valid values:
   * 
   * 1.  vcoreSeconds: the total CPU consumption over time in seconds.
   * 2.  memSeconds: the total memory consumption over time in seconds.
   * 3.  vcoreUtilization: the average CPU utilization. The meaning is the same as the %CPU parameter in the output of the top command in Linux.
   * 4.  memUtilization: the average memory usage.
   * 5.  vcoreSecondsDayGrowthRatio: the day-to-day growth rate of the total CPU consumption over time in seconds.
   * 6.  memSecondsDayGrowthRatio: the day-to-day growth rate of the total memory consumption over time in seconds.
   * 7.  readSize: the total amount of data read from the file system.
   * 8.  writeSize: the total amount of data written to the file system.
   * 9.  healthyJobCount: the total number of healthy jobs.
   * 10. subHealthyJobCount: the total number of sub-healthy jobs.
   * 11. unhealthyJobCount: the total number of unhealthy jobs.
   * 12. needAttentionJobCount: the total number of jobs that require attention.
   * 13. score: the score for jobs.
   * 14. scoreDayGrowthRatio: the day-to-day growth rate of the score for jobs.
   * 
   * @example
   * score
   */
  orderBy?: string;
  /**
   * @remarks
   * The order in which you want to sort the query results. Valid values:
   * 
   * *   ASC: in ascending order.
   * *   DESC: in descending order.
   * 
   * @example
   * ASC
   */
  orderType?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      componentTypes: 'ComponentTypes',
      dateTime: 'DateTime',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      orderBy: 'OrderBy',
      orderType: 'OrderType',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      componentTypes: { 'type': 'array', 'itemType': 'string' },
      dateTime: 'string',
      maxResults: 'number',
      nextToken: 'string',
      orderBy: 'string',
      orderType: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorComputeSummaryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of resource usage.
   */
  data?: ListDoctorComputeSummaryResponseBodyData[];
  /**
   * @remarks
   * The maximum number of entries that are returned.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * A pagination token.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 200
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListDoctorComputeSummaryResponseBodyData },
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorComputeSummaryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDoctorComputeSummaryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDoctorComputeSummaryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseRegionServersRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The query date.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-01-01
   */
  dateTime?: string;
  /**
   * @remarks
   * The maximum number of entries to return on each page.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * The pagination token that is used in the request to retrieve a new page of results.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The field that you use to sort the query results. Valid value:
   * 
   * *   regionCount: the number of regions.
   * 
   * @example
   * regionCount
   */
  orderBy?: string;
  /**
   * @remarks
   * The order in which you want to sort the query results. Valid value:
   * 
   * *   ASC: in ascending order
   * *   DESC: in descending order
   * 
   * @example
   * ASC
   */
  orderType?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The RegionServer hosts.
   * 
   * @example
   * null
   */
  regionServerHosts?: string[];
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dateTime: 'DateTime',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      orderBy: 'OrderBy',
      orderType: 'OrderType',
      regionId: 'RegionId',
      regionServerHosts: 'RegionServerHosts',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dateTime: 'string',
      maxResults: 'number',
      nextToken: 'string',
      orderBy: 'string',
      orderType: 'string',
      regionId: 'string',
      regionServerHosts: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseRegionServersResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned data.
   */
  data?: ListDoctorHBaseRegionServersResponseBodyData[];
  /**
   * @remarks
   * The maximum number of entries that are returned.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * A pagination token.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 200
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListDoctorHBaseRegionServersResponseBodyData },
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseRegionServersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDoctorHBaseRegionServersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDoctorHBaseRegionServersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The query date.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-01-01
   */
  dateTime?: string;
  /**
   * @remarks
   * The maximum number of entries that are returned.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * Marks the current position to start reading. If this field is empty, the data is read from the beginning.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The field that you use to sort the query results.
   * 
   * Valid values:
   * 
   * *   tableSize
   * 
   * @example
   * tableSize
   */
  orderBy?: string;
  /**
   * @remarks
   * The order in which you want to sort the query results. Valid value:
   * 
   * *   ASC: in ascending order
   * *   DESC: in descending order
   * 
   * @example
   * ASC
   */
  orderType?: string;
  /**
   * @remarks
   * The ID of the region.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The table names, which are used to filter the query results.
   * 
   * @example
   * null
   */
  tableNames?: string[];
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dateTime: 'DateTime',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      orderBy: 'OrderBy',
      orderType: 'OrderType',
      regionId: 'RegionId',
      tableNames: 'TableNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dateTime: 'string',
      maxResults: 'number',
      nextToken: 'string',
      orderBy: 'string',
      orderType: 'string',
      regionId: 'string',
      tableNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response parameters.
   */
  data?: ListDoctorHBaseTablesResponseBodyData[];
  /**
   * @remarks
   * The maximum number of entries returned.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * The page number of the next page returned.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 200
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListDoctorHBaseTablesResponseBodyData },
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDoctorHBaseTablesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDoctorHBaseTablesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesRequest extends $tea.Model {
  /**
   * @remarks
   * 集群ID。
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2023-01-01
   */
  dateTime?: string;
  /**
   * @example
   * /tmp/test
   */
  dirPath?: string;
  /**
   * @remarks
   * 一次获取的最大记录数。取值范围：1~100。
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * 标记当前开始读取的位置，置空表示从头开始。
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @example
   * smallFileCount
   */
  orderBy?: string;
  /**
   * @example
   * ASC
   */
  orderType?: string;
  /**
   * @remarks
   * 区域ID。
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dateTime: 'DateTime',
      dirPath: 'DirPath',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      orderBy: 'OrderBy',
      orderType: 'OrderType',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dateTime: 'string',
      dirPath: 'string',
      maxResults: 'number',
      nextToken: 'string',
      orderBy: 'string',
      orderType: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBody extends $tea.Model {
  data?: ListDoctorHDFSDirectoriesResponseBodyData[];
  /**
   * @remarks
   * 本次请求所返回的最大记录条数。
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * 返回读取到的数据位置，空代表数据已经读取完毕。
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * 请求ID。
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  /**
   * @remarks
   * 本次请求条件下的数据总量。
   * 
   * @example
   * 200
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListDoctorHDFSDirectoriesResponseBodyData },
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDoctorHDFSDirectoriesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDoctorHDFSDirectoriesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSUGIRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * Specify the date in the ISO 8601 standard. For example, 2023-01-01 represents January 1, 2023.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-01-01
   */
  dateTime?: string;
  /**
   * @remarks
   * The maximum number of entries to return on each page.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * The pagination token that is used in the request to retrieve a new page of results.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The basis on which you want to sort the query results. Valid values:
   * 
   * *   totalFileCount: the total number of files
   * *   totalDataSize: the total data size
   * *   totalDirCount: the total number of directories
   * 
   * @example
   * totalFileCount
   */
  orderBy?: string;
  /**
   * @remarks
   * The order in which you want to sort the query results. Valid values:
   * 
   * *   ASC: in ascending order
   * *   DESC: in descending order
   * 
   * @example
   * ASC
   */
  orderType?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The filter condition. Valid values:
   * 
   * *   user
   * *   group
   * 
   * This parameter is required.
   * 
   * @example
   * group
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dateTime: 'DateTime',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      orderBy: 'OrderBy',
      orderType: 'OrderType',
      regionId: 'RegionId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dateTime: 'string',
      maxResults: 'number',
      nextToken: 'string',
      orderBy: 'string',
      orderType: 'string',
      regionId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSUGIResponseBody extends $tea.Model {
  /**
   * @remarks
   * The results of batch HDFS analysis.
   */
  data?: ListDoctorHDFSUGIResponseBodyData[];
  /**
   * @remarks
   * The maximum number of entries that are returned.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * A pagination token.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 200
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListDoctorHDFSUGIResponseBodyData },
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSUGIResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDoctorHDFSUGIResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDoctorHDFSUGIResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The database names.
   * 
   * @example
   * null
   */
  databaseNames?: string[];
  /**
   * @remarks
   * The query date.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-01-01
   */
  dateTime?: string;
  /**
   * @remarks
   * The maximum number of entries to return on each page.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * The pagination token that is used in the request to retrieve a new page of results.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The basis on which you want to sort the query results. Valid values:
   * 
   * *   tableCount: the number of tables
   * 
   * @example
   * tableCount
   */
  orderBy?: string;
  /**
   * @remarks
   * The order in which you want to sort the query results. Valid values:
   * 
   * *   ASC: in ascending order
   * *   DESC: in descending order
   * 
   * @example
   * ASC
   */
  orderType?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      databaseNames: 'DatabaseNames',
      dateTime: 'DateTime',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      orderBy: 'OrderBy',
      orderType: 'OrderType',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      databaseNames: { 'type': 'array', 'itemType': 'string' },
      dateTime: 'string',
      maxResults: 'number',
      nextToken: 'string',
      orderBy: 'string',
      orderType: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The analysis results of Hive databases.
   */
  data?: ListDoctorHiveDatabasesResponseBodyData[];
  /**
   * @remarks
   * The maximum number of entries that are returned.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * A pagination token.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 200
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListDoctorHiveDatabasesResponseBodyData },
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDoctorHiveDatabasesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDoctorHiveDatabasesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * Specify the date in the ISO 8601 standard. For example, 2023-01-01 represents January 1, 2023.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-01-01
   */
  dateTime?: string;
  /**
   * @remarks
   * The maximum number of entries to return on each page.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * The pagination token that is used in the request to retrieve a new page of results.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The basis on which you want to sort the query results. Valid values:
   * 
   * *   partitionNum: the number of partitions.
   * *   totalFileCount: the total number of files.
   * *   largeFileCount: the number of large files. Large files are those with a size greater than 1 GB.
   * *   mediumFileCount: the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   * *   smallFileCount: the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   * *   tinyFileCount: the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   * *   emptyFileCount: the number of empty files. Empty files are those with a size of 0 MB.
   * *   largeFileRatio: the proportion of large files. Large files are those with a size greater than 1 GB.
   * *   mediumFileRatio: the proportion of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   * *   smallFileRatio: the proportion of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   * *   tinyFileRatio: the proportion of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   * *   emptyFileRatio: the proportion of empty files. Empty files are those with a size of 0 MB.
   * *   hotDataSize: the amount of hot data. Hot data refers to data that is accessed in previous seven days.
   * *   WarmDataSize: the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
   * *   coldDataSize: the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
   * *   freezeDataSize: the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   * *   totalDataSize: the total amount of data.
   * *   hotDataRatio: the proportion of hot data. Hot data refers to data that is accessed in previous seven days.
   * *   WarmDataRatio: the proportion of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
   * *   coldDataRatio: the proportion of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
   * *   freezeDataRatio: the proportion of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   * *   totalFileDayGrowthCount: the daily increment of the total number of files.
   * *   largeFileDayGrowthCount: the daily increment of the number of large files. Large files are those with a size greater than 1 GB.
   * *   mediumFileDayGrowthCount: the daily increment of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   * *   smallFileDayGrowthCount: the daily increment of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   * *   tinyFileDayGrowthCount: the daily increment of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   * *   emptyFileDayGrowthCount: the daily increment of the number of empty files. Empty files are those with a size of 0 MB.
   * *   hotDataDayGrowthSize: the daily increment of the amount of hot data. Hot data refers to data that is accessed in previous seven days.
   * *   warmDataDayGrowthSize: the daily increment of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
   * *   coldDataDayGrowthSize: the daily increment of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
   * *   freezeDataDayGrowthSize: the daily increment of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   * *   totalDataDayGrowthSize: the daily increment of the amount of total data.
   * *   totalFileCountDayGrowthRatio: the day-to-day growth rate of the total number of files.
   * *   largeFileCountDayGrowthRatio: the day-to-day growth rate of the number of large files. Large files are those with a size greater than 1 GB.
   * *   mediumFileCountDayGrowthRatio: the day-to-day growth rate of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   * *   smallFileCountDayGrowthRatio: the day-to-day growth rate of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   * *   tinyFileCountDayGrowthRatio: the day-to-day growth rate of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   * *   emptyFileCountDayGrowthRatio: the day-to-day growth rate of the number of empty files. Empty files are those with a size of 0 MB.
   * *   hotDataSizeDayGrowthRatio: the day-to-day growth rate of the amount of hot data. Hot data refers to data that is accessed in previous seven days.
   * *   warmDataSizeDayGrowthRatio: the day-to-day growth rate of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
   * *   coldDataSizeDayGrowthRatio: the day-to-day growth rate of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
   * *   freezeDataSizeDayGrowthRatio: the day-to-day growth rate of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   * *   totalDataSizeDayGrowthRatio: the day-to-day growth rate of the total amount of data.
   * 
   * @example
   * totalFileCount
   */
  orderBy?: string;
  /**
   * @remarks
   * The order in which you want to sort the query results. Valid value:
   * 
   * *   ASC: in ascending order
   * *   DESC: in descending order
   * 
   * @example
   * ASC
   */
  orderType?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The table names, which are used to filter the query results.
   * 
   * @example
   * null
   */
  tableNames?: string[];
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dateTime: 'DateTime',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      orderBy: 'OrderBy',
      orderType: 'OrderType',
      regionId: 'RegionId',
      tableNames: 'TableNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dateTime: 'string',
      maxResults: 'number',
      nextToken: 'string',
      orderBy: 'string',
      orderType: 'string',
      regionId: 'string',
      tableNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The analysis results of Hive tables.
   */
  data?: ListDoctorHiveTablesResponseBodyData[];
  /**
   * @remarks
   * The maximum number of entries that are returned.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * A pagination token.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 200
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListDoctorHiveTablesResponseBodyData },
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDoctorHiveTablesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDoctorHiveTablesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorJobsRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of the jobs that are submitted to YARN.
   * 
   * @example
   * null
   */
  appIds?: string[];
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The range of end time. You can filter jobs whose end time falls within the specified time range.
   */
  endRange?: ListDoctorJobsRequestEndRange;
  /**
   * @remarks
   * The maximum number of entries to return on each page.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * The pagination token that is used in the request to retrieve a new page of results.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The field that you use to sort the query results. Valid values:
   * 
   * *   vcoreSeconds: the aggregated number of vCPUs that are allocated to the job multiplied by the number of seconds the job has been running
   * *   memSeconds: the aggregated amount of memory that is allocated to the job multiplied by the number of seconds the job has been running
   * 
   * @example
   * vcoreSeconds
   */
  orderBy?: string;
  /**
   * @remarks
   * The order in which you want to sort the query results. Valid values:
   * 
   * *   ASC: the ascending order
   * *   DESC: the descending order
   * 
   * @example
   * ASC
   */
  orderType?: string;
  /**
   * @remarks
   * The YARN queues to which the jobs are submitted.
   * 
   * @example
   * null
   */
  queues?: string[];
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The range of start time. You can filter jobs whose start time falls within the specified time range.
   */
  startRange?: ListDoctorJobsRequestStartRange;
  /**
   * @remarks
   * The YARN engines to which the jobs are submitted.
   * 
   * @example
   * null
   */
  types?: string[];
  /**
   * @remarks
   * The users who submit the jobs.
   * 
   * @example
   * null
   */
  users?: string[];
  static names(): { [key: string]: string } {
    return {
      appIds: 'AppIds',
      clusterId: 'ClusterId',
      endRange: 'EndRange',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      orderBy: 'OrderBy',
      orderType: 'OrderType',
      queues: 'Queues',
      regionId: 'RegionId',
      startRange: 'StartRange',
      types: 'Types',
      users: 'Users',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appIds: { 'type': 'array', 'itemType': 'string' },
      clusterId: 'string',
      endRange: ListDoctorJobsRequestEndRange,
      maxResults: 'number',
      nextToken: 'string',
      orderBy: 'string',
      orderType: 'string',
      queues: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
      startRange: ListDoctorJobsRequestStartRange,
      types: { 'type': 'array', 'itemType': 'string' },
      users: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorJobsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the jobs.
   */
  data?: ListDoctorJobsResponseBodyData[];
  /**
   * @remarks
   * The maximum number of entries returned.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * A pagination token.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 200
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListDoctorJobsResponseBodyData },
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorJobsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDoctorJobsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDoctorJobsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorJobsStatsRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The range of end time. You can filter jobs whose end time falls within the specified time range.
   */
  endRange?: ListDoctorJobsStatsRequestEndRange;
  /**
   * @remarks
   * The fields that are used for grouping data.
   * 
   * Currently, only the first value is used for grouping data. Combinations of multiple values will be supported in the future.
   * 
   * @example
   * null
   */
  groupBy?: string[];
  /**
   * @remarks
   * The maximum number of entries to return on each page.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * The pagination token that is used in the request to retrieve a new page of results.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The field that you use to sort the query results. Valid values:
   * 
   * *   vcoreSeconds: the aggregated number of vCPUs that are allocated to the job multiplied by the number of seconds the job has been running
   * *   memSeconds: the aggregated amount of memory that is allocated to the job multiplied by the number of seconds the job has been running
   * 
   * @example
   * vcoreSeconds
   */
  orderBy?: string;
  /**
   * @remarks
   * The order in which you want to sort the query results. Valid values:
   * 
   * *   ASC: in ascending order
   * *   DESC: in descending order
   * 
   * @example
   * ASC
   */
  orderType?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The range of start time. You can filter jobs whose start time falls within the specified time range.
   */
  startRange?: ListDoctorJobsStatsRequestStartRange;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      endRange: 'EndRange',
      groupBy: 'GroupBy',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      orderBy: 'OrderBy',
      orderType: 'OrderType',
      regionId: 'RegionId',
      startRange: 'StartRange',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      endRange: ListDoctorJobsStatsRequestEndRange,
      groupBy: { 'type': 'array', 'itemType': 'string' },
      maxResults: 'number',
      nextToken: 'string',
      orderBy: 'string',
      orderType: 'string',
      regionId: 'string',
      startRange: ListDoctorJobsStatsRequestStartRange,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorJobsStatsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The summary of job information.
   */
  data?: ListDoctorJobsStatsResponseBodyData[];
  /**
   * @remarks
   * The maximum number of entries returned.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * A pagination token.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 200
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListDoctorJobsStatsResponseBodyData },
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorJobsStatsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDoctorJobsStatsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDoctorJobsStatsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorReportsRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * The pagination token that is used in the request to retrieve a new page of results.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      maxResults: 'number',
      nextToken: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorReportsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The reports.
   */
  data?: ListDoctorReportsResponseBodyData[];
  /**
   * @remarks
   * The maximum number of entries returned.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * A pagination token.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 200
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListDoctorReportsResponseBodyData },
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorReportsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDoctorReportsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDoctorReportsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceTypesRequest extends $tea.Model {
  /**
   * @remarks
   * 集群ID，仅升配场景使用。
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * 创建的EMR集群类型。取值范围：
   * - DATALAKE：新版数据湖。
   * - OLAP：数据分析。
   * - DATAFLOW：实时数据流。
   * - DATASERVING：数据服务。
   * - CUSTOM：自定义集群。
   * - HADOOP：旧版数据湖（不推荐使用，建议使用新版数据湖）。
   * 
   * This parameter is required.
   * 
   * @example
   * DATALAKE
   */
  clusterType?: string;
  /**
   * @remarks
   * 集群中的应用部署模式。取值范围：
   * - NORMAL：非高可用部署。集群1个MASTER节点。
   * - HA：高可用部署。高可用部署要求至少3个MASTER节点。
   * 
   * 默认值：NORMAL。
   * 
   * @example
   * HA
   */
  deployMode?: string;
  /**
   * @remarks
   * 机型
   * 
   * @example
   * ecs.g6.xlarge
   */
  instanceType?: string;
  /**
   * @remarks
   * 是否变配。
   * 
   * @example
   * false
   */
  isModification?: boolean;
  /**
   * @remarks
   * 节点组ID。
   * 
   * @example
   * G-F06C4B47966A****
   */
  nodeGroupId?: string;
  /**
   * @remarks
   * 节点组类型。取值范围：
   * - MASTER：管理类型节点组。
   * - CORE：存储类型节点组。
   * - TASK：计算类型节点组。
   * 
   * This parameter is required.
   * 
   * @example
   * CORE
   */
  nodeGroupType?: string;
  /**
   * @remarks
   * 集群的付费类型。取值范围：
   * - PayAsYouGo：后付费。
   * - Subscription：预付费。
   * 
   * 默认值：PayAsYouGo。
   * 
   * This parameter is required.
   * 
   * @example
   * PayAsYouGo
   */
  paymentType?: string;
  /**
   * @remarks
   * 区域ID。
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * EMR发行版。
   * 
   * @example
   * EMR-5.3.0
   */
  releaseVersion?: string;
  /**
   * @remarks
   * 可用区ID。
   * 
   * This parameter is required.
   * 
   * @example
   * cn-beijing-h
   */
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      clusterType: 'ClusterType',
      deployMode: 'DeployMode',
      instanceType: 'InstanceType',
      isModification: 'IsModification',
      nodeGroupId: 'NodeGroupId',
      nodeGroupType: 'NodeGroupType',
      paymentType: 'PaymentType',
      regionId: 'RegionId',
      releaseVersion: 'ReleaseVersion',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      clusterType: 'string',
      deployMode: 'string',
      instanceType: 'string',
      isModification: 'boolean',
      nodeGroupId: 'string',
      nodeGroupType: 'string',
      paymentType: 'string',
      regionId: 'string',
      releaseVersion: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceTypesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The instance types.
   */
  instanceTypes?: InstanceType[];
  /**
   * @remarks
   * 本次请求所返回的最大记录条数。
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * 返回读取到的数据位置，空代表数据已经读取完毕。
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * 请求ID。
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  /**
   * @remarks
   * 本次请求条件下的数据总量。
   * 
   * @example
   * 200
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      instanceTypes: 'InstanceTypes',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceTypes: { 'type': 'array', 'itemType': InstanceType },
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceTypesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListInstanceTypesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListInstanceTypesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodeGroupsRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The number of maximum number of records to obtain at a time. Valid values: 1 to 100.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * Marks the current position where reading starts. If you set this value to null, you can start from the beginning.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The IDs of node groups. Valid values of the number of array elements N: 1 to 100.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  nodeGroupIds?: string[];
  /**
   * @remarks
   * The list of node group names. Valid values of the number of array elements N: 1 to 100.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nodeGroupNames?: string[];
  /**
   * @remarks
   * The status of the node group. Valid values of the number of array elements N: 1 to 100.
   * 
   * @example
   * ["CORE"]
   */
  nodeGroupStates?: string[];
  /**
   * @remarks
   * The list of node group types. Valid values of the number of array elements N: 1 to 100.
   * 
   * @example
   * 20
   */
  nodeGroupTypes?: string[];
  /**
   * @remarks
   * The ID of the region in which you want to create the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      nodeGroupIds: 'NodeGroupIds',
      nodeGroupNames: 'NodeGroupNames',
      nodeGroupStates: 'NodeGroupStates',
      nodeGroupTypes: 'NodeGroupTypes',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      maxResults: 'number',
      nextToken: 'string',
      nodeGroupIds: { 'type': 'array', 'itemType': 'string' },
      nodeGroupNames: { 'type': 'array', 'itemType': 'string' },
      nodeGroupStates: { 'type': 'array', 'itemType': 'string' },
      nodeGroupTypes: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodeGroupsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The maximum number of entries returned.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * Returns the location of the data that was read. Empty indicates that the data has been read.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The array of node groups.
   */
  nodeGroups?: NodeGroup[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 200
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      nodeGroups: 'NodeGroups',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      nodeGroups: { 'type': 'array', 'itemType': NodeGroup },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodeGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListNodeGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListNodeGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The number of maximum number of records to obtain at a time. Valid values: 1 to 100.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * Marks the current position where reading starts. If you set this value to null, you can start from the beginning.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The IDs of node groups.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nodeGroupIds?: string[];
  /**
   * @remarks
   * An array that consists of information about the ID of the node.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  nodeIds?: string[];
  /**
   * @remarks
   * The names of the nodes.
   * 
   * @example
   * 20
   */
  nodeNames?: string[];
  /**
   * @remarks
   * The status of the node.
   * 
   * @example
   * ["CREATED"]
   */
  nodeStates?: string[];
  /**
   * @remarks
   * The private IP address.
   * 
   * @example
   * ["172.12.0.91"]
   */
  privateIps?: string[];
  /**
   * @remarks
   * The public IP address.
   * 
   * @example
   * ["120.13.14.38"]
   */
  publicIps?: string[];
  /**
   * @remarks
   * The ID of the region in which you want to create the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The list of tags to be bound.
   */
  tags?: Tag[];
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      nodeGroupIds: 'NodeGroupIds',
      nodeIds: 'NodeIds',
      nodeNames: 'NodeNames',
      nodeStates: 'NodeStates',
      privateIps: 'PrivateIps',
      publicIps: 'PublicIps',
      regionId: 'RegionId',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      maxResults: 'number',
      nextToken: 'string',
      nodeGroupIds: { 'type': 'array', 'itemType': 'string' },
      nodeIds: { 'type': 'array', 'itemType': 'string' },
      nodeNames: { 'type': 'array', 'itemType': 'string' },
      nodeStates: { 'type': 'array', 'itemType': 'string' },
      privateIps: { 'type': 'array', 'itemType': 'string' },
      publicIps: { 'type': 'array', 'itemType': 'string' },
      regionId: 'string',
      tags: { 'type': 'array', 'itemType': Tag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The maximum number of entries returned.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * The position at which the next read starts. If null is returned, the data has been read.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * Details about nodes.
   */
  nodes?: Node[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of records in this request.
   * 
   * @example
   * 200
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      nodes: 'Nodes',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      nodes: { 'type': 'array', 'itemType': Node },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListNodesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListNodesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListReleaseVersionsRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * DATALAKE
   */
  clusterType?: string;
  /**
   * @remarks
   * The type of the IaaS resource.
   * 
   * @example
   * ECS
   */
  iaasType?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterType: 'ClusterType',
      iaasType: 'IaasType',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterType: 'string',
      iaasType: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListReleaseVersionsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The maximum number of entries returned.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * Returns the location of the data that was read.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The major EMR versions.
   */
  releaseVersions?: ListReleaseVersionsResponseBodyReleaseVersions[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 200
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      releaseVersions: 'ReleaseVersions',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      releaseVersions: { 'type': 'array', 'itemType': ListReleaseVersionsResponseBodyReleaseVersions },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListReleaseVersionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListReleaseVersionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListReleaseVersionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScriptsRequest extends $tea.Model {
  /**
   * @remarks
   * 集群ID。
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * 一次获取的最大记录数。取值范围：1~100。
   * 
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @remarks
   * 标记当前开始读取的位置，置空表示从头开始。
   * 
   * @example
   * dd6b1b2a-5837-5237-abe4-ff0c89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * 区域ID。
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * 集群脚本类型。
   * 
   * This parameter is required.
   * 
   * @example
   * BOOTSTRAP
   */
  scriptType?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      regionId: 'RegionId',
      scriptType: 'ScriptType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      maxResults: 'number',
      nextToken: 'string',
      regionId: 'string',
      scriptType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScriptsResponseBody extends $tea.Model {
  /**
   * @remarks
   * 本次请求所返回的最大记录条数。
   * 
   * @example
   * 10
   */
  maxResults?: number;
  /**
   * @remarks
   * 返回读取到的数据位置，空代表数据已经读取完毕。
   * 
   * @example
   * dd6b1b2a-5837-5237-abe4-ff0c89568982
   */
  nextToken?: string;
  /**
   * @remarks
   * 请求ID。
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  /**
   * @remarks
   * The scripts.
   */
  scripts?: ListScriptsResponseBodyScripts[];
  /**
   * @remarks
   * 本次请求条件下的数据总量。
   * 
   * @example
   * 200
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      scripts: 'Scripts',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      scripts: { 'type': 'array', 'itemType': ListScriptsResponseBodyScripts },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScriptsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListScriptsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListScriptsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesRequest extends $tea.Model {
  /**
   * @remarks
   * The number of maximum number of records to obtain at a time.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * The pagination token that is used in the request to retrieve a new page of results. If NextToken is empty, the query starts from the beginning.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The ID of the region in which you want to create the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The list of resource IDs. Number of array elements N Valid values: 1 to 1
   * 
   * This parameter is required.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  resourceIds?: string[];
  /**
   * @remarks
   * The type of the resource. Set the value to cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * cluster
   */
  resourceType?: string;
  /**
   * @remarks
   * The array of tags. The number of array elements N. Valid values: 1 to 20.
   * 
   * @example
   * 20
   */
  tags?: Tag[];
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      regionId: 'RegionId',
      resourceIds: 'ResourceIds',
      resourceType: 'ResourceType',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      regionId: 'string',
      resourceIds: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      tags: { 'type': 'array', 'itemType': Tag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The maximum number of entries returned.
   * 
   * @example
   * 20
   */
  maxResults?: number;
  /**
   * @remarks
   * Returns the location of the data that was read. Empty indicates that the data has been read.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C89568980
   */
  nextToken?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 372D4E9B-2509-5EFA-846B-B34FBF143F56
   */
  requestId?: string;
  /**
   * @remarks
   * The details about the tag. Contains the resource ID, resource type, and tag key-value information.
   */
  tagResources?: ListTagResourcesResponseBodyTagResources[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 200
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      maxResults: 'MaxResults',
      nextToken: 'NextToken',
      requestId: 'RequestId',
      tagResources: 'TagResources',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxResults: 'number',
      nextToken: 'string',
      requestId: 'string',
      tagResources: { 'type': 'array', 'itemType': ListTagResourcesResponseBodyTagResources },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutAutoScalingPolicyRequest extends $tea.Model {
  /**
   * @remarks
   * 集群ID。
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The maximum and minimum numbers of nodes in a node group.
   */
  constraints?: ScalingConstraints;
  /**
   * @remarks
   * 节点组ID。节点组 Id-针对 ACK 集群，此字段为空。
   * 
   * This parameter is required.
   * 
   * @example
   * ng-869471354ecd****
   */
  nodeGroupId?: string;
  /**
   * @remarks
   * 区域ID。
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The auto scaling rules. Number of elements in the array: 0 to 100.
   */
  scalingRules?: ScalingRule[];
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      constraints: 'Constraints',
      nodeGroupId: 'NodeGroupId',
      regionId: 'RegionId',
      scalingRules: 'ScalingRules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      constraints: ScalingConstraints,
      nodeGroupId: 'string',
      regionId: 'string',
      scalingRules: { 'type': 'array', 'itemType': ScalingRule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutAutoScalingPolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * 请求ID。
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutAutoScalingPolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PutAutoScalingPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PutAutoScalingPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveAutoScalingPolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The ID of the node group.
   * 
   * This parameter is required.
   * 
   * @example
   * ng-869471354ecd****
   */
  nodeGroupId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      nodeGroupId: 'NodeGroupId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      nodeGroupId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveAutoScalingPolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveAutoScalingPolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RemoveAutoScalingPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RemoveAutoScalingPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunApiTemplateRequest extends $tea.Model {
  /**
   * @remarks
   * 接口名。
   * 
   * This parameter is required.
   * 
   * @example
   * CreateCluster
   */
  apiName?: string;
  /**
   * @remarks
   * 幂等客户端TOKEN。
   * 
   * @example
   * A7D960FA-6DBA-5E07-8746-A63E3E4D****
   */
  clientToken?: string;
  /**
   * @remarks
   * 地域ID。
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * 集群模板id。
   * 
   * This parameter is required.
   * 
   * @example
   * AT-****
   */
  templateId?: string;
  static names(): { [key: string]: string } {
    return {
      apiName: 'ApiName',
      clientToken: 'ClientToken',
      regionId: 'RegionId',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiName: 'string',
      clientToken: 'string',
      regionId: 'string',
      templateId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunApiTemplateResponseBody extends $tea.Model {
  /**
   * @example
   * {\\"clusterId\\":\\"c-b7be171f1928****\\",\\"operationId\\":\\"op-61126efe629d****\\"}
   */
  data?: string;
  /**
   * @remarks
   * 请求ID。
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunApiTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RunApiTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RunApiTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunApplicationActionRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the action. Valid values:
   * 
   * *   start
   * *   stop
   * *   config
   * *   restart
   * *   refresh_queues
   * *   refresh_labels
   * 
   * This parameter is required.
   * 
   * @example
   * start
   */
  actionName?: string;
  /**
   * @remarks
   * The number of applications in each batch.
   * 
   * @example
   * 1
   */
  batchSize?: number;
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * C-C95F0A39D8FF****
   */
  clusterId?: string;
  /**
   * @remarks
   * The operation object.
   * 
   * This parameter is required.
   */
  componentInstanceSelector?: ComponentInstanceSelector;
  /**
   * @remarks
   * The description of the execution.
   * 
   * @example
   * 运行描述
   */
  description?: string;
  /**
   * @remarks
   * The execution policy. Valid values:
   * 
   * *   FAILED_BLOCK: The system stops the execution if the execution fails.
   * *   FAILED_CONTINUE: The system continues the execution if the execution fails.
   * 
   * @example
   * FAILED_CONTINUE
   */
  executeStrategy?: string;
  /**
   * @remarks
   * The interval for rolling execution. Unit: seconds.
   * 
   * @example
   * 10
   */
  interval?: number;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * Specifies whether to enable rolling execution.
   * 
   * @example
   * true
   */
  rollingExecute?: boolean;
  static names(): { [key: string]: string } {
    return {
      actionName: 'ActionName',
      batchSize: 'BatchSize',
      clusterId: 'ClusterId',
      componentInstanceSelector: 'ComponentInstanceSelector',
      description: 'Description',
      executeStrategy: 'ExecuteStrategy',
      interval: 'Interval',
      regionId: 'RegionId',
      rollingExecute: 'RollingExecute',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionName: 'string',
      batchSize: 'number',
      clusterId: 'string',
      componentInstanceSelector: ComponentInstanceSelector,
      description: 'string',
      executeStrategy: 'string',
      interval: 'number',
      regionId: 'string',
      rollingExecute: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunApplicationActionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The abnormal nodes.
   */
  abnInstances?: RunApplicationActionResponseBodyAbnInstances[];
  /**
   * @remarks
   * The operation ID.
   * 
   * @example
   * op-13c37a77c505****
   */
  operationId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9E3A7161-EB7B-172B-8D18-FFB06BA3****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      abnInstances: 'AbnInstances',
      operationId: 'OperationId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      abnInstances: { 'type': 'array', 'itemType': RunApplicationActionResponseBodyAbnInstances },
      operationId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunApplicationActionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RunApplicationActionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RunApplicationActionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunClusterRequest extends $tea.Model {
  /**
   * @remarks
   * 应用配置。数组元素个数N的取值范围：1~1000。
   */
  applicationConfigs?: ApplicationConfig[];
  /**
   * @remarks
   * 应用列表。数组元素个数N的取值范围：1~100。
   * 
   * This parameter is required.
   */
  applications?: Application[];
  /**
   * @remarks
   * 引导脚本。数组元素个数N的取值范围：1~10。
   */
  bootstrapScripts?: Script[];
  /**
   * @remarks
   * 幂等客户端TOKEN。同一个ClientToken多次调用的返回结果一致，同一个ClientToken最多只创建一个集群。
   * 
   * @example
   * A7D960FA-6DBA-5E07-8746-A63E3E4D****
   */
  clientToken?: string;
  /**
   * @remarks
   * 集群名称。长度为1~128个字符，必须以大小字母或中文开头，不能以http://和https://开头。可以包含中文、英文、数字、半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）
   * 
   * This parameter is required.
   * 
   * @example
   * emrtest
   */
  clusterName?: string;
  /**
   * @remarks
   * 创建的EMR集群类型。取值范围：
   * - DATALAKE：新版数据湖。
   * - OLAP：数据分析。
   * - DATAFLOW：实时数据流。
   * - DATASERVING：数据服务。
   * - CUSTOM：自定义集群。
   * - HADOOP：旧版数据湖（不推荐使用，建议使用新版数据湖）。
   * 
   * This parameter is required.
   * 
   * @example
   * DATALAKE
   */
  clusterType?: string;
  /**
   * @remarks
   * 集群中的应用部署模式。取值范围：
   * - NORMAL：非高可用部署。集群1个MASTER节点。
   * - HA：高可用部署。高可用部署要求至少3个MASTER节点。
   * 
   * 默认值：NORMAL。
   * 
   * @example
   * HA
   */
  deployMode?: string;
  /**
   * @example
   * Emr cluster for ETL
   */
  description?: string;
  nodeAttributes?: NodeAttributes;
  /**
   * @remarks
   * 节点组。数组元素个数N的取值范围：1~100。
   * <p>
   * 
   * This parameter is required.
   */
  nodeGroups?: NodeGroupConfig[];
  /**
   * @remarks
   * 集群的付费类型。取值范围：
   * - PayAsYouGo：后付费。
   * - Subscription：预付费。
   * 
   * 默认值：PayAsYouGo。
   * 
   * @example
   * PayAsYouGo
   */
  paymentType?: string;
  /**
   * @remarks
   * 区域ID。
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * EMR发行版。
   * 
   * This parameter is required.
   * 
   * @example
   * EMR-5.16.0
   */
  releaseVersion?: string;
  /**
   * @remarks
   * 集群所在的企业资源组ID。
   * 
   * @example
   * rg-acfmzabjyop****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * Kerberos安全模式。取值范围：
   * - NORMAL：普通模式，不开启Kerberos模式。
   * - KERBEROS：开启Kerberos模式。
   * 
   * 默认值：NORMAL
   * 
   * @example
   * NORMAL
   */
  securityMode?: string;
  subscriptionConfig?: SubscriptionConfig;
  /**
   * @remarks
   * 标签。数组元数个数N的取值范围：0~20。
   */
  tags?: Tag[];
  static names(): { [key: string]: string } {
    return {
      applicationConfigs: 'ApplicationConfigs',
      applications: 'Applications',
      bootstrapScripts: 'BootstrapScripts',
      clientToken: 'ClientToken',
      clusterName: 'ClusterName',
      clusterType: 'ClusterType',
      deployMode: 'DeployMode',
      description: 'Description',
      nodeAttributes: 'NodeAttributes',
      nodeGroups: 'NodeGroups',
      paymentType: 'PaymentType',
      regionId: 'RegionId',
      releaseVersion: 'ReleaseVersion',
      resourceGroupId: 'ResourceGroupId',
      securityMode: 'SecurityMode',
      subscriptionConfig: 'SubscriptionConfig',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationConfigs: { 'type': 'array', 'itemType': ApplicationConfig },
      applications: { 'type': 'array', 'itemType': Application },
      bootstrapScripts: { 'type': 'array', 'itemType': Script },
      clientToken: 'string',
      clusterName: 'string',
      clusterType: 'string',
      deployMode: 'string',
      description: 'string',
      nodeAttributes: NodeAttributes,
      nodeGroups: { 'type': 'array', 'itemType': NodeGroupConfig },
      paymentType: 'string',
      regionId: 'string',
      releaseVersion: 'string',
      resourceGroupId: 'string',
      securityMode: 'string',
      subscriptionConfig: SubscriptionConfig,
      tags: { 'type': 'array', 'itemType': Tag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunClusterShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * 应用配置。数组元素个数N的取值范围：1~1000。
   */
  applicationConfigsShrink?: string;
  /**
   * @remarks
   * 应用列表。数组元素个数N的取值范围：1~100。
   * 
   * This parameter is required.
   */
  applicationsShrink?: string;
  /**
   * @remarks
   * 引导脚本。数组元素个数N的取值范围：1~10。
   */
  bootstrapScriptsShrink?: string;
  /**
   * @remarks
   * 幂等客户端TOKEN。同一个ClientToken多次调用的返回结果一致，同一个ClientToken最多只创建一个集群。
   * 
   * @example
   * A7D960FA-6DBA-5E07-8746-A63E3E4D****
   */
  clientToken?: string;
  /**
   * @remarks
   * 集群名称。长度为1~128个字符，必须以大小字母或中文开头，不能以http://和https://开头。可以包含中文、英文、数字、半角冒号（:）、下划线（_）、半角句号（.）或者短划线（-）
   * 
   * This parameter is required.
   * 
   * @example
   * emrtest
   */
  clusterName?: string;
  /**
   * @remarks
   * 创建的EMR集群类型。取值范围：
   * - DATALAKE：新版数据湖。
   * - OLAP：数据分析。
   * - DATAFLOW：实时数据流。
   * - DATASERVING：数据服务。
   * - CUSTOM：自定义集群。
   * - HADOOP：旧版数据湖（不推荐使用，建议使用新版数据湖）。
   * 
   * This parameter is required.
   * 
   * @example
   * DATALAKE
   */
  clusterType?: string;
  /**
   * @remarks
   * 集群中的应用部署模式。取值范围：
   * - NORMAL：非高可用部署。集群1个MASTER节点。
   * - HA：高可用部署。高可用部署要求至少3个MASTER节点。
   * 
   * 默认值：NORMAL。
   * 
   * @example
   * HA
   */
  deployMode?: string;
  /**
   * @example
   * Emr cluster for ETL
   */
  description?: string;
  nodeAttributesShrink?: string;
  /**
   * @remarks
   * 节点组。数组元素个数N的取值范围：1~100。
   * <p>
   * 
   * This parameter is required.
   */
  nodeGroupsShrink?: string;
  /**
   * @remarks
   * 集群的付费类型。取值范围：
   * - PayAsYouGo：后付费。
   * - Subscription：预付费。
   * 
   * 默认值：PayAsYouGo。
   * 
   * @example
   * PayAsYouGo
   */
  paymentType?: string;
  /**
   * @remarks
   * 区域ID。
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * EMR发行版。
   * 
   * This parameter is required.
   * 
   * @example
   * EMR-5.16.0
   */
  releaseVersion?: string;
  /**
   * @remarks
   * 集群所在的企业资源组ID。
   * 
   * @example
   * rg-acfmzabjyop****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * Kerberos安全模式。取值范围：
   * - NORMAL：普通模式，不开启Kerberos模式。
   * - KERBEROS：开启Kerberos模式。
   * 
   * 默认值：NORMAL
   * 
   * @example
   * NORMAL
   */
  securityMode?: string;
  subscriptionConfigShrink?: string;
  /**
   * @remarks
   * 标签。数组元数个数N的取值范围：0~20。
   */
  tagsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      applicationConfigsShrink: 'ApplicationConfigs',
      applicationsShrink: 'Applications',
      bootstrapScriptsShrink: 'BootstrapScripts',
      clientToken: 'ClientToken',
      clusterName: 'ClusterName',
      clusterType: 'ClusterType',
      deployMode: 'DeployMode',
      description: 'Description',
      nodeAttributesShrink: 'NodeAttributes',
      nodeGroupsShrink: 'NodeGroups',
      paymentType: 'PaymentType',
      regionId: 'RegionId',
      releaseVersion: 'ReleaseVersion',
      resourceGroupId: 'ResourceGroupId',
      securityMode: 'SecurityMode',
      subscriptionConfigShrink: 'SubscriptionConfig',
      tagsShrink: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationConfigsShrink: 'string',
      applicationsShrink: 'string',
      bootstrapScriptsShrink: 'string',
      clientToken: 'string',
      clusterName: 'string',
      clusterType: 'string',
      deployMode: 'string',
      description: 'string',
      nodeAttributesShrink: 'string',
      nodeGroupsShrink: 'string',
      paymentType: 'string',
      regionId: 'string',
      releaseVersion: 'string',
      resourceGroupId: 'string',
      securityMode: 'string',
      subscriptionConfigShrink: 'string',
      tagsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunClusterResponseBody extends $tea.Model {
  /**
   * @remarks
   * 集群ID。
   * 
   * @example
   * c-b933c5aac7f7***
   */
  clusterId?: string;
  /**
   * @remarks
   * 操作ID。
   * 
   * @example
   * op-13c37a77c505****
   */
  operationId?: string;
  /**
   * @remarks
   * 请求ID。
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      operationId: 'OperationId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      operationId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunClusterResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RunClusterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RunClusterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the region in which you want to create the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The list of resource IDs. Valid values of N: 1 to 1.
   * 
   * This parameter is required.
   * 
   * @example
   * cluster
   */
  resourceIds?: string[];
  /**
   * @remarks
   * The type of the resource to which the tag belongs. Valid values:
   * 
   * *   cluster: cluster
   * 
   * This parameter is required.
   * 
   * @example
   * cluster
   */
  resourceType?: string;
  /**
   * @remarks
   * The tags.
   * 
   * This parameter is required.
   * 
   * @example
   * [null]
   */
  tags?: Tag[];
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      resourceIds: 'ResourceIds',
      resourceType: 'ResourceType',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      resourceIds: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      tags: { 'type': 'array', 'itemType': Tag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * A964BDB2-0FDA-1037-AF3F-2633D5C3F20F
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: TagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: TagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to remove all tags. This parameter is valid only when the **Tagkeys** is empty. Valid values:
   * 
   * *   true: All the data is deleted.
   * *   false: Not all of them are deleted.
   * 
   * Default value: false
   * 
   * @example
   * false
   */
  all?: boolean;
  /**
   * @remarks
   * The ID of the region in which you want to create the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The list of resource IDs.
   * 
   * This parameter is required.
   * 
   * @example
   * cluster
   */
  resourceIds?: string[];
  /**
   * @remarks
   * The type of the resource. Set the value to cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * cluster
   */
  resourceType?: string;
  /**
   * @remarks
   * The key of the label. Valid values of N: 1 to 20.
   * 
   * @example
   * ["c-b933c5aac8fe****"]
   */
  tagKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      all: 'All',
      regionId: 'RegionId',
      resourceIds: 'ResourceIds',
      resourceType: 'ResourceType',
      tagKeys: 'TagKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      all: 'boolean',
      regionId: 'string',
      resourceIds: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      tagKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 17A6A3D5-4B13-1DAD-9A23-66EA5FC83B50
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UntagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UntagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateApiTemplateRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the API. You can create only a cluster API operation template. Set the value to CreateCluster.
   * 
   * This parameter is required.
   * 
   * @example
   * CreateCluster
   */
  apiName?: string;
  /**
   * @remarks
   * The content of the cluster API operation template. Set the value to JSON strings of the request parameters of the [CreateCluster](https://help.aliyun.com/document_detail/454393.html) API for creating a cluster.
   * 
   * This parameter is required.
   * 
   * @example
   * CreateCluster
   */
  content?: string;
  /**
   * @remarks
   * 区域ID。
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * 资源组ID。
   * 
   * @example
   * rg-acfmzabjyop****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * 集群模板id。
   * 
   * This parameter is required.
   * 
   * @example
   * AT-****
   */
  templateId?: string;
  /**
   * @remarks
   * 集群模板名字。
   * 
   * This parameter is required.
   * 
   * @example
   * DATALAKE模板
   */
  templateName?: string;
  static names(): { [key: string]: string } {
    return {
      apiName: 'ApiName',
      content: 'Content',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
      templateId: 'TemplateId',
      templateName: 'TemplateName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiName: 'string',
      content: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
      templateId: 'string',
      templateName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateApiTemplateResponseBody extends $tea.Model {
  /**
   * @remarks
   * 请求ID。
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  /**
   * @example
   * true
   * 
   * @deprecated
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateApiTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateApiTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateApiTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateApplicationConfigsRequest extends $tea.Model {
  /**
   * @remarks
   * 应用配置列表。
   * 
   * This parameter is required.
   */
  applicationConfigs?: UpdateApplicationConfig[];
  /**
   * @remarks
   * The application name.
   * 
   * This parameter is required.
   * 
   * @example
   * HDFS
   */
  applicationName?: string;
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-e6a9d46e9267****
   */
  clusterId?: string;
  /**
   * @remarks
   * The operation performed on configuration items. Valid values:
   * 
   * *   ADD
   * *   UPDATE
   * *   DELETE
   * 
   * @example
   * ADD
   */
  configAction?: string;
  /**
   * @remarks
   * The operation scope. Valid values:
   * 
   * *   CLUSTER
   * *   NODE_GROUP
   * 
   * @example
   * CLUSTER
   */
  configScope?: string;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * 更新YARN内存配置。
   */
  description?: string;
  /**
   * @remarks
   * The node group ID.
   * 
   * @example
   * ng-869471354ecd****
   */
  nodeGroupId?: string;
  /**
   * @remarks
   * The node ID.
   * 
   * @example
   * i-bp1cudc25w2bfwl5****
   */
  nodeId?: string;
  /**
   * @remarks
   * Specifies whether to refresh the configurations. Default value: True.
   * 
   * @example
   * true
   */
  refreshConfig?: boolean;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      applicationConfigs: 'ApplicationConfigs',
      applicationName: 'ApplicationName',
      clusterId: 'ClusterId',
      configAction: 'ConfigAction',
      configScope: 'ConfigScope',
      description: 'Description',
      nodeGroupId: 'NodeGroupId',
      nodeId: 'NodeId',
      refreshConfig: 'RefreshConfig',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationConfigs: { 'type': 'array', 'itemType': UpdateApplicationConfig },
      applicationName: 'string',
      clusterId: 'string',
      configAction: 'string',
      configScope: 'string',
      description: 'string',
      nodeGroupId: 'string',
      nodeId: 'string',
      refreshConfig: 'boolean',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateApplicationConfigsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The operation ID.
   * 
   * @example
   * op-13c37a77c505****
   */
  operationId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9E3A7161-EB7B-172B-8D18-FFB06BA3****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      operationId: 'OperationId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operationId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateApplicationConfigsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateApplicationConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateApplicationConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScriptRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The script.
   * 
   * This parameter is required.
   */
  script?: Script;
  /**
   * @remarks
   * The script ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cs-da7476a7679a4d4c9cede62ebe09****
   */
  scriptId?: string;
  /**
   * @remarks
   * The type of the script. Valid values:
   * 
   * *   BOOTSTRAP: indicates a bootstrap action of the Elastic Compute Service (ECS) instance.
   * *   NORMAL: indicates a common script.
   * 
   * This parameter is required.
   * 
   * @example
   * BOOTSTRAP
   */
  scriptType?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
      script: 'Script',
      scriptId: 'ScriptId',
      scriptType: 'ScriptType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
      script: Script,
      scriptId: 'string',
      scriptType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScriptShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * This parameter is required.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The script.
   * 
   * This parameter is required.
   */
  scriptShrink?: string;
  /**
   * @remarks
   * The script ID.
   * 
   * This parameter is required.
   * 
   * @example
   * cs-da7476a7679a4d4c9cede62ebe09****
   */
  scriptId?: string;
  /**
   * @remarks
   * The type of the script. Valid values:
   * 
   * *   BOOTSTRAP: indicates a bootstrap action of the Elastic Compute Service (ECS) instance.
   * *   NORMAL: indicates a common script.
   * 
   * This parameter is required.
   * 
   * @example
   * BOOTSTRAP
   */
  scriptType?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      regionId: 'RegionId',
      scriptShrink: 'Script',
      scriptId: 'ScriptId',
      scriptType: 'ScriptType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      regionId: 'string',
      scriptShrink: 'string',
      scriptId: 'string',
      scriptType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScriptResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * DD6B1B2A-5837-5237-ABE4-FF0C8944****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScriptResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateScriptResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateScriptResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AckConfigPvcs extends $tea.Model {
  dataDiskSize?: number;
  dataDiskStorageClass?: string;
  name?: string;
  path?: string;
  static names(): { [key: string]: string } {
    return {
      dataDiskSize: 'DataDiskSize',
      dataDiskStorageClass: 'DataDiskStorageClass',
      name: 'Name',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataDiskSize: 'number',
      dataDiskStorageClass: 'string',
      name: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AckConfigVolumeMounts extends $tea.Model {
  name?: string;
  path?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AckConfigVolumes extends $tea.Model {
  name?: string;
  path?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      path: 'Path',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      path: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AckNodeSelectorLabels extends $tea.Model {
  /**
   * @remarks
   * 标签键。
   * 
   * @example
   * emr
   */
  key?: string;
  /**
   * @remarks
   * 标签值。
   * 
   * @example
   * true
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AckNodeSelectorTaints extends $tea.Model {
  /**
   * @remarks
   * 污点效果。
   */
  effect?: string;
  /**
   * @remarks
   * 污点键。
   * 
   * @example
   * emr
   */
  key?: string;
  /**
   * @remarks
   * 污点值。
   * 
   * @example
   * true
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      effect: 'Effect',
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      effect: 'string',
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AutoScalingConstraintsSupportMetricTags extends $tea.Model {
  /**
   * @remarks
   * 指标名称。
   */
  metricName?: string;
  /**
   * @remarks
   * 指标Tag。
   */
  tags?: Tag[];
  static names(): { [key: string]: string } {
    return {
      metricName: 'MetricName',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      metricName: 'string',
      tags: { 'type': 'array', 'itemType': Tag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AutoScalingPolicyConstraints extends $tea.Model {
  maxCapacity?: number;
  minCapacity?: number;
  static names(): { [key: string]: string } {
    return {
      maxCapacity: 'maxCapacity',
      minCapacity: 'minCapacity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxCapacity: 'number',
      minCapacity: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ComponentInstanceSelectorComponentInstances extends $tea.Model {
  /**
   * @remarks
   * 应用名称。
   * 
   * @example
   * HDFS
   */
  applicationName?: string;
  /**
   * @remarks
   * 组件名称。
   * 
   * @example
   * DataNode
   */
  componentName?: string;
  /**
   * @remarks
   * 节点ID。
   * 
   * @example
   * i-bp1cudc25w2bfwl5****
   */
  nodeId?: string;
  static names(): { [key: string]: string } {
    return {
      applicationName: 'ApplicationName',
      componentName: 'ComponentName',
      nodeId: 'NodeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationName: 'string',
      componentName: 'string',
      nodeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ComponentInstanceSelectorComponents extends $tea.Model {
  /**
   * @remarks
   * 应用名称。
   * 
   * @example
   * HDFS
   */
  applicationName?: string;
  /**
   * @remarks
   * 组件名称。
   * 
   * @example
   * DataNode
   */
  componentName?: string;
  static names(): { [key: string]: string } {
    return {
      applicationName: 'ApplicationName',
      componentName: 'ComponentName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationName: 'string',
      componentName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ComponentLayoutNodeSelector extends $tea.Model {
  /**
   * @remarks
   * 节点结束编号，包含结束编号。
   * 
   * @example
   * 3
   */
  nodeEndIndex?: number;
  /**
   * @remarks
   * 节点组ID。
   * 
   * @example
   * G-F609686D45D4ABCD
   */
  nodeGroupId?: string;
  /**
   * @remarks
   * 机器组下标编号。
   * 
   * @example
   * 1
   */
  nodeGroupIndex?: number;
  /**
   * @remarks
   * 机器组名。
   * 
   * @example
   * master-1
   */
  nodeGroupName?: string;
  /**
   * @remarks
   * SelectType = NODE_GROUP 且 nodeGroupId 不存在时使用
   * 
   * @example
   * [null]
   */
  nodeGroupTypes?: string[];
  /**
   * @remarks
   * 节点名称列表。
   * 
   * @example
   * [null]
   */
  nodeNames?: string[];
  /**
   * @remarks
   * 节点选择类型。
   * 
   * This parameter is required.
   * 
   * @example
   * CLUSTER
   */
  nodeSelectType?: string;
  /**
   * @remarks
   * 节点开始编号，包含开始编号。
   * 
   * @example
   * 1
   */
  nodeStartIndex?: number;
  static names(): { [key: string]: string } {
    return {
      nodeEndIndex: 'NodeEndIndex',
      nodeGroupId: 'NodeGroupId',
      nodeGroupIndex: 'NodeGroupIndex',
      nodeGroupName: 'NodeGroupName',
      nodeGroupTypes: 'NodeGroupTypes',
      nodeNames: 'NodeNames',
      nodeSelectType: 'NodeSelectType',
      nodeStartIndex: 'NodeStartIndex',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeEndIndex: 'number',
      nodeGroupId: 'string',
      nodeGroupIndex: 'number',
      nodeGroupName: 'string',
      nodeGroupTypes: { 'type': 'array', 'itemType': 'string' },
      nodeNames: { 'type': 'array', 'itemType': 'string' },
      nodeSelectType: 'string',
      nodeStartIndex: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ScalingGroupConfigInstanceTypeList extends $tea.Model {
  /**
   * @remarks
   * Ecs类型。
   * 
   * @example
   * ecs.c5.xlarge
   */
  instanceType?: string;
  /**
   * @remarks
   * 抢占价格上限,可空。
   * 
   * @example
   * 0.79
   */
  spotPriceLimit?: number;
  static names(): { [key: string]: string } {
    return {
      instanceType: 'InstanceType',
      spotPriceLimit: 'SpotPriceLimit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceType: 'string',
      spotPriceLimit: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ScalingGroupConfigMultiAvailablePolicyPolicyParam extends $tea.Model {
  /**
   * @remarks
   * 按需实例最小个数。
   * 
   * @example
   * 1
   */
  onDemandBaseCapacity?: number;
  /**
   * @remarks
   * 按需实例百分比。
   * 
   * @example
   * 10
   */
  onDemandPercentageAboveBaseCapacity?: number;
  /**
   * @remarks
   * 抢占实例类型池规模。
   * 
   * @example
   * 10
   */
  spotInstancePools?: number;
  /**
   * @remarks
   * 是否使用按量补偿。
   * 
   * @example
   * false
   */
  spotInstanceRemedy?: boolean;
  static names(): { [key: string]: string } {
    return {
      onDemandBaseCapacity: 'OnDemandBaseCapacity',
      onDemandPercentageAboveBaseCapacity: 'OnDemandPercentageAboveBaseCapacity',
      spotInstancePools: 'SpotInstancePools',
      spotInstanceRemedy: 'SpotInstanceRemedy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      onDemandBaseCapacity: 'number',
      onDemandPercentageAboveBaseCapacity: 'number',
      spotInstancePools: 'number',
      spotInstanceRemedy: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ScalingGroupConfigMultiAvailablePolicy extends $tea.Model {
  /**
   * @remarks
   * 资源可用性策略(成本优化参数)。
   */
  policyParam?: ScalingGroupConfigMultiAvailablePolicyPolicyParam;
  /**
   * @remarks
   * 策略类型。
   * 
   * @example
   * PRIORITY
   */
  policyType?: string;
  static names(): { [key: string]: string } {
    return {
      policyParam: 'PolicyParam',
      policyType: 'PolicyType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyParam: ScalingGroupConfigMultiAvailablePolicyPolicyParam,
      policyType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ScalingGroupConfigNodeOfflinePolicy extends $tea.Model {
  /**
   * @remarks
   * 下线模式,是否为优雅下线。
   * 
   * @example
   * DEFAULT
   */
  mode?: string;
  /**
   * @remarks
   * 下线超时时间,单位毫秒。
   * 
   * @example
   * 1000
   */
  timeoutMs?: number;
  static names(): { [key: string]: string } {
    return {
      mode: 'Mode',
      timeoutMs: 'TimeoutMs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mode: 'string',
      timeoutMs: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ScalingGroupConfigPrivatePoolOptions extends $tea.Model {
  /**
   * @remarks
   * 私有池id。
   * 
   * @example
   * eap-bp67acfmxazb4****
   */
  id?: string;
  /**
   * @remarks
   * 实例启动的私有池容量选项。。
   * 
   * @example
   * Open
   */
  matchCriteria?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      matchCriteria: 'MatchCriteria',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      matchCriteria: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ScalingRuleSpecByLoadScalingRuleSpec extends $tea.Model {
  /**
   * @remarks
   * 比较符。
   * 
   * This parameter is required.
   * 
   * @example
   * LT
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * 统计次数。
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  evaluationCount?: number;
  /**
   * @remarks
   * 指标名称。指标名称需要在 ListAutoScalingMetrics 接口返回的指标名称列表中。
   * 
   * This parameter is required.
   * 
   * @example
   * yarn_resourcemanager_root_availablememoryusage
   */
  metricName?: string;
  /**
   * @remarks
   * 统计量名称。
   * 
   * This parameter is required.
   * 
   * @example
   * AVG
   */
  statistics?: string;
  /**
   * @remarks
   * 阈值。
   * 
   * This parameter is required.
   * 
   * @example
   * 12.5
   */
  threshold?: number;
  /**
   * @remarks
   * 统计窗口。单位为秒。
   * 
   * This parameter is required.
   * 
   * @example
   * 30
   */
  timeWindow?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      evaluationCount: 'EvaluationCount',
      metricName: 'MetricName',
      statistics: 'Statistics',
      threshold: 'Threshold',
      timeWindow: 'TimeWindow',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      evaluationCount: 'number',
      metricName: 'string',
      statistics: 'string',
      threshold: 'number',
      timeWindow: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ScalingRuleSpecByTimeScalingRuleSpec extends $tea.Model {
  /**
   * @remarks
   * 重复执行定时任务的结束时间戳。单位为毫秒。
   * 
   * @example
   * 1639714800000
   */
  endTime?: number;
  /**
   * @remarks
   * 启动时间戳。单位为毫秒。
   * 
   * This parameter is required.
   * 
   * @example
   * 1639714634819
   */
  launchTime?: number;
  /**
   * @remarks
   * 指定时间规则的执行类型。
   * 
   * @example
   * WEEKLY
   */
  recurrenceType?: string;
  /**
   * @remarks
   * 重复执行定时任务的数值。具体取值取决于 recurrenceType 设置。
   * 
   * @example
   * MON,FRI,SUN
   */
  recurrenceValue?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      launchTime: 'LaunchTime',
      recurrenceType: 'RecurrenceType',
      recurrenceValue: 'RecurrenceValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      launchTime: 'number',
      recurrenceType: 'string',
      recurrenceValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ScalingRuleV1RuleParam extends $tea.Model {
  /**
   * @remarks
   * [负载触发参数] 比较符。
   * 
   * @example
   * >
   */
  comparisonOperator?: string;
  /**
   * @remarks
   * [负载触发参数] 统计次数。
   * 
   * @example
   * 1
   */
  evaluationCount?: number;
  /**
   * @remarks
   * [时间调度参数] 周期类型周期过期时间。
   * 
   * @example
   * 0
   */
  launchExpirationTime?: number;
  /**
   * @remarks
   * [时间调度参数] 周期类型周期开始时间。
   * 
   * @example
   * 2021-09-15T04:02Z
   */
  launchTime?: string;
  /**
   * @remarks
   * [负载触发参数] 度量名称。
   * 
   * @example
   * YarnRootAvailableVCores
   */
  metricName?: string;
  /**
   * @remarks
   * [负载触发参数] 统计时长,单位分钟。
   * 
   * @example
   * 5
   */
  period?: number;
  /**
   * @remarks
   * [时间调度参数] 周期类型周期结束时间。
   * 
   * @example
   * 2021-09-16T05:02Z
   */
  recurrenceEndTime?: string;
  /**
   * @remarks
   * [时间调度参数] 周期类型。
   * 
   * @example
   * Daily
   */
  recurrenceType?: string;
  /**
   * @remarks
   * [时间调度参数] 周期类型周期值。
   * 
   * @example
   * 1
   */
  recurrenceValue?: string;
  /**
   * @remarks
   * [负载触发参数] 统计方式。
   * 
   * @example
   * Average
   */
  statistics?: string;
  /**
   * @remarks
   * [负载触发参数] 阈值。
   * 
   * @example
   * 1
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      comparisonOperator: 'ComparisonOperator',
      evaluationCount: 'EvaluationCount',
      launchExpirationTime: 'LaunchExpirationTime',
      launchTime: 'LaunchTime',
      metricName: 'MetricName',
      period: 'Period',
      recurrenceEndTime: 'RecurrenceEndTime',
      recurrenceType: 'RecurrenceType',
      recurrenceValue: 'RecurrenceValue',
      statistics: 'Statistics',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comparisonOperator: 'string',
      evaluationCount: 'number',
      launchExpirationTime: 'number',
      launchTime: 'string',
      metricName: 'string',
      period: 'number',
      recurrenceEndTime: 'string',
      recurrenceType: 'string',
      recurrenceValue: 'string',
      statistics: 'string',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApplicationResponseBodyApplicationActionsActionParamsValueAttribute extends $tea.Model {
  /**
   * @remarks
   * 值表述。
   * 
   * @example
   * 描述
   */
  description?: string;
  /**
   * @remarks
   * 值步长。
   * 
   * @example
   * 2
   */
  valueIncrementStep?: string;
  /**
   * @remarks
   * 最大值。
   * 
   * @example
   * 20
   */
  valueMaximum?: string;
  /**
   * @remarks
   * 最小值。
   * 
   * @example
   * 1
   */
  valueMinimum?: string;
  /**
   * @remarks
   * 属性值类型。
   * 
   * @example
   * STRING
   */
  valueType?: string;
  /**
   * @remarks
   * 值单位。
   * 
   * @example
   * number
   */
  valueUnit?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      valueIncrementStep: 'ValueIncrementStep',
      valueMaximum: 'ValueMaximum',
      valueMinimum: 'ValueMinimum',
      valueType: 'ValueType',
      valueUnit: 'ValueUnit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      valueIncrementStep: 'string',
      valueMaximum: 'string',
      valueMinimum: 'string',
      valueType: 'string',
      valueUnit: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApplicationResponseBodyApplicationActionsActionParams extends $tea.Model {
  /**
   * @remarks
   * 动作参数描述。
   * 
   * @example
   * start
   */
  description?: string;
  /**
   * @remarks
   * 动作参数KEY。
   */
  key?: string;
  /**
   * @remarks
   * 动作参数属性。
   */
  valueAttribute?: GetApplicationResponseBodyApplicationActionsActionParamsValueAttribute;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      key: 'Key',
      valueAttribute: 'ValueAttribute',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      key: 'string',
      valueAttribute: GetApplicationResponseBodyApplicationActionsActionParamsValueAttribute,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApplicationResponseBodyApplicationActions extends $tea.Model {
  /**
   * @remarks
   * 操作名称。
   * 
   * @example
   * START
   */
  actionName?: string;
  /**
   * @remarks
   * 操作参数。
   */
  actionParams?: GetApplicationResponseBodyApplicationActionsActionParams[];
  /**
   * @remarks
   * 命令。
   * 
   * @example
   * START
   */
  command?: string;
  /**
   * @remarks
   * 组件名称。
   * 
   * @example
   * DataNode
   */
  componentName?: string;
  /**
   * @remarks
   * 操作描述。
   * 
   * @example
   * 描述
   */
  description?: string;
  /**
   * @remarks
   * 执行范围。
   * 
   * @example
   * CLUSTER
   */
  runActionScope?: string;
  static names(): { [key: string]: string } {
    return {
      actionName: 'ActionName',
      actionParams: 'ActionParams',
      command: 'Command',
      componentName: 'ComponentName',
      description: 'Description',
      runActionScope: 'RunActionScope',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionName: 'string',
      actionParams: { 'type': 'array', 'itemType': GetApplicationResponseBodyApplicationActionsActionParams },
      command: 'string',
      componentName: 'string',
      description: 'string',
      runActionScope: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetApplicationResponseBodyApplication extends $tea.Model {
  /**
   * @remarks
   * 操作列表。
   */
  actions?: GetApplicationResponseBodyApplicationActions[];
  /**
   * @remarks
   * 应用名称。
   * 
   * @example
   * HDFS
   */
  applicationName?: string;
  /**
   * @remarks
   * 应用操作状态。
   */
  applicationState?: string;
  /**
   * @remarks
   * 应用版本。
   * 
   * @example
   * 2.8.5
   */
  applicationVersion?: string;
  /**
   * @remarks
   * 社区版本。
   * 
   * @example
   * 2.8.5
   */
  communityVersion?: string;
  static names(): { [key: string]: string } {
    return {
      actions: 'Actions',
      applicationName: 'ApplicationName',
      applicationState: 'ApplicationState',
      applicationVersion: 'ApplicationVersion',
      communityVersion: 'CommunityVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actions: { 'type': 'array', 'itemType': GetApplicationResponseBodyApplicationActions },
      applicationName: 'string',
      applicationState: 'string',
      applicationVersion: 'string',
      communityVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAutoScalingActivityResponseBodyScalingActivity extends $tea.Model {
  /**
   * @remarks
   * The ID of the scaling activity.
   * 
   * @example
   * asa-36373b084d6b4b13aa50f4129a9e****
   */
  activityId?: string;
  /**
   * @remarks
   * The instances that correspond to the scaling activity.
   */
  activityResults?: ScalingActivityResult[];
  /**
   * @remarks
   * The status of the scaling activity. Valid values:
   * 
   * *   REJECTED
   * *   SUCCESSFUL
   * *   FAILED
   * *   IN_PROGRESS
   * 
   * @example
   * IN_PROGRESS
   */
  activityState?: string;
  /**
   * @remarks
   * The type of the scaling activity. Valid value:
   * 
   * *   SCALE_OUT
   * *   SCALE_IN
   * 
   * @example
   * SCALE_OUT
   */
  activityType?: string;
  /**
   * @remarks
   * The cluster ID.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The description of the scaling activity.
   * 
   * @example
   * clusterId not exist
   */
  description?: string;
  /**
   * @remarks
   * The time when scaling ended.
   * 
   * @example
   * 1639715634819
   */
  endTime?: number;
  /**
   * @remarks
   * The number of added or removed instances.
   * 
   * @example
   * 10
   */
  expectNum?: number;
  /**
   * @remarks
   * The ID of the node group.
   * 
   * @example
   * ng-869471354ecd****
   */
  nodeGroupId?: string;
  /**
   * @remarks
   * The name of the node group.
   * 
   * @example
   * task-01
   */
  nodeGroupName?: string;
  /**
   * @remarks
   * The operation ID.
   * 
   * @example
   * op-13c37a77c505****
   */
  operationId?: string;
  /**
   * @remarks
   * The description of the scaling rule.
   */
  ruleDetail?: ScalingRule;
  /**
   * @remarks
   * The name of the scaling rule.
   * 
   * @example
   * scaling-out-memory
   */
  ruleName?: string;
  /**
   * @remarks
   * The time when scaling started.
   * 
   * @example
   * 1639714634819
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      activityId: 'ActivityId',
      activityResults: 'ActivityResults',
      activityState: 'ActivityState',
      activityType: 'ActivityType',
      clusterId: 'ClusterId',
      description: 'Description',
      endTime: 'EndTime',
      expectNum: 'ExpectNum',
      nodeGroupId: 'NodeGroupId',
      nodeGroupName: 'NodeGroupName',
      operationId: 'OperationId',
      ruleDetail: 'RuleDetail',
      ruleName: 'RuleName',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activityId: 'string',
      activityResults: { 'type': 'array', 'itemType': ScalingActivityResult },
      activityState: 'string',
      activityType: 'string',
      clusterId: 'string',
      description: 'string',
      endTime: 'number',
      expectNum: 'number',
      nodeGroupId: 'string',
      nodeGroupName: 'string',
      operationId: 'string',
      ruleDetail: ScalingRule,
      ruleName: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAutoScalingPolicyResponseBodyScalingPolicyConstraints extends $tea.Model {
  /**
   * @remarks
   * The maximum number of nodes in the node group. Default value: 2000.
   * 
   * @example
   * 2000
   */
  maxCapacity?: number;
  /**
   * @remarks
   * The minimum number of nodes in the node group. Default value: 0.
   * 
   * @example
   * 0
   */
  minCapacity?: number;
  static names(): { [key: string]: string } {
    return {
      maxCapacity: 'MaxCapacity',
      minCapacity: 'MinCapacity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxCapacity: 'number',
      minCapacity: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAutoScalingPolicyResponseBodyScalingPolicyScalingRules extends $tea.Model {
  /**
   * @remarks
   * The scaling type. Valid values:
   * 
   * *   SCALE_OUT
   * *   SCALE_IN
   * 
   * @example
   * SCALE_OUT
   */
  activityType?: string;
  /**
   * @remarks
   * The adjustment type.
   * 
   * @example
   * CHANGE_IN_CAPACITY
   */
  adjustmentType?: string;
  /**
   * @remarks
   * The adjustment value. The parameter value must be a positive integer, which indicates the number of instances that you want to add or remove.
   * 
   * @example
   * 100
   */
  adjustmentValue?: number;
  /**
   * @remarks
   * The description of load-based scaling.
   */
  metricsTrigger?: MetricsTrigger;
  /**
   * @remarks
   * The name of the auto scaling rule.
   * 
   * @example
   * scaling-out-memory
   */
  ruleName?: string;
  /**
   * @remarks
   * The description of time-based scaling.
   */
  timeTrigger?: TimeTrigger;
  /**
   * @remarks
   * The type of the auto scaling rule. Valid values:
   * 
   * *   TIME_TRIGGER: time-based scaling
   * *   METRICS_TRIGGER: load-based scaling
   * 
   * @example
   * TIME_TRIGGER
   */
  triggerType?: string;
  static names(): { [key: string]: string } {
    return {
      activityType: 'ActivityType',
      adjustmentType: 'AdjustmentType',
      adjustmentValue: 'AdjustmentValue',
      metricsTrigger: 'MetricsTrigger',
      ruleName: 'RuleName',
      timeTrigger: 'TimeTrigger',
      triggerType: 'TriggerType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activityType: 'string',
      adjustmentType: 'string',
      adjustmentValue: 'number',
      metricsTrigger: MetricsTrigger,
      ruleName: 'string',
      timeTrigger: TimeTrigger,
      triggerType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAutoScalingPolicyResponseBodyScalingPolicy extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The maximum and minimum number of nodes in the node group.
   */
  constraints?: GetAutoScalingPolicyResponseBodyScalingPolicyConstraints;
  /**
   * @remarks
   * The ID of the node group.
   * 
   * @example
   * ng-869471354ecd****
   */
  nodeGroupId?: string;
  /**
   * @remarks
   * The ID of the scaling policy.
   * 
   * @example
   * asp-asduwe23znl***
   */
  scalingPolicyId?: string;
  /**
   * @remarks
   * The auto scaling rules.
   */
  scalingRules?: GetAutoScalingPolicyResponseBodyScalingPolicyScalingRules[];
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      constraints: 'Constraints',
      nodeGroupId: 'NodeGroupId',
      scalingPolicyId: 'ScalingPolicyId',
      scalingRules: 'ScalingRules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      constraints: GetAutoScalingPolicyResponseBodyScalingPolicyConstraints,
      nodeGroupId: 'string',
      scalingPolicyId: 'string',
      scalingRules: { 'type': 'array', 'itemType': GetAutoScalingPolicyResponseBodyScalingPolicyScalingRules },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClusterCloneMetaResponseBodyClusterCloneMetaScalingPoliciesConstraints extends $tea.Model {
  /**
   * @remarks
   * The maximum number of nodes in the node group. Default value: 2000.
   * 
   * @example
   * 200
   */
  maxCapacity?: number;
  /**
   * @remarks
   * The minimum number of nodes in the node group. Default value: 0.
   * 
   * @example
   * 50
   */
  minCapacity?: number;
  static names(): { [key: string]: string } {
    return {
      maxCapacity: 'MaxCapacity',
      minCapacity: 'MinCapacity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxCapacity: 'number',
      minCapacity: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClusterCloneMetaResponseBodyClusterCloneMetaScalingPoliciesScalingRules extends $tea.Model {
  /**
   * @remarks
   * The scaling type. This parameter is required. Valid values:
   * 
   * *   SCALE_OUT
   * *   SCALE_IN
   * 
   * @example
   * SCALE_OUT
   */
  activityType?: string;
  /**
   * @remarks
   * The adjustment value of the auto scaling rule. This parameter is required. The parameter value must be a positive integer, which indicates the number of instances to be added or removed.
   * 
   * @example
   * 100
   */
  adjustmentValue?: number;
  /**
   * @remarks
   * The description of load-based scaling.
   */
  metricsTrigger?: MetricsTrigger;
  /**
   * @remarks
   * The name of the auto scaling rule.
   * 
   * @example
   * scaling-out-memory
   */
  ruleName?: string;
  /**
   * @remarks
   * The description of time-based scaling.
   */
  timeTrigger?: TimeTrigger;
  /**
   * @remarks
   * The trigger mode of the auto scaling rule. This parameter is required. Valid values:
   * 
   * *   TIME_TRIGGER: time-based scaling.
   * *   METRICS_TRIGGER: load-based scaling.
   * 
   * @example
   * TIME_TRIGGER
   */
  triggerType?: string;
  static names(): { [key: string]: string } {
    return {
      activityType: 'ActivityType',
      adjustmentValue: 'AdjustmentValue',
      metricsTrigger: 'MetricsTrigger',
      ruleName: 'RuleName',
      timeTrigger: 'TimeTrigger',
      triggerType: 'TriggerType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activityType: 'string',
      adjustmentValue: 'number',
      metricsTrigger: MetricsTrigger,
      ruleName: 'string',
      timeTrigger: TimeTrigger,
      triggerType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClusterCloneMetaResponseBodyClusterCloneMetaScalingPolicies extends $tea.Model {
  /**
   * @remarks
   * The cluster ID.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The maximum and minimum number of nodes in the node group.
   */
  constraints?: GetClusterCloneMetaResponseBodyClusterCloneMetaScalingPoliciesConstraints;
  /**
   * @remarks
   * The node group ID.
   * 
   * @example
   * ng-869471354ecd****
   */
  nodeGroupId?: string;
  /**
   * @remarks
   * The ID of the auto scaling policy.
   * 
   * @example
   * asp-asduwe23znl***
   */
  scalingPolicyId?: string;
  /**
   * @remarks
   * The list of auto scaling rules.
   */
  scalingRules?: GetClusterCloneMetaResponseBodyClusterCloneMetaScalingPoliciesScalingRules[];
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      constraints: 'Constraints',
      nodeGroupId: 'NodeGroupId',
      scalingPolicyId: 'ScalingPolicyId',
      scalingRules: 'ScalingRules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      constraints: GetClusterCloneMetaResponseBodyClusterCloneMetaScalingPoliciesConstraints,
      nodeGroupId: 'string',
      scalingPolicyId: 'string',
      scalingRules: { 'type': 'array', 'itemType': GetClusterCloneMetaResponseBodyClusterCloneMetaScalingPoliciesScalingRules },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClusterCloneMetaResponseBodyClusterCloneMeta extends $tea.Model {
  /**
   * @remarks
   * The modified configuration items.
   */
  applicationConfigs?: ApplicationConfig[];
  /**
   * @remarks
   * The services deployed in the cluster.
   */
  applications?: Application[];
  /**
   * @remarks
   * The bootstrap actions. Number of elements in the array: 1 to 10.
   */
  bootstrapScripts?: Script[];
  /**
   * @remarks
   * The cluster ID.
   * 
   * @example
   * c-b933c5aac7f7****
   */
  clusterId?: string;
  /**
   * @remarks
   * The name of the cluster.
   * 
   * @example
   * emrtest
   */
  clusterName?: string;
  /**
   * @remarks
   * The status of the cluster. Valid values:
   * 
   * *   STARTING
   * *   START_FAILED
   * *   BOOTSTRAPPING
   * *   RUNNING
   * *   TERMINATING
   * *   TERMINATED
   * *   TERMINATED_WITH_ERRORS
   * *   TERMINATE_FAILED
   * 
   * @example
   * RUNNING
   */
  clusterState?: string;
  /**
   * @remarks
   * The cluster type. Valid values:
   * 
   * *   DATALAKE
   * *   OLAP
   * *   DATAFLOW
   * *   DATASERVING
   * *   CUSTOM
   * *   HADOOP
   * 
   * @example
   * DATALAKE
   */
  clusterType?: string;
  /**
   * @remarks
   * The deployment mode of master nodes in the cluster. Valid values:
   * 
   * *   NORMAL: regular mode.
   * *   HA: high availability mode.
   * 
   * @example
   * HA
   */
  deployMode?: string;
  /**
   * @remarks
   * The EMR service role.
   * 
   * @example
   * AliyunEMRDefaultRole
   */
  emrDefaultRole?: string;
  /**
   * @remarks
   * Indicates whether the service configurations of a Hadoop cluster that you made during cluster creation can be cloned. Valid values:
   * 
   * *   False
   * *   True
   */
  existCloneConfig?: boolean;
  /**
   * @remarks
   * The attributes of the node.
   */
  nodeAttributes?: NodeAttributes;
  /**
   * @remarks
   * The node groups. Number of elements in the array: 1 to 100.
   */
  nodeGroups?: NodeGroup[];
  /**
   * @remarks
   * The billing method of the cluster. Valid values:
   * 
   * *   PayAsYouGo
   * *   Subscription
   * 
   * @example
   * PayAsYouGo
   */
  paymentType?: string;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The EMR version.
   * 
   * @example
   * EMR-5.6.0
   */
  releaseVersion?: string;
  /**
   * @remarks
   * The resource group ID.
   * 
   * @example
   * rg-acfmzabjyop****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The auto scaling policies of each node group in the cluster.
   */
  scalingPolicies?: GetClusterCloneMetaResponseBodyClusterCloneMetaScalingPolicies[];
  /**
   * @remarks
   * The security mode of the cluster. Valid values:
   * 
   * *   NORMAL: regular mode. Kerberos is not enabled.
   * *   KERBEROS: Kerberos mode. Kerberos is enabled.
   * 
   * @example
   * NORMAL
   */
  securityMode?: string;
  /**
   * @remarks
   * The subscription configurations.
   */
  subscriptionConfig?: SubscriptionConfig;
  /**
   * @remarks
   * The list of tags.
   */
  tags?: Tag[];
  static names(): { [key: string]: string } {
    return {
      applicationConfigs: 'ApplicationConfigs',
      applications: 'Applications',
      bootstrapScripts: 'BootstrapScripts',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      clusterState: 'ClusterState',
      clusterType: 'ClusterType',
      deployMode: 'DeployMode',
      emrDefaultRole: 'EmrDefaultRole',
      existCloneConfig: 'ExistCloneConfig',
      nodeAttributes: 'NodeAttributes',
      nodeGroups: 'NodeGroups',
      paymentType: 'PaymentType',
      regionId: 'RegionId',
      releaseVersion: 'ReleaseVersion',
      resourceGroupId: 'ResourceGroupId',
      scalingPolicies: 'ScalingPolicies',
      securityMode: 'SecurityMode',
      subscriptionConfig: 'SubscriptionConfig',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationConfigs: { 'type': 'array', 'itemType': ApplicationConfig },
      applications: { 'type': 'array', 'itemType': Application },
      bootstrapScripts: { 'type': 'array', 'itemType': Script },
      clusterId: 'string',
      clusterName: 'string',
      clusterState: 'string',
      clusterType: 'string',
      deployMode: 'string',
      emrDefaultRole: 'string',
      existCloneConfig: 'boolean',
      nodeAttributes: NodeAttributes,
      nodeGroups: { 'type': 'array', 'itemType': NodeGroup },
      paymentType: 'string',
      regionId: 'string',
      releaseVersion: 'string',
      resourceGroupId: 'string',
      scalingPolicies: { 'type': 'array', 'itemType': GetClusterCloneMetaResponseBodyClusterCloneMetaScalingPolicies },
      securityMode: 'string',
      subscriptionConfig: SubscriptionConfig,
      tags: { 'type': 'array', 'itemType': Tag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorApplicationResponseBodyDataAnalysis extends $tea.Model {
  /**
   * @remarks
   * The score of the job.
   * 
   * @example
   * 67
   */
  score?: number;
  /**
   * @remarks
   * The suggestion for running the job.
   */
  suggestion?: string;
  static names(): { [key: string]: string } {
    return {
      score: 'Score',
      suggestion: 'Suggestion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      score: 'number',
      suggestion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorApplicationResponseBodyDataMetricsMemSeconds extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total memory usage over time in seconds
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * memSeconds
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB * Sec
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 12312312
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorApplicationResponseBodyDataMetricsMemUtilization extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of used memory to total available memory
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * memUtilization
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * “”
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.82
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorApplicationResponseBodyDataMetricsVcoreSeconds extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total vcore usage over time in seconds
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * vcoreSeconds
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * VCores * Sec
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 11123
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorApplicationResponseBodyDataMetricsVcoreUtilization extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of used vcore to total available cores
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * vcoreUtilization
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * “”
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 32.1
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorApplicationResponseBodyDataMetrics extends $tea.Model {
  /**
   * @remarks
   * The aggregated amount of memory that is allocated to the job multiplied by the number of seconds the job has been running.
   */
  memSeconds?: GetDoctorApplicationResponseBodyDataMetricsMemSeconds;
  /**
   * @remarks
   * The memory usage.
   */
  memUtilization?: GetDoctorApplicationResponseBodyDataMetricsMemUtilization;
  /**
   * @remarks
   * The aggregated number of vCPUs that are allocated to the job multiplied by the number of seconds the job has been running.
   */
  vcoreSeconds?: GetDoctorApplicationResponseBodyDataMetricsVcoreSeconds;
  /**
   * @remarks
   * The CPU utilization. The meaning is the same as that of the %CPU command in the output of the Linux top command.
   */
  vcoreUtilization?: GetDoctorApplicationResponseBodyDataMetricsVcoreUtilization;
  static names(): { [key: string]: string } {
    return {
      memSeconds: 'MemSeconds',
      memUtilization: 'MemUtilization',
      vcoreSeconds: 'VcoreSeconds',
      vcoreUtilization: 'VcoreUtilization',
    };
  }

  static types(): { [key: string]: any } {
    return {
      memSeconds: GetDoctorApplicationResponseBodyDataMetricsMemSeconds,
      memUtilization: GetDoctorApplicationResponseBodyDataMetricsMemUtilization,
      vcoreSeconds: GetDoctorApplicationResponseBodyDataMetricsVcoreSeconds,
      vcoreUtilization: GetDoctorApplicationResponseBodyDataMetricsVcoreUtilization,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorApplicationResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The job analysis result.
   */
  analysis?: GetDoctorApplicationResponseBodyDataAnalysis;
  /**
   * @remarks
   * The name of the job.
   * 
   * @example
   * CREATE TABLE test...ranks=1 (Stage-1)
   */
  appName?: string;
  /**
   * @remarks
   * The end time of the job. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
   * 
   * @example
   * 1666213200000
   */
  endTime?: number;
  /**
   * @remarks
   * The job IDs. Multiple job IDs are separated with commas (,).
   * 
   * @example
   * null
   */
  ids?: string[];
  /**
   * @remarks
   * The metric information.
   */
  metrics?: GetDoctorApplicationResponseBodyDataMetrics;
  /**
   * @remarks
   * The SQL statement of the job. This parameter is left empty for non-SQL jobs.
   * 
   * @example
   * SELECT id, count(1) FROM test group by id;
   */
  querySql?: string;
  /**
   * @remarks
   * The YARN queue to which the job was submitted.
   * 
   * @example
   * DW
   */
  queue?: string;
  /**
   * @remarks
   * The time when the job was submitted. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
   * 
   * @example
   * 1677465658275
   */
  startTime?: number;
  /**
   * @remarks
   * The type of the compute engine.
   * 
   * @example
   * SPARK
   */
  type?: string;
  /**
   * @remarks
   * The username that is used to submit the job.
   * 
   * @example
   * DW
   */
  user?: string;
  static names(): { [key: string]: string } {
    return {
      analysis: 'Analysis',
      appName: 'AppName',
      endTime: 'EndTime',
      ids: 'Ids',
      metrics: 'Metrics',
      querySql: 'QuerySql',
      queue: 'Queue',
      startTime: 'StartTime',
      type: 'Type',
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      analysis: GetDoctorApplicationResponseBodyDataAnalysis,
      appName: 'string',
      endTime: 'number',
      ids: { 'type': 'array', 'itemType': 'string' },
      metrics: GetDoctorApplicationResponseBodyDataMetrics,
      querySql: 'string',
      queue: 'string',
      startTime: 'number',
      type: 'string',
      user: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorComputeSummaryRequestComponentInfo extends $tea.Model {
  /**
   * @remarks
   * Set the filter condition name based on the value of ComponentType. For example, if you set ComponentType to queue, you can specify a specific queue name to obtain the resource usage of a specific queue.
   * 
   * @example
   * MAPREDUCE
   */
  componentName?: string;
  /**
   * @remarks
   * The resource type for filtering. Valid values:
   * 
   * *   engine: filters results by engine.
   * *   queue: filters results by queue.
   * *   cluster: displays the results at the cluster level.
   * 
   * If you do not specify this parameter, the information at the cluster level is displayed by default.
   * 
   * @example
   * engine
   */
  componentType?: string;
  static names(): { [key: string]: string } {
    return {
      componentName: 'ComponentName',
      componentType: 'ComponentType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      componentName: 'string',
      componentType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorComputeSummaryResponseBodyDataAnalysis extends $tea.Model {
  /**
   * @remarks
   * The total number of healthy jobs.
   * 
   * @example
   * 3
   */
  healthyJobCount?: number;
  /**
   * @remarks
   * The total number of jobs that require attention.
   * 
   * @example
   * 234
   */
  needAttentionJobCount?: number;
  /**
   * @remarks
   * The score for jobs.
   * 
   * @example
   * 73
   */
  score?: number;
  /**
   * @remarks
   * The day-to-day growth rate of the score for jobs.
   * 
   * @example
   * 0.02
   */
  scoreDayGrowthRatio?: number;
  /**
   * @remarks
   * The total number of sub-healthy jobs.
   * 
   * @example
   * 1123
   */
  subHealthyJobCount?: number;
  /**
   * @remarks
   * The total number of unhealthy jobs.
   * 
   * @example
   * 23
   */
  unhealthyJobCount?: number;
  static names(): { [key: string]: string } {
    return {
      healthyJobCount: 'HealthyJobCount',
      needAttentionJobCount: 'NeedAttentionJobCount',
      score: 'Score',
      scoreDayGrowthRatio: 'ScoreDayGrowthRatio',
      subHealthyJobCount: 'SubHealthyJobCount',
      unhealthyJobCount: 'UnhealthyJobCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      healthyJobCount: 'number',
      needAttentionJobCount: 'number',
      score: 'number',
      scoreDayGrowthRatio: 'number',
      subHealthyJobCount: 'number',
      unhealthyJobCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorComputeSummaryResponseBodyDataMetricsMemSeconds extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total memory usage over time in seconds
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * memSeconds
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB * Sec
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 12312312
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorComputeSummaryResponseBodyDataMetricsMemSecondsDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Growth ratio of memory usage in seconds per day
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * memSecondsDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * “”
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.36
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorComputeSummaryResponseBodyDataMetricsMemUtilization extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of used memory to total available memory
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * memUtilization
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.82
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorComputeSummaryResponseBodyDataMetricsReadSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total cumulative size of data read in megabytes (MB)
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * readSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 504888659968
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorComputeSummaryResponseBodyDataMetricsVcoreSeconds extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total vcore usage over time in seconds
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * vcoreSeconds
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * VCores * Sec
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1231412
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorComputeSummaryResponseBodyDataMetricsVcoreSecondsDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Growth ratio of virtual core usage in seconds per day
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * vcoreSecondsDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * “”
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.22
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorComputeSummaryResponseBodyDataMetricsVcoreUtilization extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of used vcore to total available cores
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * vcoreUtilization
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * “”
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 32.1
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorComputeSummaryResponseBodyDataMetricsWriteSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total cumulative size of data written in megabytes (MB)
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * writeSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 6294093393920
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorComputeSummaryResponseBodyDataMetrics extends $tea.Model {
  /**
   * @remarks
   * The total memory consumption over time in seconds.
   */
  memSeconds?: GetDoctorComputeSummaryResponseBodyDataMetricsMemSeconds;
  /**
   * @remarks
   * The day-to-day growth rate of the total memory consumption over time in seconds.
   */
  memSecondsDayGrowthRatio?: GetDoctorComputeSummaryResponseBodyDataMetricsMemSecondsDayGrowthRatio;
  /**
   * @remarks
   * The average memory usage.
   */
  memUtilization?: GetDoctorComputeSummaryResponseBodyDataMetricsMemUtilization;
  /**
   * @remarks
   * The total amount of data read from the file system.
   */
  readSize?: GetDoctorComputeSummaryResponseBodyDataMetricsReadSize;
  /**
   * @remarks
   * The total CPU consumption over time in seconds.
   */
  vcoreSeconds?: GetDoctorComputeSummaryResponseBodyDataMetricsVcoreSeconds;
  /**
   * @remarks
   * The day-to-day growth rate of the total CPU consumption over time in seconds.
   */
  vcoreSecondsDayGrowthRatio?: GetDoctorComputeSummaryResponseBodyDataMetricsVcoreSecondsDayGrowthRatio;
  /**
   * @remarks
   * The average CPU utilization. The meaning is the same as the %CPU parameter in the output of the top command in Linux.
   */
  vcoreUtilization?: GetDoctorComputeSummaryResponseBodyDataMetricsVcoreUtilization;
  /**
   * @remarks
   * The total amount of data written to the file system.
   */
  writeSize?: GetDoctorComputeSummaryResponseBodyDataMetricsWriteSize;
  static names(): { [key: string]: string } {
    return {
      memSeconds: 'MemSeconds',
      memSecondsDayGrowthRatio: 'MemSecondsDayGrowthRatio',
      memUtilization: 'MemUtilization',
      readSize: 'ReadSize',
      vcoreSeconds: 'VcoreSeconds',
      vcoreSecondsDayGrowthRatio: 'VcoreSecondsDayGrowthRatio',
      vcoreUtilization: 'VcoreUtilization',
      writeSize: 'WriteSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      memSeconds: GetDoctorComputeSummaryResponseBodyDataMetricsMemSeconds,
      memSecondsDayGrowthRatio: GetDoctorComputeSummaryResponseBodyDataMetricsMemSecondsDayGrowthRatio,
      memUtilization: GetDoctorComputeSummaryResponseBodyDataMetricsMemUtilization,
      readSize: GetDoctorComputeSummaryResponseBodyDataMetricsReadSize,
      vcoreSeconds: GetDoctorComputeSummaryResponseBodyDataMetricsVcoreSeconds,
      vcoreSecondsDayGrowthRatio: GetDoctorComputeSummaryResponseBodyDataMetricsVcoreSecondsDayGrowthRatio,
      vcoreUtilization: GetDoctorComputeSummaryResponseBodyDataMetricsVcoreUtilization,
      writeSize: GetDoctorComputeSummaryResponseBodyDataMetricsWriteSize,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorComputeSummaryResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The resource analysis information.
   */
  analysis?: GetDoctorComputeSummaryResponseBodyDataAnalysis;
  /**
   * @remarks
   * The metrics.
   */
  metrics?: GetDoctorComputeSummaryResponseBodyDataMetrics;
  static names(): { [key: string]: string } {
    return {
      analysis: 'Analysis',
      metrics: 'Metrics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      analysis: GetDoctorComputeSummaryResponseBodyDataAnalysis,
      metrics: GetDoctorComputeSummaryResponseBodyDataMetrics,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseClusterResponseBodyDataAnalysis extends $tea.Model {
  /**
   * @remarks
   * The overall score of the HBase cluster.
   * 
   * @example
   * 85
   */
  hbaseScore?: number;
  static names(): { [key: string]: string } {
    return {
      hbaseScore: 'HbaseScore',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hbaseScore: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseClusterResponseBodyDataMetricsAvgLoad extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * The average load under normal working conditions
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * avgLoad
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 36.0
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseClusterResponseBodyDataMetricsDailyReadRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of read requests per day
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * dailyReadRequest
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 430
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseClusterResponseBodyDataMetricsDailyWriteRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of write requests per day
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * dailyWriteRequest
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 128
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseClusterResponseBodyDataMetricsMemHeap extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Memory heap usage in megabytes (MB)
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * memHeap
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 240
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseClusterResponseBodyDataMetricsNormalAvgLoad extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * The average load under normal working conditions
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * normalAvgLoad
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 526.4
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseClusterResponseBodyDataMetricsRegionBalance extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * The ability to evenly distribute Regions on different RegionServer nodes
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * regionBalance
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1.0
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseClusterResponseBodyDataMetricsRegionCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of regions count
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * regionCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 161
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseClusterResponseBodyDataMetricsRegionServerCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of region servers count
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * regionServerCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 6
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseClusterResponseBodyDataMetricsStoreFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of store files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * storeFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 298
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseClusterResponseBodyDataMetricsTableCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of tables
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tableCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 10
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseClusterResponseBodyDataMetricsTotalDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total data size in megabytes (MB)
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 256
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseClusterResponseBodyDataMetricsTotalReadRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total number of read requests
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalReadRequest
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 430
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseClusterResponseBodyDataMetricsTotalRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total number of requests
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalRequest
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 576
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseClusterResponseBodyDataMetricsTotalWriteRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total number of write requests
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalWriteRequest
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 520
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseClusterResponseBodyDataMetrics extends $tea.Model {
  /**
   * @remarks
   * The average load.
   */
  avgLoad?: GetDoctorHBaseClusterResponseBodyDataMetricsAvgLoad;
  /**
   * @remarks
   * The number of read requests in a day.
   */
  dailyReadRequest?: GetDoctorHBaseClusterResponseBodyDataMetricsDailyReadRequest;
  /**
   * @remarks
   * The number of write requests in a day.
   */
  dailyWriteRequest?: GetDoctorHBaseClusterResponseBodyDataMetricsDailyWriteRequest;
  /**
   * @remarks
   * The memory size.
   */
  memHeap?: GetDoctorHBaseClusterResponseBodyDataMetricsMemHeap;
  /**
   * @remarks
   * The normal average load.
   */
  normalAvgLoad?: GetDoctorHBaseClusterResponseBodyDataMetricsNormalAvgLoad;
  /**
   * @remarks
   * The region balance degree.
   */
  regionBalance?: GetDoctorHBaseClusterResponseBodyDataMetricsRegionBalance;
  /**
   * @remarks
   * The number of regions.
   */
  regionCount?: GetDoctorHBaseClusterResponseBodyDataMetricsRegionCount;
  /**
   * @remarks
   * The number of region servers.
   */
  regionServerCount?: GetDoctorHBaseClusterResponseBodyDataMetricsRegionServerCount;
  /**
   * @remarks
   * The number of StoreFiles.
   */
  storeFileCount?: GetDoctorHBaseClusterResponseBodyDataMetricsStoreFileCount;
  /**
   * @remarks
   * The number of tables.
   */
  tableCount?: GetDoctorHBaseClusterResponseBodyDataMetricsTableCount;
  /**
   * @remarks
   * The size of the cluster.
   */
  totalDataSize?: GetDoctorHBaseClusterResponseBodyDataMetricsTotalDataSize;
  /**
   * @remarks
   * The total number of read requests.
   */
  totalReadRequest?: GetDoctorHBaseClusterResponseBodyDataMetricsTotalReadRequest;
  /**
   * @remarks
   * The total number of requests in the cluster.
   */
  totalRequest?: GetDoctorHBaseClusterResponseBodyDataMetricsTotalRequest;
  /**
   * @remarks
   * The total number of write requests.
   */
  totalWriteRequest?: GetDoctorHBaseClusterResponseBodyDataMetricsTotalWriteRequest;
  static names(): { [key: string]: string } {
    return {
      avgLoad: 'AvgLoad',
      dailyReadRequest: 'DailyReadRequest',
      dailyWriteRequest: 'DailyWriteRequest',
      memHeap: 'MemHeap',
      normalAvgLoad: 'NormalAvgLoad',
      regionBalance: 'RegionBalance',
      regionCount: 'RegionCount',
      regionServerCount: 'RegionServerCount',
      storeFileCount: 'StoreFileCount',
      tableCount: 'TableCount',
      totalDataSize: 'TotalDataSize',
      totalReadRequest: 'TotalReadRequest',
      totalRequest: 'TotalRequest',
      totalWriteRequest: 'TotalWriteRequest',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgLoad: GetDoctorHBaseClusterResponseBodyDataMetricsAvgLoad,
      dailyReadRequest: GetDoctorHBaseClusterResponseBodyDataMetricsDailyReadRequest,
      dailyWriteRequest: GetDoctorHBaseClusterResponseBodyDataMetricsDailyWriteRequest,
      memHeap: GetDoctorHBaseClusterResponseBodyDataMetricsMemHeap,
      normalAvgLoad: GetDoctorHBaseClusterResponseBodyDataMetricsNormalAvgLoad,
      regionBalance: GetDoctorHBaseClusterResponseBodyDataMetricsRegionBalance,
      regionCount: GetDoctorHBaseClusterResponseBodyDataMetricsRegionCount,
      regionServerCount: GetDoctorHBaseClusterResponseBodyDataMetricsRegionServerCount,
      storeFileCount: GetDoctorHBaseClusterResponseBodyDataMetricsStoreFileCount,
      tableCount: GetDoctorHBaseClusterResponseBodyDataMetricsTableCount,
      totalDataSize: GetDoctorHBaseClusterResponseBodyDataMetricsTotalDataSize,
      totalReadRequest: GetDoctorHBaseClusterResponseBodyDataMetricsTotalReadRequest,
      totalRequest: GetDoctorHBaseClusterResponseBodyDataMetricsTotalRequest,
      totalWriteRequest: GetDoctorHBaseClusterResponseBodyDataMetricsTotalWriteRequest,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseClusterResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The analysis result.
   */
  analysis?: GetDoctorHBaseClusterResponseBodyDataAnalysis;
  /**
   * @remarks
   * The metric information.
   */
  metrics?: GetDoctorHBaseClusterResponseBodyDataMetrics;
  static names(): { [key: string]: string } {
    return {
      analysis: 'Analysis',
      metrics: 'Metrics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      analysis: GetDoctorHBaseClusterResponseBodyDataAnalysis,
      metrics: GetDoctorHBaseClusterResponseBodyDataMetrics,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseRegionResponseBodyDataMetricsDailyReadRequest extends $tea.Model {
  /**
   * @example
   * Number of read requests per day
   */
  description?: string;
  /**
   * @example
   * dailyReadRequest
   */
  name?: string;
  /**
   * @example
   * ""
   */
  unit?: string;
  /**
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseRegionResponseBodyDataMetricsDailyWriteRequest extends $tea.Model {
  /**
   * @example
   * Number of write requests per day
   */
  description?: string;
  /**
   * @example
   * dailyWriteRequest
   */
  name?: string;
  /**
   * @example
   * ""
   */
  unit?: string;
  /**
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseRegionResponseBodyDataMetricsStoreFileCount extends $tea.Model {
  /**
   * @example
   * Number of store file
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * storeFileCount
   */
  name?: string;
  /**
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 100
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseRegionResponseBodyDataMetricsTotalReadRequest extends $tea.Model {
  /**
   * @example
   * Total read request
   */
  description?: string;
  /**
   * @example
   * totalReadRequest
   */
  name?: string;
  /**
   * @example
   * ""
   */
  unit?: string;
  /**
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseRegionResponseBodyDataMetricsTotalWriteRequest extends $tea.Model {
  /**
   * @example
   * Total Write Request
   */
  description?: string;
  /**
   * @example
   * totalWriteRequest
   */
  name?: string;
  /**
   * @example
   * ""
   */
  unit?: string;
  /**
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseRegionResponseBodyDataMetrics extends $tea.Model {
  dailyReadRequest?: GetDoctorHBaseRegionResponseBodyDataMetricsDailyReadRequest;
  dailyWriteRequest?: GetDoctorHBaseRegionResponseBodyDataMetricsDailyWriteRequest;
  /**
   * @remarks
   * The number of StoreFiles.
   */
  storeFileCount?: GetDoctorHBaseRegionResponseBodyDataMetricsStoreFileCount;
  totalReadRequest?: GetDoctorHBaseRegionResponseBodyDataMetricsTotalReadRequest;
  totalWriteRequest?: GetDoctorHBaseRegionResponseBodyDataMetricsTotalWriteRequest;
  static names(): { [key: string]: string } {
    return {
      dailyReadRequest: 'DailyReadRequest',
      dailyWriteRequest: 'DailyWriteRequest',
      storeFileCount: 'StoreFileCount',
      totalReadRequest: 'TotalReadRequest',
      totalWriteRequest: 'TotalWriteRequest',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dailyReadRequest: GetDoctorHBaseRegionResponseBodyDataMetricsDailyReadRequest,
      dailyWriteRequest: GetDoctorHBaseRegionResponseBodyDataMetricsDailyWriteRequest,
      storeFileCount: GetDoctorHBaseRegionResponseBodyDataMetricsStoreFileCount,
      totalReadRequest: GetDoctorHBaseRegionResponseBodyDataMetricsTotalReadRequest,
      totalWriteRequest: GetDoctorHBaseRegionResponseBodyDataMetricsTotalWriteRequest,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseRegionResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The metric information.
   */
  metrics?: GetDoctorHBaseRegionResponseBodyDataMetrics;
  /**
   * @example
   * emr-worker-2.cluster-20****
   */
  regionServerHost?: string;
  /**
   * @example
   * tb_item
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      metrics: 'Metrics',
      regionServerHost: 'RegionServerHost',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      metrics: GetDoctorHBaseRegionResponseBodyDataMetrics,
      regionServerHost: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseRegionServerResponseBodyDataMetricsAvgGc extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * The efficiency of garbage collection in the system
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * avgGc
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 42.3
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseRegionServerResponseBodyDataMetricsCacheRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of the BlockCache memory size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * cacheRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 95.3
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyReadRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of read requests per day
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * dailyReadRequest
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyReadRequestDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * The growth rate of daily read request quantity.
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * dailyReadRequestDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1.0
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyWriteRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of write requests per day
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * dailyWriteRequest
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * The growth rate of daily write request quantity.
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * dailyWriteRequestDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1.0
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseRegionServerResponseBodyDataMetricsRegionCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of regions count
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * regionCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 15
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalReadRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total number of read requests
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalReadRequest
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total number of requests
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalRequest
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalWriteRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total number of write requests
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalWriteRequest
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseRegionServerResponseBodyDataMetrics extends $tea.Model {
  /**
   * @remarks
   * The average garbage collection (GC) duration.
   */
  avgGc?: GetDoctorHBaseRegionServerResponseBodyDataMetricsAvgGc;
  /**
   * @remarks
   * The cache hit ratio.
   */
  cacheRatio?: GetDoctorHBaseRegionServerResponseBodyDataMetricsCacheRatio;
  /**
   * @remarks
   * The number of daily read requests.
   */
  dailyReadRequest?: GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyReadRequest;
  /**
   * @remarks
   * The day-to-day increment rate of the number of daily read requests.
   */
  dailyReadRequestDayGrowthRatio?: GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyReadRequestDayGrowthRatio;
  /**
   * @remarks
   * The number of daily write requests.
   */
  dailyWriteRequest?: GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyWriteRequest;
  /**
   * @remarks
   * The day-to-day increment rate of the number of daily write requests.
   */
  dailyWriteRequestDayGrowthRatio?: GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio;
  /**
   * @remarks
   * The number of regions.
   */
  regionCount?: GetDoctorHBaseRegionServerResponseBodyDataMetricsRegionCount;
  /**
   * @remarks
   * The cumulative number of read requests.
   */
  totalReadRequest?: GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalReadRequest;
  /**
   * @remarks
   * The cumulative number of total requests.
   */
  totalRequest?: GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalRequest;
  /**
   * @remarks
   * The cumulative number of write requests.
   */
  totalWriteRequest?: GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalWriteRequest;
  static names(): { [key: string]: string } {
    return {
      avgGc: 'AvgGc',
      cacheRatio: 'CacheRatio',
      dailyReadRequest: 'DailyReadRequest',
      dailyReadRequestDayGrowthRatio: 'DailyReadRequestDayGrowthRatio',
      dailyWriteRequest: 'DailyWriteRequest',
      dailyWriteRequestDayGrowthRatio: 'DailyWriteRequestDayGrowthRatio',
      regionCount: 'RegionCount',
      totalReadRequest: 'TotalReadRequest',
      totalRequest: 'TotalRequest',
      totalWriteRequest: 'TotalWriteRequest',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgGc: GetDoctorHBaseRegionServerResponseBodyDataMetricsAvgGc,
      cacheRatio: GetDoctorHBaseRegionServerResponseBodyDataMetricsCacheRatio,
      dailyReadRequest: GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyReadRequest,
      dailyReadRequestDayGrowthRatio: GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyReadRequestDayGrowthRatio,
      dailyWriteRequest: GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyWriteRequest,
      dailyWriteRequestDayGrowthRatio: GetDoctorHBaseRegionServerResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio,
      regionCount: GetDoctorHBaseRegionServerResponseBodyDataMetricsRegionCount,
      totalReadRequest: GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalReadRequest,
      totalRequest: GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalRequest,
      totalWriteRequest: GetDoctorHBaseRegionServerResponseBodyDataMetricsTotalWriteRequest,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseRegionServerResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The metric information.
   */
  metrics?: GetDoctorHBaseRegionServerResponseBodyDataMetrics;
  static names(): { [key: string]: string } {
    return {
      metrics: 'Metrics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      metrics: GetDoctorHBaseRegionServerResponseBodyDataMetrics,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBodyDataAnalysis extends $tea.Model {
  /**
   * @example
   * null
   */
  readRequestHotspotRegionList?: string[];
  /**
   * @remarks
   * The description of read imbalance.
   */
  readRequestUnbalanceSuggestion?: string;
  /**
   * @example
   * null
   */
  requestHotspotRegionList?: string[];
  /**
   * @remarks
   * The description of read/write imbalance.
   */
  requestUnbalanceSuggestion?: string;
  /**
   * @example
   * 85
   */
  tableScore?: number;
  /**
   * @example
   * null
   */
  writeRequestHotspotRegionList?: string[];
  /**
   * @remarks
   * The description of write imbalance.
   */
  writeRequestUnbalanceSuggestion?: string;
  static names(): { [key: string]: string } {
    return {
      readRequestHotspotRegionList: 'ReadRequestHotspotRegionList',
      readRequestUnbalanceSuggestion: 'ReadRequestUnbalanceSuggestion',
      requestHotspotRegionList: 'RequestHotspotRegionList',
      requestUnbalanceSuggestion: 'RequestUnbalanceSuggestion',
      tableScore: 'TableScore',
      writeRequestHotspotRegionList: 'WriteRequestHotspotRegionList',
      writeRequestUnbalanceSuggestion: 'WriteRequestUnbalanceSuggestion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      readRequestHotspotRegionList: { 'type': 'array', 'itemType': 'string' },
      readRequestUnbalanceSuggestion: 'string',
      requestHotspotRegionList: { 'type': 'array', 'itemType': 'string' },
      requestUnbalanceSuggestion: 'string',
      tableScore: 'number',
      writeRequestHotspotRegionList: { 'type': 'array', 'itemType': 'string' },
      writeRequestUnbalanceSuggestion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBodyDataMetricsColdAccessDay extends $tea.Model {
  /**
   * @example
   * Cold access day
   */
  description?: string;
  /**
   * @example
   * coldAccessDay
   */
  name?: string;
  /**
   * @example
   * day
   */
  unit?: string;
  /**
   * @example
   * 3
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBodyDataMetricsColdConfigDay extends $tea.Model {
  /**
   * @example
   * Cold config day
   */
  description?: string;
  /**
   * @example
   * coldConfigDay
   */
  name?: string;
  /**
   * @example
   * day
   */
  unit?: string;
  /**
   * @example
   * 10
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBodyDataMetricsColdDataSize extends $tea.Model {
  /**
   * @example
   * Size of the cold data size
   */
  description?: string;
  /**
   * @example
   * coldDataSize
   */
  name?: string;
  /**
   * @example
   * ""
   */
  unit?: string;
  /**
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBodyDataMetricsDailyReadRequest extends $tea.Model {
  /**
   * @example
   * test-update
   */
  description?: string;
  /**
   * @example
   * dailyReadRequest
   */
  name?: string;
  /**
   * @example
   * ""
   */
  unit?: string;
  /**
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBodyDataMetricsDailyReadRequestDayGrowthRatio extends $tea.Model {
  /**
   * @example
   * Day growth ratio of table size
   */
  description?: string;
  /**
   * @example
   * dailyReadRequestDayGrowthRatio
   */
  name?: string;
  /**
   * @example
   * ""
   */
  unit?: string;
  /**
   * @example
   * 1.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBodyDataMetricsDailyWriteRequest extends $tea.Model {
  /**
   * @example
   * Number of write requests per day
   */
  description?: string;
  /**
   * @example
   * dailyWriteRequest
   */
  name?: string;
  /**
   * @example
   * ""
   */
  unit?: string;
  /**
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio extends $tea.Model {
  /**
   * @example
   * The balance of distributing requests
   */
  description?: string;
  /**
   * @example
   * dailyWriteRequestDayGrowthRatio
   */
  name?: string;
  /**
   * @example
   * ""
   */
  unit?: string;
  /**
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBodyDataMetricsFreezeConfigDay extends $tea.Model {
  /**
   * @example
   * Freeze config day
   */
  description?: string;
  /**
   * @example
   * freezeConfigDay
   */
  name?: string;
  /**
   * @example
   * day
   */
  unit?: string;
  /**
   * @example
   * 10
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBodyDataMetricsFreezeDataSize extends $tea.Model {
  /**
   * @example
   * Size of the freeze data size
   */
  description?: string;
  /**
   * @example
   * freezeDataSize
   */
  name?: string;
  /**
   * @example
   * MB
   */
  unit?: string;
  /**
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBodyDataMetricsHotDataSize extends $tea.Model {
  /**
   * @example
   * Size of the hot data size
   */
  description?: string;
  /**
   * @example
   * hotDataSize
   */
  name?: string;
  /**
   * @example
   * MB
   */
  unit?: string;
  /**
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBodyDataMetricsLocality extends $tea.Model {
  /**
   * @example
   * The locality of data
   */
  description?: string;
  /**
   * @example
   * locality
   */
  name?: string;
  /**
   * @example
   * ""
   */
  unit?: string;
  /**
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBodyDataMetricsReadRequestBalance extends $tea.Model {
  /**
   * @example
   * The balance of distributing read requests
   */
  description?: string;
  /**
   * @example
   * readRequestBalance
   */
  name?: string;
  /**
   * @example
   * ""
   */
  unit?: string;
  /**
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBodyDataMetricsRegionBalance extends $tea.Model {
  /**
   * @example
   * The ability to evenly distribute Regions on different RegionServer nodes
   */
  description?: string;
  /**
   * @example
   * regionBalance
   */
  name?: string;
  /**
   * @example
   * ""
   */
  unit?: string;
  /**
   * @example
   * 1.0
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBodyDataMetricsRegionCount extends $tea.Model {
  /**
   * @example
   * Number of regions count
   */
  description?: string;
  /**
   * @example
   * regionCount
   */
  name?: string;
  /**
   * @example
   * ""
   */
  unit?: string;
  /**
   * @example
   * 10
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBodyDataMetricsRegionCountDayGrowthRatio extends $tea.Model {
  /**
   * @example
   * Day growth ratio of region count
   */
  description?: string;
  /**
   * @example
   * regionCountDayGrowthRatio
   */
  name?: string;
  /**
   * @example
   * ""
   */
  unit?: string;
  /**
   * @example
   * 0.8
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBodyDataMetricsRegionServerCount extends $tea.Model {
  /**
   * @example
   * Number of region servers count
   */
  description?: string;
  /**
   * @example
   * regionServerCount
   */
  name?: string;
  /**
   * @example
   * “”
   */
  unit?: string;
  /**
   * @example
   * 10
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBodyDataMetricsRequestBalance extends $tea.Model {
  /**
   * @example
   * The balance of distributing requests
   */
  description?: string;
  /**
   * @example
   * requestBalance
   */
  name?: string;
  /**
   * @example
   * ""
   */
  unit?: string;
  /**
   * @example
   * 1.0
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBodyDataMetricsStoreFileCount extends $tea.Model {
  /**
   * @example
   * Number of store files
   */
  description?: string;
  /**
   * @example
   * storeFileCount
   */
  name?: string;
  /**
   * @example
   * ""
   */
  unit?: string;
  /**
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBodyDataMetricsStoreFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @example
   * Day growth ratio of store file count
   */
  description?: string;
  /**
   * @example
   * storeFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @example
   * ""
   */
  unit?: string;
  /**
   * @example
   * 1.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBodyDataMetricsTableSize extends $tea.Model {
  /**
   * @example
   * Size of the table
   */
  description?: string;
  /**
   * @example
   * tableSize
   */
  name?: string;
  /**
   * @example
   * ""
   */
  unit?: string;
  /**
   * @example
   * tb_item
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBodyDataMetricsTableSizeDayGrowthRatio extends $tea.Model {
  /**
   * @example
   * Day growth ratio of table size
   */
  description?: string;
  /**
   * @example
   * tableSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @example
   * ""
   */
  unit?: string;
  /**
   * @example
   * 1.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBodyDataMetricsWarmConfigDay extends $tea.Model {
  /**
   * @example
   * Size of the warm data size
   */
  description?: string;
  /**
   * @example
   * warmConfigDay
   */
  name?: string;
  /**
   * @example
   * MB
   */
  unit?: string;
  /**
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBodyDataMetricsWarmDataSize extends $tea.Model {
  /**
   * @example
   * Size of the warm data size
   */
  description?: string;
  /**
   * @example
   * warmDataSize
   */
  name?: string;
  /**
   * @example
   * MB
   */
  unit?: string;
  /**
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBodyDataMetricsWriteRequestBalance extends $tea.Model {
  /**
   * @example
   * The balance of distributing write requests
   */
  description?: string;
  /**
   * @example
   * writeRequestBalance
   */
  name?: string;
  /**
   * @example
   * ""
   */
  unit?: string;
  /**
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBodyDataMetrics extends $tea.Model {
  coldAccessDay?: GetDoctorHBaseTableResponseBodyDataMetricsColdAccessDay;
  coldConfigDay?: GetDoctorHBaseTableResponseBodyDataMetricsColdConfigDay;
  coldDataSize?: GetDoctorHBaseTableResponseBodyDataMetricsColdDataSize;
  dailyReadRequest?: GetDoctorHBaseTableResponseBodyDataMetricsDailyReadRequest;
  dailyReadRequestDayGrowthRatio?: GetDoctorHBaseTableResponseBodyDataMetricsDailyReadRequestDayGrowthRatio;
  dailyWriteRequest?: GetDoctorHBaseTableResponseBodyDataMetricsDailyWriteRequest;
  dailyWriteRequestDayGrowthRatio?: GetDoctorHBaseTableResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio;
  freezeConfigDay?: GetDoctorHBaseTableResponseBodyDataMetricsFreezeConfigDay;
  freezeDataSize?: GetDoctorHBaseTableResponseBodyDataMetricsFreezeDataSize;
  hotDataSize?: GetDoctorHBaseTableResponseBodyDataMetricsHotDataSize;
  locality?: GetDoctorHBaseTableResponseBodyDataMetricsLocality;
  readRequestBalance?: GetDoctorHBaseTableResponseBodyDataMetricsReadRequestBalance;
  regionBalance?: GetDoctorHBaseTableResponseBodyDataMetricsRegionBalance;
  regionCount?: GetDoctorHBaseTableResponseBodyDataMetricsRegionCount;
  regionCountDayGrowthRatio?: GetDoctorHBaseTableResponseBodyDataMetricsRegionCountDayGrowthRatio;
  regionServerCount?: GetDoctorHBaseTableResponseBodyDataMetricsRegionServerCount;
  requestBalance?: GetDoctorHBaseTableResponseBodyDataMetricsRequestBalance;
  storeFileCount?: GetDoctorHBaseTableResponseBodyDataMetricsStoreFileCount;
  storeFileCountDayGrowthRatio?: GetDoctorHBaseTableResponseBodyDataMetricsStoreFileCountDayGrowthRatio;
  tableSize?: GetDoctorHBaseTableResponseBodyDataMetricsTableSize;
  tableSizeDayGrowthRatio?: GetDoctorHBaseTableResponseBodyDataMetricsTableSizeDayGrowthRatio;
  warmConfigDay?: GetDoctorHBaseTableResponseBodyDataMetricsWarmConfigDay;
  warmDataSize?: GetDoctorHBaseTableResponseBodyDataMetricsWarmDataSize;
  writeRequestBalance?: GetDoctorHBaseTableResponseBodyDataMetricsWriteRequestBalance;
  static names(): { [key: string]: string } {
    return {
      coldAccessDay: 'ColdAccessDay',
      coldConfigDay: 'ColdConfigDay',
      coldDataSize: 'ColdDataSize',
      dailyReadRequest: 'DailyReadRequest',
      dailyReadRequestDayGrowthRatio: 'DailyReadRequestDayGrowthRatio',
      dailyWriteRequest: 'DailyWriteRequest',
      dailyWriteRequestDayGrowthRatio: 'DailyWriteRequestDayGrowthRatio',
      freezeConfigDay: 'FreezeConfigDay',
      freezeDataSize: 'FreezeDataSize',
      hotDataSize: 'HotDataSize',
      locality: 'Locality',
      readRequestBalance: 'ReadRequestBalance',
      regionBalance: 'RegionBalance',
      regionCount: 'RegionCount',
      regionCountDayGrowthRatio: 'RegionCountDayGrowthRatio',
      regionServerCount: 'RegionServerCount',
      requestBalance: 'RequestBalance',
      storeFileCount: 'StoreFileCount',
      storeFileCountDayGrowthRatio: 'StoreFileCountDayGrowthRatio',
      tableSize: 'TableSize',
      tableSizeDayGrowthRatio: 'TableSizeDayGrowthRatio',
      warmConfigDay: 'WarmConfigDay',
      warmDataSize: 'WarmDataSize',
      writeRequestBalance: 'WriteRequestBalance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      coldAccessDay: GetDoctorHBaseTableResponseBodyDataMetricsColdAccessDay,
      coldConfigDay: GetDoctorHBaseTableResponseBodyDataMetricsColdConfigDay,
      coldDataSize: GetDoctorHBaseTableResponseBodyDataMetricsColdDataSize,
      dailyReadRequest: GetDoctorHBaseTableResponseBodyDataMetricsDailyReadRequest,
      dailyReadRequestDayGrowthRatio: GetDoctorHBaseTableResponseBodyDataMetricsDailyReadRequestDayGrowthRatio,
      dailyWriteRequest: GetDoctorHBaseTableResponseBodyDataMetricsDailyWriteRequest,
      dailyWriteRequestDayGrowthRatio: GetDoctorHBaseTableResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio,
      freezeConfigDay: GetDoctorHBaseTableResponseBodyDataMetricsFreezeConfigDay,
      freezeDataSize: GetDoctorHBaseTableResponseBodyDataMetricsFreezeDataSize,
      hotDataSize: GetDoctorHBaseTableResponseBodyDataMetricsHotDataSize,
      locality: GetDoctorHBaseTableResponseBodyDataMetricsLocality,
      readRequestBalance: GetDoctorHBaseTableResponseBodyDataMetricsReadRequestBalance,
      regionBalance: GetDoctorHBaseTableResponseBodyDataMetricsRegionBalance,
      regionCount: GetDoctorHBaseTableResponseBodyDataMetricsRegionCount,
      regionCountDayGrowthRatio: GetDoctorHBaseTableResponseBodyDataMetricsRegionCountDayGrowthRatio,
      regionServerCount: GetDoctorHBaseTableResponseBodyDataMetricsRegionServerCount,
      requestBalance: GetDoctorHBaseTableResponseBodyDataMetricsRequestBalance,
      storeFileCount: GetDoctorHBaseTableResponseBodyDataMetricsStoreFileCount,
      storeFileCountDayGrowthRatio: GetDoctorHBaseTableResponseBodyDataMetricsStoreFileCountDayGrowthRatio,
      tableSize: GetDoctorHBaseTableResponseBodyDataMetricsTableSize,
      tableSizeDayGrowthRatio: GetDoctorHBaseTableResponseBodyDataMetricsTableSizeDayGrowthRatio,
      warmConfigDay: GetDoctorHBaseTableResponseBodyDataMetricsWarmConfigDay,
      warmDataSize: GetDoctorHBaseTableResponseBodyDataMetricsWarmDataSize,
      writeRequestBalance: GetDoctorHBaseTableResponseBodyDataMetricsWriteRequestBalance,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHBaseTableResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The diagnosis result.
   */
  analysis?: GetDoctorHBaseTableResponseBodyDataAnalysis;
  metrics?: GetDoctorHBaseTableResponseBodyDataMetrics;
  static names(): { [key: string]: string } {
    return {
      analysis: 'Analysis',
      metrics: 'Metrics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      analysis: GetDoctorHBaseTableResponseBodyDataAnalysis,
      metrics: GetDoctorHBaseTableResponseBodyDataMetrics,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataAnalysis extends $tea.Model {
  /**
   * @remarks
   * The overall score of HDFS storage resources.
   * 
   * @example
   * 55
   */
  hdfsScore?: number;
  static names(): { [key: string]: string } {
    return {
      hdfsScore: 'HdfsScore',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hdfsScore: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsColdDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of cold data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * -182636577752
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsColdDataRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Cold data ratio
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.01
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsColdDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Size of the cold data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 5570958082267
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsColdDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of cold data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * -0.03
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of empty files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * emptyFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 15595897
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of empty files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * emptyFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.005
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of empty files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * emptyFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 114
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of empty files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * emptyFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.3
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of freeze data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * -167683929450
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of freeze data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.12
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Size of the freeze data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1231312431
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of freeze data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * -0.09
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsHotDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of hot data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 123154
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsHotDataRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Hot data ratio
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.22
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsHotDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Size of the hot data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 6701531944206
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsHotDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of hot data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.1114
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of large files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * largeFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 123
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of large files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * largeFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.39
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of large files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * largeFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * “”
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 2
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of large files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * largeFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.22
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of medium files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * mediumFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 234
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of medium files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * mediumFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.19
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of medium files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * mediumFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 176
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of medium files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * mediumFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.21
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of small files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * smallFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 12345
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of small files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * smallFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.02
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of small files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * smallFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 12321
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of small files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * smallFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.19
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of tiny files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tinyFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 232131
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of tiny files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tinyFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.003
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of tiny files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tinyFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * -123
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of tiny files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tinyFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.19
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of total data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 256482228248
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total data size in megabytes (MB)
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 62086342083623
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of total data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.14
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of total files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 51683279
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of total files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.02
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of total files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * “”
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 27809
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of warm data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * -64806998319
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of warm data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmDataRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.12
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Size of the warm data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 4062349775577
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of warm data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * -0.015
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyDataMetrics extends $tea.Model {
  /**
   * @remarks
   * The daily increment of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in 90 days.
   */
  coldDataDayGrowthSize?: GetDoctorHDFSClusterResponseBodyDataMetricsColdDataDayGrowthSize;
  /**
   * @remarks
   * The proportion of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in 90 days.
   */
  coldDataRatio?: GetDoctorHDFSClusterResponseBodyDataMetricsColdDataRatio;
  /**
   * @remarks
   * The amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in 90 days.
   */
  coldDataSize?: GetDoctorHDFSClusterResponseBodyDataMetricsColdDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in 90 days.
   */
  coldDataSizeDayGrowthRatio?: GetDoctorHDFSClusterResponseBodyDataMetricsColdDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The number of empty files. Empty files are those with a size of 0 MB.
   */
  emptyFileCount?: GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of empty files. Empty files are those with a size of 0 MB.
   */
  emptyFileCountDayGrowthRatio?: GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of empty files. Empty files are those with a size of 0 MB.
   */
  emptyFileDayGrowthCount?: GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of empty files. Empty files are those with a size of 0 MB.
   */
  emptyFileRatio?: GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileRatio;
  /**
   * @remarks
   * The daily increment of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   */
  freezeDataDayGrowthSize?: GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataDayGrowthSize;
  /**
   * @remarks
   * The proportion of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   */
  freezeDataRatio?: GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataRatio;
  /**
   * @remarks
   * The amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   */
  freezeDataSize?: GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   */
  freezeDataSizeDayGrowthRatio?: GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the amount of hot data. Hot data refers to data that is accessed in recent seven days.
   */
  hotDataDayGrowthSize?: GetDoctorHDFSClusterResponseBodyDataMetricsHotDataDayGrowthSize;
  /**
   * @remarks
   * The proportion of hot data. Hot data refers to data that is accessed in recent seven days.
   */
  hotDataRatio?: GetDoctorHDFSClusterResponseBodyDataMetricsHotDataRatio;
  /**
   * @remarks
   * The amount of hot data. Hot data refers to data that is accessed in recent seven days.
   */
  hotDataSize?: GetDoctorHDFSClusterResponseBodyDataMetricsHotDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of hot data. Hot data refers to data that is accessed in recent seven days.
   */
  hotDataSizeDayGrowthRatio?: GetDoctorHDFSClusterResponseBodyDataMetricsHotDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The number of large files. Large files are those with a size greater than 1 GB.
   */
  largeFileCount?: GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of large files. Large files are those with a size greater than 1 GB.
   */
  largeFileCountDayGrowthRatio?: GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of large files. Large files are those with a size greater than 1 GB.
   */
  largeFileDayGrowthCount?: GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of large files. Large files are those with a size greater than 1 GB.
   */
  largeFileRatio?: GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileRatio;
  /**
   * @remarks
   * The number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   */
  mediumFileCount?: GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   */
  mediumFileCountDayGrowthRatio?: GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   */
  mediumFileDayGrowthCount?: GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   */
  mediumFileRatio?: GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileRatio;
  /**
   * @remarks
   * The number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   */
  smallFileCount?: GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   */
  smallFileCountDayGrowthRatio?: GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   */
  smallFileDayGrowthCount?: GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   */
  smallFileRatio?: GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileRatio;
  /**
   * @remarks
   * The number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   */
  tinyFileCount?: GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   */
  tinyFileCountDayGrowthRatio?: GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   */
  tinyFileDayGrowthCount?: GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   */
  tinyFileRatio?: GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileRatio;
  /**
   * @remarks
   * The daily incremental of the total data volume.
   */
  totalDataDayGrowthSize?: GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataDayGrowthSize;
  /**
   * @remarks
   * The total amount of data.
   */
  totalDataSize?: GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the total data volume.
   */
  totalDataSizeDayGrowthRatio?: GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The total number of files.
   */
  totalFileCount?: GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the total number of files.
   */
  totalFileCountDayGrowthRatio?: GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the total number of files.
   */
  totalFileDayGrowthCount?: GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileDayGrowthCount;
  /**
   * @remarks
   * The daily increment of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in 30 days.
   */
  warmDataDayGrowthSize?: GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataDayGrowthSize;
  /**
   * @remarks
   * The proportion of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in 30 days.
   */
  warmDataRatio?: GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataRatio;
  /**
   * @remarks
   * The amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in 30 days.
   */
  warmDataSize?: GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in 30 days.
   */
  warmDataSizeDayGrowthRatio?: GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataSizeDayGrowthRatio;
  static names(): { [key: string]: string } {
    return {
      coldDataDayGrowthSize: 'ColdDataDayGrowthSize',
      coldDataRatio: 'ColdDataRatio',
      coldDataSize: 'ColdDataSize',
      coldDataSizeDayGrowthRatio: 'ColdDataSizeDayGrowthRatio',
      emptyFileCount: 'EmptyFileCount',
      emptyFileCountDayGrowthRatio: 'EmptyFileCountDayGrowthRatio',
      emptyFileDayGrowthCount: 'EmptyFileDayGrowthCount',
      emptyFileRatio: 'EmptyFileRatio',
      freezeDataDayGrowthSize: 'FreezeDataDayGrowthSize',
      freezeDataRatio: 'FreezeDataRatio',
      freezeDataSize: 'FreezeDataSize',
      freezeDataSizeDayGrowthRatio: 'FreezeDataSizeDayGrowthRatio',
      hotDataDayGrowthSize: 'HotDataDayGrowthSize',
      hotDataRatio: 'HotDataRatio',
      hotDataSize: 'HotDataSize',
      hotDataSizeDayGrowthRatio: 'HotDataSizeDayGrowthRatio',
      largeFileCount: 'LargeFileCount',
      largeFileCountDayGrowthRatio: 'LargeFileCountDayGrowthRatio',
      largeFileDayGrowthCount: 'LargeFileDayGrowthCount',
      largeFileRatio: 'LargeFileRatio',
      mediumFileCount: 'MediumFileCount',
      mediumFileCountDayGrowthRatio: 'MediumFileCountDayGrowthRatio',
      mediumFileDayGrowthCount: 'MediumFileDayGrowthCount',
      mediumFileRatio: 'MediumFileRatio',
      smallFileCount: 'SmallFileCount',
      smallFileCountDayGrowthRatio: 'SmallFileCountDayGrowthRatio',
      smallFileDayGrowthCount: 'SmallFileDayGrowthCount',
      smallFileRatio: 'SmallFileRatio',
      tinyFileCount: 'TinyFileCount',
      tinyFileCountDayGrowthRatio: 'TinyFileCountDayGrowthRatio',
      tinyFileDayGrowthCount: 'TinyFileDayGrowthCount',
      tinyFileRatio: 'TinyFileRatio',
      totalDataDayGrowthSize: 'TotalDataDayGrowthSize',
      totalDataSize: 'TotalDataSize',
      totalDataSizeDayGrowthRatio: 'TotalDataSizeDayGrowthRatio',
      totalFileCount: 'TotalFileCount',
      totalFileCountDayGrowthRatio: 'TotalFileCountDayGrowthRatio',
      totalFileDayGrowthCount: 'TotalFileDayGrowthCount',
      warmDataDayGrowthSize: 'WarmDataDayGrowthSize',
      warmDataRatio: 'WarmDataRatio',
      warmDataSize: 'WarmDataSize',
      warmDataSizeDayGrowthRatio: 'WarmDataSizeDayGrowthRatio',
    };
  }

  static types(): { [key: string]: any } {
    return {
      coldDataDayGrowthSize: GetDoctorHDFSClusterResponseBodyDataMetricsColdDataDayGrowthSize,
      coldDataRatio: GetDoctorHDFSClusterResponseBodyDataMetricsColdDataRatio,
      coldDataSize: GetDoctorHDFSClusterResponseBodyDataMetricsColdDataSize,
      coldDataSizeDayGrowthRatio: GetDoctorHDFSClusterResponseBodyDataMetricsColdDataSizeDayGrowthRatio,
      emptyFileCount: GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileCount,
      emptyFileCountDayGrowthRatio: GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileCountDayGrowthRatio,
      emptyFileDayGrowthCount: GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileDayGrowthCount,
      emptyFileRatio: GetDoctorHDFSClusterResponseBodyDataMetricsEmptyFileRatio,
      freezeDataDayGrowthSize: GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataDayGrowthSize,
      freezeDataRatio: GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataRatio,
      freezeDataSize: GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataSize,
      freezeDataSizeDayGrowthRatio: GetDoctorHDFSClusterResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio,
      hotDataDayGrowthSize: GetDoctorHDFSClusterResponseBodyDataMetricsHotDataDayGrowthSize,
      hotDataRatio: GetDoctorHDFSClusterResponseBodyDataMetricsHotDataRatio,
      hotDataSize: GetDoctorHDFSClusterResponseBodyDataMetricsHotDataSize,
      hotDataSizeDayGrowthRatio: GetDoctorHDFSClusterResponseBodyDataMetricsHotDataSizeDayGrowthRatio,
      largeFileCount: GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileCount,
      largeFileCountDayGrowthRatio: GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileCountDayGrowthRatio,
      largeFileDayGrowthCount: GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileDayGrowthCount,
      largeFileRatio: GetDoctorHDFSClusterResponseBodyDataMetricsLargeFileRatio,
      mediumFileCount: GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileCount,
      mediumFileCountDayGrowthRatio: GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileCountDayGrowthRatio,
      mediumFileDayGrowthCount: GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileDayGrowthCount,
      mediumFileRatio: GetDoctorHDFSClusterResponseBodyDataMetricsMediumFileRatio,
      smallFileCount: GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileCount,
      smallFileCountDayGrowthRatio: GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileCountDayGrowthRatio,
      smallFileDayGrowthCount: GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileDayGrowthCount,
      smallFileRatio: GetDoctorHDFSClusterResponseBodyDataMetricsSmallFileRatio,
      tinyFileCount: GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileCount,
      tinyFileCountDayGrowthRatio: GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileCountDayGrowthRatio,
      tinyFileDayGrowthCount: GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileDayGrowthCount,
      tinyFileRatio: GetDoctorHDFSClusterResponseBodyDataMetricsTinyFileRatio,
      totalDataDayGrowthSize: GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataDayGrowthSize,
      totalDataSize: GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataSize,
      totalDataSizeDayGrowthRatio: GetDoctorHDFSClusterResponseBodyDataMetricsTotalDataSizeDayGrowthRatio,
      totalFileCount: GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileCount,
      totalFileCountDayGrowthRatio: GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileCountDayGrowthRatio,
      totalFileDayGrowthCount: GetDoctorHDFSClusterResponseBodyDataMetricsTotalFileDayGrowthCount,
      warmDataDayGrowthSize: GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataDayGrowthSize,
      warmDataRatio: GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataRatio,
      warmDataSize: GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataSize,
      warmDataSizeDayGrowthRatio: GetDoctorHDFSClusterResponseBodyDataMetricsWarmDataSizeDayGrowthRatio,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSClusterResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The analysis results.
   */
  analysis?: GetDoctorHDFSClusterResponseBodyDataAnalysis;
  /**
   * @remarks
   * The metric information.
   */
  metrics?: GetDoctorHDFSClusterResponseBodyDataMetrics;
  static names(): { [key: string]: string } {
    return {
      analysis: 'Analysis',
      metrics: 'Metrics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      analysis: GetDoctorHDFSClusterResponseBodyDataAnalysis,
      metrics: GetDoctorHDFSClusterResponseBodyDataMetrics,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of cold data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * -182636577752
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Size of the cold data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 5570958082267
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of cold data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * -0.03
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of empty files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * emptyFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 15595897
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of empty files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * emptyFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.005
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of empty files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * emptyFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 114
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of freeze data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * -167683929450
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Size of the freeze data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1231312431
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of freeze data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * -0.09
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of hot data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 123154
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Size of the hot data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 6701531944206
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of hot data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.1114
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of large files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * largeFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 123
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of large files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * largeFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.39
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of large files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * largeFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 2
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of medium files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * mediumFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 234
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of medium files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * mediumFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.19
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of medium files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * mediumFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 176
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of small files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * smallFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 12345
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of small files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * smallFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.02
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of small files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * smallFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 12345
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of tiny files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tinyFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 232131
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of tiny files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tinyFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.003
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of tiny files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tinyFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * -123
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of total data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 256482228248
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total data size in megabytes (MB)
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 62086342083623
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of total data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.14
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of total files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 51683279
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of total files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.02
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of total files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 27809
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of warm data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * -64806998319
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Size of the warm data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 4062349775577
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of warm data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * -0.015
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyDataMetrics extends $tea.Model {
  /**
   * @remarks
   * The daily increment of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
   */
  coldDataDayGrowthSize?: GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataDayGrowthSize;
  /**
   * @remarks
   * The amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
   */
  coldDataSize?: GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
   */
  coldDataSizeDayGrowthRatio?: GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The number of empty files. Empty files are those with a size of 0 MB.
   */
  emptyFileCount?: GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of empty files. Empty files are those with a size of 0 MB.
   */
  emptyFileCountDayGrowthRatio?: GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of empty files. Empty files are those with a size of 0 MB.
   */
  emptyFileDayGrowthCount?: GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileDayGrowthCount;
  /**
   * @remarks
   * The daily increment of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   */
  freezeDataDayGrowthSize?: GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataDayGrowthSize;
  /**
   * @remarks
   * The amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   */
  freezeDataSize?: GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   */
  freezeDataSizeDayGrowthRatio?: GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the amount of hot data. Hot data refers to data that is accessed in previous seven days.
   */
  hotDataDayGrowthSize?: GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataDayGrowthSize;
  /**
   * @remarks
   * The amount of hot data. Hot data refers to data that is accessed in previous seven days.
   */
  hotDataSize?: GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of hot data. Hot data refers to data that is accessed in previous seven days.
   */
  hotDataSizeDayGrowthRatio?: GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The number of large files. Large files are those with a size greater than 1 GB.
   */
  largeFileCount?: GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of large files. Large files are those with a size greater than 1 GB.
   */
  largeFileCountDayGrowthRatio?: GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of large files. Large files are those with a size greater than 1 GB.
   */
  largeFileDayGrowthCount?: GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileDayGrowthCount;
  /**
   * @remarks
   * The number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   */
  mediumFileCount?: GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   */
  mediumFileCountDayGrowthRatio?: GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   */
  mediumFileDayGrowthCount?: GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileDayGrowthCount;
  /**
   * @remarks
   * The number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   */
  smallFileCount?: GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   */
  smallFileCountDayGrowthRatio?: GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   */
  smallFileDayGrowthCount?: GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileDayGrowthCount;
  /**
   * @remarks
   * The number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   */
  tinyFileCount?: GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   */
  tinyFileCountDayGrowthRatio?: GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   */
  tinyFileDayGrowthCount?: GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileDayGrowthCount;
  /**
   * @remarks
   * The daily incremental of the total amount of data.
   */
  totalDataDayGrowthSize?: GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataDayGrowthSize;
  /**
   * @remarks
   * The total amount of data.
   */
  totalDataSize?: GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the total data volume.
   */
  totalDataSizeDayGrowthRatio?: GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The total number of files.
   */
  totalFileCount?: GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the total number of files.
   */
  totalFileCountDayGrowthRatio?: GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the total number of files.
   */
  totalFileDayGrowthCount?: GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileDayGrowthCount;
  /**
   * @remarks
   * The daily increment of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
   */
  warmDataDayGrowthSize?: GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataDayGrowthSize;
  /**
   * @remarks
   * The amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
   */
  warmDataSize?: GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
   */
  warmDataSizeDayGrowthRatio?: GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataSizeDayGrowthRatio;
  static names(): { [key: string]: string } {
    return {
      coldDataDayGrowthSize: 'ColdDataDayGrowthSize',
      coldDataSize: 'ColdDataSize',
      coldDataSizeDayGrowthRatio: 'ColdDataSizeDayGrowthRatio',
      emptyFileCount: 'EmptyFileCount',
      emptyFileCountDayGrowthRatio: 'EmptyFileCountDayGrowthRatio',
      emptyFileDayGrowthCount: 'EmptyFileDayGrowthCount',
      freezeDataDayGrowthSize: 'FreezeDataDayGrowthSize',
      freezeDataSize: 'FreezeDataSize',
      freezeDataSizeDayGrowthRatio: 'FreezeDataSizeDayGrowthRatio',
      hotDataDayGrowthSize: 'HotDataDayGrowthSize',
      hotDataSize: 'HotDataSize',
      hotDataSizeDayGrowthRatio: 'HotDataSizeDayGrowthRatio',
      largeFileCount: 'LargeFileCount',
      largeFileCountDayGrowthRatio: 'LargeFileCountDayGrowthRatio',
      largeFileDayGrowthCount: 'LargeFileDayGrowthCount',
      mediumFileCount: 'MediumFileCount',
      mediumFileCountDayGrowthRatio: 'MediumFileCountDayGrowthRatio',
      mediumFileDayGrowthCount: 'MediumFileDayGrowthCount',
      smallFileCount: 'SmallFileCount',
      smallFileCountDayGrowthRatio: 'SmallFileCountDayGrowthRatio',
      smallFileDayGrowthCount: 'SmallFileDayGrowthCount',
      tinyFileCount: 'TinyFileCount',
      tinyFileCountDayGrowthRatio: 'TinyFileCountDayGrowthRatio',
      tinyFileDayGrowthCount: 'TinyFileDayGrowthCount',
      totalDataDayGrowthSize: 'TotalDataDayGrowthSize',
      totalDataSize: 'TotalDataSize',
      totalDataSizeDayGrowthRatio: 'TotalDataSizeDayGrowthRatio',
      totalFileCount: 'TotalFileCount',
      totalFileCountDayGrowthRatio: 'TotalFileCountDayGrowthRatio',
      totalFileDayGrowthCount: 'TotalFileDayGrowthCount',
      warmDataDayGrowthSize: 'WarmDataDayGrowthSize',
      warmDataSize: 'WarmDataSize',
      warmDataSizeDayGrowthRatio: 'WarmDataSizeDayGrowthRatio',
    };
  }

  static types(): { [key: string]: any } {
    return {
      coldDataDayGrowthSize: GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataDayGrowthSize,
      coldDataSize: GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataSize,
      coldDataSizeDayGrowthRatio: GetDoctorHDFSDirectoryResponseBodyDataMetricsColdDataSizeDayGrowthRatio,
      emptyFileCount: GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileCount,
      emptyFileCountDayGrowthRatio: GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileCountDayGrowthRatio,
      emptyFileDayGrowthCount: GetDoctorHDFSDirectoryResponseBodyDataMetricsEmptyFileDayGrowthCount,
      freezeDataDayGrowthSize: GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataDayGrowthSize,
      freezeDataSize: GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataSize,
      freezeDataSizeDayGrowthRatio: GetDoctorHDFSDirectoryResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio,
      hotDataDayGrowthSize: GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataDayGrowthSize,
      hotDataSize: GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataSize,
      hotDataSizeDayGrowthRatio: GetDoctorHDFSDirectoryResponseBodyDataMetricsHotDataSizeDayGrowthRatio,
      largeFileCount: GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileCount,
      largeFileCountDayGrowthRatio: GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileCountDayGrowthRatio,
      largeFileDayGrowthCount: GetDoctorHDFSDirectoryResponseBodyDataMetricsLargeFileDayGrowthCount,
      mediumFileCount: GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileCount,
      mediumFileCountDayGrowthRatio: GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileCountDayGrowthRatio,
      mediumFileDayGrowthCount: GetDoctorHDFSDirectoryResponseBodyDataMetricsMediumFileDayGrowthCount,
      smallFileCount: GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileCount,
      smallFileCountDayGrowthRatio: GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileCountDayGrowthRatio,
      smallFileDayGrowthCount: GetDoctorHDFSDirectoryResponseBodyDataMetricsSmallFileDayGrowthCount,
      tinyFileCount: GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileCount,
      tinyFileCountDayGrowthRatio: GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileCountDayGrowthRatio,
      tinyFileDayGrowthCount: GetDoctorHDFSDirectoryResponseBodyDataMetricsTinyFileDayGrowthCount,
      totalDataDayGrowthSize: GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataDayGrowthSize,
      totalDataSize: GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataSize,
      totalDataSizeDayGrowthRatio: GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalDataSizeDayGrowthRatio,
      totalFileCount: GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileCount,
      totalFileCountDayGrowthRatio: GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileCountDayGrowthRatio,
      totalFileDayGrowthCount: GetDoctorHDFSDirectoryResponseBodyDataMetricsTotalFileDayGrowthCount,
      warmDataDayGrowthSize: GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataDayGrowthSize,
      warmDataSize: GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataSize,
      warmDataSizeDayGrowthRatio: GetDoctorHDFSDirectoryResponseBodyDataMetricsWarmDataSizeDayGrowthRatio,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSDirectoryResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The directory level.
   * 
   * @example
   * 2
   */
  depth?: number;
  /**
   * @remarks
   * The group to which the directory belongs.
   * 
   * @example
   * DW
   */
  group?: string;
  /**
   * @remarks
   * The metric information.
   */
  metrics?: GetDoctorHDFSDirectoryResponseBodyDataMetrics;
  /**
   * @remarks
   * The directory owner.
   * 
   * @example
   * DW
   */
  user?: string;
  static names(): { [key: string]: string } {
    return {
      depth: 'Depth',
      group: 'Group',
      metrics: 'Metrics',
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      depth: 'number',
      group: 'string',
      metrics: GetDoctorHDFSDirectoryResponseBodyDataMetrics,
      user: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSUGIResponseBodyDataMetricsTotalDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total data size in megabytes (MB)
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 40440503
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSUGIResponseBodyDataMetricsTotalDirCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of total dirs
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalDirCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 123
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSUGIResponseBodyDataMetricsTotalFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of total files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 34
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSUGIResponseBodyDataMetrics extends $tea.Model {
  /**
   * @remarks
   * The total data size.
   */
  totalDataSize?: GetDoctorHDFSUGIResponseBodyDataMetricsTotalDataSize;
  /**
   * @remarks
   * The total number of directories.
   */
  totalDirCount?: GetDoctorHDFSUGIResponseBodyDataMetricsTotalDirCount;
  /**
   * @remarks
   * The total number of files.
   */
  totalFileCount?: GetDoctorHDFSUGIResponseBodyDataMetricsTotalFileCount;
  static names(): { [key: string]: string } {
    return {
      totalDataSize: 'TotalDataSize',
      totalDirCount: 'TotalDirCount',
      totalFileCount: 'TotalFileCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalDataSize: GetDoctorHDFSUGIResponseBodyDataMetricsTotalDataSize,
      totalDirCount: GetDoctorHDFSUGIResponseBodyDataMetricsTotalDirCount,
      totalFileCount: GetDoctorHDFSUGIResponseBodyDataMetricsTotalFileCount,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHDFSUGIResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The metric information.
   */
  metrics?: GetDoctorHDFSUGIResponseBodyDataMetrics;
  static names(): { [key: string]: string } {
    return {
      metrics: 'Metrics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      metrics: GetDoctorHDFSUGIResponseBodyDataMetrics,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataAnalysis extends $tea.Model {
  /**
   * @remarks
   * The score for the distribution of files of different sizes stored in the Hive cluster.
   * 
   * @example
   * 80
   */
  hiveDistributionScore?: number;
  /**
   * @remarks
   * The score for the distribution of files stored in different formats in the Hive cluster.
   * 
   * @example
   * 80
   */
  hiveFormatScore?: number;
  /**
   * @remarks
   * The score for the access frequency of the Hive cluster.
   * 
   * @example
   * 80
   */
  hiveFrequencyScore?: number;
  /**
   * @remarks
   * The overall score of the Hive cluster.
   * 
   * @example
   * 80
   */
  hiveScore?: number;
  static names(): { [key: string]: string } {
    return {
      hiveDistributionScore: 'HiveDistributionScore',
      hiveFormatScore: 'HiveFormatScore',
      hiveFrequencyScore: 'HiveFrequencyScore',
      hiveScore: 'HiveScore',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hiveDistributionScore: 'number',
      hiveFormatScore: 'number',
      hiveFrequencyScore: 'number',
      hiveScore: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataFormats extends $tea.Model {
  /**
   * @remarks
   * The name of the storage format.
   * 
   * @example
   * TextInputFormat
   */
  formatName?: string;
  /**
   * @remarks
   * The proportion of the data in the format.
   * 
   * @example
   * 0.5
   */
  formatRatio?: number;
  /**
   * @remarks
   * The amount of data in the format.
   * 
   * @example
   * 100
   */
  formatSize?: number;
  /**
   * @remarks
   * The unit of the amount of data in the format.
   * 
   * @example
   * MB
   */
  formatSizeUnit?: string;
  static names(): { [key: string]: string } {
    return {
      formatName: 'FormatName',
      formatRatio: 'FormatRatio',
      formatSize: 'FormatSize',
      formatSizeUnit: 'FormatSizeUnit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      formatName: 'string',
      formatRatio: 'number',
      formatSize: 'number',
      formatSizeUnit: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsColdDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of cold data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsColdDataRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Cold data ratio
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsColdDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of cold files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsColdDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of cold data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsDatabaseCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of databases
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * databaseCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of empty files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * emptyFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of empty files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * emptyFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of empty files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * emptyFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of empty files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * emptyFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of freeze data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of freeze data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.12
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of freeze files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of freeze data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsHotDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of hot data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsHotDataRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Hot data ratio
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsHotDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of hot files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsHotDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of hot data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsLargeFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of large files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * largeFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsLargeFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of large files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * largeFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsLargeFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of large files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * largeFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsLargeFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of large files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * largeFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsMediumFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of medium files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * mediumFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsMediumFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of medium files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * mediumFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsMediumFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of medium files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * mediumFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * “”
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 178
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsMediumFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of medium files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * mediumFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsPartitionNum extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of partitions
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * partitionNum
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsSmallFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of small files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * smallFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsSmallFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of small files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * smallFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsSmallFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of small files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * smallFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * “”
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsSmallFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of small files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * smallFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsTableCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of tables
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tableCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsTinyFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of tiny files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tinyFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsTinyFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of tiny files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tinyFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsTinyFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of tiny files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * day growth count of tiny files
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsTinyFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of tiny files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tinyFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsTotalDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of total data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsTotalDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total data size in megabytes (MB)
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsTotalDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of total data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsTotalFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of total files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsTotalFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of total files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsTotalFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of total files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 27800
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsWarmDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of warm data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * -100
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsWarmDataRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of warm data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmDataRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsWarmDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of warm files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetricsWarmDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of warm data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyDataMetrics extends $tea.Model {
  /**
   * @remarks
   * The daily increment of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
   */
  coldDataDayGrowthSize?: GetDoctorHiveClusterResponseBodyDataMetricsColdDataDayGrowthSize;
  /**
   * @remarks
   * The proportion of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
   */
  coldDataRatio?: GetDoctorHiveClusterResponseBodyDataMetricsColdDataRatio;
  /**
   * @remarks
   * The amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
   */
  coldDataSize?: GetDoctorHiveClusterResponseBodyDataMetricsColdDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
   */
  coldDataSizeDayGrowthRatio?: GetDoctorHiveClusterResponseBodyDataMetricsColdDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The number of databases.
   */
  databaseCount?: GetDoctorHiveClusterResponseBodyDataMetricsDatabaseCount;
  /**
   * @remarks
   * The number of empty files. Empty files are those with a size of 0 MB.
   */
  emptyFileCount?: GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of empty files. Empty files are those with a size of 0 MB.
   */
  emptyFileCountDayGrowthRatio?: GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of empty files. Empty files are those with a size of 0 MB.
   */
  emptyFileDayGrowthCount?: GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of empty files. Empty files are those with a size of 0 MB.
   */
  emptyFileRatio?: GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileRatio;
  /**
   * @remarks
   * The daily increment of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   */
  freezeDataDayGrowthSize?: GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataDayGrowthSize;
  /**
   * @remarks
   * The proportion of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   */
  freezeDataRatio?: GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataRatio;
  /**
   * @remarks
   * The amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   */
  freezeDataSize?: GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   */
  freezeDataSizeDayGrowthRatio?: GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the amount of hot data. Hot data refers to data that is accessed in previous seven days.
   */
  hotDataDayGrowthSize?: GetDoctorHiveClusterResponseBodyDataMetricsHotDataDayGrowthSize;
  /**
   * @remarks
   * The proportion of hot data. Hot data refers to data that is accessed in previous seven days.
   */
  hotDataRatio?: GetDoctorHiveClusterResponseBodyDataMetricsHotDataRatio;
  /**
   * @remarks
   * The amount of hot data. Hot data refers to data that is accessed in previous seven days.
   */
  hotDataSize?: GetDoctorHiveClusterResponseBodyDataMetricsHotDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of hot data. Hot data refers to data that is accessed in previous seven days.
   */
  hotDataSizeDayGrowthRatio?: GetDoctorHiveClusterResponseBodyDataMetricsHotDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The number of large files. Large files are those with a size greater than 1 GB.
   */
  largeFileCount?: GetDoctorHiveClusterResponseBodyDataMetricsLargeFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of large files. Large files are those with a size greater than 1 GB.
   */
  largeFileCountDayGrowthRatio?: GetDoctorHiveClusterResponseBodyDataMetricsLargeFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of large files. Large files are those with a size greater than 1 GB.
   */
  largeFileDayGrowthCount?: GetDoctorHiveClusterResponseBodyDataMetricsLargeFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of large files. Large files are those with a size greater than 1 GB.
   */
  largeFileRatio?: GetDoctorHiveClusterResponseBodyDataMetricsLargeFileRatio;
  /**
   * @remarks
   * The number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   */
  mediumFileCount?: GetDoctorHiveClusterResponseBodyDataMetricsMediumFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   */
  mediumFileCountDayGrowthRatio?: GetDoctorHiveClusterResponseBodyDataMetricsMediumFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   */
  mediumFileDayGrowthCount?: GetDoctorHiveClusterResponseBodyDataMetricsMediumFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   */
  mediumFileRatio?: GetDoctorHiveClusterResponseBodyDataMetricsMediumFileRatio;
  /**
   * @remarks
   * The number of partitions.
   */
  partitionNum?: GetDoctorHiveClusterResponseBodyDataMetricsPartitionNum;
  /**
   * @remarks
   * The number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   */
  smallFileCount?: GetDoctorHiveClusterResponseBodyDataMetricsSmallFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   */
  smallFileCountDayGrowthRatio?: GetDoctorHiveClusterResponseBodyDataMetricsSmallFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   */
  smallFileDayGrowthCount?: GetDoctorHiveClusterResponseBodyDataMetricsSmallFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   */
  smallFileRatio?: GetDoctorHiveClusterResponseBodyDataMetricsSmallFileRatio;
  /**
   * @remarks
   * The number of tables.
   */
  tableCount?: GetDoctorHiveClusterResponseBodyDataMetricsTableCount;
  /**
   * @remarks
   * The number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   */
  tinyFileCount?: GetDoctorHiveClusterResponseBodyDataMetricsTinyFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   */
  tinyFileCountDayGrowthRatio?: GetDoctorHiveClusterResponseBodyDataMetricsTinyFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   */
  tinyFileDayGrowthCount?: GetDoctorHiveClusterResponseBodyDataMetricsTinyFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   */
  tinyFileRatio?: GetDoctorHiveClusterResponseBodyDataMetricsTinyFileRatio;
  /**
   * @remarks
   * The daily incremental of the amount of total data.
   */
  totalDataDayGrowthSize?: GetDoctorHiveClusterResponseBodyDataMetricsTotalDataDayGrowthSize;
  /**
   * @remarks
   * The total amount of data.
   */
  totalDataSize?: GetDoctorHiveClusterResponseBodyDataMetricsTotalDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the total data volume.
   */
  totalDataSizeDayGrowthRatio?: GetDoctorHiveClusterResponseBodyDataMetricsTotalDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The total number of files.
   */
  totalFileCount?: GetDoctorHiveClusterResponseBodyDataMetricsTotalFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the total number of files.
   */
  totalFileCountDayGrowthRatio?: GetDoctorHiveClusterResponseBodyDataMetricsTotalFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the total number of files.
   */
  totalFileDayGrowthCount?: GetDoctorHiveClusterResponseBodyDataMetricsTotalFileDayGrowthCount;
  /**
   * @remarks
   * The daily increment of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
   */
  warmDataDayGrowthSize?: GetDoctorHiveClusterResponseBodyDataMetricsWarmDataDayGrowthSize;
  /**
   * @remarks
   * The proportion of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
   */
  warmDataRatio?: GetDoctorHiveClusterResponseBodyDataMetricsWarmDataRatio;
  /**
   * @remarks
   * The amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
   */
  warmDataSize?: GetDoctorHiveClusterResponseBodyDataMetricsWarmDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
   */
  warmDataSizeDayGrowthRatio?: GetDoctorHiveClusterResponseBodyDataMetricsWarmDataSizeDayGrowthRatio;
  static names(): { [key: string]: string } {
    return {
      coldDataDayGrowthSize: 'ColdDataDayGrowthSize',
      coldDataRatio: 'ColdDataRatio',
      coldDataSize: 'ColdDataSize',
      coldDataSizeDayGrowthRatio: 'ColdDataSizeDayGrowthRatio',
      databaseCount: 'DatabaseCount',
      emptyFileCount: 'EmptyFileCount',
      emptyFileCountDayGrowthRatio: 'EmptyFileCountDayGrowthRatio',
      emptyFileDayGrowthCount: 'EmptyFileDayGrowthCount',
      emptyFileRatio: 'EmptyFileRatio',
      freezeDataDayGrowthSize: 'FreezeDataDayGrowthSize',
      freezeDataRatio: 'FreezeDataRatio',
      freezeDataSize: 'FreezeDataSize',
      freezeDataSizeDayGrowthRatio: 'FreezeDataSizeDayGrowthRatio',
      hotDataDayGrowthSize: 'HotDataDayGrowthSize',
      hotDataRatio: 'HotDataRatio',
      hotDataSize: 'HotDataSize',
      hotDataSizeDayGrowthRatio: 'HotDataSizeDayGrowthRatio',
      largeFileCount: 'LargeFileCount',
      largeFileCountDayGrowthRatio: 'LargeFileCountDayGrowthRatio',
      largeFileDayGrowthCount: 'LargeFileDayGrowthCount',
      largeFileRatio: 'LargeFileRatio',
      mediumFileCount: 'MediumFileCount',
      mediumFileCountDayGrowthRatio: 'MediumFileCountDayGrowthRatio',
      mediumFileDayGrowthCount: 'MediumFileDayGrowthCount',
      mediumFileRatio: 'MediumFileRatio',
      partitionNum: 'PartitionNum',
      smallFileCount: 'SmallFileCount',
      smallFileCountDayGrowthRatio: 'SmallFileCountDayGrowthRatio',
      smallFileDayGrowthCount: 'SmallFileDayGrowthCount',
      smallFileRatio: 'SmallFileRatio',
      tableCount: 'TableCount',
      tinyFileCount: 'TinyFileCount',
      tinyFileCountDayGrowthRatio: 'TinyFileCountDayGrowthRatio',
      tinyFileDayGrowthCount: 'TinyFileDayGrowthCount',
      tinyFileRatio: 'TinyFileRatio',
      totalDataDayGrowthSize: 'TotalDataDayGrowthSize',
      totalDataSize: 'TotalDataSize',
      totalDataSizeDayGrowthRatio: 'TotalDataSizeDayGrowthRatio',
      totalFileCount: 'TotalFileCount',
      totalFileCountDayGrowthRatio: 'TotalFileCountDayGrowthRatio',
      totalFileDayGrowthCount: 'TotalFileDayGrowthCount',
      warmDataDayGrowthSize: 'WarmDataDayGrowthSize',
      warmDataRatio: 'WarmDataRatio',
      warmDataSize: 'WarmDataSize',
      warmDataSizeDayGrowthRatio: 'WarmDataSizeDayGrowthRatio',
    };
  }

  static types(): { [key: string]: any } {
    return {
      coldDataDayGrowthSize: GetDoctorHiveClusterResponseBodyDataMetricsColdDataDayGrowthSize,
      coldDataRatio: GetDoctorHiveClusterResponseBodyDataMetricsColdDataRatio,
      coldDataSize: GetDoctorHiveClusterResponseBodyDataMetricsColdDataSize,
      coldDataSizeDayGrowthRatio: GetDoctorHiveClusterResponseBodyDataMetricsColdDataSizeDayGrowthRatio,
      databaseCount: GetDoctorHiveClusterResponseBodyDataMetricsDatabaseCount,
      emptyFileCount: GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileCount,
      emptyFileCountDayGrowthRatio: GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileCountDayGrowthRatio,
      emptyFileDayGrowthCount: GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileDayGrowthCount,
      emptyFileRatio: GetDoctorHiveClusterResponseBodyDataMetricsEmptyFileRatio,
      freezeDataDayGrowthSize: GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataDayGrowthSize,
      freezeDataRatio: GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataRatio,
      freezeDataSize: GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataSize,
      freezeDataSizeDayGrowthRatio: GetDoctorHiveClusterResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio,
      hotDataDayGrowthSize: GetDoctorHiveClusterResponseBodyDataMetricsHotDataDayGrowthSize,
      hotDataRatio: GetDoctorHiveClusterResponseBodyDataMetricsHotDataRatio,
      hotDataSize: GetDoctorHiveClusterResponseBodyDataMetricsHotDataSize,
      hotDataSizeDayGrowthRatio: GetDoctorHiveClusterResponseBodyDataMetricsHotDataSizeDayGrowthRatio,
      largeFileCount: GetDoctorHiveClusterResponseBodyDataMetricsLargeFileCount,
      largeFileCountDayGrowthRatio: GetDoctorHiveClusterResponseBodyDataMetricsLargeFileCountDayGrowthRatio,
      largeFileDayGrowthCount: GetDoctorHiveClusterResponseBodyDataMetricsLargeFileDayGrowthCount,
      largeFileRatio: GetDoctorHiveClusterResponseBodyDataMetricsLargeFileRatio,
      mediumFileCount: GetDoctorHiveClusterResponseBodyDataMetricsMediumFileCount,
      mediumFileCountDayGrowthRatio: GetDoctorHiveClusterResponseBodyDataMetricsMediumFileCountDayGrowthRatio,
      mediumFileDayGrowthCount: GetDoctorHiveClusterResponseBodyDataMetricsMediumFileDayGrowthCount,
      mediumFileRatio: GetDoctorHiveClusterResponseBodyDataMetricsMediumFileRatio,
      partitionNum: GetDoctorHiveClusterResponseBodyDataMetricsPartitionNum,
      smallFileCount: GetDoctorHiveClusterResponseBodyDataMetricsSmallFileCount,
      smallFileCountDayGrowthRatio: GetDoctorHiveClusterResponseBodyDataMetricsSmallFileCountDayGrowthRatio,
      smallFileDayGrowthCount: GetDoctorHiveClusterResponseBodyDataMetricsSmallFileDayGrowthCount,
      smallFileRatio: GetDoctorHiveClusterResponseBodyDataMetricsSmallFileRatio,
      tableCount: GetDoctorHiveClusterResponseBodyDataMetricsTableCount,
      tinyFileCount: GetDoctorHiveClusterResponseBodyDataMetricsTinyFileCount,
      tinyFileCountDayGrowthRatio: GetDoctorHiveClusterResponseBodyDataMetricsTinyFileCountDayGrowthRatio,
      tinyFileDayGrowthCount: GetDoctorHiveClusterResponseBodyDataMetricsTinyFileDayGrowthCount,
      tinyFileRatio: GetDoctorHiveClusterResponseBodyDataMetricsTinyFileRatio,
      totalDataDayGrowthSize: GetDoctorHiveClusterResponseBodyDataMetricsTotalDataDayGrowthSize,
      totalDataSize: GetDoctorHiveClusterResponseBodyDataMetricsTotalDataSize,
      totalDataSizeDayGrowthRatio: GetDoctorHiveClusterResponseBodyDataMetricsTotalDataSizeDayGrowthRatio,
      totalFileCount: GetDoctorHiveClusterResponseBodyDataMetricsTotalFileCount,
      totalFileCountDayGrowthRatio: GetDoctorHiveClusterResponseBodyDataMetricsTotalFileCountDayGrowthRatio,
      totalFileDayGrowthCount: GetDoctorHiveClusterResponseBodyDataMetricsTotalFileDayGrowthCount,
      warmDataDayGrowthSize: GetDoctorHiveClusterResponseBodyDataMetricsWarmDataDayGrowthSize,
      warmDataRatio: GetDoctorHiveClusterResponseBodyDataMetricsWarmDataRatio,
      warmDataSize: GetDoctorHiveClusterResponseBodyDataMetricsWarmDataSize,
      warmDataSizeDayGrowthRatio: GetDoctorHiveClusterResponseBodyDataMetricsWarmDataSizeDayGrowthRatio,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveClusterResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The analysis results.
   */
  analysis?: GetDoctorHiveClusterResponseBodyDataAnalysis;
  /**
   * @remarks
   * The information from the perspective of storage formats.
   */
  formats?: GetDoctorHiveClusterResponseBodyDataFormats[];
  /**
   * @remarks
   * The metric information.
   */
  metrics?: GetDoctorHiveClusterResponseBodyDataMetrics;
  static names(): { [key: string]: string } {
    return {
      analysis: 'Analysis',
      formats: 'Formats',
      metrics: 'Metrics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      analysis: GetDoctorHiveClusterResponseBodyDataAnalysis,
      formats: { 'type': 'array', 'itemType': GetDoctorHiveClusterResponseBodyDataFormats },
      metrics: GetDoctorHiveClusterResponseBodyDataMetrics,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataAnalysis extends $tea.Model {
  /**
   * @remarks
   * The score for the file sizes of the Hive database.
   * 
   * @example
   * 85
   */
  hiveDistributionScore?: number;
  /**
   * @remarks
   * The score for the data formats of the Hive database.
   * 
   * @example
   * 85
   */
  hiveFormatScore?: number;
  /**
   * @remarks
   * The score for the access frequency of the Hive database.
   * 
   * @example
   * 85
   */
  hiveFrequencyScore?: number;
  /**
   * @remarks
   * The overall score of the Hive database.
   * 
   * @example
   * 85
   */
  hiveScore?: number;
  static names(): { [key: string]: string } {
    return {
      hiveDistributionScore: 'HiveDistributionScore',
      hiveFormatScore: 'HiveFormatScore',
      hiveFrequencyScore: 'HiveFrequencyScore',
      hiveScore: 'HiveScore',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hiveDistributionScore: 'number',
      hiveFormatScore: 'number',
      hiveFrequencyScore: 'number',
      hiveScore: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataFormats extends $tea.Model {
  /**
   * @remarks
   * The daily increment of data in the format.
   * 
   * @example
   * 1000
   */
  formatDayGrowthSize?: number;
  /**
   * @remarks
   * The name of the storage format.
   * 
   * @example
   * TextInputFormat
   */
  formatName?: string;
  /**
   * @remarks
   * The proportion of the data in the format.
   * 
   * @example
   * 0.5
   */
  formatRatio?: number;
  /**
   * @remarks
   * The amount of data in the format.
   * 
   * @example
   * 1000
   */
  formatSize?: number;
  /**
   * @remarks
   * The day-to-day growth rate of data in the format.
   * 
   * @example
   * 0.5
   */
  formatSizeDayGrowthRatio?: number;
  /**
   * @remarks
   * The unit of the amount of data in the format.
   * 
   * @example
   * MB
   */
  formatSizeUnit?: string;
  static names(): { [key: string]: string } {
    return {
      formatDayGrowthSize: 'FormatDayGrowthSize',
      formatName: 'FormatName',
      formatRatio: 'FormatRatio',
      formatSize: 'FormatSize',
      formatSizeDayGrowthRatio: 'FormatSizeDayGrowthRatio',
      formatSizeUnit: 'FormatSizeUnit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      formatDayGrowthSize: 'number',
      formatName: 'string',
      formatRatio: 'number',
      formatSize: 'number',
      formatSizeDayGrowthRatio: 'number',
      formatSizeUnit: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of cold data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Cold data ratio
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of cold files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of cold data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of empty files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * emptyFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of empty files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * emptyFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of empty files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * emptyFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of empty files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * emptyFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of freeze data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of freeze data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of freeze files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of freeze data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of hot data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Hot data ratio
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of hot files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of hot data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of large files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * largeFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of large files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * largeFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of large files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * largeFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of large files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * largeFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of medium files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * mediumFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of medium files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * mediumFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of medium files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * mediumFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of medium files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * mediumFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsPartitionNum extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of partitions
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * partitionNum
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of small files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * smallFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of small files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * smallFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of small files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * smallFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of small files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * smallFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsTableCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of tables
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tableCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of tiny files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tinyFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of tiny files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tinyFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of tiny files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tinyFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of tiny files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tinyFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of total data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total data size in megabytes (MB)
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of total data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of total files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of total files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of total files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of warm data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of warm data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmDataRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of warm files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of warm data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyDataMetrics extends $tea.Model {
  /**
   * @remarks
   * The daily increment of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
   */
  coldDataDayGrowthSize?: GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataDayGrowthSize;
  /**
   * @remarks
   * The proportion of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
   */
  coldDataRatio?: GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataRatio;
  /**
   * @remarks
   * The amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
   */
  coldDataSize?: GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
   */
  coldDataSizeDayGrowthRatio?: GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The number of empty files. Empty files are those with a size of 0 MB.
   */
  emptyFileCount?: GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of empty files. Empty files are those with a size of 0 MB.
   */
  emptyFileCountDayGrowthRatio?: GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of empty files. Empty files are those with a size of 0 MB.
   */
  emptyFileDayGrowthCount?: GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of empty files. Empty files are those with a size of 0 MB.
   */
  emptyFileRatio?: GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileRatio;
  /**
   * @remarks
   * The daily increment of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   */
  freezeDataDayGrowthSize?: GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataDayGrowthSize;
  /**
   * @remarks
   * The proportion of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   */
  freezeDataRatio?: GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataRatio;
  /**
   * @remarks
   * The amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   */
  freezeDataSize?: GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   */
  freezeDataSizeDayGrowthRatio?: GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the amount of hot data. Hot data refers to data that is accessed in previous seven days.
   */
  hotDataDayGrowthSize?: GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataDayGrowthSize;
  /**
   * @remarks
   * The proportion of hot data. Hot data refers to data that is accessed in previous seven days.
   */
  hotDataRatio?: GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataRatio;
  /**
   * @remarks
   * The amount of hot data. Hot data refers to data that is accessed in previous seven days.
   */
  hotDataSize?: GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of hot data. Hot data refers to data that is accessed in previous seven days.
   */
  hotDataSizeDayGrowthRatio?: GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The number of large files. Large files are those with a size greater than 1 GB.
   */
  largeFileCount?: GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of large files. Large files are those with a size greater than 1 GB.
   */
  largeFileCountDayGrowthRatio?: GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of large files. Large files are those with a size greater than 1 GB.
   */
  largeFileDayGrowthCount?: GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of large files. Large files are those with a size greater than 1 GB.
   */
  largeFileRatio?: GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileRatio;
  /**
   * @remarks
   * The number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   */
  mediumFileCount?: GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   */
  mediumFileCountDayGrowthRatio?: GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   */
  mediumFileDayGrowthCount?: GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   */
  mediumFileRatio?: GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileRatio;
  /**
   * @remarks
   * The number of partitions.
   */
  partitionNum?: GetDoctorHiveDatabaseResponseBodyDataMetricsPartitionNum;
  /**
   * @remarks
   * The number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   */
  smallFileCount?: GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   */
  smallFileCountDayGrowthRatio?: GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   */
  smallFileDayGrowthCount?: GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   */
  smallFileRatio?: GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileRatio;
  /**
   * @remarks
   * The number of tables.
   */
  tableCount?: GetDoctorHiveDatabaseResponseBodyDataMetricsTableCount;
  /**
   * @remarks
   * The number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   */
  tinyFileCount?: GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   */
  tinyFileCountDayGrowthRatio?: GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   */
  tinyFileDayGrowthCount?: GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   */
  tinyFileRatio?: GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileRatio;
  /**
   * @remarks
   * The daily incremental of the total amount of data.
   */
  totalDataDayGrowthSize?: GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataDayGrowthSize;
  /**
   * @remarks
   * The total amount of data.
   */
  totalDataSize?: GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the total data volume.
   */
  totalDataSizeDayGrowthRatio?: GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The total number of files.
   */
  totalFileCount?: GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the total number of files.
   */
  totalFileCountDayGrowthRatio?: GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the total number of files.
   */
  totalFileDayGrowthCount?: GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileDayGrowthCount;
  /**
   * @remarks
   * The daily increment of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
   */
  warmDataDayGrowthSize?: GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataDayGrowthSize;
  /**
   * @remarks
   * The proportion of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
   */
  warmDataRatio?: GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataRatio;
  /**
   * @remarks
   * The amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
   */
  warmDataSize?: GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
   */
  warmDataSizeDayGrowthRatio?: GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataSizeDayGrowthRatio;
  static names(): { [key: string]: string } {
    return {
      coldDataDayGrowthSize: 'ColdDataDayGrowthSize',
      coldDataRatio: 'ColdDataRatio',
      coldDataSize: 'ColdDataSize',
      coldDataSizeDayGrowthRatio: 'ColdDataSizeDayGrowthRatio',
      emptyFileCount: 'EmptyFileCount',
      emptyFileCountDayGrowthRatio: 'EmptyFileCountDayGrowthRatio',
      emptyFileDayGrowthCount: 'EmptyFileDayGrowthCount',
      emptyFileRatio: 'EmptyFileRatio',
      freezeDataDayGrowthSize: 'FreezeDataDayGrowthSize',
      freezeDataRatio: 'FreezeDataRatio',
      freezeDataSize: 'FreezeDataSize',
      freezeDataSizeDayGrowthRatio: 'FreezeDataSizeDayGrowthRatio',
      hotDataDayGrowthSize: 'HotDataDayGrowthSize',
      hotDataRatio: 'HotDataRatio',
      hotDataSize: 'HotDataSize',
      hotDataSizeDayGrowthRatio: 'HotDataSizeDayGrowthRatio',
      largeFileCount: 'LargeFileCount',
      largeFileCountDayGrowthRatio: 'LargeFileCountDayGrowthRatio',
      largeFileDayGrowthCount: 'LargeFileDayGrowthCount',
      largeFileRatio: 'LargeFileRatio',
      mediumFileCount: 'MediumFileCount',
      mediumFileCountDayGrowthRatio: 'MediumFileCountDayGrowthRatio',
      mediumFileDayGrowthCount: 'MediumFileDayGrowthCount',
      mediumFileRatio: 'MediumFileRatio',
      partitionNum: 'PartitionNum',
      smallFileCount: 'SmallFileCount',
      smallFileCountDayGrowthRatio: 'SmallFileCountDayGrowthRatio',
      smallFileDayGrowthCount: 'SmallFileDayGrowthCount',
      smallFileRatio: 'SmallFileRatio',
      tableCount: 'TableCount',
      tinyFileCount: 'TinyFileCount',
      tinyFileCountDayGrowthRatio: 'TinyFileCountDayGrowthRatio',
      tinyFileDayGrowthCount: 'TinyFileDayGrowthCount',
      tinyFileRatio: 'TinyFileRatio',
      totalDataDayGrowthSize: 'TotalDataDayGrowthSize',
      totalDataSize: 'TotalDataSize',
      totalDataSizeDayGrowthRatio: 'TotalDataSizeDayGrowthRatio',
      totalFileCount: 'TotalFileCount',
      totalFileCountDayGrowthRatio: 'TotalFileCountDayGrowthRatio',
      totalFileDayGrowthCount: 'TotalFileDayGrowthCount',
      warmDataDayGrowthSize: 'WarmDataDayGrowthSize',
      warmDataRatio: 'WarmDataRatio',
      warmDataSize: 'WarmDataSize',
      warmDataSizeDayGrowthRatio: 'WarmDataSizeDayGrowthRatio',
    };
  }

  static types(): { [key: string]: any } {
    return {
      coldDataDayGrowthSize: GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataDayGrowthSize,
      coldDataRatio: GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataRatio,
      coldDataSize: GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataSize,
      coldDataSizeDayGrowthRatio: GetDoctorHiveDatabaseResponseBodyDataMetricsColdDataSizeDayGrowthRatio,
      emptyFileCount: GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileCount,
      emptyFileCountDayGrowthRatio: GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileCountDayGrowthRatio,
      emptyFileDayGrowthCount: GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileDayGrowthCount,
      emptyFileRatio: GetDoctorHiveDatabaseResponseBodyDataMetricsEmptyFileRatio,
      freezeDataDayGrowthSize: GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataDayGrowthSize,
      freezeDataRatio: GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataRatio,
      freezeDataSize: GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataSize,
      freezeDataSizeDayGrowthRatio: GetDoctorHiveDatabaseResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio,
      hotDataDayGrowthSize: GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataDayGrowthSize,
      hotDataRatio: GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataRatio,
      hotDataSize: GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataSize,
      hotDataSizeDayGrowthRatio: GetDoctorHiveDatabaseResponseBodyDataMetricsHotDataSizeDayGrowthRatio,
      largeFileCount: GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileCount,
      largeFileCountDayGrowthRatio: GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileCountDayGrowthRatio,
      largeFileDayGrowthCount: GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileDayGrowthCount,
      largeFileRatio: GetDoctorHiveDatabaseResponseBodyDataMetricsLargeFileRatio,
      mediumFileCount: GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileCount,
      mediumFileCountDayGrowthRatio: GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileCountDayGrowthRatio,
      mediumFileDayGrowthCount: GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileDayGrowthCount,
      mediumFileRatio: GetDoctorHiveDatabaseResponseBodyDataMetricsMediumFileRatio,
      partitionNum: GetDoctorHiveDatabaseResponseBodyDataMetricsPartitionNum,
      smallFileCount: GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileCount,
      smallFileCountDayGrowthRatio: GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileCountDayGrowthRatio,
      smallFileDayGrowthCount: GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileDayGrowthCount,
      smallFileRatio: GetDoctorHiveDatabaseResponseBodyDataMetricsSmallFileRatio,
      tableCount: GetDoctorHiveDatabaseResponseBodyDataMetricsTableCount,
      tinyFileCount: GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileCount,
      tinyFileCountDayGrowthRatio: GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileCountDayGrowthRatio,
      tinyFileDayGrowthCount: GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileDayGrowthCount,
      tinyFileRatio: GetDoctorHiveDatabaseResponseBodyDataMetricsTinyFileRatio,
      totalDataDayGrowthSize: GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataDayGrowthSize,
      totalDataSize: GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataSize,
      totalDataSizeDayGrowthRatio: GetDoctorHiveDatabaseResponseBodyDataMetricsTotalDataSizeDayGrowthRatio,
      totalFileCount: GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileCount,
      totalFileCountDayGrowthRatio: GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileCountDayGrowthRatio,
      totalFileDayGrowthCount: GetDoctorHiveDatabaseResponseBodyDataMetricsTotalFileDayGrowthCount,
      warmDataDayGrowthSize: GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataDayGrowthSize,
      warmDataRatio: GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataRatio,
      warmDataSize: GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataSize,
      warmDataSizeDayGrowthRatio: GetDoctorHiveDatabaseResponseBodyDataMetricsWarmDataSizeDayGrowthRatio,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveDatabaseResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The analysis results.
   */
  analysis?: GetDoctorHiveDatabaseResponseBodyDataAnalysis;
  /**
   * @remarks
   * The information from the perspective of storage formats.
   */
  formats?: GetDoctorHiveDatabaseResponseBodyDataFormats[];
  /**
   * @remarks
   * The metric information.
   */
  metrics?: GetDoctorHiveDatabaseResponseBodyDataMetrics;
  static names(): { [key: string]: string } {
    return {
      analysis: 'Analysis',
      formats: 'Formats',
      metrics: 'Metrics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      analysis: GetDoctorHiveDatabaseResponseBodyDataAnalysis,
      formats: { 'type': 'array', 'itemType': GetDoctorHiveDatabaseResponseBodyDataFormats },
      metrics: GetDoctorHiveDatabaseResponseBodyDataMetrics,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataAnalysis extends $tea.Model {
  /**
   * @remarks
   * The score for the distribution of files of different sizes stored in the Hive table.
   * 
   * @example
   * 80
   */
  hiveDistributionScore?: number;
  /**
   * @remarks
   * The score for the distribution of files stored in different formats in the Hive table.
   * 
   * @example
   * 60
   */
  hiveFormatScore?: number;
  /**
   * @remarks
   * The score for the access frequency of the Hive table.
   * 
   * @example
   * 70
   */
  hiveFrequencyScore?: number;
  /**
   * @remarks
   * The overall score of the Hive table.
   * 
   * @example
   * 80
   */
  hiveScore?: number;
  static names(): { [key: string]: string } {
    return {
      hiveDistributionScore: 'HiveDistributionScore',
      hiveFormatScore: 'HiveFormatScore',
      hiveFrequencyScore: 'HiveFrequencyScore',
      hiveScore: 'HiveScore',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hiveDistributionScore: 'number',
      hiveFormatScore: 'number',
      hiveFrequencyScore: 'number',
      hiveScore: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataFormats extends $tea.Model {
  /**
   * @remarks
   * The daily amount increment of the data in a specific storage format.
   * 
   * @example
   * 1232124
   */
  formatDayGrowthSize?: number;
  /**
   * @remarks
   * The name of the storage format.
   * 
   * @example
   * TextInputFormat
   */
  formatName?: string;
  /**
   * @remarks
   * The ratio of the data in a specific storage format.
   * 
   * @example
   * 0.23
   */
  formatRatio?: number;
  /**
   * @remarks
   * The size of storage format-specific data.
   * 
   * @example
   * 506930200
   */
  formatSize?: number;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of the data in a specific storage format.
   * 
   * @example
   * 0.04
   */
  formatSizeDayGrowthRatio?: number;
  /**
   * @remarks
   * The unit of the data size.
   * 
   * @example
   * MB
   */
  formatSizeUnit?: string;
  static names(): { [key: string]: string } {
    return {
      formatDayGrowthSize: 'FormatDayGrowthSize',
      formatName: 'FormatName',
      formatRatio: 'FormatRatio',
      formatSize: 'FormatSize',
      formatSizeDayGrowthRatio: 'FormatSizeDayGrowthRatio',
      formatSizeUnit: 'FormatSizeUnit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      formatDayGrowthSize: 'number',
      formatName: 'string',
      formatRatio: 'number',
      formatSize: 'number',
      formatSizeDayGrowthRatio: 'number',
      formatSizeUnit: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsColdDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of cold data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 217715
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsColdDataRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Cold data ratio
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.01
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsColdDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Size of the cold data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 217715
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsColdDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of cold data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.01
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsEmptyFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of empty files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * emptyFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 3123
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsEmptyFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of empty files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * emptyFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.01
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsEmptyFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of empty files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * emptyFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * -20
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsEmptyFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of empty files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * emptyFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.01
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsFreezeDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of freeze data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 33229309
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsFreezeDataRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of freeze data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.98
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsFreezeDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Size of the freeze data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 33229309
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of freeze data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.01
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsHotDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of hot data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 203431
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsHotDataRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Hot data ratio
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.01
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsHotDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Size of the hot data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 203431
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsHotDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of hot data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.01
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsLargeFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of large files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * largeFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * “”
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 123
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsLargeFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of large files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * largeFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.01
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsLargeFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of large files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * largeFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 40
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsLargeFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of large files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * largeFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.02
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsMediumFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of medium files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * mediumFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * “”
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsMediumFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of medium files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * mediumFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.01
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsMediumFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of medium files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * mediumFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 20
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsMediumFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of medium files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * mediumFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.80
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsPartitionNum extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * number of partitions
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * partitionNum
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * “”
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 441
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsSmallFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of small files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * smallFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * "“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 18
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsSmallFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of small files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * smallFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.01
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsSmallFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of small files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * smallFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 18
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsSmallFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of small files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * smallFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.04
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsTinyFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of tiny files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tinyFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 451
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsTinyFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of tiny files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tinyFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.04
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsTinyFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of tiny files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tinyFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 482
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsTinyFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of tiny files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tinyFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.96
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsTotalDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of total data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 33800296
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsTotalDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total data size in megabytes (MB)
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 33800296
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsTotalDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of total data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.01
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsTotalFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of total files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 123
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsTotalFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of total files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.01
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsTotalFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of total files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 100
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsWarmDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of warm data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 149841
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsWarmDataRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of warm data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmDataRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.1
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsWarmDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Size of the warm data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 14981
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetricsWarmDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of warm data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.01
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyDataMetrics extends $tea.Model {
  /**
   * @remarks
   * The daily increment of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in 90 days.
   */
  coldDataDayGrowthSize?: GetDoctorHiveTableResponseBodyDataMetricsColdDataDayGrowthSize;
  /**
   * @remarks
   * The proportion of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in 90 days.
   */
  coldDataRatio?: GetDoctorHiveTableResponseBodyDataMetricsColdDataRatio;
  /**
   * @remarks
   * The amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in 90 days.
   */
  coldDataSize?: GetDoctorHiveTableResponseBodyDataMetricsColdDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in 90 days.
   */
  coldDataSizeDayGrowthRatio?: GetDoctorHiveTableResponseBodyDataMetricsColdDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The number of empty files. Empty files are those with a size of 0 MB.
   */
  emptyFileCount?: GetDoctorHiveTableResponseBodyDataMetricsEmptyFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of empty files. Empty files are those with a size of 0 MB.
   */
  emptyFileCountDayGrowthRatio?: GetDoctorHiveTableResponseBodyDataMetricsEmptyFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of empty files. Empty files are those with a size of 0 MB.
   */
  emptyFileDayGrowthCount?: GetDoctorHiveTableResponseBodyDataMetricsEmptyFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of empty files. Empty files are those with a size of 0 MB.
   */
  emptyFileRatio?: GetDoctorHiveTableResponseBodyDataMetricsEmptyFileRatio;
  /**
   * @remarks
   * The daily increment of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   */
  freezeDataDayGrowthSize?: GetDoctorHiveTableResponseBodyDataMetricsFreezeDataDayGrowthSize;
  /**
   * @remarks
   * The proportion of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   */
  freezeDataRatio?: GetDoctorHiveTableResponseBodyDataMetricsFreezeDataRatio;
  /**
   * @remarks
   * The amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   */
  freezeDataSize?: GetDoctorHiveTableResponseBodyDataMetricsFreezeDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   */
  freezeDataSizeDayGrowthRatio?: GetDoctorHiveTableResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the amount of hot data. Hot data refers to data that is accessed in recent seven days.
   */
  hotDataDayGrowthSize?: GetDoctorHiveTableResponseBodyDataMetricsHotDataDayGrowthSize;
  /**
   * @remarks
   * The proportion of hot data. Hot data refers to data that is accessed in recent seven days.
   */
  hotDataRatio?: GetDoctorHiveTableResponseBodyDataMetricsHotDataRatio;
  /**
   * @remarks
   * The amount of hot data. Hot data refers to data that is accessed in recent seven days.
   */
  hotDataSize?: GetDoctorHiveTableResponseBodyDataMetricsHotDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of hot data. Hot data refers to data that is accessed in recent seven days.
   */
  hotDataSizeDayGrowthRatio?: GetDoctorHiveTableResponseBodyDataMetricsHotDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The number of large files. Large files are those with a size greater than 1 GB.
   */
  largeFileCount?: GetDoctorHiveTableResponseBodyDataMetricsLargeFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of large files. Large files are those with a size greater than 1 GB.
   */
  largeFileCountDayGrowthRatio?: GetDoctorHiveTableResponseBodyDataMetricsLargeFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of large files. Large files are those with a size greater than 1 GB.
   */
  largeFileDayGrowthCount?: GetDoctorHiveTableResponseBodyDataMetricsLargeFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of large files. Large files are those with a size greater than 1 GB.
   */
  largeFileRatio?: GetDoctorHiveTableResponseBodyDataMetricsLargeFileRatio;
  /**
   * @remarks
   * The number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   */
  mediumFileCount?: GetDoctorHiveTableResponseBodyDataMetricsMediumFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   */
  mediumFileCountDayGrowthRatio?: GetDoctorHiveTableResponseBodyDataMetricsMediumFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   */
  mediumFileDayGrowthCount?: GetDoctorHiveTableResponseBodyDataMetricsMediumFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   */
  mediumFileRatio?: GetDoctorHiveTableResponseBodyDataMetricsMediumFileRatio;
  /**
   * @remarks
   * The number of partitions.
   */
  partitionNum?: GetDoctorHiveTableResponseBodyDataMetricsPartitionNum;
  /**
   * @remarks
   * The number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   */
  smallFileCount?: GetDoctorHiveTableResponseBodyDataMetricsSmallFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   */
  smallFileCountDayGrowthRatio?: GetDoctorHiveTableResponseBodyDataMetricsSmallFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   */
  smallFileDayGrowthCount?: GetDoctorHiveTableResponseBodyDataMetricsSmallFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   */
  smallFileRatio?: GetDoctorHiveTableResponseBodyDataMetricsSmallFileRatio;
  /**
   * @remarks
   * The number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   */
  tinyFileCount?: GetDoctorHiveTableResponseBodyDataMetricsTinyFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   */
  tinyFileCountDayGrowthRatio?: GetDoctorHiveTableResponseBodyDataMetricsTinyFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   */
  tinyFileDayGrowthCount?: GetDoctorHiveTableResponseBodyDataMetricsTinyFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   */
  tinyFileRatio?: GetDoctorHiveTableResponseBodyDataMetricsTinyFileRatio;
  /**
   * @remarks
   * The daily incremental of the total data volume.
   */
  totalDataDayGrowthSize?: GetDoctorHiveTableResponseBodyDataMetricsTotalDataDayGrowthSize;
  /**
   * @remarks
   * The total amount of data.
   */
  totalDataSize?: GetDoctorHiveTableResponseBodyDataMetricsTotalDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the total data volume.
   */
  totalDataSizeDayGrowthRatio?: GetDoctorHiveTableResponseBodyDataMetricsTotalDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The total number of files.
   */
  totalFileCount?: GetDoctorHiveTableResponseBodyDataMetricsTotalFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the total number of files.
   */
  totalFileCountDayGrowthRatio?: GetDoctorHiveTableResponseBodyDataMetricsTotalFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the total number of files.
   */
  totalFileDayGrowthCount?: GetDoctorHiveTableResponseBodyDataMetricsTotalFileDayGrowthCount;
  /**
   * @remarks
   * The daily increment of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in 30 days.
   */
  warmDataDayGrowthSize?: GetDoctorHiveTableResponseBodyDataMetricsWarmDataDayGrowthSize;
  /**
   * @remarks
   * The proportion of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in 30 days.
   */
  warmDataRatio?: GetDoctorHiveTableResponseBodyDataMetricsWarmDataRatio;
  /**
   * @remarks
   * The amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in 30 days.
   */
  warmDataSize?: GetDoctorHiveTableResponseBodyDataMetricsWarmDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in 30 days.
   */
  warmDataSizeDayGrowthRatio?: GetDoctorHiveTableResponseBodyDataMetricsWarmDataSizeDayGrowthRatio;
  static names(): { [key: string]: string } {
    return {
      coldDataDayGrowthSize: 'ColdDataDayGrowthSize',
      coldDataRatio: 'ColdDataRatio',
      coldDataSize: 'ColdDataSize',
      coldDataSizeDayGrowthRatio: 'ColdDataSizeDayGrowthRatio',
      emptyFileCount: 'EmptyFileCount',
      emptyFileCountDayGrowthRatio: 'EmptyFileCountDayGrowthRatio',
      emptyFileDayGrowthCount: 'EmptyFileDayGrowthCount',
      emptyFileRatio: 'EmptyFileRatio',
      freezeDataDayGrowthSize: 'FreezeDataDayGrowthSize',
      freezeDataRatio: 'FreezeDataRatio',
      freezeDataSize: 'FreezeDataSize',
      freezeDataSizeDayGrowthRatio: 'FreezeDataSizeDayGrowthRatio',
      hotDataDayGrowthSize: 'HotDataDayGrowthSize',
      hotDataRatio: 'HotDataRatio',
      hotDataSize: 'HotDataSize',
      hotDataSizeDayGrowthRatio: 'HotDataSizeDayGrowthRatio',
      largeFileCount: 'LargeFileCount',
      largeFileCountDayGrowthRatio: 'LargeFileCountDayGrowthRatio',
      largeFileDayGrowthCount: 'LargeFileDayGrowthCount',
      largeFileRatio: 'LargeFileRatio',
      mediumFileCount: 'MediumFileCount',
      mediumFileCountDayGrowthRatio: 'MediumFileCountDayGrowthRatio',
      mediumFileDayGrowthCount: 'MediumFileDayGrowthCount',
      mediumFileRatio: 'MediumFileRatio',
      partitionNum: 'PartitionNum',
      smallFileCount: 'SmallFileCount',
      smallFileCountDayGrowthRatio: 'SmallFileCountDayGrowthRatio',
      smallFileDayGrowthCount: 'SmallFileDayGrowthCount',
      smallFileRatio: 'SmallFileRatio',
      tinyFileCount: 'TinyFileCount',
      tinyFileCountDayGrowthRatio: 'TinyFileCountDayGrowthRatio',
      tinyFileDayGrowthCount: 'TinyFileDayGrowthCount',
      tinyFileRatio: 'TinyFileRatio',
      totalDataDayGrowthSize: 'TotalDataDayGrowthSize',
      totalDataSize: 'TotalDataSize',
      totalDataSizeDayGrowthRatio: 'TotalDataSizeDayGrowthRatio',
      totalFileCount: 'TotalFileCount',
      totalFileCountDayGrowthRatio: 'TotalFileCountDayGrowthRatio',
      totalFileDayGrowthCount: 'TotalFileDayGrowthCount',
      warmDataDayGrowthSize: 'WarmDataDayGrowthSize',
      warmDataRatio: 'WarmDataRatio',
      warmDataSize: 'WarmDataSize',
      warmDataSizeDayGrowthRatio: 'WarmDataSizeDayGrowthRatio',
    };
  }

  static types(): { [key: string]: any } {
    return {
      coldDataDayGrowthSize: GetDoctorHiveTableResponseBodyDataMetricsColdDataDayGrowthSize,
      coldDataRatio: GetDoctorHiveTableResponseBodyDataMetricsColdDataRatio,
      coldDataSize: GetDoctorHiveTableResponseBodyDataMetricsColdDataSize,
      coldDataSizeDayGrowthRatio: GetDoctorHiveTableResponseBodyDataMetricsColdDataSizeDayGrowthRatio,
      emptyFileCount: GetDoctorHiveTableResponseBodyDataMetricsEmptyFileCount,
      emptyFileCountDayGrowthRatio: GetDoctorHiveTableResponseBodyDataMetricsEmptyFileCountDayGrowthRatio,
      emptyFileDayGrowthCount: GetDoctorHiveTableResponseBodyDataMetricsEmptyFileDayGrowthCount,
      emptyFileRatio: GetDoctorHiveTableResponseBodyDataMetricsEmptyFileRatio,
      freezeDataDayGrowthSize: GetDoctorHiveTableResponseBodyDataMetricsFreezeDataDayGrowthSize,
      freezeDataRatio: GetDoctorHiveTableResponseBodyDataMetricsFreezeDataRatio,
      freezeDataSize: GetDoctorHiveTableResponseBodyDataMetricsFreezeDataSize,
      freezeDataSizeDayGrowthRatio: GetDoctorHiveTableResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio,
      hotDataDayGrowthSize: GetDoctorHiveTableResponseBodyDataMetricsHotDataDayGrowthSize,
      hotDataRatio: GetDoctorHiveTableResponseBodyDataMetricsHotDataRatio,
      hotDataSize: GetDoctorHiveTableResponseBodyDataMetricsHotDataSize,
      hotDataSizeDayGrowthRatio: GetDoctorHiveTableResponseBodyDataMetricsHotDataSizeDayGrowthRatio,
      largeFileCount: GetDoctorHiveTableResponseBodyDataMetricsLargeFileCount,
      largeFileCountDayGrowthRatio: GetDoctorHiveTableResponseBodyDataMetricsLargeFileCountDayGrowthRatio,
      largeFileDayGrowthCount: GetDoctorHiveTableResponseBodyDataMetricsLargeFileDayGrowthCount,
      largeFileRatio: GetDoctorHiveTableResponseBodyDataMetricsLargeFileRatio,
      mediumFileCount: GetDoctorHiveTableResponseBodyDataMetricsMediumFileCount,
      mediumFileCountDayGrowthRatio: GetDoctorHiveTableResponseBodyDataMetricsMediumFileCountDayGrowthRatio,
      mediumFileDayGrowthCount: GetDoctorHiveTableResponseBodyDataMetricsMediumFileDayGrowthCount,
      mediumFileRatio: GetDoctorHiveTableResponseBodyDataMetricsMediumFileRatio,
      partitionNum: GetDoctorHiveTableResponseBodyDataMetricsPartitionNum,
      smallFileCount: GetDoctorHiveTableResponseBodyDataMetricsSmallFileCount,
      smallFileCountDayGrowthRatio: GetDoctorHiveTableResponseBodyDataMetricsSmallFileCountDayGrowthRatio,
      smallFileDayGrowthCount: GetDoctorHiveTableResponseBodyDataMetricsSmallFileDayGrowthCount,
      smallFileRatio: GetDoctorHiveTableResponseBodyDataMetricsSmallFileRatio,
      tinyFileCount: GetDoctorHiveTableResponseBodyDataMetricsTinyFileCount,
      tinyFileCountDayGrowthRatio: GetDoctorHiveTableResponseBodyDataMetricsTinyFileCountDayGrowthRatio,
      tinyFileDayGrowthCount: GetDoctorHiveTableResponseBodyDataMetricsTinyFileDayGrowthCount,
      tinyFileRatio: GetDoctorHiveTableResponseBodyDataMetricsTinyFileRatio,
      totalDataDayGrowthSize: GetDoctorHiveTableResponseBodyDataMetricsTotalDataDayGrowthSize,
      totalDataSize: GetDoctorHiveTableResponseBodyDataMetricsTotalDataSize,
      totalDataSizeDayGrowthRatio: GetDoctorHiveTableResponseBodyDataMetricsTotalDataSizeDayGrowthRatio,
      totalFileCount: GetDoctorHiveTableResponseBodyDataMetricsTotalFileCount,
      totalFileCountDayGrowthRatio: GetDoctorHiveTableResponseBodyDataMetricsTotalFileCountDayGrowthRatio,
      totalFileDayGrowthCount: GetDoctorHiveTableResponseBodyDataMetricsTotalFileDayGrowthCount,
      warmDataDayGrowthSize: GetDoctorHiveTableResponseBodyDataMetricsWarmDataDayGrowthSize,
      warmDataRatio: GetDoctorHiveTableResponseBodyDataMetricsWarmDataRatio,
      warmDataSize: GetDoctorHiveTableResponseBodyDataMetricsWarmDataSize,
      warmDataSizeDayGrowthRatio: GetDoctorHiveTableResponseBodyDataMetricsWarmDataSizeDayGrowthRatio,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorHiveTableResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The analysis results.
   */
  analysis?: GetDoctorHiveTableResponseBodyDataAnalysis;
  /**
   * @remarks
   * The information from the perspective of formats.
   */
  formats?: GetDoctorHiveTableResponseBodyDataFormats[];
  /**
   * @remarks
   * The metric information.
   */
  metrics?: GetDoctorHiveTableResponseBodyDataMetrics;
  /**
   * @remarks
   * The owner.
   * 
   * @example
   * DW
   */
  owner?: string;
  static names(): { [key: string]: string } {
    return {
      analysis: 'Analysis',
      formats: 'Formats',
      metrics: 'Metrics',
      owner: 'Owner',
    };
  }

  static types(): { [key: string]: any } {
    return {
      analysis: GetDoctorHiveTableResponseBodyDataAnalysis,
      formats: { 'type': 'array', 'itemType': GetDoctorHiveTableResponseBodyDataFormats },
      metrics: GetDoctorHiveTableResponseBodyDataMetrics,
      owner: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorJobResponseBodyDataMetricsMemSeconds extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total memory usage over time in seconds
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * memSeconds
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB * Sec
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 12312312
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorJobResponseBodyDataMetricsVcoreSeconds extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total vcore usage over time in seconds
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * vcoreSeconds
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * VCores * Sec
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 11123
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorJobResponseBodyDataMetrics extends $tea.Model {
  /**
   * @remarks
   * The amount of memory consumed.
   */
  memSeconds?: GetDoctorJobResponseBodyDataMetricsMemSeconds;
  /**
   * @remarks
   * The CPU usage.
   */
  vcoreSeconds?: GetDoctorJobResponseBodyDataMetricsVcoreSeconds;
  static names(): { [key: string]: string } {
    return {
      memSeconds: 'MemSeconds',
      vcoreSeconds: 'VcoreSeconds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      memSeconds: GetDoctorJobResponseBodyDataMetricsMemSeconds,
      vcoreSeconds: GetDoctorJobResponseBodyDataMetricsVcoreSeconds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorJobResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the job that was submitted to YARN.
   * 
   * @example
   * application_1542620905989_****
   */
  appId?: string;
  /**
   * @remarks
   * The name of the job.
   * 
   * @example
   * CREATE TABLE test...ranks=1 (Stage-1)
   */
  appName?: string;
  /**
   * @remarks
   * The total running time of the job. Unit: milliseconds.
   * 
   * @example
   * 278
   */
  elapsedTime?: number;
  /**
   * @remarks
   * The final state of the job. Valid values:
   * 
   * *   SUCCEEDED
   * *   FAILED
   * *   KILLED
   * *   ENDED
   * *   UNDEFINED
   * 
   * @example
   * KILLED
   */
  finalStatus?: string;
  /**
   * @remarks
   * The time when the job ended. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
   * 
   * @example
   * 1658388322000
   */
  finishTime?: number;
  /**
   * @remarks
   * The time when the job was started. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
   * 
   * @example
   * 1665014400000
   */
  launchTime?: number;
  /**
   * @remarks
   * The data about metrics.
   */
  metrics?: GetDoctorJobResponseBodyDataMetrics;
  /**
   * @remarks
   * The YARN queue to which the job was submitted.
   * 
   * @example
   * DW
   */
  queue?: string;
  /**
   * @remarks
   * The time when the job was submitted. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
   * 
   * @example
   * 1673946000000
   */
  startTime?: number;
  /**
   * @remarks
   * The running state of the job. Valid values:
   * 
   * *   FINISHED
   * *   FAILED
   * *   KILLED
   * 
   * @example
   * FINISHED
   */
  state?: string;
  /**
   * @remarks
   * The type of the compute engine.
   * 
   * @example
   * SPARK
   */
  type?: string;
  /**
   * @remarks
   * The username that was used to submit the job.
   * 
   * @example
   * DW
   */
  user?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      elapsedTime: 'ElapsedTime',
      finalStatus: 'FinalStatus',
      finishTime: 'FinishTime',
      launchTime: 'LaunchTime',
      metrics: 'Metrics',
      queue: 'Queue',
      startTime: 'StartTime',
      state: 'State',
      type: 'Type',
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      appName: 'string',
      elapsedTime: 'number',
      finalStatus: 'string',
      finishTime: 'number',
      launchTime: 'number',
      metrics: GetDoctorJobResponseBodyDataMetrics,
      queue: 'string',
      startTime: 'number',
      state: 'string',
      type: 'string',
      user: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDoctorReportComponentSummaryResponseBodyData extends $tea.Model {
  /**
   * @example
   * 88
   */
  score?: number;
  suggestion?: string;
  /**
   * @remarks
   * The summary of the report.
   */
  summary?: string;
  static names(): { [key: string]: string } {
    return {
      score: 'Score',
      suggestion: 'Suggestion',
      summary: 'Summary',
    };
  }

  static types(): { [key: string]: any } {
    return {
      score: 'number',
      suggestion: 'string',
      summary: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationConfigsResponseBodyApplicationConfigs extends $tea.Model {
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * HDFS
   */
  applicationName?: string;
  /**
   * @remarks
   * The status of the configuration value.
   * 
   * @example
   * EFFECT
   */
  configEffectState?: string;
  /**
   * @remarks
   * The name of the configuration file.
   * 
   * @example
   * hdfs-site.xml
   */
  configFileName?: string;
  /**
   * @remarks
   * The key of the configuration item.
   * 
   * @example
   * dfs.replication
   */
  configItemKey?: string;
  /**
   * @remarks
   * The value of the configuration item.
   * 
   * @example
   * 2
   */
  configItemValue?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 1628589439114
   */
  createTime?: number;
  /**
   * @remarks
   * Indicates whether the configurations are custom.
   * 
   * @example
   * false
   */
  custom?: boolean;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * dfs.replication description
   */
  description?: string;
  /**
   * @remarks
   * The initial value.
   * 
   * @example
   * 2
   */
  initValue?: string;
  /**
   * @remarks
   * The person who modified the configurations.
   * 
   * @example
   * 170906468757****
   */
  modifier?: string;
  /**
   * @remarks
   * The node group ID.
   * 
   * @example
   * ng-d555335ced5****
   */
  nodeGroupId?: string;
  /**
   * @remarks
   * The node ID.
   * 
   * @example
   * i-bp18y0ng3qqxog4mw****
   */
  nodeId?: string;
  /**
   * @remarks
   * The update time.
   * 
   * @example
   * 1628589439114
   */
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      applicationName: 'ApplicationName',
      configEffectState: 'ConfigEffectState',
      configFileName: 'ConfigFileName',
      configItemKey: 'ConfigItemKey',
      configItemValue: 'ConfigItemValue',
      createTime: 'CreateTime',
      custom: 'Custom',
      description: 'Description',
      initValue: 'InitValue',
      modifier: 'Modifier',
      nodeGroupId: 'NodeGroupId',
      nodeId: 'NodeId',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationName: 'string',
      configEffectState: 'string',
      configFileName: 'string',
      configItemKey: 'string',
      configItemValue: 'string',
      createTime: 'number',
      custom: 'boolean',
      description: 'string',
      initValue: 'string',
      modifier: 'string',
      nodeGroupId: 'string',
      nodeId: 'string',
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListApplicationsResponseBodyApplications extends $tea.Model {
  /**
   * @remarks
   * The application name.
   * 
   * @example
   * HDFS
   */
  applicationName?: string;
  /**
   * @remarks
   * The status of the applications. Valid values:
   * 
   * *   STOPPED: At least one application is in the Stopped state.
   * *   RUNNING: All applications are in the Running state.
   * 
   * This parameter is returned only for DataLake, OLAP, Dataflow, DataServing, and custom clusters. For other types of clusters, no value is returned for this parameter.
   * 
   * @example
   * RUNNING
   */
  applicationState?: string;
  /**
   * @remarks
   * The version of the application.
   * 
   * @example
   * 2.8.1
   * 
   * @deprecated
   */
  applicationVersion?: string;
  /**
   * @remarks
   * The community edition.
   * 
   * @example
   * 2.8.5
   */
  communityVersion?: string;
  static names(): { [key: string]: string } {
    return {
      applicationName: 'ApplicationName',
      applicationState: 'ApplicationState',
      applicationVersion: 'ApplicationVersion',
      communityVersion: 'CommunityVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationName: 'string',
      applicationState: 'string',
      applicationVersion: 'string',
      communityVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAutoScalingActivitiesResponseBodyScalingActivities extends $tea.Model {
  /**
   * @remarks
   * The ID of the scaling activity.
   * 
   * @example
   * asa-36373b084d6b4b13aa50f4129a9e****
   */
  activityId?: string;
  /**
   * @remarks
   * The status of the scaling activity. Valid values:
   * 
   * *   REJECTED
   * *   SUCCESSFUL
   * *   FAILED
   * *   IN_PROGRESS
   * 
   * @example
   * IN_PROGRESS
   */
  activityState?: string;
  /**
   * @remarks
   * The type of the scaling activity. Valid values:
   * 
   * *   SCALE_OUT
   * *   SCALE_IN
   * 
   * @example
   * SCALE_OUT
   */
  activityType?: string;
  /**
   * @remarks
   * The cluster ID.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  clusterId?: string;
  /**
   * @remarks
   * The description of the scaling activity.
   * 
   * @example
   * clusterId not exist
   */
  description?: string;
  /**
   * @remarks
   * The end time of the scaling. Unit: milliseconds.
   * 
   * @example
   * 1639715634819
   */
  endTime?: number;
  /**
   * @remarks
   * The number of added or removed instances.
   * 
   * @example
   * 10
   */
  expectNum?: number;
  /**
   * @remarks
   * The ID of the node group.
   * 
   * @example
   * ng-869471354ecd****
   */
  nodeGroupId?: string;
  /**
   * @remarks
   * The name of the node group.
   * 
   * @example
   * task-01
   */
  nodeGroupName?: string;
  /**
   * @remarks
   * The operation ID.
   * 
   * @example
   * op-13c37a77c505****
   */
  operationId?: string;
  /**
   * @remarks
   * The name of the scaling rule.
   * 
   * @example
   * scaling-out-memory
   */
  ruleName?: string;
  /**
   * @remarks
   * The start time of the scaling. Unit: milliseconds.
   * 
   * @example
   * 1639714634819
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      activityId: 'ActivityId',
      activityState: 'ActivityState',
      activityType: 'ActivityType',
      clusterId: 'ClusterId',
      description: 'Description',
      endTime: 'EndTime',
      expectNum: 'ExpectNum',
      nodeGroupId: 'NodeGroupId',
      nodeGroupName: 'NodeGroupName',
      operationId: 'OperationId',
      ruleName: 'RuleName',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activityId: 'string',
      activityState: 'string',
      activityType: 'string',
      clusterId: 'string',
      description: 'string',
      endTime: 'number',
      expectNum: 'number',
      nodeGroupId: 'string',
      nodeGroupName: 'string',
      operationId: 'string',
      ruleName: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListComponentInstancesResponseBodyComponentInstances extends $tea.Model {
  /**
   * @remarks
   * 应用名称。
   * 
   * @example
   * HDFS
   */
  applicationName?: string;
  /**
   * @remarks
   * 组件服务状态，取值如下：
   * - active：主服务
   * - standby：备用服务。
   * 
   * @example
   * active
   */
  bizState?: string;
  /**
   * @remarks
   * Commission状态，取值如下：
   * - COMMISSIONED：已上线
   * - COMMISSIONING：上线中
   * - DECOMMISSIONED：已下线
   * - DECOMMISSIONINPROGRESS：下线进程中
   * - DECOMMISSIONFAILED：下线失败
   * - INSERVICE：服务中
   * - UNKNOWN：未知状态。
   * <p>
   * 
   * @example
   * INSERVICE
   */
  commissionState?: string;
  /**
   * @remarks
   * 组件实例操作状态，取值如下：
   * - WAITING：等待中
   * - INSTALLING：安装中
   * - INSTALLED：已安装
   * - INSTALL_FAILED：安装失败
   * - STARTING：启动中
   * - STARTED：已启动
   * - START_FAILED：启动失败
   * - STOPPING：停止中
   * - STOPPED：已停止
   * - STOP_FAILED：停止失败
   */
  componentInstanceState?: string;
  /**
   * @remarks
   * 组件名称。
   * 
   * @example
   * DataNode
   */
  componentName?: string;
  /**
   * @remarks
   * 安装时间戳。
   * 
   * @example
   * 1628248947000
   */
  createTime?: number;
  /**
   * @remarks
   * 期望状态，取值如下：
   * - WAITING：等待中
   * - INSTALLING：安装中
   * - INSTALLED：已安装
   * - INSTALL_FAILED：安装失败
   * - STARTING：启动中
   * - STARTED：已启动
   * - START_FAILED：启动失败
   * - STOPPING：停止中
   * - STOPPED：已停止
   * - STOP_FAILED：停止失败。
   * 
   * @example
   * STARTED
   */
  desiredState?: string;
  /**
   * @remarks
   * 节点ID。
   * 
   * @example
   * i-bp1cudc25w2bfwl5****
   */
  nodeId?: string;
  /**
   * @remarks
   * 节点名称。
   * 
   * @example
   * core1-1
   */
  nodeName?: string;
  static names(): { [key: string]: string } {
    return {
      applicationName: 'ApplicationName',
      bizState: 'BizState',
      commissionState: 'CommissionState',
      componentInstanceState: 'ComponentInstanceState',
      componentName: 'ComponentName',
      createTime: 'CreateTime',
      desiredState: 'DesiredState',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationName: 'string',
      bizState: 'string',
      commissionState: 'string',
      componentInstanceState: 'string',
      componentName: 'string',
      createTime: 'number',
      desiredState: 'string',
      nodeId: 'string',
      nodeName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListComponentsResponseBodyComponents extends $tea.Model {
  /**
   * @remarks
   * 应用名称。
   * 
   * @example
   * HDFS
   */
  applicationName?: string;
  /**
   * @remarks
   * 属性列表。
   */
  attributes?: Attribute[];
  /**
   * @remarks
   * 组件名称。
   * 
   * @example
   * DataNode
   */
  componentName?: string;
  /**
   * @remarks
   * 命名空间。
   */
  namespace?: string;
  /**
   * @remarks
   * 安装该组件的机器总数。
   * 
   * @example
   * 1
   */
  replica?: number;
  static names(): { [key: string]: string } {
    return {
      applicationName: 'ApplicationName',
      attributes: 'Attributes',
      componentName: 'ComponentName',
      namespace: 'Namespace',
      replica: 'Replica',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationName: 'string',
      attributes: { 'type': 'array', 'itemType': Attribute },
      componentName: 'string',
      namespace: 'string',
      replica: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorApplicationsResponseBodyDataAnalysis extends $tea.Model {
  /**
   * @remarks
   * The score of the job.
   * 
   * @example
   * 23
   */
  score?: number;
  /**
   * @remarks
   * The suggestion on executing the job.
   */
  suggestion?: string;
  static names(): { [key: string]: string } {
    return {
      score: 'Score',
      suggestion: 'Suggestion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      score: 'number',
      suggestion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorApplicationsResponseBodyDataMetricsMemSeconds extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total memory usage over time in seconds
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * memSeconds
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB * Sec
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 12312312
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorApplicationsResponseBodyDataMetricsMemUtilization extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of used memory to total available memory
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * memUtilization
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.23
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorApplicationsResponseBodyDataMetricsVcoreSeconds extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total vcore usage over time in seconds
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * vcoreSeconds
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * VCores * Sec
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 11123
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorApplicationsResponseBodyDataMetricsVcoreUtilization extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of used vcore to total available cores
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * vcoreUtilization
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 23.1
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorApplicationsResponseBodyDataMetrics extends $tea.Model {
  /**
   * @remarks
   * The amount of memory consumed.
   */
  memSeconds?: ListDoctorApplicationsResponseBodyDataMetricsMemSeconds;
  /**
   * @remarks
   * The memory usage
   */
  memUtilization?: ListDoctorApplicationsResponseBodyDataMetricsMemUtilization;
  /**
   * @remarks
   * The CPU usage.
   */
  vcoreSeconds?: ListDoctorApplicationsResponseBodyDataMetricsVcoreSeconds;
  /**
   * @remarks
   * The CPU utilization. This parameter has the same meaning as %CPU in the Linux top command.
   */
  vcoreUtilization?: ListDoctorApplicationsResponseBodyDataMetricsVcoreUtilization;
  static names(): { [key: string]: string } {
    return {
      memSeconds: 'MemSeconds',
      memUtilization: 'MemUtilization',
      vcoreSeconds: 'VcoreSeconds',
      vcoreUtilization: 'VcoreUtilization',
    };
  }

  static types(): { [key: string]: any } {
    return {
      memSeconds: ListDoctorApplicationsResponseBodyDataMetricsMemSeconds,
      memUtilization: ListDoctorApplicationsResponseBodyDataMetricsMemUtilization,
      vcoreSeconds: ListDoctorApplicationsResponseBodyDataMetricsVcoreSeconds,
      vcoreUtilization: ListDoctorApplicationsResponseBodyDataMetricsVcoreUtilization,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorApplicationsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The analysis results of the jobs.
   */
  analysis?: ListDoctorApplicationsResponseBodyDataAnalysis;
  /**
   * @remarks
   * The job ID in YARN. The value of QueryID or SessionID is returned for a Hive job.
   * 
   * @example
   * application_1665056147236_*****
   */
  appId?: string;
  /**
   * @remarks
   * The name of the job.
   * 
   * @example
   * data-upload
   */
  appName?: string;
  /**
   * @remarks
   * The time when the job ended. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
   * 
   * @example
   * 1682049088086
   */
  endTime?: number;
  /**
   * @remarks
   * The job IDs. Multiple job IDs are separated with commas (,).
   * 
   * @example
   * null
   */
  ids?: string[];
  /**
   * @remarks
   * The data about metrics.
   */
  metrics?: ListDoctorApplicationsResponseBodyDataMetrics;
  /**
   * @remarks
   * The query statement. This parameter is left empty for non-SQL jobs.
   * 
   * @example
   * SELECT id, count(1) FROM test group by id;
   */
  querySql?: string;
  /**
   * @remarks
   * The YARN queue to which the job was submitted.
   * 
   * @example
   * DW
   */
  queue?: string;
  /**
   * @remarks
   * The time when the job was submitted. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
   * 
   * @example
   * 1677465658275
   */
  startTime?: number;
  /**
   * @remarks
   * The type of the compute engine.
   * 
   * @example
   * TEZ
   */
  type?: string;
  /**
   * @remarks
   * The username that was used to submit the job.
   * 
   * @example
   * DW
   */
  user?: string;
  static names(): { [key: string]: string } {
    return {
      analysis: 'Analysis',
      appId: 'AppId',
      appName: 'AppName',
      endTime: 'EndTime',
      ids: 'Ids',
      metrics: 'Metrics',
      querySql: 'QuerySql',
      queue: 'Queue',
      startTime: 'StartTime',
      type: 'Type',
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      analysis: ListDoctorApplicationsResponseBodyDataAnalysis,
      appId: 'string',
      appName: 'string',
      endTime: 'number',
      ids: { 'type': 'array', 'itemType': 'string' },
      metrics: ListDoctorApplicationsResponseBodyDataMetrics,
      querySql: 'string',
      queue: 'string',
      startTime: 'number',
      type: 'string',
      user: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorComputeSummaryResponseBodyDataAnalysis extends $tea.Model {
  /**
   * @remarks
   * The total number of healthy jobs.
   * 
   * @example
   * 3
   */
  healthyJobCount?: number;
  /**
   * @remarks
   * The total number of jobs that require attention.
   * 
   * @example
   * 23
   */
  needAttentionJobCount?: number;
  /**
   * @remarks
   * The score for jobs.
   * 
   * @example
   * 56
   */
  score?: number;
  /**
   * @remarks
   * The day-to-day growth rate of the score for jobs.
   * 
   * @example
   * 0.03
   */
  scoreDayGrowthRatio?: number;
  /**
   * @remarks
   * The total number of sub-healthy jobs.
   * 
   * @example
   * 13
   */
  subHealthyJobCount?: number;
  /**
   * @remarks
   * The total number of unhealthy jobs.
   * 
   * @example
   * 123
   */
  unhealthyJobCount?: number;
  static names(): { [key: string]: string } {
    return {
      healthyJobCount: 'HealthyJobCount',
      needAttentionJobCount: 'NeedAttentionJobCount',
      score: 'Score',
      scoreDayGrowthRatio: 'ScoreDayGrowthRatio',
      subHealthyJobCount: 'SubHealthyJobCount',
      unhealthyJobCount: 'UnhealthyJobCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      healthyJobCount: 'number',
      needAttentionJobCount: 'number',
      score: 'number',
      scoreDayGrowthRatio: 'number',
      subHealthyJobCount: 'number',
      unhealthyJobCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorComputeSummaryResponseBodyDataMetricsMemSeconds extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total memory usage over time in seconds
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * memSeconds
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB * Sec
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 12312312
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorComputeSummaryResponseBodyDataMetricsMemSecondsDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Growth ratio of memory usage in seconds per day
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * memSecondsDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * “”
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.36
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorComputeSummaryResponseBodyDataMetricsMemUtilization extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of used memory to total available memory
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * memUtilization
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * “”
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.82
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorComputeSummaryResponseBodyDataMetricsReadSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total cumulative size of data read in megabytes (MB)
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * readSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 504888659968
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorComputeSummaryResponseBodyDataMetricsVcoreSeconds extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total vcore usage over time in seconds
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * vcoreSeconds
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * VCores * Sec
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1231412
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorComputeSummaryResponseBodyDataMetricsVcoreSecondsDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Growth ratio of virtual core usage in seconds per day
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * vcoreSecondsDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * “”
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.22
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorComputeSummaryResponseBodyDataMetricsVcoreUtilization extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of used vcore to total available cores
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * vcoreUtilization
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * “”
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 32.1
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorComputeSummaryResponseBodyDataMetricsWriteSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total cumulative size of data written in megabytes (MB)
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * writeSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 6294093393920
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorComputeSummaryResponseBodyDataMetrics extends $tea.Model {
  /**
   * @remarks
   * The total memory consumption over time in seconds.
   */
  memSeconds?: ListDoctorComputeSummaryResponseBodyDataMetricsMemSeconds;
  /**
   * @remarks
   * The day-to-day growth rate of the total memory consumption over time in seconds.
   */
  memSecondsDayGrowthRatio?: ListDoctorComputeSummaryResponseBodyDataMetricsMemSecondsDayGrowthRatio;
  /**
   * @remarks
   * The average memory usage.
   */
  memUtilization?: ListDoctorComputeSummaryResponseBodyDataMetricsMemUtilization;
  /**
   * @remarks
   * The total amount of data read from the file system.
   */
  readSize?: ListDoctorComputeSummaryResponseBodyDataMetricsReadSize;
  /**
   * @remarks
   * The total CPU consumption over time in seconds.
   */
  vcoreSeconds?: ListDoctorComputeSummaryResponseBodyDataMetricsVcoreSeconds;
  /**
   * @remarks
   * The day-to-day growth rate of the total CPU consumption over time in seconds.
   */
  vcoreSecondsDayGrowthRatio?: ListDoctorComputeSummaryResponseBodyDataMetricsVcoreSecondsDayGrowthRatio;
  /**
   * @remarks
   * The average CPU utilization. The meaning is the same as the %CPU parameter in the output of the top command in Linux.
   */
  vcoreUtilization?: ListDoctorComputeSummaryResponseBodyDataMetricsVcoreUtilization;
  /**
   * @remarks
   * The total amount of data written to the file system.
   */
  writeSize?: ListDoctorComputeSummaryResponseBodyDataMetricsWriteSize;
  static names(): { [key: string]: string } {
    return {
      memSeconds: 'MemSeconds',
      memSecondsDayGrowthRatio: 'MemSecondsDayGrowthRatio',
      memUtilization: 'MemUtilization',
      readSize: 'ReadSize',
      vcoreSeconds: 'VcoreSeconds',
      vcoreSecondsDayGrowthRatio: 'VcoreSecondsDayGrowthRatio',
      vcoreUtilization: 'VcoreUtilization',
      writeSize: 'WriteSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      memSeconds: ListDoctorComputeSummaryResponseBodyDataMetricsMemSeconds,
      memSecondsDayGrowthRatio: ListDoctorComputeSummaryResponseBodyDataMetricsMemSecondsDayGrowthRatio,
      memUtilization: ListDoctorComputeSummaryResponseBodyDataMetricsMemUtilization,
      readSize: ListDoctorComputeSummaryResponseBodyDataMetricsReadSize,
      vcoreSeconds: ListDoctorComputeSummaryResponseBodyDataMetricsVcoreSeconds,
      vcoreSecondsDayGrowthRatio: ListDoctorComputeSummaryResponseBodyDataMetricsVcoreSecondsDayGrowthRatio,
      vcoreUtilization: ListDoctorComputeSummaryResponseBodyDataMetricsVcoreUtilization,
      writeSize: ListDoctorComputeSummaryResponseBodyDataMetricsWriteSize,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorComputeSummaryResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The resource analysis results.
   */
  analysis?: ListDoctorComputeSummaryResponseBodyDataAnalysis;
  /**
   * @remarks
   * The name of the resource whose details are obtained based on the value of ComponentTypes. For example, if the value of ComponentTypes is Queue, the value of this parameter is a queue, such as DW.
   * 
   * @example
   * DW
   */
  componentName?: string;
  /**
   * @remarks
   * The metric information.
   */
  metrics?: ListDoctorComputeSummaryResponseBodyDataMetrics;
  static names(): { [key: string]: string } {
    return {
      analysis: 'Analysis',
      componentName: 'ComponentName',
      metrics: 'Metrics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      analysis: ListDoctorComputeSummaryResponseBodyDataAnalysis,
      componentName: 'string',
      metrics: ListDoctorComputeSummaryResponseBodyDataMetrics,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseRegionServersResponseBodyDataMetricsAvgGc extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * The efficiency of garbage collection in the system
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * avgGc
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 37.9
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseRegionServersResponseBodyDataMetricsCacheRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of the BlockCache memory size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * cacheRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 96.7
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyReadRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of read requests per day
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * dailyReadRequest
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 42571
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyReadRequestDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * The growth rate of daily read request quantity.
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * dailyReadRequestDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1.0
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyWriteRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of write requests per day
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * dailyWriteRequest
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 23124
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * The growth rate of daily write request quantity.
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * dailyWriteRequestDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1.0
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseRegionServersResponseBodyDataMetricsRegionCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of regions count
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * regionCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 81
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalReadRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total number of read requests
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalReadRequest
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 170500567
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total number of requests
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalRequest
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 89499511
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalWriteRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total number of write requests
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalWriteRequest
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 30109837
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseRegionServersResponseBodyDataMetrics extends $tea.Model {
  /**
   * @remarks
   * The average garbage collection (GC) duration.
   */
  avgGc?: ListDoctorHBaseRegionServersResponseBodyDataMetricsAvgGc;
  /**
   * @remarks
   * The cache hit ratio.
   */
  cacheRatio?: ListDoctorHBaseRegionServersResponseBodyDataMetricsCacheRatio;
  /**
   * @remarks
   * The number of daily read requests.
   */
  dailyReadRequest?: ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyReadRequest;
  /**
   * @remarks
   * The growth rate of the number of daily read requests.
   */
  dailyReadRequestDayGrowthRatio?: ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyReadRequestDayGrowthRatio;
  /**
   * @remarks
   * The number of daily write requests.
   */
  dailyWriteRequest?: ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyWriteRequest;
  /**
   * @remarks
   * The growth rate of the number of daily write requests.
   */
  dailyWriteRequestDayGrowthRatio?: ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio;
  /**
   * @remarks
   * The number of regions.
   */
  regionCount?: ListDoctorHBaseRegionServersResponseBodyDataMetricsRegionCount;
  /**
   * @remarks
   * The cumulative number of read requests.
   */
  totalReadRequest?: ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalReadRequest;
  /**
   * @remarks
   * The cumulative number of all requests.
   */
  totalRequest?: ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalRequest;
  /**
   * @remarks
   * The cumulative number of write requests.
   */
  totalWriteRequest?: ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalWriteRequest;
  static names(): { [key: string]: string } {
    return {
      avgGc: 'AvgGc',
      cacheRatio: 'CacheRatio',
      dailyReadRequest: 'DailyReadRequest',
      dailyReadRequestDayGrowthRatio: 'DailyReadRequestDayGrowthRatio',
      dailyWriteRequest: 'DailyWriteRequest',
      dailyWriteRequestDayGrowthRatio: 'DailyWriteRequestDayGrowthRatio',
      regionCount: 'RegionCount',
      totalReadRequest: 'TotalReadRequest',
      totalRequest: 'TotalRequest',
      totalWriteRequest: 'TotalWriteRequest',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgGc: ListDoctorHBaseRegionServersResponseBodyDataMetricsAvgGc,
      cacheRatio: ListDoctorHBaseRegionServersResponseBodyDataMetricsCacheRatio,
      dailyReadRequest: ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyReadRequest,
      dailyReadRequestDayGrowthRatio: ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyReadRequestDayGrowthRatio,
      dailyWriteRequest: ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyWriteRequest,
      dailyWriteRequestDayGrowthRatio: ListDoctorHBaseRegionServersResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio,
      regionCount: ListDoctorHBaseRegionServersResponseBodyDataMetricsRegionCount,
      totalReadRequest: ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalReadRequest,
      totalRequest: ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalRequest,
      totalWriteRequest: ListDoctorHBaseRegionServersResponseBodyDataMetricsTotalWriteRequest,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseRegionServersResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The metric information.
   */
  metrics?: ListDoctorHBaseRegionServersResponseBodyDataMetrics;
  /**
   * @remarks
   * The RegionServer host.
   * 
   * @example
   * emr-worker-4.cluster-20****
   */
  regionServerHost?: string;
  static names(): { [key: string]: string } {
    return {
      metrics: 'Metrics',
      regionServerHost: 'RegionServerHost',
    };
  }

  static types(): { [key: string]: any } {
    return {
      metrics: ListDoctorHBaseRegionServersResponseBodyDataMetrics,
      regionServerHost: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBodyDataAnalysis extends $tea.Model {
  /**
   * @remarks
   * The regions that have read hotspot issues.
   * 
   * @example
   * null
   */
  readRequestHotspotRegionList?: string[];
  /**
   * @remarks
   * The description of read imbalance.
   * 
   * @example
   * read request unbalance is <p class=\\"report-detail-topic\\">
   */
  readRequestUnbalanceSuggestion?: string;
  /**
   * @remarks
   * The regions that have read/write hotspot issues.
   * 
   * @example
   * null
   */
  requestHotspotRegionList?: string[];
  /**
   * @remarks
   * The description of read/write imbalance.
   * 
   * @example
   * read request unbalance is <p class=\\"report-detail-topic\\">
   */
  requestUnbalanceSuggestion?: string;
  /**
   * @remarks
   * The score of the table.
   * 
   * @example
   * 67
   */
  tableScore?: number;
  /**
   * @remarks
   * The regions that have write hotspot issues.
   * 
   * @example
   * null
   */
  writeRequestHotspotRegionList?: string[];
  /**
   * @remarks
   * The description of write imbalance.
   * 
   * @example
   * write request unbalance is <p class=\\"report-detail-topic\\">
   */
  writeRequestUnbalanceSuggestion?: string;
  static names(): { [key: string]: string } {
    return {
      readRequestHotspotRegionList: 'ReadRequestHotspotRegionList',
      readRequestUnbalanceSuggestion: 'ReadRequestUnbalanceSuggestion',
      requestHotspotRegionList: 'RequestHotspotRegionList',
      requestUnbalanceSuggestion: 'RequestUnbalanceSuggestion',
      tableScore: 'TableScore',
      writeRequestHotspotRegionList: 'WriteRequestHotspotRegionList',
      writeRequestUnbalanceSuggestion: 'WriteRequestUnbalanceSuggestion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      readRequestHotspotRegionList: { 'type': 'array', 'itemType': 'string' },
      readRequestUnbalanceSuggestion: 'string',
      requestHotspotRegionList: { 'type': 'array', 'itemType': 'string' },
      requestUnbalanceSuggestion: 'string',
      tableScore: 'number',
      writeRequestHotspotRegionList: { 'type': 'array', 'itemType': 'string' },
      writeRequestUnbalanceSuggestion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBodyDataMetricsColdAccessDay extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Cold access day
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldAccessDay
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * day
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBodyDataMetricsColdConfigDay extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Cold config day
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldConfigDay
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * dat
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBodyDataMetricsColdDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Size of the cold data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 100
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBodyDataMetricsDailyReadRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of read requests per day
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * dailyReadRequest
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * “”
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBodyDataMetricsDailyReadRequestDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of read requests
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * dailyReadRequestDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.8
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBodyDataMetricsDailyWriteRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of write requests per day
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * dailyWriteRequest
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * “”
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * The balance of distributing requests
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * dailyWriteRequestDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.8
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBodyDataMetricsFreezeConfigDay extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Freeze config day
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeConfigDay
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * day
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBodyDataMetricsFreezeDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Size of the freeze data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 100
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBodyDataMetricsHotDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Size of the hot data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 100
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBodyDataMetricsLocality extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * The locality of data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * locality
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBodyDataMetricsReadRequestBalance extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * The balance of distributing read requests
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * readRequestBalance
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1.0
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBodyDataMetricsRegionBalance extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * The ability to evenly distribute Regions on different RegionServer nodes
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * regionBalance
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * “”
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1.0
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBodyDataMetricsRegionCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of regions count
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * regionCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 3
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBodyDataMetricsRegionCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of region count
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * regionCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1.0
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBodyDataMetricsRegionServerCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of region servers count
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * regionServerCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 2
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBodyDataMetricsRequestBalance extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * The balance of distributing requests
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * requestBalance
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * “”
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.9
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBodyDataMetricsStoreFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of store files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * storeFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 36
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBodyDataMetricsStoreFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of store file count
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * storeFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.7
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBodyDataMetricsTableSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Size of the table
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tableSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 678
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBodyDataMetricsTableSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of table size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tableSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * \\""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1.0
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBodyDataMetricsWarmConfigDay extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Warm config day
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmConfigDay
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * day
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBodyDataMetricsWarmDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Size of the warm data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 100
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBodyDataMetricsWriteRequestBalance extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * The balance of distributing write requests
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * writeRequestBalance
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1.0
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBodyDataMetrics extends $tea.Model {
  /**
   * @remarks
   * The number of days during which the table was not accessed.
   */
  coldAccessDay?: ListDoctorHBaseTablesResponseBodyDataMetricsColdAccessDay;
  /**
   * @remarks
   * The number of consecutive days without access to data before the data is considered as very cold data.
   */
  coldConfigDay?: ListDoctorHBaseTablesResponseBodyDataMetricsColdConfigDay;
  /**
   * @remarks
   * The size of cold data.
   */
  coldDataSize?: ListDoctorHBaseTablesResponseBodyDataMetricsColdDataSize;
  /**
   * @remarks
   * The total number of read requests for the table in a day.
   */
  dailyReadRequest?: ListDoctorHBaseTablesResponseBodyDataMetricsDailyReadRequest;
  /**
   * @remarks
   * The daily increment ratio of the number of read requests in a day.
   */
  dailyReadRequestDayGrowthRatio?: ListDoctorHBaseTablesResponseBodyDataMetricsDailyReadRequestDayGrowthRatio;
  /**
   * @remarks
   * The total number of write requests for the table in a day.
   */
  dailyWriteRequest?: ListDoctorHBaseTablesResponseBodyDataMetricsDailyWriteRequest;
  /**
   * @remarks
   * The daily increment ratio of the number of write requests in a day.
   */
  dailyWriteRequestDayGrowthRatio?: ListDoctorHBaseTablesResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio;
  /**
   * @remarks
   * The number of consecutive days without access to data before the data was considered as very cold data.
   */
  freezeConfigDay?: ListDoctorHBaseTablesResponseBodyDataMetricsFreezeConfigDay;
  /**
   * @remarks
   * The size of very cold data.
   */
  freezeDataSize?: ListDoctorHBaseTablesResponseBodyDataMetricsFreezeDataSize;
  /**
   * @remarks
   * The size of hot data.
   */
  hotDataSize?: ListDoctorHBaseTablesResponseBodyDataMetricsHotDataSize;
  /**
   * @remarks
   * The localization rate.
   */
  locality?: ListDoctorHBaseTablesResponseBodyDataMetricsLocality;
  /**
   * @remarks
   * The read balancing degree.
   */
  readRequestBalance?: ListDoctorHBaseTablesResponseBodyDataMetricsReadRequestBalance;
  /**
   * @remarks
   * The balancing degree.
   */
  regionBalance?: ListDoctorHBaseTablesResponseBodyDataMetricsRegionBalance;
  /**
   * @remarks
   * The number of regions that host the table.
   */
  regionCount?: ListDoctorHBaseTablesResponseBodyDataMetricsRegionCount;
  /**
   * @remarks
   * The daily increment ratio of the number of regions.
   */
  regionCountDayGrowthRatio?: ListDoctorHBaseTablesResponseBodyDataMetricsRegionCountDayGrowthRatio;
  /**
   * @remarks
   * The number of region servers that host the table.
   */
  regionServerCount?: ListDoctorHBaseTablesResponseBodyDataMetricsRegionServerCount;
  /**
   * @remarks
   * The request balancing degree.
   */
  requestBalance?: ListDoctorHBaseTablesResponseBodyDataMetricsRequestBalance;
  /**
   * @remarks
   * The number of StoreFiles.
   */
  storeFileCount?: ListDoctorHBaseTablesResponseBodyDataMetricsStoreFileCount;
  /**
   * @remarks
   * The daily increment ratio of the number of StoreFiles.
   */
  storeFileCountDayGrowthRatio?: ListDoctorHBaseTablesResponseBodyDataMetricsStoreFileCountDayGrowthRatio;
  /**
   * @remarks
   * The size of the table.
   */
  tableSize?: ListDoctorHBaseTablesResponseBodyDataMetricsTableSize;
  /**
   * @remarks
   * The daily increment ratio of the table size.
   */
  tableSizeDayGrowthRatio?: ListDoctorHBaseTablesResponseBodyDataMetricsTableSizeDayGrowthRatio;
  /**
   * @remarks
   * The number of consecutive days without access to data before the data is considered as cold data.
   */
  warmConfigDay?: ListDoctorHBaseTablesResponseBodyDataMetricsWarmConfigDay;
  /**
   * @remarks
   * The size of warm data.
   */
  warmDataSize?: ListDoctorHBaseTablesResponseBodyDataMetricsWarmDataSize;
  /**
   * @remarks
   * The write balancing degree.
   */
  writeRequestBalance?: ListDoctorHBaseTablesResponseBodyDataMetricsWriteRequestBalance;
  static names(): { [key: string]: string } {
    return {
      coldAccessDay: 'ColdAccessDay',
      coldConfigDay: 'ColdConfigDay',
      coldDataSize: 'ColdDataSize',
      dailyReadRequest: 'DailyReadRequest',
      dailyReadRequestDayGrowthRatio: 'DailyReadRequestDayGrowthRatio',
      dailyWriteRequest: 'DailyWriteRequest',
      dailyWriteRequestDayGrowthRatio: 'DailyWriteRequestDayGrowthRatio',
      freezeConfigDay: 'FreezeConfigDay',
      freezeDataSize: 'FreezeDataSize',
      hotDataSize: 'HotDataSize',
      locality: 'Locality',
      readRequestBalance: 'ReadRequestBalance',
      regionBalance: 'RegionBalance',
      regionCount: 'RegionCount',
      regionCountDayGrowthRatio: 'RegionCountDayGrowthRatio',
      regionServerCount: 'RegionServerCount',
      requestBalance: 'RequestBalance',
      storeFileCount: 'StoreFileCount',
      storeFileCountDayGrowthRatio: 'StoreFileCountDayGrowthRatio',
      tableSize: 'TableSize',
      tableSizeDayGrowthRatio: 'TableSizeDayGrowthRatio',
      warmConfigDay: 'WarmConfigDay',
      warmDataSize: 'WarmDataSize',
      writeRequestBalance: 'WriteRequestBalance',
    };
  }

  static types(): { [key: string]: any } {
    return {
      coldAccessDay: ListDoctorHBaseTablesResponseBodyDataMetricsColdAccessDay,
      coldConfigDay: ListDoctorHBaseTablesResponseBodyDataMetricsColdConfigDay,
      coldDataSize: ListDoctorHBaseTablesResponseBodyDataMetricsColdDataSize,
      dailyReadRequest: ListDoctorHBaseTablesResponseBodyDataMetricsDailyReadRequest,
      dailyReadRequestDayGrowthRatio: ListDoctorHBaseTablesResponseBodyDataMetricsDailyReadRequestDayGrowthRatio,
      dailyWriteRequest: ListDoctorHBaseTablesResponseBodyDataMetricsDailyWriteRequest,
      dailyWriteRequestDayGrowthRatio: ListDoctorHBaseTablesResponseBodyDataMetricsDailyWriteRequestDayGrowthRatio,
      freezeConfigDay: ListDoctorHBaseTablesResponseBodyDataMetricsFreezeConfigDay,
      freezeDataSize: ListDoctorHBaseTablesResponseBodyDataMetricsFreezeDataSize,
      hotDataSize: ListDoctorHBaseTablesResponseBodyDataMetricsHotDataSize,
      locality: ListDoctorHBaseTablesResponseBodyDataMetricsLocality,
      readRequestBalance: ListDoctorHBaseTablesResponseBodyDataMetricsReadRequestBalance,
      regionBalance: ListDoctorHBaseTablesResponseBodyDataMetricsRegionBalance,
      regionCount: ListDoctorHBaseTablesResponseBodyDataMetricsRegionCount,
      regionCountDayGrowthRatio: ListDoctorHBaseTablesResponseBodyDataMetricsRegionCountDayGrowthRatio,
      regionServerCount: ListDoctorHBaseTablesResponseBodyDataMetricsRegionServerCount,
      requestBalance: ListDoctorHBaseTablesResponseBodyDataMetricsRequestBalance,
      storeFileCount: ListDoctorHBaseTablesResponseBodyDataMetricsStoreFileCount,
      storeFileCountDayGrowthRatio: ListDoctorHBaseTablesResponseBodyDataMetricsStoreFileCountDayGrowthRatio,
      tableSize: ListDoctorHBaseTablesResponseBodyDataMetricsTableSize,
      tableSizeDayGrowthRatio: ListDoctorHBaseTablesResponseBodyDataMetricsTableSizeDayGrowthRatio,
      warmConfigDay: ListDoctorHBaseTablesResponseBodyDataMetricsWarmConfigDay,
      warmDataSize: ListDoctorHBaseTablesResponseBodyDataMetricsWarmDataSize,
      writeRequestBalance: ListDoctorHBaseTablesResponseBodyDataMetricsWriteRequestBalance,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHBaseTablesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The diagnosis result.
   */
  analysis?: ListDoctorHBaseTablesResponseBodyDataAnalysis;
  /**
   * @remarks
   * The metric information.
   */
  metrics?: ListDoctorHBaseTablesResponseBodyDataMetrics;
  /**
   * @remarks
   * The name of the table.
   * 
   * @example
   * tb_item
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      analysis: 'Analysis',
      metrics: 'Metrics',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      analysis: ListDoctorHBaseTablesResponseBodyDataAnalysis,
      metrics: ListDoctorHBaseTablesResponseBodyDataMetrics,
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataDayGrowthSize extends $tea.Model {
  /**
   * @example
   * Day growth size of cold data
   */
  description?: string;
  /**
   * @example
   * coldDataDayGrowthSize
   */
  name?: string;
  /**
   * @example
   * MB
   */
  unit?: string;
  /**
   * @example
   * -182636577752
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataSize extends $tea.Model {
  /**
   * @example
   * Size of the cold data size
   */
  description?: string;
  /**
   * @example
   * coldDataSize
   */
  name?: string;
  /**
   * @example
   * MB
   */
  unit?: string;
  /**
   * @example
   * 5570958082267
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @example
   * Day growth ratio of cold data size
   */
  description?: string;
  /**
   * @example
   * coldDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @example
   * -0.03
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileCount extends $tea.Model {
  /**
   * @example
   * Number of empty files
   */
  description?: string;
  /**
   * @example
   * emptyFileCount
   */
  name?: string;
  /**
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @example
   * 15595897
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @example
   * Day growth ratio of empty files
   */
  description?: string;
  /**
   * @example
   * emptyFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @example
   * 0.005
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileDayGrowthCount extends $tea.Model {
  /**
   * @example
   * Day growth count of empty files
   */
  description?: string;
  /**
   * @example
   * emptyFileDayGrowthCount
   */
  name?: string;
  /**
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @example
   * 114
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataDayGrowthSize extends $tea.Model {
  /**
   * @example
   * Day growth size of freeze data
   */
  description?: string;
  /**
   * @example
   * freezeDataDayGrowthSize
   */
  name?: string;
  /**
   * @example
   * MB
   */
  unit?: string;
  /**
   * @example
   * -167683929450
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataSize extends $tea.Model {
  /**
   * @example
   * Size of the freeze data size
   */
  description?: string;
  /**
   * @example
   * freezeDataSize
   */
  name?: string;
  /**
   * @example
   * MB
   */
  unit?: string;
  /**
   * @example
   * 1231312431
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @example
   * Day growth ratio of freeze data size
   */
  description?: string;
  /**
   * @example
   * freezeDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @example
   * -0.09
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataDayGrowthSize extends $tea.Model {
  /**
   * @example
   * Day growth size of hot data
   */
  description?: string;
  /**
   * @example
   * hotDataDayGrowthSize
   */
  name?: string;
  /**
   * @example
   * MB
   */
  unit?: string;
  /**
   * @example
   * 123154
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataSize extends $tea.Model {
  /**
   * @example
   * Size of the hot data size
   */
  description?: string;
  /**
   * @example
   * hotDataSize
   */
  name?: string;
  /**
   * @example
   * MB
   */
  unit?: string;
  /**
   * @example
   * 6701531944206
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @example
   * Day growth ratio of hot data size
   */
  description?: string;
  /**
   * @example
   * hotDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @example
   * 0.1114
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileCount extends $tea.Model {
  /**
   * @example
   * Number of large files
   */
  description?: string;
  /**
   * @example
   * largeFileCount
   */
  name?: string;
  /**
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @example
   * 123
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @example
   * Day growth ratio of large files
   */
  description?: string;
  /**
   * @example
   * largeFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @example
   * 0.39
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileDayGrowthCount extends $tea.Model {
  /**
   * @example
   * Day growth count of large files
   */
  description?: string;
  /**
   * @example
   * largeFileDayGrowthCount
   */
  name?: string;
  /**
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @example
   * 2
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileCount extends $tea.Model {
  /**
   * @example
   * Number of medium files
   */
  description?: string;
  /**
   * @example
   * mediumFileCount
   */
  name?: string;
  /**
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @example
   * 323
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @example
   * Day growth ratio of medium files
   */
  description?: string;
  /**
   * @example
   * mediumFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @example
   * 0.19
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileDayGrowthCount extends $tea.Model {
  /**
   * @example
   * Day growth count of medium files
   */
  description?: string;
  /**
   * @example
   * mediumFileDayGrowthCount
   */
  name?: string;
  /**
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @example
   * 176
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileCount extends $tea.Model {
  /**
   * @example
   * Number of small files
   */
  description?: string;
  /**
   * @example
   * smallFileCount
   */
  name?: string;
  /**
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @example
   * 12345
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @example
   * Day growth ratio of small files
   */
  description?: string;
  /**
   * @example
   * smallFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @example
   * 0.02
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileDayGrowthCount extends $tea.Model {
  /**
   * @example
   * Day growth count of small files
   */
  description?: string;
  /**
   * @example
   * smallFileDayGrowthCount
   */
  name?: string;
  /**
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @example
   * 12345
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileCount extends $tea.Model {
  /**
   * @example
   * Number of tiny files
   */
  description?: string;
  /**
   * @example
   * tinyFileCount
   */
  name?: string;
  /**
   * @example
   * ""
   */
  unit?: string;
  /**
   * @example
   * 232131
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @example
   * Day growth ratio of tiny files
   */
  description?: string;
  /**
   * @example
   * tinyFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @example
   * 0.003
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileDayGrowthCount extends $tea.Model {
  /**
   * @example
   * Day growth count of tiny files
   */
  description?: string;
  /**
   * @example
   * tinyFileDayGrowthCount
   */
  name?: string;
  /**
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @example
   * -123
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataDayGrowthSize extends $tea.Model {
  /**
   * @example
   * Day growth size of total data
   */
  description?: string;
  /**
   * @example
   * totalDataDayGrowthSize
   */
  name?: string;
  /**
   * @example
   * MB
   */
  unit?: string;
  /**
   * @example
   * 256482228248
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataSize extends $tea.Model {
  /**
   * @example
   * Total data size in megabytes (MB)
   */
  description?: string;
  /**
   * @example
   * totalDataSize
   */
  name?: string;
  /**
   * @example
   * MB
   */
  unit?: string;
  /**
   * @example
   * 62086342083623
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @example
   * Day growth ratio of total data size
   */
  description?: string;
  /**
   * @example
   * totalDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @example
   * 0.14
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileCount extends $tea.Model {
  /**
   * @example
   * Number of total files
   */
  description?: string;
  /**
   * @example
   * totalFileCount
   */
  name?: string;
  /**
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @example
   * 51683279
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @example
   * Day growth ratio of total files
   */
  description?: string;
  /**
   * @example
   * totalFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @example
   * 0.02
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileDayGrowthCount extends $tea.Model {
  /**
   * @example
   * Day growth count of total files
   */
  description?: string;
  /**
   * @example
   * totalFileDayGrowthCount
   */
  name?: string;
  /**
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @example
   * 27809
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataDayGrowthSize extends $tea.Model {
  /**
   * @example
   * Day growth size of warm data
   */
  description?: string;
  /**
   * @example
   * warmDataDayGrowthSize
   */
  name?: string;
  /**
   * @example
   * MB
   */
  unit?: string;
  /**
   * @example
   * -64806998319
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataSize extends $tea.Model {
  /**
   * @example
   * Size of the warm data size
   */
  description?: string;
  /**
   * @example
   * warmDataSize
   */
  name?: string;
  /**
   * @example
   * MB
   */
  unit?: string;
  /**
   * @example
   * 4062349775577
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @example
   * Day growth ratio of warm data size
   */
  description?: string;
  /**
   * @example
   * warmDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @example
   * -0.015
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyDataMetrics extends $tea.Model {
  coldDataDayGrowthSize?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataDayGrowthSize;
  coldDataSize?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataSize;
  coldDataSizeDayGrowthRatio?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataSizeDayGrowthRatio;
  emptyFileCount?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileCount;
  emptyFileCountDayGrowthRatio?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio;
  emptyFileDayGrowthCount?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileDayGrowthCount;
  freezeDataDayGrowthSize?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataDayGrowthSize;
  freezeDataSize?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataSize;
  freezeDataSizeDayGrowthRatio?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio;
  hotDataDayGrowthSize?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataDayGrowthSize;
  hotDataSize?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataSize;
  hotDataSizeDayGrowthRatio?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataSizeDayGrowthRatio;
  largeFileCount?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileCount;
  largeFileCountDayGrowthRatio?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileCountDayGrowthRatio;
  largeFileDayGrowthCount?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileDayGrowthCount;
  mediumFileCount?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileCount;
  mediumFileCountDayGrowthRatio?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileCountDayGrowthRatio;
  mediumFileDayGrowthCount?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileDayGrowthCount;
  smallFileCount?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileCount;
  smallFileCountDayGrowthRatio?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileCountDayGrowthRatio;
  smallFileDayGrowthCount?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileDayGrowthCount;
  tinyFileCount?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileCount;
  tinyFileCountDayGrowthRatio?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileCountDayGrowthRatio;
  tinyFileDayGrowthCount?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileDayGrowthCount;
  totalDataDayGrowthSize?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataDayGrowthSize;
  totalDataSize?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataSize;
  totalDataSizeDayGrowthRatio?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio;
  totalFileCount?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileCount;
  totalFileCountDayGrowthRatio?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileCountDayGrowthRatio;
  totalFileDayGrowthCount?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileDayGrowthCount;
  warmDataDayGrowthSize?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataDayGrowthSize;
  warmDataSize?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataSize;
  warmDataSizeDayGrowthRatio?: ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio;
  static names(): { [key: string]: string } {
    return {
      coldDataDayGrowthSize: 'ColdDataDayGrowthSize',
      coldDataSize: 'ColdDataSize',
      coldDataSizeDayGrowthRatio: 'ColdDataSizeDayGrowthRatio',
      emptyFileCount: 'EmptyFileCount',
      emptyFileCountDayGrowthRatio: 'EmptyFileCountDayGrowthRatio',
      emptyFileDayGrowthCount: 'EmptyFileDayGrowthCount',
      freezeDataDayGrowthSize: 'FreezeDataDayGrowthSize',
      freezeDataSize: 'FreezeDataSize',
      freezeDataSizeDayGrowthRatio: 'FreezeDataSizeDayGrowthRatio',
      hotDataDayGrowthSize: 'HotDataDayGrowthSize',
      hotDataSize: 'HotDataSize',
      hotDataSizeDayGrowthRatio: 'HotDataSizeDayGrowthRatio',
      largeFileCount: 'LargeFileCount',
      largeFileCountDayGrowthRatio: 'LargeFileCountDayGrowthRatio',
      largeFileDayGrowthCount: 'LargeFileDayGrowthCount',
      mediumFileCount: 'MediumFileCount',
      mediumFileCountDayGrowthRatio: 'MediumFileCountDayGrowthRatio',
      mediumFileDayGrowthCount: 'MediumFileDayGrowthCount',
      smallFileCount: 'SmallFileCount',
      smallFileCountDayGrowthRatio: 'SmallFileCountDayGrowthRatio',
      smallFileDayGrowthCount: 'SmallFileDayGrowthCount',
      tinyFileCount: 'TinyFileCount',
      tinyFileCountDayGrowthRatio: 'TinyFileCountDayGrowthRatio',
      tinyFileDayGrowthCount: 'TinyFileDayGrowthCount',
      totalDataDayGrowthSize: 'TotalDataDayGrowthSize',
      totalDataSize: 'TotalDataSize',
      totalDataSizeDayGrowthRatio: 'TotalDataSizeDayGrowthRatio',
      totalFileCount: 'TotalFileCount',
      totalFileCountDayGrowthRatio: 'TotalFileCountDayGrowthRatio',
      totalFileDayGrowthCount: 'TotalFileDayGrowthCount',
      warmDataDayGrowthSize: 'WarmDataDayGrowthSize',
      warmDataSize: 'WarmDataSize',
      warmDataSizeDayGrowthRatio: 'WarmDataSizeDayGrowthRatio',
    };
  }

  static types(): { [key: string]: any } {
    return {
      coldDataDayGrowthSize: ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataDayGrowthSize,
      coldDataSize: ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataSize,
      coldDataSizeDayGrowthRatio: ListDoctorHDFSDirectoriesResponseBodyDataMetricsColdDataSizeDayGrowthRatio,
      emptyFileCount: ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileCount,
      emptyFileCountDayGrowthRatio: ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio,
      emptyFileDayGrowthCount: ListDoctorHDFSDirectoriesResponseBodyDataMetricsEmptyFileDayGrowthCount,
      freezeDataDayGrowthSize: ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataDayGrowthSize,
      freezeDataSize: ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataSize,
      freezeDataSizeDayGrowthRatio: ListDoctorHDFSDirectoriesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio,
      hotDataDayGrowthSize: ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataDayGrowthSize,
      hotDataSize: ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataSize,
      hotDataSizeDayGrowthRatio: ListDoctorHDFSDirectoriesResponseBodyDataMetricsHotDataSizeDayGrowthRatio,
      largeFileCount: ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileCount,
      largeFileCountDayGrowthRatio: ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileCountDayGrowthRatio,
      largeFileDayGrowthCount: ListDoctorHDFSDirectoriesResponseBodyDataMetricsLargeFileDayGrowthCount,
      mediumFileCount: ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileCount,
      mediumFileCountDayGrowthRatio: ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileCountDayGrowthRatio,
      mediumFileDayGrowthCount: ListDoctorHDFSDirectoriesResponseBodyDataMetricsMediumFileDayGrowthCount,
      smallFileCount: ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileCount,
      smallFileCountDayGrowthRatio: ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileCountDayGrowthRatio,
      smallFileDayGrowthCount: ListDoctorHDFSDirectoriesResponseBodyDataMetricsSmallFileDayGrowthCount,
      tinyFileCount: ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileCount,
      tinyFileCountDayGrowthRatio: ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileCountDayGrowthRatio,
      tinyFileDayGrowthCount: ListDoctorHDFSDirectoriesResponseBodyDataMetricsTinyFileDayGrowthCount,
      totalDataDayGrowthSize: ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataDayGrowthSize,
      totalDataSize: ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataSize,
      totalDataSizeDayGrowthRatio: ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio,
      totalFileCount: ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileCount,
      totalFileCountDayGrowthRatio: ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileCountDayGrowthRatio,
      totalFileDayGrowthCount: ListDoctorHDFSDirectoriesResponseBodyDataMetricsTotalFileDayGrowthCount,
      warmDataDayGrowthSize: ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataDayGrowthSize,
      warmDataSize: ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataSize,
      warmDataSizeDayGrowthRatio: ListDoctorHDFSDirectoriesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSDirectoriesResponseBodyData extends $tea.Model {
  /**
   * @example
   * 2
   */
  depth?: number;
  /**
   * @example
   * /tmp/test
   */
  dirPath?: string;
  /**
   * @example
   * DW
   */
  group?: string;
  metrics?: ListDoctorHDFSDirectoriesResponseBodyDataMetrics;
  /**
   * @example
   * DW
   */
  user?: string;
  static names(): { [key: string]: string } {
    return {
      depth: 'Depth',
      dirPath: 'DirPath',
      group: 'Group',
      metrics: 'Metrics',
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      depth: 'number',
      dirPath: 'string',
      group: 'string',
      metrics: ListDoctorHDFSDirectoriesResponseBodyDataMetrics,
      user: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSUGIResponseBodyDataMetricsTotalDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total data size in megabytes (MB)
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 40440503
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSUGIResponseBodyDataMetricsTotalDirCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of total dirs
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalDirCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 123
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSUGIResponseBodyDataMetricsTotalFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of total files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 34
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSUGIResponseBodyDataMetrics extends $tea.Model {
  /**
   * @remarks
   * The total data size.
   */
  totalDataSize?: ListDoctorHDFSUGIResponseBodyDataMetricsTotalDataSize;
  /**
   * @remarks
   * The total number of directories.
   */
  totalDirCount?: ListDoctorHDFSUGIResponseBodyDataMetricsTotalDirCount;
  /**
   * @remarks
   * The total number of files.
   */
  totalFileCount?: ListDoctorHDFSUGIResponseBodyDataMetricsTotalFileCount;
  static names(): { [key: string]: string } {
    return {
      totalDataSize: 'TotalDataSize',
      totalDirCount: 'TotalDirCount',
      totalFileCount: 'TotalFileCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalDataSize: ListDoctorHDFSUGIResponseBodyDataMetricsTotalDataSize,
      totalDirCount: ListDoctorHDFSUGIResponseBodyDataMetricsTotalDirCount,
      totalFileCount: ListDoctorHDFSUGIResponseBodyDataMetricsTotalFileCount,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHDFSUGIResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The metric information.
   */
  metrics?: ListDoctorHDFSUGIResponseBodyDataMetrics;
  /**
   * @remarks
   * The actual name of the owner or group returned based on the value of Type.
   * 
   * @example
   * DW
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      metrics: 'Metrics',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      metrics: ListDoctorHDFSUGIResponseBodyDataMetrics,
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataAnalysis extends $tea.Model {
  /**
   * @remarks
   * The score for the distribution of files of different sizes stored in the Hive database.
   * 
   * @example
   * 85
   */
  hiveDistributionScore?: number;
  /**
   * @remarks
   * The score for the distribution of files stored in different formats in the Hive database.
   * 
   * @example
   * 85
   */
  hiveFormatScore?: number;
  /**
   * @remarks
   * The score for the access frequency of the Hive database.
   * 
   * @example
   * 85
   */
  hiveFrequencyScore?: number;
  /**
   * @remarks
   * The overall score of the Hive database.
   * 
   * @example
   * 85
   */
  hiveScore?: number;
  static names(): { [key: string]: string } {
    return {
      hiveDistributionScore: 'HiveDistributionScore',
      hiveFormatScore: 'HiveFormatScore',
      hiveFrequencyScore: 'HiveFrequencyScore',
      hiveScore: 'HiveScore',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hiveDistributionScore: 'number',
      hiveFormatScore: 'number',
      hiveFrequencyScore: 'number',
      hiveScore: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataFormats extends $tea.Model {
  /**
   * @remarks
   * The daily increment of storage format-specific data.
   * 
   * @example
   * 1000
   */
  formatDayGrowthSize?: number;
  /**
   * @remarks
   * The name of the storage format.
   * 
   * @example
   * TextInputFormat
   */
  formatName?: string;
  /**
   * @remarks
   * The proportion of data in a specific storage format.
   * 
   * @example
   * 0.5
   */
  formatRatio?: number;
  /**
   * @remarks
   * The amount of storage format-specific data.
   * 
   * @example
   * 1000
   */
  formatSize?: number;
  /**
   * @remarks
   * The day-to-day growth rate of storage format-specific data.
   * 
   * @example
   * 0.5
   */
  formatSizeDayGrowthRatio?: number;
  /**
   * @remarks
   * The unit of the amount of storage format-specific data.
   * 
   * @example
   * MB
   */
  formatSizeUnit?: string;
  static names(): { [key: string]: string } {
    return {
      formatDayGrowthSize: 'FormatDayGrowthSize',
      formatName: 'FormatName',
      formatRatio: 'FormatRatio',
      formatSize: 'FormatSize',
      formatSizeDayGrowthRatio: 'FormatSizeDayGrowthRatio',
      formatSizeUnit: 'FormatSizeUnit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      formatDayGrowthSize: 'number',
      formatName: 'string',
      formatRatio: 'number',
      formatSize: 'number',
      formatSizeDayGrowthRatio: 'number',
      formatSizeUnit: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of cold data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Cold data ratio
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of cold files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of cold data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of empty files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * emptyFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of empty files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * emptyFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of empty files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * emptyFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of empty files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * emptyFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of freeze data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of freeze data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of freeze files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of freeze data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of hot data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Hot data ratio
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of hot files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of hot data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of large files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * largeFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * “”
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of large files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * largeFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of large files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * largeFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of large files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * largeFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of medium files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * mediumFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of medium files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * mediumFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of medium files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * mediumFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of medium files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * mediumFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsPartitionNum extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of partitions
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * ppartitionNum
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of small files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * smallFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of small files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * smallFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of small files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * smallFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of small files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * smallFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsTableCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of tables
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * TableCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of tiny files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tinyFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of tiny files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tinyFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of tiny files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tinyFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of tiny files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tinyFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of total data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total data size in megabytes (MB)
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of total data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of total files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of total files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of total files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of warm data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of warm data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmDataRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of warm files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 1000
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of warm data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * WarmDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyDataMetrics extends $tea.Model {
  /**
   * @remarks
   * The daily increment of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in 90 days.
   */
  coldDataDayGrowthSize?: ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataDayGrowthSize;
  /**
   * @remarks
   * The proportion of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in 90 days.
   */
  coldDataRatio?: ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataRatio;
  /**
   * @remarks
   * The amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in 90 days.
   */
  coldDataSize?: ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in 90 days.
   */
  coldDataSizeDayGrowthRatio?: ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The number of empty files. Empty files are those with a size of 0 MB.
   */
  emptyFileCount?: ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of empty files. Empty files are those with a size of 0 MB.
   */
  emptyFileCountDayGrowthRatio?: ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of empty files. Empty files are those with a size of 0 MB.
   */
  emptyFileDayGrowthCount?: ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of empty files. Empty files are those with a size of 0 MB.
   */
  emptyFileRatio?: ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileRatio;
  /**
   * @remarks
   * The daily increment of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   */
  freezeDataDayGrowthSize?: ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataDayGrowthSize;
  /**
   * @remarks
   * The proportion of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   */
  freezeDataRatio?: ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataRatio;
  /**
   * @remarks
   * The amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   */
  freezeDataSize?: ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   */
  freezeDataSizeDayGrowthRatio?: ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the amount of hot data. Hot data refers to data that is accessed in recent seven days.
   */
  hotDataDayGrowthSize?: ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataDayGrowthSize;
  /**
   * @remarks
   * The proportion of hot data. Hot data refers to data that is accessed in recent seven days.
   */
  hotDataRatio?: ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataRatio;
  /**
   * @remarks
   * The amount of hot data. Hot data refers to data that is accessed in recent seven days.
   */
  hotDataSize?: ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of hot data. Hot data refers to data that is accessed in recent seven days.
   */
  hotDataSizeDayGrowthRatio?: ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The number of large files. Large files are those with a size greater than 1 GB.
   */
  largeFileCount?: ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of large files. Large files are those with a size greater than 1 GB.
   */
  largeFileCountDayGrowthRatio?: ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of large files. Large files are those with a size greater than 1 GB.
   */
  largeFileDayGrowthCount?: ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of large files. Large files are those with a size greater than 1 GB.
   */
  largeFileRatio?: ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileRatio;
  /**
   * @remarks
   * The number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   */
  mediumFileCount?: ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   */
  mediumFileCountDayGrowthRatio?: ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   */
  mediumFileDayGrowthCount?: ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   */
  mediumFileRatio?: ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileRatio;
  /**
   * @remarks
   * The number of partitions.
   */
  partitionNum?: ListDoctorHiveDatabasesResponseBodyDataMetricsPartitionNum;
  /**
   * @remarks
   * The number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   */
  smallFileCount?: ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   */
  smallFileCountDayGrowthRatio?: ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   */
  smallFileDayGrowthCount?: ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   */
  smallFileRatio?: ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileRatio;
  /**
   * @remarks
   * The number of tables.
   */
  tableCount?: ListDoctorHiveDatabasesResponseBodyDataMetricsTableCount;
  /**
   * @remarks
   * The number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   */
  tinyFileCount?: ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   */
  tinyFileCountDayGrowthRatio?: ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   */
  tinyFileDayGrowthCount?: ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   */
  tinyFileRatio?: ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileRatio;
  /**
   * @remarks
   * The daily incremental of the total data volume.
   */
  totalDataDayGrowthSize?: ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataDayGrowthSize;
  /**
   * @remarks
   * The total amount of data.
   */
  totalDataSize?: ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the total data volume.
   */
  totalDataSizeDayGrowthRatio?: ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The total number of files.
   */
  totalFileCount?: ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the total number of files.
   */
  totalFileCountDayGrowthRatio?: ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the total number of files.
   */
  totalFileDayGrowthCount?: ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileDayGrowthCount;
  /**
   * @remarks
   * The daily increment of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in 30 days.
   */
  warmDataDayGrowthSize?: ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataDayGrowthSize;
  /**
   * @remarks
   * The proportion of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in 30 days.
   */
  warmDataRatio?: ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataRatio;
  /**
   * @remarks
   * The amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in 30 days.
   */
  warmDataSize?: ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in 30 days.
   */
  warmDataSizeDayGrowthRatio?: ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio;
  static names(): { [key: string]: string } {
    return {
      coldDataDayGrowthSize: 'ColdDataDayGrowthSize',
      coldDataRatio: 'ColdDataRatio',
      coldDataSize: 'ColdDataSize',
      coldDataSizeDayGrowthRatio: 'ColdDataSizeDayGrowthRatio',
      emptyFileCount: 'EmptyFileCount',
      emptyFileCountDayGrowthRatio: 'EmptyFileCountDayGrowthRatio',
      emptyFileDayGrowthCount: 'EmptyFileDayGrowthCount',
      emptyFileRatio: 'EmptyFileRatio',
      freezeDataDayGrowthSize: 'FreezeDataDayGrowthSize',
      freezeDataRatio: 'FreezeDataRatio',
      freezeDataSize: 'FreezeDataSize',
      freezeDataSizeDayGrowthRatio: 'FreezeDataSizeDayGrowthRatio',
      hotDataDayGrowthSize: 'HotDataDayGrowthSize',
      hotDataRatio: 'HotDataRatio',
      hotDataSize: 'HotDataSize',
      hotDataSizeDayGrowthRatio: 'HotDataSizeDayGrowthRatio',
      largeFileCount: 'LargeFileCount',
      largeFileCountDayGrowthRatio: 'LargeFileCountDayGrowthRatio',
      largeFileDayGrowthCount: 'LargeFileDayGrowthCount',
      largeFileRatio: 'LargeFileRatio',
      mediumFileCount: 'MediumFileCount',
      mediumFileCountDayGrowthRatio: 'MediumFileCountDayGrowthRatio',
      mediumFileDayGrowthCount: 'MediumFileDayGrowthCount',
      mediumFileRatio: 'MediumFileRatio',
      partitionNum: 'PartitionNum',
      smallFileCount: 'SmallFileCount',
      smallFileCountDayGrowthRatio: 'SmallFileCountDayGrowthRatio',
      smallFileDayGrowthCount: 'SmallFileDayGrowthCount',
      smallFileRatio: 'SmallFileRatio',
      tableCount: 'TableCount',
      tinyFileCount: 'TinyFileCount',
      tinyFileCountDayGrowthRatio: 'TinyFileCountDayGrowthRatio',
      tinyFileDayGrowthCount: 'TinyFileDayGrowthCount',
      tinyFileRatio: 'TinyFileRatio',
      totalDataDayGrowthSize: 'TotalDataDayGrowthSize',
      totalDataSize: 'TotalDataSize',
      totalDataSizeDayGrowthRatio: 'TotalDataSizeDayGrowthRatio',
      totalFileCount: 'TotalFileCount',
      totalFileCountDayGrowthRatio: 'TotalFileCountDayGrowthRatio',
      totalFileDayGrowthCount: 'TotalFileDayGrowthCount',
      warmDataDayGrowthSize: 'WarmDataDayGrowthSize',
      warmDataRatio: 'WarmDataRatio',
      warmDataSize: 'WarmDataSize',
      warmDataSizeDayGrowthRatio: 'WarmDataSizeDayGrowthRatio',
    };
  }

  static types(): { [key: string]: any } {
    return {
      coldDataDayGrowthSize: ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataDayGrowthSize,
      coldDataRatio: ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataRatio,
      coldDataSize: ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataSize,
      coldDataSizeDayGrowthRatio: ListDoctorHiveDatabasesResponseBodyDataMetricsColdDataSizeDayGrowthRatio,
      emptyFileCount: ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileCount,
      emptyFileCountDayGrowthRatio: ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio,
      emptyFileDayGrowthCount: ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileDayGrowthCount,
      emptyFileRatio: ListDoctorHiveDatabasesResponseBodyDataMetricsEmptyFileRatio,
      freezeDataDayGrowthSize: ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataDayGrowthSize,
      freezeDataRatio: ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataRatio,
      freezeDataSize: ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataSize,
      freezeDataSizeDayGrowthRatio: ListDoctorHiveDatabasesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio,
      hotDataDayGrowthSize: ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataDayGrowthSize,
      hotDataRatio: ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataRatio,
      hotDataSize: ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataSize,
      hotDataSizeDayGrowthRatio: ListDoctorHiveDatabasesResponseBodyDataMetricsHotDataSizeDayGrowthRatio,
      largeFileCount: ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileCount,
      largeFileCountDayGrowthRatio: ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileCountDayGrowthRatio,
      largeFileDayGrowthCount: ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileDayGrowthCount,
      largeFileRatio: ListDoctorHiveDatabasesResponseBodyDataMetricsLargeFileRatio,
      mediumFileCount: ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileCount,
      mediumFileCountDayGrowthRatio: ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileCountDayGrowthRatio,
      mediumFileDayGrowthCount: ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileDayGrowthCount,
      mediumFileRatio: ListDoctorHiveDatabasesResponseBodyDataMetricsMediumFileRatio,
      partitionNum: ListDoctorHiveDatabasesResponseBodyDataMetricsPartitionNum,
      smallFileCount: ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileCount,
      smallFileCountDayGrowthRatio: ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileCountDayGrowthRatio,
      smallFileDayGrowthCount: ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileDayGrowthCount,
      smallFileRatio: ListDoctorHiveDatabasesResponseBodyDataMetricsSmallFileRatio,
      tableCount: ListDoctorHiveDatabasesResponseBodyDataMetricsTableCount,
      tinyFileCount: ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileCount,
      tinyFileCountDayGrowthRatio: ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileCountDayGrowthRatio,
      tinyFileDayGrowthCount: ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileDayGrowthCount,
      tinyFileRatio: ListDoctorHiveDatabasesResponseBodyDataMetricsTinyFileRatio,
      totalDataDayGrowthSize: ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataDayGrowthSize,
      totalDataSize: ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataSize,
      totalDataSizeDayGrowthRatio: ListDoctorHiveDatabasesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio,
      totalFileCount: ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileCount,
      totalFileCountDayGrowthRatio: ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileCountDayGrowthRatio,
      totalFileDayGrowthCount: ListDoctorHiveDatabasesResponseBodyDataMetricsTotalFileDayGrowthCount,
      warmDataDayGrowthSize: ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataDayGrowthSize,
      warmDataRatio: ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataRatio,
      warmDataSize: ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataSize,
      warmDataSizeDayGrowthRatio: ListDoctorHiveDatabasesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveDatabasesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The analysis results.
   */
  analysis?: ListDoctorHiveDatabasesResponseBodyDataAnalysis;
  /**
   * @remarks
   * The database name.
   * 
   * @example
   * db1
   */
  databaseName?: string;
  /**
   * @remarks
   * The information from the perspective of storage formats.
   */
  formats?: ListDoctorHiveDatabasesResponseBodyDataFormats[];
  /**
   * @remarks
   * The metric information.
   */
  metrics?: ListDoctorHiveDatabasesResponseBodyDataMetrics;
  static names(): { [key: string]: string } {
    return {
      analysis: 'Analysis',
      databaseName: 'DatabaseName',
      formats: 'Formats',
      metrics: 'Metrics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      analysis: ListDoctorHiveDatabasesResponseBodyDataAnalysis,
      databaseName: 'string',
      formats: { 'type': 'array', 'itemType': ListDoctorHiveDatabasesResponseBodyDataFormats },
      metrics: ListDoctorHiveDatabasesResponseBodyDataMetrics,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataAnalysis extends $tea.Model {
  /**
   * @remarks
   * The score for the file sizes of the Hive table.
   * 
   * @example
   * 80
   */
  hiveDistributionScore?: number;
  /**
   * @remarks
   * The score for the data formats of the Hive table.
   * 
   * @example
   * 60
   */
  hiveFormatScore?: number;
  /**
   * @remarks
   * The score for the access frequency of the Hive table.
   * 
   * @example
   * 70
   */
  hiveFrequencyScore?: number;
  /**
   * @remarks
   * The overall score of the Hive table.
   * 
   * @example
   * 80
   */
  hiveScore?: number;
  static names(): { [key: string]: string } {
    return {
      hiveDistributionScore: 'HiveDistributionScore',
      hiveFormatScore: 'HiveFormatScore',
      hiveFrequencyScore: 'HiveFrequencyScore',
      hiveScore: 'HiveScore',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hiveDistributionScore: 'number',
      hiveFormatScore: 'number',
      hiveFrequencyScore: 'number',
      hiveScore: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataFormats extends $tea.Model {
  /**
   * @remarks
   * The daily increment of data in the format.
   * 
   * @example
   * 1232124
   */
  formatDayGrowthSize?: number;
  /**
   * @remarks
   * The name of the storage format.
   * 
   * @example
   * TextInputFormat
   */
  formatName?: string;
  /**
   * @remarks
   * The proportion of the data in the format.
   * 
   * @example
   * 0.23
   */
  formatRatio?: number;
  /**
   * @remarks
   * The amount of data in the format.
   * 
   * @example
   * 506930200
   */
  formatSize?: number;
  /**
   * @remarks
   * The day-to-day growth rate of data in the format.
   * 
   * @example
   * 0.04
   */
  formatSizeDayGrowthRatio?: number;
  /**
   * @remarks
   * The unit of the amount of data in the format.
   * 
   * @example
   * MB
   */
  formatSizeUnit?: string;
  static names(): { [key: string]: string } {
    return {
      formatDayGrowthSize: 'FormatDayGrowthSize',
      formatName: 'FormatName',
      formatRatio: 'FormatRatio',
      formatSize: 'FormatSize',
      formatSizeDayGrowthRatio: 'FormatSizeDayGrowthRatio',
      formatSizeUnit: 'FormatSizeUnit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      formatDayGrowthSize: 'number',
      formatName: 'string',
      formatRatio: 'number',
      formatSize: 'number',
      formatSizeDayGrowthRatio: 'number',
      formatSizeUnit: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsColdDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of cold data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 217715
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsColdDataRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Cold data ratio
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.01
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsColdDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Size of the cold data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 217715
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsColdDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of cold data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * coldDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.01
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of empty files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * emptyFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 3123
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of empty files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * emptyFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.01
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of empty files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * emptyFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * -20
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of empty files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * emptyFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.01
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of freeze data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 33229309
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of freeze data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.98
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Size of the freeze data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 33229309
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of freeze data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * freezeDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.01
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsHotDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of hot data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 203431
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsHotDataRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Hot data ratio
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.01
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsHotDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Size of the hot data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 203431
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsHotDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of hot data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * hotDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.01
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsLargeFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of large files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * largeFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * “”
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 132
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsLargeFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of large files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * largeFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.01
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsLargeFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of large files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * largeFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 40
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsLargeFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of large files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * largeFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.02
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsMediumFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of medium files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * mediumFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * “”
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 5
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsMediumFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of medium files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * mediumFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.01
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsMediumFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of medium files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * mediumFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 20
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsMediumFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of medium files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * mediumFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.8
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsPartitionNum extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * number of partitions
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * partitionNum
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * “”
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 331
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsSmallFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of small files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * smallFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * "“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 18
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsSmallFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of small files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * smallFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.01
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsSmallFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of small files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * smallFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 18
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsSmallFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of small files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * smallFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.04
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsTinyFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of tiny files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tinyFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 451
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsTinyFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of tiny files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tinyFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.04
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsTinyFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of tiny files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tinyFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 482
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsTinyFileRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of tiny files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * tinyFileRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.96
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsTotalDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of total data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 33800296
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsTotalDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total data size in megabytes (MB)
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 33800296
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of total data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.01
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsTotalFileCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Number of total files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalFileCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 123
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsTotalFileCountDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of total files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalFileCountDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.01
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsTotalFileDayGrowthCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth count of total files
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * totalFileDayGrowthCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 100
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsWarmDataDayGrowthSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth size of warm data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmDataDayGrowthSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 149841
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsWarmDataRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Ratio of warm data
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmDataRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.1
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsWarmDataSize extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Size of the warm data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmDataSize
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 14981
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Day growth ratio of warm data size
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * warmDataSizeDayGrowthRatio
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ”“
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 0.01
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyDataMetrics extends $tea.Model {
  /**
   * @remarks
   * The daily increment of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
   */
  coldDataDayGrowthSize?: ListDoctorHiveTablesResponseBodyDataMetricsColdDataDayGrowthSize;
  /**
   * @remarks
   * The proportion of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
   */
  coldDataRatio?: ListDoctorHiveTablesResponseBodyDataMetricsColdDataRatio;
  /**
   * @remarks
   * The amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
   */
  coldDataSize?: ListDoctorHiveTablesResponseBodyDataMetricsColdDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of cold data. Cold data refers to data that is not accessed for more than 30 days but is accessed in previous 90 days.
   */
  coldDataSizeDayGrowthRatio?: ListDoctorHiveTablesResponseBodyDataMetricsColdDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The number of empty files. Empty files are those with a size of 0 MB.
   */
  emptyFileCount?: ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of empty files. Empty files are those with a size of 0 MB.
   */
  emptyFileCountDayGrowthRatio?: ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of empty files. Empty files are those with a size of 0 MB.
   */
  emptyFileDayGrowthCount?: ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of empty files. Empty files are those with a size of 0 MB.
   */
  emptyFileRatio?: ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileRatio;
  /**
   * @remarks
   * The daily increment of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   */
  freezeDataDayGrowthSize?: ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataDayGrowthSize;
  /**
   * @remarks
   * The proportion of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   */
  freezeDataRatio?: ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataRatio;
  /**
   * @remarks
   * The amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   */
  freezeDataSize?: ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of very cold data. Very cold data refers to data that is not accessed for more than 90 days.
   */
  freezeDataSizeDayGrowthRatio?: ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the amount of hot data. Hot data refers to data that is accessed in previous seven days.
   */
  hotDataDayGrowthSize?: ListDoctorHiveTablesResponseBodyDataMetricsHotDataDayGrowthSize;
  /**
   * @remarks
   * The proportion of hot data. Hot data refers to data that is accessed in previous seven days.
   */
  hotDataRatio?: ListDoctorHiveTablesResponseBodyDataMetricsHotDataRatio;
  /**
   * @remarks
   * The amount of hot data. Hot data refers to data that is accessed in previous seven days.
   */
  hotDataSize?: ListDoctorHiveTablesResponseBodyDataMetricsHotDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of hot data. Hot data refers to data that is accessed in previous seven days.
   */
  hotDataSizeDayGrowthRatio?: ListDoctorHiveTablesResponseBodyDataMetricsHotDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The number of large files. Large files are those with a size greater than 1 GB.
   */
  largeFileCount?: ListDoctorHiveTablesResponseBodyDataMetricsLargeFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of large files. Large files are those with a size greater than 1 GB.
   */
  largeFileCountDayGrowthRatio?: ListDoctorHiveTablesResponseBodyDataMetricsLargeFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of large files. Large files are those with a size greater than 1 GB.
   */
  largeFileDayGrowthCount?: ListDoctorHiveTablesResponseBodyDataMetricsLargeFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of large files. Large files are those with a size greater than 1 GB.
   */
  largeFileRatio?: ListDoctorHiveTablesResponseBodyDataMetricsLargeFileRatio;
  /**
   * @remarks
   * The number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   */
  mediumFileCount?: ListDoctorHiveTablesResponseBodyDataMetricsMediumFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   */
  mediumFileCountDayGrowthRatio?: ListDoctorHiveTablesResponseBodyDataMetricsMediumFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   */
  mediumFileDayGrowthCount?: ListDoctorHiveTablesResponseBodyDataMetricsMediumFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of medium files. Medium files are those with a size greater than or equal to 128 MB and less than or equal to 1 GB.
   */
  mediumFileRatio?: ListDoctorHiveTablesResponseBodyDataMetricsMediumFileRatio;
  /**
   * @remarks
   * The number of partitions.
   */
  partitionNum?: ListDoctorHiveTablesResponseBodyDataMetricsPartitionNum;
  /**
   * @remarks
   * The number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   */
  smallFileCount?: ListDoctorHiveTablesResponseBodyDataMetricsSmallFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   */
  smallFileCountDayGrowthRatio?: ListDoctorHiveTablesResponseBodyDataMetricsSmallFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   */
  smallFileDayGrowthCount?: ListDoctorHiveTablesResponseBodyDataMetricsSmallFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of small files. Small files are those with a size greater than or equal to 10 MB and less than 128 MB.
   */
  smallFileRatio?: ListDoctorHiveTablesResponseBodyDataMetricsSmallFileRatio;
  /**
   * @remarks
   * The number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   */
  tinyFileCount?: ListDoctorHiveTablesResponseBodyDataMetricsTinyFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   */
  tinyFileCountDayGrowthRatio?: ListDoctorHiveTablesResponseBodyDataMetricsTinyFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the number of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   */
  tinyFileDayGrowthCount?: ListDoctorHiveTablesResponseBodyDataMetricsTinyFileDayGrowthCount;
  /**
   * @remarks
   * The proportion of very small files. Very small files are those with a size greater than 0 MB and less than 10 MB.
   */
  tinyFileRatio?: ListDoctorHiveTablesResponseBodyDataMetricsTinyFileRatio;
  /**
   * @remarks
   * The daily increment of the total amount of data.
   */
  totalDataDayGrowthSize?: ListDoctorHiveTablesResponseBodyDataMetricsTotalDataDayGrowthSize;
  /**
   * @remarks
   * The total amount of data.
   */
  totalDataSize?: ListDoctorHiveTablesResponseBodyDataMetricsTotalDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the total amount of data.
   */
  totalDataSizeDayGrowthRatio?: ListDoctorHiveTablesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio;
  /**
   * @remarks
   * The total number of files.
   */
  totalFileCount?: ListDoctorHiveTablesResponseBodyDataMetricsTotalFileCount;
  /**
   * @remarks
   * The day-to-day growth rate of the total number of files.
   */
  totalFileCountDayGrowthRatio?: ListDoctorHiveTablesResponseBodyDataMetricsTotalFileCountDayGrowthRatio;
  /**
   * @remarks
   * The daily increment of the total number of files.
   */
  totalFileDayGrowthCount?: ListDoctorHiveTablesResponseBodyDataMetricsTotalFileDayGrowthCount;
  /**
   * @remarks
   * The daily increment of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
   */
  warmDataDayGrowthSize?: ListDoctorHiveTablesResponseBodyDataMetricsWarmDataDayGrowthSize;
  /**
   * @remarks
   * The proportion of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
   */
  warmDataRatio?: ListDoctorHiveTablesResponseBodyDataMetricsWarmDataRatio;
  /**
   * @remarks
   * The amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
   */
  warmDataSize?: ListDoctorHiveTablesResponseBodyDataMetricsWarmDataSize;
  /**
   * @remarks
   * The day-to-day growth rate of the amount of warm data. Warm data refers to data that is not accessed for more than 7 days but is accessed in previous 30 days.
   */
  warmDataSizeDayGrowthRatio?: ListDoctorHiveTablesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio;
  static names(): { [key: string]: string } {
    return {
      coldDataDayGrowthSize: 'ColdDataDayGrowthSize',
      coldDataRatio: 'ColdDataRatio',
      coldDataSize: 'ColdDataSize',
      coldDataSizeDayGrowthRatio: 'ColdDataSizeDayGrowthRatio',
      emptyFileCount: 'EmptyFileCount',
      emptyFileCountDayGrowthRatio: 'EmptyFileCountDayGrowthRatio',
      emptyFileDayGrowthCount: 'EmptyFileDayGrowthCount',
      emptyFileRatio: 'EmptyFileRatio',
      freezeDataDayGrowthSize: 'FreezeDataDayGrowthSize',
      freezeDataRatio: 'FreezeDataRatio',
      freezeDataSize: 'FreezeDataSize',
      freezeDataSizeDayGrowthRatio: 'FreezeDataSizeDayGrowthRatio',
      hotDataDayGrowthSize: 'HotDataDayGrowthSize',
      hotDataRatio: 'HotDataRatio',
      hotDataSize: 'HotDataSize',
      hotDataSizeDayGrowthRatio: 'HotDataSizeDayGrowthRatio',
      largeFileCount: 'LargeFileCount',
      largeFileCountDayGrowthRatio: 'LargeFileCountDayGrowthRatio',
      largeFileDayGrowthCount: 'LargeFileDayGrowthCount',
      largeFileRatio: 'LargeFileRatio',
      mediumFileCount: 'MediumFileCount',
      mediumFileCountDayGrowthRatio: 'MediumFileCountDayGrowthRatio',
      mediumFileDayGrowthCount: 'MediumFileDayGrowthCount',
      mediumFileRatio: 'MediumFileRatio',
      partitionNum: 'PartitionNum',
      smallFileCount: 'SmallFileCount',
      smallFileCountDayGrowthRatio: 'SmallFileCountDayGrowthRatio',
      smallFileDayGrowthCount: 'SmallFileDayGrowthCount',
      smallFileRatio: 'SmallFileRatio',
      tinyFileCount: 'TinyFileCount',
      tinyFileCountDayGrowthRatio: 'TinyFileCountDayGrowthRatio',
      tinyFileDayGrowthCount: 'TinyFileDayGrowthCount',
      tinyFileRatio: 'TinyFileRatio',
      totalDataDayGrowthSize: 'TotalDataDayGrowthSize',
      totalDataSize: 'TotalDataSize',
      totalDataSizeDayGrowthRatio: 'TotalDataSizeDayGrowthRatio',
      totalFileCount: 'TotalFileCount',
      totalFileCountDayGrowthRatio: 'TotalFileCountDayGrowthRatio',
      totalFileDayGrowthCount: 'TotalFileDayGrowthCount',
      warmDataDayGrowthSize: 'WarmDataDayGrowthSize',
      warmDataRatio: 'WarmDataRatio',
      warmDataSize: 'WarmDataSize',
      warmDataSizeDayGrowthRatio: 'WarmDataSizeDayGrowthRatio',
    };
  }

  static types(): { [key: string]: any } {
    return {
      coldDataDayGrowthSize: ListDoctorHiveTablesResponseBodyDataMetricsColdDataDayGrowthSize,
      coldDataRatio: ListDoctorHiveTablesResponseBodyDataMetricsColdDataRatio,
      coldDataSize: ListDoctorHiveTablesResponseBodyDataMetricsColdDataSize,
      coldDataSizeDayGrowthRatio: ListDoctorHiveTablesResponseBodyDataMetricsColdDataSizeDayGrowthRatio,
      emptyFileCount: ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileCount,
      emptyFileCountDayGrowthRatio: ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileCountDayGrowthRatio,
      emptyFileDayGrowthCount: ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileDayGrowthCount,
      emptyFileRatio: ListDoctorHiveTablesResponseBodyDataMetricsEmptyFileRatio,
      freezeDataDayGrowthSize: ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataDayGrowthSize,
      freezeDataRatio: ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataRatio,
      freezeDataSize: ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataSize,
      freezeDataSizeDayGrowthRatio: ListDoctorHiveTablesResponseBodyDataMetricsFreezeDataSizeDayGrowthRatio,
      hotDataDayGrowthSize: ListDoctorHiveTablesResponseBodyDataMetricsHotDataDayGrowthSize,
      hotDataRatio: ListDoctorHiveTablesResponseBodyDataMetricsHotDataRatio,
      hotDataSize: ListDoctorHiveTablesResponseBodyDataMetricsHotDataSize,
      hotDataSizeDayGrowthRatio: ListDoctorHiveTablesResponseBodyDataMetricsHotDataSizeDayGrowthRatio,
      largeFileCount: ListDoctorHiveTablesResponseBodyDataMetricsLargeFileCount,
      largeFileCountDayGrowthRatio: ListDoctorHiveTablesResponseBodyDataMetricsLargeFileCountDayGrowthRatio,
      largeFileDayGrowthCount: ListDoctorHiveTablesResponseBodyDataMetricsLargeFileDayGrowthCount,
      largeFileRatio: ListDoctorHiveTablesResponseBodyDataMetricsLargeFileRatio,
      mediumFileCount: ListDoctorHiveTablesResponseBodyDataMetricsMediumFileCount,
      mediumFileCountDayGrowthRatio: ListDoctorHiveTablesResponseBodyDataMetricsMediumFileCountDayGrowthRatio,
      mediumFileDayGrowthCount: ListDoctorHiveTablesResponseBodyDataMetricsMediumFileDayGrowthCount,
      mediumFileRatio: ListDoctorHiveTablesResponseBodyDataMetricsMediumFileRatio,
      partitionNum: ListDoctorHiveTablesResponseBodyDataMetricsPartitionNum,
      smallFileCount: ListDoctorHiveTablesResponseBodyDataMetricsSmallFileCount,
      smallFileCountDayGrowthRatio: ListDoctorHiveTablesResponseBodyDataMetricsSmallFileCountDayGrowthRatio,
      smallFileDayGrowthCount: ListDoctorHiveTablesResponseBodyDataMetricsSmallFileDayGrowthCount,
      smallFileRatio: ListDoctorHiveTablesResponseBodyDataMetricsSmallFileRatio,
      tinyFileCount: ListDoctorHiveTablesResponseBodyDataMetricsTinyFileCount,
      tinyFileCountDayGrowthRatio: ListDoctorHiveTablesResponseBodyDataMetricsTinyFileCountDayGrowthRatio,
      tinyFileDayGrowthCount: ListDoctorHiveTablesResponseBodyDataMetricsTinyFileDayGrowthCount,
      tinyFileRatio: ListDoctorHiveTablesResponseBodyDataMetricsTinyFileRatio,
      totalDataDayGrowthSize: ListDoctorHiveTablesResponseBodyDataMetricsTotalDataDayGrowthSize,
      totalDataSize: ListDoctorHiveTablesResponseBodyDataMetricsTotalDataSize,
      totalDataSizeDayGrowthRatio: ListDoctorHiveTablesResponseBodyDataMetricsTotalDataSizeDayGrowthRatio,
      totalFileCount: ListDoctorHiveTablesResponseBodyDataMetricsTotalFileCount,
      totalFileCountDayGrowthRatio: ListDoctorHiveTablesResponseBodyDataMetricsTotalFileCountDayGrowthRatio,
      totalFileDayGrowthCount: ListDoctorHiveTablesResponseBodyDataMetricsTotalFileDayGrowthCount,
      warmDataDayGrowthSize: ListDoctorHiveTablesResponseBodyDataMetricsWarmDataDayGrowthSize,
      warmDataRatio: ListDoctorHiveTablesResponseBodyDataMetricsWarmDataRatio,
      warmDataSize: ListDoctorHiveTablesResponseBodyDataMetricsWarmDataSize,
      warmDataSizeDayGrowthRatio: ListDoctorHiveTablesResponseBodyDataMetricsWarmDataSizeDayGrowthRatio,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorHiveTablesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The analysis results.
   */
  analysis?: ListDoctorHiveTablesResponseBodyDataAnalysis;
  /**
   * @remarks
   * The table format information.
   */
  formats?: ListDoctorHiveTablesResponseBodyDataFormats[];
  /**
   * @remarks
   * The metric information.
   */
  metrics?: ListDoctorHiveTablesResponseBodyDataMetrics;
  /**
   * @remarks
   * The owner.
   * 
   * @example
   * DW
   */
  owner?: string;
  /**
   * @remarks
   * The table name. The table name must follow the naming rule in Hive. A name in the {Database name.Table name} format uniquely identifies a table.
   * 
   * @example
   * dw.dwd_creta_service_order_long_renew_long_da
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      analysis: 'Analysis',
      formats: 'Formats',
      metrics: 'Metrics',
      owner: 'Owner',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      analysis: ListDoctorHiveTablesResponseBodyDataAnalysis,
      formats: { 'type': 'array', 'itemType': ListDoctorHiveTablesResponseBodyDataFormats },
      metrics: ListDoctorHiveTablesResponseBodyDataMetrics,
      owner: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorJobsRequestEndRange extends $tea.Model {
  /**
   * @remarks
   * The end of the time range during which jobs ended. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
   * 
   * @example
   * 1666865137099
   */
  endTime?: number;
  /**
   * @remarks
   * The beginning of the time range during which jobs ended. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
   * 
   * @example
   * 1679135111960
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorJobsRequestStartRange extends $tea.Model {
  /**
   * @remarks
   * The end of the time range during which jobs were submitted. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
   * 
   * @example
   * 1683340662020
   */
  endTime?: number;
  /**
   * @remarks
   * The beginning of the time range during which jobs were submitted. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
   * 
   * @example
   * 1683340662016
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorJobsResponseBodyDataMetricsMemSeconds extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total memory usage over time in seconds
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * memSeconds
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB * Sec
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 12312312
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorJobsResponseBodyDataMetricsVcoreSeconds extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total vcore usage over time in seconds
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * vcoreSeconds
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * VCores * Sec
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 11123
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorJobsResponseBodyDataMetrics extends $tea.Model {
  /**
   * @remarks
   * The amount of memory consumed.
   */
  memSeconds?: ListDoctorJobsResponseBodyDataMetricsMemSeconds;
  /**
   * @remarks
   * The CPU usage.
   */
  vcoreSeconds?: ListDoctorJobsResponseBodyDataMetricsVcoreSeconds;
  static names(): { [key: string]: string } {
    return {
      memSeconds: 'MemSeconds',
      vcoreSeconds: 'VcoreSeconds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      memSeconds: ListDoctorJobsResponseBodyDataMetricsMemSeconds,
      vcoreSeconds: ListDoctorJobsResponseBodyDataMetricsVcoreSeconds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorJobsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the job that was submitted to YARN.
   * 
   * @example
   * application_1607584549220_*****
   */
  appId?: string;
  /**
   * @remarks
   * The name of the job.
   * 
   * @example
   * tpcds
   */
  appName?: string;
  /**
   * @remarks
   * The total running time of the job. Unit: milliseconds.
   * 
   * @example
   * 242
   */
  elapsedTime?: number;
  /**
   * @remarks
   * The final state of the job. Valid values:
   * 
   * *   SUCCEEDED
   * *   FAILED
   * *   KILLED
   * *   ENDED
   * *   UNDEFINED
   * 
   * @example
   * KILLED
   */
  finalStatus?: string;
  /**
   * @remarks
   * The end time of the job. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
   * 
   * @example
   * 1683690929000
   */
  finishTime?: number;
  /**
   * @remarks
   * The time when the job was started. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
   * 
   * @example
   * 1672148400000
   */
  launchTime?: number;
  /**
   * @remarks
   * The data about the metrics.
   */
  metrics?: ListDoctorJobsResponseBodyDataMetrics;
  /**
   * @remarks
   * The YARN queue to which the job was submitted.
   * 
   * @example
   * DW
   */
  queue?: string;
  /**
   * @remarks
   * The time when the job was submitted. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
   * 
   * @example
   * 1675180800000
   */
  startTime?: number;
  /**
   * @remarks
   * The running state of the job. Valid values:
   * 
   * *   FINISHED
   * *   FAILED
   * *   KILLED
   * 
   * @example
   * FINISHED
   */
  state?: string;
  /**
   * @remarks
   * The type of the compute engine.
   * 
   * @example
   * SPARK
   */
  type?: string;
  /**
   * @remarks
   * The username that was used to submit the job.
   * 
   * @example
   * DW
   */
  user?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      appName: 'AppName',
      elapsedTime: 'ElapsedTime',
      finalStatus: 'FinalStatus',
      finishTime: 'FinishTime',
      launchTime: 'LaunchTime',
      metrics: 'Metrics',
      queue: 'Queue',
      startTime: 'StartTime',
      state: 'State',
      type: 'Type',
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      appName: 'string',
      elapsedTime: 'number',
      finalStatus: 'string',
      finishTime: 'number',
      launchTime: 'number',
      metrics: ListDoctorJobsResponseBodyDataMetrics,
      queue: 'string',
      startTime: 'number',
      state: 'string',
      type: 'string',
      user: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorJobsStatsRequestEndRange extends $tea.Model {
  /**
   * @remarks
   * The end of the time range during which jobs ended. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1680019200000
   */
  endTime?: number;
  /**
   * @remarks
   * The beginning of the time range during which jobs ended. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1675180800000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorJobsStatsRequestStartRange extends $tea.Model {
  /**
   * @remarks
   * The end of the time range during which jobs were submitted. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
   * 
   * @example
   * 1666406820000
   */
  endTime?: number;
  /**
   * @remarks
   * The beginning of the time range during which jobs were submitted. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Unit: milliseconds.
   * 
   * @example
   * 1679036826987
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorJobsStatsResponseBodyDataAppsCount extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total apps count
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * appsCount
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * ""
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 123
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorJobsStatsResponseBodyDataMemSeconds extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total memory usage over time in seconds
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * memSeconds
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * MB * Sec
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 12312312
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorJobsStatsResponseBodyDataVcoreSeconds extends $tea.Model {
  /**
   * @remarks
   * The description of the metric.
   * 
   * @example
   * Total vcore usage over time in seconds
   */
  description?: string;
  /**
   * @remarks
   * The name of the metric.
   * 
   * @example
   * vcoreSeconds
   */
  name?: string;
  /**
   * @remarks
   * The unit of the metric.
   * 
   * @example
   * VCores * Sec
   */
  unit?: string;
  /**
   * @remarks
   * The value of the metric.
   * 
   * @example
   * 11123
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      unit: 'Unit',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      unit: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorJobsStatsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The total number of jobs.
   */
  appsCount?: ListDoctorJobsStatsResponseBodyDataAppsCount;
  /**
   * @remarks
   * The aggregated amount of memory that is allocated to the job multiplied by the number of seconds the job has been running.
   */
  memSeconds?: ListDoctorJobsStatsResponseBodyDataMemSeconds;
  /**
   * @remarks
   * The YARN queue to which the job was submitted.
   * 
   * @example
   * DW
   */
  queue?: string;
  /**
   * @remarks
   * The type of the compute engine.
   * 
   * @example
   * SPARK
   */
  type?: string;
  /**
   * @remarks
   * The username that is used to submit the job.
   * 
   * @example
   * DW
   */
  user?: string;
  /**
   * @remarks
   * The aggregated number of vCPUs that are allocated to the job multiplied by the number of seconds the job has been running.
   */
  vcoreSeconds?: ListDoctorJobsStatsResponseBodyDataVcoreSeconds;
  static names(): { [key: string]: string } {
    return {
      appsCount: 'AppsCount',
      memSeconds: 'MemSeconds',
      queue: 'Queue',
      type: 'Type',
      user: 'User',
      vcoreSeconds: 'VcoreSeconds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appsCount: ListDoctorJobsStatsResponseBodyDataAppsCount,
      memSeconds: ListDoctorJobsStatsResponseBodyDataMemSeconds,
      queue: 'string',
      type: 'string',
      user: 'string',
      vcoreSeconds: ListDoctorJobsStatsResponseBodyDataVcoreSeconds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorReportsResponseBodyDataSummaryReport extends $tea.Model {
  /**
   * @remarks
   * The score.
   * 
   * @example
   * 88
   */
  score?: number;
  /**
   * @remarks
   * The optimization suggestion.
   * 
   * @example
   * block
   */
  suggestion?: string;
  /**
   * @remarks
   * The summary of the report.
   * 
   * @example
   * eastbuy-mse-plugin-auth
   */
  summary?: string;
  static names(): { [key: string]: string } {
    return {
      score: 'Score',
      suggestion: 'Suggestion',
      summary: 'Summary',
    };
  }

  static types(): { [key: string]: any } {
    return {
      score: 'number',
      suggestion: 'string',
      summary: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDoctorReportsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The component types.
   * 
   * Valid values:
   * 
   * *   compute
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   hive
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   hdfs
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   yarn
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   oss
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * *   hbase
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   *     <!-- -->
   * 
   * @example
   * null
   */
  componentTypes?: string[];
  /**
   * @remarks
   * The date on which the report was generated.
   * 
   * @example
   * 2023-06-29
   */
  dateTime?: string;
  /**
   * @remarks
   * The summary of the report.
   */
  summaryReport?: ListDoctorReportsResponseBodyDataSummaryReport;
  static names(): { [key: string]: string } {
    return {
      componentTypes: 'ComponentTypes',
      dateTime: 'DateTime',
      summaryReport: 'SummaryReport',
    };
  }

  static types(): { [key: string]: any } {
    return {
      componentTypes: { 'type': 'array', 'itemType': 'string' },
      dateTime: 'string',
      summaryReport: ListDoctorReportsResponseBodyDataSummaryReport,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListReleaseVersionsResponseBodyReleaseVersions extends $tea.Model {
  /**
   * @remarks
   * The IaaS type.
   * 
   * @example
   * ECS
   */
  iaasType?: string;
  /**
   * @remarks
   * The EMR version.
   * 
   * @example
   * EMR-5.3.0
   */
  releaseVersion?: string;
  /**
   * @remarks
   * The version series.
   * 
   * @example
   * EMR-6.X
   */
  series?: string;
  static names(): { [key: string]: string } {
    return {
      iaasType: 'IaasType',
      releaseVersion: 'ReleaseVersion',
      series: 'Series',
    };
  }

  static types(): { [key: string]: any } {
    return {
      iaasType: 'string',
      releaseVersion: 'string',
      series: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScriptsResponseBodyScripts extends $tea.Model {
  /**
   * @remarks
   * The name of the API operation.
   * 
   * @example
   * ListScripts
   */
  action?: string;
  /**
   * @remarks
   * The time when the system finishes the running of the script. This parameter is returned only if the ScriptType parameter is set to NORMAL.
   * 
   * @example
   * 1639715635819
   */
  endTime?: number;
  /**
   * @remarks
   * The policy that is used to handle execution failures of the script. Valid values:
   * 
   * *   FAILED_CONTINUE
   * *   FAILED_BLOCK
   * 
   * @example
   * FAILED_CONTINUE
   */
  executionFailStrategy?: string;
  /**
   * @remarks
   * The time based on which the system runs the script. Valid values:
   * 
   * *   BEFORE_INSTALL
   * *   AFTER_STARTED
   * 
   * @example
   * BEFORE_INSTALL
   */
  executionMoment?: string;
  /**
   * @remarks
   * The status of the script. This parameter is returned only if the `ScriptType` parameter is set to `NORMAL`. Valid values:
   * 
   * *   SCRIPT_COMPLETED
   * *   SCRIPT_SUBMISSION_FAILED
   * *   SCRIPT_RUNNING
   * 
   * @example
   * SCRIPT_COMPLETED
   */
  executionState?: string;
  /**
   * @remarks
   * The time when the script was last modified.
   * 
   * @example
   * 1639714634819
   */
  lastUpdateTime?: number;
  /**
   * @remarks
   * The node selector.
   */
  nodeSelector?: NodeSelector;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The runtime parameters of the script.
   * 
   * @example
   * --mode=client -h -p
   */
  scriptArgs?: string;
  /**
   * @remarks
   * The script ID.
   * 
   * @example
   * cs-bf25219d103043a0820613e32781****
   */
  scriptId?: string;
  /**
   * @remarks
   * The name of the script.
   * 
   * @example
   * check_env
   */
  scriptName?: string;
  /**
   * @remarks
   * The path in which the script is stored.
   * 
   * @example
   * oss://bucket1/check_evn.sh
   */
  scriptPath?: string;
  /**
   * @remarks
   * The time when the system starts to run the script. This parameter is returned only if the ScriptType parameter is set to NORMAL.
   * 
   * @example
   * 1639714634000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      endTime: 'EndTime',
      executionFailStrategy: 'ExecutionFailStrategy',
      executionMoment: 'ExecutionMoment',
      executionState: 'ExecutionState',
      lastUpdateTime: 'LastUpdateTime',
      nodeSelector: 'NodeSelector',
      regionId: 'RegionId',
      scriptArgs: 'ScriptArgs',
      scriptId: 'ScriptId',
      scriptName: 'ScriptName',
      scriptPath: 'ScriptPath',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      endTime: 'number',
      executionFailStrategy: 'string',
      executionMoment: 'string',
      executionState: 'string',
      lastUpdateTime: 'number',
      nodeSelector: NodeSelector,
      regionId: 'string',
      scriptArgs: 'string',
      scriptId: 'string',
      scriptName: 'string',
      scriptPath: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponseBodyTagResources extends $tea.Model {
  /**
   * @remarks
   * Indicates the ID of a resource.
   * 
   * @example
   * c-b933c5aac8fe****
   */
  resourceId?: string;
  /**
   * @remarks
   * The resource type.
   * 
   * @example
   * cluster
   */
  resourceType?: string;
  /**
   * @remarks
   * The tag key of the ENI.
   * 
   * @example
   * Department
   */
  tagKey?: string;
  /**
   * @remarks
   * The tag value of the ENI.
   * 
   * @example
   * Dev
   */
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceId: 'string',
      resourceType: 'string',
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunApplicationActionResponseBodyAbnInstances extends $tea.Model {
  /**
   * @remarks
   * The ID of the abnormal node.
   * 
   * @example
   * i-bp1cudc25w2bfwl5****
   */
  nodeId?: string;
  /**
   * @remarks
   * The name of the abnormal node.
   * 
   * @example
   * core1-1
   */
  nodeName?: string;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      nodeName: 'NodeName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'string',
      nodeName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends OpenApi {

  constructor(config: $OpenApi.Config) {
    super(config);
    this._endpointRule = "regional";
    this._endpointMap = {
      'cn-beijing': "emr.aliyuncs.com",
      'cn-hangzhou': "emr.aliyuncs.com",
      'cn-shanghai': "emr.aliyuncs.com",
      'cn-shenzhen': "emr.aliyuncs.com",
      'ap-southeast-1': "emr.aliyuncs.com",
      'us-west-1': "emr.aliyuncs.com",
      'cn-shanghai-finance-1': "emr.aliyuncs.com",
      'cn-shenzhen-finance-1': "emr.aliyuncs.com",
      'cn-north-2-gov-1': "emr.aliyuncs.com",
      'ap-northeast-2-pop': "emr.aliyuncs.com",
      'cn-beijing-finance-1': "emr.aliyuncs.com",
      'cn-beijing-finance-pop': "emr.aliyuncs.com",
      'cn-beijing-gov-1': "emr.aliyuncs.com",
      'cn-beijing-nu16-b01': "emr.aliyuncs.com",
      'cn-edge-1': "emr.aliyuncs.com",
      'cn-fujian': "emr.aliyuncs.com",
      'cn-haidian-cm12-c01': "emr.aliyuncs.com",
      'cn-hangzhou-bj-b01': "emr.aliyuncs.com",
      'cn-hangzhou-finance': "emr.aliyuncs.com",
      'cn-hangzhou-internal-prod-1': "emr.aliyuncs.com",
      'cn-hangzhou-internal-test-1': "emr.aliyuncs.com",
      'cn-hangzhou-internal-test-2': "emr.aliyuncs.com",
      'cn-hangzhou-internal-test-3': "emr.aliyuncs.com",
      'cn-hangzhou-test-306': "emr.aliyuncs.com",
      'cn-hongkong-finance-pop': "emr.aliyuncs.com",
      'cn-huhehaote-nebula-1': "emr.aliyuncs.com",
      'cn-qingdao-nebula': "emr.aliyuncs.com",
      'cn-shanghai-et15-b01': "emr.aliyuncs.com",
      'cn-shanghai-et2-b01': "emr.aliyuncs.com",
      'cn-shanghai-inner': "emr.aliyuncs.com",
      'cn-shanghai-internal-test-1': "emr.aliyuncs.com",
      'cn-shenzhen-inner': "emr.aliyuncs.com",
      'cn-shenzhen-st4-d01': "emr.aliyuncs.com",
      'cn-shenzhen-su18-b01': "emr.aliyuncs.com",
      'cn-wuhan': "emr.aliyuncs.com",
      'cn-yushanfang': "emr.aliyuncs.com",
      'cn-zhangbei': "emr.aliyuncs.com",
      'cn-zhangbei-na61-b01': "emr.aliyuncs.com",
      'cn-zhangjiakou-na62-a01': "emr.aliyuncs.com",
      'cn-zhengzhou-nebula-1': "emr.aliyuncs.com",
      'eu-west-1-oxs': "emr.aliyuncs.com",
      'rus-west-1-pop': "emr.aliyuncs.com",
    };
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("emr", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!Util.empty(endpoint)) {
      return endpoint;
    }

    if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  /**
   * @param request - CreateApiTemplateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateApiTemplateResponse
   */
  async createApiTemplateWithOptions(request: CreateApiTemplateRequest, runtime: $Util.RuntimeOptions): Promise<CreateApiTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiName)) {
      query["ApiName"] = request.apiName;
    }

    if (!Util.isUnset(request.content)) {
      query["Content"] = request.content;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.templateName)) {
      query["TemplateName"] = request.templateName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateApiTemplate",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateApiTemplateResponse>(await this.callApi(params, req, runtime), new CreateApiTemplateResponse({}));
  }

  /**
   * @param request - CreateApiTemplateRequest
   * @returns CreateApiTemplateResponse
   */
  async createApiTemplate(request: CreateApiTemplateRequest): Promise<CreateApiTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createApiTemplateWithOptions(request, runtime);
  }

  /**
   * Creates a pay-as-you-go or subscription cluster.
   * 
   * @param request - CreateClusterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateClusterResponse
   */
  async createClusterWithOptions(request: CreateClusterRequest, runtime: $Util.RuntimeOptions): Promise<CreateClusterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.applicationConfigs)) {
      query["ApplicationConfigs"] = request.applicationConfigs;
    }

    if (!Util.isUnset(request.applications)) {
      query["Applications"] = request.applications;
    }

    if (!Util.isUnset(request.bootstrapScripts)) {
      query["BootstrapScripts"] = request.bootstrapScripts;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.clusterName)) {
      query["ClusterName"] = request.clusterName;
    }

    if (!Util.isUnset(request.clusterType)) {
      query["ClusterType"] = request.clusterType;
    }

    if (!Util.isUnset(request.deployMode)) {
      query["DeployMode"] = request.deployMode;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.nodeAttributes)) {
      query["NodeAttributes"] = request.nodeAttributes;
    }

    if (!Util.isUnset(request.nodeGroups)) {
      query["NodeGroups"] = request.nodeGroups;
    }

    if (!Util.isUnset(request.paymentType)) {
      query["PaymentType"] = request.paymentType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.releaseVersion)) {
      query["ReleaseVersion"] = request.releaseVersion;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.securityMode)) {
      query["SecurityMode"] = request.securityMode;
    }

    if (!Util.isUnset(request.subscriptionConfig)) {
      query["SubscriptionConfig"] = request.subscriptionConfig;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateCluster",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateClusterResponse>(await this.callApi(params, req, runtime), new CreateClusterResponse({}));
  }

  /**
   * Creates a pay-as-you-go or subscription cluster.
   * 
   * @param request - CreateClusterRequest
   * @returns CreateClusterResponse
   */
  async createCluster(request: CreateClusterRequest): Promise<CreateClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createClusterWithOptions(request, runtime);
  }

  /**
   * Creates a node group.
   * 
   * @remarks
   * 创建节点组。
   * 
   * @param request - CreateNodeGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateNodeGroupResponse
   */
  async createNodeGroupWithOptions(request: CreateNodeGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateNodeGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.nodeGroup)) {
      query["NodeGroup"] = request.nodeGroup;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateNodeGroup",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateNodeGroupResponse>(await this.callApi(params, req, runtime), new CreateNodeGroupResponse({}));
  }

  /**
   * Creates a node group.
   * 
   * @remarks
   * 创建节点组。
   * 
   * @param request - CreateNodeGroupRequest
   * @returns CreateNodeGroupResponse
   */
  async createNodeGroup(request: CreateNodeGroupRequest): Promise<CreateNodeGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createNodeGroupWithOptions(request, runtime);
  }

  /**
   * Adds a bootstrap action or a common script of an E-MapReduce (EMR) cluster.
   * 
   * @param request - CreateScriptRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateScriptResponse
   */
  async createScriptWithOptions(request: CreateScriptRequest, runtime: $Util.RuntimeOptions): Promise<CreateScriptResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.scriptType)) {
      query["ScriptType"] = request.scriptType;
    }

    if (!Util.isUnset(request.scripts)) {
      query["Scripts"] = request.scripts;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateScript",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateScriptResponse>(await this.callApi(params, req, runtime), new CreateScriptResponse({}));
  }

  /**
   * Adds a bootstrap action or a common script of an E-MapReduce (EMR) cluster.
   * 
   * @param request - CreateScriptRequest
   * @returns CreateScriptResponse
   */
  async createScript(request: CreateScriptRequest): Promise<CreateScriptResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createScriptWithOptions(request, runtime);
  }

  /**
   * Perform a scale-out operation on the target node group.
   * 
   * @param request - DecreaseNodesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DecreaseNodesResponse
   */
  async decreaseNodesWithOptions(request: DecreaseNodesRequest, runtime: $Util.RuntimeOptions): Promise<DecreaseNodesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.decreaseNodeCount)) {
      query["DecreaseNodeCount"] = request.decreaseNodeCount;
    }

    if (!Util.isUnset(request.nodeGroupId)) {
      query["NodeGroupId"] = request.nodeGroupId;
    }

    if (!Util.isUnset(request.nodeIds)) {
      query["NodeIds"] = request.nodeIds;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DecreaseNodes",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DecreaseNodesResponse>(await this.callApi(params, req, runtime), new DecreaseNodesResponse({}));
  }

  /**
   * Perform a scale-out operation on the target node group.
   * 
   * @param request - DecreaseNodesRequest
   * @returns DecreaseNodesResponse
   */
  async decreaseNodes(request: DecreaseNodesRequest): Promise<DecreaseNodesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.decreaseNodesWithOptions(request, runtime);
  }

  /**
   * @remarks
   * 创建集群模板
   * 
   * @param request - DeleteApiTemplateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteApiTemplateResponse
   */
  async deleteApiTemplateWithOptions(request: DeleteApiTemplateRequest, runtime: $Util.RuntimeOptions): Promise<DeleteApiTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiName)) {
      query["ApiName"] = request.apiName;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteApiTemplate",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteApiTemplateResponse>(await this.callApi(params, req, runtime), new DeleteApiTemplateResponse({}));
  }

  /**
   * @remarks
   * 创建集群模板
   * 
   * @param request - DeleteApiTemplateRequest
   * @returns DeleteApiTemplateResponse
   */
  async deleteApiTemplate(request: DeleteApiTemplateRequest): Promise<DeleteApiTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteApiTemplateWithOptions(request, runtime);
  }

  /**
   * @param request - DeleteClusterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteClusterResponse
   */
  async deleteClusterWithOptions(request: DeleteClusterRequest, runtime: $Util.RuntimeOptions): Promise<DeleteClusterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteCluster",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteClusterResponse>(await this.callApi(params, req, runtime), new DeleteClusterResponse({}));
  }

  /**
   * @param request - DeleteClusterRequest
   * @returns DeleteClusterResponse
   */
  async deleteCluster(request: DeleteClusterRequest): Promise<DeleteClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteClusterWithOptions(request, runtime);
  }

  /**
   * Deletes a bootstrap action or a common script of an E-MapReduce (EMR) cluster.
   * 
   * @param request - DeleteScriptRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteScriptResponse
   */
  async deleteScriptWithOptions(request: DeleteScriptRequest, runtime: $Util.RuntimeOptions): Promise<DeleteScriptResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.scriptId)) {
      query["ScriptId"] = request.scriptId;
    }

    if (!Util.isUnset(request.scriptType)) {
      query["ScriptType"] = request.scriptType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteScript",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteScriptResponse>(await this.callApi(params, req, runtime), new DeleteScriptResponse({}));
  }

  /**
   * Deletes a bootstrap action or a common script of an E-MapReduce (EMR) cluster.
   * 
   * @param request - DeleteScriptRequest
   * @returns DeleteScriptResponse
   */
  async deleteScript(request: DeleteScriptRequest): Promise<DeleteScriptResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteScriptWithOptions(request, runtime);
  }

  /**
   * 获取API模板详情
   * 
   * @param request - GetApiTemplateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetApiTemplateResponse
   */
  async getApiTemplateWithOptions(request: GetApiTemplateRequest, runtime: $Util.RuntimeOptions): Promise<GetApiTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetApiTemplate",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetApiTemplateResponse>(await this.callApi(params, req, runtime), new GetApiTemplateResponse({}));
  }

  /**
   * 获取API模板详情
   * 
   * @param request - GetApiTemplateRequest
   * @returns GetApiTemplateResponse
   */
  async getApiTemplate(request: GetApiTemplateRequest): Promise<GetApiTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getApiTemplateWithOptions(request, runtime);
  }

  /**
   * @remarks
   * 查询应用详情。
   * 
   * @param request - GetApplicationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetApplicationResponse
   */
  async getApplicationWithOptions(request: GetApplicationRequest, runtime: $Util.RuntimeOptions): Promise<GetApplicationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.applicationName)) {
      query["ApplicationName"] = request.applicationName;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetApplication",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetApplicationResponse>(await this.callApi(params, req, runtime), new GetApplicationResponse({}));
  }

  /**
   * @remarks
   * 查询应用详情。
   * 
   * @param request - GetApplicationRequest
   * @returns GetApplicationResponse
   */
  async getApplication(request: GetApplicationRequest): Promise<GetApplicationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getApplicationWithOptions(request, runtime);
  }

  /**
   * @remarks
   * 获取弹性伸缩活动详情。
   * 
   * @param request - GetAutoScalingActivityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetAutoScalingActivityResponse
   */
  async getAutoScalingActivityWithOptions(request: GetAutoScalingActivityRequest, runtime: $Util.RuntimeOptions): Promise<GetAutoScalingActivityResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.scalingActivityId)) {
      query["ScalingActivityId"] = request.scalingActivityId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetAutoScalingActivity",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetAutoScalingActivityResponse>(await this.callApi(params, req, runtime), new GetAutoScalingActivityResponse({}));
  }

  /**
   * @remarks
   * 获取弹性伸缩活动详情。
   * 
   * @param request - GetAutoScalingActivityRequest
   * @returns GetAutoScalingActivityResponse
   */
  async getAutoScalingActivity(request: GetAutoScalingActivityRequest): Promise<GetAutoScalingActivityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getAutoScalingActivityWithOptions(request, runtime);
  }

  /**
   * @param request - GetAutoScalingPolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetAutoScalingPolicyResponse
   */
  async getAutoScalingPolicyWithOptions(request: GetAutoScalingPolicyRequest, runtime: $Util.RuntimeOptions): Promise<GetAutoScalingPolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.nodeGroupId)) {
      query["NodeGroupId"] = request.nodeGroupId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetAutoScalingPolicy",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetAutoScalingPolicyResponse>(await this.callApi(params, req, runtime), new GetAutoScalingPolicyResponse({}));
  }

  /**
   * @param request - GetAutoScalingPolicyRequest
   * @returns GetAutoScalingPolicyResponse
   */
  async getAutoScalingPolicy(request: GetAutoScalingPolicyRequest): Promise<GetAutoScalingPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getAutoScalingPolicyWithOptions(request, runtime);
  }

  /**
   * Obtains the details of a cluster.
   * 
   * @param request - GetClusterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetClusterResponse
   */
  async getClusterWithOptions(request: GetClusterRequest, runtime: $Util.RuntimeOptions): Promise<GetClusterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetCluster",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetClusterResponse>(await this.callApi(params, req, runtime), new GetClusterResponse({}));
  }

  /**
   * Obtains the details of a cluster.
   * 
   * @param request - GetClusterRequest
   * @returns GetClusterResponse
   */
  async getCluster(request: GetClusterRequest): Promise<GetClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getClusterWithOptions(request, runtime);
  }

  /**
   * Obtains metadata of the E-MapReduce (EMR) cluster that you want to clone. This helps you call the CreateCluster API operation to quickly create an EMR cluster.
   * 
   * @param request - GetClusterCloneMetaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetClusterCloneMetaResponse
   */
  async getClusterCloneMetaWithOptions(request: GetClusterCloneMetaRequest, runtime: $Util.RuntimeOptions): Promise<GetClusterCloneMetaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetClusterCloneMeta",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetClusterCloneMetaResponse>(await this.callApi(params, req, runtime), new GetClusterCloneMetaResponse({}));
  }

  /**
   * Obtains metadata of the E-MapReduce (EMR) cluster that you want to clone. This helps you call the CreateCluster API operation to quickly create an EMR cluster.
   * 
   * @param request - GetClusterCloneMetaRequest
   * @returns GetClusterCloneMetaResponse
   */
  async getClusterCloneMeta(request: GetClusterCloneMetaRequest): Promise<GetClusterCloneMetaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getClusterCloneMetaWithOptions(request, runtime);
  }

  /**
   * Obtains job analysis information on E-MapReduce (EMR) Doctor.
   * 
   * @remarks
   * get one doctor analysis app
   * 
   * @param request - GetDoctorApplicationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDoctorApplicationResponse
   */
  async getDoctorApplicationWithOptions(request: GetDoctorApplicationRequest, runtime: $Util.RuntimeOptions): Promise<GetDoctorApplicationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dateTime)) {
      query["DateTime"] = request.dateTime;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDoctorApplication",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDoctorApplicationResponse>(await this.callApi(params, req, runtime), new GetDoctorApplicationResponse({}));
  }

  /**
   * Obtains job analysis information on E-MapReduce (EMR) Doctor.
   * 
   * @remarks
   * get one doctor analysis app
   * 
   * @param request - GetDoctorApplicationRequest
   * @returns GetDoctorApplicationResponse
   */
  async getDoctorApplication(request: GetDoctorApplicationRequest): Promise<GetDoctorApplicationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDoctorApplicationWithOptions(request, runtime);
  }

  /**
   * Obtains the information about resource usage in a cluster on E-MapReduce (EMR) Doctor.
   * 
   * @remarks
   * get one specific luster engine queue by <type, name>
   * 
   * @param request - GetDoctorComputeSummaryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDoctorComputeSummaryResponse
   */
  async getDoctorComputeSummaryWithOptions(request: GetDoctorComputeSummaryRequest, runtime: $Util.RuntimeOptions): Promise<GetDoctorComputeSummaryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.componentInfo)) {
      query["ComponentInfo"] = request.componentInfo;
    }

    if (!Util.isUnset(request.dateTime)) {
      query["DateTime"] = request.dateTime;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDoctorComputeSummary",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDoctorComputeSummaryResponse>(await this.callApi(params, req, runtime), new GetDoctorComputeSummaryResponse({}));
  }

  /**
   * Obtains the information about resource usage in a cluster on E-MapReduce (EMR) Doctor.
   * 
   * @remarks
   * get one specific luster engine queue by <type, name>
   * 
   * @param request - GetDoctorComputeSummaryRequest
   * @returns GetDoctorComputeSummaryResponse
   */
  async getDoctorComputeSummary(request: GetDoctorComputeSummaryRequest): Promise<GetDoctorComputeSummaryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDoctorComputeSummaryWithOptions(request, runtime);
  }

  /**
   * Obtains the metrics of an HBase cluster.
   * 
   * @remarks
   * get Doctor HBaseCluster
   * 
   * @param request - GetDoctorHBaseClusterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDoctorHBaseClusterResponse
   */
  async getDoctorHBaseClusterWithOptions(request: GetDoctorHBaseClusterRequest, runtime: $Util.RuntimeOptions): Promise<GetDoctorHBaseClusterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dateTime)) {
      query["DateTime"] = request.dateTime;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDoctorHBaseCluster",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDoctorHBaseClusterResponse>(await this.callApi(params, req, runtime), new GetDoctorHBaseClusterResponse({}));
  }

  /**
   * Obtains the metrics of an HBase cluster.
   * 
   * @remarks
   * get Doctor HBaseCluster
   * 
   * @param request - GetDoctorHBaseClusterRequest
   * @returns GetDoctorHBaseClusterResponse
   */
  async getDoctorHBaseCluster(request: GetDoctorHBaseClusterRequest): Promise<GetDoctorHBaseClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDoctorHBaseClusterWithOptions(request, runtime);
  }

  /**
   * @remarks
   * list Doctor HBaseRegions
   * 
   * @param request - GetDoctorHBaseRegionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDoctorHBaseRegionResponse
   */
  async getDoctorHBaseRegionWithOptions(request: GetDoctorHBaseRegionRequest, runtime: $Util.RuntimeOptions): Promise<GetDoctorHBaseRegionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dateTime)) {
      query["DateTime"] = request.dateTime;
    }

    if (!Util.isUnset(request.hbaseRegionId)) {
      query["HbaseRegionId"] = request.hbaseRegionId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDoctorHBaseRegion",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDoctorHBaseRegionResponse>(await this.callApi(params, req, runtime), new GetDoctorHBaseRegionResponse({}));
  }

  /**
   * @remarks
   * list Doctor HBaseRegions
   * 
   * @param request - GetDoctorHBaseRegionRequest
   * @returns GetDoctorHBaseRegionResponse
   */
  async getDoctorHBaseRegion(request: GetDoctorHBaseRegionRequest): Promise<GetDoctorHBaseRegionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDoctorHBaseRegionWithOptions(request, runtime);
  }

  /**
   * Obtains the information about an HBase region server.
   * 
   * @remarks
   * get Doctor HBaseRegionServer
   * 
   * @param request - GetDoctorHBaseRegionServerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDoctorHBaseRegionServerResponse
   */
  async getDoctorHBaseRegionServerWithOptions(request: GetDoctorHBaseRegionServerRequest, runtime: $Util.RuntimeOptions): Promise<GetDoctorHBaseRegionServerResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dateTime)) {
      query["DateTime"] = request.dateTime;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionServerHost)) {
      query["RegionServerHost"] = request.regionServerHost;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDoctorHBaseRegionServer",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDoctorHBaseRegionServerResponse>(await this.callApi(params, req, runtime), new GetDoctorHBaseRegionServerResponse({}));
  }

  /**
   * Obtains the information about an HBase region server.
   * 
   * @remarks
   * get Doctor HBaseRegionServer
   * 
   * @param request - GetDoctorHBaseRegionServerRequest
   * @returns GetDoctorHBaseRegionServerResponse
   */
  async getDoctorHBaseRegionServer(request: GetDoctorHBaseRegionServerRequest): Promise<GetDoctorHBaseRegionServerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDoctorHBaseRegionServerWithOptions(request, runtime);
  }

  /**
   * @remarks
   * get Doctor HBaseTable
   * 
   * @param request - GetDoctorHBaseTableRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDoctorHBaseTableResponse
   */
  async getDoctorHBaseTableWithOptions(request: GetDoctorHBaseTableRequest, runtime: $Util.RuntimeOptions): Promise<GetDoctorHBaseTableResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dateTime)) {
      query["DateTime"] = request.dateTime;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDoctorHBaseTable",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDoctorHBaseTableResponse>(await this.callApi(params, req, runtime), new GetDoctorHBaseTableResponse({}));
  }

  /**
   * @remarks
   * get Doctor HBaseTable
   * 
   * @param request - GetDoctorHBaseTableRequest
   * @returns GetDoctorHBaseTableResponse
   */
  async getDoctorHBaseTable(request: GetDoctorHBaseTableRequest): Promise<GetDoctorHBaseTableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDoctorHBaseTableWithOptions(request, runtime);
  }

  /**
   * Obtains the analysis results of the Hadoop Distributed File System (HDFS) storage resources of a cluster on E-MapReduce (EMR) Doctor.
   * 
   * @remarks
   * list Doctor HBaseTableRegions
   * 
   * @param request - GetDoctorHDFSClusterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDoctorHDFSClusterResponse
   */
  async getDoctorHDFSClusterWithOptions(request: GetDoctorHDFSClusterRequest, runtime: $Util.RuntimeOptions): Promise<GetDoctorHDFSClusterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dateTime)) {
      query["DateTime"] = request.dateTime;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDoctorHDFSCluster",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDoctorHDFSClusterResponse>(await this.callApi(params, req, runtime), new GetDoctorHDFSClusterResponse({}));
  }

  /**
   * Obtains the analysis results of the Hadoop Distributed File System (HDFS) storage resources of a cluster on E-MapReduce (EMR) Doctor.
   * 
   * @remarks
   * list Doctor HBaseTableRegions
   * 
   * @param request - GetDoctorHDFSClusterRequest
   * @returns GetDoctorHDFSClusterResponse
   */
  async getDoctorHDFSCluster(request: GetDoctorHDFSClusterRequest): Promise<GetDoctorHDFSClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDoctorHDFSClusterWithOptions(request, runtime);
  }

  /**
   * Obtains the analysis results of a specific Hadoop Distributed File System (HDFS) directory of a cluster. The depth of the directory is not greater than five.
   * 
   * @remarks
   * get Doctor HDFSNode
   * 
   * @param request - GetDoctorHDFSDirectoryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDoctorHDFSDirectoryResponse
   */
  async getDoctorHDFSDirectoryWithOptions(request: GetDoctorHDFSDirectoryRequest, runtime: $Util.RuntimeOptions): Promise<GetDoctorHDFSDirectoryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dateTime)) {
      query["DateTime"] = request.dateTime;
    }

    if (!Util.isUnset(request.dirPath)) {
      query["DirPath"] = request.dirPath;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDoctorHDFSDirectory",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDoctorHDFSDirectoryResponse>(await this.callApi(params, req, runtime), new GetDoctorHDFSDirectoryResponse({}));
  }

  /**
   * Obtains the analysis results of a specific Hadoop Distributed File System (HDFS) directory of a cluster. The depth of the directory is not greater than five.
   * 
   * @remarks
   * get Doctor HDFSNode
   * 
   * @param request - GetDoctorHDFSDirectoryRequest
   * @returns GetDoctorHDFSDirectoryResponse
   */
  async getDoctorHDFSDirectory(request: GetDoctorHDFSDirectoryRequest): Promise<GetDoctorHDFSDirectoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDoctorHDFSDirectoryWithOptions(request, runtime);
  }

  /**
   * Obtains the analysis results of Hadoop Distributed File System (HDFS) storage resources for a specific owner or group on E-MapReduce (EMR) Doctor.
   * 
   * @remarks
   * get Doctor HDFS UGI
   * 
   * @param request - GetDoctorHDFSUGIRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDoctorHDFSUGIResponse
   */
  async getDoctorHDFSUGIWithOptions(request: GetDoctorHDFSUGIRequest, runtime: $Util.RuntimeOptions): Promise<GetDoctorHDFSUGIResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dateTime)) {
      query["DateTime"] = request.dateTime;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDoctorHDFSUGI",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDoctorHDFSUGIResponse>(await this.callApi(params, req, runtime), new GetDoctorHDFSUGIResponse({}));
  }

  /**
   * Obtains the analysis results of Hadoop Distributed File System (HDFS) storage resources for a specific owner or group on E-MapReduce (EMR) Doctor.
   * 
   * @remarks
   * get Doctor HDFS UGI
   * 
   * @param request - GetDoctorHDFSUGIRequest
   * @returns GetDoctorHDFSUGIResponse
   */
  async getDoctorHDFSUGI(request: GetDoctorHDFSUGIRequest): Promise<GetDoctorHDFSUGIResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDoctorHDFSUGIWithOptions(request, runtime);
  }

  /**
   * Obtains the analysis results of a Hive cluster.
   * 
   * @remarks
   * list Doctor Hive Cluster
   * 
   * @param request - GetDoctorHiveClusterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDoctorHiveClusterResponse
   */
  async getDoctorHiveClusterWithOptions(request: GetDoctorHiveClusterRequest, runtime: $Util.RuntimeOptions): Promise<GetDoctorHiveClusterResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dateTime)) {
      query["DateTime"] = request.dateTime;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDoctorHiveCluster",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDoctorHiveClusterResponse>(await this.callApi(params, req, runtime), new GetDoctorHiveClusterResponse({}));
  }

  /**
   * Obtains the analysis results of a Hive cluster.
   * 
   * @remarks
   * list Doctor Hive Cluster
   * 
   * @param request - GetDoctorHiveClusterRequest
   * @returns GetDoctorHiveClusterResponse
   */
  async getDoctorHiveCluster(request: GetDoctorHiveClusterRequest): Promise<GetDoctorHiveClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDoctorHiveClusterWithOptions(request, runtime);
  }

  /**
   * Obtains the analysis results of a Hive database.
   * 
   * @remarks
   * get Doctor Hive Database
   * 
   * @param request - GetDoctorHiveDatabaseRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDoctorHiveDatabaseResponse
   */
  async getDoctorHiveDatabaseWithOptions(request: GetDoctorHiveDatabaseRequest, runtime: $Util.RuntimeOptions): Promise<GetDoctorHiveDatabaseResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.databaseName)) {
      query["DatabaseName"] = request.databaseName;
    }

    if (!Util.isUnset(request.dateTime)) {
      query["DateTime"] = request.dateTime;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDoctorHiveDatabase",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDoctorHiveDatabaseResponse>(await this.callApi(params, req, runtime), new GetDoctorHiveDatabaseResponse({}));
  }

  /**
   * Obtains the analysis results of a Hive database.
   * 
   * @remarks
   * get Doctor Hive Database
   * 
   * @param request - GetDoctorHiveDatabaseRequest
   * @returns GetDoctorHiveDatabaseResponse
   */
  async getDoctorHiveDatabase(request: GetDoctorHiveDatabaseRequest): Promise<GetDoctorHiveDatabaseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDoctorHiveDatabaseWithOptions(request, runtime);
  }

  /**
   * Obtains the analysis results of a specific Hive table in a cluster on E-MapReduce (EMR) Doctor.
   * 
   * @remarks
   * get Doctor Hive Table
   * 
   * @param request - GetDoctorHiveTableRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDoctorHiveTableResponse
   */
  async getDoctorHiveTableWithOptions(request: GetDoctorHiveTableRequest, runtime: $Util.RuntimeOptions): Promise<GetDoctorHiveTableResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dateTime)) {
      query["DateTime"] = request.dateTime;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDoctorHiveTable",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDoctorHiveTableResponse>(await this.callApi(params, req, runtime), new GetDoctorHiveTableResponse({}));
  }

  /**
   * Obtains the analysis results of a specific Hive table in a cluster on E-MapReduce (EMR) Doctor.
   * 
   * @remarks
   * get Doctor Hive Table
   * 
   * @param request - GetDoctorHiveTableRequest
   * @returns GetDoctorHiveTableResponse
   */
  async getDoctorHiveTable(request: GetDoctorHiveTableRequest): Promise<GetDoctorHiveTableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDoctorHiveTableWithOptions(request, runtime);
  }

  /**
   * Obtains the basic running information about a job on E-MapReduce (EMR) Doctor.
   * 
   * @remarks
   * Get realtime job by yarn
   * 
   * @param request - GetDoctorJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDoctorJobResponse
   */
  async getDoctorJobWithOptions(request: GetDoctorJobRequest, runtime: $Util.RuntimeOptions): Promise<GetDoctorJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDoctorJob",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDoctorJobResponse>(await this.callApi(params, req, runtime), new GetDoctorJobResponse({}));
  }

  /**
   * Obtains the basic running information about a job on E-MapReduce (EMR) Doctor.
   * 
   * @remarks
   * Get realtime job by yarn
   * 
   * @param request - GetDoctorJobRequest
   * @returns GetDoctorJobResponse
   */
  async getDoctorJob(request: GetDoctorJobRequest): Promise<GetDoctorJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDoctorJobWithOptions(request, runtime);
  }

  /**
   * @remarks
   * get specify component's report analysis by emr doctor
   * 
   * @param request - GetDoctorReportComponentSummaryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDoctorReportComponentSummaryResponse
   */
  async getDoctorReportComponentSummaryWithOptions(request: GetDoctorReportComponentSummaryRequest, runtime: $Util.RuntimeOptions): Promise<GetDoctorReportComponentSummaryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.componentType)) {
      query["ComponentType"] = request.componentType;
    }

    if (!Util.isUnset(request.dateTime)) {
      query["DateTime"] = request.dateTime;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDoctorReportComponentSummary",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDoctorReportComponentSummaryResponse>(await this.callApi(params, req, runtime), new GetDoctorReportComponentSummaryResponse({}));
  }

  /**
   * @remarks
   * get specify component's report analysis by emr doctor
   * 
   * @param request - GetDoctorReportComponentSummaryRequest
   * @returns GetDoctorReportComponentSummaryResponse
   */
  async getDoctorReportComponentSummary(request: GetDoctorReportComponentSummaryRequest): Promise<GetDoctorReportComponentSummaryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDoctorReportComponentSummaryWithOptions(request, runtime);
  }

  /**
   * You can call this operation to obtain the details of a node group.
   * 
   * @remarks
   * 获取节点组详情。
   * 
   * @param request - GetNodeGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetNodeGroupResponse
   */
  async getNodeGroupWithOptions(request: GetNodeGroupRequest, runtime: $Util.RuntimeOptions): Promise<GetNodeGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.nodeGroupId)) {
      query["NodeGroupId"] = request.nodeGroupId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetNodeGroup",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetNodeGroupResponse>(await this.callApi(params, req, runtime), new GetNodeGroupResponse({}));
  }

  /**
   * You can call this operation to obtain the details of a node group.
   * 
   * @remarks
   * 获取节点组详情。
   * 
   * @param request - GetNodeGroupRequest
   * @returns GetNodeGroupResponse
   */
  async getNodeGroup(request: GetNodeGroupRequest): Promise<GetNodeGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getNodeGroupWithOptions(request, runtime);
  }

  /**
   * Gets the details of an asynchronous operation.
   * 
   * @param request - GetOperationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetOperationResponse
   */
  async getOperationWithOptions(request: GetOperationRequest, runtime: $Util.RuntimeOptions): Promise<GetOperationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.operationId)) {
      query["OperationId"] = request.operationId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetOperation",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOperationResponse>(await this.callApi(params, req, runtime), new GetOperationResponse({}));
  }

  /**
   * Gets the details of an asynchronous operation.
   * 
   * @param request - GetOperationRequest
   * @returns GetOperationResponse
   */
  async getOperation(request: GetOperationRequest): Promise<GetOperationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getOperationWithOptions(request, runtime);
  }

  /**
   * Scale out the node group.
   * 
   * @param request - IncreaseNodesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns IncreaseNodesResponse
   */
  async increaseNodesWithOptions(request: IncreaseNodesRequest, runtime: $Util.RuntimeOptions): Promise<IncreaseNodesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.applicationConfigs)) {
      query["ApplicationConfigs"] = request.applicationConfigs;
    }

    if (!Util.isUnset(request.autoPayOrder)) {
      query["AutoPayOrder"] = request.autoPayOrder;
    }

    if (!Util.isUnset(request.autoRenew)) {
      query["AutoRenew"] = request.autoRenew;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.increaseNodeCount)) {
      query["IncreaseNodeCount"] = request.increaseNodeCount;
    }

    if (!Util.isUnset(request.minIncreaseNodeCount)) {
      query["MinIncreaseNodeCount"] = request.minIncreaseNodeCount;
    }

    if (!Util.isUnset(request.nodeGroupId)) {
      query["NodeGroupId"] = request.nodeGroupId;
    }

    if (!Util.isUnset(request.paymentDuration)) {
      query["PaymentDuration"] = request.paymentDuration;
    }

    if (!Util.isUnset(request.paymentDurationUnit)) {
      query["PaymentDurationUnit"] = request.paymentDurationUnit;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "IncreaseNodes",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<IncreaseNodesResponse>(await this.callApi(params, req, runtime), new IncreaseNodesResponse({}));
  }

  /**
   * Scale out the node group.
   * 
   * @param request - IncreaseNodesRequest
   * @returns IncreaseNodesResponse
   */
  async increaseNodes(request: IncreaseNodesRequest): Promise<IncreaseNodesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.increaseNodesWithOptions(request, runtime);
  }

  /**
   * Add an EMR resource to the target resource group. A resource can belong to only one resource group.
   * 
   * @param request - JoinResourceGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns JoinResourceGroupResponse
   */
  async joinResourceGroupWithOptions(request: JoinResourceGroupRequest, runtime: $Util.RuntimeOptions): Promise<JoinResourceGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "JoinResourceGroup",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<JoinResourceGroupResponse>(await this.callApi(params, req, runtime), new JoinResourceGroupResponse({}));
  }

  /**
   * Add an EMR resource to the target resource group. A resource can belong to only one resource group.
   * 
   * @param request - JoinResourceGroupRequest
   * @returns JoinResourceGroupResponse
   */
  async joinResourceGroup(request: JoinResourceGroupRequest): Promise<JoinResourceGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.joinResourceGroupWithOptions(request, runtime);
  }

  /**
   * 查询API模板
   * 
   * @param request - ListApiTemplatesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListApiTemplatesResponse
   */
  async listApiTemplatesWithOptions(request: ListApiTemplatesRequest, runtime: $Util.RuntimeOptions): Promise<ListApiTemplatesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiName)) {
      query["ApiName"] = request.apiName;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.templateIds)) {
      query["TemplateIds"] = request.templateIds;
    }

    if (!Util.isUnset(request.templateName)) {
      query["TemplateName"] = request.templateName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListApiTemplates",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListApiTemplatesResponse>(await this.callApi(params, req, runtime), new ListApiTemplatesResponse({}));
  }

  /**
   * 查询API模板
   * 
   * @param request - ListApiTemplatesRequest
   * @returns ListApiTemplatesResponse
   */
  async listApiTemplates(request: ListApiTemplatesRequest): Promise<ListApiTemplatesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listApiTemplatesWithOptions(request, runtime);
  }

  /**
   * @remarks
   * 查询应用配置。
   * 
   * @param request - ListApplicationConfigsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListApplicationConfigsResponse
   */
  async listApplicationConfigsWithOptions(request: ListApplicationConfigsRequest, runtime: $Util.RuntimeOptions): Promise<ListApplicationConfigsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.applicationName)) {
      query["ApplicationName"] = request.applicationName;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.configFileName)) {
      query["ConfigFileName"] = request.configFileName;
    }

    if (!Util.isUnset(request.configItemKey)) {
      query["ConfigItemKey"] = request.configItemKey;
    }

    if (!Util.isUnset(request.configItemValue)) {
      query["ConfigItemValue"] = request.configItemValue;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.nodeGroupId)) {
      query["NodeGroupId"] = request.nodeGroupId;
    }

    if (!Util.isUnset(request.nodeId)) {
      query["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListApplicationConfigs",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListApplicationConfigsResponse>(await this.callApi(params, req, runtime), new ListApplicationConfigsResponse({}));
  }

  /**
   * @remarks
   * 查询应用配置。
   * 
   * @param request - ListApplicationConfigsRequest
   * @returns ListApplicationConfigsResponse
   */
  async listApplicationConfigs(request: ListApplicationConfigsRequest): Promise<ListApplicationConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listApplicationConfigsWithOptions(request, runtime);
  }

  /**
   * @param request - ListApplicationsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListApplicationsResponse
   */
  async listApplicationsWithOptions(request: ListApplicationsRequest, runtime: $Util.RuntimeOptions): Promise<ListApplicationsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.applicationNames)) {
      query["ApplicationNames"] = request.applicationNames;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListApplications",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListApplicationsResponse>(await this.callApi(params, req, runtime), new ListApplicationsResponse({}));
  }

  /**
   * @param request - ListApplicationsRequest
   * @returns ListApplicationsResponse
   */
  async listApplications(request: ListApplicationsRequest): Promise<ListApplicationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listApplicationsWithOptions(request, runtime);
  }

  /**
   * @remarks
   * 查询弹性伸缩活动列表。
   * 
   * @param request - ListAutoScalingActivitiesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListAutoScalingActivitiesResponse
   */
  async listAutoScalingActivitiesWithOptions(request: ListAutoScalingActivitiesRequest, runtime: $Util.RuntimeOptions): Promise<ListAutoScalingActivitiesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.nodeGroupId)) {
      query["NodeGroupId"] = request.nodeGroupId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.scalingActivityStates)) {
      query["ScalingActivityStates"] = request.scalingActivityStates;
    }

    if (!Util.isUnset(request.scalingActivityType)) {
      query["ScalingActivityType"] = request.scalingActivityType;
    }

    if (!Util.isUnset(request.scalingRuleName)) {
      query["ScalingRuleName"] = request.scalingRuleName;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListAutoScalingActivities",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListAutoScalingActivitiesResponse>(await this.callApi(params, req, runtime), new ListAutoScalingActivitiesResponse({}));
  }

  /**
   * @remarks
   * 查询弹性伸缩活动列表。
   * 
   * @param request - ListAutoScalingActivitiesRequest
   * @returns ListAutoScalingActivitiesResponse
   */
  async listAutoScalingActivities(request: ListAutoScalingActivitiesRequest): Promise<ListAutoScalingActivitiesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAutoScalingActivitiesWithOptions(request, runtime);
  }

  /**
   * Queries E-MapReduce (EMR) clusters.
   * 
   * @param request - ListClustersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListClustersResponse
   */
  async listClustersWithOptions(request: ListClustersRequest, runtime: $Util.RuntimeOptions): Promise<ListClustersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterIds)) {
      query["ClusterIds"] = request.clusterIds;
    }

    if (!Util.isUnset(request.clusterName)) {
      query["ClusterName"] = request.clusterName;
    }

    if (!Util.isUnset(request.clusterStates)) {
      query["ClusterStates"] = request.clusterStates;
    }

    if (!Util.isUnset(request.clusterTypes)) {
      query["ClusterTypes"] = request.clusterTypes;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.paymentTypes)) {
      query["PaymentTypes"] = request.paymentTypes;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListClusters",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListClustersResponse>(await this.callApi(params, req, runtime), new ListClustersResponse({}));
  }

  /**
   * Queries E-MapReduce (EMR) clusters.
   * 
   * @param request - ListClustersRequest
   * @returns ListClustersResponse
   */
  async listClusters(request: ListClustersRequest): Promise<ListClustersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClustersWithOptions(request, runtime);
  }

  /**
   * @remarks
   * 查询组件实例列表。
   * 
   * @param request - ListComponentInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListComponentInstancesResponse
   */
  async listComponentInstancesWithOptions(request: ListComponentInstancesRequest, runtime: $Util.RuntimeOptions): Promise<ListComponentInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.applicationNames)) {
      query["ApplicationNames"] = request.applicationNames;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.componentNames)) {
      query["ComponentNames"] = request.componentNames;
    }

    if (!Util.isUnset(request.componentStates)) {
      query["ComponentStates"] = request.componentStates;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.nodeIds)) {
      query["NodeIds"] = request.nodeIds;
    }

    if (!Util.isUnset(request.nodeNames)) {
      query["NodeNames"] = request.nodeNames;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListComponentInstances",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListComponentInstancesResponse>(await this.callApi(params, req, runtime), new ListComponentInstancesResponse({}));
  }

  /**
   * @remarks
   * 查询组件实例列表。
   * 
   * @param request - ListComponentInstancesRequest
   * @returns ListComponentInstancesResponse
   */
  async listComponentInstances(request: ListComponentInstancesRequest): Promise<ListComponentInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listComponentInstancesWithOptions(request, runtime);
  }

  /**
   * @param request - ListComponentsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListComponentsResponse
   */
  async listComponentsWithOptions(request: ListComponentsRequest, runtime: $Util.RuntimeOptions): Promise<ListComponentsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.applicationNames)) {
      query["ApplicationNames"] = request.applicationNames;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.componentNames)) {
      query["ComponentNames"] = request.componentNames;
    }

    if (!Util.isUnset(request.componentStates)) {
      query["ComponentStates"] = request.componentStates;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListComponents",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListComponentsResponse>(await this.callApi(params, req, runtime), new ListComponentsResponse({}));
  }

  /**
   * @param request - ListComponentsRequest
   * @returns ListComponentsResponse
   */
  async listComponents(request: ListComponentsRequest): Promise<ListComponentsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listComponentsWithOptions(request, runtime);
  }

  /**
   * Obtains the analysis results of multiple jobs on E-MapReduce (EMR) Doctor.
   * 
   * @remarks
   * list all doctor analysis apps
   * 
   * @param request - ListDoctorApplicationsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDoctorApplicationsResponse
   */
  async listDoctorApplicationsWithOptions(request: ListDoctorApplicationsRequest, runtime: $Util.RuntimeOptions): Promise<ListDoctorApplicationsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appIds)) {
      query["AppIds"] = request.appIds;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dateTime)) {
      query["DateTime"] = request.dateTime;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["OrderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.orderType)) {
      query["OrderType"] = request.orderType;
    }

    if (!Util.isUnset(request.queues)) {
      query["Queues"] = request.queues;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.types)) {
      query["Types"] = request.types;
    }

    if (!Util.isUnset(request.users)) {
      query["Users"] = request.users;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDoctorApplications",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDoctorApplicationsResponse>(await this.callApi(params, req, runtime), new ListDoctorApplicationsResponse({}));
  }

  /**
   * Obtains the analysis results of multiple jobs on E-MapReduce (EMR) Doctor.
   * 
   * @remarks
   * list all doctor analysis apps
   * 
   * @param request - ListDoctorApplicationsRequest
   * @returns ListDoctorApplicationsResponse
   */
  async listDoctorApplications(request: ListDoctorApplicationsRequest): Promise<ListDoctorApplicationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDoctorApplicationsWithOptions(request, runtime);
  }

  /**
   * Obtains the information about resource usage by resource type in a cluster on E-MapReduce (EMR) Doctor.
   * 
   * @remarks
   * list Doctor analysis result of cluster engine queue view
   * 
   * @param request - ListDoctorComputeSummaryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDoctorComputeSummaryResponse
   */
  async listDoctorComputeSummaryWithOptions(request: ListDoctorComputeSummaryRequest, runtime: $Util.RuntimeOptions): Promise<ListDoctorComputeSummaryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.componentTypes)) {
      query["ComponentTypes"] = request.componentTypes;
    }

    if (!Util.isUnset(request.dateTime)) {
      query["DateTime"] = request.dateTime;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["OrderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.orderType)) {
      query["OrderType"] = request.orderType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDoctorComputeSummary",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDoctorComputeSummaryResponse>(await this.callApi(params, req, runtime), new ListDoctorComputeSummaryResponse({}));
  }

  /**
   * Obtains the information about resource usage by resource type in a cluster on E-MapReduce (EMR) Doctor.
   * 
   * @remarks
   * list Doctor analysis result of cluster engine queue view
   * 
   * @param request - ListDoctorComputeSummaryRequest
   * @returns ListDoctorComputeSummaryResponse
   */
  async listDoctorComputeSummary(request: ListDoctorComputeSummaryRequest): Promise<ListDoctorComputeSummaryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDoctorComputeSummaryWithOptions(request, runtime);
  }

  /**
   * Obtains the information about multiple HBase RegionServers at a time.
   * 
   * @remarks
   * list Doctor HBaseRegionServers
   * 
   * @param request - ListDoctorHBaseRegionServersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDoctorHBaseRegionServersResponse
   */
  async listDoctorHBaseRegionServersWithOptions(request: ListDoctorHBaseRegionServersRequest, runtime: $Util.RuntimeOptions): Promise<ListDoctorHBaseRegionServersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dateTime)) {
      query["DateTime"] = request.dateTime;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["OrderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.orderType)) {
      query["OrderType"] = request.orderType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.regionServerHosts)) {
      query["RegionServerHosts"] = request.regionServerHosts;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDoctorHBaseRegionServers",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDoctorHBaseRegionServersResponse>(await this.callApi(params, req, runtime), new ListDoctorHBaseRegionServersResponse({}));
  }

  /**
   * Obtains the information about multiple HBase RegionServers at a time.
   * 
   * @remarks
   * list Doctor HBaseRegionServers
   * 
   * @param request - ListDoctorHBaseRegionServersRequest
   * @returns ListDoctorHBaseRegionServersResponse
   */
  async listDoctorHBaseRegionServers(request: ListDoctorHBaseRegionServersRequest): Promise<ListDoctorHBaseRegionServersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDoctorHBaseRegionServersWithOptions(request, runtime);
  }

  /**
   * Obtains the information about multiple HBase tables at a time.
   * 
   * @remarks
   * list Doctor HBaseTables
   * 
   * @param request - ListDoctorHBaseTablesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDoctorHBaseTablesResponse
   */
  async listDoctorHBaseTablesWithOptions(request: ListDoctorHBaseTablesRequest, runtime: $Util.RuntimeOptions): Promise<ListDoctorHBaseTablesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dateTime)) {
      query["DateTime"] = request.dateTime;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["OrderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.orderType)) {
      query["OrderType"] = request.orderType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.tableNames)) {
      query["TableNames"] = request.tableNames;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDoctorHBaseTables",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDoctorHBaseTablesResponse>(await this.callApi(params, req, runtime), new ListDoctorHBaseTablesResponse({}));
  }

  /**
   * Obtains the information about multiple HBase tables at a time.
   * 
   * @remarks
   * list Doctor HBaseTables
   * 
   * @param request - ListDoctorHBaseTablesRequest
   * @returns ListDoctorHBaseTablesResponse
   */
  async listDoctorHBaseTables(request: ListDoctorHBaseTablesRequest): Promise<ListDoctorHBaseTablesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDoctorHBaseTablesWithOptions(request, runtime);
  }

  /**
   * @remarks
   * list Doctor HDFSNodes
   * 
   * @param request - ListDoctorHDFSDirectoriesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDoctorHDFSDirectoriesResponse
   */
  async listDoctorHDFSDirectoriesWithOptions(request: ListDoctorHDFSDirectoriesRequest, runtime: $Util.RuntimeOptions): Promise<ListDoctorHDFSDirectoriesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dateTime)) {
      query["DateTime"] = request.dateTime;
    }

    if (!Util.isUnset(request.dirPath)) {
      query["DirPath"] = request.dirPath;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["OrderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.orderType)) {
      query["OrderType"] = request.orderType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDoctorHDFSDirectories",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDoctorHDFSDirectoriesResponse>(await this.callApi(params, req, runtime), new ListDoctorHDFSDirectoriesResponse({}));
  }

  /**
   * @remarks
   * list Doctor HDFSNodes
   * 
   * @param request - ListDoctorHDFSDirectoriesRequest
   * @returns ListDoctorHDFSDirectoriesResponse
   */
  async listDoctorHDFSDirectories(request: ListDoctorHDFSDirectoriesRequest): Promise<ListDoctorHDFSDirectoriesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDoctorHDFSDirectoriesWithOptions(request, runtime);
  }

  /**
   * Obtains the analysis results of Hadoop Distributed File System (HDFS) storage resources for multiple owners or groups at a time on E-MapReduce (EMR) Doctor.
   * 
   * @remarks
   * list Doctor HDFS UGIs
   * 
   * @param request - ListDoctorHDFSUGIRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDoctorHDFSUGIResponse
   */
  async listDoctorHDFSUGIWithOptions(request: ListDoctorHDFSUGIRequest, runtime: $Util.RuntimeOptions): Promise<ListDoctorHDFSUGIResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dateTime)) {
      query["DateTime"] = request.dateTime;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["OrderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.orderType)) {
      query["OrderType"] = request.orderType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDoctorHDFSUGI",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDoctorHDFSUGIResponse>(await this.callApi(params, req, runtime), new ListDoctorHDFSUGIResponse({}));
  }

  /**
   * Obtains the analysis results of Hadoop Distributed File System (HDFS) storage resources for multiple owners or groups at a time on E-MapReduce (EMR) Doctor.
   * 
   * @remarks
   * list Doctor HDFS UGIs
   * 
   * @param request - ListDoctorHDFSUGIRequest
   * @returns ListDoctorHDFSUGIResponse
   */
  async listDoctorHDFSUGI(request: ListDoctorHDFSUGIRequest): Promise<ListDoctorHDFSUGIResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDoctorHDFSUGIWithOptions(request, runtime);
  }

  /**
   * Obtains the analysis results of multiple Hive databases at a time.
   * 
   * @remarks
   * list Doctor Hive Databases
   * 
   * @param request - ListDoctorHiveDatabasesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDoctorHiveDatabasesResponse
   */
  async listDoctorHiveDatabasesWithOptions(request: ListDoctorHiveDatabasesRequest, runtime: $Util.RuntimeOptions): Promise<ListDoctorHiveDatabasesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.databaseNames)) {
      query["DatabaseNames"] = request.databaseNames;
    }

    if (!Util.isUnset(request.dateTime)) {
      query["DateTime"] = request.dateTime;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["OrderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.orderType)) {
      query["OrderType"] = request.orderType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDoctorHiveDatabases",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDoctorHiveDatabasesResponse>(await this.callApi(params, req, runtime), new ListDoctorHiveDatabasesResponse({}));
  }

  /**
   * Obtains the analysis results of multiple Hive databases at a time.
   * 
   * @remarks
   * list Doctor Hive Databases
   * 
   * @param request - ListDoctorHiveDatabasesRequest
   * @returns ListDoctorHiveDatabasesResponse
   */
  async listDoctorHiveDatabases(request: ListDoctorHiveDatabasesRequest): Promise<ListDoctorHiveDatabasesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDoctorHiveDatabasesWithOptions(request, runtime);
  }

  /**
   * Obtains the analysis results of multiple Hive tables at a time on E-MapReduce (EMR) Doctor.
   * 
   * @remarks
   * list Doctor Hive Tables
   * 
   * @param request - ListDoctorHiveTablesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDoctorHiveTablesResponse
   */
  async listDoctorHiveTablesWithOptions(request: ListDoctorHiveTablesRequest, runtime: $Util.RuntimeOptions): Promise<ListDoctorHiveTablesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dateTime)) {
      query["DateTime"] = request.dateTime;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["OrderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.orderType)) {
      query["OrderType"] = request.orderType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.tableNames)) {
      query["TableNames"] = request.tableNames;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDoctorHiveTables",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDoctorHiveTablesResponse>(await this.callApi(params, req, runtime), new ListDoctorHiveTablesResponse({}));
  }

  /**
   * Obtains the analysis results of multiple Hive tables at a time on E-MapReduce (EMR) Doctor.
   * 
   * @remarks
   * list Doctor Hive Tables
   * 
   * @param request - ListDoctorHiveTablesRequest
   * @returns ListDoctorHiveTablesResponse
   */
  async listDoctorHiveTables(request: ListDoctorHiveTablesRequest): Promise<ListDoctorHiveTablesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDoctorHiveTablesWithOptions(request, runtime);
  }

  /**
   * Obtains the basic running information about multiple jobs at a time on E-MapReduce (EMR) Doctor.
   * 
   * @remarks
   * list realtime jobs by yarn
   * 
   * @param request - ListDoctorJobsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDoctorJobsResponse
   */
  async listDoctorJobsWithOptions(request: ListDoctorJobsRequest, runtime: $Util.RuntimeOptions): Promise<ListDoctorJobsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appIds)) {
      query["AppIds"] = request.appIds;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.endRange)) {
      query["EndRange"] = request.endRange;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["OrderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.orderType)) {
      query["OrderType"] = request.orderType;
    }

    if (!Util.isUnset(request.queues)) {
      query["Queues"] = request.queues;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.startRange)) {
      query["StartRange"] = request.startRange;
    }

    if (!Util.isUnset(request.types)) {
      query["Types"] = request.types;
    }

    if (!Util.isUnset(request.users)) {
      query["Users"] = request.users;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDoctorJobs",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDoctorJobsResponse>(await this.callApi(params, req, runtime), new ListDoctorJobsResponse({}));
  }

  /**
   * Obtains the basic running information about multiple jobs at a time on E-MapReduce (EMR) Doctor.
   * 
   * @remarks
   * list realtime jobs by yarn
   * 
   * @param request - ListDoctorJobsRequest
   * @returns ListDoctorJobsResponse
   */
  async listDoctorJobs(request: ListDoctorJobsRequest): Promise<ListDoctorJobsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDoctorJobsWithOptions(request, runtime);
  }

  /**
   * Obtains the summary of basic running information about multiple jobs at a time on E-MapReduce (EMR) Doctor.
   * 
   * @remarks
   * list stats groupBy jobs by yarn
   * 
   * @param request - ListDoctorJobsStatsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDoctorJobsStatsResponse
   */
  async listDoctorJobsStatsWithOptions(request: ListDoctorJobsStatsRequest, runtime: $Util.RuntimeOptions): Promise<ListDoctorJobsStatsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.endRange)) {
      query["EndRange"] = request.endRange;
    }

    if (!Util.isUnset(request.groupBy)) {
      query["GroupBy"] = request.groupBy;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["OrderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.orderType)) {
      query["OrderType"] = request.orderType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.startRange)) {
      query["StartRange"] = request.startRange;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDoctorJobsStats",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDoctorJobsStatsResponse>(await this.callApi(params, req, runtime), new ListDoctorJobsStatsResponse({}));
  }

  /**
   * Obtains the summary of basic running information about multiple jobs at a time on E-MapReduce (EMR) Doctor.
   * 
   * @remarks
   * list stats groupBy jobs by yarn
   * 
   * @param request - ListDoctorJobsStatsRequest
   * @returns ListDoctorJobsStatsResponse
   */
  async listDoctorJobsStats(request: ListDoctorJobsStatsRequest): Promise<ListDoctorJobsStatsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDoctorJobsStatsWithOptions(request, runtime);
  }

  /**
   * Obtains the overall analysis result reports of E-MapReduce (EMR) Doctor at a time.
   * 
   * @remarks
   * list all reports analysis by emr doctor
   * 
   * @param request - ListDoctorReportsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDoctorReportsResponse
   */
  async listDoctorReportsWithOptions(request: ListDoctorReportsRequest, runtime: $Util.RuntimeOptions): Promise<ListDoctorReportsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDoctorReports",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDoctorReportsResponse>(await this.callApi(params, req, runtime), new ListDoctorReportsResponse({}));
  }

  /**
   * Obtains the overall analysis result reports of E-MapReduce (EMR) Doctor at a time.
   * 
   * @remarks
   * list all reports analysis by emr doctor
   * 
   * @param request - ListDoctorReportsRequest
   * @returns ListDoctorReportsResponse
   */
  async listDoctorReports(request: ListDoctorReportsRequest): Promise<ListDoctorReportsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDoctorReportsWithOptions(request, runtime);
  }

  /**
   * @param request - ListInstanceTypesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListInstanceTypesResponse
   */
  async listInstanceTypesWithOptions(request: ListInstanceTypesRequest, runtime: $Util.RuntimeOptions): Promise<ListInstanceTypesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.clusterType)) {
      query["ClusterType"] = request.clusterType;
    }

    if (!Util.isUnset(request.deployMode)) {
      query["DeployMode"] = request.deployMode;
    }

    if (!Util.isUnset(request.instanceType)) {
      query["InstanceType"] = request.instanceType;
    }

    if (!Util.isUnset(request.isModification)) {
      query["IsModification"] = request.isModification;
    }

    if (!Util.isUnset(request.nodeGroupId)) {
      query["NodeGroupId"] = request.nodeGroupId;
    }

    if (!Util.isUnset(request.nodeGroupType)) {
      query["NodeGroupType"] = request.nodeGroupType;
    }

    if (!Util.isUnset(request.paymentType)) {
      query["PaymentType"] = request.paymentType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.releaseVersion)) {
      query["ReleaseVersion"] = request.releaseVersion;
    }

    if (!Util.isUnset(request.zoneId)) {
      query["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListInstanceTypes",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListInstanceTypesResponse>(await this.callApi(params, req, runtime), new ListInstanceTypesResponse({}));
  }

  /**
   * @param request - ListInstanceTypesRequest
   * @returns ListInstanceTypesResponse
   */
  async listInstanceTypes(request: ListInstanceTypesRequest): Promise<ListInstanceTypesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listInstanceTypesWithOptions(request, runtime);
  }

  /**
   * Queries the list of node groups in an EMR cluster.
   * 
   * @param request - ListNodeGroupsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListNodeGroupsResponse
   */
  async listNodeGroupsWithOptions(request: ListNodeGroupsRequest, runtime: $Util.RuntimeOptions): Promise<ListNodeGroupsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.nodeGroupIds)) {
      query["NodeGroupIds"] = request.nodeGroupIds;
    }

    if (!Util.isUnset(request.nodeGroupNames)) {
      query["NodeGroupNames"] = request.nodeGroupNames;
    }

    if (!Util.isUnset(request.nodeGroupStates)) {
      query["NodeGroupStates"] = request.nodeGroupStates;
    }

    if (!Util.isUnset(request.nodeGroupTypes)) {
      query["NodeGroupTypes"] = request.nodeGroupTypes;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListNodeGroups",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListNodeGroupsResponse>(await this.callApi(params, req, runtime), new ListNodeGroupsResponse({}));
  }

  /**
   * Queries the list of node groups in an EMR cluster.
   * 
   * @param request - ListNodeGroupsRequest
   * @returns ListNodeGroupsResponse
   */
  async listNodeGroups(request: ListNodeGroupsRequest): Promise<ListNodeGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listNodeGroupsWithOptions(request, runtime);
  }

  /**
   * Queries the node list of an EMR cluster.
   * 
   * @param request - ListNodesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListNodesResponse
   */
  async listNodesWithOptions(request: ListNodesRequest, runtime: $Util.RuntimeOptions): Promise<ListNodesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.nodeGroupIds)) {
      query["NodeGroupIds"] = request.nodeGroupIds;
    }

    if (!Util.isUnset(request.nodeIds)) {
      query["NodeIds"] = request.nodeIds;
    }

    if (!Util.isUnset(request.nodeNames)) {
      query["NodeNames"] = request.nodeNames;
    }

    if (!Util.isUnset(request.nodeStates)) {
      query["NodeStates"] = request.nodeStates;
    }

    if (!Util.isUnset(request.privateIps)) {
      query["PrivateIps"] = request.privateIps;
    }

    if (!Util.isUnset(request.publicIps)) {
      query["PublicIps"] = request.publicIps;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListNodes",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListNodesResponse>(await this.callApi(params, req, runtime), new ListNodesResponse({}));
  }

  /**
   * Queries the node list of an EMR cluster.
   * 
   * @param request - ListNodesRequest
   * @returns ListNodesResponse
   */
  async listNodes(request: ListNodesRequest): Promise<ListNodesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listNodesWithOptions(request, runtime);
  }

  /**
   * Queries the major E-MapReduce (EMR) versions.
   * 
   * @remarks
   * 查询主版本。
   * 
   * @param request - ListReleaseVersionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListReleaseVersionsResponse
   */
  async listReleaseVersionsWithOptions(request: ListReleaseVersionsRequest, runtime: $Util.RuntimeOptions): Promise<ListReleaseVersionsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterType)) {
      query["ClusterType"] = request.clusterType;
    }

    if (!Util.isUnset(request.iaasType)) {
      query["IaasType"] = request.iaasType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListReleaseVersions",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListReleaseVersionsResponse>(await this.callApi(params, req, runtime), new ListReleaseVersionsResponse({}));
  }

  /**
   * Queries the major E-MapReduce (EMR) versions.
   * 
   * @remarks
   * 查询主版本。
   * 
   * @param request - ListReleaseVersionsRequest
   * @returns ListReleaseVersionsResponse
   */
  async listReleaseVersions(request: ListReleaseVersionsRequest): Promise<ListReleaseVersionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listReleaseVersionsWithOptions(request, runtime);
  }

  /**
   * @param request - ListScriptsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListScriptsResponse
   */
  async listScriptsWithOptions(request: ListScriptsRequest, runtime: $Util.RuntimeOptions): Promise<ListScriptsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.scriptType)) {
      query["ScriptType"] = request.scriptType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListScripts",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListScriptsResponse>(await this.callApi(params, req, runtime), new ListScriptsResponse({}));
  }

  /**
   * @param request - ListScriptsRequest
   * @returns ListScriptsResponse
   */
  async listScripts(request: ListScriptsRequest): Promise<ListScriptsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listScriptsWithOptions(request, runtime);
  }

  /**
   * Queries the tags that are bound to an EMR cluster.
   * 
   * @param request - ListTagResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListTagResourcesResponse
   */
  async listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<ListTagResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.maxResults)) {
      query["MaxResults"] = request.maxResults;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceIds)) {
      query["ResourceIds"] = request.resourceIds;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTagResources",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTagResourcesResponse>(await this.callApi(params, req, runtime), new ListTagResourcesResponse({}));
  }

  /**
   * Queries the tags that are bound to an EMR cluster.
   * 
   * @param request - ListTagResourcesRequest
   * @returns ListTagResourcesResponse
   */
  async listTagResources(request: ListTagResourcesRequest): Promise<ListTagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTagResourcesWithOptions(request, runtime);
  }

  /**
   * Configures auto scaling rules.
   * 
   * @remarks
   * You can call this operation to configure auto scaling policies.
   * 
   * @param request - PutAutoScalingPolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PutAutoScalingPolicyResponse
   */
  async putAutoScalingPolicyWithOptions(request: PutAutoScalingPolicyRequest, runtime: $Util.RuntimeOptions): Promise<PutAutoScalingPolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.constraints)) {
      query["Constraints"] = request.constraints;
    }

    if (!Util.isUnset(request.nodeGroupId)) {
      query["NodeGroupId"] = request.nodeGroupId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.scalingRules)) {
      query["ScalingRules"] = request.scalingRules;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PutAutoScalingPolicy",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PutAutoScalingPolicyResponse>(await this.callApi(params, req, runtime), new PutAutoScalingPolicyResponse({}));
  }

  /**
   * Configures auto scaling rules.
   * 
   * @remarks
   * You can call this operation to configure auto scaling policies.
   * 
   * @param request - PutAutoScalingPolicyRequest
   * @returns PutAutoScalingPolicyResponse
   */
  async putAutoScalingPolicy(request: PutAutoScalingPolicyRequest): Promise<PutAutoScalingPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.putAutoScalingPolicyWithOptions(request, runtime);
  }

  /**
   * @param request - RemoveAutoScalingPolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RemoveAutoScalingPolicyResponse
   */
  async removeAutoScalingPolicyWithOptions(request: RemoveAutoScalingPolicyRequest, runtime: $Util.RuntimeOptions): Promise<RemoveAutoScalingPolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.nodeGroupId)) {
      query["NodeGroupId"] = request.nodeGroupId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RemoveAutoScalingPolicy",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RemoveAutoScalingPolicyResponse>(await this.callApi(params, req, runtime), new RemoveAutoScalingPolicyResponse({}));
  }

  /**
   * @param request - RemoveAutoScalingPolicyRequest
   * @returns RemoveAutoScalingPolicyResponse
   */
  async removeAutoScalingPolicy(request: RemoveAutoScalingPolicyRequest): Promise<RemoveAutoScalingPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removeAutoScalingPolicyWithOptions(request, runtime);
  }

  /**
   * @param request - RunApiTemplateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RunApiTemplateResponse
   */
  async runApiTemplateWithOptions(request: RunApiTemplateRequest, runtime: $Util.RuntimeOptions): Promise<RunApiTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiName)) {
      query["ApiName"] = request.apiName;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RunApiTemplate",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RunApiTemplateResponse>(await this.callApi(params, req, runtime), new RunApiTemplateResponse({}));
  }

  /**
   * @param request - RunApiTemplateRequest
   * @returns RunApiTemplateResponse
   */
  async runApiTemplate(request: RunApiTemplateRequest): Promise<RunApiTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.runApiTemplateWithOptions(request, runtime);
  }

  /**
   * @param request - RunApplicationActionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RunApplicationActionResponse
   */
  async runApplicationActionWithOptions(request: RunApplicationActionRequest, runtime: $Util.RuntimeOptions): Promise<RunApplicationActionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.actionName)) {
      query["ActionName"] = request.actionName;
    }

    if (!Util.isUnset(request.batchSize)) {
      query["BatchSize"] = request.batchSize;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.componentInstanceSelector)) {
      query["ComponentInstanceSelector"] = request.componentInstanceSelector;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.executeStrategy)) {
      query["ExecuteStrategy"] = request.executeStrategy;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.rollingExecute)) {
      query["RollingExecute"] = request.rollingExecute;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RunApplicationAction",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RunApplicationActionResponse>(await this.callApi(params, req, runtime), new RunApplicationActionResponse({}));
  }

  /**
   * @param request - RunApplicationActionRequest
   * @returns RunApplicationActionResponse
   */
  async runApplicationAction(request: RunApplicationActionRequest): Promise<RunApplicationActionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.runApplicationActionWithOptions(request, runtime);
  }

  /**
   * @param tmpReq - RunClusterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RunClusterResponse
   */
  async runClusterWithOptions(tmpReq: RunClusterRequest, runtime: $Util.RuntimeOptions): Promise<RunClusterResponse> {
    Util.validateModel(tmpReq);
    let request = new RunClusterShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.applicationConfigs)) {
      request.applicationConfigsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.applicationConfigs, "ApplicationConfigs", "json");
    }

    if (!Util.isUnset(tmpReq.applications)) {
      request.applicationsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.applications, "Applications", "json");
    }

    if (!Util.isUnset(tmpReq.bootstrapScripts)) {
      request.bootstrapScriptsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.bootstrapScripts, "BootstrapScripts", "json");
    }

    if (!Util.isUnset(tmpReq.nodeAttributes)) {
      request.nodeAttributesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.nodeAttributes, "NodeAttributes", "json");
    }

    if (!Util.isUnset(tmpReq.nodeGroups)) {
      request.nodeGroupsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.nodeGroups, "NodeGroups", "json");
    }

    if (!Util.isUnset(tmpReq.subscriptionConfig)) {
      request.subscriptionConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.subscriptionConfig, "SubscriptionConfig", "json");
    }

    if (!Util.isUnset(tmpReq.tags)) {
      request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, "Tags", "json");
    }

    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.applicationConfigsShrink)) {
      body["ApplicationConfigs"] = request.applicationConfigsShrink;
    }

    if (!Util.isUnset(request.applicationsShrink)) {
      body["Applications"] = request.applicationsShrink;
    }

    if (!Util.isUnset(request.bootstrapScriptsShrink)) {
      body["BootstrapScripts"] = request.bootstrapScriptsShrink;
    }

    if (!Util.isUnset(request.clientToken)) {
      body["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.clusterName)) {
      body["ClusterName"] = request.clusterName;
    }

    if (!Util.isUnset(request.clusterType)) {
      body["ClusterType"] = request.clusterType;
    }

    if (!Util.isUnset(request.deployMode)) {
      body["DeployMode"] = request.deployMode;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.nodeAttributesShrink)) {
      body["NodeAttributes"] = request.nodeAttributesShrink;
    }

    if (!Util.isUnset(request.nodeGroupsShrink)) {
      body["NodeGroups"] = request.nodeGroupsShrink;
    }

    if (!Util.isUnset(request.paymentType)) {
      body["PaymentType"] = request.paymentType;
    }

    if (!Util.isUnset(request.releaseVersion)) {
      body["ReleaseVersion"] = request.releaseVersion;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      body["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.securityMode)) {
      body["SecurityMode"] = request.securityMode;
    }

    if (!Util.isUnset(request.subscriptionConfigShrink)) {
      body["SubscriptionConfig"] = request.subscriptionConfigShrink;
    }

    if (!Util.isUnset(request.tagsShrink)) {
      body["Tags"] = request.tagsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "RunCluster",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RunClusterResponse>(await this.callApi(params, req, runtime), new RunClusterResponse({}));
  }

  /**
   * @param request - RunClusterRequest
   * @returns RunClusterResponse
   */
  async runCluster(request: RunClusterRequest): Promise<RunClusterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.runClusterWithOptions(request, runtime);
  }

  /**
   * Bind tags to a specified EMR cluster.
   * 
   * @param request - TagResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns TagResourcesResponse
   */
  async tagResourcesWithOptions(request: TagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<TagResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceIds)) {
      query["ResourceIds"] = request.resourceIds;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "TagResources",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<TagResourcesResponse>(await this.callApi(params, req, runtime), new TagResourcesResponse({}));
  }

  /**
   * Bind tags to a specified EMR cluster.
   * 
   * @param request - TagResourcesRequest
   * @returns TagResourcesResponse
   */
  async tagResources(request: TagResourcesRequest): Promise<TagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.tagResourcesWithOptions(request, runtime);
  }

  /**
   * Unbinds tags from a specified column in an EMR cluster. If the tag is not bound to other resources, the tag is automatically deleted.
   * 
   * @param request - UntagResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UntagResourcesResponse
   */
  async untagResourcesWithOptions(request: UntagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<UntagResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.all)) {
      query["All"] = request.all;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceIds)) {
      query["ResourceIds"] = request.resourceIds;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.tagKeys)) {
      query["TagKeys"] = request.tagKeys;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UntagResources",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UntagResourcesResponse>(await this.callApi(params, req, runtime), new UntagResourcesResponse({}));
  }

  /**
   * Unbinds tags from a specified column in an EMR cluster. If the tag is not bound to other resources, the tag is automatically deleted.
   * 
   * @param request - UntagResourcesRequest
   * @returns UntagResourcesResponse
   */
  async untagResources(request: UntagResourcesRequest): Promise<UntagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.untagResourcesWithOptions(request, runtime);
  }

  /**
   * Updates an API operation template.
   * 
   * @remarks
   * 修改集群模板
   * 
   * @param request - UpdateApiTemplateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateApiTemplateResponse
   */
  async updateApiTemplateWithOptions(request: UpdateApiTemplateRequest, runtime: $Util.RuntimeOptions): Promise<UpdateApiTemplateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiName)) {
      query["ApiName"] = request.apiName;
    }

    if (!Util.isUnset(request.content)) {
      query["Content"] = request.content;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.templateId)) {
      query["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.templateName)) {
      query["TemplateName"] = request.templateName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateApiTemplate",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateApiTemplateResponse>(await this.callApi(params, req, runtime), new UpdateApiTemplateResponse({}));
  }

  /**
   * Updates an API operation template.
   * 
   * @remarks
   * 修改集群模板
   * 
   * @param request - UpdateApiTemplateRequest
   * @returns UpdateApiTemplateResponse
   */
  async updateApiTemplate(request: UpdateApiTemplateRequest): Promise<UpdateApiTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateApiTemplateWithOptions(request, runtime);
  }

  /**
   * @param request - UpdateApplicationConfigsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateApplicationConfigsResponse
   */
  async updateApplicationConfigsWithOptions(request: UpdateApplicationConfigsRequest, runtime: $Util.RuntimeOptions): Promise<UpdateApplicationConfigsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.applicationName)) {
      query["ApplicationName"] = request.applicationName;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.configAction)) {
      query["ConfigAction"] = request.configAction;
    }

    if (!Util.isUnset(request.configScope)) {
      query["ConfigScope"] = request.configScope;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.nodeGroupId)) {
      query["NodeGroupId"] = request.nodeGroupId;
    }

    if (!Util.isUnset(request.nodeId)) {
      query["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.refreshConfig)) {
      query["RefreshConfig"] = request.refreshConfig;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let body : {[key: string ]: any} = { };
    let bodyFlat : {[key: string ]: any} = { };
    if (!Util.isUnset(request.applicationConfigs)) {
      bodyFlat["ApplicationConfigs"] = request.applicationConfigs;
    }

    body = {
      ...body,
      ...OpenApiUtil.query(bodyFlat),
    };
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateApplicationConfigs",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateApplicationConfigsResponse>(await this.callApi(params, req, runtime), new UpdateApplicationConfigsResponse({}));
  }

  /**
   * @param request - UpdateApplicationConfigsRequest
   * @returns UpdateApplicationConfigsResponse
   */
  async updateApplicationConfigs(request: UpdateApplicationConfigsRequest): Promise<UpdateApplicationConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateApplicationConfigsWithOptions(request, runtime);
  }

  /**
   * Updates a bootstrap action or a common script of an E-MapReduce (EMR) cluster.
   * 
   * @param tmpReq - UpdateScriptRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateScriptResponse
   */
  async updateScriptWithOptions(tmpReq: UpdateScriptRequest, runtime: $Util.RuntimeOptions): Promise<UpdateScriptResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateScriptShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.script)) {
      request.scriptShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.script, "Script", "json");
    }

    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.scriptShrink)) {
      query["Script"] = request.scriptShrink;
    }

    if (!Util.isUnset(request.scriptId)) {
      query["ScriptId"] = request.scriptId;
    }

    if (!Util.isUnset(request.scriptType)) {
      query["ScriptType"] = request.scriptType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateScript",
      version: "2021-03-20",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateScriptResponse>(await this.callApi(params, req, runtime), new UpdateScriptResponse({}));
  }

  /**
   * Updates a bootstrap action or a common script of an E-MapReduce (EMR) cluster.
   * 
   * @param request - UpdateScriptRequest
   * @returns UpdateScriptResponse
   */
  async updateScript(request: UpdateScriptRequest): Promise<UpdateScriptResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateScriptWithOptions(request, runtime);
  }

}
