// This file is auto-generated, don't edit it
/**
 */
import Util, * as $Util from '@alicloud/tea-util';
import OSS, * as $OSS from '@alicloud/oss-client';
import OpenPlatform, * as $OpenPlatform from '@alicloud/openplatform20191219';
import OSSUtil, * as $OSSUtil from '@alicloud/oss-util';
import FileForm, * as $FileForm from '@alicloud/tea-fileform';
import OpenApi, * as $OpenApi from '@alicloud/openapi-client';
import OpenApiUtil from '@alicloud/openapi-util';
import EndpointUtil from '@alicloud/endpoint-util';
import { Readable } from 'stream';
import * as $tea from '@alicloud/tea-typescript';

export class WafQuotaInteger extends $tea.Model {
  equal?: number;
  greaterThan?: number;
  greaterThanOrEqual?: number;
  lessThan?: number;
  lessThanOrEqual?: number;
  static names(): { [key: string]: string } {
    return {
      equal: 'Equal',
      greaterThan: 'GreaterThan',
      greaterThanOrEqual: 'GreaterThanOrEqual',
      lessThan: 'LessThan',
      lessThanOrEqual: 'LessThanOrEqual',
    };
  }

  static types(): { [key: string]: any } {
    return {
      equal: 'number',
      greaterThan: 'number',
      greaterThanOrEqual: 'number',
      lessThan: 'number',
      lessThanOrEqual: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafQuotaString extends $tea.Model {
  regexp?: string;
  static names(): { [key: string]: string } {
    return {
      regexp: 'Regexp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regexp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDcdnDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The URL that is used for health checks.
   * 
   * @example
   * example.com
   */
  checkUrl?: string;
  /**
   * @remarks
   * The domain name that you want to add. You can specify only one domain name in each request.
   * 
   * Wildcard domain names are supported. A wildcard domain name must start with a period (.), such as .example.com.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * Computing service type. Valid values:
   * 
   * *   **routine**
   * *   **image**
   * *   **cloudFunction**
   * 
   * @example
   * routine
   */
  functionType?: string;
  ownerAccount?: string;
  ownerId?: number;
  /**
   * @remarks
   * The ID of the resource group. If you do not specify a value for this parameter, the system automatically assigns the ID of the default resource group.
   * 
   * @example
   * rg-acfmyuji4b6r4**
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The Acceleration scen. Supported:
   * 
   * * apiscene:API acceleration.
   * * webservicescene: accelerate website business.
   * * staticscene: video and graphic acceleration.
   * * (Empty): no scene.
   * 
   * @example
   * apiscene
   */
  scene?: string;
  /**
   * @remarks
   * The acceleration region. Valid values:
   * 
   * *   **domestic**: Chinese mainland
   * *   **overseas**: outside the Chinese mainland
   * *   **global**: global
   * 
   * Default value: **domestic**.
   * 
   * @example
   * domestic
   */
  scope?: string;
  securityToken?: string;
  /**
   * @remarks
   * The information about the addresses of origin servers.
   * 
   * @example
   * [{"content":"10.10.10.10","type":"ipaddr","priority":"20","port":80}]
   */
  sources?: string;
  /**
   * @remarks
   * The information about the tags.
   */
  tag?: AddDcdnDomainRequestTag[];
  /**
   * @remarks
   * The top-level domain.
   * 
   * @example
   * yourTopLevelDomain
   */
  topLevelDomain?: string;
  static names(): { [key: string]: string } {
    return {
      checkUrl: 'CheckUrl',
      domainName: 'DomainName',
      functionType: 'FunctionType',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      resourceGroupId: 'ResourceGroupId',
      scene: 'Scene',
      scope: 'Scope',
      securityToken: 'SecurityToken',
      sources: 'Sources',
      tag: 'Tag',
      topLevelDomain: 'TopLevelDomain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkUrl: 'string',
      domainName: 'string',
      functionType: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      resourceGroupId: 'string',
      scene: 'string',
      scope: 'string',
      securityToken: 'string',
      sources: 'string',
      tag: { 'type': 'array', 'itemType': AddDcdnDomainRequestTag },
      topLevelDomain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDcdnDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDcdnDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddDcdnDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddDcdnDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDcdnIpaDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The URL that is used for health checks.
   * 
   * @example
   * example.com/image_01.png
   */
  checkUrl?: string;
  /**
   * @remarks
   * The domain name to be added to IPA.
   * 
   * A wildcard domain that starts with a period (.) is supported, such as .example.com.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  ownerAccount?: string;
  ownerId?: number;
  /**
   * @remarks
   * The protocol. Valid values:
   * 
   * *   **udp**
   * *   **tcp**
   * 
   * **
   * 
   * **Description** For example: `{"protocol":"udp"}`.
   * 
   * @example
   * udp
   */
  protocol?: string;
  /**
   * @remarks
   * The ID of the resource group. If you do not specify a value for this parameter, the system automatically assigns the ID of the default resource group.
   * 
   * @example
   * rg
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The acceleration region. Default value: domestic. Valid values:
   * 
   * *   **domestic**: Chinese mainland
   * *   **overseas**: outside the Chinese mainland
   * *   **global**: global
   * 
   * @example
   * domestic
   */
  scope?: string;
  securityToken?: string;
  /**
   * @remarks
   * The information about the addresses of origin servers.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"content":"10.10.10.10","type":"ipaddr","priority":"20","port":80,"weight":"15"}]
   */
  sources?: string;
  /**
   * @remarks
   * The top-level domain.
   * 
   * @example
   * *.com
   */
  topLevelDomain?: string;
  static names(): { [key: string]: string } {
    return {
      checkUrl: 'CheckUrl',
      domainName: 'DomainName',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      protocol: 'Protocol',
      resourceGroupId: 'ResourceGroupId',
      scope: 'Scope',
      securityToken: 'SecurityToken',
      sources: 'Sources',
      topLevelDomain: 'TopLevelDomain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkUrl: 'string',
      domainName: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      protocol: 'string',
      resourceGroupId: 'string',
      scope: 'string',
      securityToken: 'string',
      sources: 'string',
      topLevelDomain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDcdnIpaDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDcdnIpaDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddDcdnIpaDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddDcdnIpaDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddDcdnDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The URL that is used for health checks.
   * 
   * @example
   * www.example.com/test.html
   */
  checkUrl?: string;
  /**
   * @remarks
   * You can add up to 20 domain names to DCDN for each of your Alibaba Cloud account. If you specify multiple domain names, separate them with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * example.com,example.org
   */
  domainName?: string;
  ownerAccount?: string;
  ownerId?: number;
  /**
   * @remarks
   * The ID of the resource group. If you do not specify a value for this parameter, the system uses the ID of the default resource group.
   * 
   * @example
   * testID
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The acceleration region. Default value: domestic. Valid values:
   * 
   * *   domestic: Chinese mainland
   * *   overseas: global (excluding the Chinese mainland)
   * *   global: global
   * 
   * @example
   * domestic
   */
  scope?: string;
  securityToken?: string;
  /**
   * @remarks
   * The information about the addresses of origin servers.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"content":"10.10.10.10","type":"ipaddr","priority":"20","port":80,"weight":"15"}]
   */
  sources?: string;
  /**
   * @remarks
   * The top-level domain.
   * 
   * @example
   * example.com
   */
  topLevelDomain?: string;
  static names(): { [key: string]: string } {
    return {
      checkUrl: 'CheckUrl',
      domainName: 'DomainName',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      resourceGroupId: 'ResourceGroupId',
      scope: 'Scope',
      securityToken: 'SecurityToken',
      sources: 'Sources',
      topLevelDomain: 'TopLevelDomain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkUrl: 'string',
      domainName: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      resourceGroupId: 'string',
      scope: 'string',
      securityToken: 'string',
      sources: 'string',
      topLevelDomain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddDcdnDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddDcdnDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchAddDcdnDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchAddDcdnDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateDcdnWafRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the protection policy.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000001
   */
  policyId?: number;
  /**
   * @remarks
   * The configuration of the protection rule.
   * 
   * This parameter is required.
   * 
   * @example
   * {"name":"ttttt","action":"monitor","conditions":[{"key":"URL","opValue":"match-one","values":"1,2,3,4,5"},{"key":"Header","opValue":"contain-one","subKey":"testheader","values":"6,7,8,9,10"}],"ratelimit":{"target":"header","interval":10,"threshold":5,"ttl":1800,"subKey":"testheadercc","status":{"code":"502","count":5}},"ccStatus":"on","effect":"rule","status":"on"}
   */
  ruleConfigs?: string;
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
      ruleConfigs: 'RuleConfigs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'number',
      ruleConfigs: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateDcdnWafRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CB1A380B-09F0-41BB-280B-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @remarks
   * The IDs of created rules.
   */
  ruleIds?: BatchCreateDcdnWafRulesResponseBodyRuleIds;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      ruleIds: 'RuleIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      ruleIds: BatchCreateDcdnWafRulesResponseBodyRuleIds,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateDcdnWafRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchCreateDcdnWafRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchCreateDcdnWafRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteDcdnDomainConfigsRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain names whose configurations you want to delete. Separate multiple accelerated domain names with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainNames?: string;
  /**
   * @remarks
   * The names of the features that you want to delete. Separate multiple feature names with commas (,). For more information about feature names, see [Feature settings for a domain name](https://help.aliyun.com/document_detail/410622.html).
   * 
   * This parameter is required.
   * 
   * @example
   * referer_white_list_set,https_force
   */
  functionNames?: string;
  ownerAccount?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainNames: 'DomainNames',
      functionNames: 'FunctionNames',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainNames: 'string',
      functionNames: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteDcdnDomainConfigsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteDcdnDomainConfigsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchDeleteDcdnDomainConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchDeleteDcdnDomainConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteDcdnKvRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  keys?: string[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      keys: 'Keys',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keys: { 'type': 'array', 'itemType': 'string' },
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteDcdnKvShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  keysShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      keysShrink: 'Keys',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keysShrink: 'string',
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteDcdnKvResponseBody extends $tea.Model {
  failKeys?: string[];
  /**
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  successKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      failKeys: 'FailKeys',
      requestId: 'RequestId',
      successKeys: 'SuccessKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failKeys: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
      successKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteDcdnKvResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchDeleteDcdnKvResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchDeleteDcdnKvResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteDcdnKvWithHighCapacityRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      namespace: 'Namespace',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      namespace: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteDcdnKvWithHighCapacityAdvanceRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7
   */
  urlObject?: Readable;
  static names(): { [key: string]: string } {
    return {
      namespace: 'Namespace',
      urlObject: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      namespace: 'string',
      urlObject: 'Readable',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteDcdnKvWithHighCapacityResponseBody extends $tea.Model {
  failKeys?: string[];
  /**
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  successKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      failKeys: 'FailKeys',
      requestId: 'RequestId',
      successKeys: 'SuccessKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failKeys: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
      successKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteDcdnKvWithHighCapacityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchDeleteDcdnKvWithHighCapacityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchDeleteDcdnKvWithHighCapacityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteDcdnWafRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of the protection rules that you want to delete. Separate multiple IDs with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * 20000001,20000002
   */
  ruleIds?: string;
  static names(): { [key: string]: string } {
    return {
      ruleIds: 'RuleIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteDcdnWafRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CB1A380B-09F0-41BB-802B-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteDcdnWafRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchDeleteDcdnWafRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchDeleteDcdnWafRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchModifyDcdnWafRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the protection policy.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000001
   */
  policyId?: number;
  /**
   * @remarks
   * The configurations of the protection rule.
   * 
   * This parameter is required.
   * 
   * @example
   * [{"id":135,"type":"web_sdk","status":"on","config":{"mode":"automatic","crossDomain":"example.com"},"action":""},{"id":149,"type":"intelligence_fake_crawler","status":"on","config":{},"action":"deny"}]
   */
  ruleConfigs?: string;
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
      ruleConfigs: 'RuleConfigs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'number',
      ruleConfigs: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchModifyDcdnWafRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CB1A380B-09F0-41BB-XXXX-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchModifyDcdnWafRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchModifyDcdnWafRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchModifyDcdnWafRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPutDcdnKvRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  kvList?: BatchPutDcdnKvRequestKvList[];
  /**
   * @remarks
   * The name of the namespace.
   * 
   * This parameter is required.
   * 
   * @example
   * ns1
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      kvList: 'KvList',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      kvList: { 'type': 'array', 'itemType': BatchPutDcdnKvRequestKvList },
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPutDcdnKvShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  kvListShrink?: string;
  /**
   * @remarks
   * The name of the namespace.
   * 
   * This parameter is required.
   * 
   * @example
   * ns1
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      kvListShrink: 'KvList',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      kvListShrink: 'string',
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPutDcdnKvResponseBody extends $tea.Model {
  /**
   * @remarks
   * The keys that failed to be written.
   */
  failKeys?: string[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 156A6B-677B1A-4297B7-9187B7-2B44792
   */
  requestId?: string;
  /**
   * @remarks
   * The keys that were written.
   */
  successKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      failKeys: 'FailKeys',
      requestId: 'RequestId',
      successKeys: 'SuccessKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failKeys: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
      successKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPutDcdnKvResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchPutDcdnKvResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchPutDcdnKvResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPutDcdnKvWithHighCapacityRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      namespace: 'Namespace',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      namespace: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPutDcdnKvWithHighCapacityAdvanceRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7
   */
  urlObject?: Readable;
  static names(): { [key: string]: string } {
    return {
      namespace: 'Namespace',
      urlObject: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      namespace: 'string',
      urlObject: 'Readable',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPutDcdnKvWithHighCapacityResponseBody extends $tea.Model {
  failKeys?: string[];
  /**
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  successKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      failKeys: 'FailKeys',
      requestId: 'RequestId',
      successKeys: 'SuccessKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failKeys: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
      successKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPutDcdnKvWithHighCapacityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchPutDcdnKvWithHighCapacityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchPutDcdnKvWithHighCapacityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetDcdnDomainCertificateRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the certificate.
   * 
   * @example
   * cert-te**.com
   */
  certName?: string;
  /**
   * @remarks
   * The type of the certificate. Valid values:
   * 
   * *   **upload**: a custom certificate that you upload.
   * *   **cas**: a certificate that is acquired through Certificate Management Service.
   * 
   * @example
   * cas
   */
  certType?: string;
  /**
   * @remarks
   * The accelerated domain name for which you want to configure the HTTPS certificate. The accelerated domain must have HTTPS acceleration enabled. You can specify multiple domain names and separate them with commas (,).
   * 
   * > You can configure up to 10 domain names in each request.
   * 
   * This parameter is required.
   * 
   * @example
   * **example**.com
   */
  domainName?: string;
  ownerId?: number;
  /**
   * @remarks
   * The ID of the region.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The private key. This parameter is required only if you enable the certificate.
   * 
   * @example
   * y****
   */
  SSLPri?: string;
  /**
   * @remarks
   * Specifies whether to enable the HTTPS certificate. Valid values:
   * 
   * *   **on**: enables the HTTPS certificate.
   * *   **off**: does not enable the HTTPS certificate.
   * 
   * This is the default value.
   * 
   * This parameter is required.
   * 
   * @example
   * on
   */
  SSLProtocol?: string;
  /**
   * @remarks
   * The content of the certificate. This parameter is required only if you enable the certificate.
   * 
   * @example
   * x****
   */
  SSLPub?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      certName: 'CertName',
      certType: 'CertType',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      region: 'Region',
      SSLPri: 'SSLPri',
      SSLProtocol: 'SSLProtocol',
      SSLPub: 'SSLPub',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certName: 'string',
      certType: 'string',
      domainName: 'string',
      ownerId: 'number',
      region: 'string',
      SSLPri: 'string',
      SSLProtocol: 'string',
      SSLPub: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetDcdnDomainCertificateResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetDcdnDomainCertificateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchSetDcdnDomainCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchSetDcdnDomainCertificateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetDcdnDomainConfigsRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain names. Specify multiple accelerated domain names with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * example.com,example.org
   */
  domainNames?: string;
  /**
   * @remarks
   * The features that you want to configure. Format:
   * 
   * *   **functionName**: The name of the feature. Separate multiple values with commas (,). For more information, see [A list of features](https://help.aliyun.com/document_detail/410622.html).
   * 
   * *   **argName**: The feature parameters for **functionName**.
   * *   **argValue**: The parameter values set for **functionName**.
   * *   **parentid**: the rule ID. This parameter is optional. You can use the **condition** rules engine to create a rule. For information, see [Feature settings for domain names](https://help.aliyun.com/document_detail/388460.html). A rule can identify parameters that are included in requests and filter requests based on the identified parameters. After you create a rule, a [configid](https://help.aliyun.com/document_detail/388994.html) is generated. A configid can be used as parentId that is referenced by other features. This way, you can combine rules and features for flexible configurations.
   * 
   * If the **parentId** parameter is **-1**, the existing rules in the configurations are deleted.
   * 
   * ````[
   *  {
   *    "functionArgs": [
   *     {
   *      "argName": "Parameter A", 
   *      "argValue": Value of parameter A"
   *     }, 
   *   {
   *     "argName": "Parameter B", 
   *     "argValue": "Value of Parameter B"
   *      }
   *  ], 
   *  "functionName": "Feature name"
   *     }
   * ]```
   * ````
   * 
   * This parameter is required.
   * 
   * @example
   * [{"functionArgs":[{"argName":"switch","argValue":"on"},{"argName":"region","argValue":"*"}],"functionName":"ipv6"}]
   */
  functions?: string;
  ownerAccount?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainNames: 'DomainNames',
      functions: 'Functions',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainNames: 'string',
      functions: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetDcdnDomainConfigsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of domain configurations.
   */
  domainConfigList?: BatchSetDcdnDomainConfigsResponseBodyDomainConfigList;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domainConfigList: 'DomainConfigList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainConfigList: BatchSetDcdnDomainConfigsResponseBodyDomainConfigList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetDcdnDomainConfigsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchSetDcdnDomainConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchSetDcdnDomainConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetDcdnIpaDomainConfigsRequest extends $tea.Model {
  /**
   * @remarks
   * The domain names accelerated by IPA. Separate multiple domain names with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainNames?: string;
  /**
   * @remarks
   * The list of features. `[{"functionArgs":[{"argName":"parameter name","argValue":"parameter value"}],"functionName":"feature name"}]`
   * 
   * This parameter is required.
   * 
   * @example
   * [{"functionArgs":[{"argName":"domain_name","argValue":"api.*com"}],"functionName":"protogw"}]
   */
  functions?: string;
  ownerAccount?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainNames: 'DomainNames',
      functions: 'Functions',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainNames: 'string',
      functions: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetDcdnIpaDomainConfigsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetDcdnIpaDomainConfigsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchSetDcdnIpaDomainConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchSetDcdnIpaDomainConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetDcdnWafDomainConfigsRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies the header that records the IP address to be obtained. If the default header is selected, the value of this parameter is empty. If a custom header is selected, the value of this parameter is the value specified by the user. Separate multiple values with commas (,). You can specify a maximum of five values.
   * 
   * @example
   * X-Forwarded-For
   */
  clientIpTag?: string;
  /**
   * @remarks
   * The protection status of the domain name. Valid values: on, off, and empty string.
   * 
   * *   When you add a domain name, the value of this parameter is **on**, and the value of ClientIpTag takes effect, which is empty if the default header is selected and is the value specified by the user if a custom header is selected.
   * *   When you delete a domain name, the value of this parameter is **off**, and the value of ClientIpTag does not take effect.
   * *   When you only modify the value of ClientIpTag, the value of DefenseStatus is an empty string.
   * 
   * @example
   * on
   */
  defenseStatus?: string;
  /**
   * @remarks
   * The protected domain names for which you want to change the protection status. You can specify up to 50 domain names. Separate multiple domain names with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * example.com,example2.com
   */
  domainNames?: string;
  static names(): { [key: string]: string } {
    return {
      clientIpTag: 'ClientIpTag',
      defenseStatus: 'DefenseStatus',
      domainNames: 'DomainNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientIpTag: 'string',
      defenseStatus: 'string',
      domainNames: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetDcdnWafDomainConfigsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CB1A380B-09F0-41BB-3C82-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetDcdnWafDomainConfigsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchSetDcdnWafDomainConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchSetDcdnWafDomainConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchStartDcdnDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. You can specify multiple accelerated domain names and separate them with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainNames?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainNames: 'DomainNames',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainNames: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchStartDcdnDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchStartDcdnDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchStartDcdnDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchStartDcdnDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchStopDcdnDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain names. If you need to specify multiple accelerated domain names, separate domain names with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainNames?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainNames: 'DomainNames',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainNames: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchStopDcdnDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchStopDcdnDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchStopDcdnDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchStopDcdnDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckDcdnProjectExistRequest extends $tea.Model {
  /**
   * @remarks
   * The name of a real-time log delivery project.
   * 
   * This parameter is required.
   * 
   * @example
   * example
   */
  projectName?: string;
  static names(): { [key: string]: string } {
    return {
      projectName: 'ProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckDcdnProjectExistResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned results.
   */
  content?: CheckDcdnProjectExistResponseBodyContent;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * b021e538-9dde-46ed-a1f2-9469da8f3e77
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: CheckDcdnProjectExistResponseBodyContent,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckDcdnProjectExistResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CheckDcdnProjectExistResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CheckDcdnProjectExistResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CommitStagingRoutineCodeRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the code version.
   * 
   * This parameter is required.
   * 
   * @example
   * Hello World
   */
  codeDescription?: string;
  /**
   * @remarks
   * The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      codeDescription: 'CodeDescription',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeDescription: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CommitStagingRoutineCodeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The version number of the code.
   * 
   * @example
   * 1620876959997924701
   */
  content?: { [key: string]: any };
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 5CC228B4-7A67-4016-9C9F-4A4133494A91
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CommitStagingRoutineCodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CommitStagingRoutineCodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CommitStagingRoutineCodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDcdnCertificateSigningRequestRequest extends $tea.Model {
  /**
   * @remarks
   * The city. Default value: Hangzhou.
   * 
   * @example
   * Hangzhou
   */
  city?: string;
  /**
   * @remarks
   * The Common Name of the certificate.
   * 
   * This parameter is required.
   * 
   * @example
   * testName
   */
  commonName?: string;
  /**
   * @remarks
   * The country or region in which the organization is located. Default value: CN.
   * 
   * @example
   * CN
   */
  country?: string;
  /**
   * @remarks
   * The email address.
   * 
   * @example
   * test@aliyundoc.com
   */
  email?: string;
  /**
   * @remarks
   * The name of the organization. Default value: Alibaba Inc.
   * 
   * @example
   * Alibaba Inc
   */
  organization?: string;
  /**
   * @remarks
   * The name of the department. Default value: Aliyun CDN.
   * 
   * @example
   * Aliyun CDN
   */
  organizationUnit?: string;
  /**
   * @remarks
   * The Subject Alternative Name (SAN) extension that allows multiple domain names to be associated with the certificate. Separate multiple domain names with commas (,).
   * 
   * @example
   * example.com,example.org
   */
  SANs?: string;
  /**
   * @remarks
   * The provincial district. Default value: Zhejiang.
   * 
   * @example
   * Zhejiang
   */
  state?: string;
  static names(): { [key: string]: string } {
    return {
      city: 'City',
      commonName: 'CommonName',
      country: 'Country',
      email: 'Email',
      organization: 'Organization',
      organizationUnit: 'OrganizationUnit',
      SANs: 'SANs',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      city: 'string',
      commonName: 'string',
      country: 'string',
      email: 'string',
      organization: 'string',
      organizationUnit: 'string',
      SANs: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDcdnCertificateSigningRequestResponseBody extends $tea.Model {
  /**
   * @remarks
   * The Common Name of the certificate.
   * 
   * @example
   * example.com
   */
  commonName?: string;
  /**
   * @remarks
   * The content of the CSR file.
   * 
   * @example
   * -----BEGIN CERTIFICATE REQUEST-----\\nMIIC/zCCAecCAQAwZTELMAkGA1UEBhMCQ04xCzAJBgNVBAgTAlpKMQswCQYDVQQH
   */
  csr?: string;
  /**
   * @remarks
   * The MD5 hash value of the certificate public key.
   * 
   * @example
   * 629bf4fd8104eda171135bcb0f77a10b
   */
  pubMd5?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      commonName: 'CommonName',
      csr: 'Csr',
      pubMd5: 'PubMd5',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonName: 'string',
      csr: 'string',
      pubMd5: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDcdnCertificateSigningRequestResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDcdnCertificateSigningRequestResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDcdnCertificateSigningRequestResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDcdnDeliverTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The method that is used to send operations reports. Operations reports are sent to you only by email. The settings must be escaped in JSON.
   * 
   * This parameter is required.
   * 
   * @example
   * {"email":{"subject":"the email subject","to":["username@example.com","username@example.org"]}}
   */
  deliver?: string;
  /**
   * @remarks
   * The domain names to be tracked. Separate multiple domain names with commas (,). You can specify up to 500 domain names. If you want to specify more than 500 domain names, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.2020520001.aliyun_topbar.18.dbd44bd3e4f845#/ticket/createIndex).
   * 
   * > If you do not specify a domain name, the tracking task is created for all domain names that belong to your Alibaba Cloud account.
   * 
   * @example
   * example.com,example.org
   */
  domainName?: string;
  /**
   * @remarks
   * The name of the tracking task.
   * 
   * This parameter is required.
   * 
   * @example
   * Domain name report
   */
  name?: string;
  /**
   * @remarks
   * The operations reports that are tracked by the task. The data must be escaped in JSON.
   * 
   * This parameter is required.
   * 
   * @example
   * [{\\\\"reportId\\\\":2,\\\\"conditions\\\\":[{\\\\"field\\\\":\\\\"prov\\\\",\\\\"op\\\\":\\\\"in\\\\",\\\\"value\\\\":[\\\\"Heilongjiang\\\\",\\\\"Beijing\\\\"]}]}]
   */
  reports?: string;
  /**
   * @remarks
   * The parameters that specify the time interval at which the tracking task sends operations reports. The settings must be escaped in JSON.
   * 
   * This parameter is required.
   * 
   * @example
   * {"schedName":"the name of the tracking task","description":"the description","crontab":"000\\*\\*?","frequency":"d","status":"enable","effectiveFrom":"2020-09-17T00:00:00Z","effectiveEnd":"2020-11-17T00:00:00Z"}
   */
  schedule?: string;
  static names(): { [key: string]: string } {
    return {
      deliver: 'Deliver',
      domainName: 'DomainName',
      name: 'Name',
      reports: 'Reports',
      schedule: 'Schedule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deliver: 'string',
      domainName: 'string',
      name: 'string',
      reports: 'string',
      schedule: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDcdnDeliverTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the change tracking task.
   * 
   * @example
   * 92
   */
  deliverId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      deliverId: 'DeliverId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deliverId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDcdnDeliverTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDcdnDeliverTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDcdnDeliverTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDcdnSLSRealTimeLogDeliveryRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the collected logs. Default value: cdn_log_access_l1. Valid values:
   * 
   * *   **cdn_log_access_l1**: access logs of Dynamic Content Delivery Network (DCDN) points of presence (POPs)
   * *   **cdn_log_origin**: back-to-origin logs
   * *   **cdn_log_er**: EdgeRoutine logs
   * 
   * @example
   * cdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The data center. Valid values:
   * 
   * *   cn: China
   * *   sg: Singapore
   * *   in: India
   * *   eu: Europe
   * *   us: United States
   * 
   * This parameter is required.
   * 
   * @example
   * cn
   */
  dataCenter?: string;
  /**
   * @remarks
   * The domain names from which logs were collected. You can specify one or more domain names. Separate multiple domain names with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The name of a real-time log delivery project.
   * 
   * This parameter is required.
   * 
   * @example
   * example
   */
  projectName?: string;
  /**
   * @remarks
   * The name of the Log Service Logstore.
   * 
   * This parameter is required.
   * 
   * @example
   * demo
   */
  SLSLogStore?: string;
  /**
   * @remarks
   * The name of the Log Service project.
   * 
   * This parameter is required.
   * 
   * @example
   * aliyundoc
   */
  SLSProject?: string;
  /**
   * @remarks
   * The region to which real-time logs are delivered.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  SLSRegion?: string;
  /**
   * @remarks
   * The sampling rate.
   * 
   * @example
   * 1.0
   */
  samplingRate?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      dataCenter: 'DataCenter',
      domainName: 'DomainName',
      projectName: 'ProjectName',
      SLSLogStore: 'SLSLogStore',
      SLSProject: 'SLSProject',
      SLSRegion: 'SLSRegion',
      samplingRate: 'SamplingRate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      dataCenter: 'string',
      domainName: 'string',
      projectName: 'string',
      SLSLogStore: 'string',
      SLSProject: 'string',
      SLSRegion: 'string',
      samplingRate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDcdnSLSRealTimeLogDeliveryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The configuration results of the domain name.
   */
  content?: CreateDcdnSLSRealTimeLogDeliveryResponseBodyContent;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F32C57AA-7BF8-49AE-A2CC-9F42390F5A19
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: CreateDcdnSLSRealTimeLogDeliveryResponseBodyContent,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDcdnSLSRealTimeLogDeliveryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDcdnSLSRealTimeLogDeliveryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDcdnSLSRealTimeLogDeliveryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDcdnSubTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The domain names to be tracked. Separate multiple domain names with commas (,). You can specify up to 500 domain names. If you want to specify more than 500 domain names, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.2020520001.aliyun_topbar.18.dbd44bd3e4f845#/ticket/createIndex).
   * 
   * > If you do not specify a domain name, the tracking task is created for all domain names that belong to your Alibaba Cloud account.
   * 
   * @example
   * example.com,example.org
   */
  domainName?: string;
  /**
   * @remarks
   * The IDs of the metrics that you want to include in the report. Separate multiple IDs with commas (,). Valid values:
   * 
   * *   **2**: Popular URLs by Request
   * *   **4**: Popular URLs by Traffic
   * *   **6**: Popular Referer by Request
   * *   **8**: Popular Referer by Traffic
   * *   **10**: Popular Back-to-origin URLs by Request
   * *   **12**: Popular Back-to-origin URLs by Traffic
   * *   **14**: Top Client IPs by Request
   * *   **16**: Top Client IPs by Traffic
   * *   **18**: Popular Domain Names by Traffic
   * *   **20**: PV/UV
   * *   **22**: Visit Distribution by Region
   * *   **24**: Distribution of ISPs
   * *   **26**: Peak IPv4/IPv6 Bandwidth
   * *   **27**: Back-to-origin bandwidth
   * 
   * This parameter is required.
   * 
   * @example
   * 2,4,6
   */
  reportIds?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      reportIds: 'ReportIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      reportIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDcdnSubTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDcdnSubTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDcdnSubTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDcdnSubTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDcdnWafGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the WAF rule group. The name can be up to 128 characters in length. This parameter is required when you create a custom WAF rule group.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * Specifies whether to enable subscription. Valid values:
   * 
   * *   **on**
   * *   **off**
   * 
   * When you replicate a custom rule group, do not specify this parameter.
   * 
   * @example
   * on
   */
  subscribe?: string;
  /**
   * @remarks
   * The ID of the rule group to be replicated. This parameter is required when you replicate a custom WAF rule group. You can call the [DescribeDcdnWafGroups](~~DescribeDcdnWafGroups~~) operation to query the ID of the rule group. If no template is used, set the value to 0 or do not specify this parameter.
   * 
   * @example
   * 0
   */
  templateId?: number;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      subscribe: 'Subscribe',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      subscribe: 'string',
      templateId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDcdnWafGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the created WAF rule group.
   * 
   * @example
   * 30000166
   */
  id?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 675F4820-400E-5929-8B03-2C031A5D5391
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDcdnWafGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDcdnWafGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDcdnWafGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDcdnWafPolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the WAF protection policy. Valid values:
   * 
   * *   waf_group: basic web protection
   * *   custom_acl: custom protection
   * *   whitelist: IP address whitelist
   * *   ip_blacklist: IP address blacklist
   * *   region_block: region blacklist
   * *   bot: bot management
   * 
   * This parameter is required.
   * 
   * @example
   * waf_group
   */
  defenseScene?: string;
  /**
   * @remarks
   * The name of the protection policy. The name can be up to 64 characters in length and can contain letters, digits, and underscores (_).
   * 
   * This parameter is required.
   * 
   * @example
   * policy_test
   */
  policyName?: string;
  /**
   * @remarks
   * The status of the protection policy. Valid values:
   * 
   * *   on: The policy is enabled.
   * *   off: The policy is disabled.
   * 
   * This parameter is required.
   * 
   * @example
   * on
   */
  policyStatus?: string;
  /**
   * @remarks
   * Specifies whether to set the current policy as the default policy. Valid values:
   * 
   * *   default: sets the current policy as the default policy.
   * *   custom: does not set the current policy as the default policy.
   * 
   * This parameter is required.
   * 
   * @example
   * default
   */
  policyType?: string;
  static names(): { [key: string]: string } {
    return {
      defenseScene: 'DefenseScene',
      policyName: 'PolicyName',
      policyStatus: 'PolicyStatus',
      policyType: 'PolicyType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defenseScene: 'string',
      policyName: 'string',
      policyStatus: 'string',
      policyType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDcdnWafPolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the protection policy that you created.
   * 
   * @example
   * 10000001
   */
  policyId?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CB1A380B-09F0-41BB-A198-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDcdnWafPolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDcdnWafPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDcdnWafPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRoutineRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the routine.
   * 
   * @example
   * the description of this routine
   */
  description?: string;
  /**
   * @remarks
   * The configurations of the specified environment.
   * 
   * @example
   * {"staging":{"SpecName":"50ms"},"production":{"SpecName":"50ms"}}
   */
  envConf?: { [key: string]: any };
  /**
   * @remarks
   * The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      envConf: 'EnvConf',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      envConf: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRoutineShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the routine.
   * 
   * @example
   * the description of this routine
   */
  description?: string;
  /**
   * @remarks
   * The configurations of the specified environment.
   * 
   * @example
   * {"staging":{"SpecName":"50ms"},"production":{"SpecName":"50ms"}}
   */
  envConfShrink?: string;
  /**
   * @remarks
   * The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      envConfShrink: 'EnvConf',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      envConfShrink: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRoutineResponseBody extends $tea.Model {
  /**
   * @remarks
   * The message returned, such as ""Status": "OK"".
   * 
   * @example
   * "Status": "OK"
   */
  content?: { [key: string]: any };
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRoutineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateRoutineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateRoutineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSlrAndSlsProjectRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the collected logs. Default value: cdn_log_access_l1. Valid values:
   * 
   * *   **cdn_log_access_l1**: access logs of L1 Dynamic Route for CDN (DCDN) points of presence (POPs)
   * *   **cdn_log_origin**: back-to-origin logs
   * *   **cdn_log_er**: EdgeRoutine logs
   * 
   * @example
   * cdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The region where Log Service resides. Valid values:
   * 
   * *   **cn-hangzhou**
   * *   **cn-shanghai**
   * *   **cn-qingdao**
   * *   **cn-beijing**
   * *   **cn-zhangjiakou**
   * *   **cn-shenzhen**
   * *   **eu-central-1**
   * *   **us-west-1**
   * *   **ap-south-1**
   * *   **ap-southeast-1**
   * 
   * This parameter is required.
   * 
   * @example
   * cn-shanghai
   */
  region?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      region: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSlrAndSlsProjectResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * fe33a379-5053-4f22-a73c-826e2b44355d
   */
  requestId?: string;
  /**
   * @remarks
   * The information about Log Service.
   */
  slsInfo?: CreateSlrAndSlsProjectResponseBodySlsInfo;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      slsInfo: 'SlsInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      slsInfo: CreateSlrAndSlsProjectResponseBodySlsInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSlrAndSlsProjectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateSlrAndSlsProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSlrAndSlsProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnDeliverTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of the tracking tasks that you want to delete. You can call the [DescribeCdnDeliverList](https://help.aliyun.com/document_detail/270043.html) operation to query task IDs.
   * 
   * This parameter is required.
   * 
   * @example
   * 92
   */
  deliverId?: number;
  static names(): { [key: string]: string } {
    return {
      deliverId: 'DeliverId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deliverId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnDeliverTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnDeliverTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDcdnDeliverTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDcdnDeliverTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name to be deleted. You can specify only one domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  ownerAccount?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDcdnDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDcdnDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnIpaDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name that you want to delete. You can specify only one accelerated domain name in each request.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  ownerAccount?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerAccount: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnIpaDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 94E3559F-7B6A-4A5E-AFFD-44E2A208A249
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnIpaDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDcdnIpaDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDcdnIpaDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnIpaSpecificConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the configuration. You can call the [DescribeDcdnDomainConfigs](https://help.aliyun.com/document_detail/130625.html) operation to query configuration IDs.
   * 
   * This parameter is required.
   * 
   * @example
   * 50035**
   */
  configId?: string;
  /**
   * @remarks
   * The accelerated domain name. You can specify only one domain name in each request.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'string',
      domainName: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnIpaSpecificConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnIpaSpecificConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDcdnIpaSpecificConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDcdnIpaSpecificConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnKvRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the key that you want to delete.
   * 
   * This parameter is required.
   * 
   * @example
   * test_key_1
   */
  key?: string;
  /**
   * @remarks
   * The namespace that you specify when you call the PutDcdnKvNamespace operation.
   * 
   * This parameter is required.
   * 
   * @example
   * ns1
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnKvResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * D61E4801-EAFF-4A63-AAE1-FBF6CE1CFD1C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnKvResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDcdnKvResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDcdnKvResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnKvNamespaceRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the namespace. You can call the [PutDcdnKvNamespace](~~PutDcdnKvNamespace~~) operation to query the name of a namespace.
   * 
   * This parameter is required.
   * 
   * @example
   * ns1
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnKvNamespaceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * D61E4801-EAFF-4A63-AAE1-FBF6CE1CFD1C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnKvNamespaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDcdnKvNamespaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDcdnKvNamespaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnRealTimeLogProjectRequest extends $tea.Model {
  /**
   * @remarks
   * The name of a real-time log delivery project.
   * 
   * This parameter is required.
   * 
   * @example
   * example
   */
  projectName?: string;
  static names(): { [key: string]: string } {
    return {
      projectName: 'ProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnRealTimeLogProjectResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 9732E117-8A37-49FD-A36F-ABBB87556CA7
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnRealTimeLogProjectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDcdnRealTimeLogProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDcdnRealTimeLogProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnSpecificConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the configuration. Separate multiple configuration IDs with commas (,). For more information about ConfigId, see [Usage notes on ConfigId](https://help.aliyun.com/document_detail/410558.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 2117
   */
  configId?: string;
  /**
   * @remarks
   * The accelerated domain name. You can specify only one domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'string',
      domainName: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnSpecificConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnSpecificConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDcdnSpecificConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDcdnSpecificConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnSpecificStagingConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the configuration to be deleted. You can specify multiple configuration IDs and separate them with commas (,).
   * 
   * You can call the DescribeDcdnDomainStagingConfig operation to query the environment configuration.
   * 
   * This parameter is required.
   * 
   * @example
   * 2317
   */
  configId?: string;
  /**
   * @remarks
   * The accelerated domain name. You can specify only one domain name in each call.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'string',
      domainName: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnSpecificStagingConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnSpecificStagingConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDcdnSpecificStagingConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDcdnSpecificStagingConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnSubTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnSubTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDcdnSubTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDcdnSubTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnUserConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the user feature that you want to delete. Currently, only DCDN Web Application Firewall (WAF) can be deleted. Default value: waf.
   * 
   * @example
   * waf
   */
  functionName?: string;
  static names(): { [key: string]: string } {
    return {
      functionName: 'FunctionName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnUserConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 5CC228B4-7A67-4016-9C9F-4A4133494A91
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnUserConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDcdnUserConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDcdnUserConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnWafGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the custom WAF rule group.
   * 
   * @example
   * 30000135
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnWafGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2430E05E-1340-5773-B5E1-B743929F46F2
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnWafGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDcdnWafGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDcdnWafGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnWafPolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the protection policy that you want to delete. You can specify only one ID in each request.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000001
   */
  policyId?: number;
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnWafPolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CB1A380B-09F0-41BB-B084-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDcdnWafPolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDcdnWafPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDcdnWafPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineResponseBody extends $tea.Model {
  /**
   * @remarks
   * The message returned, such as ""Status": "OK"".
   * 
   * @example
   * "Status": "OK"
   */
  content?: { [key: string]: any };
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRoutineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRoutineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineCodeRevisionRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The number of the version that you want to delete.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  selectCodeRevision?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      selectCodeRevision: 'SelectCodeRevision',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      selectCodeRevision: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineCodeRevisionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The message returned, such as ""Status": "OK"".
   * 
   * @example
   * "Status": "OK"
   */
  content?: { [key: string]: any };
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineCodeRevisionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRoutineCodeRevisionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRoutineCodeRevisionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineConfEnvsRequest extends $tea.Model {
  /**
   * @remarks
   * The custom canary release environments that you want to delete.
   * 
   * This parameter is required.
   * 
   * @example
   * ["presetCanaryZheJiang"]
   */
  envs?: { [key: string]: any };
  /**
   * @remarks
   * The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      envs: 'Envs',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      envs: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineConfEnvsShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The custom canary release environments that you want to delete.
   * 
   * This parameter is required.
   * 
   * @example
   * ["presetCanaryZheJiang"]
   */
  envsShrink?: string;
  /**
   * @remarks
   * The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      envsShrink: 'Envs',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      envsShrink: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineConfEnvsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The message returned, such as ""Status": "OK"".
   * 
   * @example
   * "Status": "OK"
   */
  content?: { [key: string]: any };
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineConfEnvsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRoutineConfEnvsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRoutineConfEnvsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnAclFieldsRequest extends $tea.Model {
  /**
   * @remarks
   * The access language. Default value: en. Valid values:
   * 
   * *   **en**: English
   * *   **zh**: Chinese
   * 
   * This parameter is required.
   * 
   * @example
   * en
   */
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnAclFieldsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details about the rules.
   */
  content?: DescribeDcdnAclFieldsResponseBodyContent[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 30A3A25A-86B3-4C1D-BAA8-12B8607A5CFD
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'array', 'itemType': DescribeDcdnAclFieldsResponseBodyContent },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnAclFieldsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnAclFieldsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnAclFieldsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnBgpBpsDataRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the device. If you specify this parameter, the data of the device is returned. Otherwise, the data of all devices is returned.
   * 
   * @example
   * devicename
   */
  deviceName?: string;
  /**
   * @remarks
   * The port of the device. If you specify this parameter, the data of the port is returned. Otherwise, the data of all ports is returned. This parameter takes effect only when the **DeviceName** parameter is specified.
   * 
   * @example
   * 123
   */
  devicePort?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2018-11-30T00:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The data collection interval. Unit: seconds. Valid values: 300 and 3600. Default value: 300. The default value of 300 seconds is equal to 5 minutes. The value of this parameter varies based on the time range from the specified start time to the specified end time.
   * 
   * @example
   * 300
   */
  interval?: string;
  /**
   * @remarks
   * The ISPs. If you need to specify multiple ISPs, separate them with commas (,). If you specify multiple ISPs, the data for the ISPs is aggregated. If you do not specify this parameter, the operation returns the data for all the ISPs.
   * 
   * Valid values:
   * 
   * *   cu: China Unicom
   * *   cmi: China Mobile
   * *   ct: China Telecom
   * 
   * @example
   * cu
   */
  isp?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * The minimum data collection interval is an hour.
   * 
   * If you do not set this parameter, data collected in the last 24 hours is queried.
   * 
   * @example
   * 2018-11-29T00:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      deviceName: 'DeviceName',
      devicePort: 'DevicePort',
      endTime: 'EndTime',
      interval: 'Interval',
      isp: 'Isp',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deviceName: 'string',
      devicePort: 'string',
      endTime: 'string',
      interval: 'string',
      isp: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnBgpBpsDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The BGP bandwidth data that is collected for each interval.
   */
  bgpDataInterval?: DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval[];
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 2018-11-30T00:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E9D3257A-1B7C-414C-90C1-8D07AC47BCAC
   */
  requestId?: string;
  /**
   * @remarks
   * The start of the time range during which data was queried.
   * 
   * @example
   * 2018-11-29T00:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      bgpDataInterval: 'BgpDataInterval',
      endTime: 'EndTime',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bgpDataInterval: { 'type': 'array', 'itemType': DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval },
      endTime: 'string',
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnBgpBpsDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnBgpBpsDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnBgpBpsDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnBgpTrafficDataRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2018-11-30T00:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The data collection interval. Unit: seconds. Valid values: 300 and 3600. Default value: 300. The default value of 300 seconds is equal to 5 minutes. The value of this parameter varies based on the time range from the specified start time to the specified end time.
   * 
   * @example
   * 300
   */
  interval?: string;
  /**
   * @remarks
   * The ISP. Separate multiple ISPs with commas (,). If you specify multiple ISPs, the data for the ISPs is aggregated. If you do not specify this parameter, the operation returns the data for all the ISPs.
   * 
   * Valid values:
   * 
   * *   cu: China Unicom
   * *   cmi: China Mobile
   * *   ct: China Telecom
   * 
   * @example
   * cu
   */
  isp?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * The minimum data collection interval is an hour.
   * 
   * If you do not set this parameter, data collected in the last 24 hours is queried.
   * 
   * @example
   * 2018-11-29T00:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      interval: 'Interval',
      isp: 'Isp',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      interval: 'string',
      isp: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnBgpTrafficDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The BGP traffic at each time interval.
   */
  bgpDataInterval?: DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval[];
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 2018-11-30T00:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E9D3257A-1B7C-414C-90C1-8D07AC47BCAC
   */
  requestId?: string;
  /**
   * @remarks
   * The start of the time range during which data was queried.
   * 
   * @example
   * 2018-11-29T00:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      bgpDataInterval: 'BgpDataInterval',
      endTime: 'EndTime',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bgpDataInterval: { 'type': 'array', 'itemType': DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval },
      endTime: 'string',
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnBgpTrafficDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnBgpTrafficDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnBgpTrafficDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnBlockedRegionsRequest extends $tea.Model {
  /**
   * @remarks
   * The language. Valid values: zh, en, and jp.
   * 
   * This parameter is required.
   * 
   * @example
   * zh
   */
  language?: string;
  static names(): { [key: string]: string } {
    return {
      language: 'Language',
    };
  }

  static types(): { [key: string]: any } {
    return {
      language: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnBlockedRegionsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the country or region.
   */
  infoList?: DescribeDcdnBlockedRegionsResponseBodyInfoList;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * BFFCDFAD-DACC-484E-9BE6-0AF3B3A0DD23
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      infoList: 'InfoList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      infoList: DescribeDcdnBlockedRegionsResponseBodyInfoList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnBlockedRegionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnBlockedRegionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnBlockedRegionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnCertificateDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the certificate.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  certName?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      certName: 'CertName',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certName: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnCertificateDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The content of the certificate.
   * 
   * @example
   * -----BEGIN CERTIFICATE-----xxx-----END CERTIFICATE-----
   */
  cert?: string;
  /**
   * @remarks
   * The ID of the certificate.
   * 
   * @example
   * 123
   */
  certId?: number;
  /**
   * @remarks
   * The name of the certificate.
   * 
   * @example
   * 123
   */
  certName?: string;
  /**
   * @remarks
   * The key of the certificate.
   * 
   * @example
   * ak1htyxxxx
   */
  key?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C7C69682-7F88-40DD-A198-10D0309E439B
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      cert: 'Cert',
      certId: 'CertId',
      certName: 'CertName',
      key: 'Key',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cert: 'string',
      certId: 'number',
      certName: 'string',
      key: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnCertificateDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnCertificateDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnCertificateDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnCertificateListRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. Separate multiple accelerated domain names with commas (,).
   * 
   * By default, this operation queries the certificates of all accelerated domain names.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnCertificateListResponseBody extends $tea.Model {
  /**
   * @remarks
   * Details about certificates.
   */
  certificateListModel?: DescribeDcdnCertificateListResponseBodyCertificateListModel;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * FC0E34AC-0239-44A7-AB0E-800DE522C8DA
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      certificateListModel: 'CertificateListModel',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certificateListModel: DescribeDcdnCertificateListResponseBodyCertificateListModel,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnCertificateListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnCertificateListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnCertificateListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDdosServiceRequest extends $tea.Model {
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDdosServiceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time when the renewed service takes effect. The time is displayed in UTC.
   * 
   * @example
   * 2018-03-31T16:00:00Z
   */
  changingAffectTime?: string;
  /**
   * @remarks
   * The metering method after the configuration changes Valid values:
   * 
   * *   **PayByBandwidth**
   * *   **PayByTraffic**
   * *   **PayByBandwidth95**
   * 
   * @example
   * PayByBandwidth
   */
  changingChargeType?: string;
  /**
   * @remarks
   * The number of protected domain names.
   * 
   * @example
   * 30
   */
  changingDomianNum?: number;
  /**
   * @remarks
   * The protection edition for which the configuration changes take effect. Valid values:
   * 
   * *   **poc**: POC Edition
   * *   **basic**: Basic Edition
   * *   **insurance**: Insurance Edition
   * *   **unlimited**: Unlimited Edition
   * 
   * @example
   * basic
   */
  changingEdition?: string;
  /**
   * @remarks
   * The number of mitigation sessions with configuration changes.
   * 
   * @example
   * 100
   */
  changingProtectNum?: number;
  /**
   * @remarks
   * The billing method. Valid values:
   * 
   * *   **PayByBandwidth**
   * *   **PayByTraffic**
   * *   **PayByBandwidth95**
   * 
   * @example
   * PayByTraffic
   */
  chargeType?: string;
  /**
   * @remarks
   * The number of protected domain names.
   * 
   * @example
   * 20
   */
  domianNum?: number;
  /**
   * @remarks
   * The protection edition. Valid values:
   * 
   * *   **poc**: POC Edition
   * *   **basic**: Basic Edition
   * *   **insurance**: Insurance Edition
   * *   **unlimited**: Unlimited Edition
   * 
   * @example
   * poc
   */
  edition?: string;
  /**
   * @remarks
   * The activation status of the service. Valid values:
   * 
   * *   **on**
   * *   **off**
   * 
   * @example
   * on
   */
  enabled?: string;
  /**
   * @remarks
   * The service expiration time.
   * 
   * @example
   * 2023-09-26T16:00:00Z
   */
  endingTime?: string;
  /**
   * @remarks
   * The instance ID.
   * 
   * @example
   * xxx-12345
   */
  instanceId?: string;
  /**
   * @remarks
   * The time when the service was enabled.
   * 
   * @example
   * 2021-09-26T16:00:00Z
   */
  openingTime?: string;
  /**
   * @remarks
   * The number of mitigation sessions.
   * 
   * @example
   * 100
   */
  protectNum?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * C370DAF1-C838-4288-A1A0-9A87633D248E
   */
  requestId?: string;
  /**
   * @remarks
   * The status of the service. Valid values:
   * 
   * *   **Normal**
   * *   **WaitForExpire**
   * *   **expired**
   * *   **Released**
   * 
   * @example
   * Normal
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      changingAffectTime: 'ChangingAffectTime',
      changingChargeType: 'ChangingChargeType',
      changingDomianNum: 'ChangingDomianNum',
      changingEdition: 'ChangingEdition',
      changingProtectNum: 'ChangingProtectNum',
      chargeType: 'ChargeType',
      domianNum: 'DomianNum',
      edition: 'Edition',
      enabled: 'Enabled',
      endingTime: 'EndingTime',
      instanceId: 'InstanceId',
      openingTime: 'OpeningTime',
      protectNum: 'ProtectNum',
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      changingAffectTime: 'string',
      changingChargeType: 'string',
      changingDomianNum: 'number',
      changingEdition: 'string',
      changingProtectNum: 'number',
      chargeType: 'string',
      domianNum: 'number',
      edition: 'string',
      enabled: 'string',
      endingTime: 'string',
      instanceId: 'string',
      openingTime: 'string',
      protectNum: 'number',
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDdosServiceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDdosServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDdosServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDdosSpecInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The bandwidth limit of a single instance.
   * 
   * @example
   * 40Gbps
   */
  bandwidthLimit?: string;
  /**
   * @remarks
   * The version. Valid values:
   * 
   * * **poc**: POC Edition
   * * **basic**: Basic Edition
   * * **insurance**: Insurance Edition
   * * **unlimited**: Unlimited Edition
   * * **port_enhancement**: Special Port Enhanced Edition
   * 
   * @example
   * insurance
   */
  edition?: string;
  /**
   * @remarks
   * Specifies whether to enable DDoS mitigation. Valid values:
   * 
   * *   **on:**
   * *   **off**.
   * 
   * @example
   * on
   */
  enable?: string;
  /**
   * @remarks
   * Specifies whether custom ports are supported. Valid values:
   * 
   * *   **yes**
   * *   **no**
   * 
   * @example
   * no
   */
  isSpecialPort?: string;
  /**
   * @remarks
   * Protected region. Valid values:
   * 
   * * **global**: global
   * * **chinese_mainland**: Chinese mainland
   * * **global_excluding_the_chinese_mainland**: outside the Chinese mainland
   * 
   * @example
   * global
   */
  protectedArea?: string;
  /**
   * @remarks
   * The QPS limit.
   * 
   * @example
   * 100
   */
  qpsLimit?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * DEA8E7BE-33C6-56F5-AC56-74D50547CF34
   */
  requestId?: string;
  /**
   * @remarks
   * The code and configurations of the security rules.
   */
  specInfos?: DescribeDcdnDdosSpecInfoResponseBodySpecInfos[];
  static names(): { [key: string]: string } {
    return {
      bandwidthLimit: 'BandwidthLimit',
      edition: 'Edition',
      enable: 'Enable',
      isSpecialPort: 'IsSpecialPort',
      protectedArea: 'ProtectedArea',
      qpsLimit: 'QpsLimit',
      requestId: 'RequestId',
      specInfos: 'SpecInfos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bandwidthLimit: 'string',
      edition: 'string',
      enable: 'string',
      isSpecialPort: 'string',
      protectedArea: 'string',
      qpsLimit: 'string',
      requestId: 'string',
      specInfos: { 'type': 'array', 'itemType': DescribeDcdnDdosSpecInfoResponseBodySpecInfos },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDdosSpecInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDdosSpecInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDdosSpecInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDeletedDomainsRequest extends $tea.Model {
  /**
   * @remarks
   * The number of the page to return. Valid values: **1** to **100000**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of domain names to return on each page. Valid values: an integer from **1** to **500**. Default value: **20**.
   * 
   * @example
   * 5
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDeletedDomainsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the accelerated domain name.
   */
  domains?: DescribeDcdnDeletedDomainsResponseBodyDomains;
  /**
   * @remarks
   * The page number of the returned page, which is the same as the **PageNumber** parameter in request parameters.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of domain names returned per page, which is the same as the **PageSize** parameter in request parameters.
   * 
   * @example
   * 5
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * AA75AADB-5E25-4970-B480-EAA1F5658483
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of domain names returned.
   * 
   * @example
   * 16
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      domains: 'Domains',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domains: DescribeDcdnDeletedDomainsResponseBodyDomains,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDeletedDomainsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDeletedDomainsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDeletedDomainsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDeliverListRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the tracking task that you want to query. If you do not specify an ID, all tracking tasks are queried.
   * 
   * @example
   * 92
   */
  deliverId?: number;
  static names(): { [key: string]: string } {
    return {
      deliverId: 'DeliverId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deliverId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDeliverListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the tracking task.
   * 
   * @example
   * "data": [{"deliverId": 1,"status": "enable","createTime": "2021-06-14T11:19:26Z","crontab": "0 0 0 \\* \\* ?","frequency": "d","name": "Domain name report","dmList": ["www.example.com"],"reports": [{"reportId": 1,"conditions": [{"op": "in","field": "prov","value": ["Heilongjiang","Beijing"]}]},{"reportId": 2}],"deliver": {"email": {"subject": "subject","to": ["username@example.com","username@example.org"],"copy":["username@example.com","username@example.org"]}}}]}
   */
  content?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDeliverListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDeliverListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDeliverListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainBpsDataRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * Separate multiple domain names with commas (,). If you do not specify a value for this parameter, bandwidth data of all accelerated domain names is queried.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * > The end time must be later than the start time.
   * 
   * @example
   * 2017-12-10T21:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The time granularity of the data entries. Unit: seconds.
   * 
   * The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
   * 
   * @example
   * 300
   */
  interval?: string;
  /**
   * @remarks
   * The name of the Internet service provider (ISP).
   * 
   * You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query ISPs. If you do not specify an ISP, bandwidth data of all ISPs is queried.
   * 
   * @example
   * beijing
   */
  ispNameEn?: string;
  /**
   * @remarks
   * The name of the region.
   * 
   * You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query regions. If you do not specify a region, bandwidth data in all regions is queried.
   * 
   * @example
   * unicom
   */
  locationNameEn?: string;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      interval: 'Interval',
      ispNameEn: 'IspNameEn',
      locationNameEn: 'LocationNameEn',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      interval: 'string',
      ispNameEn: 'string',
      locationNameEn: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainBpsDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The bandwidth data returned at each interval.
   */
  bpsDataPerInterval?: DescribeDcdnDomainBpsDataResponseBodyBpsDataPerInterval;
  /**
   * @remarks
   * The time interval between the data entries returned.
   * 
   * @example
   * 300
   */
  dataInterval?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 2017-12-10T21:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3C6CCEC4-6B88-4D4A-93E4-D47B3D92CF8F
   */
  requestId?: string;
  /**
   * @remarks
   * The start of the time range during which data was queried.
   * 
   * @example
   * 2017-12-10T10:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      bpsDataPerInterval: 'BpsDataPerInterval',
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bpsDataPerInterval: DescribeDcdnDomainBpsDataResponseBodyBpsDataPerInterval,
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainBpsDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainBpsDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainBpsDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainBpsDataByLayerRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. Separate mutiple domain names with commas (,). You can specify up to 500 domain names in each request. The query results of multiple domain names are aggregated.
   * 
   * If you do not specify a domain name, data of all domain names is queried.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * >  The end time must be later than the start time.
   * 
   * @example
   * 2015-12-10T21:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The time granularity of the data entries. Unit: seconds.
   * 
   * The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
   * 
   * @example
   * 300
   */
  interval?: string;
  /**
   * @remarks
   * The Internet service provider (ISP) name. You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query the ISP name. If you do not specify this parameter, all ISPs are queried.
   * 
   * @example
   * telecom
   */
  ispNameEn?: string;
  /**
   * @remarks
   * The layer at which you want to query the bandwidth data. The network layer supports IPv4 and IPv6. The application layer supports http, https, and quic. You can also set the value to all.
   * 
   * Default value: all.
   * 
   * @example
   * all
   */
  layer?: string;
  /**
   * @remarks
   * The region name. You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query regions. If you do not specify this parameter, all regions are queried.
   * 
   * @example
   * hangzhou
   */
  locationNameEn?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * The minimum data granularity is 5 minutes.
   * 
   * If you do not set this parameter, data in the last 24 hours is queried.
   * 
   * @example
   * 2015-12-10T20:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      interval: 'Interval',
      ispNameEn: 'IspNameEn',
      layer: 'Layer',
      locationNameEn: 'LocationNameEn',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      interval: 'string',
      ispNameEn: 'string',
      layer: 'string',
      locationNameEn: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainBpsDataByLayerResponseBody extends $tea.Model {
  /**
   * @remarks
   * The bandwidth returned at each time interval.
   */
  bpsDataInterval?: DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataInterval;
  /**
   * @remarks
   * The time interval between the data entries returned. Unit: seconds.
   * 
   * @example
   * 300
   */
  dataInterval?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * BEA5625F-8FCF-48F4-851B-CA63946DA664
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      bpsDataInterval: 'BpsDataInterval',
      dataInterval: 'DataInterval',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bpsDataInterval: DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataInterval,
      dataInterval: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainBpsDataByLayerResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainBpsDataByLayerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainBpsDataByLayerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainByCertificateRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether the domain name list to return matches the SSL certificate.
   * - **true**: The domain name list matches the SSL certificate.
   * - **false**: The domain name list does not match the SSL certificate.
   * 
   * @example
   * true
   */
  exact?: boolean;
  /**
   * @remarks
   * The public key of the certificate.
   * 
   * You must use Base64 encoding schemes and then the encodeURIComponent method to encode the public key. PEM files are supported.
   * 
   * This parameter is required.
   * 
   * @example
   * xxx
   */
  SSLPub?: string;
  /**
   * @remarks
   * Specifies whether the domain name list to return contains only domain names with HTTPS enabled or disabled.
   * 
   * *   true: The list contains only domain names with HTTPS enabled.
   * *   false: The list contains only domain names with HTTPS disabled.
   * 
   * @example
   * true
   */
  SSLStatus?: boolean;
  static names(): { [key: string]: string } {
    return {
      exact: 'Exact',
      SSLPub: 'SSLPub',
      SSLStatus: 'SSLStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      exact: 'boolean',
      SSLPub: 'string',
      SSLStatus: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainByCertificateResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the certificate.
   */
  certInfos?: DescribeDcdnDomainByCertificateResponseBodyCertInfos;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * ASAF2FDS-12SADSA-DDSAE3D-DSADCD4C-CDADS2D
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      certInfos: 'CertInfos',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certInfos: DescribeDcdnDomainByCertificateResponseBodyCertInfos,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainByCertificateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainByCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainByCertificateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainCcActivityLogRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. You can specify one or more domain names. Separate multiple domain names with commas (,).
   * 
   * If you leave this parameter empty, the data of all domain names is queried.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * The end time must be later than the start time.
   * 
   * @example
   * 2015-12-10T21:05:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The page number of the page returned. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: **30**.
   * 
   * @example
   * 30
   */
  pageSize?: number;
  /**
   * @remarks
   * The name of the defense rule.
   * 
   * *   default_normal in normal mode
   * *   default_attack in emergency mode
   * *   A custom rule name in custom mode. Example: test2.
   * 
   * If you leave this parameter empty, events that triggered rate limiting based on all rules are queried.
   * 
   * @example
   * test2
   */
  ruleName?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * The resolution of the queried data is 5 minutes.
   * 
   * If you leave this parameter empty, the data collected over the last 24 hours is queried.
   * 
   * @example
   * 2015-12-10T20:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The trigger of rate limiting by which you want to query data.
   * 
   * If you leave this parameter empty, all events that triggered rate limiting are queried.
   * 
   * @example
   * IP
   */
  triggerObject?: string;
  /**
   * @remarks
   * The value of the object that triggered rate limiting.
   * 
   * If you leave this parameter empty, events that triggered rate limiting based on all rules are queried.
   * 
   * @example
   * 10.10.10.10
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ruleName: 'RuleName',
      startTime: 'StartTime',
      triggerObject: 'TriggerObject',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      ruleName: 'string',
      startTime: 'string',
      triggerObject: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainCcActivityLogResponseBody extends $tea.Model {
  /**
   * @remarks
   * The log data of the event that triggered rate limiting.
   */
  activityLog?: DescribeDcdnDomainCcActivityLogResponseBodyActivityLog[];
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageIndex?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 30
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 3C6CCEC4-6B88-4D4A-93E4-D47B3D92CF8F
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 20
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      activityLog: 'ActivityLog',
      pageIndex: 'PageIndex',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      activityLog: { 'type': 'array', 'itemType': DescribeDcdnDomainCcActivityLogResponseBodyActivityLog },
      pageIndex: 'number',
      pageSize: 'number',
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainCcActivityLogResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainCcActivityLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainCcActivityLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainCertificateInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. You can specify only one domain name in each request.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainCertificateInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the certificate.
   */
  certInfos?: DescribeDcdnDomainCertificateInfoResponseBodyCertInfos;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 5C1E43DC-9E51-4771-82C0-7D5ECEB547A1
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      certInfos: 'CertInfos',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certInfos: DescribeDcdnDomainCertificateInfoResponseBodyCertInfos,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainCertificateInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainCertificateInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainCertificateInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainCnameRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. Separate multiple domain names with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * example.com,example.org
   */
  domainName?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainCnameResponseBody extends $tea.Model {
  /**
   * @remarks
   * The CNAME information.
   */
  cnameDatas?: DescribeDcdnDomainCnameResponseBodyCnameDatas;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      cnameDatas: 'CnameDatas',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cnameDatas: DescribeDcdnDomainCnameResponseBodyCnameDatas,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainCnameResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainCnameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainCnameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainConfigsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the configuration.
   * 
   * @example
   * 5003576
   */
  configId?: string;
  /**
   * @remarks
   * The accelerated domain name. You can specify only one domain name in each request.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The names of the features to query. Separate features with commas (,).
   * 
   * @example
   * filetype_based_ttl_set,set_req_host_header
   */
  functionNames?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      domainName: 'DomainName',
      functionNames: 'FunctionNames',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'string',
      domainName: 'string',
      functionNames: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainConfigsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The configurations of the domain name.
   */
  domainConfigs?: DescribeDcdnDomainConfigsResponseBodyDomainConfigs;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F8AA0364-0FDB-4AD5-AC74-D69FAB8924ED
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domainConfigs: 'DomainConfigs',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainConfigs: DescribeDcdnDomainConfigsResponseBodyDomainConfigs,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainConfigsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. You can specify only one domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the accelerated domain name.
   */
  domainDetail?: DescribeDcdnDomainDetailResponseBodyDomainDetail;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 09ABE829-6CD3-4FE0-AFEE-556113E29727
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domainDetail: 'DomainDetail',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainDetail: DescribeDcdnDomainDetailResponseBodyDomainDetail,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainHitRateDataRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. You can specify only one domain name.
   * 
   * If you do not specify a value for this parameter, all domain names are queried.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time needs to be in UTC.
   * 
   * The end time needs to be later than the start time.
   * 
   * @example
   * 2018-03-02T15:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The time granularity for a query. Unit: seconds.
   * 
   * The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
   * 
   * @example
   * 300
   */
  interval?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time needs to be in UTC.
   * 
   * @example
   * 2018-03-02T12:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      interval: 'Interval',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      interval: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainHitRateDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time interval between the data entries returned. Unit: seconds.
   * 
   * @example
   * 3600
   */
  dataInterval?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 2018-03-02T15:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The byte hit ratio at each time interval. The byte hit ratio is measured in percentage.
   */
  hitRatePerInterval?: DescribeDcdnDomainHitRateDataResponseBodyHitRatePerInterval;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4D07ABFE-4737-4834-B1B9-A661308C47B4
   */
  requestId?: string;
  /**
   * @remarks
   * The beginning of the time range during which data was queried.
   * 
   * @example
   * 2018-03-02T12:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      hitRatePerInterval: 'HitRatePerInterval',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      hitRatePerInterval: DescribeDcdnDomainHitRateDataResponseBodyHitRatePerInterval,
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainHitRateDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainHitRateDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainHitRateDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainHttpCodeDataRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. Separate multiple accelerated domain names with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * > The end time must be later than the start time.
   * 
   * @example
   * 2019-03-02T00:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The time granularity of the data entries. Unit: seconds.
   * 
   * The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
   * 
   * @example
   * 300
   */
  interval?: string;
  /**
   * @remarks
   * The name of the Internet service provider (ISP).
   * 
   * You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query ISPs.
   * 
   * @example
   * unicom
   */
  ispNameEn?: string;
  /**
   * @remarks
   * The name of the region.
   * 
   * You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query regions.
   * 
   * @example
   * beijing
   */
  locationNameEn?: string;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2019-03-01T00:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      interval: 'Interval',
      ispNameEn: 'IspNameEn',
      locationNameEn: 'LocationNameEn',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      interval: 'string',
      ispNameEn: 'string',
      locationNameEn: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainHttpCodeDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time interval between the data entries returned. Unit: seconds.
   * 
   * @example
   * 300
   */
  dataInterval?: string;
  /**
   * @remarks
   * The proportions of HTTP status codes at each time interval.
   */
  dataPerInterval?: DescribeDcdnDomainHttpCodeDataResponseBodyDataPerInterval;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 2018-03-01T13:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 91FC2D9D-B042-4634-8A5C-7B8E7482C22D
   */
  requestId?: string;
  /**
   * @remarks
   * The start of the time range during which data was queried.
   * 
   * @example
   * 2019-03-01T00:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      dataPerInterval: 'DataPerInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      dataPerInterval: DescribeDcdnDomainHttpCodeDataResponseBodyDataPerInterval,
      domainName: 'string',
      endTime: 'string',
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainHttpCodeDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainHttpCodeDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainHttpCodeDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainHttpCodeDataByLayerRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. You can specify multiple domain names and separate them with commas (,). You can specify up to 500 domain names in each request. The query results of multiple domain names are aggregated. If you do not specify this parameter, data of all accelerated domain names under your account is queried.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time needs to be in UTC.
   * 
   * > The end time needs to be later than the start time.
   * 
   * @example
   * 2015-12-10T21:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The time interval between the data entries. Unit: seconds.
   * 
   * The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
   * 
   * @example
   * 300
   */
  interval?: string;
  /**
   * @remarks
   * The name of the Internet service provider (ISP). You can call the DescribeDcdnRegionAndIsp operation to query the ISP name. If you do not specify a value for this parameter, all ISPs are queried.
   * 
   * @example
   * telecom
   */
  ispNameEn?: string;
  /**
   * @remarks
   * The layer at which you want to query the bandwidth data. The network layer supports IPv4 and IPv6. The application layer supports http, https, and quic. You can also set the value to all. Default value: all.
   * 
   * @example
   * all
   */
  layer?: string;
  /**
   * @remarks
   * The name of the region. You can call the DescribeDcdnRegionAndIsp operation to query the region name. If you do not specify a value for this parameter, all regions are queried.
   * 
   * @example
   * hangzhou
   */
  locationNameEn?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time needs to be in UTC. The minimum data granularity is 5 minutes. If you do not set this parameter, data in the last 24 hours is queried.
   * 
   * @example
   * 2015-12-10T20:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      interval: 'Interval',
      ispNameEn: 'IspNameEn',
      layer: 'Layer',
      locationNameEn: 'LocationNameEn',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      interval: 'string',
      ispNameEn: 'string',
      layer: 'string',
      locationNameEn: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainHttpCodeDataByLayerResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time interval between the data entries returned. Unit: seconds.
   * 
   * @example
   * 300
   */
  dataInterval?: string;
  /**
   * @remarks
   * The distribution of HTTP status codes at each time interval.
   */
  httpCodeDataInterval?: DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * BEA5625F-8FCF-48F4-851B-CA63946DA664
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      httpCodeDataInterval: 'HttpCodeDataInterval',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      httpCodeDataInterval: DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainHttpCodeDataByLayerResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainHttpCodeDataByLayerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainHttpCodeDataByLayerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainIpaBpsDataRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * Separate multiple domain names with commas (,). If you leave this parameter empty, all accelerated domain names are queried.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * > The end time must be later than the start time.
   * 
   * @example
   * 2017-12-10T21:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * Specifies whether to implement padding with zeros. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * false
   */
  fixTimeGap?: string;
  /**
   * @remarks
   * The time granularity of data entries. Unit: seconds.
   * 
   * The time granularity varies with the time range specified by **StartTime** and **EndTime**.
   * 
   * *   If the time range between StartTime and EndTime is less than 3 days, the valid values are **300**, **3600**, and **86400**. If you leave this parameter empty, **300** is used.
   * *   If the time range between StartTime and EndTime is greater than or equal to 3 days and less than 31 days, the valid values are **3600** and **86400**. Default value: **3600**.
   * *   If the time range between StartTime and EndTime is 31 days or longer, the valid value is **86400**. Default value: **86400**.
   * 
   * @example
   * 300
   */
  interval?: string;
  /**
   * @remarks
   * The name of the Internet service provider (ISP).
   * 
   * You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query ISPs.
   * 
   * @example
   * Unicom
   */
  ispNameEn?: string;
  /**
   * @remarks
   * The name of the region.
   * 
   * You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query regions.
   * 
   * @example
   * beijing
   */
  locationNameEn?: string;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * Specifies whether to automatically set the interval. If you set **TimeMerge** to **1**, the value of the **Interval** parameter is automatically assigned based on the **startTime** and **endTime** parameters. You can specify either this parameter or the **Interval** parameter.
   * 
   * @example
   * 1
   */
  timeMerge?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      fixTimeGap: 'FixTimeGap',
      interval: 'Interval',
      ispNameEn: 'IspNameEn',
      locationNameEn: 'LocationNameEn',
      startTime: 'StartTime',
      timeMerge: 'TimeMerge',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      fixTimeGap: 'string',
      interval: 'string',
      ispNameEn: 'string',
      locationNameEn: 'string',
      startTime: 'string',
      timeMerge: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainIpaBpsDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The bandwidth data returned at each interval.
   */
  bpsDataPerInterval?: DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerInterval;
  /**
   * @remarks
   * The time interval at which data was collected. Unit: seconds.
   * 
   * @example
   * 300
   */
  dataInterval?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 2017-12-10T21:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3C6CCEC4-6B88-4D4A-93E4-D47B3D92CF8F
   */
  requestId?: string;
  /**
   * @remarks
   * The beginning of the time range during which data was queried.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      bpsDataPerInterval: 'BpsDataPerInterval',
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bpsDataPerInterval: DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerInterval,
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainIpaBpsDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainIpaBpsDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainIpaBpsDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainIpaConnDataRequest extends $tea.Model {
  /**
   * @remarks
   * The domain names accelerated by IPA. Separate multiple domain names with commas (,).
   * 
   * > If you do not specify this parameter, the merged data of all accelerated domain names is returned.
   * 
   * @example
   * example1.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * > The end time must be later than the start time.
   * 
   * @example
   * 2015-02-22T7:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * Specifies how query results are grouped. By default, this parameter is empty. Valid values:
   * 
   * *   domain: Query results are grouped by accelerated domain name.
   * *   An empty string: Query results are not grouped.
   * 
   * @example
   * domain
   */
  splitBy?: string;
  /**
   * @remarks
   * The start of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2015-02-21T07:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      splitBy: 'SplitBy',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      splitBy: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainIpaConnDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The number of user connections at each time interval.
   */
  connectionDataPerInterval?: DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerInterval;
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 2015-02-22T15:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * A2A1EEF8-043E-43A1-807C-BEAC18EA1807
   */
  requestId?: string;
  /**
   * @remarks
   * The beginning of the time range during which data was queried.
   * 
   * @example
   * 2015-02-21T15:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      connectionDataPerInterval: 'ConnectionDataPerInterval',
      endTime: 'EndTime',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connectionDataPerInterval: DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerInterval,
      endTime: 'string',
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainIpaConnDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainIpaConnDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainIpaConnDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainIpaTrafficDataRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * Separate multiple domain names with commas (,). If you do not specify a value for this parameter, data for all accelerated domain names is queried.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * > The end time must be later than the start time.
   * 
   * @example
   * 2017-12-10T21:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * Specify whether to implement padding with zeros. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * false
   */
  fixTimeGap?: string;
  /**
   * @remarks
   * The time granularity of data entries. Unit: seconds.
   * 
   * The time granularity varies with the time range specified by **StartTime** and **EndTime**.
   * 
   * *   If the time range between StartTime and EndTime is less than 3 days, the valid values are **300**, **3600**, and **86400**. If you do not specify a value for this parameter, **300** is used.
   * *   If the time range between StartTime and EndTime is greater than or equal to 3 days and less than 31 days, the valid values are **3600** and **86400**. Default value: **3600**.
   * *   If the time range between StartTime and EndTime is 31 days or longer, the valid value is **86400**. Default value: **86400**.
   * 
   * @example
   * 300
   */
  interval?: string;
  /**
   * @remarks
   * The name of the Internet service provider (ISP).
   * 
   * You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query ISPs.
   * 
   * @example
   * unicom
   */
  ispNameEn?: string;
  /**
   * @remarks
   * The name of the region.
   * 
   * You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query regions.
   * 
   * @example
   * beijing
   */
  locationNameEn?: string;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * Specifies whether to automatically calculate the value of the **interval**. If the **timeMerge** parameter is set to **1**, the value of **inteval** is calculated based on **StartTime** and **EndTime**. You can set either this parameter or the **interval** parameter.
   * 
   * @example
   * 1
   */
  timeMerge?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      fixTimeGap: 'FixTimeGap',
      interval: 'Interval',
      ispNameEn: 'IspNameEn',
      locationNameEn: 'LocationNameEn',
      startTime: 'StartTime',
      timeMerge: 'TimeMerge',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      fixTimeGap: 'string',
      interval: 'string',
      ispNameEn: 'string',
      locationNameEn: 'string',
      startTime: 'string',
      timeMerge: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainIpaTrafficDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time interval between the data entries returned. Unit: seconds.
   * 
   * @example
   * 300
   */
  dataInterval?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 2017-12-10T21:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * B955107D-E658-4E77-B913-E0AC3D31693E
   */
  requestId?: string;
  /**
   * @remarks
   * The start of the time range during which data was queried.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The network traffic that was collected at each interval.
   */
  trafficDataPerInterval?: DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerInterval;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      requestId: 'RequestId',
      startTime: 'StartTime',
      trafficDataPerInterval: 'TrafficDataPerInterval',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      requestId: 'string',
      startTime: 'string',
      trafficDataPerInterval: DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerInterval,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainIpaTrafficDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainIpaTrafficDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainIpaTrafficDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainIspDataRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. You can specify only one domain name in each request.
   * 
   * If you do not specify an accelerated domain name, the data of all accelerated domain names that belong to your account is queried.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * > The end time must be later than the start time.
   * 
   * @example
   * 2019-12-06T12:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2019-12-05T12:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainIspDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time interval between the data entries returned. Unit: seconds.
   * 
   * @example
   * 86400
   */
  dataInterval?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 2019-12-06T12:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 2E5AD83F-BD7B-462E-8319-2E30E305519A
   */
  requestId?: string;
  /**
   * @remarks
   * The start of the time range during which data was queried.
   * 
   * @example
   * 2019-12-05T12:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The access statistics by ISP.
   */
  value?: DescribeDcdnDomainIspDataResponseBodyValue;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      requestId: 'RequestId',
      startTime: 'StartTime',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      requestId: 'string',
      startTime: 'string',
      value: DescribeDcdnDomainIspDataResponseBodyValue,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainIspDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainIspDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainIspDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainLogRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name that you want to query. You can specify only one domain name in each call.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * > The end time must be later than the start time.
   * 
   * @example
   * 2021-11-07T18:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page **1**.
   * 
   * Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page.
   * 
   * Valid values: **1** to **1000**. Default value: **300**. Maximum value: **1000**.
   * 
   * @example
   * 300
   */
  pageSize?: number;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2021-11-07T17:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainLogResponseBody extends $tea.Model {
  /**
   * @remarks
   * The log information. The log information is indicated by the DomainLogDetail parameter.
   */
  domainLogDetails?: DescribeDcdnDomainLogResponseBodyDomainLogDetails;
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 95594003-CAC5-5636-AF72-2A094364****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domainLogDetails: 'DomainLogDetails',
      domainName: 'DomainName',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainLogDetails: DescribeDcdnDomainLogResponseBodyDomainLogDetails,
      domainName: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainLogResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainLogExTtlRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  domainName?: string;
  endTime?: string;
  pageNumber?: number;
  pageSize?: number;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainLogExTtlResponseBody extends $tea.Model {
  domainLogDetails?: DescribeDcdnDomainLogExTtlResponseBodyDomainLogDetails;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domainLogDetails: 'DomainLogDetails',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainLogDetails: DescribeDcdnDomainLogExTtlResponseBodyDomainLogDetails,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainLogExTtlResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainLogExTtlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainLogExTtlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainMultiUsageDataRequest extends $tea.Model {
  /**
   * @remarks
   * If this parameter is not set, data of all your accelerated domain names is queried.
   * 
   * You can specify multiple domain names and separate them with commas (,).
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end time must be later than the start time.
   * 
   * *   Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * *   The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.
   * *   You need to set both the start time and the end time.
   * 
   * @example
   * 2017-12-10T21:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * *   Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * *   The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.
   * *   The resolution of the queried data is 5 minutes.
   * *   If you do not set this parameter, data in the last 24 hours is queried.
   * *   You need to set both the start time and the end time.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainMultiUsageDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The end of the time range that was queried.
   * 
   * @example
   * 2017-12-10T21:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3C6CCEC4-6B88-4D4A-93E4-D47B3D92CF8F
   */
  requestId?: string;
  /**
   * @remarks
   * The information about requests collected every 5 minutes.
   */
  requestPerInterval?: DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerInterval;
  /**
   * @remarks
   * The beginning of the time range that was queried.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The statistics of network traffic collected every 5 minutes.
   */
  trafficPerInterval?: DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerInterval;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      requestId: 'RequestId',
      requestPerInterval: 'RequestPerInterval',
      startTime: 'StartTime',
      trafficPerInterval: 'TrafficPerInterval',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      requestId: 'string',
      requestPerInterval: DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerInterval,
      startTime: 'string',
      trafficPerInterval: DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerInterval,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainMultiUsageDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainMultiUsageDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainMultiUsageDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainOriginBpsDataRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. Separate multiple accelerated domain names with commas (,). If you do not specify a value for this parameter, all accelerated domain names are queried.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * > The end time must be later than the start time.
   * 
   * @example
   * 2019-12-11T00:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The time granularity for a query. Unit: seconds.
   * 
   * The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
   * 
   * @example
   * 300
   */
  interval?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2019-12-10T00:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      interval: 'Interval',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      interval: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainOriginBpsDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time interval between the data entries returned. Unit: seconds.
   * 
   * @example
   * 300
   */
  dataInterval?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 2019-12-11T00:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The origin bandwidth data returned at each time interval. Unit: bit/s.
   */
  originBpsDataPerInterval?: DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerInterval;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 7CBCD6AD-B016-42E5-AE0B-B3731DE8F755
   */
  requestId?: string;
  /**
   * @remarks
   * The start of the time range during which data was queried.
   * 
   * @example
   * 2019-12-10T00:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      originBpsDataPerInterval: 'OriginBpsDataPerInterval',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      originBpsDataPerInterval: DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerInterval,
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainOriginBpsDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainOriginBpsDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainOriginBpsDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainOriginTrafficDataRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. Separate multiple accelerated domain names with commas (,). If you do not specify a value for this parameter, all accelerated domain names are queried.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * >  The end time must be later than the start time.
   * 
   * @example
   * 2017-12-10T21:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The time interval between the data entries to return. Unit: seconds.
   * 
   * The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Description**.
   * 
   * @example
   * 300
   */
  interval?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      interval: 'Interval',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      interval: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainOriginTrafficDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time interval between the data entries returned. Unit: seconds.
   * 
   * @example
   * 300
   */
  dataInterval?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 2017-12-10T21:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The amount of back-to-origin traffic returned at each time interval. Unit: bytes.
   */
  originTrafficDataPerInterval?: DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerInterval;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * A666D44F-19D6-490E-97CF-1A64AB962C57
   */
  requestId?: string;
  /**
   * @remarks
   * The beginning of the time range during which data was queried.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      originTrafficDataPerInterval: 'OriginTrafficDataPerInterval',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      originTrafficDataPerInterval: DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerInterval,
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainOriginTrafficDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainOriginTrafficDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainOriginTrafficDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainPropertyRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name that you want to query. You can specify only one domain name in each call.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainPropertyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The protocol. Valid values:
   * 
   * *   **udp**
   * *   **tcp**
   * 
   * @example
   * udp
   */
  protocol?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 34AB41F1-04A5-496F-8C8D-634BDBE6A9FB
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      protocol: 'Protocol',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      protocol: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainPropertyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainPropertyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainPropertyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainPvDataRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. You can specify only one domain name in each request.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2019-11-29T00:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The start of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2019-11-28T00:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainPvDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time interval between the data entries returned. Unit: seconds.
   * 
   * @example
   * 3600
   */
  dataInterval?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range that was queried.
   * 
   * @example
   * 2019-11-29T00:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The number of PVs at each interval.
   */
  pvDataInterval?: DescribeDcdnDomainPvDataResponseBodyPvDataInterval;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * BCD7D917-76F1-442F-BB75-C810DE34C761
   */
  requestId?: string;
  /**
   * @remarks
   * The beginning of the time range that was queried.
   * 
   * @example
   * 2019-11-28T00:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      pvDataInterval: 'PvDataInterval',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      pvDataInterval: DescribeDcdnDomainPvDataResponseBodyPvDataInterval,
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainPvDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainPvDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainPvDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainQpsDataRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * Separate multiple domain names with commas (,). If you do not specify a value for this parameter, all accelerated domain names are queried.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * > The end time must be later than the start time.
   * 
   * @example
   * 2017-12-10T21:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The time granularity for a query. Unit: seconds.
   * 
   * The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
   * 
   * @example
   * 300
   */
  interval?: string;
  /**
   * @remarks
   * The name of the Internet service provider (ISP).
   * 
   * You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query ISPs.
   * 
   * @example
   * unicom
   */
  ispNameEn?: string;
  /**
   * @remarks
   * The name of the region.
   * 
   * You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query regions.
   * 
   * @example
   * beijing
   */
  locationNameEn?: string;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      interval: 'Interval',
      ispNameEn: 'IspNameEn',
      locationNameEn: 'LocationNameEn',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      interval: 'string',
      ispNameEn: 'string',
      locationNameEn: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainQpsDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time interval between the data entries returned. Unit: seconds.
   * 
   * @example
   * 300
   */
  dataInterval?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 2017-12-10T21:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The QPS returned at each time interval.
   */
  qpsDataPerInterval?: DescribeDcdnDomainQpsDataResponseBodyQpsDataPerInterval;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * BEA5625F-8FCF-48F4-851B-CA63946DA664
   */
  requestId?: string;
  /**
   * @remarks
   * The start of the time range during which data was queried.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      qpsDataPerInterval: 'QpsDataPerInterval',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      qpsDataPerInterval: DescribeDcdnDomainQpsDataResponseBodyQpsDataPerInterval,
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainQpsDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainQpsDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainQpsDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainQpsDataByLayerRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. You can specify multiple domain names and separate them with commas (,). You can specify up to 500 domain names in each request. The query results of multiple domain names are aggregated. If you do not specify a domain name, data of all domain names is queried.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * > The end time must be later than the start time.
   * 
   * @example
   * 2015-12-10T21:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The time interval between the data entries. Unit: seconds.
   * 
   * The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
   * 
   * @example
   * 300
   */
  interval?: string;
  /**
   * @remarks
   * The name of the ISP. You can call the DescribeDcdnRegionAndIsp operation to query the ISP name. If you do not specify a value for this parameter, all ISPs are queried.
   * 
   * @example
   * telecom
   */
  ispNameEn?: string;
  /**
   * @remarks
   * The layers at which you want to query the QPS. The network layer supports IPv4 and IPv6. The application layer supports http, https, and quic. You can also set the value to all. Default value: all.
   * 
   * @example
   * all
   */
  layer?: string;
  /**
   * @remarks
   * The name of the region. You can call the DescribeDcdnRegionAndIsp operation to query the region name. If you do not specify a value for this parameter, all regions are queried.
   * 
   * @example
   * hangzhou
   */
  locationNameEn?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. The minimum data granularity is 5 minutes. If you do not set this parameter, data in the last 24 hours is queried.
   * 
   * @example
   * 2015-12-10T20:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      interval: 'Interval',
      ispNameEn: 'IspNameEn',
      layer: 'Layer',
      locationNameEn: 'LocationNameEn',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      interval: 'string',
      ispNameEn: 'string',
      layer: 'string',
      locationNameEn: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainQpsDataByLayerResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time interval between the data entries returned. Unit: seconds.
   * 
   * @example
   * 300
   */
  dataInterval?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 2015-12-10T21:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The layer at which the data was collected.
   * 
   * @example
   * all
   */
  layer?: string;
  /**
   * @remarks
   * The QPS returned at each time interval.
   */
  qpsDataInterval?: DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataInterval;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * BEA5625F-8FCF-48F4-851B-CA63946DA664
   */
  requestId?: string;
  /**
   * @remarks
   * The start of the time range during which data was queried.
   * 
   * @example
   * 2015-12-10T20:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      layer: 'Layer',
      qpsDataInterval: 'QpsDataInterval',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      layer: 'string',
      qpsDataInterval: DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataInterval,
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainQpsDataByLayerResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainQpsDataByLayerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainQpsDataByLayerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeBpsDataRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. Separate multiple accelerated domain names with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * >  The end time must be later than the start time.
   * 
   * @example
   * 2018-01-02T11:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The name of the Internet service provider (ISP).
   * 
   * If you do not set this parameter, all ISPs are queried. You can call [DescribeDcdnRegionAndIsp](~~DescribeDcdnRegionAndIsp~~) to query ISP names.
   * 
   * @example
   * telecom
   */
  ispNameEn?: string;
  /**
   * @remarks
   * The name of the region.
   * 
   * If you do not set this parameter, all regions are queried. You can call [DescribeDcdnRegionAndIsp](~~DescribeDcdnRegionAndIsp~~) to query regions.
   * 
   * @example
   * beijing
   */
  locationNameEn?: string;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2018-01-02T11:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      ispNameEn: 'IspNameEn',
      locationNameEn: 'LocationNameEn',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      ispNameEn: 'string',
      locationNameEn: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeBpsDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned data.
   */
  data?: DescribeDcdnDomainRealTimeBpsDataResponseBodyData;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * B49E6DDA-F413-422B-B58E-2FA23F286726
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeDcdnDomainRealTimeBpsDataResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeBpsDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainRealTimeBpsDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainRealTimeBpsDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeByteHitRateDataRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name. Separate multiple domain names with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * The end time must be later than the start time.
   * 
   * @example
   * 2017-12-10T21:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeByteHitRateDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of byte hit ratios.
   */
  data?: DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyData;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * B955107D-E658-4E77-B913-E0AC3D31693E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeByteHitRateDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainRealTimeByteHitRateDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainRealTimeByteHitRateDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeDetailDataRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. Separate multiple accelerated domain names with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * > The end time must be later than the start time, and the maximum time range to query is 10 minutes.
   * 
   * This parameter is required.
   * 
   * @example
   * 2019-11-30T05:40:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The type of information that you want to query. Separate multiple types with commas (,). Valid values:
   * 
   * *   **qps**: queries per second (QPS)
   * *   **bps**: bandwidth
   * *   **http_code**: HTTP status code
   * 
   * This parameter is required.
   * 
   * @example
   * bps
   */
  field?: string;
  /**
   * @remarks
   * The name of the ISP. You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query the ISP name.
   * 
   * If you leave this parameter empty, all ISPs are queried.
   * 
   * @example
   * unicom
   */
  ispNameEn?: string;
  /**
   * @remarks
   * The name of the region. You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query the region name.
   * 
   * If you leave this parameter empty, all regions are queried.
   * 
   * @example
   * beijing
   */
  locationNameEn?: string;
  /**
   * @remarks
   * Specifies whether to return a summary value. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * Default value: **false**.
   * 
   * @example
   * true
   */
  merge?: string;
  /**
   * @remarks
   * Specifies whether to return a summary value of **LocationNameEn** and **IspNameEn**. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * Default value: **false**.
   * 
   * @example
   * true
   */
  mergeLocIsp?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2019-11-30T05:33:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      field: 'Field',
      ispNameEn: 'IspNameEn',
      locationNameEn: 'LocationNameEn',
      merge: 'Merge',
      mergeLocIsp: 'MergeLocIsp',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      field: 'string',
      ispNameEn: 'string',
      locationNameEn: 'string',
      merge: 'string',
      mergeLocIsp: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeDetailDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information returned.
   * 
   * > The value of this parameter is a JSON string. The following table describes the fields in Data.
   * 
   * @example
   * [
   *     {
   *       "time_stp": "2018-06-05T20:00:00Z",
   *       "domain_name": "example.com",
   *       "location": "Guangdong",
   *       "isp": "telecom",
   *       "qps": 10.0
   *     },
   *     {
   *       "time_stp": "2018-06-05T20:00:00Z",
   *       "domain_name": "example.com",
   *       "location": "Jiangsu",
   *       "isp": "unicom",
   *       "qps": 11.1
   *     }
   *   ]
   */
  data?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * A603F324-7A05-4FB3-ADF3-2563233D26CC
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeDetailDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainRealTimeDetailDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainRealTimeDetailDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeHttpCodeDataRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. Separate multiple accelerated domain names with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * > The end time must be later than the start time.
   * 
   * @example
   * 2017-12-10T21:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The name of the Internet service provider (ISP).
   * 
   * You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query ISPs.
   * 
   * @example
   * unicom
   */
  ispNameEn?: string;
  /**
   * @remarks
   * The name of the region.
   * 
   * You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query regions.
   * 
   * @example
   * beijing
   */
  locationNameEn?: string;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      ispNameEn: 'IspNameEn',
      locationNameEn: 'LocationNameEn',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      ispNameEn: 'string',
      locationNameEn: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeHttpCodeDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time interval between the data entries returned. Unit: seconds.
   * 
   * @example
   * 60
   */
  dataInterval?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 2017-12-10T21:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The proportions of the HTTP status codes.
   */
  realTimeHttpCodeData?: DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * B955107D-E658-4E77-B913-E0AC3D31693E
   */
  requestId?: string;
  /**
   * @remarks
   * The beginning of the time range during which data was queried.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      realTimeHttpCodeData: 'RealTimeHttpCodeData',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      realTimeHttpCodeData: DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData,
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeHttpCodeDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainRealTimeHttpCodeDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainRealTimeHttpCodeDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeQpsDataRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. Separate multiple accelerated domain names with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * > The end time must be later than the start time.
   * 
   * @example
   * 2018-01-02T11:27:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The name of the Internet service provider (ISP).
   * 
   * You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query ISPs.
   * 
   * @example
   * telecom
   */
  ispNameEn?: string;
  /**
   * @remarks
   * The name of the region.
   * 
   * You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query regions.
   * 
   * @example
   * beijing
   */
  locationNameEn?: string;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2018-01-02T11:26:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      ispNameEn: 'IspNameEn',
      locationNameEn: 'LocationNameEn',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      ispNameEn: 'string',
      locationNameEn: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeQpsDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the backup set.
   */
  data?: DescribeDcdnDomainRealTimeQpsDataResponseBodyData;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 32DC9806-E9F9-4490-BBDC-B3A9E32FCC1D
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeDcdnDomainRealTimeQpsDataResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeQpsDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainRealTimeQpsDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainRealTimeQpsDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeReqHitRateDataRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. Separate multiple accelerated domain names with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * The end time needs to be later than the start time.
   * 
   * @example
   * 2019-12-10T20:03:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2019-12-10T20:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeReqHitRateDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of byte hit ratios.
   */
  data?: DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyData;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * B955107D-E658-4E77-B913-E0AC3D31693E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeReqHitRateDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainRealTimeReqHitRateDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainRealTimeReqHitRateDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeSrcBpsDataRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. Separate multiple accelerated domain names with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * The end time must be later than the start time.
   * 
   * @example
   * 2015-12-10T20:01:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2015-12-10T20:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeSrcBpsDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time interval between the data entries returned. Unit: seconds.
   * 
   * The time granularity varies with the maximum time range per query. The returned value is 60 (1 minute), 300 (5 minutes), or 3600(1 hour). For more information, see **Usage notes**.
   * 
   * @example
   * 60
   */
  dataInterval?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 2015-12-10T20:01:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The origin bandwidth data returned at each time interval. Unit: bit/s.
   */
  realTimeSrcBpsDataPerInterval?: DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 7CBCD6AD-B016-42E5-AE0B-B3731DE8F755
   */
  requestId?: string;
  /**
   * @remarks
   * The start of the time range during which data was queried.
   * 
   * @example
   * 2015-12-10T20:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      realTimeSrcBpsDataPerInterval: 'RealTimeSrcBpsDataPerInterval',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      realTimeSrcBpsDataPerInterval: DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval,
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeSrcBpsDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainRealTimeSrcBpsDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainRealTimeSrcBpsDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. Separate multiple accelerated domain names with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * example.com,example.org
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2019-11-30T05:40:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The name of the Internet service provider (ISP).
   * 
   * You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query ISPs.
   * 
   * @example
   * unicom
   */
  ispNameEn?: string;
  /**
   * @remarks
   * The name of the region.
   * 
   * You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query regions.
   * 
   * @example
   * beijing
   */
  locationNameEn?: string;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2019-11-30T05:39:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      ispNameEn: 'IspNameEn',
      locationNameEn: 'LocationNameEn',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      ispNameEn: 'string',
      locationNameEn: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time interval between the data entries returned. Unit: seconds.
   * 
   * @example
   * 60
   */
  dataInterval?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com,example.org
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2019-11-30T05:40:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The proportions of HTTP status codes at each time interval.
   */
  realTimeSrcHttpCodeData?: DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * BC858082-736F-4A25-867B-E5B67C85ACF7
   */
  requestId?: string;
  /**
   * @remarks
   * The beginning of the time range during which data was queried.
   * 
   * The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2019-11-30T05:33:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      realTimeSrcHttpCodeData: 'RealTimeSrcHttpCodeData',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      realTimeSrcHttpCodeData: DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData,
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeSrcTrafficDataRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. Separate multiple accelerated domain names with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * The end time must be later than the start time.
   * 
   * @example
   * 2015-12-10T20:01:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2015-12-10T20:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time interval between the data entries returned. Unit: seconds.
   * 
   * The time granularity varies with the maximum time range per query. Valid values: 60 (1 minute), 300 (5 minutes), and 3600(1 hour). For more information, see **Usage notes**.
   * 
   * @example
   * 60
   */
  dataInterval?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 2015-12-10T20:01:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The amount of origin traffic returned at each time interval. Unit: bytes.
   */
  realTimeSrcTrafficDataPerInterval?: DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * A666D44F-19D6-490E-97CF-1A64AB962C57
   */
  requestId?: string;
  /**
   * @remarks
   * The start of the time range during which data was queried.
   * 
   * @example
   * 2015-12-10T20:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      realTimeSrcTrafficDataPerInterval: 'RealTimeSrcTrafficDataPerInterval',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      realTimeSrcTrafficDataPerInterval: DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval,
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeSrcTrafficDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeTrafficDataRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. You can specify one or more domain names and separate them with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. The end time must be later than the start time.
   * 
   * > If you do not specify StartTime or EndTime, data within the last hour is queried. If you specify both StartTime and EndTime, data within the specified time range is queried.
   * 
   * @example
   * 2015-12-10T20:01:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * > If you do not specify StartTime or EndTime, data within the last hour is queried. If you specify both StartTime and EndTime, data within the specified time range is queried.
   * 
   * @example
   * 2015-12-10T20:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeTrafficDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time interval between the data entries. Unit: seconds.
   * 
   * The time granularity varies with the maximum time range per query. Valid values: 60 (1 minute), 300 (5 minutes), and 3600(1 hour). For more information, see **Usage notes**.
   * 
   * @example
   * 60
   */
  dataInterval?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 2015-12-10T20:01:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The amount of back-to-origin traffic returned at each interval.
   */
  realTimeTrafficDataPerInterval?: DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * A666D44F-19D6-490E-97CF-1A64AB962C57
   */
  requestId?: string;
  /**
   * @remarks
   * The beginning of the time range during which data was queried.
   * 
   * @example
   * 2015-12-10T20:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      realTimeTrafficDataPerInterval: 'RealTimeTrafficDataPerInterval',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      realTimeTrafficDataPerInterval: DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval,
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeTrafficDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainRealTimeTrafficDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainRealTimeTrafficDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRegionDataRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. You can specify only one domain name.
   * 
   * If you do not specify an accelerated domain name, the data of all accelerated domain names that belong to your account is queried.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query. The end time must be later than the start time.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2015-12-07T12:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2015-12-05T12:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRegionDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time interval between the data entries returned. Unit: seconds.
   * 
   * @example
   * 86400
   */
  dataInterval?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 2015-12-07T12:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 2E5AD83F-BD7B-462E-8319-2E30E305519A
   */
  requestId?: string;
  /**
   * @remarks
   * The start of the time range during which data was queried.
   * 
   * @example
   * 2015-12-05T12:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The proportions of requests that were initiated from each region.
   */
  value?: DescribeDcdnDomainRegionDataResponseBodyValue;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      requestId: 'RequestId',
      startTime: 'StartTime',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      requestId: 'string',
      startTime: 'string',
      value: DescribeDcdnDomainRegionDataResponseBodyValue,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRegionDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainRegionDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainRegionDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainStagingConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The names of the features to query. You can separate multiple features with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * aliauth
   */
  functionNames?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      functionNames: 'FunctionNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      functionNames: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainStagingConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The configurations of accelerated domain names returned.
   */
  domainConfigs?: DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C80705BF-0F76-41FA-BAD1-5B59296A4E59
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domainConfigs: 'DomainConfigs',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainConfigs: { 'type': 'array', 'itemType': DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainStagingConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainStagingConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainStagingConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainTopReferVisitRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. You can specify only one domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The sorting order. Valid values:
   * 
   * *   **traf**: by network traffic
   * *   **pv**: by the number of visits
   * 
   * Default value: **pv**.
   * 
   * @example
   * pv
   */
  sortBy?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * To query the data on a specified day, use the yyyy-MM-ddT16:00:00Z format.
   * 
   * If you do not set this parameter, data collected within the last 24 hours is queried.
   * 
   * @example
   * 2018-10-03T16:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      sortBy: 'SortBy',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      sortBy: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainTopReferVisitResponseBody extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 95994621-8382-464B-8762-C708E73568D1
   */
  requestId?: string;
  /**
   * @remarks
   * The start of the time range during which data was queried.
   * 
   * @example
   * 2018-10-03T16:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The list of frequently referenced URLs returned.
   */
  topReferList?: DescribeDcdnDomainTopReferVisitResponseBodyTopReferList;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      requestId: 'RequestId',
      startTime: 'StartTime',
      topReferList: 'TopReferList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      requestId: 'string',
      startTime: 'string',
      topReferList: DescribeDcdnDomainTopReferVisitResponseBodyTopReferList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainTopReferVisitResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainTopReferVisitResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainTopReferVisitResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainTopUrlVisitRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. You can specify only one domain name in each request.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The sorting order. Valid values:
   * 
   * *   **traf**: by network traffic
   * *   **pv**: by the number of visits
   * 
   * Default value: **pv**
   * 
   * @example
   * pv
   */
  sortBy?: string;
  /**
   * @remarks
   * The start of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.
   * 
   * To query the data on a specified day, use the format: yyyy-MM-ddT16:00:00Z.
   * 
   * > If you do not specify this parameter, the data in the last 24 hours is queried.
   * 
   * @example
   * 2018-10-03T16:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      sortBy: 'SortBy',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      sortBy: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainTopUrlVisitResponseBody extends $tea.Model {
  /**
   * @remarks
   * A list of frequently requested URLs.
   */
  allUrlList?: DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlList;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 64D28B53-5902-409B-94F6-FD46680144FE
   */
  requestId?: string;
  /**
   * @remarks
   * The start of the time range during which data was queried.
   * 
   * @example
   * 2018-10-03T16:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * A list of URLs for which 2xx status codes were returned.
   */
  url200List?: DescribeDcdnDomainTopUrlVisitResponseBodyUrl200List;
  /**
   * @remarks
   * A list of URLs for which 3xx status codes were returned.
   */
  url300List?: DescribeDcdnDomainTopUrlVisitResponseBodyUrl300List;
  /**
   * @remarks
   * A list of URLs for which 4xx status codes were returned.
   */
  url400List?: DescribeDcdnDomainTopUrlVisitResponseBodyUrl400List;
  /**
   * @remarks
   * A list of URLs for which 5xx status codes were returned.
   */
  url500List?: DescribeDcdnDomainTopUrlVisitResponseBodyUrl500List;
  static names(): { [key: string]: string } {
    return {
      allUrlList: 'AllUrlList',
      domainName: 'DomainName',
      requestId: 'RequestId',
      startTime: 'StartTime',
      url200List: 'Url200List',
      url300List: 'Url300List',
      url400List: 'Url400List',
      url500List: 'Url500List',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allUrlList: DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlList,
      domainName: 'string',
      requestId: 'string',
      startTime: 'string',
      url200List: DescribeDcdnDomainTopUrlVisitResponseBodyUrl200List,
      url300List: DescribeDcdnDomainTopUrlVisitResponseBodyUrl300List,
      url400List: DescribeDcdnDomainTopUrlVisitResponseBodyUrl400List,
      url500List: DescribeDcdnDomainTopUrlVisitResponseBodyUrl500List,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainTopUrlVisitResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainTopUrlVisitResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainTopUrlVisitResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainTrafficDataRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * Separate multiple domain names with commas (,). If you do not specify a value for this parameter, network traffic of all accelerated domain names is queried.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * > The end time must be later than the start time.
   * 
   * @example
   * 2017-12-10T21:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The time granularity of the data entries. Unit: seconds.
   * 
   * The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
   * 
   * @example
   * 300
   */
  interval?: string;
  /**
   * @remarks
   * The name of the Internet service provider (ISP).
   * 
   * You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query ISPs. If you do not specify an ISP, network traffic of all ISPs is queried.
   * 
   * @example
   * unicom
   */
  ispNameEn?: string;
  /**
   * @remarks
   * The name of the region.
   * 
   * You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query regions. If you do not specify a region, network traffic in all regions is queried.
   * 
   * @example
   * beijing
   */
  locationNameEn?: string;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      interval: 'Interval',
      ispNameEn: 'IspNameEn',
      locationNameEn: 'LocationNameEn',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      interval: 'string',
      ispNameEn: 'string',
      locationNameEn: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainTrafficDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time interval between the data entries returned. Unit: seconds.
   * 
   * @example
   * 300
   */
  dataInterval?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 2017-12-10T21:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * B955107D-E658-4E77-B913-E0AC3D31693E
   */
  requestId?: string;
  /**
   * @remarks
   * The start of the time range during which data was queried.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The network traffic returned at each time interval. Unit: bytes.
   */
  trafficDataPerInterval?: DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerInterval;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      requestId: 'RequestId',
      startTime: 'StartTime',
      trafficDataPerInterval: 'TrafficDataPerInterval',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      requestId: 'string',
      startTime: 'string',
      trafficDataPerInterval: DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerInterval,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainTrafficDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainTrafficDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainTrafficDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainUsageDataRequest extends $tea.Model {
  /**
   * @remarks
   * The billable region. Valid values:
   * 
   * *   **CN**: Chinese mainland
   * *   **OverSeas**: outside the Chinese mainland
   * *   **AP1**: Asia Pacific 1
   * *   **AP2**: Asia Pacific 2
   * *   **AP3**: Asia Pacific 3
   * *   **NA**: North America
   * *   **SA**: South America
   * *   **EU**: Europe
   * *   **MEAA**: Middle East and Africa
   * *   **all**: all the preceding billable regions
   * 
   * Default value: **CN**
   * 
   * @example
   * CN
   */
  area?: string;
  /**
   * @remarks
   * The protocol of the data to query. Valid values:
   * 
   * *   **quic**: Quick UDP Internet Connections (QUIC)
   * *   **https**: HTTPS
   * *   **http**: HTTP
   * *   **all**: all the preceding protocols
   * 
   * Default value: **all**
   * 
   * @example
   * all
   */
  dataProtocol?: string;
  /**
   * @remarks
   * The accelerated domain name. You can specify up to 100 domain names in each request. Separate multiple domain names with commas (,).
   * 
   * >  If you do not specify this parameter, the usage data of all accelerated domain names that belong to your Alibaba Cloud account is returned.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * >  The end time must be later than the start time. The maximum time range that can be queried is 31 days.
   * 
   * This parameter is required.
   * 
   * @example
   * 2015-12-10T22:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The type of data that you want to query. Valid values:
   * 
   * *   **bps**: bandwidth
   * *   **traf**: traffic
   * *   **acc**: requests
   * 
   * >  **acc** does not support the **Area** parameter.
   * 
   * This parameter is required.
   * 
   * @example
   * bps
   */
  field?: string;
  /**
   * @remarks
   * The time interval between the data entries to return. Unit: seconds.
   * 
   * The time interval varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
   * 
   * @example
   * 300
   */
  interval?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * >  The minimum time granularity at which the data is queried is 5 minutes.
   * 
   * This parameter is required.
   * 
   * @example
   * 2015-12-10T20:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The type of the requests. Valid values:
   * 
   * *   **static**: static requests
   * *   **dynamic**: dynamic requests
   * *   **all**: all requests
   * 
   * Default value: **all**
   * 
   * @example
   * dynamic
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      area: 'Area',
      dataProtocol: 'DataProtocol',
      domainName: 'DomainName',
      endTime: 'EndTime',
      field: 'Field',
      interval: 'Interval',
      startTime: 'StartTime',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      area: 'string',
      dataProtocol: 'string',
      domainName: 'string',
      endTime: 'string',
      field: 'string',
      interval: 'string',
      startTime: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainUsageDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The billable region where the usage data was collected.
   * 
   * @example
   * CN
   */
  area?: string;
  /**
   * @remarks
   * The time interval between the data entries returned. Unit: seconds.
   * 
   * @example
   * /
   */
  dataInterval?: string;
  /**
   * @remarks
   * The accelerated domain name that was queried.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 2015-12-10T22:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * B955107D-E658-4E77-B913-E0AC3D31693E
   */
  requestId?: string;
  /**
   * @remarks
   * The beginning of the time range during which data was queried.
   * 
   * @example
   * 2015-12-10T20:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The type of the returned data.
   * 
   * @example
   * bps
   */
  type?: string;
  /**
   * @remarks
   * The traffic that was collected at each interval.
   */
  usageDataPerInterval?: DescribeDcdnDomainUsageDataResponseBodyUsageDataPerInterval;
  static names(): { [key: string]: string } {
    return {
      area: 'Area',
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      requestId: 'RequestId',
      startTime: 'StartTime',
      type: 'Type',
      usageDataPerInterval: 'UsageDataPerInterval',
    };
  }

  static types(): { [key: string]: any } {
    return {
      area: 'string',
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      requestId: 'string',
      startTime: 'string',
      type: 'string',
      usageDataPerInterval: DescribeDcdnDomainUsageDataResponseBodyUsageDataPerInterval,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainUsageDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainUsageDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainUsageDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainUvDataRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. You can specify only one domain name in each request.
   * 
   * If you do not specify a domain name, this operation queries UV data of all accelerated domain names in your account.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * The end time must be later than the start time.
   * 
   * @example
   * 2015-11-30T00:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The start of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2015-11-29T00:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainUvDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time interval between the data entries returned. Unit: seconds.
   * 
   * @example
   * 3600
   */
  dataInterval?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range that was queried.
   * 
   * @example
   * 2015-11-30T00:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * E9D3257A-1B7C-414C-90C1-8D07AC47BCAC
   */
  requestId?: string;
  /**
   * @remarks
   * The beginning of the time range that was queried.
   * 
   * @example
   * 2015-11-29T00:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The number of UVs at each interval.
   */
  uvDataInterval?: DescribeDcdnDomainUvDataResponseBodyUvDataInterval;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      requestId: 'RequestId',
      startTime: 'StartTime',
      uvDataInterval: 'UvDataInterval',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      requestId: 'string',
      startTime: 'string',
      uvDataInterval: DescribeDcdnDomainUvDataResponseBodyUvDataInterval,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainUvDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainUvDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainUvDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainWebsocketBpsDataRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * Separate multiple domain names with commas (,). If you do not specify a value for this parameter, all accelerated domain names are queried.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * > The end time must be later than the start time.
   * 
   * @example
   * 2017-12-10T21:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The time granularity for a query. Unit: seconds.
   * 
   * The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
   * 
   * @example
   * 300
   */
  interval?: string;
  /**
   * @remarks
   * The name of the Internet service provider (ISP).
   * 
   * You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query ISPs.
   * 
   * @example
   * unicom
   */
  ispNameEn?: string;
  /**
   * @remarks
   * The name of the region.
   * 
   * You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query regions.
   * 
   * @example
   * beijing
   */
  locationNameEn?: string;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      interval: 'Interval',
      ispNameEn: 'IspNameEn',
      locationNameEn: 'LocationNameEn',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      interval: 'string',
      ispNameEn: 'string',
      locationNameEn: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainWebsocketBpsDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The bandwidth data returned at each interval.
   */
  bpsDataPerInterval?: DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerInterval;
  /**
   * @remarks
   * The time interval between the data entries returned. Unit: seconds.
   * 
   * @example
   * 300
   */
  dataInterval?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 2017-12-10T21:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3C6CCEC4-6B88-4D4A-93E4-D47B3D92CF8F
   */
  requestId?: string;
  /**
   * @remarks
   * The start of the time range during which data was queried.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      bpsDataPerInterval: 'BpsDataPerInterval',
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bpsDataPerInterval: DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerInterval,
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainWebsocketBpsDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainWebsocketBpsDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainWebsocketBpsDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainWebsocketHttpCodeDataRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. You can specify multiple accelerated domain names and separate them with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * > The end time must be later than the start time.
   * 
   * @example
   * 2018-03-01T06:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The time granularity for a query. Unit: seconds.
   * 
   * The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.
   * 
   * @example
   * 300
   */
  interval?: string;
  /**
   * @remarks
   * The name of the Internet service provider (ISP).
   * 
   * You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query ISPs.
   * 
   * @example
   * unicom
   */
  ispNameEn?: string;
  /**
   * @remarks
   * The name of the region.
   * 
   * You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query regions.
   * 
   * @example
   * beijing
   */
  locationNameEn?: string;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2018-03-01T05:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      interval: 'Interval',
      ispNameEn: 'IspNameEn',
      locationNameEn: 'LocationNameEn',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      interval: 'string',
      ispNameEn: 'string',
      locationNameEn: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainWebsocketHttpCodeDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time interval between the data entries returned. Unit: seconds.
   * 
   * @example
   * 3600
   */
  dataInterval?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 2018-03-01T13:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The HTTP status code.
   */
  httpCodeDataPerInterval?: DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerInterval;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 91FC2D9D-B042-4634-8A5C-7B8E7482C22D
   */
  requestId?: string;
  /**
   * @remarks
   * The start of the time range during which data was queried.
   * 
   * @example
   * 2018-03-01T05:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      httpCodeDataPerInterval: 'HttpCodeDataPerInterval',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      httpCodeDataPerInterval: DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerInterval,
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainWebsocketHttpCodeDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainWebsocketHttpCodeDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainWebsocketHttpCodeDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainWebsocketTrafficDataRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * Separate multiple domain names with commas (,). If you do not specify a value for this parameter, all accelerated domain names are queried.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
   * 
   * > The end time must be later than the start time.
   * 
   * @example
   * 2017-12-10T21:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The time granularity for a query. Unit: seconds.
   * 
   * The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Operation Description**.
   * 
   * @example
   * 300
   */
  interval?: string;
  /**
   * @remarks
   * The name of the ISP.
   * 
   * You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query ISPs.
   * 
   * @example
   * unicom
   */
  ispNameEn?: string;
  /**
   * @remarks
   * The name of the region.
   * 
   * You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query regions.
   * 
   * @example
   * beijing
   */
  locationNameEn?: string;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      interval: 'Interval',
      ispNameEn: 'IspNameEn',
      locationNameEn: 'LocationNameEn',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      interval: 'string',
      ispNameEn: 'string',
      locationNameEn: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainWebsocketTrafficDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time interval between the data entries returned. Unit: seconds.
   * 
   * @example
   * 300
   */
  dataInterval?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 2017-12-10T21:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * B955107D-E658-4E77-B913-E0AC3D31693E
   */
  requestId?: string;
  /**
   * @remarks
   * The start of the time range during which data was queried.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The network traffic returned at each time interval. Unit: bytes.
   */
  trafficDataPerInterval?: DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerInterval;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      domainName: 'DomainName',
      endTime: 'EndTime',
      requestId: 'RequestId',
      startTime: 'StartTime',
      trafficDataPerInterval: 'TrafficDataPerInterval',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'string',
      domainName: 'string',
      endTime: 'string',
      requestId: 'string',
      startTime: 'string',
      trafficDataPerInterval: DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerInterval,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainWebsocketTrafficDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainWebsocketTrafficDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainWebsocketTrafficDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainsBySourceRequest extends $tea.Model {
  /**
   * @remarks
   * The list of origin servers. Separate origin servers with commas (,). You can specify a maximum of 20 origin servers. Fuzzy match is not supported.
   * 
   * This parameter is required.
   * 
   * @example
   * example.org
   */
  sources?: string;
  static names(): { [key: string]: string } {
    return {
      sources: 'Sources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sources: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainsBySourceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about each origin server and the corresponding domain names.
   * 
   * This parameter is required.
   */
  domainInfo?: DescribeDcdnDomainsBySourceResponseBodyDomainInfo[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F61CDR30-E83C-4FDA-BF73-9A94CDD44229
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domainInfo: 'DomainInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainInfo: { 'type': 'array', 'itemType': DescribeDcdnDomainsBySourceResponseBodyDomainInfo },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainsBySourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnDomainsBySourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnDomainsBySourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnErUsageDataRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * > The end time must be later than the start time.
   * 
   * @example
   * 2018-10-31T16:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the routine.
   * 
   * @example
   * routine1.test
   */
  routineID?: string;
  /**
   * @remarks
   * The specification of the routine. Valid values:
   * 
   * *   5ms
   * *   50ms
   * *   100ms
   * 
   * @example
   * 50ms
   */
  spec?: string;
  /**
   * @remarks
   * Specifies how the results are grouped. If you set this parameter to routine, the returned results are grouped based on the routine ID. If you set this parameter to spec, the returned results are grouped based on the routine specification.
   * 
   * > If you leave this parameter empty, the returned results are not grouped.
   * 
   * @example
   * routine
   */
  splitBy?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2018-10-30T16:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      routineID: 'RoutineID',
      spec: 'Spec',
      splitBy: 'SplitBy',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      routineID: 'string',
      spec: 'string',
      splitBy: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnErUsageDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 2018-10-31T16:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The list of the data returned.
   */
  erAccData?: DescribeDcdnErUsageDataResponseBodyErAccData;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C370DAF1-C838-4288-A1A0-9A87633D248E
   */
  requestId?: string;
  /**
   * @remarks
   * The start of the time range during which data was queried.
   * 
   * @example
   * 2018-10-30T16:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      erAccData: 'ErAccData',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      erAccData: DescribeDcdnErUsageDataResponseBodyErAccData,
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnErUsageDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnErUsageDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnErUsageDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnFullDomainsBlockIPConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The IP address or CIDR block to query. Separate multiple values with commas (,). You can specify up to 50 IP addresses or CIDR blocks.
   * 
   * @example
   * 10.XX.XX.10/24
   */
  IPList?: string;
  static names(): { [key: string]: string } {
    return {
      IPList: 'IPList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      IPList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnFullDomainsBlockIPConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code.
   * 
   * The value of Code is not 0 in the following scenarios:
   * 
   * *   The format of the IP address is invalid.
   * *   The number of IP addresses exceeds the limit.
   * *   Other abnormal scenarios
   * 
   * @example
   * 0
   */
  code?: number;
  /**
   * @remarks
   * The returned results. If the operation is successful, URLs of OSS objects are returned. If the operation fails, an error message is returned.
   * 
   * @example
   * http://xxxx-api.oss-cn-hangzhou.aliyuncs.com/blocklist%2Fxxxxxxxxxxxx.txt?Expires=1682663947&OSSAccessKeyId=xxxxxxxxxx&Signature=xxxxxx
   */
  message?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0C58632F-BA12-1A1E-986D-09285752B42C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnFullDomainsBlockIPConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnFullDomainsBlockIPConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnFullDomainsBlockIPConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnFullDomainsBlockIPHistoryRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The end time must be later than the start time.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-24T19:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The IP address or CIDR block to query.
   * 
   * This parameter is required.
   * 
   * @example
   * 10.XX.XX.10/24
   */
  IPList?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-24T17:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      IPList: 'IPList',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      IPList: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnFullDomainsBlockIPHistoryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code.
   * 
   * The value of Code is not 0 in the following scenarios:
   * 
   * *   The format of the IP address is invalid.
   * *   The format of the time is invalid.
   * *   Other abnormal scenarios
   * 
   * @example
   * 0
   */
  code?: number;
  /**
   * @remarks
   * The description of the status returned.
   * 
   * @example
   * OK
   */
  description?: string;
  /**
   * @remarks
   * The result of the operation.
   */
  IPBlockInfo?: DescribeDcdnFullDomainsBlockIPHistoryResponseBodyIPBlockInfo[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 13A2B792-9212-1CC9-8525-59EBEF3FFE01
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      description: 'Description',
      IPBlockInfo: 'IPBlockInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      description: 'string',
      IPBlockInfo: { 'type': 'array', 'itemType': DescribeDcdnFullDomainsBlockIPHistoryResponseBodyIPBlockInfo },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnFullDomainsBlockIPHistoryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnFullDomainsBlockIPHistoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnFullDomainsBlockIPHistoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnHttpsDomainListRequest extends $tea.Model {
  /**
   * @remarks
   * The keyword that is used to search for certificates.
   * 
   * @example
   * cert
   */
  keyword?: string;
  /**
   * @remarks
   * The number of returned pages. Valid values: **1 to 100000**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Valid values: **1 to 500**. Default value: **20**.
   * 
   * @example
   * 2
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      keyword: 'Keyword',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keyword: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnHttpsDomainListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the certificate.
   */
  certInfos?: DescribeDcdnHttpsDomainListResponseBodyCertInfos;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F5E8DF64-7175-4186-9B06-F002C0BBD0C5
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 16
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      certInfos: 'CertInfos',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certInfos: DescribeDcdnHttpsDomainListResponseBodyCertInfos,
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnHttpsDomainListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnHttpsDomainListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnHttpsDomainListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The IP address. You can specify only one IP address.
   * 
   * This parameter is required.
   * 
   * @example
   * 10.10.10.10
   */
  IP?: string;
  static names(): { [key: string]: string } {
    return {
      IP: 'IP',
    };
  }

  static types(): { [key: string]: any } {
    return {
      IP: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the specified IP address is assigned to an Alibaba Cloud DCDN POP.
   * 
   * *   True
   * *   False
   * 
   * @example
   * True
   */
  dcdnIp?: string;
  /**
   * @remarks
   * The ISP to which the specified IP address belongs.
   * 
   * @example
   * China Telecom
   */
  ISP?: string;
  /**
   * @remarks
   * The name of the Internet service provider (ISP).
   * 
   * @example
   * telecom
   */
  ispEname?: string;
  /**
   * @remarks
   * The Chinese name of the region.
   * 
   * @example
   * >  The maximum number of times that users can call this operation per second is 50.
   */
  region?: string;
  /**
   * @remarks
   * The English name of the region.
   * 
   * @example
   * China-Guizhou-guiyang
   */
  regionEname?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 1B1D0EE7-9559-489D-BC4E-279495EB8FB8
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      dcdnIp: 'DcdnIp',
      ISP: 'ISP',
      ispEname: 'IspEname',
      region: 'Region',
      regionEname: 'RegionEname',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dcdnIp: 'string',
      ISP: 'string',
      ispEname: 'string',
      region: 'string',
      regionEname: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnIpInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnIpInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaDomainCidrRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. You can specify only one domain name in each request.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaDomainCidrResponseBody extends $tea.Model {
  /**
   * @remarks
   * The back-to-origin IPv4 and IPv6 CIDR blocks.
   * 
   * @example
   * ["1.1.1.0/24","2.2.2.0/24","1111:2222:3333:4444:5555:0:0:0/80"]
   */
  cidr?: string[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      cidr: 'Cidr',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cidr: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaDomainCidrResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnIpaDomainCidrResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnIpaDomainCidrResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaDomainConfigsRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. Separate multiple domain names with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The name of the feature. Set the value to protogw, which indicates IP Application Accelerator (IPA).
   * 
   * This parameter is required.
   * 
   * @example
   * protogw
   */
  functionNames?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      functionNames: 'FunctionNames',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      functionNames: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaDomainConfigsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The configurations of the domain name.
   */
  domainConfigs?: DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigs;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F8AA0364-0FDB-4AD5-AC74-D69FAB8924ED
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domainConfigs: 'DomainConfigs',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainConfigs: DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigs,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaDomainConfigsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnIpaDomainConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnIpaDomainConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaDomainDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain names for which you want to query basic information. You can specify only one domain name in each request.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaDomainDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details about the accelerated domain name.
   */
  domainDetail?: DescribeDcdnIpaDomainDetailResponseBodyDomainDetail;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 09ABE829-6CD3-4FE0-AFEE-556113E29727
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domainDetail: 'DomainDetail',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainDetail: DescribeDcdnIpaDomainDetailResponseBodyDomainDetail,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaDomainDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnIpaDomainDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnIpaDomainDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaServiceRequest extends $tea.Model {
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaServiceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time when the change of the billing method starts to take effect. The time is in GMT. This time appears on the frontend only when it is later than the current time.
   * 
   * @example
   * 2018-03-31T16:00:00Z
   */
  changingAffectTime?: string;
  /**
   * @remarks
   * The new billing method to take effect. Valid values:
   * 
   * *   **PayByTraffic**: pay-by-data-transfer
   * *   **PayByBandwidth**: pay-by-bandwidth
   * *   **PayByBandwidth95**: pay-by-95th percentile bandwidth
   * *   **PayByBandwidth_monthavg**: pay-by-monthly average bandwidth
   * *   **PayByBandwidth_month4th**: pay-by-fourth peak bandwidth per month
   * *   **PayByBandwidth_monthday95avg**: pay-by-monthly average 95th percentile bandwidth
   * *   **PayByBandwidth_nighthalf95**: pay-by-95th percentile bandwidth (50% off during nighttime)
   * 
   * @example
   * PayByBandwidth
   */
  changingChargeType?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * 1883927335936173
   */
  instanceId?: string;
  /**
   * @remarks
   * The billing method of the instance. Valid values:
   * 
   * *   **PayByTraffic**: pay-by-data-transfer
   * *   **PayByBandwidth**: pay-by-bandwidth
   * *   **PayByBandwidth95**: pay-by-95th percentile bandwidth
   * *   **PayByBandwidth_monthavg**: pay-by-monthly average bandwidth
   * *   **PayByBandwidth_month4th**: pay-by-fourth peak bandwidth per month
   * *   **PayByBandwidth_monthday95avg**: pay-by-monthly average 95th percentile bandwidth
   * *   **PayByBandwidth_nighthalf95**: pay-by-95th percentile bandwidth (50% off during nighttime)
   * 
   * @example
   * PayByBandwidth
   */
  internetChargeType?: string;
  /**
   * @remarks
   * The time when the DCDN service was activated. The time follows the ISO 8601 standard.
   * 
   * @example
   * 2018-03-19T11:16:11Z
   */
  openingTime?: string;
  /**
   * @remarks
   * The lock status of secure DCDN.
   */
  operationLocks?: DescribeDcdnIpaServiceResponseBodyOperationLocks;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * EF2AEBC2-EDBD-41CF-BF64-7E095D42D6EF
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      changingAffectTime: 'ChangingAffectTime',
      changingChargeType: 'ChangingChargeType',
      instanceId: 'InstanceId',
      internetChargeType: 'InternetChargeType',
      openingTime: 'OpeningTime',
      operationLocks: 'OperationLocks',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      changingAffectTime: 'string',
      changingChargeType: 'string',
      instanceId: 'string',
      internetChargeType: 'string',
      openingTime: 'string',
      operationLocks: DescribeDcdnIpaServiceResponseBodyOperationLocks,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaServiceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnIpaServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnIpaServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaUserDomainsRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to display domain names that are under review, failed the review, or failed to be configured. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * false
   */
  checkDomainShow?: boolean;
  /**
   * @remarks
   * The domain name that is used as a keyword to filter domain names. Fuzzy match is supported.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The search method. Default value: full_match. Valid values:
   * 
   * *   **fuzzy_match**: fuzzy match
   * *   **pre_match**: prefix match
   * *   **suf_match**: suffix match
   * *   **full_match**: exact match
   * 
   * @example
   * fuzzy_match
   */
  domainSearchType?: string;
  /**
   * @remarks
   * The status of the domain name. Valid values:
   * 
   * *   **online**: enabled
   * *   **offline**: disabled
   * *   **configuring**: configuring
   * *   **configure_failed**: configuration failed
   * *   **checking**: reviewing
   * *   **check_failed:** review failed
   * 
   * @example
   * online
   */
  domainStatus?: string;
  /**
   * @remarks
   * The status of the feature.
   * 
   * *   config: The feature is enabled.
   * *   unconfig: The feature is not enabled.
   * 
   * @example
   * config
   */
  funcFilter?: string;
  /**
   * @remarks
   * The ID of the feature. For example, a value of 7 specifies the feature of configuring an expiration rule for a specific directory. For more information about feature IDs, see [Parameters for configuring features for domain names](https://help.aliyun.com/document_detail/410622.html).
   * 
   * @example
   * 7
   */
  funcId?: string;
  ownerId?: number;
  /**
   * @remarks
   * The page number. Valid values: **1** to **100000**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of domain names per page. Default value: **20**.**** Valid values: **1** to **500**.
   * 
   * @example
   * 5
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * abcd1234abcd****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The tags of the command.
   */
  tag?: DescribeDcdnIpaUserDomainsRequestTag[];
  static names(): { [key: string]: string } {
    return {
      checkDomainShow: 'CheckDomainShow',
      domainName: 'DomainName',
      domainSearchType: 'DomainSearchType',
      domainStatus: 'DomainStatus',
      funcFilter: 'FuncFilter',
      funcId: 'FuncId',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      resourceGroupId: 'ResourceGroupId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkDomainShow: 'boolean',
      domainName: 'string',
      domainSearchType: 'string',
      domainStatus: 'string',
      funcFilter: 'string',
      funcId: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      resourceGroupId: 'string',
      tag: { 'type': 'array', 'itemType': DescribeDcdnIpaUserDomainsRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaUserDomainsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The array that consists of multiple PageData parameters. The details about each accelerated domain name are included in a separate PageData parameter.
   */
  domains?: DescribeDcdnIpaUserDomainsResponseBodyDomains;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of domain names returned per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * AA75AADB-5E25-4970-B480-EAA1F5658483
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of domain names returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      domains: 'Domains',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domains: DescribeDcdnIpaUserDomainsResponseBodyDomains,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaUserDomainsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnIpaUserDomainsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnIpaUserDomainsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnKvAccountResponseBody extends $tea.Model {
  capacity?: number;
  /**
   * @remarks
   * The available capacity of all namespaces.
   * 
   * @example
   * 2GB
   */
  capacityString?: string;
  capacityUsed?: number;
  /**
   * @remarks
   * All namespaces have used capacity.
   * 
   * @example
   * 200 MB
   */
  capacityUsedString?: string;
  /**
   * @remarks
   * Details about the namespaces.
   */
  namespaceList?: DescribeDcdnKvAccountResponseBodyNamespaceList[];
  /**
   * @remarks
   * The maximum number of namespaces that you can apply for by using your account.
   * 
   * @example
   * 10
   */
  namespaceQuota?: number;
  /**
   * @remarks
   * The number of namespaces that you applied for by using your account.
   * 
   * @example
   * 1
   */
  namespaceUsed?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * D61E4801-EAFF-4A63-AAE1-FBF6CE1CFD1C
   */
  requestId?: string;
  /**
   * @remarks
   * The status of the account.
   * 
   * *   **online**: enabled
   * *   **offline**: disabled
   * 
   * @example
   * online,offline
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      capacity: 'Capacity',
      capacityString: 'CapacityString',
      capacityUsed: 'CapacityUsed',
      capacityUsedString: 'CapacityUsedString',
      namespaceList: 'NamespaceList',
      namespaceQuota: 'NamespaceQuota',
      namespaceUsed: 'NamespaceUsed',
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacity: 'number',
      capacityString: 'string',
      capacityUsed: 'number',
      capacityUsedString: 'string',
      namespaceList: { 'type': 'array', 'itemType': DescribeDcdnKvAccountResponseBodyNamespaceList },
      namespaceQuota: 'number',
      namespaceUsed: 'number',
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnKvAccountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnKvAccountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnKvAccountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnKvAccountStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 5C1E43DC-9E51-4771-82C0-7D5ECEB547A1
   */
  requestId?: string;
  /**
   * @remarks
   * The status of the account.
   * 
   * *   **online**
   * *   **offline**
   * 
   * @example
   * online
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnKvAccountStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnKvAccountStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnKvAccountStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnKvNamespaceRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the namespace.
   * 
   * This parameter is required.
   * 
   * @example
   * ns1
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnKvNamespaceResponseBody extends $tea.Model {
  capacity?: number;
  /**
   * @remarks
   * The available capacity of all namespaces in your account.
   * 
   * @example
   * 1 GB
   */
  capacityString?: string;
  capacityUsed?: number;
  /**
   * @remarks
   * The used capacity of all namespaces in your account.
   * 
   * @example
   * 100 MB
   */
  capacityUsedString?: string;
  /**
   * @remarks
   * The description of the namespace.
   * 
   * @example
   * the first namespace
   */
  description?: string;
  /**
   * @remarks
   * The system behavior when a key-value pair fails to be obtained at the edge. Valid values:
   * 
   * *   Normal (default): If a key-value pair fails to be obtained at the edge, DCDN attempts to query the key-value pair from the origin server to ensure global data consistency.
   * *   Rapid: If a key-value pair fails to be obtained at the edge, an error message indicating that the key does not exist is returned. This feature enhances key-value query performance but may decrease the hit rate of queries. To enable this feature, submit a ticket.
   * 
   * @example
   * Normal
   */
  mode?: string;
  /**
   * @remarks
   * The name of the namespace.
   * 
   * @example
   * ns1
   */
  namespace?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * 12423131231****
   */
  namespaceId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * D61E4801-EAFF-4A63-AAE1-FBF6CE1CFD1C
   */
  requestId?: string;
  /**
   * @remarks
   * The status of the namespace. Valid values:
   * 
   * *   **online**: normal
   * *   **delete**: pending delete
   * *   **deleting**: being deleted
   * *   **deleted**: deleted
   * 
   * @example
   * online
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      capacity: 'Capacity',
      capacityString: 'CapacityString',
      capacityUsed: 'CapacityUsed',
      capacityUsedString: 'CapacityUsedString',
      description: 'Description',
      mode: 'Mode',
      namespace: 'Namespace',
      namespaceId: 'NamespaceId',
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacity: 'number',
      capacityString: 'string',
      capacityUsed: 'number',
      capacityUsedString: 'string',
      description: 'string',
      mode: 'string',
      namespace: 'string',
      namespaceId: 'string',
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnKvNamespaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnKvNamespaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnKvNamespaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnL2IpsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C370DAF1-C838-4288-A1A0-9A87633D248E
   */
  requestId?: string;
  /**
   * @remarks
   * The CIDR blocks of the POPs.
   */
  vips?: string[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      vips: 'Vips',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vips: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnL2IpsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnL2IpsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnL2IpsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnL2VipsRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name. You can specify only one domain name in each request. If you do not specify this parameter, the origin CIDR blocks of all domain names in your account in the whitelist are returned.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnL2VipsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 820E7900-5CA9-4AEF-B0DD-20ED5F64BE55
   */
  requestId?: string;
  /**
   * @remarks
   * The virtual IP addresses (VIPs).
   */
  vips?: string[];
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      requestId: 'RequestId',
      vips: 'Vips',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      requestId: 'string',
      vips: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnL2VipsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnL2VipsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnL2VipsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnOriginSiteHealthStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. You can specify only one domain name in each request.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnOriginSiteHealthStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the origin server of the accelerated domain name.
   */
  originSiteStatus?: DescribeDcdnOriginSiteHealthStatusResponseBodyOriginSiteStatus[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      originSiteStatus: 'OriginSiteStatus',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      originSiteStatus: { 'type': 'array', 'itemType': DescribeDcdnOriginSiteHealthStatusResponseBodyOriginSiteStatus },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnOriginSiteHealthStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnOriginSiteHealthStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnOriginSiteHealthStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnRealTimeDeliveryFieldRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the collected logs. Default value: cdn_log_access_l1. Valid values:
   * 
   * *   **cdn_log_access_l1**: access logs of Dynamic Content Delivery Network (DCDN) points of presence (POPs)
   * *   **cdn_log_origin**: back-to-origin logs
   * *   **cdn_log_er**: EdgeRoutine logs
   * 
   * @example
   * cdn_log_access_l1
   */
  businessType?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnRealTimeDeliveryFieldResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned results.
   */
  content?: DescribeDcdnRealTimeDeliveryFieldResponseBodyContent;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3EACD23C-F49F-4BF7-B9AD-C2CD3BA888C4
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: DescribeDcdnRealTimeDeliveryFieldResponseBodyContent,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnRealTimeDeliveryFieldResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnRealTimeDeliveryFieldResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnRealTimeDeliveryFieldResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnRefreshQuotaRequest extends $tea.Model {
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnRefreshQuotaResponseBody extends $tea.Model {
  /**
   * @remarks
   * The maximum number of URLs that can be blocked.
   * 
   * @example
   * 100
   */
  blockQuota?: string;
  /**
   * @remarks
   * The remaining number of URLs that can be blocked on the current day.
   * 
   * @example
   * 100
   */
  blockRemain?: string;
  /**
   * @remarks
   * The maximum number of directories that can be refreshed on the current day.
   * 
   * @example
   * 100
   */
  dirQuota?: string;
  /**
   * @remarks
   * The remaining number of directories that can be refreshed on the current day.
   * 
   * @example
   * 100
   */
  dirRemain?: string;
  /**
   * @remarks
   * The maximum number of URLs or directories with parameters ignored that can be refreshed on the current day.
   * 
   * @example
   * 100
   */
  ignoreParamsQuota?: string;
  /**
   * @remarks
   * The number of remaining URLs or directories that can be refreshed with parameters ignored on the current day.
   * 
   * @example
   * 10
   */
  ignoreParamsRemain?: string;
  /**
   * @remarks
   * The maximum number of URLs that can be prefetched on the current day.
   * 
   * @example
   * 500
   */
  preloadQuota?: string;
  /**
   * @remarks
   * The remaining number of URLs that can be prefetched on the current day.
   * 
   * @example
   * 500
   */
  preloadRemain?: string;
  /**
   * @remarks
   * The maximum number of URLs or directories that can be refreshed by using regular expressions on the current day.
   * 
   * @example
   * 100
   */
  regexQuota?: string;
  /**
   * @remarks
   * The remaining number of URLs or directories that can be refreshed by using regular expressions on the current day.
   * 
   * @example
   * 100
   */
  regexRemain?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 42E0554B-80F4-4921-AED6-ACFB22CAAAD0
   */
  requestId?: string;
  /**
   * @remarks
   * The maximum number of URLs that can be refreshed on the current day.
   * 
   * @example
   * 2000
   */
  urlQuota?: string;
  /**
   * @remarks
   * The remaining number of URLs that can be refreshed on the current day.
   * 
   * @example
   * 2000
   */
  urlRemain?: string;
  static names(): { [key: string]: string } {
    return {
      blockQuota: 'BlockQuota',
      blockRemain: 'BlockRemain',
      dirQuota: 'DirQuota',
      dirRemain: 'DirRemain',
      ignoreParamsQuota: 'IgnoreParamsQuota',
      ignoreParamsRemain: 'IgnoreParamsRemain',
      preloadQuota: 'PreloadQuota',
      preloadRemain: 'PreloadRemain',
      regexQuota: 'RegexQuota',
      regexRemain: 'RegexRemain',
      requestId: 'RequestId',
      urlQuota: 'UrlQuota',
      urlRemain: 'UrlRemain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockQuota: 'string',
      blockRemain: 'string',
      dirQuota: 'string',
      dirRemain: 'string',
      ignoreParamsQuota: 'string',
      ignoreParamsRemain: 'string',
      preloadQuota: 'string',
      preloadRemain: 'string',
      regexQuota: 'string',
      regexRemain: 'string',
      requestId: 'string',
      urlQuota: 'string',
      urlRemain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnRefreshQuotaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnRefreshQuotaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnRefreshQuotaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnRefreshTaskByIdRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task that you want to query. The following signature algorithms require different message digest algorithms:
   * 
   * *   Perform the [RefreshDcdnObjectCaches](https://help.aliyun.com/document_detail/130620.html) operation to query refresh task IDs.
   * *   Perform the [PreloadDcdnObjectCaches](https://help.aliyun.com/document_detail/130636.html) operation to query prefetch task IDs.
   * 
   * > You can specify at most 10 task IDs in each call. Separate IDs with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * 113681**
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnRefreshTaskByIdResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * E0C2EF95-B1EC-4C93-855E-2059A7DA2B7B
   */
  requestId?: string;
  /**
   * @remarks
   * A list of prefetch or refresh tasks.
   */
  tasks?: DescribeDcdnRefreshTaskByIdResponseBodyTasks[];
  /**
   * @remarks
   * The total number of tasks.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tasks: 'Tasks',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tasks: { 'type': 'array', 'itemType': DescribeDcdnRefreshTaskByIdResponseBodyTasks },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnRefreshTaskByIdResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnRefreshTaskByIdResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnRefreshTaskByIdResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnRefreshTasksRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. You can specify only one domain name in each request.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * > The end time must be later than the start time.
   * 
   * @example
   * 2017-01-01T12:13:20Z
   */
  endTime?: string;
  /**
   * @remarks
   * The path of the object. The path is used as a condition for exact matching.
   * 
   * @example
   * http://example.com/examplefile.txt
   */
  objectPath?: string;
  /**
   * @remarks
   * The type of the task.
   * 
   * *   **file**: URL-based refresh
   * *   **directory**: directory-based refresh
   * *   **preload**: URL-based prefetch
   * 
   * If you set **DomainName** or **Status**, you must also set this parameter.
   * 
   * @example
   * file
   */
  objectType?: string;
  ownerId?: number;
  /**
   * @remarks
   * The number of the page to return. Valid values: **1** to **100000**.
   * 
   * @example
   * 2
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: **20**. Maximum value: **50**. Valid values: **1** to **50**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  securityToken?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2017-01-01T12:12:20Z
   */
  startTime?: string;
  /**
   * @remarks
   * The status of the task.
   * 
   * *   **Complete**: The task is complete.
   * *   **Refreshing**: The task is in progress.
   * *   **Failed**: The task failed.
   * 
   * @example
   * Complete
   */
  status?: string;
  /**
   * @remarks
   * The ID of the task. A task ID is assigned when you create a refresh or prefetch task.
   * 
   * @example
   * 704225667
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      objectPath: 'ObjectPath',
      objectType: 'ObjectType',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      securityToken: 'SecurityToken',
      startTime: 'StartTime',
      status: 'Status',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      objectPath: 'string',
      objectType: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      securityToken: 'string',
      startTime: 'string',
      status: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnRefreshTasksResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 2
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 2
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 174F6032-AA26-470D-B90E-36F0EB205BEE
   */
  requestId?: string;
  /**
   * @remarks
   * Details about tasks.
   */
  tasks?: DescribeDcdnRefreshTasksResponseBodyTasks;
  /**
   * @remarks
   * The number of tasks.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      tasks: 'Tasks',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      tasks: DescribeDcdnRefreshTasksResponseBodyTasks,
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnRefreshTasksResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnRefreshTasksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnRefreshTasksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnRegionAndIspRequest extends $tea.Model {
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnRegionAndIspResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of ISPs.
   */
  isps?: DescribeDcdnRegionAndIspResponseBodyIsps;
  /**
   * @remarks
   * The list of regions.
   */
  regions?: DescribeDcdnRegionAndIspResponseBodyRegions;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 2387C335-932C-4E1E-862C-1C4363B6DE72
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      isps: 'Isps',
      regions: 'Regions',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isps: DescribeDcdnRegionAndIspResponseBodyIsps,
      regions: DescribeDcdnRegionAndIspResponseBodyRegions,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnRegionAndIspResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnRegionAndIspResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnRegionAndIspResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnReportRequest extends $tea.Model {
  /**
   * @remarks
   * The region. You can call the [DescribeDcdnRegionAndIsp](https://help.aliyun.com/document_detail/207199.html) operation to query regions.
   * 
   * *   If you do not specify a region, data in all regions is queried.
   * *   If you specify a region, data in the specified region is returned. You can specify one or more regions. Separate regions with commas (,).
   * 
   * @example
   * shanghai
   */
  area?: string;
  /**
   * @remarks
   * The domain names that you want to query. Separate domain names with commas (,).
   * 
   * @example
   * www.example.com,www.example.org
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-07-02T01:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The HTTP status code. Valid values:
   * 
   * *   **2xx**: HTTP 2xx status codes
   * *   **3xx**: HTTP 3xx status codes
   * *   **4xx**: HTTP 4xx status codes
   * *   **5xx**: HTTP 5xx status codes
   * 
   * If you do not specify an HTTP status code, data for all preceding HTTP status codes is queried.
   * 
   * @example
   * 2xx
   */
  httpCode?: string;
  /**
   * @remarks
   * Specify whether the region is outside the Chinese mainland. Valid values:
   * 
   * *   **1**: outside the Chinese mainland
   * *   **0**: inside the Chinese mainland
   * 
   * @example
   * 0
   */
  isOverseas?: string;
  /**
   * @remarks
   * The ID of the operations report that you want to query. You can enter only one ID in each call. You can call the [DescribeDcdnSubList](https://help.aliyun.com/document_detail/270075.html) operation to query report IDs.
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  reportId?: number;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-07-02T00:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      area: 'Area',
      domainName: 'DomainName',
      endTime: 'EndTime',
      httpCode: 'HttpCode',
      isOverseas: 'IsOverseas',
      reportId: 'ReportId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      area: 'string',
      domainName: 'string',
      endTime: 'string',
      httpCode: 'string',
      isOverseas: 'string',
      reportId: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnReportResponseBody extends $tea.Model {
  /**
   * @remarks
   * The content of the operations report.
   * 
   * @example
   * "data":[{"deliver":{ "report":{"title":"TopUrlByAcc","format":"table","sape":"","header":["url","traf","traf_rate","acc","acc_rate"]}}, "data":[{"acc":440,"acc_rate":"0.200%","traf":22,"url":"http://example.com","traf_rate":"0.100%"},{"acc":440,"acc_rate":"0.200%","traf":22,"url":"http://example.org","traf_rate":"0.100%"}]}]
   */
  content?: { [key: string]: any };
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnReportResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnReportResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnReportResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnReportListRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the operations report that you want to query. If you do not specify an ID, all operations reports are queried.
   * 
   * @example
   * 2
   */
  reportId?: number;
  static names(): { [key: string]: string } {
    return {
      reportId: 'ReportId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      reportId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnReportListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the operations report.
   * 
   * @example
   * "data": [{"reportId":2,"deliver":{"report":{"title":"DomainPvUv","format":"chart","shape":"line","xAxis":"ds","yAxis":"cnt","legend":"cnt_type","header":["ds","cnt_type","cnt"]}}}
   */
  content?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnReportListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnReportListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnReportListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSLSRealTimeLogTypeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned results.
   */
  content?: DescribeDcdnSLSRealTimeLogTypeResponseBodyContent;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: DescribeDcdnSLSRealTimeLogTypeResponseBodyContent,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSLSRealTimeLogTypeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnSLSRealTimeLogTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnSLSRealTimeLogTypeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSLSRealtimeLogDeliveryRequest extends $tea.Model {
  /**
   * @remarks
   * The name of a real-time log delivery project.
   * 
   * This parameter is required.
   * 
   * @example
   * example
   */
  projectName?: string;
  static names(): { [key: string]: string } {
    return {
      projectName: 'ProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSLSRealtimeLogDeliveryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The configuration results of the domain name.
   */
  content?: DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F32C57AA-7BF8-49AE-A2CC-9F42390F5A19
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSLSRealtimeLogDeliveryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnSLSRealtimeLogDeliveryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnSLSRealtimeLogDeliveryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSMCertificateDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the certificate.
   * 
   * This parameter is required.
   * 
   * @example
   * 648****-cn-hangzhou
   */
  certIdentifier?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      certIdentifier: 'CertIdentifier',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certIdentifier: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSMCertificateDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time when the certificate expires. The time is displayed in UTC.
   * 
   * @example
   * 2022-08-31T09:42:28Z
   */
  certExpireTime?: string;
  /**
   * @remarks
   * The ID of the certificate.
   * 
   * @example
   * 648****-cn-hangzhou
   */
  certIdentifier?: string;
  /**
   * @remarks
   * The name of the certificate.
   * 
   * @example
   * yourCertName
   */
  certName?: string;
  /**
   * @remarks
   * The certificate authority (CA) that issued the certificate.
   * 
   * @example
   * DigiCert Inc
   */
  certOrg?: string;
  /**
   * @remarks
   * The top-level domain name.
   * 
   * @example
   * example.com
   */
  commonName?: string;
  /**
   * @remarks
   * The content of the encryption certificate.
   * 
   * @example
   * --BEGIN CERTIFICATE-----***-----END CERTIFICATE--
   */
  encryptCertificate?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * A7C69682-7F88-40DD-A198-10D0309E439D
   */
  requestId?: string;
  /**
   * @remarks
   * The domain name on the additional certificate.
   * 
   * @example
   * ***.example.com
   */
  sans?: string;
  /**
   * @remarks
   * The content of the signature certificate.
   * 
   * @example
   * --BEGIN CERTIFICATE-----***-----END CERTIFICATE--
   */
  signCertificate?: string;
  static names(): { [key: string]: string } {
    return {
      certExpireTime: 'CertExpireTime',
      certIdentifier: 'CertIdentifier',
      certName: 'CertName',
      certOrg: 'CertOrg',
      commonName: 'CommonName',
      encryptCertificate: 'EncryptCertificate',
      requestId: 'RequestId',
      sans: 'Sans',
      signCertificate: 'SignCertificate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certExpireTime: 'string',
      certIdentifier: 'string',
      certName: 'string',
      certOrg: 'string',
      commonName: 'string',
      encryptCertificate: 'string',
      requestId: 'string',
      sans: 'string',
      signCertificate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSMCertificateDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnSMCertificateDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnSMCertificateDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSMCertificateListRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name whose SM certificates you want to query.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSMCertificateListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The type of the certificate information.
   */
  certificateListModel?: DescribeDcdnSMCertificateListResponseBodyCertificateListModel;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * DC0E34AC-0239-44A7-AB0E-800DE522C8DC
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      certificateListModel: 'CertificateListModel',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certificateListModel: DescribeDcdnSMCertificateListResponseBodyCertificateListModel,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSMCertificateListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnSMCertificateListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnSMCertificateListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSSLCertificateListRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain secured by the SSL certificate. HTTPS secure acceleration is enabled for the accelerated domain name.
   * 
   * @example
   * www.example.com
   */
  domainName?: string;
  ownerId?: number;
  /**
   * @remarks
   * The number of the page. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The maximum number of entries to return on each page. Valid values: **1 to 1000**.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The keyword that is used to query the certificate.
   * 
   * @example
   * taobao
   */
  searchKeyword?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchKeyword: 'SearchKeyword',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      searchKeyword: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSSLCertificateListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of certificates.
   */
  certificateListModel?: DescribeDcdnSSLCertificateListResponseBodyCertificateListModel;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CB1A380B-09F0-41BB-3C82-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      certificateListModel: 'CertificateListModel',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certificateListModel: DescribeDcdnSSLCertificateListResponseBodyCertificateListModel,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSSLCertificateListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnSSLCertificateListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnSSLCertificateListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSecFuncInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The language. Valid values: en and zh. Default value: en.
   * 
   * This parameter is required.
   * 
   * @example
   * en
   */
  lang?: string;
  /**
   * @remarks
   * The type of the drop-down list. Valid values: RobotRuleName and RobotObject.
   * 
   * This parameter is required.
   * 
   * @example
   * RobotRuleName
   */
  secFuncType?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      secFuncType: 'SecFuncType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      secFuncType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSecFuncInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The parameters required by the code.
   */
  content?: DescribeDcdnSecFuncInfoResponseBodyContent[];
  /**
   * @remarks
   * The description of HTTP responses.
   * 
   * @example
   * OK
   */
  description?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatus?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 30A3A25A-86B3-4C1D-BAA8-12B8607A5CFD
   */
  requestId?: string;
  /**
   * @remarks
   * The return value for HTTP requests. Valid values:
   * 
   * *   0: OK.
   * *   Values other than 0: an error.
   * 
   * @example
   * 0
   */
  retCode?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      description: 'Description',
      httpStatus: 'HttpStatus',
      requestId: 'RequestId',
      retCode: 'RetCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'array', 'itemType': DescribeDcdnSecFuncInfoResponseBodyContent },
      description: 'string',
      httpStatus: 'string',
      requestId: 'string',
      retCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSecFuncInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnSecFuncInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnSecFuncInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSecSpecInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 32f6cbb7-13e5-403a-9941-4d4e978dd227
   */
  requestId?: string;
  /**
   * @remarks
   * The code and configurations of the security rules.
   */
  specInfos?: DescribeDcdnSecSpecInfoResponseBodySpecInfos[];
  /**
   * @remarks
   * The version of secure DCDN.
   * 
   * @example
   * enterprise
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      specInfos: 'SpecInfos',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      specInfos: { 'type': 'array', 'itemType': DescribeDcdnSecSpecInfoResponseBodySpecInfos },
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSecSpecInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnSecSpecInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnSecSpecInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnServiceRequest extends $tea.Model {
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnServiceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time when the renewed secure DCDN takes effect. The time is displayed in UTC.
   * 
   * @example
   * 2018-03-31T16:00:00Z
   */
  changingAffectTime?: string;
  /**
   * @remarks
   * The new metering method for the renewed secure DCDN. Valid values:
   * 
   * *   **PayByTraffic**: pay by data transfer
   * *   **PayByBandwidth**: pay by bandwidth
   * *   **PayByBandwidth95**: pay by 95th percentile bandwidth
   * *   **PayByBandwidth_monthavg**: pay by monthly average bandwidth
   * *   **PayByBandwidth_month4th**: pay by fourth peak bandwidth per month
   * *   **PayByBandwidth_monthday95avg**: pay by monthly average 95th percentile bandwidth
   * *   **PayByBandwidth_nighthalf95**: pay by 95th percentile bandwidth (50% off during nighttime)
   * 
   * @example
   * PayByBandwidth
   */
  changingChargeType?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * FP-mkqgwxxxx
   */
  instanceId?: string;
  /**
   * @remarks
   * The current metering method. Valid values:
   * 
   * *   **PayByTraffic**: pay by data transfer
   * *   **PayByBandwidth**: pay by bandwidth
   * *   **PayByBandwidth95**: pay by 95th percentile bandwidth
   * *   **PayByBandwidth_monthavg**: pay by monthly average bandwidth
   * *   **PayByBandwidth_month4th**: pay by fourth peak bandwidth per month
   * *   **PayByBandwidth_monthday95avg**: pay by monthly average 95th percentile bandwidth
   * *   **PayByBandwidth_nighthalf95**: pay by 95th percentile bandwidth (50% off during nighttime)
   * 
   * @example
   * PayByTraffic
   */
  internetChargeType?: string;
  /**
   * @remarks
   * The time when the DCDN service was activated. The time follows the ISO 8601 standard.
   * 
   * @example
   * 2018-03-19T11:16:11Z
   */
  openingTime?: string;
  /**
   * @remarks
   * The lock status of DCDN.
   */
  operationLocks?: DescribeDcdnServiceResponseBodyOperationLocks;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EF2AEBC2-EDBD-41CF-BF64-7E095D42D6EF
   */
  requestId?: string;
  /**
   * @remarks
   * The time when the changes of the WebSocket configuration take effect. The value is the same as that of the ChangingAffectTime parameter. This parameter can be displayed in the console only if the specified time is later than the current time.
   * 
   * @example
   * 2018-03-19T11:16:11Z
   */
  websocketChangingTime?: string;
  /**
   * @remarks
   * The next effective billing method of WebSocket. Valid values: **websockettraffic** and **websocketbps**. A value of websockettraffic indicates that you are billed based on the traffic volume. A value of websocketbps indicates that you are billed based on the bandwidth.
   * 
   * @example
   * websocketbps
   */
  websocketChangingType?: string;
  /**
   * @remarks
   * The current billing method of WebSocket. Valid values: **websockettraffic** and **websocketbps**. A value of websockettraffic indicates that you are billed based on the traffic volume. A value of websocketbps indicates that you are billed based on the bandwidth.
   * 
   * @example
   * websocketbps
   */
  websocketType?: string;
  static names(): { [key: string]: string } {
    return {
      changingAffectTime: 'ChangingAffectTime',
      changingChargeType: 'ChangingChargeType',
      instanceId: 'InstanceId',
      internetChargeType: 'InternetChargeType',
      openingTime: 'OpeningTime',
      operationLocks: 'OperationLocks',
      requestId: 'RequestId',
      websocketChangingTime: 'WebsocketChangingTime',
      websocketChangingType: 'WebsocketChangingType',
      websocketType: 'WebsocketType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      changingAffectTime: 'string',
      changingChargeType: 'string',
      instanceId: 'string',
      internetChargeType: 'string',
      openingTime: 'string',
      operationLocks: DescribeDcdnServiceResponseBodyOperationLocks,
      requestId: 'string',
      websocketChangingTime: 'string',
      websocketChangingType: 'string',
      websocketType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnServiceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnStagingIpResponseBody extends $tea.Model {
  IPV4s?: DescribeDcdnStagingIpResponseBodyIPV4s;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 1B9E0E83-24AC-49F4-9EE0-BF5EB03E8381
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      IPV4s: 'IPV4s',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      IPV4s: DescribeDcdnStagingIpResponseBodyIPV4s,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnStagingIpResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnStagingIpResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnStagingIpResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSubListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the custom report.
   * 
   * @example
   * "data": [{"subId": 336,"reportId": [6,8],"createTime": "2021-07-05T06:18:46Z","domains": ["example.com"],"effectiveFrom": "2021-07-05T06:18:46Z","effectiveEnd": "2021-10-05T06:18:46Z","status": "enable"}]
   */
  content?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 3250A51D-C11D-46BA-B6B3-95348EEDE652
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSubListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnSubListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnSubListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnTagResourcesRequest extends $tea.Model {
  /**
   * @remarks
   * The list of resource IDs. You can specify a maximum of 50 resource IDs.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  resourceId?: string[];
  /**
   * @remarks
   * The type of the resource. Set the value to **DOMAIN**.
   * 
   * This parameter is required.
   * 
   * @example
   * DOMAIN
   */
  resourceType?: string;
  /**
   * @remarks
   * The tags. You can specify a maximum of 20 tag values.
   */
  tag?: DescribeDcdnTagResourcesRequestTag[];
  static names(): { [key: string]: string } {
    return {
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      tag: { 'type': 'array', 'itemType': DescribeDcdnTagResourcesRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnTagResourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 34AB41F1-04A5-496F-8C8D-634BDBE6A9FB
   */
  requestId?: string;
  /**
   * @remarks
   * The tag of the instance.
   */
  tagResources?: DescribeDcdnTagResourcesResponseBodyTagResources[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tagResources: 'TagResources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tagResources: { 'type': 'array', 'itemType': DescribeDcdnTagResourcesResponseBodyTagResources },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnTagResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnTagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnTagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnTopDomainsByFlowRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * The end time must be later than the start time.
   * 
   * @example
   * 2016-03-14T07:34:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The maximum number of domain names to return. Valid values: **1** to **100**. Default value: **20**.
   * 
   * @example
   * 20
   */
  limit?: number;
  /**
   * @remarks
   * The start of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2016-03-01T04:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      limit: 'Limit',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      limit: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnTopDomainsByFlowResponseBody extends $tea.Model {
  /**
   * @remarks
   * The total number of accelerated domains under your account.
   * 
   * @example
   * 68
   */
  domainCount?: number;
  /**
   * @remarks
   * The total number of accelerated domains that are in the **Enabled** state under your account.
   * 
   * @example
   * 68
   */
  domainOnlineCount?: number;
  /**
   * @remarks
   * The end of the reporting period.
   * 
   * @example
   * 2016-03-14T07:34:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 4E09C5D7-E1CF-4CAA-A45E-8727F4C8FD70
   */
  requestId?: string;
  /**
   * @remarks
   * The beginning of the reporting period.
   * 
   * @example
   * 2016-03-14T06:34:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The top N domain names ranked by network traffic.
   */
  topDomains?: DescribeDcdnTopDomainsByFlowResponseBodyTopDomains;
  static names(): { [key: string]: string } {
    return {
      domainCount: 'DomainCount',
      domainOnlineCount: 'DomainOnlineCount',
      endTime: 'EndTime',
      requestId: 'RequestId',
      startTime: 'StartTime',
      topDomains: 'TopDomains',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainCount: 'number',
      domainOnlineCount: 'number',
      endTime: 'string',
      requestId: 'string',
      startTime: 'string',
      topDomains: DescribeDcdnTopDomainsByFlowResponseBodyTopDomains,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnTopDomainsByFlowResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnTopDomainsByFlowResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnTopDomainsByFlowResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserBillHistoryRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * The end time must be later than the start time.
   * 
   * This parameter is required.
   * 
   * @example
   * 2018-10-31T16:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * The minimum data granularity is 5 minutes.
   * 
   * This parameter is required.
   * 
   * @example
   * 2018-09-30T16:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserBillHistoryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The billing history returned.
   */
  billHistoryData?: DescribeDcdnUserBillHistoryResponseBodyBillHistoryData;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * ED61C6C3-8241-4187-AAA7-5157AE175CEC
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      billHistoryData: 'BillHistoryData',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      billHistoryData: DescribeDcdnUserBillHistoryResponseBodyBillHistoryData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserBillHistoryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnUserBillHistoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnUserBillHistoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserBillTypeRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * The end time must be later than the start time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2018-10-31T16:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2018-09-30T16:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserBillTypeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the metering method.
   */
  billTypeData?: DescribeDcdnUserBillTypeResponseBodyBillTypeData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * C370DAF1-C838-4288-A1A0-9A87633D248E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      billTypeData: 'BillTypeData',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      billTypeData: DescribeDcdnUserBillTypeResponseBodyBillTypeData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserBillTypeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnUserBillTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnUserBillTypeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserCertificateExpireCountResponseBody extends $tea.Model {
  /**
   * @remarks
   * The number of domain names whose SSL certificates are about to expire within 30 days.
   * 
   * @example
   * 0
   */
  expireWithin30DaysCount?: number;
  /**
   * @remarks
   * The number of domain names whose SSL certificates have already expired.
   * 
   * @example
   * 6
   */
  expiredCount?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F5E8DF64-7175-4186-9B06-F002C0BBD0C5
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      expireWithin30DaysCount: 'ExpireWithin30DaysCount',
      expiredCount: 'ExpiredCount',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expireWithin30DaysCount: 'number',
      expiredCount: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserCertificateExpireCountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnUserCertificateExpireCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnUserCertificateExpireCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserConfigsRequest extends $tea.Model {
  /**
   * @remarks
   * The configuration that you want to query. Valid values:
   * 
   * *   domain_business_control: user configurations
   * *   bot_basic: the basic edition of bot traffic management, which supports authorized crawlers and provides threat intelligence
   * *   bot_Advance: the advanced edition of bot traffic management, which supports authorized crawlers and AI intelligent protection and provides threat intelligence
   * 
   * This parameter is required.
   * 
   * @example
   * domain_business_control
   */
  functionName?: string;
  static names(): { [key: string]: string } {
    return {
      functionName: 'FunctionName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserConfigsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The user configurations.
   */
  configs?: DescribeDcdnUserConfigsResponseBodyConfigs[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 06D29681-B7CD-4034-A8CC-28AFFA213539
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      configs: 'Configs',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configs: { 'type': 'array', 'itemType': DescribeDcdnUserConfigsResponseBodyConfigs },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserConfigsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnUserConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnUserConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserDomainsRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC+0.
   * 
   * > The end time must be later than the start time.
   * 
   * @example
   * 2018-05-10T14:00:00Z
   */
  changeEndTime?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC+0.
   * 
   * @example
   * 2018-05-10T12:00:00Z
   */
  changeStartTime?: string;
  /**
   * @remarks
   * Specifies whether to display domain names that are under review, failed the review, or failed to be configured. Valid values:
   * 
   * *   true: displays domain names.
   * *   false: does not display detailed information.
   * 
   * @example
   * false
   */
  checkDomainShow?: boolean;
  /**
   * @remarks
   * The acceleration region. By default, all acceleration regions are queried.
   * 
   * *   **domestic**: Chinese mainland
   * *   **overseas**: outside the Chinese mainland
   * *   **global**: global
   * 
   * @example
   * domestic
   */
  coverage?: string;
  /**
   * @remarks
   * The accelerated domain names. If you do not set this parameter, configurations of all domain names that match the conditions are returned.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The search method. Default value: full_match. Valid values:
   * 
   * *   **fuzzy_match**: fuzzy match
   * *   **pre_match**: prefix match
   * *   **suf_match**: suffix match
   * *   **full_match** (default): exact match
   * 
   * > If you specify the domain names to query but do not set the DomainSearchType parameter, the exact match mode is used.
   * 
   * @example
   * fuzzy_match
   */
  domainSearchType?: string;
  /**
   * @remarks
   * The status of the domain name. Valid values:
   * 
   * *   **online**: enabled
   * *   **offline**: disabled
   * *   **configuring**: configuring
   * *   **configure_failed**: configuration failed
   * *   **checking**: reviewing
   * *   **check_failed:** review failed
   * 
   * @example
   * online
   */
  domainStatus?: string;
  ownerId?: number;
  /**
   * @remarks
   * The number of returned pages. Valid values: **1** to **100000**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: **20**. Valid values: **1** to **500**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfmv6jutt**
   */
  resourceGroupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The list of tags.
   */
  tag?: DescribeDcdnUserDomainsRequestTag[];
  /**
   * @remarks
   * The business type of the domain. Separate multiple values with commas (,). Default value: **dynamic**. To query common domains, keep the default value. To query domains of the computing business type, enter **computing_routine** or **computing_image**.
   * 
   * @example
   * computing_routine
   */
  webSiteType?: string;
  static names(): { [key: string]: string } {
    return {
      changeEndTime: 'ChangeEndTime',
      changeStartTime: 'ChangeStartTime',
      checkDomainShow: 'CheckDomainShow',
      coverage: 'Coverage',
      domainName: 'DomainName',
      domainSearchType: 'DomainSearchType',
      domainStatus: 'DomainStatus',
      ownerId: 'OwnerId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      resourceGroupId: 'ResourceGroupId',
      securityToken: 'SecurityToken',
      tag: 'Tag',
      webSiteType: 'WebSiteType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      changeEndTime: 'string',
      changeStartTime: 'string',
      checkDomainShow: 'boolean',
      coverage: 'string',
      domainName: 'string',
      domainSearchType: 'string',
      domainStatus: 'string',
      ownerId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      resourceGroupId: 'string',
      securityToken: 'string',
      tag: { 'type': 'array', 'itemType': DescribeDcdnUserDomainsRequestTag },
      webSiteType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserDomainsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the queried domains.
   */
  domains?: DescribeDcdnUserDomainsResponseBodyDomains;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 12
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * AA75AADB-5E25-4970-B480-EAA1F5658483
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 12
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      domains: 'Domains',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domains: DescribeDcdnUserDomainsResponseBodyDomains,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserDomainsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnUserDomainsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnUserDomainsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserDomainsByFuncRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name whose ICP filing status you want to update.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * Specifies whether the feature that is specified by the FuncId parameter is enabled.
   * 
   * *   **config**: enabled
   * *   **unconfig**: not enabled
   * 
   * @example
   * config
   */
  funcFilter?: string;
  /**
   * @remarks
   * The ID of the feature. For more information about how to query feature IDs, see [Parameters for configuring features for domain names](https://help.aliyun.com/document_detail/410622.html). For example, the ID of the origin host feature (set_req_host_header) is 18.
   * 
   * This parameter is required.
   * 
   * @example
   * 7
   */
  funcId?: number;
  /**
   * @remarks
   * The type of the search. Default value: exact_match. Valid values:
   * 
   * *   fuzzy_match: fuzzy search.
   * *   exact_match: exact search.
   * 
   * @example
   * exact_match
   */
  matchType?: string;
  /**
   * @remarks
   * The number of the page to return. Default value: **1**. Valid values: **1 to 100000**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: **20**. Valid values: **1 to 500**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfmyuji4b6r4**
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      funcFilter: 'FuncFilter',
      funcId: 'FuncId',
      matchType: 'MatchType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      funcFilter: 'string',
      funcId: 'number',
      matchType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserDomainsByFuncResponseBody extends $tea.Model {
  /**
   * @remarks
   * The array that consists of multiple PageData parameters. The details about each accelerated domain name are included in a separate PageData parameter.
   */
  domains?: DescribeDcdnUserDomainsByFuncResponseBodyDomains;
  /**
   * @remarks
   * The page number of the page returned.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 5
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * AA75AADB-5E25-4970-B480-EAA1F5658483
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of domain names returned.
   * 
   * @example
   * 16
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      domains: 'Domains',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domains: DescribeDcdnUserDomainsByFuncResponseBodyDomains,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserDomainsByFuncResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnUserDomainsByFuncResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnUserDomainsByFuncResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserQuotaRequest extends $tea.Model {
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserQuotaResponseBody extends $tea.Model {
  /**
   * @remarks
   * The maximum number of URLs that can be blocked.
   * 
   * @example
   * 20
   */
  blockQuota?: number;
  /**
   * @remarks
   * The remaining number of URLs that can be blocked.
   * 
   * @example
   * 500
   */
  blockRemain?: number;
  /**
   * @remarks
   * The maximum number of accelerated domains.
   * 
   * @example
   * 50
   */
  domainQuota?: number;
  /**
   * @remarks
   * The maximum number of URLs or directories with parameters ignored that can be refreshed.
   * 
   * @example
   * 100
   */
  ignoreParamsQuota?: number;
  /**
   * @remarks
   * The number of remaining URLs or directories with parameters ignored that can be refreshed.
   * 
   * @example
   * 10
   */
  ignoreParamsRemain?: number;
  /**
   * @remarks
   * The maximum number of URLs that can be prefetched.
   * 
   * @example
   * 500
   */
  preloadQuota?: number;
  /**
   * @remarks
   * The remaining number of URLs that can be prefetched.
   * 
   * @example
   * 300
   */
  preloadRemain?: number;
  /**
   * @remarks
   * The maximum number of directories that can be refreshed.
   * 
   * @example
   * 100
   */
  refreshDirQuota?: number;
  /**
   * @remarks
   * The remaining number of directories that can be refreshed.
   * 
   * @example
   * 100
   */
  refreshDirRemain?: number;
  /**
   * @remarks
   * The maximum number of URLs that can be refreshed.
   * 
   * @example
   * 100
   */
  refreshUrlQuota?: number;
  /**
   * @remarks
   * The remaining number of URLs that can be refreshed.
   * 
   * @example
   * 100
   */
  refreshUrlRemain?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * BFFCDFAD-DACC-484E-9BE6-0AF3B3A0DD23
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      blockQuota: 'BlockQuota',
      blockRemain: 'BlockRemain',
      domainQuota: 'DomainQuota',
      ignoreParamsQuota: 'IgnoreParamsQuota',
      ignoreParamsRemain: 'IgnoreParamsRemain',
      preloadQuota: 'PreloadQuota',
      preloadRemain: 'PreloadRemain',
      refreshDirQuota: 'RefreshDirQuota',
      refreshDirRemain: 'RefreshDirRemain',
      refreshUrlQuota: 'RefreshUrlQuota',
      refreshUrlRemain: 'RefreshUrlRemain',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockQuota: 'number',
      blockRemain: 'number',
      domainQuota: 'number',
      ignoreParamsQuota: 'number',
      ignoreParamsRemain: 'number',
      preloadQuota: 'number',
      preloadRemain: 'number',
      refreshDirQuota: 'number',
      refreshDirRemain: 'number',
      refreshUrlQuota: 'number',
      refreshUrlRemain: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserQuotaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnUserQuotaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnUserQuotaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserRealTimeDeliveryFieldRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the collected logs. Default value: cdn_log_access_l1. Valid values:
   * 
   * *   **cdn_log_access_l1**: access logs of L1 Dynamic Content Delivery Network (DCDN) points of presence (POPs)
   * *   **cdn_log_origin**: back-to-origin logs
   * *   **cdn_log_er**: EdgeRoutine logs
   * 
   * @example
   * cdn_log_access_l1
   */
  businessType?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserRealTimeDeliveryFieldResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data returned.
   */
  content?: DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContent;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3EACD23C-F49F-4BF7-B9AD-C2CD3BA888C4
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContent,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserRealTimeDeliveryFieldResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnUserRealTimeDeliveryFieldResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnUserRealTimeDeliveryFieldResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserResourcePackageRequest extends $tea.Model {
  ownerId?: number;
  securityToken?: string;
  /**
   * @remarks
   * The status of the resource plan. Valid values:
   * 
   * *   **valid**: valid
   * *   **closed**: expired
   * *   If you leave this parameter empty, all resource plans are queried.
   * 
   * @example
   * valid
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      securityToken: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserResourcePackageResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 96ED3127-EC7A-57C5-AFA6-A689B24B2530
   */
  requestId?: string;
  /**
   * @remarks
   * The detailed information about resource plans. The returned information is displayed in the format that is specified by the ResourcePackageInfo parameter.
   */
  resourcePackageInfos?: DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfos;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      resourcePackageInfos: 'ResourcePackageInfos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      resourcePackageInfos: DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfos,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserResourcePackageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnUserResourcePackageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnUserResourcePackageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserSecDropRequest extends $tea.Model {
  /**
   * @remarks
   * The date or month that you want to query.
   * 
   * *   If data is collected every day, set Data in the format of yyyymmdd, such as 20201203.
   * *   If data is collected every month, set Data in the format of yyyymm, such as 202012.
   * 
   * This parameter is required.
   * 
   * @example
   * 20201203
   */
  data?: string;
  /**
   * @remarks
   * The time interval at which data is collected.
   * 
   * *   If data is collected every day, the number of blocked packets on the specified day is calculated.
   * *   If data is collected every month, the number of blocked packets in the specified month is calculated.
   * 
   * This parameter is required.
   * 
   * @example
   * 1day
   */
  metric?: string;
  /**
   * @remarks
   * The security feature. Valid values:
   * 
   * *   waf: WAF
   * *   tmd: rate limiting
   * *   robot: bot traffic recognition
   * *   l4_dm_drop: domain name blocking at Layer 4
   * 
   * This parameter is required.
   * 
   * @example
   * waf
   */
  secFunc?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      metric: 'Metric',
      secFunc: 'SecFunc',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      metric: 'string',
      secFunc: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserSecDropResponseBody extends $tea.Model {
  /**
   * @remarks
   * The number of packets that are blocked.
   * 
   * @example
   * 233023208
   */
  drops?: number;
  /**
   * @remarks
   * Indicates whether the information is found.
   * 
   * *   Found
   * *   Not Found
   * 
   * @example
   * Found
   */
  msg?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4A1295C0-7A5C-4F27-8D70-C3A648E7037F
   */
  requestId?: string;
  /**
   * @remarks
   * The character string that is concatenated based on the request parameters and is used to locate causes when data is not found.
   * 
   * @example
   * 1day10811******6429wafDCDN
   */
  uuidStr?: string;
  static names(): { [key: string]: string } {
    return {
      drops: 'Drops',
      msg: 'Msg',
      requestId: 'RequestId',
      uuidStr: 'UuidStr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      drops: 'number',
      msg: 'string',
      requestId: 'string',
      uuidStr: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserSecDropResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnUserSecDropResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnUserSecDropResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserSecDropByMinuteRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. Example: 2006-01-02T15:05:04Z.
   * 
   * > The end time must be later than the start time.
   * 
   * @example
   * 2006-01-02T15:05:04Z
   */
  endTime?: string;
  /**
   * @remarks
   * The language. Valid values: en and zh. Default value: en
   * 
   * This parameter is required.
   * 
   * @example
   * zh
   */
  lang?: string;
  /**
   * @remarks
   * The object that triggered rate limiting.
   * 
   * @example
   * robot_fingerprint_ai
   */
  object?: string;
  /**
   * @remarks
   * The number of the page to return. Pages start from page 1.
   * 
   * @example
   * 10
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 100.
   * 
   * @example
   * 2
   */
  pageSize?: number;
  /**
   * @remarks
   * The rule that was triggered.
   * 
   * @example
   * robot_ai
   */
  ruleName?: string;
  /**
   * @remarks
   * The name of the security feature.
   * 
   * This parameter is required.
   * 
   * @example
   * robot
   */
  secFunc?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. Example: 2006-01-02T15:04:04Z.
   * 
   * @example
   * 2006-01-02T15:04:04Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      lang: 'Lang',
      object: 'Object',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ruleName: 'RuleName',
      secFunc: 'SecFunc',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      lang: 'string',
      object: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      ruleName: 'string',
      secFunc: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserSecDropByMinuteResponseBody extends $tea.Model {
  /**
   * @remarks
   * The description of HTTP responses.
   * 
   * @example
   * OK
   */
  description?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 2
   */
  len?: number;
  /**
   * @remarks
   * The number of the returned page.
   * 
   * @example
   * 10
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 2
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 8143fA8A-B2B2-4915-538D-546B538D25FA
   */
  requestId?: string;
  /**
   * @remarks
   * An array.
   */
  rows?: DescribeDcdnUserSecDropByMinuteResponseBodyRows[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 5738
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      len: 'Len',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      rows: 'Rows',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      len: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      rows: { 'type': 'array', 'itemType': DescribeDcdnUserSecDropByMinuteResponseBodyRows },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserSecDropByMinuteResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnUserSecDropByMinuteResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnUserSecDropByMinuteResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserTagsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 34AB41F1-04A5-496F-8C8D-634BDBE6A9FB
   */
  requestId?: string;
  /**
   * @remarks
   * The tag.
   */
  tags?: DescribeDcdnUserTagsResponseBodyTags[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tags: { 'type': 'array', 'itemType': DescribeDcdnUserTagsResponseBodyTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserTagsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnUserTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnUserTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserVipsByDomainRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to query the virtual IP addresses of only healthy POPs. Valid value:
   * 
   * *   **on**: queries healthy VIPs.
   * *   **off**: queries all VIPs.
   * 
   * @example
   * on
   */
  available?: string;
  /**
   * @remarks
   * The accelerated domain name. You can specify only one domain name.
   * 
   * Enumeration values: example.com
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  static names(): { [key: string]: string } {
    return {
      available: 'Available',
      domainName: 'DomainName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      available: 'string',
      domainName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserVipsByDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 820E7900-5CA9-4AEF-B0DD-20ED5F64BE55
   */
  requestId?: string;
  /**
   * @remarks
   * The list of VIPs.
   */
  vips?: DescribeDcdnUserVipsByDomainResponseBodyVips;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      requestId: 'RequestId',
      vips: 'Vips',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      requestId: 'string',
      vips: DescribeDcdnUserVipsByDomainResponseBodyVips,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserVipsByDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnUserVipsByDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnUserVipsByDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnVerifyContentRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name for which you want to query the ownership verification content. You can specify only one domain name in one request.
   * 
   * This parameter is required.
   * 
   * @example
   * **example**.com
   */
  domainName?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnVerifyContentResponseBody extends $tea.Model {
  /**
   * @remarks
   * The verification result.
   * 
   * @example
   * verify_dffeb6610035dcb78b413a59c31cd9**
   */
  content?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 34AB41F1-04A5-496F-8C8D-634BDBE6A9FB
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnVerifyContentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnVerifyContentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnVerifyContentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafBotAppKeyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The SDK authentication key for the Alibaba Cloud account.
   * 
   * @example
   * examp1eapp_key_xxxiuMWTX4Gw
   */
  appKey?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F2542B96-B535-5BF9-8EEE-1CF11B20CCA8
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      appKey: 'AppKey',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appKey: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafBotAppKeyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnWafBotAppKeyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnWafBotAppKeyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafDefaultRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The query conditions. The value is a string in the JSON format. Format: `QueryArgs={"DefenseScene":"anti_scan"}`
   * 
   * @example
   * {"DefenseScene":"anti_scan"}
   */
  queryArgs?: string;
  static names(): { [key: string]: string } {
    return {
      queryArgs: 'QueryArgs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      queryArgs: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafDefaultRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The rule configurations.
   */
  content?: DescribeDcdnWafDefaultRulesResponseBodyContent[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A123425345
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'array', 'itemType': DescribeDcdnWafDefaultRulesResponseBodyContent },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafDefaultRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnWafDefaultRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnWafDefaultRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. If you do not specify an accelerated domain name, all accelerated domain names are queried.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The region where WAF is enabled.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the resource group. If you leave this parameter empty, the default resource group is used.
   * 
   * @example
   * /
   */
  resourceGroupId?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      regionId: 'RegionId',
      resourceGroupId: 'ResourceGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      regionId: 'string',
      resourceGroupId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name.
   */
  outPutDomains?: DescribeDcdnWafDomainResponseBodyOutPutDomains[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CB1A380B-09F0-41BB-802B-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @remarks
   * The number of accelerated domain names returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      outPutDomains: 'OutPutDomains',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      outPutDomains: { 'type': 'array', 'itemType': DescribeDcdnWafDomainResponseBodyOutPutDomains },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnWafDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnWafDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafDomainDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. You can specify only one domain name in each request. Exact match is supported.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafDomainDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the accelerated domain name.
   */
  domain?: DescribeDcdnWafDomainDetailResponseBodyDomain;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 153ca2cd-3c01-44be-82C0-64dbc6c88630
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: DescribeDcdnWafDomainDetailResponseBodyDomain,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafDomainDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnWafDomainDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnWafDomainDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafDomainsRequest extends $tea.Model {
  /**
   * @remarks
   * The number of the page to return. Valid values: **1** to **100000**.
   * 
   * Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of domain names to return on each page. Valid values: an integer from **1** to **500**. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The query conditions. You can filter domain names by name. Fuzzy match is supported `QueryArgs={"DomainName":"Accelerated domain name"}`
   * 
   * @example
   * {"DomainName":"example.com"}
   */
  queryArgs?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      queryArgs: 'QueryArgs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      queryArgs: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafDomainsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The protected domain name.
   */
  domains?: DescribeDcdnWafDomainsResponseBodyDomains[];
  /**
   * @remarks
   * The page number of the returned page, which is the same as the PageNumber parameter in request parameters.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of domain names returned per page, which is the same as the PageSize parameter in request parameters.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 153ca2cd-3c01-44be-b408-64dbc6c88630
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of protected domain names.
   * 
   * @example
   * 15
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      domains: 'Domains',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domains: { 'type': 'array', 'itemType': DescribeDcdnWafDomainsResponseBodyDomains },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafDomainsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnWafDomainsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnWafDomainsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafFilterInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the protection policy. Separate multiple types with commas (,). Valid values:
   * 
   * *   waf_group: basic web protection
   * *   custom_acl: custom protection
   * *   whitelist: IP address whitelist
   * 
   * >If you do not specify this parameter, all types are returned.
   * 
   * @example
   * custom_acl
   */
  defenseScenes?: string;
  /**
   * @remarks
   * The language of the returned information. Valid values:
   * 
   * *   en: English
   * *   cn: Simplified Chinese
   * 
   * This parameter is required.
   * 
   * @example
   * cn
   */
  language?: string;
  static names(): { [key: string]: string } {
    return {
      defenseScenes: 'DefenseScenes',
      language: 'Language',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defenseScenes: 'string',
      language: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafFilterInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned information.
   */
  content?: DescribeDcdnWafFilterInfoResponseBodyContent[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 153ca2cd-3c01-44be-204c-64dbc6c88630
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'array', 'itemType': DescribeDcdnWafFilterInfoResponseBodyContent },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafFilterInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnWafFilterInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnWafFilterInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafGeoInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the information to return. Valid values:
   * 
   * *   cn: Chinese
   * *   en: English
   * 
   * This parameter is required.
   * 
   * @example
   * cn
   */
  language?: string;
  static names(): { [key: string]: string } {
    return {
      language: 'Language',
    };
  }

  static types(): { [key: string]: any } {
    return {
      language: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafGeoInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The type of information about the country or region.
   */
  content?: DescribeDcdnWafGeoInfoResponseBodyContent[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 66A98669-CC6E-4F3E-80A6-3014697B11AE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'array', 'itemType': DescribeDcdnWafGeoInfoResponseBodyContent },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafGeoInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnWafGeoInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnWafGeoInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the WAF rule group. You can query the ID by calling the [DescribeDcdnWafGroups](~~DescribeDcdnWafGroups~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1012
   */
  id?: number;
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   **en**: English.
   * *   **zh**: Chinese.
   * 
   * This parameter is required.
   * 
   * @example
   * zh
   */
  language?: string;
  /**
   * @remarks
   * The number of the page to return. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The query conditions. The value is a JSON string in the following format:
   * 
   * `QueryArgs={"PolicyIds":"The range of protection policy IDs","RuleIds":"The range of protection rule IDs","RuleNameLike":"The name of the protection rule","DomainNames":"The protected domain names","DefenseScenes":"waf_group","RuleStatus":"on","OrderBy":"GmtModified","Desc":"false"}`
   * 
   * >  If you do not specify this parameter, all protection rules are queried.
   * 
   * @example
   * {\\"RiskLevel\\":\\"\\",\\"ProtectionType\\":\\"\\",\\"ApplicationType\\":\\"\\",\\"RuleIdLike\\":\\"\\"}
   */
  queryArgs?: string;
  /**
   * @remarks
   * The range of the rule group to be queried.
   * 
   * *   **in**: Rules in the rule group are returned.
   * *   **out**: Rules that are in the full rule set but are not in the rule group are returned.
   * 
   * This parameter is required.
   * 
   * @example
   * in
   */
  scope?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      language: 'Language',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      queryArgs: 'QueryArgs',
      scope: 'Scope',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      language: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      queryArgs: 'string',
      scope: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the custom WAF rule group.
   * 
   * @example
   * 1012
   */
  id?: number;
  /**
   * @remarks
   * The name of the WAF rule group.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The page number of the page returned.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  /**
   * @remarks
   * The configurations of the rule.
   */
  rules?: DescribeDcdnWafGroupResponseBodyRules[];
  /**
   * @remarks
   * Indicates whether to enable subscription. Valid values:
   * 
   * *   **on:**
   * *   **off**
   * 
   * @example
   * on
   */
  subscribe?: string;
  /**
   * @remarks
   * The ID of the template.
   * 
   * @example
   * 1012
   */
  templateId?: number;
  /**
   * @remarks
   * The total number of rules that are filtered out.
   * 
   * @example
   * 16
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      rules: 'Rules',
      subscribe: 'Subscribe',
      templateId: 'TemplateId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      rules: { 'type': 'array', 'itemType': DescribeDcdnWafGroupResponseBodyRules },
      subscribe: 'string',
      templateId: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnWafGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnWafGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafGroupsRequest extends $tea.Model {
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   **en** (default): English.
   * *   **zh**: Chinese.
   * 
   * @example
   * zh
   */
  language?: string;
  /**
   * @remarks
   * The number of the page to return. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The query conditions. The value is a string in the JSON format. Format: `QueryArgs={"PolicyIds":"IDs of protection policies","RuleIds":"IDs of the protection rules","RuleNameLike":"Names of the protection rule","DomainNames":"Protected domain names","DefenseScenes":"waf_group","RuleStatus":"on","OrderBy":"GmtModified","Desc":"false"}`
   * 
   * > If you do not specify this parameter, all protection rules are queried.
   * 
   * @example
   * {"RuleIds":"100001,200002"}
   */
  queryArgs?: string;
  static names(): { [key: string]: string } {
    return {
      language: 'Language',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      queryArgs: 'QueryArgs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      language: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      queryArgs: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafGroupsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  /**
   * @remarks
   * The number of WAF rule groups.
   * 
   * @example
   * 16
   */
  totalCount?: number;
  /**
   * @remarks
   * The list of WAF rule groups.
   */
  wafGroups?: DescribeDcdnWafGroupsResponseBodyWafGroups[];
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      wafGroups: 'WafGroups',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      wafGroups: { 'type': 'array', 'itemType': DescribeDcdnWafGroupsResponseBodyWafGroups },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnWafGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnWafGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafLogsRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. You can specify only one domain name in each request.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2017-12-22T08:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The number of the page to return. Valid values: an integer greater than 0.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: **300**. Valid values: **1 to 1000**.
   * 
   * @example
   * 300
   */
  pageSize?: number;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2017-12-21T08:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafLogsResponseBody extends $tea.Model {
  /**
   * @remarks
   * Details about logs returned.
   */
  domainLogDetails?: DescribeDcdnWafLogsResponseBodyDomainLogDetails[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0985A362-C81E-5A56-891D-90226BEECA7C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domainLogDetails: 'DomainLogDetails',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainLogDetails: { 'type': 'array', 'itemType': DescribeDcdnWafLogsResponseBodyDomainLogDetails },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafLogsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnWafLogsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnWafLogsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafPoliciesRequest extends $tea.Model {
  /**
   * @remarks
   * The number of the page to return. Valid values: **1** to **100000**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of protection policies to return on each page. Valid values: an integer from **1** to **500**. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The query conditions. The value is a JSON string. The format is `QueryArgs={"PolicyIds":"The IDs of protection policies","RuleIds":"The IDs of protection rules","PolicyNameLike":"The name of the protection policy","DomainNames":"The protected domain names","PolicyType":"default","DefenseScenes":"waf_group","PolicyStatus":"on","OrderBy":"GmtModified","Desc":"false"}`
   * 
   * > If you do not set this parameter, all protection policies are queried.
   * 
   * @example
   * {"PolicyNameLIike":"test_policy"}
   */
  queryArgs?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      queryArgs: 'QueryArgs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      queryArgs: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafPoliciesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page. Valid values: **1** to **100000**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of protection policies returned per page. Valid values: an integer from **1** to **500**. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The information about protection policies.
   */
  policies?: DescribeDcdnWafPoliciesResponseBodyPolicies[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 153ca2cd-3c01-44be-2e83-64dbc6c88630
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of protection policies.
   * 
   * @example
   * 15
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      policies: 'Policies',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      policies: { 'type': 'array', 'itemType': DescribeDcdnWafPoliciesResponseBodyPolicies },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafPoliciesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnWafPoliciesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnWafPoliciesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafPolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the protection policy. You can specify only one ID in each request.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000001
   */
  policyId?: number;
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafPolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the protection policy.
   */
  policy?: DescribeDcdnWafPolicyResponseBodyPolicy;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 66A98669-CC6E-4F3E-80A6-3014697B11AE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      policy: 'Policy',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policy: DescribeDcdnWafPolicyResponseBodyPolicy,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafPolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnWafPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnWafPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafPolicyDomainsRequest extends $tea.Model {
  /**
   * @remarks
   * The number of the page to return. Valid values: **1** to **100000**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of domain names to return on each page. Valid values: an integer from **1** to **500**. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the protection policy. You can specify only one ID in each request.
   * 
   * This parameter is required.
   * 
   * @example
   * 100001
   */
  policyId?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      policyId: 'PolicyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      policyId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafPolicyDomainsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain names.
   */
  domains?: DescribeDcdnWafPolicyDomainsResponseBodyDomains[];
  /**
   * @remarks
   * The page number of the returned page, which is the same as the PageNumber parameter in request parameters.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of domain names returned per page, which is the same as the PageSize parameter in request parameters.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 153ca2cd-3c01-44be-b480-64dbc6c88630
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of domain names returned.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      domains: 'Domains',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domains: { 'type': 'array', 'itemType': DescribeDcdnWafPolicyDomainsResponseBodyDomains },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafPolicyDomainsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnWafPolicyDomainsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnWafPolicyDomainsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafPolicyValidDomainsRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the Web Application Firewall (WAF) protection policy. Valid values:
   * 
   * *   waf_group: basic web protection
   * *   custom_acl: custom protection
   * *   whitelist: IP address whitelist
   * *   ip_blacklist: IP address blacklist
   * *   region_block: region blacklist
   * *   bot: bot management
   * 
   * This parameter is required.
   * 
   * @example
   * custom_acl
   */
  defenseScene?: string;
  /**
   * @remarks
   * The protected domain name. Fuzzy search is supported.
   * 
   * @example
   * example.com
   */
  domainNameLike?: string;
  /**
   * @remarks
   * The page number of the returned page. Valid values: **1** to **100000**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of domain names to return on each page. Valid values: an integer from **1** to **500**. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      defenseScene: 'DefenseScene',
      domainNameLike: 'DomainNameLike',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defenseScene: 'string',
      domainNameLike: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafPolicyValidDomainsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the protected domain names.
   */
  domains?: DescribeDcdnWafPolicyValidDomainsResponseBodyDomains[];
  /**
   * @remarks
   * The page number of the returned page, which is the same as the PageNumber parameter in request parameters.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of domain names returned per page, which is the same as the PageSize parameter in request parameters.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3C6CCEC4-6B88-4D4A-93E4-D47B3D92C630
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of domain names returned.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      domains: 'Domains',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domains: { 'type': 'array', 'itemType': DescribeDcdnWafPolicyValidDomainsResponseBodyDomains },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafPolicyValidDomainsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnWafPolicyValidDomainsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnWafPolicyValidDomainsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the protection rule. You can specify only one ID in each request.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000001
   */
  ruleId?: number;
  static names(): { [key: string]: string } {
    return {
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 66A98669-CC6E-4F3E-80A6-3014697B11AE
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the protection rule.
   */
  rule?: DescribeDcdnWafRuleResponseBodyRule;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      rule: 'Rule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      rule: DescribeDcdnWafRuleResponseBodyRule,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnWafRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnWafRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The number of the page to return. Valid values: **1** to **100000**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of protection rules to return per page. Valid values: integers from **1** to **500**. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The query conditions. The value needs to be a JSON string in the following format: `QueryArgs={"PolicyIds":"The range of protection policy IDs","RuleIds":"The range of protection rule IDs","RuleNameLike":"The name of the protection rule","DomainNames":"The protected domain names","DefenseScenes":"waf_group","RuleStatus":"on","OrderBy":"GmtModified","Desc":"false"}`.
   * 
   * > If you do not specify this parameter, all protection rules are queried.
   * 
   * @example
   * {"RuleIds":"100001,200002"}
   */
  queryArgs?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      queryArgs: 'QueryArgs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      queryArgs: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page. The value of this parameter is the same as that of the PageNumber parameter in the request.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of protection rules returned per page. The value of this parameter is the same as that of the PageSize parameter in the request.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 66A98669-CC6E-4F3E-80A6-3014697B11AE
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the protection rule.
   */
  rules?: DescribeDcdnWafRulesResponseBodyRules[];
  /**
   * @remarks
   * The total number of protection rules.
   * 
   * @example
   * 121
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      rules: 'Rules',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      rules: { 'type': 'array', 'itemType': DescribeDcdnWafRulesResponseBodyRules },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnWafRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnWafRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafScenesRequest extends $tea.Model {
  /**
   * @remarks
   * The types of the protection policies that you want to query. Separate multiple types with commas (,). Valid values:
   * 
   * *   waf_group: basic web protection
   * *   custom_acl: custom protection
   * *   whitelist: IP address whitelist
   * *   ip_blacklist: IP address blacklist
   * *   region_block: region blacklist
   * *   bot: bot management
   * 
   * > If you do not set this parameter, all types of protection policies are queried.
   * 
   * @example
   * waf_group,custom_acl,whitelist
   */
  defenseScenes?: string;
  static names(): { [key: string]: string } {
    return {
      defenseScenes: 'DefenseScenes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defenseScenes: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafScenesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The types of the protection policies.
   */
  defenseScenes?: DescribeDcdnWafScenesResponseBodyDefenseScenes[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3D7BB13C-DD84-5654-A835-B8E1385DE274
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      defenseScenes: 'DefenseScenes',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defenseScenes: { 'type': 'array', 'itemType': DescribeDcdnWafScenesResponseBodyDefenseScenes },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafScenesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnWafScenesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnWafScenesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafServiceRequest extends $tea.Model {
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafServiceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The edition of WAF.
   * 
   * @example
   * dcdnwaf_afterpay
   */
  edition?: string;
  /**
   * @remarks
   * The status of WAF. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  enabled?: string;
  /**
   * @remarks
   * The time when WAF was enabled.
   * 
   * @example
   * 2021-09-26T16:00:00Z
   */
  openingTime?: string;
  /**
   * @remarks
   * The metering method for requests.
   * 
   * @example
   * dcdn_waf_req
   */
  requestBillingType?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4A95CA90-E0F2-1BF6-99E0-8C1510CAF649
   */
  requestId?: string;
  /**
   * @remarks
   * The metering method for rules. You are charged for the number of SeCUs.
   * 
   * @example
   * dcdn_waf_rule
   */
  ruleBillingType?: string;
  /**
   * @remarks
   * The status of WAF. Valid values:
   * 
   * *   Normal
   * *   WaitForExpire
   * *   Expired
   * *   Released
   * 
   * @example
   * Normal
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      edition: 'Edition',
      enabled: 'Enabled',
      openingTime: 'OpeningTime',
      requestBillingType: 'RequestBillingType',
      requestId: 'RequestId',
      ruleBillingType: 'RuleBillingType',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      edition: 'string',
      enabled: 'string',
      openingTime: 'string',
      requestBillingType: 'string',
      requestId: 'string',
      ruleBillingType: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafServiceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnWafServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnWafServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafSpecInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The version of WAF.
   * 
   * @example
   * dcdnwaf_afterpay
   */
  edition?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 7281593a-f414-42c1-b7ba-2ce65e21cc00
   */
  requestId?: string;
  /**
   * @remarks
   * The supported types of protection policies and the configuration information of protection rules.
   */
  specInfos?: DescribeDcdnWafSpecInfoResponseBodySpecInfos[];
  static names(): { [key: string]: string } {
    return {
      edition: 'Edition',
      requestId: 'RequestId',
      specInfos: 'SpecInfos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      edition: 'string',
      requestId: 'string',
      specInfos: { 'type': 'array', 'itemType': DescribeDcdnWafSpecInfoResponseBodySpecInfos },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafSpecInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnWafSpecInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnWafSpecInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafUsageDataRequest extends $tea.Model {
  /**
   * @remarks
   * The timestamp of the data returned.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * >  The end time must be later than the start time.
   * 
   * @example
   * 2018-10-01T16:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The number of used SeCUs.
   * 
   * @example
   * 300
   */
  interval?: string;
  /**
   * @remarks
   * The WAF information about the accelerated domain name.
   * 
   * @example
   * domain
   */
  splitBy?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2018-09-30T16:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      interval: 'Interval',
      splitBy: 'SplitBy',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      interval: 'string',
      splitBy: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafUsageDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The operation that you want to perform. Set the value to **DescribeDcdnWafUsageData**.
   * 
   * @example
   * 2018-10-01T16:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * Specifies how query results are grouped. By default, this parameter is empty. Valid values:
   * 
   * *   domain: Query results are grouped by accelerated domain name.
   * *   An empty string: Query results are not grouped.
   * 
   * @example
   * CB1A380B-09F0-41BB-802B-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * 2018-09-30T16:00:00Z",
   */
  startTime?: string;
  /**
   * @remarks
   * The number of monitored requests.
   */
  wafUsageData?: DescribeDcdnWafUsageDataResponseBodyWafUsageData;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      requestId: 'RequestId',
      startTime: 'StartTime',
      wafUsageData: 'WafUsageData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      requestId: 'string',
      startTime: 'string',
      wafUsageData: DescribeDcdnWafUsageDataResponseBodyWafUsageData,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafUsageDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnWafUsageDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnWafUsageDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnsecServiceRequest extends $tea.Model {
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnsecServiceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The time when the renewed service takes effect. The time is displayed in UTC.
   * 
   * @example
   * 2021-09-30T16:00:00Z
   */
  changingAffectTime?: string;
  /**
   * @remarks
   * The new metering method for the renewed DCDN. Valid values:
   * 
   * *   **PayByTraffic**: pay by data transfer
   * *   **PayByBandwidth**: pay by bandwidth
   * *   **PayByBandwidth95**: pay by 95th percentile bandwidth
   * *   **PayByBandwidth_monthavg**: pay by monthly average bandwidth
   * *   **PayByBandwidth_month4th**: pay by fourth peak bandwidth per month
   * *   **PayByBandwidth_monthday95avg**: pay by monthly average 95th percentile bandwidth
   * *   **PayByBandwidth_nighthalf95**: pay by 95th percentile bandwidth (50% off during nighttime)
   * 
   * @example
   * PayByBandwidth
   */
  changingChargeType?: string;
  /**
   * @remarks
   * The number of accelerated domain names that use DCDN.
   * 
   * @example
   * 130
   */
  domainNum?: string;
  /**
   * @remarks
   * The service expiration time.
   * 
   * @example
   * 2021-09-26T16:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The metering method for traffic.
   * 
   * @example
   * PayBySecTraffic
   */
  flowType?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * dcdn_dcdnsec_public_cn-123***
   */
  instanceId?: string;
  /**
   * @remarks
   * The current metering method. Valid values:
   * 
   * *   **PayByTraffic**: pay by data transfer
   * *   **PayByBandwidth**: pay by bandwidth
   * *   **PayByBandwidth95**: pay by 95th percentile bandwidth
   * *   **PayByBandwidth_monthavg**: pay by monthly average bandwidth
   * *   **PayByBandwidth_month4th**: pay by fourth peak bandwidth per month
   * *   **PayByBandwidth_monthday95avg**: pay by monthly average 95th percentile bandwidth
   * *   **PayByBandwidth_nighthalf95**: pay by 95th percentile bandwidth (50% off during nighttime)
   * 
   * @example
   * PayByTraffic
   */
  internetChargeType?: string;
  /**
   * @remarks
   * The lock status of DCDN.
   */
  operationLocks?: DescribeDcdnsecServiceResponseBodyOperationLocks;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E20B46E1-9BCD-10E5-AAEF-6D7B737467A1
   */
  requestId?: string;
  /**
   * @remarks
   * The metering method for requests.
   * 
   * @example
   * PayBySecRequest
   */
  requestType?: string;
  /**
   * @remarks
   * The service activation time.
   * 
   * @example
   * 2021-08-26T02:52:08Z
   */
  startTime?: string;
  /**
   * @remarks
   * The version number.
   * 
   * @example
   * enterprise
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      changingAffectTime: 'ChangingAffectTime',
      changingChargeType: 'ChangingChargeType',
      domainNum: 'DomainNum',
      endTime: 'EndTime',
      flowType: 'FlowType',
      instanceId: 'InstanceId',
      internetChargeType: 'InternetChargeType',
      operationLocks: 'OperationLocks',
      requestId: 'RequestId',
      requestType: 'RequestType',
      startTime: 'StartTime',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      changingAffectTime: 'string',
      changingChargeType: 'string',
      domainNum: 'string',
      endTime: 'string',
      flowType: 'string',
      instanceId: 'string',
      internetChargeType: 'string',
      operationLocks: DescribeDcdnsecServiceResponseBodyOperationLocks,
      requestId: 'string',
      requestType: 'string',
      startTime: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnsecServiceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDcdnsecServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDcdnsecServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDdosAllEventListRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. The end time must be later than the start time. The maximum time range is 31 days.
   * 
   * @example
   * 2023-04-25T15:59:59Z
   */
  endTime?: string;
  /**
   * @remarks
   * The type of the DDoS attack event to be queried. Valid values:
   * 
   *  *   **web-cc**: resource exhaustion attacks
   *  *   **cc**: connection flood attacks
   *  *   **traffic**: volumetric attacks
   * 
   * If you do not configure this parameter, DDoS attack events of all types are queried.
   * 
   * @example
   * web-cc
   */
  eventType?: string;
  /**
   * @remarks
   * The page number. Default value: 1. Value range: 1 to 10,000.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: **10**. Valid values: 5, 10, and 20.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-03-27T16:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      eventType: 'EventType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      eventType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDdosAllEventListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of events.
   */
  dataList?: DescribeDdosAllEventListResponseBodyDataList[];
  /**
   * @remarks
   * The number of the page to return. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned on each page. Default value: **10**. Valid values: 5, 10, and 20.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * D73A4243-CFBD-5110-876F-09237E77ECBD
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 20
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      dataList: 'DataList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataList: { 'type': 'array', 'itemType': DescribeDdosAllEventListResponseBodyDataList },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDdosAllEventListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDdosAllEventListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDdosAllEventListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEncryptRoutineUidResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned ciphertext, which contains the Alibaba Cloud account ID, timestamp, and time to live (TTL).
   * 
   * @example
   * XXXXXj20p4UB/xgdOH5LtXXXXXX
   */
  content?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 4DBA68F5-04A9-406B-B1E4-F2CB635E103F
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEncryptRoutineUidResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeEncryptRoutineUidResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeEncryptRoutineUidResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHighlightInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-04-10T02:43:34Z
   */
  endTime?: string;
  /**
   * @remarks
   * The access language. Valid values:
   * 
   * *   **en-US** (default): English.
   * *   **zh-CN**: Chinese.
   * 
   * This parameter is required.
   * 
   * @example
   * en_US
   */
  lang?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-02-19T16:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The ID of the trace.
   * 
   * This parameter is required.
   * 
   * @example
   * 800e749616838513398137319e
   */
  traceId?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      lang: 'Lang',
      startTime: 'StartTime',
      traceId: 'TraceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      lang: 'string',
      startTime: 'string',
      traceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHighlightInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data model of the highlighted data.
   */
  dataModule?: DescribeHighlightInfoResponseBodyDataModule[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeHighlightInfoResponseBodyDataModule },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHighlightInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeHighlightInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeHighlightInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeKvUsageDataRequest extends $tea.Model {
  /**
   * @remarks
   * The request method. If the parameter is empty, data about all methods is returned. Valid values:
   * 
   * *   **get**
   * *   **put**
   * *   **list**
   * *   **delete**
   * 
   * @example
   * get
   */
  accessType?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2022-08-10T23:59:59Z
   */
  endTime?: string;
  /**
   * @remarks
   * The type of the request data. Set the value to **acc**.
   * 
   * This parameter is required.
   * 
   * @example
   * acc
   */
  field?: string;
  /**
   * @remarks
   * The namespace ID. If the parameter is empty, data about all namespaces is returned.
   * 
   * You can specify a maximum number of 30 namespace IDs and separate them with commas (,).
   * 
   * @example
   * 12423131231****
   */
  namespaceId?: string;
  /**
   * @remarks
   * The type of the response data. Valid values:
   * 
   * *   **detail**: detailed data
   * *   **total**: summary data
   * 
   * Default value: **detail**.
   * 
   * @example
   * detail
   */
  responseType?: string;
  /**
   * @remarks
   * The key that is used to group data. Valid values: **type** and **namespace**.
   * 
   * *   **type**: Data is grouped by time. The data in the last 5 minutes is returned.
   * *   **namespace**: Data is grouped by namespace and is not padded with zeros.
   * *   Default value: **type**.
   * 
   * If **ResponseType** is set to **total**, data to return is not grouped by **namespace** but by **type**.
   * 
   * @example
   * type
   */
  splitBy?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * The minimum data granularity is 1 hour. If you do not specify this parameter, the data in the last seven days is returned.
   * 
   * @example
   * 2022-08-10T00:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      accessType: 'AccessType',
      endTime: 'EndTime',
      field: 'Field',
      namespaceId: 'NamespaceId',
      responseType: 'ResponseType',
      splitBy: 'SplitBy',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessType: 'string',
      endTime: 'string',
      field: 'string',
      namespaceId: 'string',
      responseType: 'string',
      splitBy: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeKvUsageDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 2022-11-18T15:59:59Z
   */
  endTime?: string;
  /**
   * @remarks
   * The usage details.
   */
  kvUsageData?: DescribeKvUsageDataResponseBodyKvUsageData[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9732E117-8A37-49FD-A36F-ABBB87556CA7
   */
  requestId?: string;
  /**
   * @remarks
   * The beginning of the time range during which data was queried.
   * 
   * @example
   * 2022-11-06T16:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      kvUsageData: 'KvUsageData',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      kvUsageData: { 'type': 'array', 'itemType': DescribeKvUsageDataResponseBodyKvUsageData },
      requestId: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeKvUsageDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeKvUsageDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeKvUsageDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRDDomainConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The name of the feature. Default value: source_group.
   * 
   * @example
   * source_group
   */
  functionName?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      functionName: 'FunctionName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      functionName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRDDomainConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The configuration of the domain name.
   */
  domainConfigs?: DescribeRDDomainConfigResponseBodyDomainConfigs[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * C80705BF-0F76-41FA-BAD1-5B59296A4E59
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domainConfigs: 'DomainConfigs',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainConfigs: { 'type': 'array', 'itemType': DescribeRDDomainConfigResponseBodyDomainConfigs },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRDDomainConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeRDDomainConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRDDomainConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRDDomainsRequest extends $tea.Model {
  /**
   * @remarks
   * The number of the page to return. Valid values: 1 to 100000.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. The default value is 20. Valid values: an integer between 1 and 500. Default value: 20.
   * 
   * @example
   * 5
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRDDomainsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status information about the accelerated domain name.
   */
  domains?: DescribeRDDomainsResponseBodyDomains;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 5
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * AA75AADB-5E25-4970-B480-EAA1F5658483
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 16
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      domains: 'Domains',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domains: DescribeRDDomainsResponseBodyDomains,
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRDDomainsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeRDDomainsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRDDomainsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRoutineRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRoutineResponseBody extends $tea.Model {
  /**
   * @remarks
   * The metadata of the routine. The following table describes the fields.
   */
  content?: { [key: string]: any };
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4DBA68F5-04A9-406B-B1E4-F2CB635E103F
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRoutineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeRoutineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRoutineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRoutineCanaryEnvsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The canary release environments that are supported.
   * 
   * @example
   * presetCanaryShanghai
   */
  content?: { [key: string]: any };
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CDCD94C0-F7FE-412F-B8F8-7E3C610C78E5
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRoutineCanaryEnvsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeRoutineCanaryEnvsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRoutineCanaryEnvsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRoutineCodeRevisionRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The version of the JavaScript code that you want to query.
   * 
   * This parameter is required.
   * 
   * @example
   * 1611151912787121550
   */
  selectCodeRevision?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      selectCodeRevision: 'SelectCodeRevision',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      selectCodeRevision: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRoutineCodeRevisionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the JavaScript code version.
   */
  content?: { [key: string]: any };
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * D24F0C48-1B27-4C58-8B84-1A0C001A514E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRoutineCodeRevisionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeRoutineCodeRevisionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRoutineCodeRevisionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRoutineRelatedDomainsRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the routine. The name is unique in the same account.
   * 
   * This parameter is required.
   * 
   * @example
   * routine_test
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRoutineRelatedDomainsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The domain names associated with a routine.
   * 
   * @example
   * "Domains": [
   *             "xxx.com",
   *             "yyy.com",
   *             ...
   *         ]
   */
  content?: { [key: string]: any };
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * FC0E34AC-0239-44A7-AB0E-800DE522C8DA
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRoutineRelatedDomainsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeRoutineRelatedDomainsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRoutineRelatedDomainsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRoutineSpecResponseBody extends $tea.Model {
  /**
   * @remarks
   * The specification of the CPU time slice. Valid values: 5 ms, 50 ms, and 100 ms.
   * 
   * @example
   * 5ms, 50ms, 100ms
   */
  content?: { [key: string]: any };
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * AE4E1B80-D5F3-47DB-824A-DA98A21854C8
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRoutineSpecResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeRoutineSpecResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRoutineSpecResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRoutineUserInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The content returned by calling the operation.
   */
  content?: { [key: string]: any };
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 691DEEE5-4BDB-47F3-930E-F57176427717
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRoutineUserInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeRoutineUserInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRoutineUserInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserDcdnIpaStatusRequest extends $tea.Model {
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserDcdnIpaStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the IPA service is activated.
   * 
   * @example
   * true
   */
  enabled?: boolean;
  /**
   * @remarks
   * Indicates whether you have overdue payments.
   * 
   * @example
   * false
   */
  inDebt?: boolean;
  /**
   * @remarks
   * Indicates whether the grace period for your overdue payments expired.
   * 
   * @example
   * false
   */
  inDebtOverdue?: boolean;
  /**
   * @remarks
   * Indicates whether the IPA service is available. The IPA service is available when no payment is overdue.
   * 
   * @example
   * true
   */
  onService?: boolean;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4F51E9C3-728F-4E35-952D-0ED87A06A8A1
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      enabled: 'Enabled',
      inDebt: 'InDebt',
      inDebtOverdue: 'InDebtOverdue',
      onService: 'OnService',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      inDebt: 'boolean',
      inDebtOverdue: 'boolean',
      onService: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserDcdnIpaStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeUserDcdnIpaStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeUserDcdnIpaStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserDcdnStatusRequest extends $tea.Model {
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserDcdnStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the DCDN service is activated.
   * 
   * @example
   * true
   */
  enabled?: boolean;
  /**
   * @remarks
   * Indicates whether your account has overdue payments.
   * 
   * @example
   * false
   */
  inDebt?: boolean;
  /**
   * @remarks
   * Indicates whether the grace period for your overdue payments expired.
   * 
   * @example
   * false
   */
  inDebtOverdue?: boolean;
  /**
   * @remarks
   * Indicates whether the service is available.
   * 
   * @example
   * true
   */
  onService?: boolean;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4F51E9C3-728F-4E35-952D-0ED87A06A8A1
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      enabled: 'Enabled',
      inDebt: 'InDebt',
      inDebtOverdue: 'InDebtOverdue',
      onService: 'OnService',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      inDebt: 'boolean',
      inDebtOverdue: 'boolean',
      onService: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserDcdnStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeUserDcdnStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeUserDcdnStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserErStatusRequest extends $tea.Model {
  ownerId?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserErStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether ER is activated.
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  enabled?: boolean;
  /**
   * @remarks
   * Indicates whether ER has an overdue payment.
   * 
   * *   true
   * *   false
   * 
   * @example
   * false
   */
  inDebt?: boolean;
  /**
   * @remarks
   * Indicates whether an overdue payment of ER has passed the grace period.
   * 
   * *   true
   * *   false
   * 
   * @example
   * false
   */
  inDebtOverdue?: boolean;
  /**
   * @remarks
   * Indicates whether ER is available.
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  onService?: boolean;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4F51E9C3-728F-4E35-952D-0ED87A06A8A1
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      enabled: 'Enabled',
      inDebt: 'InDebt',
      inDebtOverdue: 'InDebtOverdue',
      onService: 'OnService',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      inDebt: 'boolean',
      inDebtOverdue: 'boolean',
      onService: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserErStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeUserErStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeUserErStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserLogserviceStatusRequest extends $tea.Model {
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserLogserviceStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether Log Service is activated.
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  enabled?: boolean;
  /**
   * @remarks
   * Indicates whether your Log Service has overdue payments.
   * 
   * *   true
   * *   false
   * 
   * @example
   * false
   */
  inDebt?: boolean;
  /**
   * @remarks
   * Indicates whether an overdue payment of your Log Service has passed the grace period.
   * 
   * *   true
   * *   false
   * 
   * @example
   * false
   */
  inDebtOverdue?: boolean;
  /**
   * @remarks
   * Indicates whether Log Service is available.
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  onService?: boolean;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 4F51E9C3-728F-4E35-952D-0ED87A06A8A1
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      enabled: 'Enabled',
      inDebt: 'InDebt',
      inDebtOverdue: 'InDebtOverdue',
      onService: 'OnService',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      inDebt: 'boolean',
      inDebtOverdue: 'boolean',
      onService: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserLogserviceStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeUserLogserviceStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeUserLogserviceStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditRoutineConfRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the routine.
   * 
   * @example
   * the description of this routine
   */
  description?: string;
  /**
   * @remarks
   * The configurations of the specified environment.
   * 
   * @example
   * {"staging":{"SpecName":"50ms","AllowedHosts":["test-a.alicdn.com","test-b.alicdn.com"]},"production":{"SpecName":"50ms","AllowedHosts":["test-c.alicdn.com","test-d.alicdn.com"]},"presetCanaryZhejiang":{"SpecName":"100ms","AllowedHosts":["test-e.alicdn.com","test-f.alicdn.com"]},"presetCanaryBeijing":{"SpecName":"5ms","AllowedHosts":["test-g.alicdn.com","test-h.alicdn.com"]},"presetCanaryNotExist":{"SpecName":"5ms","CodeRev":"1622446907645949975","AllowedHosts":["error hosts"]}}
   */
  envConf?: { [key: string]: any };
  /**
   * @remarks
   * The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
   * 
   * This parameter is required.
   * 
   * @example
   * test-slc
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      envConf: 'EnvConf',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      envConf: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditRoutineConfShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the routine.
   * 
   * @example
   * the description of this routine
   */
  description?: string;
  /**
   * @remarks
   * The configurations of the specified environment.
   * 
   * @example
   * {"staging":{"SpecName":"50ms","AllowedHosts":["test-a.alicdn.com","test-b.alicdn.com"]},"production":{"SpecName":"50ms","AllowedHosts":["test-c.alicdn.com","test-d.alicdn.com"]},"presetCanaryZhejiang":{"SpecName":"100ms","AllowedHosts":["test-e.alicdn.com","test-f.alicdn.com"]},"presetCanaryBeijing":{"SpecName":"5ms","AllowedHosts":["test-g.alicdn.com","test-h.alicdn.com"]},"presetCanaryNotExist":{"SpecName":"5ms","CodeRev":"1622446907645949975","AllowedHosts":["error hosts"]}}
   */
  envConfShrink?: string;
  /**
   * @remarks
   * The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
   * 
   * This parameter is required.
   * 
   * @example
   * test-slc
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      envConfShrink: 'EnvConf',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      envConfShrink: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditRoutineConfResponseBody extends $tea.Model {
  /**
   * @remarks
   * The description of the execution errors and the version number of the latest environment configurations.
   */
  content?: { [key: string]: any };
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * BAECB354-6D42-42C1-87DA-C9992EF1E7C8
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditRoutineConfResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EditRoutineConfResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EditRoutineConfResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDcdnKvRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the key that you want to query.
   * 
   * This parameter is required.
   * 
   * @example
   * key1
   */
  key?: string;
  /**
   * @remarks
   * The name of the namespace.
   * 
   * This parameter is required.
   * 
   * @example
   * ns1
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDcdnKvResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * D61E4801-EAFF-4A63-AAE1-FBF6CE1CFD1C
   */
  requestId?: string;
  /**
   * @remarks
   * The value of the key.
   * 
   * @example
   * value1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDcdnKvResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDcdnKvResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDcdnKvResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDcdnKvStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the key that you want to query.
   * 
   * This parameter is required.
   * 
   * @example
   * key1
   */
  key?: string;
  /**
   * @remarks
   * The name of the namespace.
   * 
   * This parameter is required.
   * 
   * @example
   * ns1
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDcdnKvStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * Specifies whether the configured key has taken effect on all points of presence (POPs).
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  complete?: boolean;
  /**
   * @remarks
   * The timeout period of the configured key. The value is an absolute timestamp, such as 2023-09-11T15:39:44+08:00. This parameter is not returned if the key is permanently stored.
   * 
   * @example
   * 2023-09-11T15:39:44+08:00
   */
  expire?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      complete: 'Complete',
      expire: 'Expire',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      complete: 'boolean',
      expire: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDcdnKvStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDcdnKvStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDcdnKvStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDcdnKvRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the namespace.
   * 
   * This parameter is required.
   * 
   * @example
   * ns1
   */
  namespace?: string;
  /**
   * @remarks
   * The number of the page to return. The product of PageNumber and PageSize cannot exceed 50,000.
   * 
   * @example
   * 10
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: 50. Maximum value: 100.
   * 
   * @example
   * 50
   */
  pageSize?: number;
  /**
   * @remarks
   * The prefix to query.
   * 
   * @example
   * prefix-
   */
  prefix?: string;
  static names(): { [key: string]: string } {
    return {
      namespace: 'Namespace',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      prefix: 'Prefix',
    };
  }

  static types(): { [key: string]: any } {
    return {
      namespace: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      prefix: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDcdnKvResponseBody extends $tea.Model {
  /**
   * @remarks
   * The keys obtained in this traversal.
   */
  keys?: ListDcdnKvResponseBodyKeys[];
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 100
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 50
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * D61E4801-EAFF-4A63-AAE1-FBF6CE1CFD1C
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 1024
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      keys: 'Keys',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keys: { 'type': 'array', 'itemType': ListDcdnKvResponseBodyKeys },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDcdnKvResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDcdnKvResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDcdnKvResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDcdnRealTimeDeliveryProjectRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the collected logs. Default value: cdn_log_access_l1. Valid values:
   * 
   * *   **cdn_log_access_l1**: access logs of Dynamic Content Delivery Network (DCDN) points of presence (POPs)
   * *   **cdn_log_origin**: back-to-origin logs
   * *   **cdn_log_er**: EdgeRoutine logs
   * *   By default, this parameter is left empty, and all logs are returned.
   * 
   * @example
   * cdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The domain name. You can specify only one domain name in each request. If this parameter is not specified, all domain names are queried.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The number of the page to return. Valid values: **1** to **100000**. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. The default value is 20.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      domainName: 'DomainName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      domainName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDcdnRealTimeDeliveryProjectResponseBody extends $tea.Model {
  /**
   * @remarks
   * The configuration results of the domain name.
   */
  content?: ListDcdnRealTimeDeliveryProjectResponseBodyContent;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3EACD23C-F49F-4BF7-B9AD-C2CD3BA888C4
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of returned entries.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: ListDcdnRealTimeDeliveryProjectResponseBodyContent,
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDcdnRealTimeDeliveryProjectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDcdnRealTimeDeliveryProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDcdnRealTimeDeliveryProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDCdnDomainSchdmByPropertyRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the accelerated domain for which you want to change the acceleration region. You can specify only one domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The region where the acceleration service is deployed. Valid values:
   * 
   * *   **domestic**: Chinese mainland
   * *   **overseas**: global (excluding mainland China)
   * *   **global**: global
   * 
   * This parameter is required.
   * 
   * @example
   * {"coverage":"overseas"}
   */
  property?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      property: 'Property',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      property: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDCdnDomainSchdmByPropertyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDCdnDomainSchdmByPropertyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyDCdnDomainSchdmByPropertyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyDCdnDomainSchdmByPropertyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDcdnWafGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the custom WAF rule group.
   * 
   * This parameter is required.
   * 
   * @example
   * 30000110
   */
  id?: number;
  /**
   * @remarks
   * The name of the custom WAF rule group.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The incremental modifications of the rules in the custom WAF rule group. The value is a JSON string.
   * 
   * @example
   * {\\"All\\":false,\\"Op\\":\\"del\\",\\"List\\":\\"900109\\"}
   */
  rules?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
      rules: 'Rules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
      rules: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDcdnWafGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 79B78B62-9006-5D6A-9DAB-303E134CD7AA
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDcdnWafGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyDcdnWafGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyDcdnWafGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDcdnWafPolicyRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the protection policy that you want to modify. You can specify only one ID in each request.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000001
   */
  policyId?: number;
  /**
   * @remarks
   * The new name of the protection policy.
   * 
   * > You must specify PolicyName or PolicyStatus.
   * 
   * @example
   * policy_test
   */
  policyName?: string;
  /**
   * @remarks
   * The new status of the protection policy. Valid values:
   * 
   * *   **on**
   * *   **off**
   * 
   * > You must specify PolicyName or PolicyStatus.
   * 
   * @example
   * on
   */
  policyStatus?: string;
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
      policyName: 'PolicyName',
      policyStatus: 'PolicyStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'number',
      policyName: 'string',
      policyStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDcdnWafPolicyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CB1A380B-09F0-41BB-C730-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDcdnWafPolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyDcdnWafPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyDcdnWafPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDcdnWafPolicyDomainsRequest extends $tea.Model {
  /**
   * @remarks
   * The domain names that you want to bind to the protection policy. You can specify up to 50 domain names. Separate multiple domain names with commas (,).
   * 
   * > You can configure either **BindDomains** or **UnbindDomains**.
   * 
   * @example
   * example.com,example2.com
   */
  bindDomains?: string;
  /**
   * @remarks
   * The association method. Valid values:
   * 
   * *   0: replace.
   * *   1: add.
   * *   Default value: 0.
   * 
   * > 
   * 
   * *   This parameter takes effect only when you specify **BindDomains**. If you have associated a domain name indicated by **BindDomains** with the default protection policy, the `Policy.DefaultAndCustom.BindToSameDomain` error is returned.
   * 
   * *   You can only replace accelerated domain names that are bound to the default protection policy.
   * 
   * @example
   * 0
   */
  method?: number;
  /**
   * @remarks
   * The ID of the protection policy. You can specify only one ID in each request.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000001
   */
  policyId?: number;
  /**
   * @remarks
   * The domain names that you want to unbind from the protection policy. You can specify up to 50 domain names. Separate multiple domain names with commas (,).
   * 
   * > You can configure either **BindDomains** or **UnbindDomains**.
   * 
   * @example
   * example3.com
   */
  unbindDomains?: string;
  static names(): { [key: string]: string } {
    return {
      bindDomains: 'BindDomains',
      method: 'Method',
      policyId: 'PolicyId',
      unbindDomains: 'UnbindDomains',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindDomains: 'string',
      method: 'number',
      policyId: 'number',
      unbindDomains: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDcdnWafPolicyDomainsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CB1A380B-09F0-41BB-2B35-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDcdnWafPolicyDomainsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyDcdnWafPolicyDomainsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyDcdnWafPolicyDomainsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDcdnWafRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The new configurations of the protection rule.
   * 
   * > After you modify the configurations of the protection rule, the previous configurations are overwritten.
   * 
   * @example
   * {\\"origin\\":\\"custom\\",\\"conditions\\":[{\\"opValue\\":\\"eq\\",\\"key\\":\\"URL\\",\\"values\\":\\"/example\\"},{\\"opValue\\":\\"eq\\",\\"key\\":\\"Header\\",\\"values\\":\\"3333\\",\\"subKey\\":\\"trt\\"}],\\"actionExternal\\":{},\\"action\\":\\"monitor\\",\\"ccStatus\\":1,\\"ratelimit\\":{\\"target\\":\\"remote_addr\\",\\"interval\\":\\"5\\",\\"threshold\\":\\"2\\",\\"effect\\":\\"rule\\",\\"status\\":{\\"code\\":\\"404\\",\\"count\\":\\"2\\"},\\"ttl\\":\\"1800\\"}}\\"
   */
  ruleConfig?: string;
  /**
   * @remarks
   * The ID of the protection rule. You can specify only one ID in each request.
   * 
   * This parameter is required.
   * 
   * @example
   * 200001
   */
  ruleId?: number;
  /**
   * @remarks
   * The new name of the protection rule.
   * 
   * @example
   * test
   */
  ruleName?: string;
  /**
   * @remarks
   * The new status of the protection rule. Valid values:
   * 
   * *   **on**
   * *   **off**
   * 
   * @example
   * off
   */
  ruleStatus?: string;
  static names(): { [key: string]: string } {
    return {
      ruleConfig: 'RuleConfig',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      ruleStatus: 'RuleStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleConfig: 'string',
      ruleId: 'number',
      ruleName: 'string',
      ruleStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDcdnWafRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CB1A380B-09F0-41BB-3C2B-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyDcdnWafRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyDcdnWafRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyDcdnWafRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenDcdnServiceRequest extends $tea.Model {
  /**
   * @remarks
   * The metering method of DCDN. Valid values:
   * 
   * *   **PayByTraffic**: pay-by-traffic
   * *   **PayByBandwidth**: pay-by-bandwidth
   * 
   * This parameter is required.
   * 
   * @example
   * PayByTraffic
   */
  billType?: string;
  ownerId?: number;
  securityToken?: string;
  /**
   * @remarks
   * The metering method of WebSocket. Valid values:
   * 
   * *   **websockettraffic**: pay-by-data-transfer
   * *   **websocketbps**: pay-by-bandwidth
   * 
   * This parameter is required.
   * 
   * @example
   * websockettraffic
   */
  websocketBillType?: string;
  static names(): { [key: string]: string } {
    return {
      billType: 'BillType',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
      websocketBillType: 'WebsocketBillType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      billType: 'string',
      ownerId: 'number',
      securityToken: 'string',
      websocketBillType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenDcdnServiceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 97C68796-EB7F-4D41-9D5B-12B909D76503
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenDcdnServiceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: OpenDcdnServiceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OpenDcdnServiceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreloadDcdnObjectCachesRequest extends $tea.Model {
  /**
   * @remarks
   * The acceleration region in which you want to prefetch content. If you do not specify a region, the value overseas is used.
   * 
   * *   **domestic**: Chinese mainland
   * *   **overseas**: outside the Chinese mainland
   * 
   * @example
   * domestic
   */
  area?: string;
  /**
   * @remarks
   * Specifies whether to prefetch content to POPs. Valid values:
   * 
   * *   **true**: prefetches content to nodes that include L2 DCDN nodes.
   * *   **false**: prefetches content to L2 POPs or L3 POPs.
   * 
   * @example
   * true
   */
  l2Preload?: boolean;
  /**
   * @remarks
   * The path of the content that you want to prefetch. Separate multiple URLs with line feed characters (\\n) or a pair of carriage return and line feed characters (\\r\\n).
   * 
   * This parameter is required.
   * 
   * @example
   * example.com/examplefile.txt
   */
  objectPath?: string;
  ownerId?: number;
  securityToken?: string;
  /**
   * @remarks
   * The custom header for prefetch in the JSON format.
   * 
   * @example
   * {
   *       "Accept-Encoding": [
   *             "gzip"
   *       ]
   * }
   */
  withHeader?: string;
  static names(): { [key: string]: string } {
    return {
      area: 'Area',
      l2Preload: 'L2Preload',
      objectPath: 'ObjectPath',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
      withHeader: 'WithHeader',
    };
  }

  static types(): { [key: string]: any } {
    return {
      area: 'string',
      l2Preload: 'boolean',
      objectPath: 'string',
      ownerId: 'number',
      securityToken: 'string',
      withHeader: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreloadDcdnObjectCachesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the prefetch task. Multiple IDs are separated by commas (,).
   * 
   * @example
   * 95248880
   */
  preloadTaskId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E5BD4B50-7A02-493A-AE0B-97B9024B4135
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      preloadTaskId: 'PreloadTaskId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      preloadTaskId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreloadDcdnObjectCachesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PreloadDcdnObjectCachesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PreloadDcdnObjectCachesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishDcdnStagingConfigToProductionRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. You can specify only one domain name in each request.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The name of the feature.
   * 
   * This parameter is required.
   * 
   * @example
   * aliauth
   */
  functionName?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      functionName: 'FunctionName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      functionName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishDcdnStagingConfigToProductionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishDcdnStagingConfigToProductionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PublishDcdnStagingConfigToProductionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PublishDcdnStagingConfigToProductionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishRoutineCodeRevisionRequest extends $tea.Model {
  /**
   * @remarks
   * The environment to which you want to publish the code.
   * 
   * > 
   * 
   * *   production: the name of the environment, including the environment name (SpecName) and the domain name whitelist (AllowedHosts).
   * 
   * *   presetCanary: You can add canary release environments based on your business requirements. This parameter is optional.
   * 
   * This parameter is required.
   * 
   * @example
   * ["production","presetCanaryZhejiang"]
   */
  envs?: { [key: string]: any };
  /**
   * @remarks
   * The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The version of the routine code that you want to publish.
   * 
   * This parameter is required.
   * 
   * @example
   * 1620876959997924701
   */
  selectCodeRevision?: string;
  static names(): { [key: string]: string } {
    return {
      envs: 'Envs',
      name: 'Name',
      selectCodeRevision: 'SelectCodeRevision',
    };
  }

  static types(): { [key: string]: any } {
    return {
      envs: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      name: 'string',
      selectCodeRevision: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishRoutineCodeRevisionShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The environment to which you want to publish the code.
   * 
   * > 
   * 
   * *   production: the name of the environment, including the environment name (SpecName) and the domain name whitelist (AllowedHosts).
   * 
   * *   presetCanary: You can add canary release environments based on your business requirements. This parameter is optional.
   * 
   * This parameter is required.
   * 
   * @example
   * ["production","presetCanaryZhejiang"]
   */
  envsShrink?: string;
  /**
   * @remarks
   * The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The version of the routine code that you want to publish.
   * 
   * This parameter is required.
   * 
   * @example
   * 1620876959997924701
   */
  selectCodeRevision?: string;
  static names(): { [key: string]: string } {
    return {
      envsShrink: 'Envs',
      name: 'Name',
      selectCodeRevision: 'SelectCodeRevision',
    };
  }

  static types(): { [key: string]: any } {
    return {
      envsShrink: 'string',
      name: 'string',
      selectCodeRevision: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishRoutineCodeRevisionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The version of the routine code that is published to the specified environment.
   * 
   * @example
   * "CodeRevision": "1620876959997924701"
   */
  content?: { [key: string]: any };
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * A513734D-D17B-411E-864D-XXXX
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishRoutineCodeRevisionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PublishRoutineCodeRevisionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PublishRoutineCodeRevisionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutDcdnKvRequest extends $tea.Model {
  /**
   * @remarks
   * The time when the key expires.Example: "1690081381".
   * 
   * @example
   * 1690081381
   */
  expiration?: number;
  /**
   * @remarks
   * The time when the key expires.Example: "3600".
   * 
   * @example
   * 3600
   */
  expirationTtl?: number;
  /**
   * @remarks
   * The key. The key can be up to 512 characters in length, and cannot contain spaces.
   * 
   * This parameter is required.
   * 
   * @example
   * key1
   */
  key?: string;
  /**
   * @remarks
   * The name of the namespace.
   * 
   * This parameter is required.
   * 
   * @example
   * ns1
   */
  namespace?: string;
  /**
   * @remarks
   * The value of the key. The maximum size is 2 MB (2 x 1000 x 1000 bytes).
   * 
   * This parameter is required.
   * 
   * @example
   * value1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      expiration: 'Expiration',
      expirationTtl: 'ExpirationTtl',
      key: 'Key',
      namespace: 'Namespace',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expiration: 'number',
      expirationTtl: 'number',
      key: 'string',
      namespace: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutDcdnKvResponseBody extends $tea.Model {
  /**
   * @remarks
   * The length of the key.
   * 
   * @example
   * 5
   */
  length?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 96ED3127-EC7A-57C5-AFA6-A689B24B2530
   */
  requestId?: string;
  /**
   * @remarks
   * The value of the key. If the value exceeds 256 characters in length, the first 100 characters and the last 100 characters are retained and other characters are not displayed.
   * 
   * @example
   * value1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      length: 'Length',
      requestId: 'RequestId',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      length: 'number',
      requestId: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutDcdnKvResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PutDcdnKvResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PutDcdnKvResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutDcdnKvNamespaceRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the namespace.
   * 
   * This parameter is required.
   * 
   * @example
   * the first namespace
   */
  description?: string;
  /**
   * @remarks
   * The name of the namespace. The name can contain letters, digits, hyphens (-), and underscores (_).
   * 
   * This parameter is required.
   * 
   * @example
   * ns1
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      namespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutDcdnKvNamespaceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The description of the namespace.
   * 
   * @example
   * the first namespace
   */
  description?: string;
  /**
   * @remarks
   * The name of the namespace.
   * 
   * @example
   * ns1
   */
  namespace?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * 12423131231****
   */
  namespaceId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * D61E4801-EAFF-4A63-AAE1-FBF6CE1CFD1C
   */
  requestId?: string;
  /**
   * @remarks
   * The status of the namespace. Valid values:
   * 
   * *   **online**: normal
   * *   **delete**: pending delete
   * *   **deleting**: being deleted
   * *   **deleted**: deleted
   * 
   * @example
   * online
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      namespace: 'Namespace',
      namespaceId: 'NamespaceId',
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      namespace: 'string',
      namespaceId: 'string',
      requestId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutDcdnKvNamespaceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PutDcdnKvNamespaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PutDcdnKvNamespaceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutDcdnKvWithHighCapacityRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test_key
   */
  key?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * test_namesapce
   */
  namespace?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      namespace: 'Namespace',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      namespace: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutDcdnKvWithHighCapacityResponseBody extends $tea.Model {
  /**
   * @example
   * 4
   */
  length?: number;
  /**
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @example
   * test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      length: 'Length',
      requestId: 'RequestId',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      length: 'number',
      requestId: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutDcdnKvWithHighCapacityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PutDcdnKvWithHighCapacityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PutDcdnKvWithHighCapacityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshDcdnObjectCacheByCacheTagRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * tag1,tag2
   */
  cacheTag?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @example
   * true
   */
  force?: boolean;
  static names(): { [key: string]: string } {
    return {
      cacheTag: 'CacheTag',
      domainName: 'DomainName',
      force: 'Force',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cacheTag: 'string',
      domainName: 'string',
      force: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshDcdnObjectCacheByCacheTagResponseBody extends $tea.Model {
  /**
   * @example
   * 17410889914
   */
  refreshTaskId?: string;
  /**
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      refreshTaskId: 'RefreshTaskId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      refreshTaskId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshDcdnObjectCacheByCacheTagResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RefreshDcdnObjectCacheByCacheTagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RefreshDcdnObjectCacheByCacheTagResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshDcdnObjectCachesRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to refresh resources in a directory if the resources are different from the resources in the same directory in the origin server. Default value: false.
   * 
   * *   **true**: refresh all resources in the directory.
   * *   **false**: refresh the changed resources in the directory.
   * 
   * @example
   * false
   */
  force?: boolean;
  /**
   * @remarks
   * The path of the objects that you want to refresh. Separate multiple URLs with line feed characters (\\n) or a pair of carriage return and line feed characters (\\r\\n).
   * 
   * This parameter is required.
   * 
   * @example
   * example.com/example.txt
   */
  objectPath?: string;
  /**
   * @remarks
   * The refresh type. Valid values:
   * 
   * *   **File** (default): refreshes resources based on URLs.
   * *   **Directory**: refreshes resources based on directories.
   * *   **Regex**: refreshes content based on regular expressions.
   * *   **IgnoreParams**: removes the question mark (`?`) and parameters after `?` in a request URL and refreshes content. After you call this operation with the request URL submitted, the system compares the submitted URL with the URL of the cached resource without specific parameters. If the URLs match, the DCDN POPs refresh the cached resource.
   * 
   * >*   For more information about features of URL refresh and directory refresh, see [Refresh and prefetch resources](https://help.aliyun.com/document_detail/64936.html).
   * >*   If you set ObjectType to Directory, the resources in the directory that you want to refresh are marked as expired. You cannot delete the directory. If clients request resources after the resources on POPs are marked as expired, DCDN checks whether the resources on your origin server are updated with a later version. If a later version exists, DCDN retrieves the resources of the later version and returns the resources to the clients. Otherwise, DCDN retrieves the 304 status code from the origin server.
   * 
   * @example
   * File
   */
  objectType?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      force: 'Force',
      objectPath: 'ObjectPath',
      objectType: 'ObjectType',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      force: 'boolean',
      objectPath: 'string',
      objectType: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshDcdnObjectCachesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the refresh task. Multiple IDs are separated by commas (,).
   * 
   * @example
   * 95248880
   */
  refreshTaskId?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * E5BD4B50-7A02-493A-AE0B-97B9024B4135
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      refreshTaskId: 'RefreshTaskId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      refreshTaskId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshDcdnObjectCachesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RefreshDcdnObjectCachesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RefreshDcdnObjectCachesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshErObjectCachesRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to refresh resources in a directory if the resources requested are different from the resources on the origin server. Default value: false.
   * 
   * *   **true**: refreshes all resources in the directory.
   * *   **false**: refreshes the changed resources in the directory.
   * 
   * @example
   * false
   */
  force?: boolean;
  /**
   * @remarks
   * The domain names that are merged for refreshing. POPs that provide services for the domain names are refreshed.
   * 
   * >  Separate multiple domain names with commas (,).
   * 
   * @example
   * a.test.com,b.test.com
   */
  mergeDomainName?: string;
  /**
   * @remarks
   * The URL that you want to refresh.
   * 
   * > *   Separate URLs with line feeds (\\n or \\r\\n). Each object path can be up to 1,024 characters in length.
   * >*   The URLs in a request must belong to the same domain name.
   * >*   You can refresh up to 1,000 URLs in each request.
   * 
   * This parameter is required.
   * 
   * @example
   * http://example.com/examplefile.txt
   */
  objectPath?: string;
  /**
   * @remarks
   * The refresh type. Valid values:
   * 
   * *   **File** (default): refreshes content based on URLs.
   * *   **Directory**: refreshes content based on directories.
   * *   **Regex**: refreshes content based on regular expressions.
   * *   **IgnoreParams**: removes the question mark (`?`) and parameters after the question mark (`?`) in a request URL and refreshes content. After you call this operation with the request URL submitted, the system compares the submitted URL with the URL of the cached resource without specific parameters. If the URLs match, the points of presence (POPs) refresh the cached resource.
   * 
   * >  If you refresh the files in one or more directories, the resources in the directory that you want to refresh are marked as expired. You cannot delete the directory. If clients request resources on POPs that are marked as expired, Dynamic Content Delivery Network (DCDN) checks whether the resources on your origin server are updated. If resources are updated, DCDN retrieves the latest version of the resources and returns the resources to the clients. Otherwise, the origin server returns the 304 status code.
   * 
   * This parameter is required.
   * 
   * @example
   * File
   */
  objectType?: string;
  /**
   * @remarks
   * The ID of the routine, which is in the format of "Name.Subdomain" and is the unique identifier of a custom routine.
   * 
   * @example
   * test.mysubdomain
   */
  routineId?: string;
  static names(): { [key: string]: string } {
    return {
      force: 'Force',
      mergeDomainName: 'MergeDomainName',
      objectPath: 'ObjectPath',
      objectType: 'ObjectType',
      routineId: 'RoutineId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      force: 'boolean',
      mergeDomainName: 'string',
      objectPath: 'string',
      objectType: 'string',
      routineId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshErObjectCachesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the refresh task. Separate multiple IDs with commas (,).
   * 
   * @example
   * 95248880
   */
  refreshTaskId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 3C6CCEC4-6B88-4D4A-93E4-D47B3D92CF8F
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      refreshTaskId: 'RefreshTaskId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      refreshTaskId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshErObjectCachesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RefreshErObjectCachesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RefreshErObjectCachesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RollbackDcdnStagingConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. You can specify only one domain name in each call.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RollbackDcdnStagingConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RollbackDcdnStagingConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RollbackDcdnStagingConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RollbackDcdnStagingConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDcdnDomainCSRCertificateRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name that is secured by the certificate. The domain name uses HTTPS acceleration.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The content of the certificate. The certificate must match the certificate signing request (CSR) created by calling the [CreateDcdnCertificateSigningRequest](https://help.aliyun.com/document_detail/144478.html) operation. Make sure that the certificate is in PEM format and its content is Base64-encoded and then encoded by encodeURIComponent.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  serverCertificate?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      serverCertificate: 'ServerCertificate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      serverCertificate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDcdnDomainCSRCertificateResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDcdnDomainCSRCertificateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetDcdnDomainCSRCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetDcdnDomainCSRCertificateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDcdnDomainCertificateRequest extends $tea.Model {
  /**
   * @remarks
   * The certificate name.
   * 
   * @example
   * yourCertName
   */
  certName?: string;
  /**
   * @remarks
   * The certificate type.
   * 
   * *   **upload**: a user-uploaded SSL certificate.
   * *   **cas**: a certificate that is acquired through Certificate Management Service.
   * 
   * > If the value of the CertType parameter is **cas**, the **SSLPri** parameter is not required.
   * 
   * @example
   * cas
   */
  certType?: string;
  /**
   * @remarks
   * The accelerated domain name. You can specify only one domain name.
   * 
   * HTTPS acceleration must be enabled for the accelerated domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * Specifies whether to check the certificate name for duplicates. If you set the value to 1, the system does not perform the check and overwrites the information about the existing certificate that uses the same name.
   * 
   * @example
   * 1
   */
  forceSet?: string;
  ownerId?: number;
  /**
   * @remarks
   * The region. Default value: ch-hangzhou.
   * 
   * @example
   * cn-shanghai
   */
  region?: string;
  /**
   * @remarks
   * The private key. This parameter is required only if you enable the SSL certificate.
   * 
   * @example
   * SSLPri
   */
  SSLPri?: string;
  /**
   * @remarks
   * Specifies whether to enable the SSL certificate.
   * 
   * *   **on**
   * *   **off**
   * 
   * This parameter is required.
   * 
   * @example
   * on
   */
  SSLProtocol?: string;
  /**
   * @remarks
   * The certificate content. This parameter is required only if you enable the SSL certificate.
   * 
   * @example
   * SSLPub
   */
  SSLPub?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      certName: 'CertName',
      certType: 'CertType',
      domainName: 'DomainName',
      forceSet: 'ForceSet',
      ownerId: 'OwnerId',
      region: 'Region',
      SSLPri: 'SSLPri',
      SSLProtocol: 'SSLProtocol',
      SSLPub: 'SSLPub',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certName: 'string',
      certType: 'string',
      domainName: 'string',
      forceSet: 'string',
      ownerId: 'number',
      region: 'string',
      SSLPri: 'string',
      SSLProtocol: 'string',
      SSLPub: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDcdnDomainCertificateResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDcdnDomainCertificateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetDcdnDomainCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetDcdnDomainCertificateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDcdnDomainSMCertificateRequest extends $tea.Model {
  /**
   * @remarks
   * The identifier of the certificate. The value is Certificate ID-cn-hangzhou. If the ID of the certificate is 123, CertIdentifier is set to 123-cn-hangzhou.
   * 
   * This parameter is required.
   * 
   * @example
   * 123-cn-hangzhou
   */
  certIdentifier?: string;
  /**
   * @remarks
   * The accelerated domain name for which the SM certificate is configured.
   * 
   * > The domain name must have HTTPS secure acceleration enabled.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  ownerId?: number;
  /**
   * @remarks
   * Specifies whether to enable the SSL certificate. Valid values:
   * 
   * *   **on**
   * *   **off**
   * 
   * This parameter is required.
   * 
   * @example
   * on
   */
  SSLProtocol?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      certIdentifier: 'CertIdentifier',
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      SSLProtocol: 'SSLProtocol',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certIdentifier: 'string',
      domainName: 'string',
      ownerId: 'number',
      SSLProtocol: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDcdnDomainSMCertificateResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C8
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDcdnDomainSMCertificateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetDcdnDomainSMCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetDcdnDomainSMCertificateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDcdnDomainSSLCertificateRequest extends $tea.Model {
  /**
   * @remarks
   * The certificate ID. This parameter is required and valid only when **CertType** is set to **cas**. If you specify this parameter, an existing certificate is used.
   * 
   * @example
   * 8089870
   */
  certId?: number;
  /**
   * @remarks
   * The name of the new certificate. You can specify only one certificate name. This parameter is optional and valid only when **CertType** is set to **upload**.
   * 
   * @example
   * yourCertName
   */
  certName?: string;
  /**
   * @remarks
   * The region of the SSL certificate. This parameter takes effect only when **CertType** is set to **cas**. Default value: **cn-hangzhou**. Valid values: **cn-hangzhou** and **ap-southeast-1**.
   * 
   * @example
   * cn-hangzhou
   */
  certRegion?: string;
  /**
   * @remarks
   * The type of the certificate. Valid values:
   * 
   * *   **upload**: a user-uploaded SSL certificate.
   * *   **cas**: a certificate that is acquired through Certificate Management Service.
   * 
   * @example
   * upload
   */
  certType?: string;
  /**
   * @remarks
   * The domain name that is secured by the SSL certificate.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * Specifies whether the certificate is issued in canary releases. If you set this parameter to **staging**, the certificate is issued in canary releases. If you do not specify this parameter or set this parameter to other values, the certificate is officially issued.
   * 
   * @example
   * staging
   */
  env?: string;
  ownerId?: number;
  /**
   * @remarks
   * The private key. Specify the private key only if you want to enable the SSL certificate.
   * 
   * @example
   * y****
   */
  SSLPri?: string;
  /**
   * @remarks
   * Specifies whether to enable the SSL certificate. Valid values:
   * 
   * *   **on**
   * *   **off**
   * 
   * This parameter is required.
   * 
   * @example
   * off
   */
  SSLProtocol?: string;
  /**
   * @remarks
   * The content of the SSL certificate. Specify the content of the SSL certificate only if you want to enable the SSL certificate.
   * 
   * @example
   * xxx
   */
  SSLPub?: string;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      certId: 'CertId',
      certName: 'CertName',
      certRegion: 'CertRegion',
      certType: 'CertType',
      domainName: 'DomainName',
      env: 'Env',
      ownerId: 'OwnerId',
      SSLPri: 'SSLPri',
      SSLProtocol: 'SSLProtocol',
      SSLPub: 'SSLPub',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certId: 'number',
      certName: 'string',
      certRegion: 'string',
      certType: 'string',
      domainName: 'string',
      env: 'string',
      ownerId: 'number',
      SSLPri: 'string',
      SSLProtocol: 'string',
      SSLPub: 'string',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDcdnDomainSSLCertificateResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * A7C69682-7F88-40DD-A198-10D0309E439D
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDcdnDomainSSLCertificateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetDcdnDomainSSLCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetDcdnDomainSSLCertificateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDcdnDomainStagingConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. Separate multiple accelerated domain names with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The list of features. Format: `[{"functionArgs":[{"argName":"parameter key","argValue":"parameter value"},{"argName":"xx","argValue":"xx"}],"functionName": feature name"}]`
   * 
   * > Separate multiple parameters with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * [{\\"functionArgs\\":[{\\"argName\\":\\"enable\\",\\"argValue\\":\\"on\\",\\"argName\\":\\"pri\\",\\"argValue\\":\\"1\\",\\"argName\\":\\"rule\\",\\"argValue\\":\\"xxx\\"}],\\"functionName\\":\\"edge_function\\"}]
   */
  functions?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      functions: 'Functions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      functions: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDcdnDomainStagingConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDcdnDomainStagingConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetDcdnDomainStagingConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetDcdnDomainStagingConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDcdnFullDomainsBlockIPRequest extends $tea.Model {
  /**
   * @remarks
   * The duration for which IP addresses or CIDR blocks are blocked. Unit: seconds. The value **0** specifies that IP addresses or CIDR blocks are permanently blocked. This parameter is available only if you set **OperationType** to **block**.
   * 
   * @example
   * 3000
   */
  blockInterval?: number;
  /**
   * @remarks
   * The IP addresses that you want to block or unblock. Separate multiple IP addresses with commas (,). You can specify up to 1,000 IP addresses.
   * 
   * This parameter is required.
   * 
   * @example
   * 1.XXX.XXX.1,2.XXX.XXX.2
   */
  IPList?: string;
  /**
   * @remarks
   * The action that you want to perform. Valid values:
   * 
   * *   **block**
   * *   **unblock**
   * 
   * This parameter is required.
   * 
   * @example
   * block
   */
  operationType?: string;
  /**
   * @remarks
   * The type of the blocking duration. This parameter is available only if you set **OperationType** to **block**. Valid values:
   * 
   * *   **cover**: the blocking duration that is specified in the request takes effect.
   * *   **uncover**: the longer one of the blocking duration that is specified in the request and the remaining blocking duration takes effect.
   * *   Default value: cover.
   * 
   * @example
   * cover
   */
  updateType?: string;
  static names(): { [key: string]: string } {
    return {
      blockInterval: 'BlockInterval',
      IPList: 'IPList',
      operationType: 'OperationType',
      updateType: 'UpdateType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockInterval: 'number',
      IPList: 'string',
      operationType: 'string',
      updateType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDcdnFullDomainsBlockIPResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response code.
   * 
   * If the value of Code is not 0, specific required parameters are missing or the parameter format is invalid.
   * 
   * @example
   * 0
   */
  code?: number;
  /**
   * @remarks
   * The response message.
   * 
   * @example
   * OK
   */
  message?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CB1A380B-09F0-41BB-802B-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDcdnFullDomainsBlockIPResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetDcdnFullDomainsBlockIPResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetDcdnFullDomainsBlockIPResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDcdnUserConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The configuration parameters of the feature.
   * 
   * This parameter is required.
   * 
   * @example
   * \\"argId\\":12,\\"argValue\\":\\"on\\"
   */
  configs?: string;
  /**
   * @remarks
   * The ID of the feature.
   * 
   * This parameter is required.
   * 
   * @example
   * 6
   */
  functionId?: number;
  ownerAccount?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      configs: 'Configs',
      functionId: 'FunctionId',
      ownerAccount: 'OwnerAccount',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configs: 'string',
      functionId: 'number',
      ownerAccount: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDcdnUserConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F8AA0364-0FDB-4AD5-AC74-D69FAB8924ED
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDcdnUserConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetDcdnUserConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetDcdnUserConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetRoutineSubdomainRequest extends $tea.Model {
  /**
   * @remarks
   * The parameters of the subdomain.
   * 
   * The parameters are in the following format:
   * 
   *     Subdomains: [
   *         "subdomain-test"
   *     ]
   * 
   * This parameter is required.
   * 
   * @example
   * ["subdomain-test"]
   */
  subdomains?: { [key: string]: any };
  static names(): { [key: string]: string } {
    return {
      subdomains: 'Subdomains',
    };
  }

  static types(): { [key: string]: any } {
    return {
      subdomains: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetRoutineSubdomainShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The parameters of the subdomain.
   * 
   * The parameters are in the following format:
   * 
   *     Subdomains: [
   *         "subdomain-test"
   *     ]
   * 
   * This parameter is required.
   * 
   * @example
   * ["subdomain-test"]
   */
  subdomainsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      subdomainsShrink: 'Subdomains',
    };
  }

  static types(): { [key: string]: any } {
    return {
      subdomainsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetRoutineSubdomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The message returned, such as ""Status": "OK"".
   * 
   * @example
   * "Status": "OK"
   */
  content?: { [key: string]: any };
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetRoutineSubdomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetRoutineSubdomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetRoutineSubdomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartDcdnDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. You can specify only one domain name in each request.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartDcdnDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartDcdnDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StartDcdnDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartDcdnDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartDcdnIpaDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the accelerated domain to be enabled. You can specify only one accelerated domain name at a time.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartDcdnIpaDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartDcdnIpaDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StartDcdnIpaDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartDcdnIpaDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopDcdnDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name that you want to disable. You can specify only one domain name in each request.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopDcdnDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopDcdnDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StopDcdnDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopDcdnDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopDcdnIpaDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the accelerated domain that you want to disable. You can specify only one domain name at a time.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  ownerId?: number;
  securityToken?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
      securityToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopDcdnIpaDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopDcdnIpaDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StopDcdnIpaDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopDcdnIpaDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagDcdnResourcesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the resource. Valid values of N: **1** to **50**.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  resourceId?: string[];
  /**
   * @remarks
   * The type of the resource. Set the value to **DOMAIN**.
   * 
   * This parameter is required.
   * 
   * @example
   * DOMAIN
   */
  resourceType?: string;
  /**
   * @remarks
   * The tags.
   * 
   * This parameter is required.
   */
  tag?: TagDcdnResourcesRequestTag[];
  static names(): { [key: string]: string } {
    return {
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      tag: { 'type': 'array', 'itemType': TagDcdnResourcesRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagDcdnResourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 97C68796-EB7F-4D41-9D5B-12B909D76508
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagDcdnResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: TagDcdnResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: TagDcdnResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagDcdnResourcesRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to delete all tags. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * Default value: **false**
   * 
   * @example
   * false
   */
  all?: boolean;
  /**
   * @remarks
   * The ID of the resource. Valid values of N: **1** to **50**.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  resourceId?: string[];
  /**
   * @remarks
   * The type of the resource. Set the value to **DOMAIN**.
   * 
   * This parameter is required.
   * 
   * @example
   * DOMAIN
   */
  resourceType?: string;
  /**
   * @remarks
   * The key of the tag. Valid values of N: **1** to **20**.
   * 
   * @example
   * env
   */
  tagKey?: string[];
  static names(): { [key: string]: string } {
    return {
      all: 'All',
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      all: 'boolean',
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      tagKey: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagDcdnResourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 97C68796-EB7F-4D41-9D5B-12B909D76508
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagDcdnResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UntagDcdnResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UntagDcdnResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDcdnDeliverTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The method that is used to send operations reports. Operations reports are sent to you only by email. The settings need to be escaped in JSON.
   * 
   * @example
   * {"email":{"subject":"the email subject","to":["username@example.com","username@example.com"]}}
   */
  deliver?: string;
  /**
   * @remarks
   * The ID of the tracking task that you want to update.
   * 
   * This parameter is required.
   * 
   * @example
   * 92
   */
  deliverId?: number;
  /**
   * @remarks
   * The domain names from which the tracking task collects data. Separate domain names with commas (,). If you do not specify a domain name, the task collects data from all domain names that belong to your Alibaba Cloud account.
   * 
   * @example
   * www.example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The name of the tracking task.
   * 
   * @example
   * Domain name report
   */
  name?: string;
  /**
   * @remarks
   * The operations reports that are tracked by the task. The data needs to be escaped in JSON.
   * 
   * @example
   * [{\\\\"reportId\\\\":2,\\\\"conditions\\\\":[{\\\\"field\\\\":\\\\"prov\\\\",\\\\"op\\\\":\\\\"in\\\\",\\\\"value\\\\":[\\\\"Heilongjiang\\\\",\\\\"Beijing\\\\"]}]}]
   */
  reports?: string;
  /**
   * @remarks
   * The parameters that specify the time interval at which the tracking task sends operations reports. The settings need to be escaped in JSON.
   * 
   * @example
   * {"schedName":"the name of the tracking task","description":"the description","crontab":"000\\*\\*?","frequency":"d","status":"enable","effectiveFrom":"2020-09-17T00:00:00Z","effectiveEnd":"2020-11-17T00:00:00Z"}
   */
  schedule?: string;
  static names(): { [key: string]: string } {
    return {
      deliver: 'Deliver',
      deliverId: 'DeliverId',
      domainName: 'DomainName',
      name: 'Name',
      reports: 'Reports',
      schedule: 'Schedule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deliver: 'string',
      deliverId: 'number',
      domainName: 'string',
      name: 'string',
      reports: 'string',
      schedule: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDcdnDeliverTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDcdnDeliverTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateDcdnDeliverTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDcdnDeliverTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDcdnDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name. You can specify only one domain name in each call.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  ownerId?: number;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-xxxxx
   */
  resourceGroupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The information about the addresses of origin servers.
   * 
   * @example
   * [{"content":"10.10.10.10","type":"ipaddr","priority":"20","port":80}]
   */
  sources?: string;
  /**
   * @remarks
   * The top-level domain.
   * 
   * @example
   * yourTopLevelDomain
   */
  topLevelDomain?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      resourceGroupId: 'ResourceGroupId',
      securityToken: 'SecurityToken',
      sources: 'Sources',
      topLevelDomain: 'TopLevelDomain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
      resourceGroupId: 'string',
      securityToken: 'string',
      sources: 'string',
      topLevelDomain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDcdnDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDcdnDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateDcdnDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDcdnDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDcdnIpaDomainRequest extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name that you want to modify. You can specify only one domain name in each request.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  ownerId?: number;
  /**
   * @remarks
   * The resource group ID.
   * 
   * @example
   * rg-acfmyuji4b6r4**
   */
  resourceGroupId?: string;
  securityToken?: string;
  /**
   * @remarks
   * The information about the addresses of the origin server.
   * 
   * @example
   * [{"content":"10.10.10.10","type":"ipaddr","priority":"20","port":80,"weight":"15"}]
   */
  sources?: string;
  /**
   * @remarks
   * The top-level domain name.
   * 
   * @example
   * example.edu
   */
  topLevelDomain?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      ownerId: 'OwnerId',
      resourceGroupId: 'ResourceGroupId',
      securityToken: 'SecurityToken',
      sources: 'Sources',
      topLevelDomain: 'TopLevelDomain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      ownerId: 'number',
      resourceGroupId: 'string',
      securityToken: 'string',
      sources: 'string',
      topLevelDomain: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDcdnIpaDomainResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDcdnIpaDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateDcdnIpaDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDcdnIpaDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDcdnSLSRealtimeLogDeliveryRequest extends $tea.Model {
  /**
   * @remarks
   * The region from which logs are collected.
   * 
   * *   **cn**: Chinese mainland
   * *   **sg**: Singapore
   * *   **in**: India
   * *   **eu**: Europe
   * *   **us**: United States
   * 
   * This parameter is required.
   * 
   * @example
   * cn
   */
  dataCenter?: string;
  /**
   * @remarks
   * The domain names from which logs were collected. You can specify one or more domain names. Separate multiple domain names with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The name of the project.
   * 
   * This parameter is required.
   * 
   * @example
   * example
   */
  projectName?: string;
  /**
   * @remarks
   * The name of the Logstore.
   * 
   * This parameter is required.
   * 
   * @example
   * example-cn
   */
  SLSLogStore?: string;
  /**
   * @remarks
   * The name of the log file.
   * 
   * This parameter is required.
   * 
   * @example
   * example-cn
   */
  SLSProject?: string;
  /**
   * @remarks
   * The region to which logs were delivered.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  SLSRegion?: string;
  /**
   * @remarks
   * The sampling rate.
   * 
   * @example
   * 1.0
   */
  samplingRate?: string;
  static names(): { [key: string]: string } {
    return {
      dataCenter: 'DataCenter',
      domainName: 'DomainName',
      projectName: 'ProjectName',
      SLSLogStore: 'SLSLogStore',
      SLSProject: 'SLSProject',
      SLSRegion: 'SLSRegion',
      samplingRate: 'SamplingRate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataCenter: 'string',
      domainName: 'string',
      projectName: 'string',
      SLSLogStore: 'string',
      SLSProject: 'string',
      SLSRegion: 'string',
      samplingRate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDcdnSLSRealtimeLogDeliveryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The configuration results of the domain name.
   */
  content?: UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContent;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * F32C57AA-7BF8-49AE-A2CC-9F42390F5A19
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContent,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDcdnSLSRealtimeLogDeliveryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateDcdnSLSRealtimeLogDeliveryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDcdnSLSRealtimeLogDeliveryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDcdnSubTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The domain names that you want to include in the operations report. If you do not specify a domain name, all domain names that belong to your Alibaba Cloud account are included.
   * 
   * @example
   * www.example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The end time of the operations report. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2021-06-17T00:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The IDs of the metrics that you want to update. Separate IDs with commas (,). You can call the [DescribeDcdnSubList](https://help.aliyun.com/document_detail/270075.html) operation to query the IDs.
   * 
   * @example
   * 2,4,6
   */
  reportIds?: string;
  /**
   * @remarks
   * The start time of the operations report. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2021-04-17T00:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      endTime: 'EndTime',
      reportIds: 'ReportIds',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      endTime: 'string',
      reportIds: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDcdnSubTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDcdnSubTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateDcdnSubTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDcdnSubTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDcdnUserRealTimeDeliveryFieldRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the collected logs. Default value: cdn_log_access_l1. Valid values:
   * 
   * *   **cdn_log_access_l1**: access logs of L1 Dynamic Route for CDN (DCDN) points of presence (POPs)
   * *   **cdn_log_origin**: back-to-origin logs
   * *   **cdn_log_er**: EdgeRoutine logs
   * 
   * @example
   * cdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The list of fields. Separate multiple fields with commas (,). For more information, see [Fields in a real-time log](https://help.aliyun.com/document_detail/324199.html).
   * 
   * This parameter is required.
   * 
   * @example
   * body_bytes_sent,client_ip,content_type
   */
  fields?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      fields: 'Fields',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      fields: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDcdnUserRealTimeDeliveryFieldResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 3EACD23C-F49F-4BF7-B9AD-C2CD3BA888C4
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDcdnUserRealTimeDeliveryFieldResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateDcdnUserRealTimeDeliveryFieldResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDcdnUserRealTimeDeliveryFieldResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadRoutineCodeRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the code version.
   * 
   * This parameter is required.
   * 
   * @example
   * Hello World
   */
  codeDescription?: string;
  /**
   * @remarks
   * The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      codeDescription: 'CodeDescription',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeDescription: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadRoutineCodeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The content returned, such as the code version number and information about the code upload.
   */
  content?: { [key: string]: any };
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * DFA2027F-86C0-4421-9593-581A7993696C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadRoutineCodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UploadRoutineCodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UploadRoutineCodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadStagingRoutineCodeRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the version.
   * 
   * @example
   * desc
   */
  codeDescription?: string;
  /**
   * @remarks
   * The name of the routine. The name needs to be unique among the routines that belong to the same Alibaba Cloud account.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      codeDescription: 'CodeDescription',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeDescription: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadStagingRoutineCodeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The parameters required by the code.
   */
  content?: { [key: string]: any };
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * DFA2027F-86C0-4421-9593-581A7993696C
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadStagingRoutineCodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UploadStagingRoutineCodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UploadStagingRoutineCodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class VerifyDcdnDomainOwnerRequest extends $tea.Model {
  /**
   * @remarks
   * The domain name of which you want to verify the ownership. You can specify only one domain name in each call.
   * 
   * This parameter is required.
   * 
   * @example
   * **example**.com
   */
  domainName?: string;
  /**
   * @remarks
   * The verification method. Valid values:
   * 
   * *   **dnsCheck**: by DNS record
   * *   **fileCheck**: by verification file
   * 
   * This parameter is required.
   * 
   * @example
   * dnsCheck
   */
  verifyType?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      verifyType: 'VerifyType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      verifyType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class VerifyDcdnDomainOwnerResponseBody extends $tea.Model {
  /**
   * @remarks
   * The verification result.
   * 
   * @example
   * verify_dffeb6610035dcb77b413a59c32cd9**
   */
  content?: string;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 34AB41F1-04A5-496F-8C8D-634BDBE6A9FB
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class VerifyDcdnDomainOwnerResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: VerifyDcdnDomainOwnerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: VerifyDcdnDomainOwnerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddDcdnDomainRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of a tag. Valid values of N: **1 to 20**.
   * 
   * @example
   * env
   */
  key?: string;
  /**
   * @remarks
   * The value of a tag. Valid values of N: **1 to 20**.
   * 
   * @example
   * value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateDcdnWafRulesResponseBodyRuleIds extends $tea.Model {
  ruleId?: string[];
  static names(): { [key: string]: string } {
    return {
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleId: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPutDcdnKvRequestKvList extends $tea.Model {
  expiration?: number;
  expirationTtl?: number;
  /**
   * @remarks
   * This parameter is required.
   */
  key?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      expiration: 'Expiration',
      expirationTtl: 'ExpirationTtl',
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expiration: 'number',
      expirationTtl: 'number',
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetDcdnDomainConfigsResponseBodyDomainConfigListDomainConfigModel extends $tea.Model {
  /**
   * @remarks
   * The ID of the configuration.
   * 
   * @example
   * 123456
   */
  configId?: number;
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * www.example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The name of the feature.
   * 
   * @example
   * set_resp_header
   */
  functionName?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      domainName: 'DomainName',
      functionName: 'FunctionName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      domainName: 'string',
      functionName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchSetDcdnDomainConfigsResponseBodyDomainConfigList extends $tea.Model {
  domainConfigModel?: BatchSetDcdnDomainConfigsResponseBodyDomainConfigListDomainConfigModel[];
  static names(): { [key: string]: string } {
    return {
      domainConfigModel: 'DomainConfigModel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainConfigModel: { 'type': 'array', 'itemType': BatchSetDcdnDomainConfigsResponseBodyDomainConfigListDomainConfigModel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckDcdnProjectExistResponseBodyContent extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the real-time log delivery project exists. Valid values:
   * 
   * *   **false**
   * *   **true**
   * 
   * @example
   * false
   */
  exist?: string;
  static names(): { [key: string]: string } {
    return {
      exist: 'Exist',
    };
  }

  static types(): { [key: string]: any } {
    return {
      exist: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDcdnSLSRealTimeLogDeliveryResponseBodyContentDomains extends $tea.Model {
  /**
   * @remarks
   * The description of the returned result.
   * 
   * @example
   * ok
   */
  desc?: string;
  /**
   * @remarks
   * The domain name from which real-time logs were collected.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The region to which real-time logs were delivered.
   * 
   * @example
   * cn
   */
  region?: string;
  /**
   * @remarks
   * The status of real-time logs.
   * 
   * @example
   * success
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      desc: 'Desc',
      domainName: 'DomainName',
      region: 'Region',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desc: 'string',
      domainName: 'string',
      region: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDcdnSLSRealTimeLogDeliveryResponseBodyContent extends $tea.Model {
  domains?: CreateDcdnSLSRealTimeLogDeliveryResponseBodyContentDomains[];
  static names(): { [key: string]: string } {
    return {
      domains: 'Domains',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domains: { 'type': 'array', 'itemType': CreateDcdnSLSRealTimeLogDeliveryResponseBodyContentDomains },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSlrAndSlsProjectResponseBodySlsInfo extends $tea.Model {
  /**
   * @remarks
   * The endpoint of Log Service.
   * 
   * @example
   * cn-shanghai.log.*.com
   */
  endPoint?: string;
  /**
   * @remarks
   * The Logstore of Log Service.
   * 
   * @example
   * dcdn-edge-trlog
   */
  logStore?: string;
  /**
   * @remarks
   * The project of Log Service.
   * 
   * @example
   * dcdn-edge-rtlog-cn-cfc7****
   */
  project?: string;
  /**
   * @remarks
   * The region where Log Service resides.
   * 
   * @example
   * cn-shanghai
   */
  region?: string;
  static names(): { [key: string]: string } {
    return {
      endPoint: 'EndPoint',
      logStore: 'LogStore',
      project: 'Project',
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endPoint: 'string',
      logStore: 'string',
      project: 'string',
      region: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnAclFieldsResponseBodyContent extends $tea.Model {
  /**
   * @remarks
   * The rules and policies that were configured. The JSON string is decoded.
   * 
   * @example
   * \\"fieldList\\":[{\\"name\\":\\"alert\\",\\"display\\":\\"observe\\",\\"tip\\":\\"mark the request in the log without blocking it\\"},{\\"name\\":\\"bypass\\",\\"display\\":\\"bypass\\",\\"tip\\":\\"bypass security modules\\"}],\\"module\\":[{\\"name\\":\\"cc\\",\\"display\\":\\"Rate Limit\\",\\"tip\\":\\"bypass Rate Limit\\"},{\\"name\\":\\"bot\\",\\"display\\":\\"Bot Traffic Management\\",\\"tip\\":\\"bypass Bot Manager\\"}]
   */
  fields?: string;
  static names(): { [key: string]: string } {
    return {
      fields: 'Fields',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fields: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval extends $tea.Model {
  /**
   * @remarks
   * The inbound bandwidth. Unit: bit/s.
   * 
   * @example
   * 318
   */
  in?: number;
  /**
   * @remarks
   * The outbound bandwidth. Unit: bit/s.
   * 
   * @example
   * 183
   */
  out?: number;
  /**
   * @remarks
   * The timestamp of the returned data.
   * 
   * @example
   * 2018-11-29T20:00:00Z
   */
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      in: 'In',
      out: 'Out',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      in: 'number',
      out: 'number',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval extends $tea.Model {
  /**
   * @remarks
   * The inbound traffic. Unit: bytes.
   * 
   * @example
   * 318
   */
  in?: number;
  /**
   * @remarks
   * The outbound traffic. Unit: bytes.
   * 
   * @example
   * 183
   */
  out?: number;
  /**
   * @remarks
   * The timestamp of the data returned.
   * 
   * @example
   * 2018-11-29T20:00:00Z
   */
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      in: 'In',
      out: 'Out',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      in: 'number',
      out: 'number',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem extends $tea.Model {
  /**
   * @remarks
   * The larger region to which the country or region belongs.
   * 
   * @example
   * Middle East
   */
  continent?: string;
  /**
   * @remarks
   * The abbreviation of the name of the country or region.
   * 
   * @example
   * AE
   */
  countriesAndRegions?: string;
  /**
   * @remarks
   * The name of the country or region.
   * 
   * @example
   * United Arab Emirates
   */
  countriesAndRegionsName?: string;
  static names(): { [key: string]: string } {
    return {
      continent: 'Continent',
      countriesAndRegions: 'CountriesAndRegions',
      countriesAndRegionsName: 'CountriesAndRegionsName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      continent: 'string',
      countriesAndRegions: 'string',
      countriesAndRegionsName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnBlockedRegionsResponseBodyInfoList extends $tea.Model {
  infoItem?: DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem[];
  static names(): { [key: string]: string } {
    return {
      infoItem: 'InfoItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      infoItem: { 'type': 'array', 'itemType': DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert extends $tea.Model {
  /**
   * @remarks
   * The ID of the certificate.
   * 
   * @example
   * 123
   */
  certId?: number;
  /**
   * @remarks
   * The name of the certificate.
   * 
   * @example
   * Certificate 2
   */
  certName?: string;
  /**
   * @remarks
   * The Common Name (CN) attribute of the certificate. In most cases, the CN is a domain name.
   * 
   * @example
   * example.com
   */
  common?: string;
  /**
   * @remarks
   * The fingerprint of the certificate.
   * 
   * @example
   * 0151xxxx
   */
  fingerprint?: string;
  /**
   * @remarks
   * The certificate authority (CA) that issued the certificate.
   * 
   * @example
   * DigiCert
   */
  issuer?: string;
  /**
   * @remarks
   * The timestamp.
   * 
   * @example
   * 1548065550
   */
  lastTime?: number;
  static names(): { [key: string]: string } {
    return {
      certId: 'CertId',
      certName: 'CertName',
      common: 'Common',
      fingerprint: 'Fingerprint',
      issuer: 'Issuer',
      lastTime: 'LastTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certId: 'number',
      certName: 'string',
      common: 'string',
      fingerprint: 'string',
      issuer: 'string',
      lastTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnCertificateListResponseBodyCertificateListModelCertList extends $tea.Model {
  cert?: DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert[];
  static names(): { [key: string]: string } {
    return {
      cert: 'Cert',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cert: { 'type': 'array', 'itemType': DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnCertificateListResponseBodyCertificateListModel extends $tea.Model {
  /**
   * @remarks
   * Details about each certificate.
   */
  certList?: DescribeDcdnCertificateListResponseBodyCertificateListModelCertList;
  /**
   * @remarks
   * The number of certificates.
   * 
   * @example
   * 123
   */
  count?: number;
  static names(): { [key: string]: string } {
    return {
      certList: 'CertList',
      count: 'Count',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certList: DescribeDcdnCertificateListResponseBodyCertificateListModelCertList,
      count: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDdosSpecInfoResponseBodySpecInfosConfigs extends $tea.Model {
  /**
   * @remarks
   * The configuration code of the version rule. Valid values:
   * 
   * *   **total_defense_num**: the total number of mitigation sessions of the version.
   * *   **consume_defense_num**: the number of used mitigation sessions of the version.
   * *   **max_domain_num**: the limit on the number of added domain names.
   * *   **emain_domain_num**: the number of added domain names.
   * *   **defence_package_num**: the total number of purchased additional mitigation sessions.
   * *   **consume_defence_package_num**: the number of used additional mitigation sessions.
   * 
   * @example
   * total_defense_num
   */
  config?: string;
  /**
   * @remarks
   * The configuration expression of the version rule.
   * 
   * @example
   * equal
   */
  expr?: string;
  /**
   * @remarks
   * The value of the configuration expression of the version rule.
   * 
   * @example
   * 1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      expr: 'Expr',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      expr: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDdosSpecInfoResponseBodySpecInfos extends $tea.Model {
  /**
   * @remarks
   * The configurations of the version rule.
   */
  configs?: DescribeDcdnDdosSpecInfoResponseBodySpecInfosConfigs[];
  /**
   * @remarks
   * The version rule. Valid values:
   * 
   * *   **version_defense_num**: the rule for the number of version mitigation sessions
   * *   **domain_num**: the rule for the limit on the number of domain names
   * *   **defence_package_num**: the rule for extra mitigation session plans
   * 
   * @example
   * version_defense_num
   */
  rule?: string;
  static names(): { [key: string]: string } {
    return {
      configs: 'Configs',
      rule: 'Rule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configs: { 'type': 'array', 'itemType': DescribeDcdnDdosSpecInfoResponseBodySpecInfosConfigs },
      rule: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDeletedDomainsResponseBodyDomainsPageData extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The time when the accelerated domain name was modified. The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2015-10-28T11:05:52Z
   */
  gmtModified?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      gmtModified: 'GmtModified',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      gmtModified: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDeletedDomainsResponseBodyDomains extends $tea.Model {
  pageData?: DescribeDcdnDeletedDomainsResponseBodyDomainsPageData[];
  static names(): { [key: string]: string } {
    return {
      pageData: 'PageData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageData: { 'type': 'array', 'itemType': DescribeDcdnDeletedDomainsResponseBodyDomainsPageData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule extends $tea.Model {
  /**
   * @remarks
   * The bandwidth value. Unit: bit/s.
   * 
   * @example
   * 11286
   */
  bps?: number;
  /**
   * @remarks
   * The bandwidth that was consumed to deliver dynamic content over HTTP. Unit: bit/s.
   * 
   * @example
   * 11286111
   */
  dynamicHttpBps?: number;
  /**
   * @remarks
   * The bandwidth that was consumed to deliver dynamic content over HTTPS. Unit: bit/s.
   * 
   * @example
   * 12312
   */
  dynamicHttpsBps?: number;
  /**
   * @remarks
   * The bandwidth that was consumed to deliver static content over HTTP. Unit: bit/s.
   * 
   * @example
   * 123
   */
  staticHttpBps?: number;
  /**
   * @remarks
   * The bandwidth that was consumed to deliver static content over HTTPS. Unit: bit/s.
   * 
   * @example
   * 123
   */
  staticHttpsBps?: number;
  /**
   * @remarks
   * The timestamp of the data returned.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      bps: 'Bps',
      dynamicHttpBps: 'DynamicHttpBps',
      dynamicHttpsBps: 'DynamicHttpsBps',
      staticHttpBps: 'StaticHttpBps',
      staticHttpsBps: 'StaticHttpsBps',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bps: 'number',
      dynamicHttpBps: 'number',
      dynamicHttpsBps: 'number',
      staticHttpBps: 'number',
      staticHttpsBps: 'number',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainBpsDataResponseBodyBpsDataPerInterval extends $tea.Model {
  dataModule?: DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule extends $tea.Model {
  /**
   * @remarks
   * The traffic that is used to deliver dynamic content. Unit: bytes.
   * 
   * @example
   * 200
   */
  dynamicTrafficValue?: string;
  /**
   * @remarks
   * The bandwidth that is used to deliver dynamic content. Unit: bit/s.
   * 
   * @example
   * 0.34
   */
  dynamicValue?: string;
  /**
   * @remarks
   * The traffic that is used to deliver static content. Unit: bytes.
   * 
   * @example
   * 131
   */
  staticTrafficValue?: string;
  /**
   * @remarks
   * The bandwidth that is used to deliver static content. Unit: bit/s.
   * 
   * @example
   * 0.22
   */
  staticValue?: string;
  /**
   * @remarks
   * The timestamp of the data returned.
   * 
   * @example
   * 2015-12-10T21:00:00Z
   */
  timeStamp?: string;
  /**
   * @remarks
   * The total traffic. Unit: bytes.
   * 
   * @example
   * 331
   */
  trafficValue?: string;
  /**
   * @remarks
   * The total bandwidth. Unit: bit/s.
   * 
   * @example
   * 0.56
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      dynamicTrafficValue: 'DynamicTrafficValue',
      dynamicValue: 'DynamicValue',
      staticTrafficValue: 'StaticTrafficValue',
      staticValue: 'StaticValue',
      timeStamp: 'TimeStamp',
      trafficValue: 'TrafficValue',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dynamicTrafficValue: 'string',
      dynamicValue: 'string',
      staticTrafficValue: 'string',
      staticValue: 'string',
      timeStamp: 'string',
      trafficValue: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataInterval extends $tea.Model {
  dataModule?: DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the SSL certificate is obsolete. Valid values:
   * 
   * *   **yes**: The SSL certificate is obsolete.
   * *   **no**: The SSL certificate is working as expected.
   * 
   * @example
   * yes
   */
  certCaIsLegacy?: string;
  /**
   * @remarks
   * The time at which the certificate expires.
   * 
   * @example
   * Nov 29 00:00:00 2016 GMT
   */
  certExpireTime?: string;
  /**
   * @remarks
   * Indicates whether the SSL certificate is expired. Valid values:
   * 
   * *   **yes**: The SSL certificate is expired.
   * *   **no**: The SSL certificate is not expired.
   * 
   * @example
   * yes
   */
  certExpired?: string;
  /**
   * @remarks
   * The time at which the certificate became effective.
   * 
   * @example
   * Nov 29 23:59:59 2017 GMT
   */
  certStartTime?: string;
  /**
   * @remarks
   * The name of the SSL certificate owner.
   * 
   * @example
   * example.aliyundoc.com
   */
  certSubjectCommonName?: string;
  /**
   * @remarks
   * The type of the certificate. Valid values: **RSA**, **DSA**, and **ECDSA**.
   * 
   * @example
   * RSA
   */
  certType?: string;
  /**
   * @remarks
   * The list of domain names that use the certificate.
   * 
   * If one or more domain names are returned, the domain names are matched with the specified certificate. Multiple domain names are separated with commas (,).
   * 
   * @example
   * example.com,example.org
   */
  domainList?: string;
  /**
   * @remarks
   * The domain names (DNS fields) that match the certificate. Multiple domain names are separated with commas (,).
   * 
   * @example
   * *.example.com,example.org
   */
  domainNames?: string;
  /**
   * @remarks
   * The certificate authority (CA) that issued the certificate.
   * 
   * @example
   * C=US, O=Symantec Corporation, OU=Symantec Trust Network, OU=Domain Validated SSL, CN=Symantec Basic DV SSL CA - G1
   */
  issuer?: string;
  static names(): { [key: string]: string } {
    return {
      certCaIsLegacy: 'CertCaIsLegacy',
      certExpireTime: 'CertExpireTime',
      certExpired: 'CertExpired',
      certStartTime: 'CertStartTime',
      certSubjectCommonName: 'CertSubjectCommonName',
      certType: 'CertType',
      domainList: 'DomainList',
      domainNames: 'DomainNames',
      issuer: 'Issuer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certCaIsLegacy: 'string',
      certExpireTime: 'string',
      certExpired: 'string',
      certStartTime: 'string',
      certSubjectCommonName: 'string',
      certType: 'string',
      domainList: 'string',
      domainNames: 'string',
      issuer: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainByCertificateResponseBodyCertInfos extends $tea.Model {
  certInfo?: DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo[];
  static names(): { [key: string]: string } {
    return {
      certInfo: 'CertInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certInfo: { 'type': 'array', 'itemType': DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainCcActivityLogResponseBodyActivityLog extends $tea.Model {
  /**
   * @remarks
   * The action that was triggered.
   * 
   * @example
   * deny
   */
  action?: string;
  /**
   * @remarks
   * The accelerated domain name whose ICP filing status you want to update.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The name of the rule that was triggered.
   * 
   * @example
   * test2
   */
  ruleName?: string;
  /**
   * @remarks
   * The timestamp of the data returned.
   * 
   * @example
   * 2015-12-10T20:00:00Z
   */
  timeStamp?: string;
  /**
   * @remarks
   * The object that triggered the blocking event.
   * 
   * @example
   * IP
   */
  triggerObject?: string;
  /**
   * @remarks
   * The period of time during which rate limiting remains effective.
   * 
   * @example
   * 300
   */
  ttl?: number;
  /**
   * @remarks
   * The value of the trigger for rate limiting.
   * 
   * @example
   * 10.10.10.10
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      domainName: 'DomainName',
      ruleName: 'RuleName',
      timeStamp: 'TimeStamp',
      triggerObject: 'TriggerObject',
      ttl: 'Ttl',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      domainName: 'string',
      ruleName: 'string',
      timeStamp: 'string',
      triggerObject: 'string',
      ttl: 'number',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo extends $tea.Model {
  /**
   * @remarks
   * The domain name that matches the certificate.
   * 
   * @example
   * example.com
   */
  certDomainName?: string;
  /**
   * @remarks
   * The time at which the certificate expires.
   * 
   * @example
   * 2018-06-03T22:03:39Z
   */
  certExpireTime?: string;
  /**
   * @remarks
   * The ID of the certificate.
   * 
   * @example
   * 9002448
   */
  certId?: string;
  /**
   * @remarks
   * The validity period of the certificate. Unit: **months** or **years**.
   * 
   * @example
   * 3 months
   */
  certLife?: string;
  /**
   * @remarks
   * The name of the certificate.
   * 
   * @example
   * cert-example.com
   */
  certName?: string;
  /**
   * @remarks
   * The certificate authority (CA) that issued the certificate.
   * 
   * @example
   * Let\\"s Encrypt
   */
  certOrg?: string;
  /**
   * @remarks
   * The region where the certificate is used.
   * 
   * @example
   * cn-hangzhou
   */
  certRegion?: string;
  /**
   * @remarks
   * The type of the certificate.
   * 
   * *   **cas**: a certificate that is purchased by using Certificates Management Service
   * *   **upload**: a custom certificate that you upload
   * 
   * @example
   * cas
   */
  certType?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The status of HTTPS. Valid values:
   * 
   * *   **on**
   * *   **off**
   * 
   * @example
   * on
   */
  SSLProtocol?: string;
  /**
   * @remarks
   * The public key of the certificate.
   * 
   * @example
   * xxxx
   */
  SSLPub?: string;
  /**
   * @remarks
   * The status of the certificate. Valid values:
   * 
   * *   **success**: The certificate has taken effect.
   * *   **checking**: The system is checking whether the domain name is using Dynamic Route for CDN (DCDN).
   * *   **cname_error**: The domain name is not using DCDN.
   * *   **domain_invalid**: The domain name contains invalid characters.
   * *   **unsupport_wildcard**: The wildcard domain name is not supported.
   * *   **applying**: Certificate application is in progress.
   * *   **get_token_timeout**: The certificate application request has timed out.
   * *   **check_token_timeout**: The verification has timed out.
   * *   **get_cert_timeout**: The request to obtain the certificate has timed out.
   * *   **failed**: The certificate application request failed.
   * 
   * @example
   * success
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      certDomainName: 'CertDomainName',
      certExpireTime: 'CertExpireTime',
      certId: 'CertId',
      certLife: 'CertLife',
      certName: 'CertName',
      certOrg: 'CertOrg',
      certRegion: 'CertRegion',
      certType: 'CertType',
      domainName: 'DomainName',
      SSLProtocol: 'SSLProtocol',
      SSLPub: 'SSLPub',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certDomainName: 'string',
      certExpireTime: 'string',
      certId: 'string',
      certLife: 'string',
      certName: 'string',
      certOrg: 'string',
      certRegion: 'string',
      certType: 'string',
      domainName: 'string',
      SSLProtocol: 'string',
      SSLPub: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainCertificateInfoResponseBodyCertInfos extends $tea.Model {
  certInfo?: DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo[];
  static names(): { [key: string]: string } {
    return {
      certInfo: 'CertInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certInfo: { 'type': 'array', 'itemType': DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainCnameResponseBodyCnameDatasData extends $tea.Model {
  /**
   * @remarks
   * The CNAME assigned to the domain name.
   * 
   * @example
   * *.com
   */
  cname?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * .example.com
   */
  domain?: string;
  /**
   * @remarks
   * The configuration status of the CNAME record. If the operation returns 0 for the parameter, the configuration was successful. Otherwise, the configuration failed.
   * 
   * @example
   * 0
   */
  status?: number;
  static names(): { [key: string]: string } {
    return {
      cname: 'Cname',
      domain: 'Domain',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cname: 'string',
      domain: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainCnameResponseBodyCnameDatas extends $tea.Model {
  data?: DescribeDcdnDomainCnameResponseBodyCnameDatasData[];
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribeDcdnDomainCnameResponseBodyCnameDatasData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg extends $tea.Model {
  /**
   * @remarks
   * The name of the configuration.
   * 
   * @example
   * ttl
   */
  argName?: string;
  /**
   * @remarks
   * The value of the configuration.
   * 
   * @example
   * 13
   */
  argValue?: string;
  static names(): { [key: string]: string } {
    return {
      argName: 'ArgName',
      argValue: 'ArgValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      argName: 'string',
      argValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs extends $tea.Model {
  functionArg?: DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg[];
  static names(): { [key: string]: string } {
    return {
      functionArg: 'FunctionArg',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionArg: { 'type': 'array', 'itemType': DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig extends $tea.Model {
  /**
   * @remarks
   * The ID of the configuration.
   * 
   * @example
   * 5068995
   */
  configId?: string;
  /**
   * @remarks
   * The configurations of the features.
   */
  functionArgs?: DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs;
  /**
   * @remarks
   * The feature name.
   * 
   * @example
   * set_req_host_header
   */
  functionName?: string;
  /**
   * @remarks
   * The ID of the advanced condition configuration.
   * 
   * @example
   * 1234567
   */
  parentId?: string;
  /**
   * @remarks
   * The status of the configuration. Valid values:
   * 
   * *   **success**: successful
   * *   **testing**: testing
   * *   **failed**: The configuration failed.
   * *   **configuring**: The configuration is in progress.
   * 
   * @example
   * success
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      functionArgs: 'FunctionArgs',
      functionName: 'FunctionName',
      parentId: 'ParentId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'string',
      functionArgs: DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs,
      functionName: 'string',
      parentId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainConfigsResponseBodyDomainConfigs extends $tea.Model {
  domainConfig?: DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig[];
  static names(): { [key: string]: string } {
    return {
      domainConfig: 'DomainConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainConfig: { 'type': 'array', 'itemType': DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource extends $tea.Model {
  /**
   * @remarks
   * The address of the origin server.
   * 
   * @example
   * example.org
   */
  content?: string;
  /**
   * @remarks
   * The status.
   * 
   * @example
   * online
   */
  enabled?: string;
  /**
   * @remarks
   * The port over which requests are redirected to the origin server. Ports 443 and 80 are supported.
   * 
   * @example
   * 80
   */
  port?: number;
  /**
   * @remarks
   * The priority.
   * 
   * @example
   * 50
   */
  priority?: string;
  /**
   * @remarks
   * The type of the origin server. Valid values:
   * 
   * *   **ipaddr**: an IP address
   * *   **domain**: an origin domain name
   * *   **oss**: the domain name of an Object Storage Service (OSS) bucket
   * 
   * @example
   * oss
   */
  type?: string;
  /**
   * @remarks
   * The weight of the origin server if multiple origin servers are specified.
   * 
   * @example
   * 20
   */
  weight?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      enabled: 'Enabled',
      port: 'Port',
      priority: 'Priority',
      type: 'Type',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      enabled: 'string',
      port: 'number',
      priority: 'string',
      type: 'string',
      weight: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainDetailResponseBodyDomainDetailSources extends $tea.Model {
  source?: DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource[];
  static names(): { [key: string]: string } {
    return {
      source: 'Source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      source: { 'type': 'array', 'itemType': DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainDetailResponseBodyDomainDetail extends $tea.Model {
  /**
   * @remarks
   * The CNAME that is assigned to the accelerated domain name. You must add the CNAME record to the system of your Domain Name System (DNS) provider to map the accelerated domain name to the CNAME.
   * 
   * @example
   * example.aliyundoc.com
   */
  cname?: string;
  /**
   * @remarks
   * The information about the Internet content provider (ICP) filing of the domain name.
   * 
   * @example
   * Beijing ICP Filing No. 1703xxxx
   */
  description?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The status of the accelerated domain name. Valid values:
   * 
   * *   **online**
   * *   **offline**
   * *   **configuring**
   * *   **configure_failed**
   * *   **checking**
   * *   **check_failed**
   * 
   * @example
   * online
   */
  domainStatus?: string;
  /**
   * @remarks
   * Computing service type. Valid values:
   * 
   * *   **routine**
   * *   **image**
   * *   **cloudFunction**
   * 
   * @example
   * routine
   */
  functionType?: string;
  /**
   * @remarks
   * The time when the domain name was added.
   * 
   * @example
   * 2017-11-27T06:51:26Z
   */
  gmtCreated?: string;
  /**
   * @remarks
   * The time when the domain name was last modified.
   * 
   * @example
   * 2017-11-27T06:51:25Z
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfmyuji4b6r4**
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * Indicates whether the Security Socket Layer (SSL) certificate is enabled. Valid values:
   * 
   * *   **on**: **enabled**
   * *   **off**: **disabled**
   * 
   * @example
   * on
   */
  SSLProtocol?: string;
  /**
   * @remarks
   * The public key of the certificate if HTTPS is enabled.
   * 
   * @example
   * xxx
   */
  SSLPub?: string;
  /**
   * @remarks
   * Acceleration scenario. Valid values:
   * 
   * *   **apiscene**: API acceleration.
   * *   **webservicescene**: website acceleration.
   * *   **staticscene**: video, image, and text acceleration.
   * *   **an empty string**: no acceleration scenario is used.
   * 
   * @example
   * apiscene
   */
  scene?: string;
  /**
   * @remarks
   * The acceleration region. Default value: domestic. Valid values:
   * 
   * *   **domestic**: Chinese mainland
   * *   **overseas**: global (excluding the Chinese mainland)
   * *   **global**: global
   * 
   * @example
   * overseas
   */
  scope?: string;
  /**
   * @remarks
   * The information about the origin server.
   */
  sources?: DescribeDcdnDomainDetailResponseBodyDomainDetailSources;
  static names(): { [key: string]: string } {
    return {
      cname: 'Cname',
      description: 'Description',
      domainName: 'DomainName',
      domainStatus: 'DomainStatus',
      functionType: 'FunctionType',
      gmtCreated: 'GmtCreated',
      gmtModified: 'GmtModified',
      resourceGroupId: 'ResourceGroupId',
      SSLProtocol: 'SSLProtocol',
      SSLPub: 'SSLPub',
      scene: 'Scene',
      scope: 'Scope',
      sources: 'Sources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cname: 'string',
      description: 'string',
      domainName: 'string',
      domainStatus: 'string',
      functionType: 'string',
      gmtCreated: 'string',
      gmtModified: 'string',
      resourceGroupId: 'string',
      SSLProtocol: 'string',
      SSLPub: 'string',
      scene: 'string',
      scope: 'string',
      sources: DescribeDcdnDomainDetailResponseBodyDomainDetailSources,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule extends $tea.Model {
  /**
   * @remarks
   * The byte hit ratio.
   * 
   * @example
   * 0
   */
  byteHitRate?: number;
  /**
   * @remarks
   * The request hit ratio.
   * 
   * @example
   * 0
   */
  reqHitRate?: number;
  /**
   * @remarks
   * The timestamp of the returned data.
   * 
   * @example
   * 2018-03-02T13:00:00Z
   */
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      byteHitRate: 'ByteHitRate',
      reqHitRate: 'ReqHitRate',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      byteHitRate: 'number',
      reqHitRate: 'number',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainHitRateDataResponseBodyHitRatePerInterval extends $tea.Model {
  dataModule?: DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 404
   */
  code?: number;
  /**
   * @remarks
   * The count of each HTTP status code.
   * 
   * @example
   * 1
   */
  count?: number;
  /**
   * @remarks
   * The proportion of the HTTP status code.
   * 
   * @example
   * 33.333333
   */
  proportion?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      count: 'Count',
      proportion: 'Proportion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      count: 'number',
      proportion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerInterval extends $tea.Model {
  httpCodeDataModule?: DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule[];
  static names(): { [key: string]: string } {
    return {
      httpCodeDataModule: 'HttpCodeDataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      httpCodeDataModule: { 'type': 'array', 'itemType': DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule extends $tea.Model {
  /**
   * @remarks
   * The proportions of the HTTP status codes.
   */
  httpCodeDataPerInterval?: DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerInterval;
  /**
   * @remarks
   * The timestamp of the data returned.
   * 
   * @example
   * 2019-03-01T13:00:00Z
   */
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      httpCodeDataPerInterval: 'HttpCodeDataPerInterval',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      httpCodeDataPerInterval: DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerInterval,
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainHttpCodeDataResponseBodyDataPerInterval extends $tea.Model {
  dataModule?: DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule extends $tea.Model {
  /**
   * @remarks
   * The timestamp of the returned data.
   * 
   * @example
   * 2015-12-10T21:00:00Z
   */
  timeStamp?: string;
  /**
   * @remarks
   * The total number of times that HTTP status codes were returned.
   * 
   * @example
   * 110
   */
  totalValue?: string;
  /**
   * @remarks
   * The number of times that the HTTP status code was returned.
   * 
   * @example
   * {"200": 10,"206": 100}
   */
  value?: { [key: string]: any };
  static names(): { [key: string]: string } {
    return {
      timeStamp: 'TimeStamp',
      totalValue: 'TotalValue',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeStamp: 'string',
      totalValue: 'string',
      value: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval extends $tea.Model {
  dataModule?: DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule extends $tea.Model {
  /**
   * @remarks
   * The bandwidth value. Unit: bit/s.
   * 
   * @example
   * 11288111
   */
  ipaBps?: number;
  /**
   * @remarks
   * The timestamp of the data returned.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      ipaBps: 'IpaBps',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipaBps: 'number',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerInterval extends $tea.Model {
  dataModule?: DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerIntervalDataModule extends $tea.Model {
  /**
   * @remarks
   * The number of IPA user connections.
   * 
   * @example
   * 189095
   */
  connections?: number;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example1.com
   */
  domain?: string;
  /**
   * @remarks
   * The timestamp of the data returned.
   * 
   * @example
   * 2022-02-21T15:00:00+08:00
   */
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      connections: 'Connections',
      domain: 'Domain',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connections: 'number',
      domain: 'string',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerInterval extends $tea.Model {
  dataModule?: DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule extends $tea.Model {
  /**
   * @remarks
   * The total amount of network traffic.
   * 
   * @example
   * 423304182
   */
  ipaTraffic?: number;
  /**
   * @remarks
   * The timestamp of the returned data.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      ipaTraffic: 'IpaTraffic',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ipaTraffic: 'number',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerInterval extends $tea.Model {
  dataModule?: DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainIspDataResponseBodyValueIspProportionData extends $tea.Model {
  /**
   * @remarks
   * The average response size. Unit: bytes.
   * 
   * @example
   * 800019.0
   */
  avgObjectSize?: string;
  /**
   * @remarks
   * The average response speed. Unit: byte/ms.
   * 
   * @example
   * 154.3345765545624
   */
  avgResponseRate?: string;
  /**
   * @remarks
   * The average response time. Unit: milliseconds.
   * 
   * @example
   * 5183.666666666667
   */
  avgResponseTime?: string;
  /**
   * @remarks
   * The bandwidth.
   * 
   * @example
   * 380.9614285714286
   */
  bps?: string;
  /**
   * @remarks
   * The proportion of network traffic. For example, a value of 90 indicates that 90% of network traffic was coming from the specified ISP.
   * 
   * @example
   * 0.003544181046236794
   */
  bytesProportion?: string;
  /**
   * @remarks
   * The information about the ISP.
   * 
   * @example
   * China Unicom
   */
  isp?: string;
  /**
   * @remarks
   * The name of the ISP.
   * 
   * @example
   * unicom
   */
  ispEname?: string;
  /**
   * @remarks
   * The proportion of the HTTP status code.
   * 
   * @example
   * 0.01155980271270037
   */
  proportion?: string;
  /**
   * @remarks
   * The number of queries per second (QPS).
   * 
   * @example
   * 5.9523809523809524E-5
   */
  qps?: string;
  /**
   * @remarks
   * The total volume of traffic.
   * 
   * @example
   * 2400057
   */
  totalBytes?: string;
  /**
   * @remarks
   * The total number of requests that are destined for your website.
   * 
   * @example
   * 3
   */
  totalQuery?: string;
  static names(): { [key: string]: string } {
    return {
      avgObjectSize: 'AvgObjectSize',
      avgResponseRate: 'AvgResponseRate',
      avgResponseTime: 'AvgResponseTime',
      bps: 'Bps',
      bytesProportion: 'BytesProportion',
      isp: 'Isp',
      ispEname: 'IspEname',
      proportion: 'Proportion',
      qps: 'Qps',
      totalBytes: 'TotalBytes',
      totalQuery: 'TotalQuery',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgObjectSize: 'string',
      avgResponseRate: 'string',
      avgResponseTime: 'string',
      bps: 'string',
      bytesProportion: 'string',
      isp: 'string',
      ispEname: 'string',
      proportion: 'string',
      qps: 'string',
      totalBytes: 'string',
      totalQuery: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainIspDataResponseBodyValue extends $tea.Model {
  ispProportionData?: DescribeDcdnDomainIspDataResponseBodyValueIspProportionData[];
  static names(): { [key: string]: string } {
    return {
      ispProportionData: 'IspProportionData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ispProportionData: { 'type': 'array', 'itemType': DescribeDcdnDomainIspDataResponseBodyValueIspProportionData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail extends $tea.Model {
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 2021-11-07T18:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The name of the log file.
   * 
   * @example
   * example.com_2021_11_08_010000_020000.gz
   */
  logName?: string;
  /**
   * @remarks
   * The path of the log file.
   * 
   * Take note of the Expires field (expiration timestamp) in the response parameter LogPath. If the log download URL expires, you must obtain it again. For more information, see [LogPath field](https://help.aliyun.com/document_detail/31952.html).
   * 
   * @example
   * example.aliyundoc.com /v1.l1cache/105252530/example.com/2021_11_08/example.com_2021_11_08_010000_020000.gz?Expires=1636963354&OSSAccessKeyId=LTAIviCc6zy8****&Signature=u0V6foRfZniHE8i%2BHUdxGOhZsK****
   */
  logPath?: string;
  /**
   * @remarks
   * The size of the log file. Unit: bytes.
   * 
   * @example
   * 192
   */
  logSize?: number;
  /**
   * @remarks
   * The start of the time range during which data was queried.
   * 
   * @example
   * 2021-11-07T17:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      logName: 'LogName',
      logPath: 'LogPath',
      logSize: 'LogSize',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      logName: 'string',
      logPath: 'string',
      logSize: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos extends $tea.Model {
  logInfoDetail?: DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail[];
  static names(): { [key: string]: string } {
    return {
      logInfoDetail: 'LogInfoDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logInfoDetail: { 'type': 'array', 'itemType': DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageIndex?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 4
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      pageIndex: 'PageIndex',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageIndex: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail extends $tea.Model {
  /**
   * @remarks
   * The total number of entries returned on the current page.
   * 
   * @example
   * 4
   */
  logCount?: number;
  /**
   * @remarks
   * The log information. The log information is indicated by the LogInfoDetail parameter.
   */
  logInfos?: DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos;
  /**
   * @remarks
   * The page information. The page information is indicated by the PageInfoDetail parameter.
   */
  pageInfos?: DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos;
  static names(): { [key: string]: string } {
    return {
      logCount: 'LogCount',
      logInfos: 'LogInfos',
      pageInfos: 'PageInfos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logCount: 'number',
      logInfos: DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos,
      pageInfos: DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainLogResponseBodyDomainLogDetails extends $tea.Model {
  domainLogDetail?: DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail[];
  static names(): { [key: string]: string } {
    return {
      domainLogDetail: 'DomainLogDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainLogDetail: { 'type': 'array', 'itemType': DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail extends $tea.Model {
  endTime?: string;
  logName?: string;
  logPath?: string;
  logSize?: number;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      logName: 'LogName',
      logPath: 'LogPath',
      logSize: 'LogSize',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      logName: 'string',
      logPath: 'string',
      logSize: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailLogInfos extends $tea.Model {
  logInfoDetail?: DescribeDcdnDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail[];
  static names(): { [key: string]: string } {
    return {
      logInfoDetail: 'LogInfoDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logInfoDetail: { 'type': 'array', 'itemType': DescribeDcdnDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailPageInfos extends $tea.Model {
  pageIndex?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      pageIndex: 'PageIndex',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageIndex: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetail extends $tea.Model {
  domainName?: string;
  logCount?: number;
  logInfos?: DescribeDcdnDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailLogInfos;
  pageInfos?: DescribeDcdnDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailPageInfos;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      logCount: 'LogCount',
      logInfos: 'LogInfos',
      pageInfos: 'PageInfos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      logCount: 'number',
      logInfos: DescribeDcdnDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailLogInfos,
      pageInfos: DescribeDcdnDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetailPageInfos,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainLogExTtlResponseBodyDomainLogDetails extends $tea.Model {
  domainLogDetail?: DescribeDcdnDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetail[];
  static names(): { [key: string]: string } {
    return {
      domainLogDetail: 'DomainLogDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainLogDetail: { 'type': 'array', 'itemType': DescribeDcdnDomainLogExTtlResponseBodyDomainLogDetailsDomainLogDetail },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domain?: string;
  /**
   * @remarks
   * The number of requests.
   * 
   * @example
   * 1128
   */
  request?: number;
  /**
   * @remarks
   * The timestamp of the data returned.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  timeStamp?: string;
  /**
   * @remarks
   * The type of the requests. Valid values: StaticHttps, DynamicHttps, DynamicHttp, StaticQuic, and DynamicQuic.
   * 
   * @example
   * DynamicHttp
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      request: 'Request',
      timeStamp: 'TimeStamp',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      request: 'number',
      timeStamp: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerInterval extends $tea.Model {
  requestDataModule?: DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule[];
  static names(): { [key: string]: string } {
    return {
      requestDataModule: 'RequestDataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestDataModule: { 'type': 'array', 'itemType': DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule extends $tea.Model {
  /**
   * @remarks
   * The name of the region.
   * 
   * @example
   * CN
   */
  area?: string;
  /**
   * @remarks
   * The number of bits per second.
   * 
   * @example
   * 11288111.1
   */
  bps?: number;
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domain?: string;
  /**
   * @remarks
   * The timestamp of the data returned.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  timeStamp?: string;
  /**
   * @remarks
   * The type of the network traffic. Valid values: Simple, IPA, and WebSocket.
   * 
   * @example
   * Simple
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      area: 'Area',
      bps: 'Bps',
      domain: 'Domain',
      timeStamp: 'TimeStamp',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      area: 'string',
      bps: 'number',
      domain: 'string',
      timeStamp: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerInterval extends $tea.Model {
  trafficDataModule?: DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule[];
  static names(): { [key: string]: string } {
    return {
      trafficDataModule: 'TrafficDataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      trafficDataModule: { 'type': 'array', 'itemType': DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule extends $tea.Model {
  /**
   * @remarks
   * The bandwidth that was consumed for fetching dynamic content from the origin over HTTP.
   * 
   * @example
   * 100
   */
  dynamicHttpOriginBps?: number;
  /**
   * @remarks
   * The bandwidth that was consumed for fetching dynamic content from the origin over HTTPS.
   * 
   * @example
   * 100
   */
  dynamicHttpsOriginBps?: number;
  /**
   * @remarks
   * The bandwidth that was consumed for fetching content from the origin.
   * 
   * @example
   * 100
   */
  originBps?: number;
  /**
   * @remarks
   * The bandwidth that was consumed for fetching static content from the origin over HTTP.
   * 
   * @example
   * 100
   */
  staticHttpOriginBps?: number;
  /**
   * @remarks
   * The bandwidth that was consumed for fetching static content from the origin over HTTPS.
   * 
   * @example
   * 100
   */
  staticHttpsOriginBps?: number;
  /**
   * @remarks
   * The timestamp of the returned data.
   * 
   * @example
   * 2019-12-10T00:00:00Z
   */
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      dynamicHttpOriginBps: 'DynamicHttpOriginBps',
      dynamicHttpsOriginBps: 'DynamicHttpsOriginBps',
      originBps: 'OriginBps',
      staticHttpOriginBps: 'StaticHttpOriginBps',
      staticHttpsOriginBps: 'StaticHttpsOriginBps',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dynamicHttpOriginBps: 'number',
      dynamicHttpsOriginBps: 'number',
      originBps: 'number',
      staticHttpOriginBps: 'number',
      staticHttpsOriginBps: 'number',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerInterval extends $tea.Model {
  dataModule?: DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule extends $tea.Model {
  /**
   * @remarks
   * The amount of back-to-origin traffic that was consumed to deliver dynamic content over HTTP.
   * 
   * @example
   * 1000
   */
  dynamicHttpOriginTraffic?: number;
  /**
   * @remarks
   * The amount of back-to-origin traffic that was consumed to deliver dynamic content over HTTPS.
   * 
   * @example
   * 500
   */
  dynamicHttpsOriginTraffic?: number;
  /**
   * @remarks
   * The amount of back-to-origin traffic.
   * 
   * @example
   * 100
   */
  originTraffic?: number;
  /**
   * @remarks
   * The amount of back-to-origin traffic that was consumed to deliver static content over HTTP.
   * 
   * @example
   * 0
   */
  staticHttpOriginTraffic?: number;
  /**
   * @remarks
   * The amount of back-to-origin traffic that was consumed to deliver static content over HTTPS.
   * 
   * @example
   * 100
   */
  staticHttpsOriginTraffic?: number;
  /**
   * @remarks
   * The timestamp of the data returned.
   * 
   * @example
   * 2017-12-10T21:00:00Z
   */
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      dynamicHttpOriginTraffic: 'DynamicHttpOriginTraffic',
      dynamicHttpsOriginTraffic: 'DynamicHttpsOriginTraffic',
      originTraffic: 'OriginTraffic',
      staticHttpOriginTraffic: 'StaticHttpOriginTraffic',
      staticHttpsOriginTraffic: 'StaticHttpsOriginTraffic',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dynamicHttpOriginTraffic: 'number',
      dynamicHttpsOriginTraffic: 'number',
      originTraffic: 'number',
      staticHttpOriginTraffic: 'number',
      staticHttpsOriginTraffic: 'number',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerInterval extends $tea.Model {
  dataModule?: DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData extends $tea.Model {
  /**
   * @remarks
   * The timestamp of the data returned.
   * 
   * @example
   * 2015-11-28T03:00:00Z
   */
  timeStamp?: string;
  /**
   * @remarks
   * The number of PVs.
   * 
   * @example
   * 9292
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      timeStamp: 'TimeStamp',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeStamp: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainPvDataResponseBodyPvDataInterval extends $tea.Model {
  usageData?: DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData[];
  static names(): { [key: string]: string } {
    return {
      usageData: 'UsageData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      usageData: { 'type': 'array', 'itemType': DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule extends $tea.Model {
  /**
   * @remarks
   * The total number of requests.
   * 
   * @example
   * 100
   */
  acc?: number;
  /**
   * @remarks
   * The number of requests for dynamic content delivery over HTTP.
   * 
   * @example
   * 0
   */
  dynamicHttpAcc?: number;
  /**
   * @remarks
   * The QPS for dynamic content delivery over HTTP.
   * 
   * @example
   * 0
   */
  dynamicHttpQps?: number;
  /**
   * @remarks
   * The number of requests for dynamic content delivery over HTTPS.
   * 
   * @example
   * 0
   */
  dynamicHttpsAcc?: number;
  /**
   * @remarks
   * The QPS for dynamic content delivery over HTTPS.
   * 
   * @example
   * 0
   */
  dynamicHttpsQps?: number;
  /**
   * @remarks
   * The total QPS.
   * 
   * @example
   * 0.56
   */
  qps?: number;
  /**
   * @remarks
   * The number of requests for static content delivery over HTTP.
   * 
   * @example
   * 0
   */
  staticHttpAcc?: number;
  /**
   * @remarks
   * The QPS for static content delivery over HTTP.
   * 
   * @example
   * 0
   */
  staticHttpQps?: number;
  /**
   * @remarks
   * The number of requests for static content delivery over HTTPS.
   * 
   * @example
   * 0
   */
  staticHttpsAcc?: number;
  /**
   * @remarks
   * The QPS for static content delivery over HTTPS.
   * 
   * @example
   * 0
   */
  staticHttpsQps?: number;
  /**
   * @remarks
   * The timestamp of the returned data.
   * 
   * @example
   * 2017-12-10T21:00:00Z
   */
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      acc: 'Acc',
      dynamicHttpAcc: 'DynamicHttpAcc',
      dynamicHttpQps: 'DynamicHttpQps',
      dynamicHttpsAcc: 'DynamicHttpsAcc',
      dynamicHttpsQps: 'DynamicHttpsQps',
      qps: 'Qps',
      staticHttpAcc: 'StaticHttpAcc',
      staticHttpQps: 'StaticHttpQps',
      staticHttpsAcc: 'StaticHttpsAcc',
      staticHttpsQps: 'StaticHttpsQps',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acc: 'number',
      dynamicHttpAcc: 'number',
      dynamicHttpQps: 'number',
      dynamicHttpsAcc: 'number',
      dynamicHttpsQps: 'number',
      qps: 'number',
      staticHttpAcc: 'number',
      staticHttpQps: 'number',
      staticHttpsAcc: 'number',
      staticHttpsQps: 'number',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainQpsDataResponseBodyQpsDataPerInterval extends $tea.Model {
  dataModule?: DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule extends $tea.Model {
  /**
   * @remarks
   * The number of requests in the Chinese mainland.
   * 
   * @example
   * 12
   */
  accDomesticValue?: string;
  /**
   * @remarks
   * The number of requests outside the Chinese mainland.
   * 
   * @example
   * 44
   */
  accOverseasValue?: string;
  /**
   * @remarks
   * The total number of requests.
   * 
   * @example
   * 56
   */
  accValue?: string;
  /**
   * @remarks
   * The number of queries per second in the Chinese mainland.
   * 
   * @example
   * 0.12
   */
  domesticValue?: string;
  /**
   * @remarks
   * The number of queries per second outside the Chinese mainland.
   * 
   * @example
   * 0.44
   */
  overseasValue?: string;
  /**
   * @remarks
   * The timestamp of the returned data.
   * 
   * @example
   * 2015-12-10T21:00:00Z
   */
  timeStamp?: string;
  /**
   * @remarks
   * The total number of queries per second.
   * 
   * @example
   * 0.56
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      accDomesticValue: 'AccDomesticValue',
      accOverseasValue: 'AccOverseasValue',
      accValue: 'AccValue',
      domesticValue: 'DomesticValue',
      overseasValue: 'OverseasValue',
      timeStamp: 'TimeStamp',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accDomesticValue: 'string',
      accOverseasValue: 'string',
      accValue: 'string',
      domesticValue: 'string',
      overseasValue: 'string',
      timeStamp: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataInterval extends $tea.Model {
  dataModule?: DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel extends $tea.Model {
  /**
   * @remarks
   * The bandwidth. Unit: bit/s.
   * 
   * @example
   * 16710625.733333332
   */
  bps?: number;
  /**
   * @remarks
   * The timestamp of the data returned. The time follows the ISO 8601 standard. The time is displayed in UTC.
   * 
   * @example
   * 2018-01-02T11:05:00Z
   */
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      bps: 'Bps',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bps: 'number',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeBpsDataResponseBodyData extends $tea.Model {
  bpsModel?: DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel[];
  static names(): { [key: string]: string } {
    return {
      bpsModel: 'BpsModel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bpsModel: { 'type': 'array', 'itemType': DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel extends $tea.Model {
  /**
   * @remarks
   * The byte hit ratio.
   * 
   * @example
   * 0.8956940476262277
   */
  byteHitRate?: number;
  /**
   * @remarks
   * The timestamp of the data returned. The time follows the ISO 8601 standard. The time is displayed in UTC.
   * 
   * @example
   * 2016-10-20T04:00:00Z
   */
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      byteHitRate: 'ByteHitRate',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      byteHitRate: 'number',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyData extends $tea.Model {
  byteHitRateDataModel?: DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel[];
  static names(): { [key: string]: string } {
    return {
      byteHitRateDataModel: 'ByteHitRateDataModel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      byteHitRateDataModel: { 'type': 'array', 'itemType': DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The count of each HTTP status code.
   * 
   * @example
   * 1
   */
  count?: string;
  /**
   * @remarks
   * The proportion of the HTTP status code.
   * 
   * @example
   * 0.01155980271270037
   */
  proportion?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      count: 'Count',
      proportion: 'Proportion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      count: 'string',
      proportion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue extends $tea.Model {
  realTimeCodeProportionData?: DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData[];
  static names(): { [key: string]: string } {
    return {
      realTimeCodeProportionData: 'RealTimeCodeProportionData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      realTimeCodeProportionData: { 'type': 'array', 'itemType': DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData extends $tea.Model {
  /**
   * @remarks
   * The timestamp of the returned data.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  timeStamp?: string;
  /**
   * @remarks
   * The information about the HTTP status code returned.
   */
  value?: DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue;
  static names(): { [key: string]: string } {
    return {
      timeStamp: 'TimeStamp',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeStamp: 'string',
      value: DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData extends $tea.Model {
  usageData?: DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData[];
  static names(): { [key: string]: string } {
    return {
      usageData: 'UsageData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      usageData: { 'type': 'array', 'itemType': DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel extends $tea.Model {
  /**
   * @remarks
   * The number of queries per second (QPS).
   * 
   * @example
   * 1851.25
   */
  qps?: number;
  /**
   * @remarks
   * The timestamp of the data returned. The time follows the ISO 8601 standard. The time is displayed in UTC.
   * 
   * @example
   * 2018-01-02T11:26:00Z
   */
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      qps: 'Qps',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      qps: 'number',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeQpsDataResponseBodyData extends $tea.Model {
  qpsModel?: DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel[];
  static names(): { [key: string]: string } {
    return {
      qpsModel: 'QpsModel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      qpsModel: { 'type': 'array', 'itemType': DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel extends $tea.Model {
  /**
   * @remarks
   * The request hit ratio.
   * 
   * @example
   * 0.8956940476262277
   */
  reqHitRate?: number;
  /**
   * @remarks
   * The timestamp of the data returned. The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2016-10-20T04:00:00Z
   */
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      reqHitRate: 'ReqHitRate',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      reqHitRate: 'number',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyData extends $tea.Model {
  reqHitRateDataModel?: DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel[];
  static names(): { [key: string]: string } {
    return {
      reqHitRateDataModel: 'ReqHitRateDataModel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      reqHitRateDataModel: { 'type': 'array', 'itemType': DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule extends $tea.Model {
  /**
   * @remarks
   * The timestamp of the data returned.
   * 
   * @example
   * 2015-12-10T20:01:00Z
   */
  timeStamp?: string;
  /**
   * @remarks
   * The bandwidth value.
   * 
   * @example
   * 0
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      timeStamp: 'TimeStamp',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeStamp: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval extends $tea.Model {
  dataModule?: DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  code?: string;
  /**
   * @remarks
   * The number of HTTP status codes.
   * 
   * @example
   * 2
   */
  count?: string;
  /**
   * @remarks
   * The proportion of the HTTP status code.
   * 
   * @example
   * 66.046511627907
   */
  proportion?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      count: 'Count',
      proportion: 'Proportion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      count: 'string',
      proportion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue extends $tea.Model {
  realTimeSrcCodeProportionData?: DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData[];
  static names(): { [key: string]: string } {
    return {
      realTimeSrcCodeProportionData: 'RealTimeSrcCodeProportionData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      realTimeSrcCodeProportionData: { 'type': 'array', 'itemType': DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData extends $tea.Model {
  /**
   * @remarks
   * The timestamp of the returned data.
   * 
   * @example
   * 2019-11-30T05:40:00Z
   */
  timeStamp?: string;
  /**
   * @remarks
   * The proportions of the HTTP status codes.
   */
  value?: DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue;
  static names(): { [key: string]: string } {
    return {
      timeStamp: 'TimeStamp',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeStamp: 'string',
      value: DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData extends $tea.Model {
  usageData?: DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData[];
  static names(): { [key: string]: string } {
    return {
      usageData: 'UsageData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      usageData: { 'type': 'array', 'itemType': DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule extends $tea.Model {
  /**
   * @remarks
   * The timestamp of the returned data.
   * 
   * @example
   * 2015-12-10T20:00:00Z
   */
  timeStamp?: string;
  /**
   * @remarks
   * The traffic value at each time interval.
   * 
   * @example
   * 0
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      timeStamp: 'TimeStamp',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeStamp: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval extends $tea.Model {
  dataModule?: DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule extends $tea.Model {
  /**
   * @remarks
   * The timestamp of the data returned.
   * 
   * @example
   * 2015-12-10T20:00:00Z
   */
  timeStamp?: string;
  /**
   * @remarks
   * The traffic value at each time interval.
   * 
   * > The network traffic is measured in bytes.
   * 
   * @example
   * 0
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      timeStamp: 'TimeStamp',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeStamp: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval extends $tea.Model {
  dataModule?: DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData extends $tea.Model {
  /**
   * @remarks
   * The average response size. Unit: bytes.
   * 
   * @example
   * 0
   */
  avgObjectSize?: string;
  /**
   * @remarks
   * The average response speed. Unit: byte/s.
   * 
   * @example
   * 0
   */
  avgResponseRate?: string;
  /**
   * @remarks
   * The average response time. Unit: milliseconds.
   * 
   * @example
   * 0
   */
  avgResponseTime?: string;
  /**
   * @remarks
   * The bandwidth.
   * 
   * @example
   * 0
   */
  bps?: string;
  /**
   * @remarks
   * The proportion of network traffic. For example, a value of 90 indicates that 90% of network traffic was coming from the specified ISP.
   * 
   * @example
   * 0.003544181046236794
   */
  bytesProportion?: string;
  /**
   * @remarks
   * The proportion of requests from the specified region based on the total number of requests in percentile. For example, a value of 90 indicates that 90% of the requests were coming from the specified region.
   * 
   * @example
   * 0
   */
  proportion?: string;
  /**
   * @remarks
   * The number of queries per second (QPS).
   * 
   * @example
   * 0
   */
  qps?: string;
  /**
   * @remarks
   * The information of the regions.
   * 
   * @example
   * Chongqing
   */
  region?: string;
  /**
   * @remarks
   * The name of the region.
   * 
   * @example
   * chongqing
   */
  regionEname?: string;
  /**
   * @remarks
   * The total amount of network traffic.
   * 
   * @example
   * 0
   */
  totalBytes?: string;
  /**
   * @remarks
   * The total number of requests that are destined for your website.
   * 
   * @example
   * 0
   */
  totalQuery?: string;
  static names(): { [key: string]: string } {
    return {
      avgObjectSize: 'AvgObjectSize',
      avgResponseRate: 'AvgResponseRate',
      avgResponseTime: 'AvgResponseTime',
      bps: 'Bps',
      bytesProportion: 'BytesProportion',
      proportion: 'Proportion',
      qps: 'Qps',
      region: 'Region',
      regionEname: 'RegionEname',
      totalBytes: 'TotalBytes',
      totalQuery: 'TotalQuery',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgObjectSize: 'string',
      avgResponseRate: 'string',
      avgResponseTime: 'string',
      bps: 'string',
      bytesProportion: 'string',
      proportion: 'string',
      qps: 'string',
      region: 'string',
      regionEname: 'string',
      totalBytes: 'string',
      totalQuery: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainRegionDataResponseBodyValue extends $tea.Model {
  regionProportionData?: DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData[];
  static names(): { [key: string]: string } {
    return {
      regionProportionData: 'RegionProportionData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionProportionData: { 'type': 'array', 'itemType': DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs extends $tea.Model {
  /**
   * @remarks
   * The name of the configuration.
   * 
   * @example
   * auth_type
   */
  argName?: string;
  /**
   * @remarks
   * The value of the configuration.
   * 
   * @example
   * req_auth
   */
  argValue?: string;
  static names(): { [key: string]: string } {
    return {
      argName: 'ArgName',
      argValue: 'ArgValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      argName: 'string',
      argValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs extends $tea.Model {
  /**
   * @remarks
   * The ID of the configuration.
   * 
   * @example
   * 6295
   */
  configId?: string;
  /**
   * @remarks
   * The following table describes the features.
   */
  functionArgs?: DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs[];
  /**
   * @remarks
   * The name of the feature.
   * 
   * @example
   * aliauth
   */
  functionName?: string;
  /**
   * @remarks
   * The status. Valid values:
   * 
   * *   success: The configuration is successful.
   * *   testing: The configuration is under testing.
   * *   failed: The task failed.
   * *   configuring: The feature is being configured.
   * 
   * @example
   * success
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      functionArgs: 'FunctionArgs',
      functionName: 'FunctionName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'string',
      functionArgs: { 'type': 'array', 'itemType': DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs },
      functionName: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList extends $tea.Model {
  /**
   * @remarks
   * The amount of network traffic. (Unit: bytes)
   * 
   * @example
   * 460486880
   */
  flow?: string;
  /**
   * @remarks
   * The proportion of network traffic consumed to access the URL.
   * 
   * @example
   * 0.35
   */
  flowProportion?: number;
  /**
   * @remarks
   * The complete referenced URL.
   * 
   * @example
   * 192.168.0.1
   */
  referDetail?: string;
  /**
   * @remarks
   * The number of visits.
   * 
   * @example
   * 229567
   */
  visitData?: string;
  /**
   * @remarks
   * The proportion of visits to the URL.
   * 
   * @example
   * 0.35
   */
  visitProportion?: number;
  static names(): { [key: string]: string } {
    return {
      flow: 'Flow',
      flowProportion: 'FlowProportion',
      referDetail: 'ReferDetail',
      visitData: 'VisitData',
      visitProportion: 'VisitProportion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flow: 'string',
      flowProportion: 'number',
      referDetail: 'string',
      visitData: 'string',
      visitProportion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainTopReferVisitResponseBodyTopReferList extends $tea.Model {
  referList?: DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList[];
  static names(): { [key: string]: string } {
    return {
      referList: 'ReferList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      referList: { 'type': 'array', 'itemType': DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList extends $tea.Model {
  /**
   * @remarks
   * The amount of network traffic. (Unit: bytes)
   * 
   * @example
   * 460486880
   */
  flow?: string;
  /**
   * @remarks
   * The proportion of network traffic consumed to access the URL.
   * 
   * @example
   * 0.35
   */
  flowProportion?: number;
  /**
   * @remarks
   * The complete URL.
   * 
   * @example
   * http://example.com/nn_live/nn_x64/a0.m3u8
   */
  urlDetail?: string;
  /**
   * @remarks
   * The number of visits.
   * 
   * @example
   * 161673
   */
  visitData?: string;
  /**
   * @remarks
   * The proportion of visits.
   * 
   * @example
   * 0.35
   */
  visitProportion?: number;
  static names(): { [key: string]: string } {
    return {
      flow: 'Flow',
      flowProportion: 'FlowProportion',
      urlDetail: 'UrlDetail',
      visitData: 'VisitData',
      visitProportion: 'VisitProportion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flow: 'string',
      flowProportion: 'number',
      urlDetail: 'string',
      visitData: 'string',
      visitProportion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlList extends $tea.Model {
  urlList?: DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList[];
  static names(): { [key: string]: string } {
    return {
      urlList: 'UrlList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      urlList: { 'type': 'array', 'itemType': DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList extends $tea.Model {
  /**
   * @remarks
   * The amount of network traffic. (Unit: bytes)
   * 
   * @example
   * 460486880
   */
  flow?: string;
  /**
   * @remarks
   * The proportion of network traffic consumed to access the URL.
   * 
   * @example
   * 0.35
   */
  flowProportion?: number;
  /**
   * @remarks
   * The complete URL.
   * 
   * @example
   * http://example.com/nn_live/nn_x64/a0.m3u8
   */
  urlDetail?: string;
  /**
   * @remarks
   * The number of visits.
   * 
   * @example
   * 161673
   */
  visitData?: string;
  /**
   * @remarks
   * The proportion of visits.
   * 
   * @example
   * 0.35
   */
  visitProportion?: number;
  static names(): { [key: string]: string } {
    return {
      flow: 'Flow',
      flowProportion: 'FlowProportion',
      urlDetail: 'UrlDetail',
      visitData: 'VisitData',
      visitProportion: 'VisitProportion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flow: 'string',
      flowProportion: 'number',
      urlDetail: 'string',
      visitData: 'string',
      visitProportion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainTopUrlVisitResponseBodyUrl200List extends $tea.Model {
  urlList?: DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList[];
  static names(): { [key: string]: string } {
    return {
      urlList: 'UrlList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      urlList: { 'type': 'array', 'itemType': DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList extends $tea.Model {
  /**
   * @remarks
   * The amount of network traffic. (Unit: bytes)
   * 
   * @example
   * 460486880
   */
  flow?: string;
  /**
   * @remarks
   * The proportion of network traffic consumed to access the URL.
   * 
   * @example
   * 0.35
   */
  flowProportion?: number;
  /**
   * @remarks
   * The complete URL.
   * 
   * @example
   * http://example.com/nn_live/nn_x64/a0.m3u8
   */
  urlDetail?: string;
  /**
   * @remarks
   * The number of visits.
   * 
   * @example
   * 161673
   */
  visitData?: string;
  /**
   * @remarks
   * The proportion of visits.
   * 
   * @example
   * 0.35
   */
  visitProportion?: number;
  static names(): { [key: string]: string } {
    return {
      flow: 'Flow',
      flowProportion: 'FlowProportion',
      urlDetail: 'UrlDetail',
      visitData: 'VisitData',
      visitProportion: 'VisitProportion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flow: 'string',
      flowProportion: 'number',
      urlDetail: 'string',
      visitData: 'string',
      visitProportion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainTopUrlVisitResponseBodyUrl300List extends $tea.Model {
  urlList?: DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList[];
  static names(): { [key: string]: string } {
    return {
      urlList: 'UrlList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      urlList: { 'type': 'array', 'itemType': DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList extends $tea.Model {
  /**
   * @remarks
   * The amount of network traffic. (Unit: bytes)
   * 
   * @example
   * 460486880
   */
  flow?: string;
  /**
   * @remarks
   * The proportion of network traffic consumed to access the URL.
   * 
   * @example
   * 0.35
   */
  flowProportion?: number;
  /**
   * @remarks
   * The complete URL.
   * 
   * @example
   * http://example.com/nn_live/nn_x64/a0.m3u8
   */
  urlDetail?: string;
  /**
   * @remarks
   * The number of visits.
   * 
   * @example
   * 161673
   */
  visitData?: string;
  /**
   * @remarks
   * The proportion of visits.
   * 
   * @example
   * 0.35
   */
  visitProportion?: number;
  static names(): { [key: string]: string } {
    return {
      flow: 'Flow',
      flowProportion: 'FlowProportion',
      urlDetail: 'UrlDetail',
      visitData: 'VisitData',
      visitProportion: 'VisitProportion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flow: 'string',
      flowProportion: 'number',
      urlDetail: 'string',
      visitData: 'string',
      visitProportion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainTopUrlVisitResponseBodyUrl400List extends $tea.Model {
  urlList?: DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList[];
  static names(): { [key: string]: string } {
    return {
      urlList: 'UrlList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      urlList: { 'type': 'array', 'itemType': DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList extends $tea.Model {
  /**
   * @remarks
   * The amount of network traffic. (Unit: bytes)
   * 
   * @example
   * 460486880
   */
  flow?: string;
  /**
   * @remarks
   * The proportion of network traffic consumed to access the URL.
   * 
   * @example
   * 0.35
   */
  flowProportion?: number;
  /**
   * @remarks
   * The complete URL.
   * 
   * @example
   * http://example.com/nn_live/nn_x64/a0.m3u8
   */
  urlDetail?: string;
  /**
   * @remarks
   * The number of visits.
   * 
   * @example
   * 161673
   */
  visitData?: string;
  /**
   * @remarks
   * The proportion of visits.
   * 
   * @example
   * 0.35
   */
  visitProportion?: number;
  static names(): { [key: string]: string } {
    return {
      flow: 'Flow',
      flowProportion: 'FlowProportion',
      urlDetail: 'UrlDetail',
      visitData: 'VisitData',
      visitProportion: 'VisitProportion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flow: 'string',
      flowProportion: 'number',
      urlDetail: 'string',
      visitData: 'string',
      visitProportion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainTopUrlVisitResponseBodyUrl500List extends $tea.Model {
  urlList?: DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList[];
  static names(): { [key: string]: string } {
    return {
      urlList: 'UrlList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      urlList: { 'type': 'array', 'itemType': DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule extends $tea.Model {
  /**
   * @remarks
   * The network traffic that was consumed to deliver dynamic content over HTTP.
   * 
   * @example
   * 0
   */
  dynamicHttpTraffic?: number;
  /**
   * @remarks
   * The network traffic that was consumed to deliver dynamic content over HTTPS.
   * 
   * @example
   * 0
   */
  dynamicHttpsTraffic?: number;
  /**
   * @remarks
   * The network traffic that was consumed to deliver static content over HTTP.
   * 
   * @example
   * 123
   */
  staticHttpTraffic?: number;
  /**
   * @remarks
   * The network traffic that was consumed to deliver static content over HTTPS.
   * 
   * @example
   * 132
   */
  staticHttpsTraffic?: number;
  /**
   * @remarks
   * The timestamp of the data returned.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  timeStamp?: string;
  /**
   * @remarks
   * The total amount of network traffic.
   * 
   * @example
   * 0
   */
  traffic?: number;
  static names(): { [key: string]: string } {
    return {
      dynamicHttpTraffic: 'DynamicHttpTraffic',
      dynamicHttpsTraffic: 'DynamicHttpsTraffic',
      staticHttpTraffic: 'StaticHttpTraffic',
      staticHttpsTraffic: 'StaticHttpsTraffic',
      timeStamp: 'TimeStamp',
      traffic: 'Traffic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dynamicHttpTraffic: 'number',
      dynamicHttpsTraffic: 'number',
      staticHttpTraffic: 'number',
      staticHttpsTraffic: 'number',
      timeStamp: 'string',
      traffic: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerInterval extends $tea.Model {
  dataModule?: DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainUsageDataResponseBodyUsageDataPerIntervalDataModule extends $tea.Model {
  /**
   * @remarks
   * The time of the peak bandwidth value if the **Field** parameter in the request is set to **bps**. Otherwise, this parameter returns the same value as the **TimeStamp** parameter.
   * 
   * @example
   * 2015-12-10T21:30:00Z
   */
  peakTime?: string;
  /**
   * @remarks
   * The data usage in a specific scenario.
   * 
   * >  This parameter indicates the data usage in a specific scenario. If no special billable item is specified, ignore this parameter.
   * 
   * @example
   * 4233041**
   */
  specialValue?: string;
  /**
   * @remarks
   * The timestamp of the returned data.
   * 
   * @example
   * 2015-12-10T21:30:00Z
   */
  timeStamp?: string;
  /**
   * @remarks
   * The usage.
   * 
   * @example
   * 4233041**
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      peakTime: 'PeakTime',
      specialValue: 'SpecialValue',
      timeStamp: 'TimeStamp',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      peakTime: 'string',
      specialValue: 'string',
      timeStamp: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainUsageDataResponseBodyUsageDataPerInterval extends $tea.Model {
  dataModule?: DescribeDcdnDomainUsageDataResponseBodyUsageDataPerIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeDcdnDomainUsageDataResponseBodyUsageDataPerIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData extends $tea.Model {
  /**
   * @remarks
   * The timestamp of the data returned.
   * 
   * @example
   * 2015-11-29T00:00:00Z
   */
  timeStamp?: string;
  /**
   * @remarks
   * The number of UVs.
   * 
   * @example
   * 326
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      timeStamp: 'TimeStamp',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeStamp: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainUvDataResponseBodyUvDataInterval extends $tea.Model {
  usageData?: DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData[];
  static names(): { [key: string]: string } {
    return {
      usageData: 'UsageData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      usageData: { 'type': 'array', 'itemType': DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule extends $tea.Model {
  /**
   * @remarks
   * The timestamp of the returned data.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  timeStamp?: string;
  /**
   * @remarks
   * The bandwidth value. Unit: bit/s.
   * 
   * @example
   * 11288111
   */
  websocketBps?: number;
  static names(): { [key: string]: string } {
    return {
      timeStamp: 'TimeStamp',
      websocketBps: 'WebsocketBps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeStamp: 'string',
      websocketBps: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerInterval extends $tea.Model {
  dataModule?: DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCodeHttpCodeDataModule extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 404
   */
  code?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 16
   */
  count?: number;
  /**
   * @remarks
   * The proportion of the HTTP status code.
   * 
   * @example
   * 100
   */
  proportion?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      count: 'Count',
      proportion: 'Proportion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      count: 'number',
      proportion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCode extends $tea.Model {
  httpCodeDataModule?: DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCodeHttpCodeDataModule[];
  static names(): { [key: string]: string } {
    return {
      httpCodeDataModule: 'HttpCodeDataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      httpCodeDataModule: { 'type': 'array', 'itemType': DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCodeHttpCodeDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModule extends $tea.Model {
  /**
   * @remarks
   * The timestamp of the returned data.
   * 
   * @example
   * 2018-03-01T13:00:00Z
   */
  timeStamp?: string;
  /**
   * @remarks
   * The proportions of the HTTP status codes.
   */
  websocketHttpCode?: DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCode;
  static names(): { [key: string]: string } {
    return {
      timeStamp: 'TimeStamp',
      websocketHttpCode: 'WebsocketHttpCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeStamp: 'string',
      websocketHttpCode: DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCode,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerInterval extends $tea.Model {
  dataModule?: DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule extends $tea.Model {
  /**
   * @remarks
   * The timestamp of the returned data.
   * 
   * @example
   * 2017-12-10T20:00:00Z
   */
  timeStamp?: string;
  /**
   * @remarks
   * The total volume of traffic.
   * 
   * @example
   * 423304182
   */
  websocketTraffic?: number;
  static names(): { [key: string]: string } {
    return {
      timeStamp: 'TimeStamp',
      websocketTraffic: 'WebsocketTraffic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeStamp: 'string',
      websocketTraffic: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerInterval extends $tea.Model {
  dataModule?: DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule[];
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainsBySourceResponseBodyDomainInfoDomainList extends $tea.Model {
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 2021-08-21T03:05:20+08:00
   */
  createTime?: string;
  /**
   * @remarks
   * The CNAME record assigned to the domain name.
   * 
   * @example
   * example.org.alikunlun.com
   */
  domainCname?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.org
   */
  domainName?: string;
  /**
   * @remarks
   * The workload type of the accelerated domain name. Valid value:
   * 
   * *   **ipa**: layer 4 acceleration
   * *   **dynamic**: layer 7 acceleration
   * 
   * @example
   * dynamic
   */
  domainType?: string;
  /**
   * @remarks
   * The status of the domain name. Valid value:
   * 
   * *   **applying**: The domain name is under review.
   * *   **configuring**: The domain name is being configured.
   * *   **online**: The domain name is working as expected.
   * *   **stopping**: The domain name is being stopped.
   * *   **offline**: The domain name is disabled.
   * *   **disabling**: The domain name is being removed.
   * 
   * @example
   * online
   */
  status?: string;
  /**
   * @remarks
   * The time when the domain name was updated.
   * 
   * @example
   * 2022-12-01T03:26:55+08:00
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      domainCname: 'DomainCname',
      domainName: 'DomainName',
      domainType: 'DomainType',
      status: 'Status',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      domainCname: 'string',
      domainName: 'string',
      domainType: 'string',
      status: 'string',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnDomainsBySourceResponseBodyDomainInfo extends $tea.Model {
  /**
   * @remarks
   * The information about the domain names.
   */
  domainList?: DescribeDcdnDomainsBySourceResponseBodyDomainInfoDomainList[];
  /**
   * @remarks
   * The origin server.
   * 
   * @example
   * example.com
   */
  source?: string;
  static names(): { [key: string]: string } {
    return {
      domainList: 'DomainList',
      source: 'Source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainList: { 'type': 'array', 'itemType': DescribeDcdnDomainsBySourceResponseBodyDomainInfoDomainList },
      source: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnErUsageDataResponseBodyErAccDataErAccItem extends $tea.Model {
  /**
   * @remarks
   * The number of requests.
   * 
   * @example
   * 125
   */
  erAcc?: number;
  /**
   * @remarks
   * The ID of the routine. This parameter is returned only when SplitBy is set to routine.
   * 
   * @example
   * routine1.test
   */
  routine?: string;
  /**
   * @remarks
   * The specification of the routine. This parameter is returned only when SplitBy is set to spec.
   * 
   * @example
   * 50ms
   */
  spec?: string;
  /**
   * @remarks
   * The timestamp of the returned data.
   * 
   * @example
   * 2018-10-30T13:00:00Z
   */
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      erAcc: 'ErAcc',
      routine: 'Routine',
      spec: 'Spec',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      erAcc: 'number',
      routine: 'string',
      spec: 'string',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnErUsageDataResponseBodyErAccData extends $tea.Model {
  erAccItem?: DescribeDcdnErUsageDataResponseBodyErAccDataErAccItem[];
  static names(): { [key: string]: string } {
    return {
      erAccItem: 'ErAccItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      erAccItem: { 'type': 'array', 'itemType': DescribeDcdnErUsageDataResponseBodyErAccDataErAccItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnFullDomainsBlockIPHistoryResponseBodyIPBlockInfo extends $tea.Model {
  /**
   * @remarks
   * The blocked IP address or CIDR block.
   * 
   * @example
   * 1.XXX.XXX.0~1.XXX.XXX.255
   */
  blockIP?: string;
  /**
   * @remarks
   * The delivery time.
   * 
   * @example
   * 2023-04-24 18:49:37
   */
  deliverTime?: string;
  /**
   * @remarks
   * The delivery status.
   * 
   * *   Success
   * *   Failed
   * 
   * @example
   * Success
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      blockIP: 'BlockIP',
      deliverTime: 'DeliverTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockIP: 'string',
      deliverTime: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo extends $tea.Model {
  /**
   * @remarks
   * The returned primary domain name of the certificate.
   * 
   * @example
   * *.com
   */
  certCommonName?: string;
  /**
   * @remarks
   * The time at which the certificate expires.
   * 
   * @example
   * 2018-12-26 14:45:09
   */
  certExpireTime?: string;
  /**
   * @remarks
   * The name of the certificate.
   * 
   * @example
   * cert
   */
  certName?: string;
  /**
   * @remarks
   * The time at which the certificate became effective.
   * 
   * @example
   * 2018-11-26 14:45:09
   */
  certStartTime?: string;
  /**
   * @remarks
   * The status of the certificate. Valid values:
   * 
   * *   **ok**: The certificate is working as expected.
   * *   **mismatch**: The certificate does not match the specified domain name.
   * *   **expired**: The certificate has expired.
   * *   **expire_soon**: The certificate is about to expire.
   * 
   * @example
   * mismatch
   */
  certStatus?: string;
  /**
   * @remarks
   * The type of the certificate. Valid values:
   * 
   * *   **cas**: a certificate that is purchased by using Certificate Management Service
   * *   **upload**: a custom certificate that you upload
   * 
   * @example
   * upload
   */
  certType?: string;
  /**
   * @remarks
   * The time at which the certificate was updated.
   * 
   * @example
   * 2019-01-08 18:33:16
   */
  certUpdateTime?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * *.com
   */
  domainName?: string;
  static names(): { [key: string]: string } {
    return {
      certCommonName: 'CertCommonName',
      certExpireTime: 'CertExpireTime',
      certName: 'CertName',
      certStartTime: 'CertStartTime',
      certStatus: 'CertStatus',
      certType: 'CertType',
      certUpdateTime: 'CertUpdateTime',
      domainName: 'DomainName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certCommonName: 'string',
      certExpireTime: 'string',
      certName: 'string',
      certStartTime: 'string',
      certStatus: 'string',
      certType: 'string',
      certUpdateTime: 'string',
      domainName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnHttpsDomainListResponseBodyCertInfos extends $tea.Model {
  certInfo?: DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo[];
  static names(): { [key: string]: string } {
    return {
      certInfo: 'CertInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certInfo: { 'type': 'array', 'itemType': DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg extends $tea.Model {
  /**
   * @remarks
   * The name of the configuration.
   * 
   * @example
   * file_type
   */
  argName?: string;
  /**
   * @remarks
   * The value of the configuration.
   * 
   * @example
   * txt
   */
  argValue?: string;
  static names(): { [key: string]: string } {
    return {
      argName: 'ArgName',
      argValue: 'ArgValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      argName: 'string',
      argValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs extends $tea.Model {
  functionArg?: DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg[];
  static names(): { [key: string]: string } {
    return {
      functionArg: 'FunctionArg',
    };
  }

  static types(): { [key: string]: any } {
    return {
      functionArg: { 'type': 'array', 'itemType': DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig extends $tea.Model {
  /**
   * @remarks
   * The ID of the configuration.
   * 
   * @example
   * 5003576
   */
  configId?: string;
  /**
   * @remarks
   * The list of features.
   */
  functionArgs?: DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs;
  /**
   * @remarks
   * The name of the feature.
   * 
   * @example
   * protogw
   */
  functionName?: string;
  /**
   * @remarks
   * The configuration status of the feature. Valid values:
   * 
   * *   **success**
   * *   **testing**
   * *   **failed**
   * *   **configuring**
   * 
   * @example
   * success
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      functionArgs: 'FunctionArgs',
      functionName: 'FunctionName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'string',
      functionArgs: DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs,
      functionName: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigs extends $tea.Model {
  domainConfig?: DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig[];
  static names(): { [key: string]: string } {
    return {
      domainConfig: 'DomainConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainConfig: { 'type': 'array', 'itemType': DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource extends $tea.Model {
  /**
   * @remarks
   * The address of the origin server.
   * 
   * @example
   * xxx.oss-cn-hangzhou.aliyuncs.com
   */
  content?: string;
  /**
   * @remarks
   * The status.
   * 
   * @example
   * online
   */
  enabled?: string;
  /**
   * @remarks
   * The custom port. Valid values: **0** to **65535**.
   * 
   * @example
   * 80
   */
  port?: number;
  /**
   * @remarks
   * The priority.
   * 
   * @example
   * 50
   */
  priority?: string;
  /**
   * @remarks
   * The type of the origin server. Valid values:
   * 
   * *   **ipaddr**: an origin IP address
   * *   **domain**: a domain name.
   * *   **oss**: Object Storage Service (OSS) buckets are not supported.
   * 
   * @example
   * oss
   */
  type?: string;
  /**
   * @remarks
   * The weight of the origin server if multiple origin servers have been specified.
   * 
   * @example
   * 10
   */
  weight?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      enabled: 'Enabled',
      port: 'Port',
      priority: 'Priority',
      type: 'Type',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      enabled: 'string',
      port: 'number',
      priority: 'string',
      type: 'string',
      weight: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSources extends $tea.Model {
  source?: DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource[];
  static names(): { [key: string]: string } {
    return {
      source: 'Source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      source: { 'type': 'array', 'itemType': DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaDomainDetailResponseBodyDomainDetail extends $tea.Model {
  /**
   * @remarks
   * Indicates the name of the certificate if the HTTPS protocol is enabled.
   * 
   * @example
   * yourCertName
   */
  certName?: string;
  /**
   * @remarks
   * The CNAME assigned to the domain name.
   * 
   * @example
   * example.com
   */
  cname?: string;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * audit failed
   */
  description?: string;
  /**
   * @remarks
   * The accelerated domain names.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The status of the accelerated domain name. Valid values:
   * 
   * *   **online**: enabled
   * *   **offline**: disabled
   * *   **configuring**: configuring
   * *   **configure_failed**: configuration failed
   * *   **checking**: reviewing
   * *   **check_failed:** review failed
   * 
   * @example
   * online
   */
  domainStatus?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 2017-11-27T06:51:26Z
   */
  gmtCreated?: string;
  /**
   * @remarks
   * The time when the domain name was last modified.
   * 
   * @example
   * 2017-11-27T06:51:26Z
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfmyuji4b6xxxx
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * Indicates whether the Security Socket Layer (SSL) certificate is enabled. Valid values:
   * 
   * *   **on**
   * *   **off**.
   * 
   * @example
   * on
   */
  SSLProtocol?: string;
  /**
   * @remarks
   * The public key of the certificate if HTTPS is enabled.
   * 
   * @example
   * SSLPub
   */
  SSLPub?: string;
  /**
   * @remarks
   * The acceleration region. Valid values:
   * 
   * *   domestic: Chinese mainland
   * *   overseas: outside the Chinese mainland
   * *   global: global
   * 
   * @example
   * overseas
   */
  scope?: string;
  /**
   * @remarks
   * The information about the origin server.
   */
  sources?: DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSources;
  static names(): { [key: string]: string } {
    return {
      certName: 'CertName',
      cname: 'Cname',
      description: 'Description',
      domainName: 'DomainName',
      domainStatus: 'DomainStatus',
      gmtCreated: 'GmtCreated',
      gmtModified: 'GmtModified',
      resourceGroupId: 'ResourceGroupId',
      SSLProtocol: 'SSLProtocol',
      SSLPub: 'SSLPub',
      scope: 'Scope',
      sources: 'Sources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certName: 'string',
      cname: 'string',
      description: 'string',
      domainName: 'string',
      domainStatus: 'string',
      gmtCreated: 'string',
      gmtModified: 'string',
      resourceGroupId: 'string',
      SSLProtocol: 'string',
      SSLPub: 'string',
      scope: 'string',
      sources: DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSources,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaServiceResponseBodyOperationLocksLockReason extends $tea.Model {
  /**
   * @remarks
   * The reason why the instance is locked. For example, a value of **financial** indicates that an overdue payment exists.
   * 
   * @example
   * financial
   */
  lockReason?: string;
  static names(): { [key: string]: string } {
    return {
      lockReason: 'LockReason',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lockReason: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaServiceResponseBodyOperationLocks extends $tea.Model {
  lockReason?: DescribeDcdnIpaServiceResponseBodyOperationLocksLockReason[];
  static names(): { [key: string]: string } {
    return {
      lockReason: 'LockReason',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lockReason: { 'type': 'array', 'itemType': DescribeDcdnIpaServiceResponseBodyOperationLocksLockReason },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaUserDomainsRequestTag extends $tea.Model {
  /**
   * @remarks
   * The tag key. Valid values of N: 1 to 20. You can call the TagDcdnResources operation to set a tag for a domain name.
   * 
   * @example
   * 1
   */
  key?: string;
  /**
   * @remarks
   * The tag value. Valid values of N: 1 to 20.
   * 
   * @example
   * 1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource extends $tea.Model {
  /**
   * @remarks
   * The address of the origin server.
   * 
   * @example
   * *.aliyuncs.com
   */
  content?: string;
  /**
   * @remarks
   * The port of the origin server.
   * 
   * @example
   * 80
   */
  port?: number;
  /**
   * @remarks
   * The priority.
   * 
   * @example
   * 20
   */
  priority?: string;
  /**
   * @remarks
   * The type of the origin server.
   * 
   * @example
   * OSS Domain
   */
  type?: string;
  /**
   * @remarks
   * The weight of the origin server if multiple origin servers have been specified.
   * 
   * @example
   * 20
   */
  weight?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      port: 'Port',
      priority: 'Priority',
      type: 'Type',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      port: 'number',
      priority: 'string',
      type: 'string',
      weight: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSources extends $tea.Model {
  source?: DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource[];
  static names(): { [key: string]: string } {
    return {
      source: 'Source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      source: { 'type': 'array', 'itemType': DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData extends $tea.Model {
  /**
   * @remarks
   * The CNAME assigned to the accelerated domain name.
   * 
   * @example
   * example.com.*.com
   */
  cname?: string;
  /**
   * @remarks
   * The reason why the accelerated domain name failed the review.
   * 
   * @example
   * audit failed
   */
  description?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The status of the accelerated domain name. Valid values:
   * 
   * *   **online**: enabled
   * *   **offline**: disabled
   * *   **configuring**: configuring
   * *   **configure_failed**: configuration failed
   * *   **checking**: reviewing
   * *   **check_failed:** review failed
   * 
   * @example
   * online
   */
  domainStatus?: string;
  /**
   * @remarks
   * The time when the accelerated domain name was added to Alibaba Cloud CDN.
   * 
   * @example
   * 2015-10-28T09:32:51Z
   */
  gmtCreated?: string;
  /**
   * @remarks
   * The time when the accelerated domain name was modified.
   * 
   * @example
   * 2015-10-28T11:05:52Z
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * abcd1234abcd****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The status of HTTPS.
   * 
   * *   **on**
   * *   **off**
   * 
   * @example
   * on
   */
  SSLProtocol?: string;
  /**
   * @remarks
   * Indicates whether the accelerated domain name was in a sandbox.
   * 
   * @example
   * normal
   */
  sandbox?: string;
  /**
   * @remarks
   * The information about the origin server.
   */
  sources?: DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSources;
  static names(): { [key: string]: string } {
    return {
      cname: 'Cname',
      description: 'Description',
      domainName: 'DomainName',
      domainStatus: 'DomainStatus',
      gmtCreated: 'GmtCreated',
      gmtModified: 'GmtModified',
      resourceGroupId: 'ResourceGroupId',
      SSLProtocol: 'SSLProtocol',
      sandbox: 'Sandbox',
      sources: 'Sources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cname: 'string',
      description: 'string',
      domainName: 'string',
      domainStatus: 'string',
      gmtCreated: 'string',
      gmtModified: 'string',
      resourceGroupId: 'string',
      SSLProtocol: 'string',
      sandbox: 'string',
      sources: DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSources,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnIpaUserDomainsResponseBodyDomains extends $tea.Model {
  pageData?: DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData[];
  static names(): { [key: string]: string } {
    return {
      pageData: 'PageData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageData: { 'type': 'array', 'itemType': DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnKvAccountResponseBodyNamespaceList extends $tea.Model {
  capacity?: number;
  /**
   * @remarks
   * The available capacity of the namespace.
   * 
   * @example
   * 1 GB
   */
  capacityString?: string;
  capacityUsed?: number;
  /**
   * @remarks
   * The namespace has used capacity.
   * 
   * @example
   * 100 MB
   */
  capacityUsedString?: string;
  /**
   * @remarks
   * The description of the namespace.
   * 
   * @example
   * the first namespace
   */
  description?: string;
  /**
   * @remarks
   * The name of the namespace.
   * 
   * @example
   * ns1
   */
  namespace?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * 12423131231****
   */
  namespaceId?: string;
  /**
   * @remarks
   * The status of the namespace. Valid values:
   * 
   * *   **online**: normal
   * *   **delete**: pending delete
   * *   **deleting**: being deleted
   * *   **deleted**: deleted
   * 
   * @example
   * online
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      capacity: 'Capacity',
      capacityString: 'CapacityString',
      capacityUsed: 'CapacityUsed',
      capacityUsedString: 'CapacityUsedString',
      description: 'Description',
      namespace: 'Namespace',
      namespaceId: 'NamespaceId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacity: 'number',
      capacityString: 'string',
      capacityUsed: 'number',
      capacityUsedString: 'string',
      description: 'string',
      namespace: 'string',
      namespaceId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnOriginSiteHealthStatusResponseBodyOriginSiteStatus extends $tea.Model {
  /**
   * @remarks
   * The health status of the origin server. Each point of presence (POP) periodically initiates a probe request to the configured origin domain name. If the POP receives a response from the origin server in 5 seconds, the probe is considered successful. After the probe data for each POP is collected, the health status of the origin server is calculated based on the proportion of successful probes. Valid values:
   * 
   * *   unknown: The probe data of the origin server is not obtained because the configurations of the origin server have been changed recently. Try again later.
   * *   healthy: The proportion of successful probes is higher than 80%.
   * *   degraded: The proportion of successful probes is higher than 0% and lower than or equal to 80%.
   * *   critical: All probing requests to the origin server failed.
   * 
   * @example
   * healthy
   */
  healthStatus?: string;
  /**
   * @remarks
   * The origin domain name that you configured in the DCDN console, which can be an IPv4 address, IPv6 address, common domain name, or Object Storage Service (OSS) domain name.
   * 
   * @example
   * host.com
   */
  host?: string;
  static names(): { [key: string]: string } {
    return {
      healthStatus: 'HealthStatus',
      host: 'Host',
    };
  }

  static types(): { [key: string]: any } {
    return {
      healthStatus: 'string',
      host: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnRealTimeDeliveryFieldResponseBodyContentFields extends $tea.Model {
  /**
   * @remarks
   * The description of the field.
   * 
   * @example
   * Access time
   */
  description?: string;
  /**
   * @remarks
   * The name of the field. For more information about fields in real-time log entries, see [Fields in a real-time log](https://help.aliyun.com/document_detail/324199.html).
   * 
   * @example
   * unixtime
   */
  fieldName?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      fieldName: 'FieldName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      fieldName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnRealTimeDeliveryFieldResponseBodyContent extends $tea.Model {
  fields?: DescribeDcdnRealTimeDeliveryFieldResponseBodyContentFields[];
  static names(): { [key: string]: string } {
    return {
      fields: 'Fields',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fields: { 'type': 'array', 'itemType': DescribeDcdnRealTimeDeliveryFieldResponseBodyContentFields },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnRefreshTaskByIdResponseBodyTasks extends $tea.Model {
  /**
   * @remarks
   * The time when the task was created. The time follows the ISO8601 standard in the YYYY-MM-DDThh:mmZ format. The time is displayed in UTC.
   * 
   * @example
   * 2021-05-10T08:54:23Z
   */
  creationTime?: string;
  /**
   * @remarks
   * The error returned when the refresh or prefetch task failed. Valid values:
   * 
   * *   **Internal Error**: An internal error occurred.
   * *   **Origin Timeout**: The response from the origin server timed out.
   * *   **Origin Return StatusCode 5XX**: The origin server returned a 5XX error.
   * 
   * @example
   * Internal Error
   */
  description?: string;
  /**
   * @remarks
   * The path of the refresh or prefetch object.
   * 
   * @example
   * http://example.com/image_01.png
   */
  objectPath?: string;
  /**
   * @remarks
   * The type of the refresh or prefetch task. Valid values:
   * 
   * *   **file**: refreshes an individual file.
   * *   **directory**: refreshes files under the specified directory.
   * *   **preload**: prefetches an individual file.
   * 
   * @example
   * file
   */
  objectType?: string;
  /**
   * @remarks
   * The progress of the task, in percentage.
   * 
   * @example
   * 100%
   */
  process?: string;
  /**
   * @remarks
   * The task status. Valid values:
   * 
   * *   **Complete**: The task is complete.
   * *   **Pending**: The task is pending.
   * *   **Refreshing**: The task is running.
   * *   **Failed**: The task failed.
   * 
   * @example
   * Complete
   */
  status?: string;
  /**
   * @remarks
   * The ID of the task.
   * 
   * @example
   * 113681**
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      description: 'Description',
      objectPath: 'ObjectPath',
      objectType: 'ObjectType',
      process: 'Process',
      status: 'Status',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      description: 'string',
      objectPath: 'string',
      objectType: 'string',
      process: 'string',
      status: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnRefreshTasksResponseBodyTasksTask extends $tea.Model {
  /**
   * @remarks
   * The time when the task was created. The time is displayed in UTC.
   * 
   * @example
   * 2014-11-27T08:23:22Z
   */
  creationTime?: string;
  /**
   * @remarks
   * The type of error returned when the refresh or prefetch task has failed.
   * 
   * *   **InternalError**: An internal error occurred.
   * *   **OriginTimeout**: The response from the origin server timed out.
   * *   **OriginReturn StatusCode 5XX**: The origin server returned a 5XX error.
   * 
   * @example
   * InternalError
   */
  description?: string;
  /**
   * @remarks
   * The URL of the object refreshed.
   * 
   * @example
   * http://example.com/examplefile.txt
   */
  objectPath?: string;
  /**
   * @remarks
   * The type of the task.
   * 
   * *   **file**: URL-based refresh
   * *   **path**: directory-based refresh
   * *   **preload**: URL-based prefetch
   * 
   * @example
   * file
   */
  objectType?: string;
  /**
   * @remarks
   * The progress of the task in percentage.
   * 
   * @example
   * 10
   */
  process?: string;
  /**
   * @remarks
   * The status of the task.
   * 
   * *   **Complete**: The task is complete.
   * *   **Refreshing**: The task is in progress.
   * *   **Failed**: The task failed.
   * 
   * @example
   * Complete
   */
  status?: string;
  /**
   * @remarks
   * The ID of the task.
   * 
   * @example
   * 123
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      creationTime: 'CreationTime',
      description: 'Description',
      objectPath: 'ObjectPath',
      objectType: 'ObjectType',
      process: 'Process',
      status: 'Status',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creationTime: 'string',
      description: 'string',
      objectPath: 'string',
      objectType: 'string',
      process: 'string',
      status: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnRefreshTasksResponseBodyTasks extends $tea.Model {
  task?: DescribeDcdnRefreshTasksResponseBodyTasksTask[];
  static names(): { [key: string]: string } {
    return {
      task: 'Task',
    };
  }

  static types(): { [key: string]: any } {
    return {
      task: { 'type': 'array', 'itemType': DescribeDcdnRefreshTasksResponseBodyTasksTask },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnRegionAndIspResponseBodyIspsIsp extends $tea.Model {
  /**
   * @remarks
   * The English name of the region.
   * 
   * @example
   * unicom
   */
  nameEn?: string;
  /**
   * @remarks
   * The Chinese name of the ISP.
   * 
   * @example
   * 联通
   */
  nameZh?: string;
  static names(): { [key: string]: string } {
    return {
      nameEn: 'NameEn',
      nameZh: 'NameZh',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nameEn: 'string',
      nameZh: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnRegionAndIspResponseBodyIsps extends $tea.Model {
  isp?: DescribeDcdnRegionAndIspResponseBodyIspsIsp[];
  static names(): { [key: string]: string } {
    return {
      isp: 'Isp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isp: { 'type': 'array', 'itemType': DescribeDcdnRegionAndIspResponseBodyIspsIsp },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnRegionAndIspResponseBodyRegionsRegion extends $tea.Model {
  /**
   * @remarks
   * The English name of the region.
   * 
   * @example
   * liaoning
   */
  nameEn?: string;
  /**
   * @remarks
   * The Chinese name of the region.
   * 
   * @example
   * 辽宁省
   */
  nameZh?: string;
  static names(): { [key: string]: string } {
    return {
      nameEn: 'NameEn',
      nameZh: 'NameZh',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nameEn: 'string',
      nameZh: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnRegionAndIspResponseBodyRegions extends $tea.Model {
  region?: DescribeDcdnRegionAndIspResponseBodyRegionsRegion[];
  static names(): { [key: string]: string } {
    return {
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      region: { 'type': 'array', 'itemType': DescribeDcdnRegionAndIspResponseBodyRegionsRegion },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSLSRealTimeLogTypeResponseBodyContentBusiness extends $tea.Model {
  /**
   * @remarks
   * The type of real-time logs. Valid values:
   * 
   * *   **dcdn_log_access_l1**: access logs.
   * *   **dcdn_log_er**: EdgeRoutine logs
   * *   **dcdn_log_waf**: WAF interception logs
   * 
   * @example
   * dcdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The description of the real-time log type.
   * 
   * @example
   * product_U8JE
   */
  desc?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      desc: 'Desc',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      desc: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSLSRealTimeLogTypeResponseBodyContent extends $tea.Model {
  business?: DescribeDcdnSLSRealTimeLogTypeResponseBodyContentBusiness[];
  static names(): { [key: string]: string } {
    return {
      business: 'Business',
    };
  }

  static types(): { [key: string]: any } {
    return {
      business: { 'type': 'array', 'itemType': DescribeDcdnSLSRealTimeLogTypeResponseBodyContentBusiness },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent extends $tea.Model {
  /**
   * @remarks
   * The type of the collected logs. Default value: cdn_log_access_l1. Valid values:
   * 
   * *   **cdn_log_access_l1**: access logs of Dynamic Content Delivery Network (DCDN) points of presence (POPs)
   * *   **cdn_log_origin**: back-to-origin logs
   * *   **cdn_log_er**: EdgeRoutine logs
   * 
   * @example
   * cdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The region from which logs were collected.
   * 
   * @example
   * cn
   */
  dataCenter?: string;
  /**
   * @remarks
   * The domain names from which logs were collected. You can specify one or more domain names. Separate multiple domain names with commas (,).
   * 
   * @example
   * example.com,example.org
   */
  domainName?: string;
  /**
   * @remarks
   * The name of the field. For more information about fields in real-time log entries, see [Fields in a real-time log](https://help.aliyun.com/document_detail/324199.html).
   * 
   * @example
   * field1,field2
   */
  fieldName?: string;
  /**
   * @remarks
   * The name of the project.
   * 
   * @example
   * example
   */
  projectName?: string;
  /**
   * @remarks
   * The name of the Logstore.
   * 
   * @example
   * example-cn
   */
  SLSLogStore?: string;
  /**
   * @remarks
   * The name of the log file.
   * 
   * @example
   * example-cn
   */
  SLSProject?: string;
  /**
   * @remarks
   * The region to which logs were delivered.
   * 
   * @example
   * cn-hangzhou
   */
  SLSRegion?: string;
  /**
   * @remarks
   * The sampling rate.
   * 
   * @example
   * 1.0
   */
  samplingRate?: string;
  /**
   * @remarks
   * The status of real-time logs.
   * 
   * *   **success**
   * *   **fail**
   * 
   * @example
   * success
   */
  status?: string;
  /**
   * @remarks
   * The type of log delivery. Only **SLS_POST** is supported.
   * 
   * @example
   * SLS_POST
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      dataCenter: 'DataCenter',
      domainName: 'DomainName',
      fieldName: 'FieldName',
      projectName: 'ProjectName',
      SLSLogStore: 'SLSLogStore',
      SLSProject: 'SLSProject',
      SLSRegion: 'SLSRegion',
      samplingRate: 'SamplingRate',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      dataCenter: 'string',
      domainName: 'string',
      fieldName: 'string',
      projectName: 'string',
      SLSLogStore: 'string',
      SLSProject: 'string',
      SLSRegion: 'string',
      samplingRate: 'string',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSMCertificateListResponseBodyCertificateListModelCertList extends $tea.Model {
  /**
   * @remarks
   * The ID of the certificate.
   * 
   * @example
   * yourCertldentifier
   */
  certIdentifier?: string;
  /**
   * @remarks
   * The name of the certificate.
   * 
   * @example
   * yourCertName
   */
  certName?: string;
  /**
   * @remarks
   * The common name of the certificate.
   * 
   * @example
   * yourCertCommon
   */
  common?: string;
  /**
   * @remarks
   * The certificate authority (CA) that issued the certificate.
   * 
   * @example
   * yourCertIssuer
   */
  issuer?: string;
  static names(): { [key: string]: string } {
    return {
      certIdentifier: 'CertIdentifier',
      certName: 'CertName',
      common: 'Common',
      issuer: 'Issuer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certIdentifier: 'string',
      certName: 'string',
      common: 'string',
      issuer: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSMCertificateListResponseBodyCertificateListModel extends $tea.Model {
  /**
   * @remarks
   * A list of certificates.
   */
  certList?: DescribeDcdnSMCertificateListResponseBodyCertificateListModelCertList[];
  /**
   * @remarks
   * The number of certificates that are returned.
   * 
   * @example
   * 2
   */
  count?: number;
  static names(): { [key: string]: string } {
    return {
      certList: 'CertList',
      count: 'Count',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certList: { 'type': 'array', 'itemType': DescribeDcdnSMCertificateListResponseBodyCertificateListModelCertList },
      count: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSSLCertificateListResponseBodyCertificateListModelCertListCert extends $tea.Model {
  /**
   * @remarks
   * The ID of the certificate.
   * 
   * @example
   * 7428244
   */
  certId?: number;
  /**
   * @remarks
   * The name of the certificate.
   * 
   * @example
   * yourCertName
   */
  certName?: string;
  /**
   * @remarks
   * The region ID of the certificate. Valid values: **cn-hangzhou** and **ap-southeast-1**. Default value: **cn-hangzhou**.
   * 
   * @example
   * cn-hangzhou
   */
  certRegion?: string;
  /**
   * @remarks
   * The Common Name (CN) attribute of the certificate. In most cases, the CN is a domain name.
   * 
   * @example
   * example.com
   */
  common?: string;
  /**
   * @remarks
   * The fingerprint of the certificate.
   * 
   * @example
   * 4278e3b81ab5bc678d253e74c17ffb88
   */
  fingerprint?: string;
  /**
   * @remarks
   * The certificate authority (CA) that issued the certificate.
   * 
   * @example
   * yourCertIssuer
   */
  issuer?: string;
  /**
   * @remarks
   * The time when the certificate was last modified. Unit: milliseconds.
   * 
   * @example
   * 1548065550
   */
  lastTime?: number;
  static names(): { [key: string]: string } {
    return {
      certId: 'CertId',
      certName: 'CertName',
      certRegion: 'CertRegion',
      common: 'Common',
      fingerprint: 'Fingerprint',
      issuer: 'Issuer',
      lastTime: 'LastTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certId: 'number',
      certName: 'string',
      certRegion: 'string',
      common: 'string',
      fingerprint: 'string',
      issuer: 'string',
      lastTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSSLCertificateListResponseBodyCertificateListModelCertList extends $tea.Model {
  cert?: DescribeDcdnSSLCertificateListResponseBodyCertificateListModelCertListCert[];
  static names(): { [key: string]: string } {
    return {
      cert: 'Cert',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cert: { 'type': 'array', 'itemType': DescribeDcdnSSLCertificateListResponseBodyCertificateListModelCertListCert },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSSLCertificateListResponseBodyCertificateListModel extends $tea.Model {
  /**
   * @remarks
   * Details about each certificate.
   */
  certList?: DescribeDcdnSSLCertificateListResponseBodyCertificateListModelCertList;
  /**
   * @remarks
   * The number of certificates.
   * 
   * @example
   * 2
   */
  count?: number;
  /**
   * @remarks
   * The page number. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 2
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: an integer from 1 to 1000.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      certList: 'CertList',
      count: 'Count',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certList: DescribeDcdnSSLCertificateListResponseBodyCertificateListModelCertList,
      count: 'number',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSecFuncInfoResponseBodyContent extends $tea.Model {
  /**
   * @remarks
   * The language (Chinese or English).
   * 
   * @example
   * ai_defense
   */
  label?: string;
  /**
   * @remarks
   * The options in the drop-down list.
   * 
   * @example
   * ai_defense
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      label: 'Label',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      label: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSecSpecInfoResponseBodySpecInfosRuleConfigs extends $tea.Model {
  /**
   * @remarks
   * The configuration code of the security rule.
   * 
   * @example
   * custom_****_number
   */
  code?: string;
  /**
   * @remarks
   * The configuration expression of the security rule.
   * 
   * @example
   * equal
   */
  expr?: string;
  /**
   * @remarks
   * The value of the configuration expression of the security rule.
   * 
   * @example
   * 20
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      expr: 'Expr',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      expr: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnSecSpecInfoResponseBodySpecInfos extends $tea.Model {
  /**
   * @remarks
   * The code of the security rule.
   * 
   * @example
   * accurate_***
   */
  ruleCode?: string;
  /**
   * @remarks
   * The configurations of the security rule.
   */
  ruleConfigs?: DescribeDcdnSecSpecInfoResponseBodySpecInfosRuleConfigs[];
  static names(): { [key: string]: string } {
    return {
      ruleCode: 'RuleCode',
      ruleConfigs: 'RuleConfigs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleCode: 'string',
      ruleConfigs: { 'type': 'array', 'itemType': DescribeDcdnSecSpecInfoResponseBodySpecInfosRuleConfigs },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnServiceResponseBodyOperationLocksLockReason extends $tea.Model {
  /**
   * @remarks
   * The reason why secure DCDN was locked. For example, a value of financial indicates that an overdue payment exists.
   * 
   * @example
   * financial
   */
  lockReason?: string;
  static names(): { [key: string]: string } {
    return {
      lockReason: 'LockReason',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lockReason: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnServiceResponseBodyOperationLocks extends $tea.Model {
  lockReason?: DescribeDcdnServiceResponseBodyOperationLocksLockReason[];
  static names(): { [key: string]: string } {
    return {
      lockReason: 'LockReason',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lockReason: { 'type': 'array', 'itemType': DescribeDcdnServiceResponseBodyOperationLocksLockReason },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnStagingIpResponseBodyIPV4s extends $tea.Model {
  IPV4?: string[];
  static names(): { [key: string]: string } {
    return {
      IPV4: 'IPV4',
    };
  }

  static types(): { [key: string]: any } {
    return {
      IPV4: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnTagResourcesRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * env
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * product
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnTagResourcesResponseBodyTagResourcesTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag.
   * 
   * @example
   * env
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag.
   * 
   * @example
   * product
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnTagResourcesResponseBodyTagResources extends $tea.Model {
  /**
   * @remarks
   * The ID of the resource.
   * 
   * @example
   * example.com
   */
  resourceId?: string;
  /**
   * @remarks
   * The tags of the snapshot.
   */
  tag?: DescribeDcdnTagResourcesResponseBodyTagResourcesTag[];
  static names(): { [key: string]: string } {
    return {
      resourceId: 'ResourceId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceId: 'string',
      tag: { 'type': 'array', 'itemType': DescribeDcdnTagResourcesResponseBodyTagResourcesTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The peak bandwidth value.
   * 
   * @example
   * 22139626
   */
  maxBps?: number;
  /**
   * @remarks
   * The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2018-11-01T08:10:00Z
   */
  maxBpsTime?: string;
  /**
   * @remarks
   * The ranking of the accelerated domain name.
   * 
   * @example
   * 1
   */
  rank?: number;
  /**
   * @remarks
   * The number of visits.
   * 
   * @example
   * 3
   */
  totalAccess?: number;
  /**
   * @remarks
   * The total amount of network traffic.
   * 
   * @example
   * 123
   */
  totalTraffic?: string;
  /**
   * @remarks
   * The proportion of network traffic consumed to access the URL.
   * 
   * @example
   * 21.686305274906182
   */
  trafficPercent?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      maxBps: 'MaxBps',
      maxBpsTime: 'MaxBpsTime',
      rank: 'Rank',
      totalAccess: 'TotalAccess',
      totalTraffic: 'TotalTraffic',
      trafficPercent: 'TrafficPercent',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      maxBps: 'number',
      maxBpsTime: 'string',
      rank: 'number',
      totalAccess: 'number',
      totalTraffic: 'string',
      trafficPercent: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnTopDomainsByFlowResponseBodyTopDomains extends $tea.Model {
  topDomain?: DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain[];
  static names(): { [key: string]: string } {
    return {
      topDomain: 'TopDomain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topDomain: { 'type': 'array', 'itemType': DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem extends $tea.Model {
  /**
   * @remarks
   * The bandwidth. Unit: bit/s.
   * 
   * @example
   * 4839
   */
  bandwidth?: number;
  /**
   * @remarks
   * The region for which the billing records are generated. Valid values: **CN**, **OverSeas**, **AP1**, **AP2**, **AP3**, **NA**, **SA**, **EU**, and **MEAA**.
   * 
   * @example
   * AP1
   */
  cdnRegion?: string;
  /**
   * @remarks
   * The billing method of the disk. Valid values: **StaticHttp**, **DynamicHttp**, and **DynamicHttps**.
   * 
   * @example
   * DynamicHttp
   */
  chargeType?: string;
  /**
   * @remarks
   * The number of billing entries.
   * 
   * @example
   * 205624
   */
  count?: number;
  /**
   * @remarks
   * The amount of network traffic. Unit: bytes.
   * 
   * @example
   * 2456
   */
  flow?: number;
  static names(): { [key: string]: string } {
    return {
      bandwidth: 'Bandwidth',
      cdnRegion: 'CdnRegion',
      chargeType: 'ChargeType',
      count: 'Count',
      flow: 'Flow',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bandwidth: 'number',
      cdnRegion: 'string',
      chargeType: 'string',
      count: 'number',
      flow: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData extends $tea.Model {
  billingDataItem?: DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem[];
  static names(): { [key: string]: string } {
    return {
      billingDataItem: 'BillingDataItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      billingDataItem: { 'type': 'array', 'itemType': DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem extends $tea.Model {
  /**
   * @remarks
   * The beginning of the time range that was queried.
   * 
   * @example
   * 2018-09-30T17:00:00Z
   */
  billTime?: string;
  /**
   * @remarks
   * The metering method.
   * 
   * @example
   * month_4th_day_bandwidth
   */
  billType?: string;
  /**
   * @remarks
   * The billable items.
   */
  billingData?: DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData;
  /**
   * @remarks
   * The dimension.
   * 
   * @example
   * vas
   */
  dimension?: string;
  static names(): { [key: string]: string } {
    return {
      billTime: 'BillTime',
      billType: 'BillType',
      billingData: 'BillingData',
      dimension: 'Dimension',
    };
  }

  static types(): { [key: string]: any } {
    return {
      billTime: 'string',
      billType: 'string',
      billingData: DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData,
      dimension: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserBillHistoryResponseBodyBillHistoryData extends $tea.Model {
  billHistoryDataItem?: DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem[];
  static names(): { [key: string]: string } {
    return {
      billHistoryDataItem: 'BillHistoryDataItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      billHistoryDataItem: { 'type': 'array', 'itemType': DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem extends $tea.Model {
  /**
   * @remarks
   * The metering method. Valid values:
   * 
   * *   **hour_flow**: pay by hourly traffic
   * *   **day_bandwidth**: pay by daily bandwidth
   * *   **month_95**: pay by monthly 95th percentile
   * *   **month_avg_day_bandwidth**: pay by average daily peak bandwidth per month
   * *   **month_4th_day_bandwidth**: pay by 4th peak bandwidth per month
   * *   **month_avg_day_95**: pay by average daily 95th percentile per month
   * *   **month_95_night_half**: pay by 95th percentile (50% off during nighttime)
   * *   **hour_vas**: pay by value-added service per month
   * *   **quic_hour_count**: pay by QUIC request per hour
   * *   **hour_count**: pay by request per hour
   * *   **rtlog_count_day**: pay by the number of real-time logs per day
   * 
   * @example
   * month_avg_day_bandwidth_overseas
   */
  billType?: string;
  /**
   * @remarks
   * The metering cycle.
   * 
   * @example
   * month
   */
  billingCycle?: string;
  /**
   * @remarks
   * The dimension. Valid values:
   * 
   * *   **flow**: network traffic and bandwidth
   * *   **vas**: value-added services (HTTPS and requests for dynamic content)
   * *   **websocket**: WebSocket
   * *   **quic**: QUIC requests
   * *   **rtlog2sls**: log entries delivered to Log Service in real time
   * 
   * @example
   * flow
   */
  dimension?: string;
  /**
   * @remarks
   * The time when the metering method ends.
   * 
   * @example
   * 2018-10-31T16:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The name of the service.
   * 
   * @example
   * dcdn
   */
  product?: string;
  /**
   * @remarks
   * The time when the metering method takes effect.
   * 
   * @example
   * 2018-10-30T16:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      billType: 'BillType',
      billingCycle: 'BillingCycle',
      dimension: 'Dimension',
      endTime: 'EndTime',
      product: 'Product',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      billType: 'string',
      billingCycle: 'string',
      dimension: 'string',
      endTime: 'string',
      product: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserBillTypeResponseBodyBillTypeData extends $tea.Model {
  billTypeDataItem?: DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem[];
  static names(): { [key: string]: string } {
    return {
      billTypeDataItem: 'BillTypeDataItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      billTypeDataItem: { 'type': 'array', 'itemType': DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserConfigsResponseBodyConfigs extends $tea.Model {
  /**
   * @remarks
   * The name of the configuration.
   * 
   * The configuration is specified by enterprise users and public service sectors.
   * 
   * @example
   * allow_function
   */
  argName?: string;
  /**
   * @remarks
   * The value of the configuration. Valid values:
   * 
   * *   cc_rule: HTTP flood protection
   * *   ddos_dispatch: DDoS mitigation
   * *   edge_safe: application security on points of presence (POPs)
   * *   blocked_regions: region blacklist
   * *   http_acl_policy: precise access control
   * *   bot_manager: bot traffic management
   * *   ip_reputation: IP reputation library
   * 
   * @example
   * {\\"dcdn_allow\\":[\\"cc_rule\\",\\"ddos_dispatch\\"]}
   */
  argValue?: string;
  /**
   * @remarks
   * The name of the feature.
   * 
   * @example
   * domain_business_control
   */
  functionName?: string;
  static names(): { [key: string]: string } {
    return {
      argName: 'ArgName',
      argValue: 'ArgValue',
      functionName: 'FunctionName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      argName: 'string',
      argValue: 'string',
      functionName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserDomainsRequestTag extends $tea.Model {
  /**
   * @remarks
   * The tag key. Valid values of N: **1** to **20**. You can call the TagDcdnResources operation to set a tag for a domain name.
   * 
   * @example
   * 1
   */
  key?: string;
  /**
   * @remarks
   * The tag value. Valid values of N: **1** to **20**.
   * 
   * @example
   * 1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource extends $tea.Model {
  /**
   * @remarks
   * The address of the origin server.
   * 
   * @example
   * example.com
   */
  content?: string;
  /**
   * @remarks
   * The port of the origin server.
   * 
   * @example
   * 80
   */
  port?: number;
  /**
   * @remarks
   * The priority of the origin server.
   * 
   * @example
   * 20
   */
  priority?: string;
  /**
   * @remarks
   * The type of the origin server.
   * 
   * @example
   * oss
   */
  type?: string;
  /**
   * @remarks
   * The weight of the origin server.
   * 
   * @example
   * 20
   */
  weight?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      port: 'Port',
      priority: 'Priority',
      type: 'Type',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      port: 'number',
      priority: 'string',
      type: 'string',
      weight: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserDomainsResponseBodyDomainsPageDataSources extends $tea.Model {
  source?: DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource[];
  static names(): { [key: string]: string } {
    return {
      source: 'Source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      source: { 'type': 'array', 'itemType': DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserDomainsResponseBodyDomainsPageData extends $tea.Model {
  /**
   * @remarks
   * The CNAME of the domain.
   * 
   * @example
   * test.aliyun.com.w.alikunlun.com
   */
  cname?: string;
  /**
   * @remarks
   * The reason why the domain failed the review.
   * 
   * @example
   * audit failed
   */
  description?: string;
  /**
   * @remarks
   * The domain ID.
   * 
   * @example
   * 11223344
   */
  domainId?: number;
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * www.example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The domain status.
   * 
   * *   **online**: The domain is active.
   * *   **offline**: The domain is suspended.
   * *   **configuring**: The domain is being configured.
   * *   **configure_failed**: The domain failed to be configured.
   * *   **checking**: The domain is under review.
   * *   **check_failed**: The domain failed the review.
   * 
   * @example
   * online
   */
  domainStatus?: string;
  /**
   * @remarks
   * The computing service type. Valid values:
   * 
   * *   **routine**
   * *   **image**
   * *   **cloudFunction**
   * 
   * @example
   * routine
   */
  functionType?: string;
  /**
   * @remarks
   * The time when the domain was added to DCDN.
   * 
   * @example
   * 2015-10-28T11:05:50Z
   */
  gmtCreated?: string;
  /**
   * @remarks
   * The time when the domain was modified.
   * 
   * @example
   * 2015-10-28T09:31:59Z
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfmv6jutt**
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * Indicates whether HTTPS was enabled.
   * 
   * *   **on**: enabled.
   * *   **off**: disabled.
   * 
   * @example
   * on
   */
  SSLProtocol?: string;
  /**
   * @remarks
   * The sandbox status.
   * 
   * @example
   * normal
   */
  sandbox?: string;
  /**
   * @remarks
   * The acceleration scenario. Valid values:
   * 
   * *   **apiscene**: accelerates response to API calls.
   * *   **webservicescene**: accelerates content delivery for websites.
   * *   **staticscene**: accelerates the delivery of videos, images, and text.
   * *   **If you leave this parameter empty, no scenarios are supported.
   * 
   * @example
   * apiscene
   */
  scene?: string;
  /**
   * @remarks
   * The information about the origin servers.
   */
  sources?: DescribeDcdnUserDomainsResponseBodyDomainsPageDataSources;
  static names(): { [key: string]: string } {
    return {
      cname: 'Cname',
      description: 'Description',
      domainId: 'DomainId',
      domainName: 'DomainName',
      domainStatus: 'DomainStatus',
      functionType: 'FunctionType',
      gmtCreated: 'GmtCreated',
      gmtModified: 'GmtModified',
      resourceGroupId: 'ResourceGroupId',
      SSLProtocol: 'SSLProtocol',
      sandbox: 'Sandbox',
      scene: 'Scene',
      sources: 'Sources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cname: 'string',
      description: 'string',
      domainId: 'number',
      domainName: 'string',
      domainStatus: 'string',
      functionType: 'string',
      gmtCreated: 'string',
      gmtModified: 'string',
      resourceGroupId: 'string',
      SSLProtocol: 'string',
      sandbox: 'string',
      scene: 'string',
      sources: DescribeDcdnUserDomainsResponseBodyDomainsPageDataSources,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserDomainsResponseBodyDomains extends $tea.Model {
  pageData?: DescribeDcdnUserDomainsResponseBodyDomainsPageData[];
  static names(): { [key: string]: string } {
    return {
      pageData: 'PageData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageData: { 'type': 'array', 'itemType': DescribeDcdnUserDomainsResponseBodyDomainsPageData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource extends $tea.Model {
  /**
   * @remarks
   * The origin server address.
   * 
   * @example
   * image.developer.aliyundoc.com
   */
  content?: string;
  /**
   * @remarks
   * The port of the origin server.
   * 
   * @example
   * 80
   */
  port?: number;
  /**
   * @remarks
   * The priority.
   * 
   * @example
   * 20
   */
  priority?: string;
  /**
   * @remarks
   * The type of the origin server.
   * 
   * @example
   * oss
   */
  type?: string;
  /**
   * @remarks
   * The weight of the origin server if multiple origin servers have been specified.
   * 
   * @example
   * 20
   */
  weight?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      port: 'Port',
      priority: 'Priority',
      type: 'Type',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      port: 'number',
      priority: 'string',
      type: 'string',
      weight: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSources extends $tea.Model {
  source?: DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource[];
  static names(): { [key: string]: string } {
    return {
      source: 'Source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      source: { 'type': 'array', 'itemType': DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData extends $tea.Model {
  /**
   * @remarks
   * The CNAME assigned to the accelerated domain name.
   * 
   * @example
   * example.com.w.alikunlun.net
   */
  cname?: string;
  /**
   * @remarks
   * The reason why the accelerated domain name failed the review.
   * 
   * @example
   * audit failed
   */
  description?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The status of the accelerated domain name. Valid values:
   * 
   * *   **online**
   * *   **offline**
   * *   **configuring**
   * *   **configure_failed**
   * *   **checking**
   * *   **check_failed**
   * 
   * @example
   * configure_failed
   */
  domainStatus?: string;
  /**
   * @remarks
   * The time when the accelerated domain name was added to Dynamic Content Delivery Network (DCDN).
   * 
   * @example
   * 2015-10-28T09:32:51Z
   */
  gmtCreated?: string;
  /**
   * @remarks
   * The time when the accelerated domain name was modified.
   * 
   * @example
   * 2015-10-28T11:05:50Z
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-acfmyuji4b6r4**
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * Indicates whether the accelerated domain name was in a sandbox.
   * 
   * @example
   * normal
   */
  sandbox?: string;
  /**
   * @remarks
   * The information about the origin servers.
   */
  sources?: DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSources;
  /**
   * @remarks
   * Indicates whether HTTPS is enabled. Valid values:
   * 
   * *   **on**: HTTPS is enabled.
   * *   **off**: HTTPS is disabled.
   * 
   * @example
   * on
   */
  sslProtocol?: string;
  static names(): { [key: string]: string } {
    return {
      cname: 'Cname',
      description: 'Description',
      domainName: 'DomainName',
      domainStatus: 'DomainStatus',
      gmtCreated: 'GmtCreated',
      gmtModified: 'GmtModified',
      resourceGroupId: 'ResourceGroupId',
      sandbox: 'Sandbox',
      sources: 'Sources',
      sslProtocol: 'SslProtocol',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cname: 'string',
      description: 'string',
      domainName: 'string',
      domainStatus: 'string',
      gmtCreated: 'string',
      gmtModified: 'string',
      resourceGroupId: 'string',
      sandbox: 'string',
      sources: DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSources,
      sslProtocol: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserDomainsByFuncResponseBodyDomains extends $tea.Model {
  pageData?: DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData[];
  static names(): { [key: string]: string } {
    return {
      pageData: 'PageData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageData: { 'type': 'array', 'itemType': DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContentFields extends $tea.Model {
  /**
   * @remarks
   * The description of the field.
   * 
   * @example
   * The timestamp of the request
   */
  description?: string;
  /**
   * @remarks
   * The name of the field.
   * 
   * @example
   * unixtime
   */
  fieldName?: string;
  /**
   * @remarks
   * Indicates whether the field was selected.
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  selected?: boolean;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      fieldName: 'FieldName',
      selected: 'Selected',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      fieldName: 'string',
      selected: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContent extends $tea.Model {
  fields?: DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContentFields[];
  static names(): { [key: string]: string } {
    return {
      fields: 'Fields',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fields: { 'type': 'array', 'itemType': DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContentFields },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo extends $tea.Model {
  /**
   * @remarks
   * The commodity code of the resource plan.
   * 
   * @example
   * dcdnpaybag
   */
  commodityCode?: string;
  /**
   * @remarks
   * The remaining quota of the resource plan.
   * 
   * *   The unit for traffic: bytes.
   * *   The unit for requests: count.
   * 
   * @example
   * 10000000
   */
  currCapacity?: string;
  /**
   * @remarks
   * The name of the resource plan.
   * 
   * @example
   * HTTPS requests for static content
   */
  displayName?: string;
  /**
   * @remarks
   * The expiration time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2022-08-24T16:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The total quota of the resource plan.
   * 
   * *   The unit for traffic: bytes.
   * *   The unit for requests: count.
   * 
   * @example
   * 10000000
   */
  initCapacity?: string;
  /**
   * @remarks
   * The ID of the resource plan.
   * 
   * @example
   * CDNFLOWBAG-cn-7pp2bihrb01ii0
   */
  instanceId?: string;
  /**
   * @remarks
   * The validation time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2021-08-24T04:09:22Z
   */
  startTime?: string;
  /**
   * @remarks
   * The status of the resource plan. Valid values:
   * 
   * *   **valid**: valid
   * *   **closed**: expired
   * 
   * @example
   * valid
   */
  status?: string;
  /**
   * @remarks
   * The name of the template.
   * 
   * @example
   * FPT_dcdnpaybag_deadlineAcc_1541151058
   */
  templateName?: string;
  static names(): { [key: string]: string } {
    return {
      commodityCode: 'CommodityCode',
      currCapacity: 'CurrCapacity',
      displayName: 'DisplayName',
      endTime: 'EndTime',
      initCapacity: 'InitCapacity',
      instanceId: 'InstanceId',
      startTime: 'StartTime',
      status: 'Status',
      templateName: 'TemplateName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commodityCode: 'string',
      currCapacity: 'string',
      displayName: 'string',
      endTime: 'string',
      initCapacity: 'string',
      instanceId: 'string',
      startTime: 'string',
      status: 'string',
      templateName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfos extends $tea.Model {
  resourcePackageInfo?: DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo[];
  static names(): { [key: string]: string } {
    return {
      resourcePackageInfo: 'ResourcePackageInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourcePackageInfo: { 'type': 'array', 'itemType': DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserSecDropByMinuteResponseBodyRows extends $tea.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.aliyundoc.com
   */
  domain?: string;
  /**
   * @remarks
   * The number of packets blocked within 5 minutes.
   * 
   * @example
   * 264
   */
  drops?: number;
  /**
   * @remarks
   * The object that triggered rate limiting.
   * 
   * @example
   * Normal Mode
   */
  object?: string;
  /**
   * @remarks
   * The rule that was triggered.
   * 
   * @example
   * Normal Mode
   */
  ruleName?: string;
  /**
   * @remarks
   * The security feature that blocked the packets.
   * 
   * @example
   * robot
   */
  secFunc?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2021-01-31T15:04:04Z
   */
  tmStr?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      drops: 'Drops',
      object: 'Object',
      ruleName: 'RuleName',
      secFunc: 'SecFunc',
      tmStr: 'TmStr',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      drops: 'number',
      object: 'string',
      ruleName: 'string',
      secFunc: 'string',
      tmStr: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserTagsResponseBodyTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * region
   */
  key?: string;
  /**
   * @remarks
   * The value of the tag that you want to query.
   */
  value?: string[];
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnUserVipsByDomainResponseBodyVips extends $tea.Model {
  vip?: string[];
  static names(): { [key: string]: string } {
    return {
      vip: 'Vip',
    };
  }

  static types(): { [key: string]: any } {
    return {
      vip: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafDefaultRulesResponseBodyContentRules extends $tea.Model {
  /**
   * @remarks
   * The default action of the rule. Valid values:
   * 
   * *   **monitor**
   * *   **deny**
   * *   **block**
   * 
   * @example
   * block
   */
  action?: string;
  /**
   * @remarks
   * The default configuration of the rule.
   * 
   * @example
   * {\\"wafGroupIds\\":\\"1012\\"}
   */
  config?: string;
  /**
   * @remarks
   * The default name of the rule.
   * 
   * @example
   * Default_WafGroup_Rule
   */
  name?: string;
  /**
   * @remarks
   * The default status of the rule. Valid values:
   * 
   * *   **on**
   * *   **off**
   * 
   * @example
   * on
   */
  status?: string;
  /**
   * @remarks
   * The type of the rule. Valid values:
   * 
   * *   **waf_group**: basic web protection.
   * *   **high_frequency**: high-frequency scanning blocking.
   * *   **directory_traversal**: directory traversal blocking.
   * *   **scan_tools**: scanner blocking.
   * 
   * @example
   * waf_group
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      config: 'Config',
      name: 'Name',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      config: 'string',
      name: 'string',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafDefaultRulesResponseBodyContent extends $tea.Model {
  /**
   * @remarks
   * The protection scenario. Valid values:
   * 
   * *   **waf_group**: basic web protection.
   * *   **anti_scan**: scan protection.
   * 
   * @example
   * anti_scan
   */
  defenseScene?: string;
  /**
   * @remarks
   * The rules.
   */
  rules?: DescribeDcdnWafDefaultRulesResponseBodyContentRules[];
  static names(): { [key: string]: string } {
    return {
      defenseScene: 'DefenseScene',
      rules: 'Rules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defenseScene: 'string',
      rules: { 'type': 'array', 'itemType': DescribeDcdnWafDefaultRulesResponseBodyContentRules },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafDomainResponseBodyOutPutDomains extends $tea.Model {
  /**
   * @remarks
   * The status of the ACL. Valid values:
   * 
   * *   0: disabled
   * *   1: enabled
   * 
   * @example
   * 1
   */
  aclStatus?: number;
  /**
   * @remarks
   * The status of protection against HTTP flood attacks. Valid values:
   * 
   * *   0: disabled
   * *   1: enabled
   * 
   * @example
   * 1
   */
  ccStatus?: number;
  /**
   * @remarks
   * The domain name that has WAF enabled.
   * 
   * @example
   * example.com
   */
  domain?: string;
  /**
   * @remarks
   * The status of the domain name. Valid values:
   * 
   * *   1: The domain name is added to WAF, or the domain name is valid.
   * *   10: The domain name is being added to WAF.
   * *   11: The domain name failed to be added to WAF.
   * 
   * @example
   * 1
   */
  status?: number;
  /**
   * @remarks
   * The status of WAF. Valid values:
   * 
   * *   0: disabled
   * *   1: enabled
   * 
   * @example
   * 1
   */
  wafStatus?: number;
  static names(): { [key: string]: string } {
    return {
      aclStatus: 'AclStatus',
      ccStatus: 'CcStatus',
      domain: 'Domain',
      status: 'Status',
      wafStatus: 'WafStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aclStatus: 'number',
      ccStatus: 'number',
      domain: 'string',
      status: 'number',
      wafStatus: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafDomainDetailResponseBodyDomainDefenseScenes extends $tea.Model {
  /**
   * @remarks
   * The type of the protection policy. Valid values:
   * 
   * *   waf_group: basic web protection
   * *   custom_acl: custom protection
   * *   whitelist: whitelist
   * 
   * @example
   * waf_group
   */
  defenseScene?: string;
  /**
   * @remarks
   * The ID of the protection policy.
   * 
   * @example
   * 10000002
   */
  policyId?: number;
  /**
   * @remarks
   * The IDs of the protection policy.
   * 
   * @example
   * 10000001,10000004
   */
  policyIds?: string;
  static names(): { [key: string]: string } {
    return {
      defenseScene: 'DefenseScene',
      policyId: 'PolicyId',
      policyIds: 'PolicyIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defenseScene: 'string',
      policyId: 'number',
      policyIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafDomainDetailResponseBodyDomain extends $tea.Model {
  /**
   * @remarks
   * The types of the protection policies.
   */
  defenseScenes?: DescribeDcdnWafDomainDetailResponseBodyDomainDefenseScenes[];
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  static names(): { [key: string]: string } {
    return {
      defenseScenes: 'DefenseScenes',
      domainName: 'DomainName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defenseScenes: { 'type': 'array', 'itemType': DescribeDcdnWafDomainDetailResponseBodyDomainDefenseScenes },
      domainName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafDomainsResponseBodyDomains extends $tea.Model {
  /**
   * @remarks
   * The header of IP address of the client that is connected to the point of presence (POP).
   * 
   * @example
   * X-Forwarded-For
   */
  clientIpTag?: string;
  /**
   * @remarks
   * The protected domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The number of protection policies that were configured for the protected domain name.
   * 
   * @example
   * 3
   */
  policyCount?: number;
  static names(): { [key: string]: string } {
    return {
      clientIpTag: 'ClientIpTag',
      domainName: 'DomainName',
      policyCount: 'PolicyCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientIpTag: 'string',
      domainName: 'string',
      policyCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbolRegexp extends $tea.Model {
  /**
   * @remarks
   * The error message returned when no items match the regular expression.
   * 
   * @example
   * Specify this field.
   */
  errMsg?: string;
  /**
   * @remarks
   * The regular expression.
   * 
   * @example
   * ^\\S+$
   */
  pattern?: string;
  static names(): { [key: string]: string } {
    return {
      errMsg: 'ErrMsg',
      pattern: 'Pattern',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errMsg: 'string',
      pattern: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol extends $tea.Model {
  /**
   * @remarks
   * The configurable attributes, which are bit-field variables that are shown in the following list.\\
   * For example, 1(00000001) indicates that case sensitivity can be enabled and stream match cannot be enabled, and 3(00000011) indicates that case sensitivity and stream match can be enabled.
   * 
   * *   Bit (low to high) - Description
   * *   1 - Case sensitivity
   * *   2 - Stream match
   * 
   * @example
   * 1
   */
  attributes?: number;
  /**
   * @remarks
   * The logical symbol that is displayed in the Dynamic Content Delivery Network (DCDN) console.
   * 
   * @example
   * Equal to one of multiple values.
   */
  description?: string;
  /**
   * @remarks
   * The maximum number of match items that can be returned. The value of this parameter varies based on the value of the Type parameter. Valid values:
   * 
   * *   If **multi** is returned for the Type parameter, the value of this parameter indicates the maximum number of match items.
   * *   If **single** is returned for the Type parameter, the value of this parameter is 1.
   * *   If **none** is returned for the Type parameter, the value of this parameter is 0.
   * 
   * @example
   * 50
   */
  maxLength?: number;
  /**
   * @remarks
   * The information about the regular expression.
   */
  regexp?: DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbolRegexp;
  /**
   * @remarks
   * The logical symbol that is passed to the backend.
   * 
   * @example
   * match-one
   */
  symbol?: string;
  /**
   * @remarks
   * The tips that are displayed in the match item.
   * 
   * @example
   * You can enter up to 50 tips. Press the Enter key.
   */
  tip?: string;
  /**
   * @remarks
   * The number of match items. Valid values:
   * 
   * *   multi: You can specify multiple match items.
   * *   single: You can specify only a match item.
   * *   none: no match items.
   * 
   * @example
   * multi
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      attributes: 'Attributes',
      description: 'Description',
      maxLength: 'MaxLength',
      regexp: 'Regexp',
      symbol: 'Symbol',
      tip: 'Tip',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attributes: 'number',
      description: 'string',
      maxLength: 'number',
      regexp: DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbolRegexp,
      symbol: 'string',
      tip: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafFilterInfoResponseBodyContentFields extends $tea.Model {
  /**
   * @remarks
   * The description of the match field. This parameter is not returned or is empty if no match fields are found.
   * 
   * @example
   * Custom Header
   */
  extendField?: string;
  /**
   * @remarks
   * The information about the logical symbol.
   */
  logicalSymbol?: DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol[];
  /**
   * @remarks
   * The match field.
   * 
   * @example
   * Header
   */
  matchField?: string;
  static names(): { [key: string]: string } {
    return {
      extendField: 'ExtendField',
      logicalSymbol: 'LogicalSymbol',
      matchField: 'MatchField',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extendField: 'string',
      logicalSymbol: { 'type': 'array', 'itemType': DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol },
      matchField: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafFilterInfoResponseBodyContent extends $tea.Model {
  /**
   * @remarks
   * The type of the protection policy. The value of this parameter is the same as that of the DefenseScenes parameter in the request.
   * 
   * @example
   * custom_acl
   */
  defenseScene?: string;
  /**
   * @remarks
   * The information about the match condition.
   */
  fields?: DescribeDcdnWafFilterInfoResponseBodyContentFields[];
  static names(): { [key: string]: string } {
    return {
      defenseScene: 'DefenseScene',
      fields: 'Fields',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defenseScene: 'string',
      fields: { 'type': 'array', 'itemType': DescribeDcdnWafFilterInfoResponseBodyContentFields },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafGeoInfoResponseBodyContentContinentsRegions extends $tea.Model {
  /**
   * @remarks
   * The name of the country or region.
   * 
   * @example
   * Beijing
   */
  name?: string;
  /**
   * @remarks
   * The code of the country or region.
   * 
   * @example
   * 110000
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafGeoInfoResponseBodyContentContinents extends $tea.Model {
  /**
   * @remarks
   * The district to which the country or region belongs.
   * 
   * @example
   * China
   */
  name?: string;
  /**
   * @remarks
   * The region information.
   */
  regions?: DescribeDcdnWafGeoInfoResponseBodyContentContinentsRegions[];
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      regions: 'Regions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      regions: { 'type': 'array', 'itemType': DescribeDcdnWafGeoInfoResponseBodyContentContinentsRegions },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafGeoInfoResponseBodyContent extends $tea.Model {
  /**
   * @remarks
   * The information about the country or region.
   */
  continents?: DescribeDcdnWafGeoInfoResponseBodyContentContinents[];
  /**
   * @remarks
   * The type of the region.
   * 
   * *   CN: China
   * *   Other: outside China
   * 
   * @example
   * CN
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      continents: 'Continents',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      continents: { 'type': 'array', 'itemType': DescribeDcdnWafGeoInfoResponseBodyContentContinents },
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafGroupResponseBodyRules extends $tea.Model {
  /**
   * @remarks
   * The type of the application. Valid values:
   * 
   * *   **0**: Common
   * *   **1**: WordPress
   * *   **2**: DedeCMS
   * *   **3**: Discuz
   * *   **4**: PHP CMS
   * *   **5**: ECShop
   * *   **6**: ShopEX
   * *   **7**: Drupal
   * *   **8**: Joomla
   * *   **9**: MetInfo
   * *   **10**: Struts2
   * *   **11**: Spring Boot
   * *   **12**: JBoss
   * *   **13**: WebLogic
   * *   **14**: WebSphere
   * *   **15**: Tomcat
   * *   **16**: Elastic Search
   * *   **18**: ThinkPHP
   * *   **19**: Fastjson
   * *   **20**: ImageMagick
   * *   **21**: PHPWind
   * *   **22**: phpMyAdmin
   * *   **23**: Resin
   * *   **24**: IIS
   * *   **99**: Others
   * 
   * @example
   * 1
   */
  applicationType?: number;
  /**
   * @remarks
   * The Common Vulnerabilities and Exposures (CVE) ID of the related vulnerability.
   * 
   * @example
   * CVE-2021-22945
   */
  cveId?: string;
  /**
   * @remarks
   * The CVE link.
   * 
   * @example
   * https://nxx.nxxx.gov/vuln/detail/CVE-2022-XXXX
   */
  cveUrl?: string;
  /**
   * @remarks
   * The description of the WAF rule.
   * 
   * @example
   * OK
   */
  description?: string;
  /**
   * @remarks
   * The time when the rule was modified.
   * 
   * @example
   * 2021-12-29T17:08:45Z
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the custom WAF rule.
   * 
   * @example
   * 100001
   */
  id?: number;
  /**
   * @remarks
   * The name of the WAF rule.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * Protection type Valid values:
   * 
   * *   **11**: SQL injection
   * *   **12**: cross-site scripting (XSS)
   * *   **13**: code execution
   * *   **14**: carriage return line feeds (CRLF)
   * *   **15**: local file inclusion
   * *   **16**: remote file inclusion
   * *   **17**: webshells
   * *   **19**: cross-site request forgery
   * *   **20**: others
   * *   **21**: SEMA
   * 
   * @example
   * 11
   */
  protectionType?: number;
  /**
   * @remarks
   * The risk level of the resources that do not comply with the managed rule. Valid values:
   * 
   * *   **1**: high risk
   * *   **2**: medium risk
   * *   **3**: low risk
   * 
   * @example
   * 2
   */
  riskLevel?: number;
  static names(): { [key: string]: string } {
    return {
      applicationType: 'ApplicationType',
      cveId: 'CveId',
      cveUrl: 'CveUrl',
      description: 'Description',
      gmtModified: 'GmtModified',
      id: 'Id',
      name: 'Name',
      protectionType: 'ProtectionType',
      riskLevel: 'RiskLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationType: 'number',
      cveId: 'string',
      cveUrl: 'string',
      description: 'string',
      gmtModified: 'string',
      id: 'number',
      name: 'string',
      protectionType: 'number',
      riskLevel: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafGroupsResponseBodyWafGroupsPolicies extends $tea.Model {
  /**
   * @remarks
   * The ID of the policy.
   * 
   * @example
   * 30000165
   */
  id?: number;
  /**
   * @remarks
   * The name of the policy.
   * 
   * @example
   * wasm-testmaster
   */
  name?: string;
  /**
   * @remarks
   * The type of the policy. Valid values:
   * 
   * *   **custom**: a custom policy
   * *   **default**: the default policy
   * 
   * @example
   * default
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafGroupsResponseBodyWafGroups extends $tea.Model {
  /**
   * @remarks
   * The time when the WAF rule group was modified.
   * 
   * @example
   * 2020-04-12 22:25:11
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the custom WAF rule group.
   * 
   * @example
   * 30000156
   */
  id?: number;
  /**
   * @remarks
   * The name of the WAF rule.
   * 
   * @example
   * DCDN-test-operation-reports-1
   */
  name?: string;
  /**
   * @remarks
   * The policy that is associated with the WAF rule group.
   */
  policies?: DescribeDcdnWafGroupsResponseBodyWafGroupsPolicies[];
  /**
   * @remarks
   * The number of WAF rules.
   * 
   * @example
   * 452
   */
  ruleCount?: number;
  /**
   * @remarks
   * Indicates whether to enable subscription. Valid values:
   * 
   * *   **on**
   * *   **off**
   * 
   * @example
   * on
   */
  subscribe?: string;
  /**
   * @remarks
   * The ID of the template.
   * 
   * @example
   * 1012
   */
  templateId?: number;
  static names(): { [key: string]: string } {
    return {
      gmtModified: 'GmtModified',
      id: 'Id',
      name: 'Name',
      policies: 'Policies',
      ruleCount: 'RuleCount',
      subscribe: 'Subscribe',
      templateId: 'TemplateId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtModified: 'string',
      id: 'number',
      name: 'string',
      policies: { 'type': 'array', 'itemType': DescribeDcdnWafGroupsResponseBodyWafGroupsPolicies },
      ruleCount: 'number',
      subscribe: 'string',
      templateId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafLogsResponseBodyDomainLogDetailsLogInfos extends $tea.Model {
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 2015-05-23T14:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The name of the log file.
   * 
   * @example
   * demo.aliyundoc.com_2015_05_23_2100_2200.xxxxxx.gz
   */
  logName?: string;
  /**
   * @remarks
   * The path of the log file.
   * 
   * @example
   * guide.aliyundoc.com-hangzhou.xxx
   */
  logPath?: string;
  /**
   * @remarks
   * The size of the log file. Unit: bytes.
   * 
   * @example
   * 258
   */
  logSize?: number;
  /**
   * @remarks
   * The beginning of the time range during which data was queried.
   * 
   * @example
   * 2015-05-23T13:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      logName: 'LogName',
      logPath: 'LogPath',
      logSize: 'LogSize',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      logName: 'string',
      logPath: 'string',
      logSize: 'number',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafLogsResponseBodyDomainLogDetailsPageInfos extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageIndex?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 20
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      pageIndex: 'PageIndex',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageIndex: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafLogsResponseBodyDomainLogDetails extends $tea.Model {
  /**
   * @remarks
   * The WAF domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The total number of entries returned on the current page.
   * 
   * @example
   * 10
   */
  logCount?: number;
  /**
   * @remarks
   * The log information.
   */
  logInfos?: DescribeDcdnWafLogsResponseBodyDomainLogDetailsLogInfos[];
  /**
   * @remarks
   * The page information.
   */
  pageInfos?: DescribeDcdnWafLogsResponseBodyDomainLogDetailsPageInfos;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      logCount: 'LogCount',
      logInfos: 'LogInfos',
      pageInfos: 'PageInfos',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      logCount: 'number',
      logInfos: { 'type': 'array', 'itemType': DescribeDcdnWafLogsResponseBodyDomainLogDetailsLogInfos },
      pageInfos: DescribeDcdnWafLogsResponseBodyDomainLogDetailsPageInfos,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafPoliciesResponseBodyPolicies extends $tea.Model {
  /**
   * @remarks
   * The type of the protection policy, which is the same as the DefenseScenes field in the QueryArgs parameter.
   * 
   * @example
   * custom_acl
   */
  defenseScene?: string;
  /**
   * @remarks
   * The number of domain names that use the protection policy.
   * 
   * @example
   * 22
   */
  domainCount?: number;
  /**
   * @remarks
   * The time when the protection policy was modified. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2021-12-29T17:08:45Z
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the protection policy.
   * 
   * @example
   * 100001
   */
  policyId?: number;
  /**
   * @remarks
   * The name of the protection policy.
   * 
   * @example
   * policy_test
   */
  policyName?: string;
  /**
   * @remarks
   * The status of the protection policy, which is the same as the PolicyStatus field in the QueryArgs parameter.
   * 
   * @example
   * on
   */
  policyStatus?: string;
  /**
   * @remarks
   * Indicates whether this protection policy is the default policy, which is the same as the PolicyType field in the QueryArgs parameter.
   * 
   * @example
   * default
   */
  policyType?: string;
  /**
   * @remarks
   * The number of protection rules in the protection policy.
   * 
   * @example
   * 9
   */
  ruleCount?: number;
  static names(): { [key: string]: string } {
    return {
      defenseScene: 'DefenseScene',
      domainCount: 'DomainCount',
      gmtModified: 'GmtModified',
      policyId: 'PolicyId',
      policyName: 'PolicyName',
      policyStatus: 'PolicyStatus',
      policyType: 'PolicyType',
      ruleCount: 'RuleCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defenseScene: 'string',
      domainCount: 'number',
      gmtModified: 'string',
      policyId: 'number',
      policyName: 'string',
      policyStatus: 'string',
      policyType: 'string',
      ruleCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafPolicyResponseBodyPolicy extends $tea.Model {
  /**
   * @remarks
   * The type of the protection policy. Valid values:
   * 
   * *   waf_group: basic web protection
   * *   custom_acl: custom protection
   * *   whitelist: whitelist
   * 
   * @example
   * waf_group
   */
  defenseScene?: string;
  /**
   * @remarks
   * The number of domain names that use the protection policy.
   * 
   * @example
   * 22
   */
  domainCount?: number;
  /**
   * @remarks
   * The time when the protection policy was modified. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2021-12-29T17:08:45Z
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the protection policy.
   * 
   * @example
   * 100001
   */
  policyId?: number;
  /**
   * @remarks
   * The name of the protection policy.
   * 
   * @example
   * policy_test
   */
  policyName?: string;
  /**
   * @remarks
   * The status of the protection policy. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  policyStatus?: string;
  /**
   * @remarks
   * Indicates whether the current policy is the default policy. Valid values:
   * 
   * *   default
   * *   custom
   * 
   * @example
   * default
   */
  policyType?: string;
  /**
   * @remarks
   * The protection rule configurations corresponding to the protection policy. The configurations only support Bot management. For more information, see [BatchCreateDcdnWafRules](~~BatchCreateDcdnWafRules~~).
   * 
   * @example
   * {     "type":"target_type",     "status":"on",     "config":{"target":"app"},     "action":""   }
   */
  ruleConfigs?: string;
  /**
   * @remarks
   * The number of protection rules in the protection policy.
   * 
   * @example
   * 9
   */
  ruleCount?: number;
  static names(): { [key: string]: string } {
    return {
      defenseScene: 'DefenseScene',
      domainCount: 'DomainCount',
      gmtModified: 'GmtModified',
      policyId: 'PolicyId',
      policyName: 'PolicyName',
      policyStatus: 'PolicyStatus',
      policyType: 'PolicyType',
      ruleConfigs: 'RuleConfigs',
      ruleCount: 'RuleCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defenseScene: 'string',
      domainCount: 'number',
      gmtModified: 'string',
      policyId: 'number',
      policyName: 'string',
      policyStatus: 'string',
      policyType: 'string',
      ruleConfigs: 'string',
      ruleCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafPolicyDomainsResponseBodyDomains extends $tea.Model {
  /**
   * @remarks
   * The accelerated domain name that is protected by the specified protection policy.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafPolicyValidDomainsResponseBodyDomainsPolicies extends $tea.Model {
  /**
   * @remarks
   * The ID of the rule.
   * 
   * @example
   * 10000002
   */
  id?: number;
  /**
   * @remarks
   * The name of the policy.
   * 
   * @example
   * test2
   */
  name?: string;
  /**
   * @remarks
   * The type of the policy.
   * 
   * @example
   * custom
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafPolicyValidDomainsResponseBodyDomains extends $tea.Model {
  /**
   * @remarks
   * The protected domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The policy that is bound to the domain name.
   */
  policies?: DescribeDcdnWafPolicyValidDomainsResponseBodyDomainsPolicies[];
  /**
   * @remarks
   * The ID of the protection policy.
   * 
   * @example
   * 1000001
   */
  policyId?: number;
  /**
   * @remarks
   * The name of the protection policy.
   * 
   * @example
   * test1
   */
  policyName?: string;
  /**
   * @remarks
   * Indicates whether the protection policy is the default policy. Valid values:
   * 
   * *   default: The protection policy is the default policy.
   * *   custom: The protection policy is not the default policy.
   * 
   * @example
   * default
   */
  policyType?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      policies: 'Policies',
      policyId: 'PolicyId',
      policyName: 'PolicyName',
      policyType: 'PolicyType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      policies: { 'type': 'array', 'itemType': DescribeDcdnWafPolicyValidDomainsResponseBodyDomainsPolicies },
      policyId: 'number',
      policyName: 'string',
      policyType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafRuleResponseBodyRule extends $tea.Model {
  /**
   * @remarks
   * The type of the protection policy. Valid values:
   * 
   * *   waf_group: basic web protection
   * *   custom_acl: custom protection
   * *   whitelist: IP address whitelist
   * 
   * @example
   * custom_acl
   */
  defenseScene?: string;
  /**
   * @remarks
   * The time when the scaling group was modified. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2021-12-29T17:08:45Z
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the protection policy.
   * 
   * @example
   * 200001
   */
  policyId?: number;
  /**
   * @remarks
   * The configurations of the protection rule.
   * 
   * @example
   * {\\"action\\":\\"monitor\\",\\"actionExternal\\":\\"{}\\",\\"ccStatus\\":1,\\"conditions\\":[{\\"key\\":\\"URL\\",\\"opValue\\":\\"eq\\",\\"targetKey\\":\\"request_uri\\",\\"values\\":\\"/example\\"},{\\"key\\":\\"Header\\",\\"opValue\\":\\"eq\\",\\"subKey\\":\\"trt\\",\\"targetKey\\":\\"header.trt\\",\\"values\\":\\"3333\\"}],\\"effect\\":\\"service\\",\\"name\\":\\"aaa333\\",\\"origin\\":\\"custom\\",\\"ratelimit\\":{\\"interval\\":5,\\"status\\":{\\"code\\":404,\\"count\\":2,\\"stat\\":{\\"mode\\":\\"count\\",\\"value\\":2.0}},\\"target\\":\\"remote_addr\\",\\"threshold\\":2,\\"ttl\\":1800}}
   */
  ruleConfig?: string;
  /**
   * @remarks
   * The ID of the protection rule.
   * 
   * @example
   * 100001
   */
  ruleId?: number;
  /**
   * @remarks
   * The name of the protection rule.
   * 
   * @example
   * rule_1
   */
  ruleName?: string;
  /**
   * @remarks
   * The status of the protection rule. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  ruleStatus?: string;
  static names(): { [key: string]: string } {
    return {
      defenseScene: 'DefenseScene',
      gmtModified: 'GmtModified',
      policyId: 'PolicyId',
      ruleConfig: 'RuleConfig',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      ruleStatus: 'RuleStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defenseScene: 'string',
      gmtModified: 'string',
      policyId: 'number',
      ruleConfig: 'string',
      ruleId: 'number',
      ruleName: 'string',
      ruleStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafRulesResponseBodyRules extends $tea.Model {
  /**
   * @remarks
   * The type of the protection policy. The value of this parameter is the same as that of the DefenseScene field in QueryArgst.
   * 
   * @example
   * custom_acl
   */
  defenseScene?: string;
  /**
   * @remarks
   * The time when the protection policy was last modified. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2021-12-29T17:08:45Z
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the protection policy.
   * 
   * @example
   * 200001
   */
  policyId?: number;
  /**
   * @remarks
   * The configuration information about the protection rule.
   * 
   * @example
   * {\\"action\\":\\"monitor\\",\\"actionExternal\\":\\"{}\\",\\"ccStatus\\":1,\\"conditions\\":[{\\"key\\":\\"URL\\",\\"opValue\\":\\"eq\\",\\"targetKey\\":\\"request_uri\\",\\"values\\":\\"/example\\"},{\\"key\\":\\"Header\\",\\"opValue\\":\\"eq\\",\\"subKey\\":\\"trt\\",\\"targetKey\\":\\"header.trt\\",\\"values\\":\\"3333\\"}],\\"effect\\":\\"service\\",\\"name\\":\\"aaa333\\",\\"origin\\":\\"custom\\",\\"ratelimit\\":{\\"interval\\":5,\\"status\\":{\\"code\\":404,\\"count\\":2,\\"stat\\":{\\"mode\\":\\"count\\",\\"value\\":2.0}},\\"target\\":\\"remote_addr\\",\\"threshold\\":2,\\"ttl\\":1800}}
   */
  ruleConfig?: string;
  /**
   * @remarks
   * The ID of the protection rule.
   * 
   * @example
   * 100001
   */
  ruleId?: number;
  /**
   * @remarks
   * The name of the protection rule.
   * 
   * @example
   * rule_1
   */
  ruleName?: string;
  /**
   * @remarks
   * The status of the protection rule. The value of this parameter is the same as that of the RuleStatus field in QueryArgst.
   * 
   * @example
   * on
   */
  ruleStatus?: string;
  static names(): { [key: string]: string } {
    return {
      defenseScene: 'DefenseScene',
      gmtModified: 'GmtModified',
      policyId: 'PolicyId',
      ruleConfig: 'RuleConfig',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      ruleStatus: 'RuleStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defenseScene: 'string',
      gmtModified: 'string',
      policyId: 'number',
      ruleConfig: 'string',
      ruleId: 'number',
      ruleName: 'string',
      ruleStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafScenesResponseBodyDefenseScenes extends $tea.Model {
  /**
   * @remarks
   * The type of the protection policy, which is the same as the DefenseScenes parameter in request parameters.
   * 
   * @example
   * waf_group
   */
  defenseScene?: string;
  /**
   * @remarks
   * The total number of policies of this type that were configured.
   * 
   * @example
   * 10
   */
  policyCount?: number;
  /**
   * @remarks
   * The total number of protection rules that were configured in this type of the policy.
   * 
   * @example
   * 12
   */
  ruleCount?: number;
  static names(): { [key: string]: string } {
    return {
      defenseScene: 'DefenseScene',
      policyCount: 'PolicyCount',
      ruleCount: 'RuleCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defenseScene: 'string',
      policyCount: 'number',
      ruleCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafSpecInfoResponseBodySpecInfosConfigs extends $tea.Model {
  /**
   * @remarks
   * The configuration code of the protection rule.
   * 
   * @example
   * enable
   */
  config?: string;
  /**
   * @remarks
   * The configuration expression of the protection rule.
   * 
   * @example
   * equal
   */
  expr?: string;
  /**
   * @remarks
   * The value of the configuration expression of the protection rule.
   * 
   * @example
   * on
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      expr: 'Expr',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      expr: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafSpecInfoResponseBodySpecInfos extends $tea.Model {
  /**
   * @remarks
   * The configuration information of the protection rule.
   */
  configs?: DescribeDcdnWafSpecInfoResponseBodySpecInfosConfigs[];
  /**
   * @remarks
   * The type of the protection policy. Valid values:
   * 
   * *   waf_group: basic web protection
   * *   custom_acl: custom
   * *   whitelist: whitelist
   * *   ip_blacklist: IP address blacklist
   * *   region_block: region blacklist
   * *   bot: bot management
   * 
   * @example
   * custom_acl
   */
  defenseScene?: string;
  static names(): { [key: string]: string } {
    return {
      configs: 'Configs',
      defenseScene: 'DefenseScene',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configs: { 'type': 'array', 'itemType': DescribeDcdnWafSpecInfoResponseBodySpecInfosConfigs },
      defenseScene: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem extends $tea.Model {
  /**
   * @remarks
   * The number of blocked requests.
   * 
   * @example
   * 600
   */
  accessCnt?: number;
  /**
   * @remarks
   * The number of allowed requests.
   * 
   * @example
   * 300
   */
  blockCnt?: number;
  /**
   * @remarks
   * The domain name that you want to query. If you do not specify an accelerated domain name, all accelerated domain names are queried by default.
   * 
   * @example
   * example.com
   */
  domain?: string;
  /**
   * @remarks
   * The end of the time range during which data was queried.
   * 
   * @example
   * 300
   */
  observeCnt?: number;
  /**
   * @remarks
   * The time granularity for a query. Unit: seconds.
   * 
   * The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day).
   * 
   * @example
   * 50
   */
  secCu?: number;
  /**
   * @remarks
   * The beginning of the time range during which data was queried.
   * 
   * @example
   * 2018-09-30T16:00:00Z
   */
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      accessCnt: 'AccessCnt',
      blockCnt: 'BlockCnt',
      domain: 'Domain',
      observeCnt: 'ObserveCnt',
      secCu: 'SecCu',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessCnt: 'number',
      blockCnt: 'number',
      domain: 'string',
      observeCnt: 'number',
      secCu: 'number',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnWafUsageDataResponseBodyWafUsageData extends $tea.Model {
  wafUsageDataItem?: DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem[];
  static names(): { [key: string]: string } {
    return {
      wafUsageDataItem: 'WafUsageDataItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      wafUsageDataItem: { 'type': 'array', 'itemType': DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnsecServiceResponseBodyOperationLocksLockReason extends $tea.Model {
  /**
   * @remarks
   * The reason why the instance was locked.
   * 
   * @example
   * financial
   */
  lockReason?: string;
  static names(): { [key: string]: string } {
    return {
      lockReason: 'LockReason',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lockReason: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDcdnsecServiceResponseBodyOperationLocks extends $tea.Model {
  lockReason?: DescribeDcdnsecServiceResponseBodyOperationLocksLockReason[];
  static names(): { [key: string]: string } {
    return {
      lockReason: 'LockReason',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lockReason: { 'type': 'array', 'itemType': DescribeDcdnsecServiceResponseBodyOperationLocksLockReason },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDdosAllEventListResponseBodyDataList extends $tea.Model {
  /**
   * @remarks
   * The peak attack traffic of volumetric attacks. Unit: bit/s.
   * 
   * @example
   * 800
   */
  bps?: number;
  /**
   * @remarks
   * The peak of connection flood attacks. Unit: connections per seconds (CPS).
   * 
   * @example
   * 50
   */
  cps?: number;
  /**
   * @remarks
   * The end of the time range during which data was queried. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2022-11-26T15:59:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The event ID.
   * 
   * @example
   * 28069
   */
  eventId?: string;
  /**
   * @remarks
   * The type of the DDoS attack event that was queried. Valid values:
   * 
   * *   **web-cc**: web resource exhaustion attacks
   * *   **cc**: connection flood attacks
   * *   **traffic**: volumetric attacks
   * *   If you do not configure this parameter, DDoS attack events of all types are queried.
   * 
   * @example
   * web-cc
   */
  eventType?: string;
  /**
   * @remarks
   * The peak attack traffic of volumetric attacks. Unit: packets per second (PPS).
   * 
   * @example
   * 12000
   */
  pps?: number;
  /**
   * @remarks
   * The peak of web resource exhaustion attacks. Unit: queries per second (QPS).
   * 
   * @example
   * 7692
   */
  qps?: number;
  /**
   * @remarks
   * The beginning of the time range during which data was queried. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2022-10-09T10:03:31Z
   */
  startTime?: string;
  /**
   * @remarks
   * The attack target.
   * 
   * @example
   * example.com
   */
  target?: string;
  static names(): { [key: string]: string } {
    return {
      bps: 'Bps',
      cps: 'Cps',
      endTime: 'EndTime',
      eventId: 'EventId',
      eventType: 'EventType',
      pps: 'Pps',
      qps: 'Qps',
      startTime: 'StartTime',
      target: 'Target',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bps: 'number',
      cps: 'number',
      endTime: 'string',
      eventId: 'string',
      eventType: 'string',
      pps: 'number',
      qps: 'number',
      startTime: 'string',
      target: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHighlightInfoResponseBodyDataModule extends $tea.Model {
  /**
   * @remarks
   * The highlighted data.
   * 
   * @example
   * [\\"data:image/php;base64\\"]
   */
  hit?: string;
  /**
   * @remarks
   * The type of the highlighted data.
   * 
   * @example
   * URL
   */
  key?: string;
  /**
   * @remarks
   * The complete data.
   * 
   * @example
   * data:image/php;base64,PD9waHAXXXXXXanVzdHR0dHXXXXXB0ZXN0Ijs/Pg==
   */
  raw?: string;
  static names(): { [key: string]: string } {
    return {
      hit: 'Hit',
      key: 'Key',
      raw: 'Raw',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hit: 'string',
      key: 'string',
      raw: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeKvUsageDataResponseBodyKvUsageData extends $tea.Model {
  /**
   * @remarks
   * The number of visits.
   * 
   * @example
   * 1340000
   */
  acc?: number;
  /**
   * @remarks
   * The request method. This parameter is available only when the **SplitBy** parameter is set to **type**.
   * 
   * @example
   * get
   */
  accessType?: string;
  /**
   * @remarks
   * The namespace ID. This parameter is available only when the **SplitBy** parameter is set to **namespace**.
   * 
   * @example
   * 534167033424646144
   */
  namespaceId?: string;
  /**
   * @remarks
   * The timestamp of the data returned.
   * 
   * @example
   * 2022-11-14T15:00:03Z
   */
  timeStamp?: string;
  static names(): { [key: string]: string } {
    return {
      acc: 'Acc',
      accessType: 'AccessType',
      namespaceId: 'NamespaceId',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acc: 'number',
      accessType: 'string',
      namespaceId: 'string',
      timeStamp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRDDomainConfigResponseBodyDomainConfigsFunctionArgs extends $tea.Model {
  /**
   * @remarks
   * The name of the configuration.
   * 
   * @example
   * source_group_name
   */
  argName?: string;
  /**
   * @remarks
   * The value of the configuration.
   * 
   * @example
   * 123
   */
  argValue?: string;
  static names(): { [key: string]: string } {
    return {
      argName: 'ArgName',
      argValue: 'ArgValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      argName: 'string',
      argValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRDDomainConfigResponseBodyDomainConfigs extends $tea.Model {
  /**
   * @remarks
   * The ID of the configuration.
   * 
   * @example
   * 6295
   */
  configId?: number;
  /**
   * @remarks
   * The configurations of the features.
   */
  functionArgs?: DescribeRDDomainConfigResponseBodyDomainConfigsFunctionArgs[];
  /**
   * @remarks
   * The name of the feature.
   * 
   * @example
   * set_req_host_header
   */
  functionName?: string;
  /**
   * @remarks
   * The ID of the advanced condition configuration.
   * 
   * @example
   * 1234567
   */
  parentId?: string;
  /**
   * @remarks
   * The status. Valid values:
   * 
   * *   **success**
   * *   **testing**
   * *   **failed**
   * *   **configuring**
   * 
   * @example
   * success
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      functionArgs: 'FunctionArgs',
      functionName: 'FunctionName',
      parentId: 'ParentId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      functionArgs: { 'type': 'array', 'itemType': DescribeRDDomainConfigResponseBodyDomainConfigsFunctionArgs },
      functionName: 'string',
      parentId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRDDomainsResponseBodyDomainsPageDataSourcesSource extends $tea.Model {
  /**
   * @remarks
   * The address of the origin server.
   * 
   * @example
   * example.aliyundoc.com
   */
  content?: string;
  /**
   * @remarks
   * The port of the origin server.
   * 
   * @example
   * 80
   */
  port?: number;
  /**
   * @remarks
   * The priority.
   * 
   * @example
   * 20
   */
  priority?: string;
  /**
   * @remarks
   * The type of the origin server.
   * 
   * @example
   * oss
   */
  type?: string;
  /**
   * @remarks
   * The origin server weight if multiple origin servers have been specified.
   * 
   * @example
   * 20
   */
  weight?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      port: 'Port',
      priority: 'Priority',
      type: 'Type',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      port: 'number',
      priority: 'string',
      type: 'string',
      weight: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRDDomainsResponseBodyDomainsPageDataSources extends $tea.Model {
  source?: DescribeRDDomainsResponseBodyDomainsPageDataSourcesSource[];
  static names(): { [key: string]: string } {
    return {
      source: 'Source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      source: { 'type': 'array', 'itemType': DescribeRDDomainsResponseBodyDomainsPageDataSourcesSource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRDDomainsResponseBodyDomainsPageData extends $tea.Model {
  bizName?: string;
  /**
   * @remarks
   * The CNAME assigned to the accelerated domain name.
   * 
   * @example
   * image.developer.aliyundoc.com
   */
  cname?: string;
  /**
   * @remarks
   * The reason why the accelerated domain name failed the review.
   * 
   * @example
   * audit failed
   */
  description?: string;
  /**
   * @remarks
   * The accelerated domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The status of the accelerated domain name. Valid values:
   * 
   * *   online: The domain name is enabled.
   * *   offline: The domain name is disabled.
   * *   configuring: The domain name is being configured.
   * *   configure_failed: The domain name failed to be configured.
   * *   checking: The domain name is being reviewed.
   * *   check_failed: The domain name failed the review.
   * 
   * @example
   * online
   */
  domainStatus?: string;
  /**
   * @remarks
   * The time when the accelerated domain name was added to DCDN.
   * 
   * @example
   * 2015-10-27T06:26:34Z
   */
  gmtCreated?: string;
  /**
   * @remarks
   * The time when the accelerated domain name was modified.
   * 
   * @example
   * 2015-10-23T09:30:00Z
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * abcd1234abcd1234
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * Indicates whether the accelerated domain name was in a sandbox.
   * 
   * @example
   * normal
   */
  sandbox?: string;
  serviceCode?: string;
  /**
   * @remarks
   * The information about the origin server.
   */
  sources?: DescribeRDDomainsResponseBodyDomainsPageDataSources;
  /**
   * @remarks
   * Indicates whether HTTPS is enabled.
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  sslProtocol?: string;
  static names(): { [key: string]: string } {
    return {
      bizName: 'BizName',
      cname: 'Cname',
      description: 'Description',
      domainName: 'DomainName',
      domainStatus: 'DomainStatus',
      gmtCreated: 'GmtCreated',
      gmtModified: 'GmtModified',
      resourceGroupId: 'ResourceGroupId',
      sandbox: 'Sandbox',
      serviceCode: 'ServiceCode',
      sources: 'Sources',
      sslProtocol: 'SslProtocol',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizName: 'string',
      cname: 'string',
      description: 'string',
      domainName: 'string',
      domainStatus: 'string',
      gmtCreated: 'string',
      gmtModified: 'string',
      resourceGroupId: 'string',
      sandbox: 'string',
      serviceCode: 'string',
      sources: DescribeRDDomainsResponseBodyDomainsPageDataSources,
      sslProtocol: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRDDomainsResponseBodyDomains extends $tea.Model {
  pageData?: DescribeRDDomainsResponseBodyDomainsPageData[];
  static names(): { [key: string]: string } {
    return {
      pageData: 'PageData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageData: { 'type': 'array', 'itemType': DescribeRDDomainsResponseBodyDomainsPageData },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDcdnKvResponseBodyKeys extends $tea.Model {
  /**
   * @remarks
   * The value of the key obtained in this traversal.
   * 
   * @example
   * Key1
   */
  name?: string;
  /**
   * @remarks
   * The time when the key was updated.
   * 
   * @example
   * 2021-12-13T07:46:03Z
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects extends $tea.Model {
  /**
   * @remarks
   * The type of the collected logs. Default value: cdn_log_access_l1. Valid values:
   * 
   * *   **cdn_log_access_l1**: access logs of DCDN POPs
   * *   **cdn_log_origin**: back-to-origin logs
   * *   **cdn_log_er**: EdgeRoutine logs
   * 
   * @example
   * cdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The region from which logs were collected.
   * 
   * @example
   * cn
   */
  dataCenter?: string;
  /**
   * @remarks
   * The domain names from which logs were collected. You can specify one or more domain names. Separate multiple domain names with commas (,).
   * 
   * @example
   * example.com,example.org
   */
  domainName?: string;
  /**
   * @remarks
   * The name of the field. For more information about fields in real-time log entries, see [Fields in a real-time log](https://help.aliyun.com/document_detail/324199.html).
   * 
   * @example
   * field1,field2
   */
  fieldName?: string;
  /**
   * @remarks
   * The name of the project.
   * 
   * @example
   * example
   */
  projectName?: string;
  /**
   * @remarks
   * The name of the Logstore.
   * 
   * @example
   * example-cn
   */
  SLSLogStore?: string;
  /**
   * @remarks
   * The name of the log file.
   * 
   * @example
   * example-cn
   */
  SLSProject?: string;
  /**
   * @remarks
   * The region to which logs were delivered.
   * 
   * @example
   * cn-hangzhou
   */
  SLSRegion?: string;
  /**
   * @remarks
   * The sampling rate.
   * 
   * @example
   * 1
   */
  samplingRate?: number;
  /**
   * @remarks
   * The type of log delivery. Only **SLS_POST** is supported.
   * 
   * @example
   * SLS_POST
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      dataCenter: 'DataCenter',
      domainName: 'DomainName',
      fieldName: 'FieldName',
      projectName: 'ProjectName',
      SLSLogStore: 'SLSLogStore',
      SLSProject: 'SLSProject',
      SLSRegion: 'SLSRegion',
      samplingRate: 'SamplingRate',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      dataCenter: 'string',
      domainName: 'string',
      fieldName: 'string',
      projectName: 'string',
      SLSLogStore: 'string',
      SLSProject: 'string',
      SLSRegion: 'string',
      samplingRate: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDcdnRealTimeDeliveryProjectResponseBodyContent extends $tea.Model {
  projects?: ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects[];
  static names(): { [key: string]: string } {
    return {
      projects: 'Projects',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projects: { 'type': 'array', 'itemType': ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagDcdnResourcesRequestTag extends $tea.Model {
  /**
   * @remarks
   * The key of the tag. Valid values of N: **1** to **20**.
   * 
   * This parameter is required.
   * 
   * @example
   * env
   */
  key?: string;
  /**
   * @remarks
   * The value of a tag. Valid values of N: **1** to **20**.
   * 
   * @example
   * value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContentDomains extends $tea.Model {
  /**
   * @remarks
   * The description of the returned result.
   * 
   * @example
   * created
   */
  desc?: string;
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domainName?: string;
  /**
   * @remarks
   * The name of the region.
   * 
   * @example
   * cn
   */
  region?: string;
  /**
   * @remarks
   * Indicates whether the real-time log delivery project was successfully updated. Valid values:
   * 
   * *   **success**
   * *   **fail**
   * 
   * @example
   * success
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      desc: 'Desc',
      domainName: 'DomainName',
      region: 'Region',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desc: 'string',
      domainName: 'string',
      region: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContent extends $tea.Model {
  domains?: UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContentDomains[];
  static names(): { [key: string]: string } {
    return {
      domains: 'Domains',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domains: { 'type': 'array', 'itemType': UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContentDomains },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends OpenApi {

  constructor(config: $OpenApi.Config) {
    super(config);
    this._endpointRule = "regional";
    this._endpointMap = {
      'ap-northeast-1': "dcdn.aliyuncs.com",
      'ap-northeast-2-pop': "dcdn.aliyuncs.com",
      'ap-south-1': "dcdn.aliyuncs.com",
      'ap-southeast-1': "dcdn.aliyuncs.com",
      'ap-southeast-2': "dcdn.aliyuncs.com",
      'ap-southeast-3': "dcdn.aliyuncs.com",
      'ap-southeast-5': "dcdn.aliyuncs.com",
      'cn-beijing': "dcdn.aliyuncs.com",
      'cn-beijing-finance-1': "dcdn.aliyuncs.com",
      'cn-beijing-finance-pop': "dcdn.aliyuncs.com",
      'cn-beijing-gov-1': "dcdn.aliyuncs.com",
      'cn-beijing-nu16-b01': "dcdn.aliyuncs.com",
      'cn-chengdu': "dcdn.aliyuncs.com",
      'cn-edge-1': "dcdn.aliyuncs.com",
      'cn-fujian': "dcdn.aliyuncs.com",
      'cn-haidian-cm12-c01': "dcdn.aliyuncs.com",
      'cn-hangzhou': "dcdn.aliyuncs.com",
      'cn-hangzhou-bj-b01': "dcdn.aliyuncs.com",
      'cn-hangzhou-finance': "dcdn.aliyuncs.com",
      'cn-hangzhou-internal-prod-1': "dcdn.aliyuncs.com",
      'cn-hangzhou-internal-test-1': "dcdn.aliyuncs.com",
      'cn-hangzhou-internal-test-2': "dcdn.aliyuncs.com",
      'cn-hangzhou-internal-test-3': "dcdn.aliyuncs.com",
      'cn-hangzhou-test-306': "dcdn.aliyuncs.com",
      'cn-hongkong': "dcdn.aliyuncs.com",
      'cn-hongkong-finance-pop': "dcdn.aliyuncs.com",
      'cn-huhehaote': "dcdn.aliyuncs.com",
      'cn-north-2-gov-1': "dcdn.aliyuncs.com",
      'cn-qingdao': "dcdn.aliyuncs.com",
      'cn-qingdao-nebula': "dcdn.aliyuncs.com",
      'cn-shanghai': "dcdn.aliyuncs.com",
      'cn-shanghai-et15-b01': "dcdn.aliyuncs.com",
      'cn-shanghai-et2-b01': "dcdn.aliyuncs.com",
      'cn-shanghai-finance-1': "dcdn.aliyuncs.com",
      'cn-shanghai-inner': "dcdn.aliyuncs.com",
      'cn-shanghai-internal-test-1': "dcdn.aliyuncs.com",
      'cn-shenzhen': "dcdn.aliyuncs.com",
      'cn-shenzhen-finance-1': "dcdn.aliyuncs.com",
      'cn-shenzhen-inner': "dcdn.aliyuncs.com",
      'cn-shenzhen-st4-d01': "dcdn.aliyuncs.com",
      'cn-shenzhen-su18-b01': "dcdn.aliyuncs.com",
      'cn-wuhan': "dcdn.aliyuncs.com",
      'cn-yushanfang': "dcdn.aliyuncs.com",
      'cn-zhangbei-na61-b01': "dcdn.aliyuncs.com",
      'cn-zhangjiakou': "dcdn.aliyuncs.com",
      'cn-zhangjiakou-na62-a01': "dcdn.aliyuncs.com",
      'cn-zhengzhou-nebula-1': "dcdn.aliyuncs.com",
      'eu-central-1': "dcdn.aliyuncs.com",
      'eu-west-1': "dcdn.aliyuncs.com",
      'eu-west-1-oxs': "dcdn.aliyuncs.com",
      'me-east-1': "dcdn.aliyuncs.com",
      'rus-west-1-pop': "dcdn.aliyuncs.com",
      'us-east-1': "dcdn.aliyuncs.com",
      'us-west-1': "dcdn.aliyuncs.com",
    };
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("dcdn", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!Util.empty(endpoint)) {
      return endpoint;
    }

    if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  /**
   * Adds a domain name to accelerate. You can specify only one domain name in each request.
   * 
   * @remarks
   * > *   Dynamic Content Delivery Network (DCDN) is activated.
   * > *   Internet content provider (ICP) filing is complete for the accelerated domain name.
   * > *   If the content of the origin server is not stored on Alibaba Cloud, the content must be reviewed. After you submit the request, the review is complete by the end of the following business day.
   * > *   You can call this operation up to 30 times per second per account.
   * 
   * @param request - AddDcdnDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddDcdnDomainResponse
   */
  async addDcdnDomainWithOptions(request: AddDcdnDomainRequest, runtime: $Util.RuntimeOptions): Promise<AddDcdnDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkUrl)) {
      query["CheckUrl"] = request.checkUrl;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.functionType)) {
      query["FunctionType"] = request.functionType;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.scene)) {
      query["Scene"] = request.scene;
    }

    if (!Util.isUnset(request.scope)) {
      query["Scope"] = request.scope;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.sources)) {
      query["Sources"] = request.sources;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.topLevelDomain)) {
      query["TopLevelDomain"] = request.topLevelDomain;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddDcdnDomain",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddDcdnDomainResponse>(await this.callApi(params, req, runtime), new AddDcdnDomainResponse({}));
  }

  /**
   * Adds a domain name to accelerate. You can specify only one domain name in each request.
   * 
   * @remarks
   * > *   Dynamic Content Delivery Network (DCDN) is activated.
   * > *   Internet content provider (ICP) filing is complete for the accelerated domain name.
   * > *   If the content of the origin server is not stored on Alibaba Cloud, the content must be reviewed. After you submit the request, the review is complete by the end of the following business day.
   * > *   You can call this operation up to 30 times per second per account.
   * 
   * @param request - AddDcdnDomainRequest
   * @returns AddDcdnDomainResponse
   */
  async addDcdnDomain(request: AddDcdnDomainRequest): Promise<AddDcdnDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addDcdnDomainWithOptions(request, runtime);
  }

  /**
   * Adds a domain name to IPA. You can specify only one domain name in each request.
   * 
   * @remarks
   * > 
   * *   Make sure that the IPA service is activated before you add a domain name to accelerate.
   * *   Make sure that the Internet content provider (ICP) filling is complete for the domain name to accelerate.
   * *   If the content on the origin server is not stored on Alibaba Cloud, the content must be reviewed. The review is complete by the end of the next business day after you submit the request.
   * *   You can call this operation up to 10 times per second per user.
   * 
   * @param request - AddDcdnIpaDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddDcdnIpaDomainResponse
   */
  async addDcdnIpaDomainWithOptions(request: AddDcdnIpaDomainRequest, runtime: $Util.RuntimeOptions): Promise<AddDcdnIpaDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkUrl)) {
      query["CheckUrl"] = request.checkUrl;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.protocol)) {
      query["Protocol"] = request.protocol;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.scope)) {
      query["Scope"] = request.scope;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.sources)) {
      query["Sources"] = request.sources;
    }

    if (!Util.isUnset(request.topLevelDomain)) {
      query["TopLevelDomain"] = request.topLevelDomain;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddDcdnIpaDomain",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddDcdnIpaDomainResponse>(await this.callApi(params, req, runtime), new AddDcdnIpaDomainResponse({}));
  }

  /**
   * Adds a domain name to IPA. You can specify only one domain name in each request.
   * 
   * @remarks
   * > 
   * *   Make sure that the IPA service is activated before you add a domain name to accelerate.
   * *   Make sure that the Internet content provider (ICP) filling is complete for the domain name to accelerate.
   * *   If the content on the origin server is not stored on Alibaba Cloud, the content must be reviewed. The review is complete by the end of the next business day after you submit the request.
   * *   You can call this operation up to 10 times per second per user.
   * 
   * @param request - AddDcdnIpaDomainRequest
   * @returns AddDcdnIpaDomainResponse
   */
  async addDcdnIpaDomain(request: AddDcdnIpaDomainRequest): Promise<AddDcdnIpaDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addDcdnIpaDomainWithOptions(request, runtime);
  }

  /**
   * Adds one or more domain names to DCDN at a time.
   * 
   * @remarks
   * *Prerequisites**:
   * *   The [DCDN service is activated](https://help.aliyun.com/document_detail/64926.html).
   * *   Internet content provider (ICP) filing is complete for the accelerated domain names.
   * > *   If the content of the origin server is not stored on Alibaba Cloud, the content must be reviewed. After you submit the request, the review is complete by the end of the following business day.
   * >*   You can specify up to 50 domain names in each request.
   * >*   You can call this operation up to 30 times per second per account.
   * 
   * @param request - BatchAddDcdnDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchAddDcdnDomainResponse
   */
  async batchAddDcdnDomainWithOptions(request: BatchAddDcdnDomainRequest, runtime: $Util.RuntimeOptions): Promise<BatchAddDcdnDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkUrl)) {
      query["CheckUrl"] = request.checkUrl;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.scope)) {
      query["Scope"] = request.scope;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.sources)) {
      query["Sources"] = request.sources;
    }

    if (!Util.isUnset(request.topLevelDomain)) {
      query["TopLevelDomain"] = request.topLevelDomain;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchAddDcdnDomain",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchAddDcdnDomainResponse>(await this.callApi(params, req, runtime), new BatchAddDcdnDomainResponse({}));
  }

  /**
   * Adds one or more domain names to DCDN at a time.
   * 
   * @remarks
   * *Prerequisites**:
   * *   The [DCDN service is activated](https://help.aliyun.com/document_detail/64926.html).
   * *   Internet content provider (ICP) filing is complete for the accelerated domain names.
   * > *   If the content of the origin server is not stored on Alibaba Cloud, the content must be reviewed. After you submit the request, the review is complete by the end of the following business day.
   * >*   You can specify up to 50 domain names in each request.
   * >*   You can call this operation up to 30 times per second per account.
   * 
   * @param request - BatchAddDcdnDomainRequest
   * @returns BatchAddDcdnDomainResponse
   */
  async batchAddDcdnDomain(request: BatchAddDcdnDomainRequest): Promise<BatchAddDcdnDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchAddDcdnDomainWithOptions(request, runtime);
  }

  /**
   * Creates Web Application Firewall (WAF) protection rules.
   * 
   * @remarks
   * >  You can call this operation up to 20 times per second per account.
   * 
   * @param request - BatchCreateDcdnWafRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchCreateDcdnWafRulesResponse
   */
  async batchCreateDcdnWafRulesWithOptions(request: BatchCreateDcdnWafRulesRequest, runtime: $Util.RuntimeOptions): Promise<BatchCreateDcdnWafRulesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.policyId)) {
      body["PolicyId"] = request.policyId;
    }

    if (!Util.isUnset(request.ruleConfigs)) {
      body["RuleConfigs"] = request.ruleConfigs;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchCreateDcdnWafRules",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchCreateDcdnWafRulesResponse>(await this.callApi(params, req, runtime), new BatchCreateDcdnWafRulesResponse({}));
  }

  /**
   * Creates Web Application Firewall (WAF) protection rules.
   * 
   * @remarks
   * >  You can call this operation up to 20 times per second per account.
   * 
   * @param request - BatchCreateDcdnWafRulesRequest
   * @returns BatchCreateDcdnWafRulesResponse
   */
  async batchCreateDcdnWafRules(request: BatchCreateDcdnWafRulesRequest): Promise<BatchCreateDcdnWafRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchCreateDcdnWafRulesWithOptions(request, runtime);
  }

  /**
   * Deletes configurations of multiple accelerated domain names at a time.
   * 
   * @remarks
   * > - You can specify up to 50 domain names in each request.
   * > - You can call this operation up to 30 times per second per account.
   * 
   * @param request - BatchDeleteDcdnDomainConfigsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchDeleteDcdnDomainConfigsResponse
   */
  async batchDeleteDcdnDomainConfigsWithOptions(request: BatchDeleteDcdnDomainConfigsRequest, runtime: $Util.RuntimeOptions): Promise<BatchDeleteDcdnDomainConfigsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainNames)) {
      query["DomainNames"] = request.domainNames;
    }

    if (!Util.isUnset(request.functionNames)) {
      query["FunctionNames"] = request.functionNames;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchDeleteDcdnDomainConfigs",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchDeleteDcdnDomainConfigsResponse>(await this.callApi(params, req, runtime), new BatchDeleteDcdnDomainConfigsResponse({}));
  }

  /**
   * Deletes configurations of multiple accelerated domain names at a time.
   * 
   * @remarks
   * > - You can specify up to 50 domain names in each request.
   * > - You can call this operation up to 30 times per second per account.
   * 
   * @param request - BatchDeleteDcdnDomainConfigsRequest
   * @returns BatchDeleteDcdnDomainConfigsResponse
   */
  async batchDeleteDcdnDomainConfigs(request: BatchDeleteDcdnDomainConfigsRequest): Promise<BatchDeleteDcdnDomainConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchDeleteDcdnDomainConfigsWithOptions(request, runtime);
  }

  /**
   * 批量删除kv数据，支持最大2M的请求体
   * 
   * @param tmpReq - BatchDeleteDcdnKvRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchDeleteDcdnKvResponse
   */
  async batchDeleteDcdnKvWithOptions(tmpReq: BatchDeleteDcdnKvRequest, runtime: $Util.RuntimeOptions): Promise<BatchDeleteDcdnKvResponse> {
    Util.validateModel(tmpReq);
    let request = new BatchDeleteDcdnKvShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.keys)) {
      request.keysShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.keys, "Keys", "json");
    }

    let query = { };
    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.keysShrink)) {
      body["Keys"] = request.keysShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchDeleteDcdnKv",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchDeleteDcdnKvResponse>(await this.callApi(params, req, runtime), new BatchDeleteDcdnKvResponse({}));
  }

  /**
   * 批量删除kv数据，支持最大2M的请求体
   * 
   * @param request - BatchDeleteDcdnKvRequest
   * @returns BatchDeleteDcdnKvResponse
   */
  async batchDeleteDcdnKv(request: BatchDeleteDcdnKvRequest): Promise<BatchDeleteDcdnKvResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchDeleteDcdnKvWithOptions(request, runtime);
  }

  /**
   * 批量删除kv数据，支持最大100M的请求体
   * 
   * @param request - BatchDeleteDcdnKvWithHighCapacityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchDeleteDcdnKvWithHighCapacityResponse
   */
  async batchDeleteDcdnKvWithHighCapacityWithOptions(request: BatchDeleteDcdnKvWithHighCapacityRequest, runtime: $Util.RuntimeOptions): Promise<BatchDeleteDcdnKvWithHighCapacityResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.url)) {
      query["Url"] = request.url;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchDeleteDcdnKvWithHighCapacity",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchDeleteDcdnKvWithHighCapacityResponse>(await this.callApi(params, req, runtime), new BatchDeleteDcdnKvWithHighCapacityResponse({}));
  }

  /**
   * 批量删除kv数据，支持最大100M的请求体
   * 
   * @param request - BatchDeleteDcdnKvWithHighCapacityRequest
   * @returns BatchDeleteDcdnKvWithHighCapacityResponse
   */
  async batchDeleteDcdnKvWithHighCapacity(request: BatchDeleteDcdnKvWithHighCapacityRequest): Promise<BatchDeleteDcdnKvWithHighCapacityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchDeleteDcdnKvWithHighCapacityWithOptions(request, runtime);
  }

  async batchDeleteDcdnKvWithHighCapacityAdvance(request: BatchDeleteDcdnKvWithHighCapacityAdvanceRequest, runtime: $Util.RuntimeOptions): Promise<BatchDeleteDcdnKvWithHighCapacityResponse> {
    // Step 0: init client
    let accessKeyId = await this._credential.getAccessKeyId();
    let accessKeySecret = await this._credential.getAccessKeySecret();
    let securityToken = await this._credential.getSecurityToken();
    let credentialType = this._credential.getType();
    let openPlatformEndpoint = this._openPlatformEndpoint;
    if (Util.empty(openPlatformEndpoint)) {
      openPlatformEndpoint = "openplatform.aliyuncs.com";
    }

    if (Util.isUnset(credentialType)) {
      credentialType = "access_key";
    }

    let authConfig = new $OpenApi.Config({
      accessKeyId: accessKeyId,
      accessKeySecret: accessKeySecret,
      securityToken: securityToken,
      type: credentialType,
      endpoint: openPlatformEndpoint,
      protocol: this._protocol,
      regionId: this._regionId,
    });
    let authClient = new OpenPlatform(authConfig);
    let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
      product: "dcdn",
      regionId: this._regionId,
    });
    let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({ });
    let ossConfig = new $OSS.Config({
      accessKeyId: accessKeyId,
      accessKeySecret: accessKeySecret,
      type: "access_key",
      protocol: this._protocol,
      regionId: this._regionId,
    });
    let ossClient : OSS = new OSS(ossConfig);
    let fileObj = new $FileForm.FileField({ });
    let ossHeader = new $OSS.PostObjectRequestHeader({ });
    let uploadRequest = new $OSS.PostObjectRequest({ });
    let ossRuntime = new $OSSUtil.RuntimeOptions({ });
    OpenApiUtil.convert(runtime, ossRuntime);
    let batchDeleteDcdnKvWithHighCapacityReq = new BatchDeleteDcdnKvWithHighCapacityRequest({ });
    OpenApiUtil.convert(request, batchDeleteDcdnKvWithHighCapacityReq);
    if (!Util.isUnset(request.urlObject)) {
      authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
      ossConfig.accessKeyId = authResponse.body.accessKeyId;
      ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
      ossClient = new OSS(ossConfig);
      fileObj = new $FileForm.FileField({
        filename: authResponse.body.objectKey,
        content: request.urlObject,
        contentType: "",
      });
      ossHeader = new $OSS.PostObjectRequestHeader({
        accessKeyId: authResponse.body.accessKeyId,
        policy: authResponse.body.encodedPolicy,
        signature: authResponse.body.signature,
        key: authResponse.body.objectKey,
        file: fileObj,
        successActionStatus: "201",
      });
      uploadRequest = new $OSS.PostObjectRequest({
        bucketName: authResponse.body.bucket,
        header: ossHeader,
      });
      await ossClient.postObject(uploadRequest, ossRuntime);
      batchDeleteDcdnKvWithHighCapacityReq.url = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
    }

    let batchDeleteDcdnKvWithHighCapacityResp = await this.batchDeleteDcdnKvWithHighCapacityWithOptions(batchDeleteDcdnKvWithHighCapacityReq, runtime);
    return batchDeleteDcdnKvWithHighCapacityResp;
  }

  /**
   * Deletes multiple Web Application Firewall (WAF) protection rules at a time.
   * 
   * @remarks
   *   You can call this operation up to 20 times per second per account.
   * *   Alibaba Cloud Dynamic Content Delivery Network (DCDN) supports POST requests.
   * 
   * @param request - BatchDeleteDcdnWafRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchDeleteDcdnWafRulesResponse
   */
  async batchDeleteDcdnWafRulesWithOptions(request: BatchDeleteDcdnWafRulesRequest, runtime: $Util.RuntimeOptions): Promise<BatchDeleteDcdnWafRulesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.ruleIds)) {
      body["RuleIds"] = request.ruleIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchDeleteDcdnWafRules",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchDeleteDcdnWafRulesResponse>(await this.callApi(params, req, runtime), new BatchDeleteDcdnWafRulesResponse({}));
  }

  /**
   * Deletes multiple Web Application Firewall (WAF) protection rules at a time.
   * 
   * @remarks
   *   You can call this operation up to 20 times per second per account.
   * *   Alibaba Cloud Dynamic Content Delivery Network (DCDN) supports POST requests.
   * 
   * @param request - BatchDeleteDcdnWafRulesRequest
   * @returns BatchDeleteDcdnWafRulesResponse
   */
  async batchDeleteDcdnWafRules(request: BatchDeleteDcdnWafRulesRequest): Promise<BatchDeleteDcdnWafRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchDeleteDcdnWafRulesWithOptions(request, runtime);
  }

  /**
   * Modifies multiple Web Application Firewall (WAF) protection rules. Only Bot management rules can be modified.
   * 
   * @remarks
   * You can call this operation up to 20 times per second per account.
   * 
   * @param request - BatchModifyDcdnWafRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchModifyDcdnWafRulesResponse
   */
  async batchModifyDcdnWafRulesWithOptions(request: BatchModifyDcdnWafRulesRequest, runtime: $Util.RuntimeOptions): Promise<BatchModifyDcdnWafRulesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.policyId)) {
      body["PolicyId"] = request.policyId;
    }

    if (!Util.isUnset(request.ruleConfigs)) {
      body["RuleConfigs"] = request.ruleConfigs;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchModifyDcdnWafRules",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchModifyDcdnWafRulesResponse>(await this.callApi(params, req, runtime), new BatchModifyDcdnWafRulesResponse({}));
  }

  /**
   * Modifies multiple Web Application Firewall (WAF) protection rules. Only Bot management rules can be modified.
   * 
   * @remarks
   * You can call this operation up to 20 times per second per account.
   * 
   * @param request - BatchModifyDcdnWafRulesRequest
   * @returns BatchModifyDcdnWafRulesResponse
   */
  async batchModifyDcdnWafRules(request: BatchModifyDcdnWafRulesRequest): Promise<BatchModifyDcdnWafRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchModifyDcdnWafRulesWithOptions(request, runtime);
  }

  /**
   * Configures multiple key-value (KV) pairs for a namespace.
   * 
   * @param tmpReq - BatchPutDcdnKvRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchPutDcdnKvResponse
   */
  async batchPutDcdnKvWithOptions(tmpReq: BatchPutDcdnKvRequest, runtime: $Util.RuntimeOptions): Promise<BatchPutDcdnKvResponse> {
    Util.validateModel(tmpReq);
    let request = new BatchPutDcdnKvShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.kvList)) {
      request.kvListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.kvList, "KvList", "json");
    }

    let query = { };
    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.kvListShrink)) {
      body["KvList"] = request.kvListShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchPutDcdnKv",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchPutDcdnKvResponse>(await this.callApi(params, req, runtime), new BatchPutDcdnKvResponse({}));
  }

  /**
   * Configures multiple key-value (KV) pairs for a namespace.
   * 
   * @param request - BatchPutDcdnKvRequest
   * @returns BatchPutDcdnKvResponse
   */
  async batchPutDcdnKv(request: BatchPutDcdnKvRequest): Promise<BatchPutDcdnKvResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchPutDcdnKvWithOptions(request, runtime);
  }

  /**
   * 批量写入kv数据，支持最大100M的请求体
   * 
   * @param request - BatchPutDcdnKvWithHighCapacityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchPutDcdnKvWithHighCapacityResponse
   */
  async batchPutDcdnKvWithHighCapacityWithOptions(request: BatchPutDcdnKvWithHighCapacityRequest, runtime: $Util.RuntimeOptions): Promise<BatchPutDcdnKvWithHighCapacityResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.url)) {
      query["Url"] = request.url;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchPutDcdnKvWithHighCapacity",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchPutDcdnKvWithHighCapacityResponse>(await this.callApi(params, req, runtime), new BatchPutDcdnKvWithHighCapacityResponse({}));
  }

  /**
   * 批量写入kv数据，支持最大100M的请求体
   * 
   * @param request - BatchPutDcdnKvWithHighCapacityRequest
   * @returns BatchPutDcdnKvWithHighCapacityResponse
   */
  async batchPutDcdnKvWithHighCapacity(request: BatchPutDcdnKvWithHighCapacityRequest): Promise<BatchPutDcdnKvWithHighCapacityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchPutDcdnKvWithHighCapacityWithOptions(request, runtime);
  }

  async batchPutDcdnKvWithHighCapacityAdvance(request: BatchPutDcdnKvWithHighCapacityAdvanceRequest, runtime: $Util.RuntimeOptions): Promise<BatchPutDcdnKvWithHighCapacityResponse> {
    // Step 0: init client
    let accessKeyId = await this._credential.getAccessKeyId();
    let accessKeySecret = await this._credential.getAccessKeySecret();
    let securityToken = await this._credential.getSecurityToken();
    let credentialType = this._credential.getType();
    let openPlatformEndpoint = this._openPlatformEndpoint;
    if (Util.empty(openPlatformEndpoint)) {
      openPlatformEndpoint = "openplatform.aliyuncs.com";
    }

    if (Util.isUnset(credentialType)) {
      credentialType = "access_key";
    }

    let authConfig = new $OpenApi.Config({
      accessKeyId: accessKeyId,
      accessKeySecret: accessKeySecret,
      securityToken: securityToken,
      type: credentialType,
      endpoint: openPlatformEndpoint,
      protocol: this._protocol,
      regionId: this._regionId,
    });
    let authClient = new OpenPlatform(authConfig);
    let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
      product: "dcdn",
      regionId: this._regionId,
    });
    let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({ });
    let ossConfig = new $OSS.Config({
      accessKeyId: accessKeyId,
      accessKeySecret: accessKeySecret,
      type: "access_key",
      protocol: this._protocol,
      regionId: this._regionId,
    });
    let ossClient : OSS = new OSS(ossConfig);
    let fileObj = new $FileForm.FileField({ });
    let ossHeader = new $OSS.PostObjectRequestHeader({ });
    let uploadRequest = new $OSS.PostObjectRequest({ });
    let ossRuntime = new $OSSUtil.RuntimeOptions({ });
    OpenApiUtil.convert(runtime, ossRuntime);
    let batchPutDcdnKvWithHighCapacityReq = new BatchPutDcdnKvWithHighCapacityRequest({ });
    OpenApiUtil.convert(request, batchPutDcdnKvWithHighCapacityReq);
    if (!Util.isUnset(request.urlObject)) {
      authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
      ossConfig.accessKeyId = authResponse.body.accessKeyId;
      ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
      ossClient = new OSS(ossConfig);
      fileObj = new $FileForm.FileField({
        filename: authResponse.body.objectKey,
        content: request.urlObject,
        contentType: "",
      });
      ossHeader = new $OSS.PostObjectRequestHeader({
        accessKeyId: authResponse.body.accessKeyId,
        policy: authResponse.body.encodedPolicy,
        signature: authResponse.body.signature,
        key: authResponse.body.objectKey,
        file: fileObj,
        successActionStatus: "201",
      });
      uploadRequest = new $OSS.PostObjectRequest({
        bucketName: authResponse.body.bucket,
        header: ossHeader,
      });
      await ossClient.postObject(uploadRequest, ossRuntime);
      batchPutDcdnKvWithHighCapacityReq.url = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
    }

    let batchPutDcdnKvWithHighCapacityResp = await this.batchPutDcdnKvWithHighCapacityWithOptions(batchPutDcdnKvWithHighCapacityReq, runtime);
    return batchPutDcdnKvWithHighCapacityResp;
  }

  /**
   * Configures the SSL certificate and modifies the certificate information for multiple accelerated domain names at a time.
   * 
   * @remarks
   * > You can call this operation up to 10 times per second per account.
   * 
   * @param request - BatchSetDcdnDomainCertificateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchSetDcdnDomainCertificateResponse
   */
  async batchSetDcdnDomainCertificateWithOptions(request: BatchSetDcdnDomainCertificateRequest, runtime: $Util.RuntimeOptions): Promise<BatchSetDcdnDomainCertificateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.certName)) {
      query["CertName"] = request.certName;
    }

    if (!Util.isUnset(request.certType)) {
      query["CertType"] = request.certType;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.SSLPri)) {
      query["SSLPri"] = request.SSLPri;
    }

    if (!Util.isUnset(request.SSLProtocol)) {
      query["SSLProtocol"] = request.SSLProtocol;
    }

    if (!Util.isUnset(request.SSLPub)) {
      query["SSLPub"] = request.SSLPub;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchSetDcdnDomainCertificate",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchSetDcdnDomainCertificateResponse>(await this.callApi(params, req, runtime), new BatchSetDcdnDomainCertificateResponse({}));
  }

  /**
   * Configures the SSL certificate and modifies the certificate information for multiple accelerated domain names at a time.
   * 
   * @remarks
   * > You can call this operation up to 10 times per second per account.
   * 
   * @param request - BatchSetDcdnDomainCertificateRequest
   * @returns BatchSetDcdnDomainCertificateResponse
   */
  async batchSetDcdnDomainCertificate(request: BatchSetDcdnDomainCertificateRequest): Promise<BatchSetDcdnDomainCertificateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchSetDcdnDomainCertificateWithOptions(request, runtime);
  }

  /**
   * Configures features for one or more domain names.
   * 
   * @remarks
   *   You can specify up to 50 domain names in each request.
   * *   You can call this operation up to 30 times per second per account.
   * 
   * @param request - BatchSetDcdnDomainConfigsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchSetDcdnDomainConfigsResponse
   */
  async batchSetDcdnDomainConfigsWithOptions(request: BatchSetDcdnDomainConfigsRequest, runtime: $Util.RuntimeOptions): Promise<BatchSetDcdnDomainConfigsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainNames)) {
      query["DomainNames"] = request.domainNames;
    }

    if (!Util.isUnset(request.functions)) {
      query["Functions"] = request.functions;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchSetDcdnDomainConfigs",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchSetDcdnDomainConfigsResponse>(await this.callApi(params, req, runtime), new BatchSetDcdnDomainConfigsResponse({}));
  }

  /**
   * Configures features for one or more domain names.
   * 
   * @remarks
   *   You can specify up to 50 domain names in each request.
   * *   You can call this operation up to 30 times per second per account.
   * 
   * @param request - BatchSetDcdnDomainConfigsRequest
   * @returns BatchSetDcdnDomainConfigsResponse
   */
  async batchSetDcdnDomainConfigs(request: BatchSetDcdnDomainConfigsRequest): Promise<BatchSetDcdnDomainConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchSetDcdnDomainConfigsWithOptions(request, runtime);
  }

  /**
   * Configures multiple domain names to be accelerated by IP Application Accelerator (IPA).
   * 
   * @remarks
   * > You can call this operation up to 20 times per second per account.
   * 
   * @param request - BatchSetDcdnIpaDomainConfigsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchSetDcdnIpaDomainConfigsResponse
   */
  async batchSetDcdnIpaDomainConfigsWithOptions(request: BatchSetDcdnIpaDomainConfigsRequest, runtime: $Util.RuntimeOptions): Promise<BatchSetDcdnIpaDomainConfigsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainNames)) {
      query["DomainNames"] = request.domainNames;
    }

    if (!Util.isUnset(request.functions)) {
      query["Functions"] = request.functions;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchSetDcdnIpaDomainConfigs",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchSetDcdnIpaDomainConfigsResponse>(await this.callApi(params, req, runtime), new BatchSetDcdnIpaDomainConfigsResponse({}));
  }

  /**
   * Configures multiple domain names to be accelerated by IP Application Accelerator (IPA).
   * 
   * @remarks
   * > You can call this operation up to 20 times per second per account.
   * 
   * @param request - BatchSetDcdnIpaDomainConfigsRequest
   * @returns BatchSetDcdnIpaDomainConfigsResponse
   */
  async batchSetDcdnIpaDomainConfigs(request: BatchSetDcdnIpaDomainConfigsRequest): Promise<BatchSetDcdnIpaDomainConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchSetDcdnIpaDomainConfigsWithOptions(request, runtime);
  }

  /**
   * Sets the protection status of multiple domain names at a time.
   * 
   * @remarks
   * #
   * *   You can call this operation up to 20 times per second.
   * *   Alibaba Cloud Dynamic Content Delivery Network (DCDN) supports POST requests.
   * 
   * @param request - BatchSetDcdnWafDomainConfigsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchSetDcdnWafDomainConfigsResponse
   */
  async batchSetDcdnWafDomainConfigsWithOptions(request: BatchSetDcdnWafDomainConfigsRequest, runtime: $Util.RuntimeOptions): Promise<BatchSetDcdnWafDomainConfigsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.clientIpTag)) {
      body["ClientIpTag"] = request.clientIpTag;
    }

    if (!Util.isUnset(request.defenseStatus)) {
      body["DefenseStatus"] = request.defenseStatus;
    }

    if (!Util.isUnset(request.domainNames)) {
      body["DomainNames"] = request.domainNames;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchSetDcdnWafDomainConfigs",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchSetDcdnWafDomainConfigsResponse>(await this.callApi(params, req, runtime), new BatchSetDcdnWafDomainConfigsResponse({}));
  }

  /**
   * Sets the protection status of multiple domain names at a time.
   * 
   * @remarks
   * #
   * *   You can call this operation up to 20 times per second.
   * *   Alibaba Cloud Dynamic Content Delivery Network (DCDN) supports POST requests.
   * 
   * @param request - BatchSetDcdnWafDomainConfigsRequest
   * @returns BatchSetDcdnWafDomainConfigsResponse
   */
  async batchSetDcdnWafDomainConfigs(request: BatchSetDcdnWafDomainConfigsRequest): Promise<BatchSetDcdnWafDomainConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchSetDcdnWafDomainConfigsWithOptions(request, runtime);
  }

  /**
   * Enables one or more accelerated domain names. After the accelerated domain names are enabled, the value of the DomainStatus parameter for the domain names changes to Online.
   * 
   * @remarks
   * > 
   * *   If an accelerated domain name is in an invalid state or your account has an overdue payment, the accelerated domain name cannot be enabled.
   * *   You can specify up to 50 domain names in each request.
   * *   You can call this operation up to 30 times per second per account.
   * 
   * @param request - BatchStartDcdnDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchStartDcdnDomainResponse
   */
  async batchStartDcdnDomainWithOptions(request: BatchStartDcdnDomainRequest, runtime: $Util.RuntimeOptions): Promise<BatchStartDcdnDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainNames)) {
      query["DomainNames"] = request.domainNames;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchStartDcdnDomain",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchStartDcdnDomainResponse>(await this.callApi(params, req, runtime), new BatchStartDcdnDomainResponse({}));
  }

  /**
   * Enables one or more accelerated domain names. After the accelerated domain names are enabled, the value of the DomainStatus parameter for the domain names changes to Online.
   * 
   * @remarks
   * > 
   * *   If an accelerated domain name is in an invalid state or your account has an overdue payment, the accelerated domain name cannot be enabled.
   * *   You can specify up to 50 domain names in each request.
   * *   You can call this operation up to 30 times per second per account.
   * 
   * @param request - BatchStartDcdnDomainRequest
   * @returns BatchStartDcdnDomainResponse
   */
  async batchStartDcdnDomain(request: BatchStartDcdnDomainRequest): Promise<BatchStartDcdnDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchStartDcdnDomainWithOptions(request, runtime);
  }

  /**
   * Disables one or more accelerated domain names. After an accelerated domain name is disabled, the value of the DomainStatus parameter for the domain name changes to Offline.
   * 
   * @remarks
   * > *   After an accelerated domain name is disabled, Dynamic Content Delivery Network (DCDN) retains the domain name information. The system automatically reroutes all requests that are destined for the accelerated domain name to the origin.
   * >*   You can specify up to 50 domain names in each request.
   * >*   You can call this operation up to 30 times per second per account.
   * 
   * @param request - BatchStopDcdnDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchStopDcdnDomainResponse
   */
  async batchStopDcdnDomainWithOptions(request: BatchStopDcdnDomainRequest, runtime: $Util.RuntimeOptions): Promise<BatchStopDcdnDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainNames)) {
      query["DomainNames"] = request.domainNames;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchStopDcdnDomain",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchStopDcdnDomainResponse>(await this.callApi(params, req, runtime), new BatchStopDcdnDomainResponse({}));
  }

  /**
   * Disables one or more accelerated domain names. After an accelerated domain name is disabled, the value of the DomainStatus parameter for the domain name changes to Offline.
   * 
   * @remarks
   * > *   After an accelerated domain name is disabled, Dynamic Content Delivery Network (DCDN) retains the domain name information. The system automatically reroutes all requests that are destined for the accelerated domain name to the origin.
   * >*   You can specify up to 50 domain names in each request.
   * >*   You can call this operation up to 30 times per second per account.
   * 
   * @param request - BatchStopDcdnDomainRequest
   * @returns BatchStopDcdnDomainResponse
   */
  async batchStopDcdnDomain(request: BatchStopDcdnDomainRequest): Promise<BatchStopDcdnDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchStopDcdnDomainWithOptions(request, runtime);
  }

  /**
   * Checks whether a real-time log delivery project exists.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - CheckDcdnProjectExistRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CheckDcdnProjectExistResponse
   */
  async checkDcdnProjectExistWithOptions(request: CheckDcdnProjectExistRequest, runtime: $Util.RuntimeOptions): Promise<CheckDcdnProjectExistResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CheckDcdnProjectExist",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CheckDcdnProjectExistResponse>(await this.callApi(params, req, runtime), new CheckDcdnProjectExistResponse({}));
  }

  /**
   * Checks whether a real-time log delivery project exists.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - CheckDcdnProjectExistRequest
   * @returns CheckDcdnProjectExistResponse
   */
  async checkDcdnProjectExist(request: CheckDcdnProjectExistRequest): Promise<CheckDcdnProjectExistResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.checkDcdnProjectExistWithOptions(request, runtime);
  }

  /**
   * Generates an official code version from unstable JavaScript code that is in the staging
   *                   environment. The version can be used in the canary release or production environment.
   * 
   * @remarks
   * >  The call frequency of the API is no more than 100 queries per second.
   * 
   * @param request - CommitStagingRoutineCodeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CommitStagingRoutineCodeResponse
   */
  async commitStagingRoutineCodeWithOptions(request: CommitStagingRoutineCodeRequest, runtime: $Util.RuntimeOptions): Promise<CommitStagingRoutineCodeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.codeDescription)) {
      body["CodeDescription"] = request.codeDescription;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CommitStagingRoutineCode",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CommitStagingRoutineCodeResponse>(await this.callApi(params, req, runtime), new CommitStagingRoutineCodeResponse({}));
  }

  /**
   * Generates an official code version from unstable JavaScript code that is in the staging
   *                   environment. The version can be used in the canary release or production environment.
   * 
   * @remarks
   * >  The call frequency of the API is no more than 100 queries per second.
   * 
   * @param request - CommitStagingRoutineCodeRequest
   * @returns CommitStagingRoutineCodeResponse
   */
  async commitStagingRoutineCode(request: CommitStagingRoutineCodeRequest): Promise<CommitStagingRoutineCodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.commitStagingRoutineCodeWithOptions(request, runtime);
  }

  /**
   * Creates a certificate signing request (CSR) file.
   * 
   * @param request - CreateDcdnCertificateSigningRequestRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDcdnCertificateSigningRequestResponse
   */
  async createDcdnCertificateSigningRequestWithOptions(request: CreateDcdnCertificateSigningRequestRequest, runtime: $Util.RuntimeOptions): Promise<CreateDcdnCertificateSigningRequestResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.city)) {
      query["City"] = request.city;
    }

    if (!Util.isUnset(request.commonName)) {
      query["CommonName"] = request.commonName;
    }

    if (!Util.isUnset(request.country)) {
      query["Country"] = request.country;
    }

    if (!Util.isUnset(request.email)) {
      query["Email"] = request.email;
    }

    if (!Util.isUnset(request.organization)) {
      query["Organization"] = request.organization;
    }

    if (!Util.isUnset(request.organizationUnit)) {
      query["OrganizationUnit"] = request.organizationUnit;
    }

    if (!Util.isUnset(request.SANs)) {
      query["SANs"] = request.SANs;
    }

    if (!Util.isUnset(request.state)) {
      query["State"] = request.state;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDcdnCertificateSigningRequest",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDcdnCertificateSigningRequestResponse>(await this.callApi(params, req, runtime), new CreateDcdnCertificateSigningRequestResponse({}));
  }

  /**
   * Creates a certificate signing request (CSR) file.
   * 
   * @param request - CreateDcdnCertificateSigningRequestRequest
   * @returns CreateDcdnCertificateSigningRequestResponse
   */
  async createDcdnCertificateSigningRequest(request: CreateDcdnCertificateSigningRequestRequest): Promise<CreateDcdnCertificateSigningRequestResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDcdnCertificateSigningRequestWithOptions(request, runtime);
  }

  /**
   * Creates a tracking task. After you create a tracking task, the system periodically sends operations reports to you by email.
   * 
   * @remarks
   * *
   * **You can call this operation up to three times per second.
   * 
   * @param request - CreateDcdnDeliverTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDcdnDeliverTaskResponse
   */
  async createDcdnDeliverTaskWithOptions(request: CreateDcdnDeliverTaskRequest, runtime: $Util.RuntimeOptions): Promise<CreateDcdnDeliverTaskResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.deliver)) {
      body["Deliver"] = request.deliver;
    }

    if (!Util.isUnset(request.domainName)) {
      body["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.reports)) {
      body["Reports"] = request.reports;
    }

    if (!Util.isUnset(request.schedule)) {
      body["Schedule"] = request.schedule;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateDcdnDeliverTask",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDcdnDeliverTaskResponse>(await this.callApi(params, req, runtime), new CreateDcdnDeliverTaskResponse({}));
  }

  /**
   * Creates a tracking task. After you create a tracking task, the system periodically sends operations reports to you by email.
   * 
   * @remarks
   * *
   * **You can call this operation up to three times per second.
   * 
   * @param request - CreateDcdnDeliverTaskRequest
   * @returns CreateDcdnDeliverTaskResponse
   */
  async createDcdnDeliverTask(request: CreateDcdnDeliverTaskRequest): Promise<CreateDcdnDeliverTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDcdnDeliverTaskWithOptions(request, runtime);
  }

  /**
   * Creates a real-time log delivery project.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - CreateDcdnSLSRealTimeLogDeliveryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDcdnSLSRealTimeLogDeliveryResponse
   */
  async createDcdnSLSRealTimeLogDeliveryWithOptions(request: CreateDcdnSLSRealTimeLogDeliveryRequest, runtime: $Util.RuntimeOptions): Promise<CreateDcdnSLSRealTimeLogDeliveryResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.businessType)) {
      body["BusinessType"] = request.businessType;
    }

    if (!Util.isUnset(request.dataCenter)) {
      body["DataCenter"] = request.dataCenter;
    }

    if (!Util.isUnset(request.domainName)) {
      body["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.projectName)) {
      body["ProjectName"] = request.projectName;
    }

    if (!Util.isUnset(request.SLSLogStore)) {
      body["SLSLogStore"] = request.SLSLogStore;
    }

    if (!Util.isUnset(request.SLSProject)) {
      body["SLSProject"] = request.SLSProject;
    }

    if (!Util.isUnset(request.SLSRegion)) {
      body["SLSRegion"] = request.SLSRegion;
    }

    if (!Util.isUnset(request.samplingRate)) {
      body["SamplingRate"] = request.samplingRate;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateDcdnSLSRealTimeLogDelivery",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDcdnSLSRealTimeLogDeliveryResponse>(await this.callApi(params, req, runtime), new CreateDcdnSLSRealTimeLogDeliveryResponse({}));
  }

  /**
   * Creates a real-time log delivery project.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - CreateDcdnSLSRealTimeLogDeliveryRequest
   * @returns CreateDcdnSLSRealTimeLogDeliveryResponse
   */
  async createDcdnSLSRealTimeLogDelivery(request: CreateDcdnSLSRealTimeLogDeliveryRequest): Promise<CreateDcdnSLSRealTimeLogDeliveryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDcdnSLSRealTimeLogDeliveryWithOptions(request, runtime);
  }

  /**
   * Creates a custom operations report.
   * 
   * @remarks
   * > *   This operation allows you to create a custom operations report for a specific domain name. You can view the statistics about the domain name in the report.
   * > *   You can call this operation up to three times per second per account.
   * 
   * @param request - CreateDcdnSubTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDcdnSubTaskResponse
   */
  async createDcdnSubTaskWithOptions(request: CreateDcdnSubTaskRequest, runtime: $Util.RuntimeOptions): Promise<CreateDcdnSubTaskResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.domainName)) {
      body["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.reportIds)) {
      body["ReportIds"] = request.reportIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateDcdnSubTask",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDcdnSubTaskResponse>(await this.callApi(params, req, runtime), new CreateDcdnSubTaskResponse({}));
  }

  /**
   * Creates a custom operations report.
   * 
   * @remarks
   * > *   This operation allows you to create a custom operations report for a specific domain name. You can view the statistics about the domain name in the report.
   * > *   You can call this operation up to three times per second per account.
   * 
   * @param request - CreateDcdnSubTaskRequest
   * @returns CreateDcdnSubTaskResponse
   */
  async createDcdnSubTask(request: CreateDcdnSubTaskRequest): Promise<CreateDcdnSubTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDcdnSubTaskWithOptions(request, runtime);
  }

  /**
   * Create a custom WAF rule group.
   * 
   * @param request - CreateDcdnWafGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDcdnWafGroupResponse
   */
  async createDcdnWafGroupWithOptions(request: CreateDcdnWafGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateDcdnWafGroupResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.subscribe)) {
      body["Subscribe"] = request.subscribe;
    }

    if (!Util.isUnset(request.templateId)) {
      body["TemplateId"] = request.templateId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateDcdnWafGroup",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDcdnWafGroupResponse>(await this.callApi(params, req, runtime), new CreateDcdnWafGroupResponse({}));
  }

  /**
   * Create a custom WAF rule group.
   * 
   * @param request - CreateDcdnWafGroupRequest
   * @returns CreateDcdnWafGroupResponse
   */
  async createDcdnWafGroup(request: CreateDcdnWafGroupRequest): Promise<CreateDcdnWafGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDcdnWafGroupWithOptions(request, runtime);
  }

  /**
   * Creates a Web Application Firewall (WAF) protection policy.
   * 
   * @remarks
   *   You can call this operation up to 20 times per second per user.
   * *   Alibaba Cloud Dynamic Route for CDN (DCDN) supports POST requests.
   * 
   * @param request - CreateDcdnWafPolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDcdnWafPolicyResponse
   */
  async createDcdnWafPolicyWithOptions(request: CreateDcdnWafPolicyRequest, runtime: $Util.RuntimeOptions): Promise<CreateDcdnWafPolicyResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.defenseScene)) {
      body["DefenseScene"] = request.defenseScene;
    }

    if (!Util.isUnset(request.policyName)) {
      body["PolicyName"] = request.policyName;
    }

    if (!Util.isUnset(request.policyStatus)) {
      body["PolicyStatus"] = request.policyStatus;
    }

    if (!Util.isUnset(request.policyType)) {
      body["PolicyType"] = request.policyType;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateDcdnWafPolicy",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDcdnWafPolicyResponse>(await this.callApi(params, req, runtime), new CreateDcdnWafPolicyResponse({}));
  }

  /**
   * Creates a Web Application Firewall (WAF) protection policy.
   * 
   * @remarks
   *   You can call this operation up to 20 times per second per user.
   * *   Alibaba Cloud Dynamic Route for CDN (DCDN) supports POST requests.
   * 
   * @param request - CreateDcdnWafPolicyRequest
   * @returns CreateDcdnWafPolicyResponse
   */
  async createDcdnWafPolicy(request: CreateDcdnWafPolicyRequest): Promise<CreateDcdnWafPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDcdnWafPolicyWithOptions(request, runtime);
  }

  /**
   * Creates a routine.
   * 
   * @remarks
   * > *   The parameters must comply with the rules of EnvConf. The description of a routine cannot exceed 50 characters in length.
   * >*   You can only specify the production and staging environments when you call this operation.
   * >*   You can call this operation up to 100 times per second per account.
   * 
   * @param tmpReq - CreateRoutineRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateRoutineResponse
   */
  async createRoutineWithOptions(tmpReq: CreateRoutineRequest, runtime: $Util.RuntimeOptions): Promise<CreateRoutineResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateRoutineShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.envConf)) {
      request.envConfShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.envConf, "EnvConf", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.envConfShrink)) {
      body["EnvConf"] = request.envConfShrink;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateRoutine",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateRoutineResponse>(await this.callApi(params, req, runtime), new CreateRoutineResponse({}));
  }

  /**
   * Creates a routine.
   * 
   * @remarks
   * > *   The parameters must comply with the rules of EnvConf. The description of a routine cannot exceed 50 characters in length.
   * >*   You can only specify the production and staging environments when you call this operation.
   * >*   You can call this operation up to 100 times per second per account.
   * 
   * @param request - CreateRoutineRequest
   * @returns CreateRoutineResponse
   */
  async createRoutine(request: CreateRoutineRequest): Promise<CreateRoutineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createRoutineWithOptions(request, runtime);
  }

  /**
   * Creates a service-linked role (SLR) and a Log Service project.
   * 
   * @remarks
   * >  You can call this operation up to 100 times per second per account.
   * 
   * @param request - CreateSlrAndSlsProjectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateSlrAndSlsProjectResponse
   */
  async createSlrAndSlsProjectWithOptions(request: CreateSlrAndSlsProjectRequest, runtime: $Util.RuntimeOptions): Promise<CreateSlrAndSlsProjectResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.businessType)) {
      body["BusinessType"] = request.businessType;
    }

    if (!Util.isUnset(request.region)) {
      body["Region"] = request.region;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateSlrAndSlsProject",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSlrAndSlsProjectResponse>(await this.callApi(params, req, runtime), new CreateSlrAndSlsProjectResponse({}));
  }

  /**
   * Creates a service-linked role (SLR) and a Log Service project.
   * 
   * @remarks
   * >  You can call this operation up to 100 times per second per account.
   * 
   * @param request - CreateSlrAndSlsProjectRequest
   * @returns CreateSlrAndSlsProjectResponse
   */
  async createSlrAndSlsProject(request: CreateSlrAndSlsProjectRequest): Promise<CreateSlrAndSlsProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSlrAndSlsProjectWithOptions(request, runtime);
  }

  /**
   * Deletes tracking tasks by task ID.
   * 
   * @remarks
   * >  The maximum number of times that each user can call this operation per second is 3.
   * 
   * @param request - DeleteDcdnDeliverTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDcdnDeliverTaskResponse
   */
  async deleteDcdnDeliverTaskWithOptions(request: DeleteDcdnDeliverTaskRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDcdnDeliverTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deliverId)) {
      query["DeliverId"] = request.deliverId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDcdnDeliverTask",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDcdnDeliverTaskResponse>(await this.callApi(params, req, runtime), new DeleteDcdnDeliverTaskResponse({}));
  }

  /**
   * Deletes tracking tasks by task ID.
   * 
   * @remarks
   * >  The maximum number of times that each user can call this operation per second is 3.
   * 
   * @param request - DeleteDcdnDeliverTaskRequest
   * @returns DeleteDcdnDeliverTaskResponse
   */
  async deleteDcdnDeliverTask(request: DeleteDcdnDeliverTaskRequest): Promise<DeleteDcdnDeliverTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDcdnDeliverTaskWithOptions(request, runtime);
  }

  /**
   * Deletes a specified accelerated domain name.
   * 
   * @remarks
   * > *   Before you delete your domain name, you need to request the Domain Name System (DNS) provider to restore the A record of the domain name. Otherwise, the domain name may become inaccessible after you delete it.
   * > *   If you call the **DeleteDcdnDomain** operation, all the information about the accelerated domain name is deleted. If you want to disable an accelerated domain name, call the [StopDcdnDomain](https://help.aliyun.com/document_detail/130622.html) operation.
   * > *   You can call this operation up to 10 times per second per account.
   * 
   * @param request - DeleteDcdnDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDcdnDomainResponse
   */
  async deleteDcdnDomainWithOptions(request: DeleteDcdnDomainRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDcdnDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDcdnDomain",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDcdnDomainResponse>(await this.callApi(params, req, runtime), new DeleteDcdnDomainResponse({}));
  }

  /**
   * Deletes a specified accelerated domain name.
   * 
   * @remarks
   * > *   Before you delete your domain name, you need to request the Domain Name System (DNS) provider to restore the A record of the domain name. Otherwise, the domain name may become inaccessible after you delete it.
   * > *   If you call the **DeleteDcdnDomain** operation, all the information about the accelerated domain name is deleted. If you want to disable an accelerated domain name, call the [StopDcdnDomain](https://help.aliyun.com/document_detail/130622.html) operation.
   * > *   You can call this operation up to 10 times per second per account.
   * 
   * @param request - DeleteDcdnDomainRequest
   * @returns DeleteDcdnDomainResponse
   */
  async deleteDcdnDomain(request: DeleteDcdnDomainRequest): Promise<DeleteDcdnDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDcdnDomainWithOptions(request, runtime);
  }

  /**
   * Deletes an accelerated domain name from IP Application Accelerator (IPA).
   * 
   * @remarks
   * > 
   * *   Before you delete your domain name, we recommend that you request the Domain Name System (DNS) provider to restore the A record of the domain name. Otherwise, the domain name may become inaccessible after you delete it.
   * *   This operation deletes all records of the specified accelerated domain name. If you want to temporarily disable an accelerated domain name, call the **StopDcdnIpaDomain** operation.****
   * *   You can call this operation up to 10 times per second per account.
   * 
   * @param request - DeleteDcdnIpaDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDcdnIpaDomainResponse
   */
  async deleteDcdnIpaDomainWithOptions(request: DeleteDcdnIpaDomainRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDcdnIpaDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDcdnIpaDomain",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDcdnIpaDomainResponse>(await this.callApi(params, req, runtime), new DeleteDcdnIpaDomainResponse({}));
  }

  /**
   * Deletes an accelerated domain name from IP Application Accelerator (IPA).
   * 
   * @remarks
   * > 
   * *   Before you delete your domain name, we recommend that you request the Domain Name System (DNS) provider to restore the A record of the domain name. Otherwise, the domain name may become inaccessible after you delete it.
   * *   This operation deletes all records of the specified accelerated domain name. If you want to temporarily disable an accelerated domain name, call the **StopDcdnIpaDomain** operation.****
   * *   You can call this operation up to 10 times per second per account.
   * 
   * @param request - DeleteDcdnIpaDomainRequest
   * @returns DeleteDcdnIpaDomainResponse
   */
  async deleteDcdnIpaDomain(request: DeleteDcdnIpaDomainRequest): Promise<DeleteDcdnIpaDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDcdnIpaDomainWithOptions(request, runtime);
  }

  /**
   * Deletes specific configurations of an accelerated domain name from IP Application Accelerator (IPA).
   * 
   * @remarks
   * > You can call this operation up to 10 times per second per account.
   * 
   * @param request - DeleteDcdnIpaSpecificConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDcdnIpaSpecificConfigResponse
   */
  async deleteDcdnIpaSpecificConfigWithOptions(request: DeleteDcdnIpaSpecificConfigRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDcdnIpaSpecificConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDcdnIpaSpecificConfig",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDcdnIpaSpecificConfigResponse>(await this.callApi(params, req, runtime), new DeleteDcdnIpaSpecificConfigResponse({}));
  }

  /**
   * Deletes specific configurations of an accelerated domain name from IP Application Accelerator (IPA).
   * 
   * @remarks
   * > You can call this operation up to 10 times per second per account.
   * 
   * @param request - DeleteDcdnIpaSpecificConfigRequest
   * @returns DeleteDcdnIpaSpecificConfigResponse
   */
  async deleteDcdnIpaSpecificConfig(request: DeleteDcdnIpaSpecificConfigRequest): Promise<DeleteDcdnIpaSpecificConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDcdnIpaSpecificConfigWithOptions(request, runtime);
  }

  /**
   * Deletes the key-value pairs in a namespace that you specify when you call the PutDcdnKvNamespace operation. EdgeKV provides a global key-value database for Dynamic Route for CDN (DCDN) points of presence (POPs).
   * 
   * @param request - DeleteDcdnKvRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDcdnKvResponse
   */
  async deleteDcdnKvWithOptions(request: DeleteDcdnKvRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDcdnKvResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.key)) {
      query["Key"] = request.key;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDcdnKv",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDcdnKvResponse>(await this.callApi(params, req, runtime), new DeleteDcdnKvResponse({}));
  }

  /**
   * Deletes the key-value pairs in a namespace that you specify when you call the PutDcdnKvNamespace operation. EdgeKV provides a global key-value database for Dynamic Route for CDN (DCDN) points of presence (POPs).
   * 
   * @param request - DeleteDcdnKvRequest
   * @returns DeleteDcdnKvResponse
   */
  async deleteDcdnKv(request: DeleteDcdnKvRequest): Promise<DeleteDcdnKvResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDcdnKvWithOptions(request, runtime);
  }

  /**
   * Deletes a namespace that belongs to your account.
   * 
   * @param request - DeleteDcdnKvNamespaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDcdnKvNamespaceResponse
   */
  async deleteDcdnKvNamespaceWithOptions(request: DeleteDcdnKvNamespaceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDcdnKvNamespaceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDcdnKvNamespace",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDcdnKvNamespaceResponse>(await this.callApi(params, req, runtime), new DeleteDcdnKvNamespaceResponse({}));
  }

  /**
   * Deletes a namespace that belongs to your account.
   * 
   * @param request - DeleteDcdnKvNamespaceRequest
   * @returns DeleteDcdnKvNamespaceResponse
   */
  async deleteDcdnKvNamespace(request: DeleteDcdnKvNamespaceRequest): Promise<DeleteDcdnKvNamespaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDcdnKvNamespaceWithOptions(request, runtime);
  }

  /**
   * The ID of the request.
   * 
   * @remarks
   * >  You can call this operation up to 100 times per second per account.
   * 
   * @param request - DeleteDcdnRealTimeLogProjectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDcdnRealTimeLogProjectResponse
   */
  async deleteDcdnRealTimeLogProjectWithOptions(request: DeleteDcdnRealTimeLogProjectRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDcdnRealTimeLogProjectResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.projectName)) {
      query["ProjectName"] = request.projectName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDcdnRealTimeLogProject",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDcdnRealTimeLogProjectResponse>(await this.callApi(params, req, runtime), new DeleteDcdnRealTimeLogProjectResponse({}));
  }

  /**
   * The ID of the request.
   * 
   * @remarks
   * >  You can call this operation up to 100 times per second per account.
   * 
   * @param request - DeleteDcdnRealTimeLogProjectRequest
   * @returns DeleteDcdnRealTimeLogProjectResponse
   */
  async deleteDcdnRealTimeLogProject(request: DeleteDcdnRealTimeLogProjectRequest): Promise<DeleteDcdnRealTimeLogProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDcdnRealTimeLogProjectWithOptions(request, runtime);
  }

  /**
   * Deletes configurations of a domain name.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - DeleteDcdnSpecificConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDcdnSpecificConfigResponse
   */
  async deleteDcdnSpecificConfigWithOptions(request: DeleteDcdnSpecificConfigRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDcdnSpecificConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDcdnSpecificConfig",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDcdnSpecificConfigResponse>(await this.callApi(params, req, runtime), new DeleteDcdnSpecificConfigResponse({}));
  }

  /**
   * Deletes configurations of a domain name.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - DeleteDcdnSpecificConfigRequest
   * @returns DeleteDcdnSpecificConfigResponse
   */
  async deleteDcdnSpecificConfig(request: DeleteDcdnSpecificConfigRequest): Promise<DeleteDcdnSpecificConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDcdnSpecificConfigWithOptions(request, runtime);
  }

  /**
   * Deletes the configurations of an accelerated domain name in the canary release environment.
   * 
   * @remarks
   * > You can call this operation up to 20 times per second per account.
   * 
   * @param request - DeleteDcdnSpecificStagingConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDcdnSpecificStagingConfigResponse
   */
  async deleteDcdnSpecificStagingConfigWithOptions(request: DeleteDcdnSpecificStagingConfigRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDcdnSpecificStagingConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDcdnSpecificStagingConfig",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDcdnSpecificStagingConfigResponse>(await this.callApi(params, req, runtime), new DeleteDcdnSpecificStagingConfigResponse({}));
  }

  /**
   * Deletes the configurations of an accelerated domain name in the canary release environment.
   * 
   * @remarks
   * > You can call this operation up to 20 times per second per account.
   * 
   * @param request - DeleteDcdnSpecificStagingConfigRequest
   * @returns DeleteDcdnSpecificStagingConfigResponse
   */
  async deleteDcdnSpecificStagingConfig(request: DeleteDcdnSpecificStagingConfigRequest): Promise<DeleteDcdnSpecificStagingConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDcdnSpecificStagingConfigWithOptions(request, runtime);
  }

  /**
   * Deletes all custom operations reports.
   * 
   * @remarks
   * > You can call this operation up to 3 times per second per account.
   * 
   * @param request - DeleteDcdnSubTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDcdnSubTaskResponse
   */
  async deleteDcdnSubTaskWithOptions(runtime: $Util.RuntimeOptions): Promise<DeleteDcdnSubTaskResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DeleteDcdnSubTask",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDcdnSubTaskResponse>(await this.callApi(params, req, runtime), new DeleteDcdnSubTaskResponse({}));
  }

  /**
   * Deletes all custom operations reports.
   * 
   * @remarks
   * > You can call this operation up to 3 times per second per account.
   * @returns DeleteDcdnSubTaskResponse
   */
  async deleteDcdnSubTask(): Promise<DeleteDcdnSubTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDcdnSubTaskWithOptions(runtime);
  }

  /**
   * Deletes feature configurations by user.
   * 
   * @param request - DeleteDcdnUserConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDcdnUserConfigResponse
   */
  async deleteDcdnUserConfigWithOptions(request: DeleteDcdnUserConfigRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDcdnUserConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.functionName)) {
      query["FunctionName"] = request.functionName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDcdnUserConfig",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDcdnUserConfigResponse>(await this.callApi(params, req, runtime), new DeleteDcdnUserConfigResponse({}));
  }

  /**
   * Deletes feature configurations by user.
   * 
   * @param request - DeleteDcdnUserConfigRequest
   * @returns DeleteDcdnUserConfigResponse
   */
  async deleteDcdnUserConfig(request: DeleteDcdnUserConfigRequest): Promise<DeleteDcdnUserConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDcdnUserConfigWithOptions(request, runtime);
  }

  /**
   * Deletes a custom WAF rule group.
   * 
   * @param request - DeleteDcdnWafGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDcdnWafGroupResponse
   */
  async deleteDcdnWafGroupWithOptions(request: DeleteDcdnWafGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDcdnWafGroupResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDcdnWafGroup",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDcdnWafGroupResponse>(await this.callApi(params, req, runtime), new DeleteDcdnWafGroupResponse({}));
  }

  /**
   * Deletes a custom WAF rule group.
   * 
   * @param request - DeleteDcdnWafGroupRequest
   * @returns DeleteDcdnWafGroupResponse
   */
  async deleteDcdnWafGroup(request: DeleteDcdnWafGroupRequest): Promise<DeleteDcdnWafGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDcdnWafGroupWithOptions(request, runtime);
  }

  /**
   * Deletes a protection policy.
   * 
   * @remarks
   *   You can call this operation up to 20 times per second per account.
   * *   Alibaba Cloud Dynamic Content Delivery Network (DCDN) supports POST requests.
   * 
   * @param request - DeleteDcdnWafPolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDcdnWafPolicyResponse
   */
  async deleteDcdnWafPolicyWithOptions(request: DeleteDcdnWafPolicyRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDcdnWafPolicyResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.policyId)) {
      body["PolicyId"] = request.policyId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDcdnWafPolicy",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDcdnWafPolicyResponse>(await this.callApi(params, req, runtime), new DeleteDcdnWafPolicyResponse({}));
  }

  /**
   * Deletes a protection policy.
   * 
   * @remarks
   *   You can call this operation up to 20 times per second per account.
   * *   Alibaba Cloud Dynamic Content Delivery Network (DCDN) supports POST requests.
   * 
   * @param request - DeleteDcdnWafPolicyRequest
   * @returns DeleteDcdnWafPolicyResponse
   */
  async deleteDcdnWafPolicy(request: DeleteDcdnWafPolicyRequest): Promise<DeleteDcdnWafPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDcdnWafPolicyWithOptions(request, runtime);
  }

  /**
   * Deletes a routine.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DeleteRoutineRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRoutineResponse
   */
  async deleteRoutineWithOptions(request: DeleteRoutineRequest, runtime: $Util.RuntimeOptions): Promise<DeleteRoutineResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteRoutine",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteRoutineResponse>(await this.callApi(params, req, runtime), new DeleteRoutineResponse({}));
  }

  /**
   * Deletes a routine.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DeleteRoutineRequest
   * @returns DeleteRoutineResponse
   */
  async deleteRoutine(request: DeleteRoutineRequest): Promise<DeleteRoutineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteRoutineWithOptions(request, runtime);
  }

  /**
   * Deletes the code of the specified version from a routine.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DeleteRoutineCodeRevisionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRoutineCodeRevisionResponse
   */
  async deleteRoutineCodeRevisionWithOptions(request: DeleteRoutineCodeRevisionRequest, runtime: $Util.RuntimeOptions): Promise<DeleteRoutineCodeRevisionResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.selectCodeRevision)) {
      body["SelectCodeRevision"] = request.selectCodeRevision;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteRoutineCodeRevision",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteRoutineCodeRevisionResponse>(await this.callApi(params, req, runtime), new DeleteRoutineCodeRevisionResponse({}));
  }

  /**
   * Deletes the code of the specified version from a routine.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DeleteRoutineCodeRevisionRequest
   * @returns DeleteRoutineCodeRevisionResponse
   */
  async deleteRoutineCodeRevision(request: DeleteRoutineCodeRevisionRequest): Promise<DeleteRoutineCodeRevisionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteRoutineCodeRevisionWithOptions(request, runtime);
  }

  /**
   * Deletes canary release environments from a routine.
   * 
   * @remarks
   * > 
   * *   This operation deletes only custom preset canary release environments. You cannot delete production or staging environments.
   * *   You can call this operation up to 100 times per second per account.
   * 
   * @param tmpReq - DeleteRoutineConfEnvsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRoutineConfEnvsResponse
   */
  async deleteRoutineConfEnvsWithOptions(tmpReq: DeleteRoutineConfEnvsRequest, runtime: $Util.RuntimeOptions): Promise<DeleteRoutineConfEnvsResponse> {
    Util.validateModel(tmpReq);
    let request = new DeleteRoutineConfEnvsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.envs)) {
      request.envsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.envs, "Envs", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.envsShrink)) {
      body["Envs"] = request.envsShrink;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteRoutineConfEnvs",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteRoutineConfEnvsResponse>(await this.callApi(params, req, runtime), new DeleteRoutineConfEnvsResponse({}));
  }

  /**
   * Deletes canary release environments from a routine.
   * 
   * @remarks
   * > 
   * *   This operation deletes only custom preset canary release environments. You cannot delete production or staging environments.
   * *   You can call this operation up to 100 times per second per account.
   * 
   * @param request - DeleteRoutineConfEnvsRequest
   * @returns DeleteRoutineConfEnvsResponse
   */
  async deleteRoutineConfEnvs(request: DeleteRoutineConfEnvsRequest): Promise<DeleteRoutineConfEnvsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteRoutineConfEnvsWithOptions(request, runtime);
  }

  /**
   * Queries precise access control rules.
   * 
   * @remarks
   * > You can call this operation up to three times per second per account.
   * 
   * @param request - DescribeDcdnAclFieldsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnAclFieldsResponse
   */
  async describeDcdnAclFieldsWithOptions(request: DescribeDcdnAclFieldsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnAclFieldsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnAclFields",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnAclFieldsResponse>(await this.callApi(params, req, runtime), new DescribeDcdnAclFieldsResponse({}));
  }

  /**
   * Queries precise access control rules.
   * 
   * @remarks
   * > You can call this operation up to three times per second per account.
   * 
   * @param request - DescribeDcdnAclFieldsRequest
   * @returns DescribeDcdnAclFieldsResponse
   */
  async describeDcdnAclFields(request: DescribeDcdnAclFieldsRequest): Promise<DescribeDcdnAclFieldsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnAclFieldsWithOptions(request, runtime);
  }

  /**
   * Queries bandwidth data for Border Gateway Protocol (BGP) accelerated domain names. Data is collected every 5 minutes.
   * 
   * @remarks
   *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range. You must set both parameters or leave both of them empty.
   * *   If you specify multiple Internet service providers (ISPs), the data for the ISPs is aggregated.
   * *   You can query data in the last 90 days.
   * *   The maximum time range from the start time to the end time is 31 days. The start time is specified by the StartTime parameter and the end time is specified by the EndTime parameter.
   * *   If the time range from the start time to the end time is 72 hours or shorter, you can specify the interval as 5 minutes. If the time range is longer than 72 hours, you must specify the interval as 1 hour.
   * *   You can call this operation up to five times per second per account.
   * 
   * @param request - DescribeDcdnBgpBpsDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnBgpBpsDataResponse
   */
  async describeDcdnBgpBpsDataWithOptions(request: DescribeDcdnBgpBpsDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnBgpBpsDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deviceName)) {
      query["DeviceName"] = request.deviceName;
    }

    if (!Util.isUnset(request.devicePort)) {
      query["DevicePort"] = request.devicePort;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.isp)) {
      query["Isp"] = request.isp;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnBgpBpsData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnBgpBpsDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnBgpBpsDataResponse({}));
  }

  /**
   * Queries bandwidth data for Border Gateway Protocol (BGP) accelerated domain names. Data is collected every 5 minutes.
   * 
   * @remarks
   *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range. You must set both parameters or leave both of them empty.
   * *   If you specify multiple Internet service providers (ISPs), the data for the ISPs is aggregated.
   * *   You can query data in the last 90 days.
   * *   The maximum time range from the start time to the end time is 31 days. The start time is specified by the StartTime parameter and the end time is specified by the EndTime parameter.
   * *   If the time range from the start time to the end time is 72 hours or shorter, you can specify the interval as 5 minutes. If the time range is longer than 72 hours, you must specify the interval as 1 hour.
   * *   You can call this operation up to five times per second per account.
   * 
   * @param request - DescribeDcdnBgpBpsDataRequest
   * @returns DescribeDcdnBgpBpsDataResponse
   */
  async describeDcdnBgpBpsData(request: DescribeDcdnBgpBpsDataRequest): Promise<DescribeDcdnBgpBpsDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnBgpBpsDataWithOptions(request, runtime);
  }

  /**
   * Queries traffic data for BGP accelerated domain names. Data is collected every 5 minutes.
   * 
   * @remarks
   *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range. You must set both parameters or leave both parameters empty.
   * *   If you specify multiple Internet service providers (ISPs), the data for the ISPs is aggregated.
   * *   You can query data in the last 90 days.
   * *   The maximum time range that you can specify is 31 days. StartTime specifies the start time and EndTime specifies the end time of the time range.
   * *   If the time range from the start time to the end time is 72 hours or shorter, you can specify the interval as 5 minutes. If the time range is longer than 72 hours, you must specify the interval as 1 hour.
   * *   You can call this operation up to five times per second per account.
   * 
   * @param request - DescribeDcdnBgpTrafficDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnBgpTrafficDataResponse
   */
  async describeDcdnBgpTrafficDataWithOptions(request: DescribeDcdnBgpTrafficDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnBgpTrafficDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.isp)) {
      query["Isp"] = request.isp;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnBgpTrafficData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnBgpTrafficDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnBgpTrafficDataResponse({}));
  }

  /**
   * Queries traffic data for BGP accelerated domain names. Data is collected every 5 minutes.
   * 
   * @remarks
   *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range. You must set both parameters or leave both parameters empty.
   * *   If you specify multiple Internet service providers (ISPs), the data for the ISPs is aggregated.
   * *   You can query data in the last 90 days.
   * *   The maximum time range that you can specify is 31 days. StartTime specifies the start time and EndTime specifies the end time of the time range.
   * *   If the time range from the start time to the end time is 72 hours or shorter, you can specify the interval as 5 minutes. If the time range is longer than 72 hours, you must specify the interval as 1 hour.
   * *   You can call this operation up to five times per second per account.
   * 
   * @param request - DescribeDcdnBgpTrafficDataRequest
   * @returns DescribeDcdnBgpTrafficDataResponse
   */
  async describeDcdnBgpTrafficData(request: DescribeDcdnBgpTrafficDataRequest): Promise<DescribeDcdnBgpTrafficDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnBgpTrafficDataWithOptions(request, runtime);
  }

  /**
   * Queries countries and regions that can be added to the blacklist.
   * 
   * @remarks
   * > You can call this operation up to 50 times per second per account.
   * 
   * @param request - DescribeDcdnBlockedRegionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnBlockedRegionsResponse
   */
  async describeDcdnBlockedRegionsWithOptions(request: DescribeDcdnBlockedRegionsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnBlockedRegionsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnBlockedRegions",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnBlockedRegionsResponse>(await this.callApi(params, req, runtime), new DescribeDcdnBlockedRegionsResponse({}));
  }

  /**
   * Queries countries and regions that can be added to the blacklist.
   * 
   * @remarks
   * > You can call this operation up to 50 times per second per account.
   * 
   * @param request - DescribeDcdnBlockedRegionsRequest
   * @returns DescribeDcdnBlockedRegionsResponse
   */
  async describeDcdnBlockedRegions(request: DescribeDcdnBlockedRegionsRequest): Promise<DescribeDcdnBlockedRegionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnBlockedRegionsWithOptions(request, runtime);
  }

  /**
   * Queries details about a certificate.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeDcdnCertificateDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnCertificateDetailResponse
   */
  async describeDcdnCertificateDetailWithOptions(request: DescribeDcdnCertificateDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnCertificateDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.certName)) {
      query["CertName"] = request.certName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnCertificateDetail",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnCertificateDetailResponse>(await this.callApi(params, req, runtime), new DescribeDcdnCertificateDetailResponse({}));
  }

  /**
   * Queries details about a certificate.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeDcdnCertificateDetailRequest
   * @returns DescribeDcdnCertificateDetailResponse
   */
  async describeDcdnCertificateDetail(request: DescribeDcdnCertificateDetailRequest): Promise<DescribeDcdnCertificateDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnCertificateDetailWithOptions(request, runtime);
  }

  /**
   * Queries the certificates of one or more accelerated domain names.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @deprecated OpenAPI DescribeDcdnCertificateList is deprecated, please use dcdn::2018-01-15::DescribeDcdnSSLCertificateList instead.
   * 
   * @param request - DescribeDcdnCertificateListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnCertificateListResponse
   */
  // Deprecated
  async describeDcdnCertificateListWithOptions(request: DescribeDcdnCertificateListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnCertificateListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnCertificateList",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnCertificateListResponse>(await this.callApi(params, req, runtime), new DescribeDcdnCertificateListResponse({}));
  }

  /**
   * Queries the certificates of one or more accelerated domain names.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @deprecated OpenAPI DescribeDcdnCertificateList is deprecated, please use dcdn::2018-01-15::DescribeDcdnSSLCertificateList instead.
   * 
   * @param request - DescribeDcdnCertificateListRequest
   * @returns DescribeDcdnCertificateListResponse
   */
  // Deprecated
  async describeDcdnCertificateList(request: DescribeDcdnCertificateListRequest): Promise<DescribeDcdnCertificateListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnCertificateListWithOptions(request, runtime);
  }

  /**
   * Queries the status of DCDN DDoS mitigation.
   * 
   * @param request - DescribeDcdnDdosServiceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDdosServiceResponse
   */
  async describeDcdnDdosServiceWithOptions(request: DescribeDcdnDdosServiceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDdosServiceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDdosService",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDdosServiceResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDdosServiceResponse({}));
  }

  /**
   * Queries the status of DCDN DDoS mitigation.
   * 
   * @param request - DescribeDcdnDdosServiceRequest
   * @returns DescribeDcdnDdosServiceResponse
   */
  async describeDcdnDdosService(request: DescribeDcdnDdosServiceRequest): Promise<DescribeDcdnDdosServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDdosServiceWithOptions(request, runtime);
  }

  /**
   * Queries the specifications of DCDN DDoS versions.
   * 
   * @param request - DescribeDcdnDdosSpecInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDdosSpecInfoResponse
   */
  async describeDcdnDdosSpecInfoWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDdosSpecInfoResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDdosSpecInfo",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDdosSpecInfoResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDdosSpecInfoResponse({}));
  }

  /**
   * Queries the specifications of DCDN DDoS versions.
   * @returns DescribeDcdnDdosSpecInfoResponse
   */
  async describeDcdnDdosSpecInfo(): Promise<DescribeDcdnDdosSpecInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDdosSpecInfoWithOptions(runtime);
  }

  /**
   * Queries the domain names that are deleted from your Alibaba Cloud account.
   * 
   * @remarks
   * > You can call this operation up to 10 times per second per account.
   * 
   * @param request - DescribeDcdnDeletedDomainsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDeletedDomainsResponse
   */
  async describeDcdnDeletedDomainsWithOptions(request: DescribeDcdnDeletedDomainsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDeletedDomainsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDeletedDomains",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDeletedDomainsResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDeletedDomainsResponse({}));
  }

  /**
   * Queries the domain names that are deleted from your Alibaba Cloud account.
   * 
   * @remarks
   * > You can call this operation up to 10 times per second per account.
   * 
   * @param request - DescribeDcdnDeletedDomainsRequest
   * @returns DescribeDcdnDeletedDomainsResponse
   */
  async describeDcdnDeletedDomains(request: DescribeDcdnDeletedDomainsRequest): Promise<DescribeDcdnDeletedDomainsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDeletedDomainsWithOptions(request, runtime);
  }

  /**
   * Queries all tracking tasks of operations reports.
   * 
   * @remarks
   * >You can call this operation up to three times per second.
   * 
   * @param request - DescribeDcdnDeliverListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDeliverListResponse
   */
  async describeDcdnDeliverListWithOptions(request: DescribeDcdnDeliverListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDeliverListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deliverId)) {
      query["DeliverId"] = request.deliverId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDeliverList",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDeliverListResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDeliverListResponse({}));
  }

  /**
   * Queries all tracking tasks of operations reports.
   * 
   * @remarks
   * >You can call this operation up to three times per second.
   * 
   * @param request - DescribeDcdnDeliverListRequest
   * @returns DescribeDcdnDeliverListResponse
   */
  async describeDcdnDeliverList(request: DescribeDcdnDeliverListRequest): Promise<DescribeDcdnDeliverListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDeliverListWithOptions(request, runtime);
  }

  /**
   * Queries the monitoring data of network bandwidth for one or more accelerated domain names. You can query data in the last 90 days.
   * 
   * @remarks
   * You can call this operation up to 100 times per second per account.
   * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * |1 day|366 days|366 days|04:00 on the next day|
   * 
   * @param request - DescribeDcdnDomainBpsDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainBpsDataResponse
   */
  async describeDcdnDomainBpsDataWithOptions(request: DescribeDcdnDomainBpsDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainBpsDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ispNameEn)) {
      query["IspNameEn"] = request.ispNameEn;
    }

    if (!Util.isUnset(request.locationNameEn)) {
      query["LocationNameEn"] = request.locationNameEn;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainBpsData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainBpsDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainBpsDataResponse({}));
  }

  /**
   * Queries the monitoring data of network bandwidth for one or more accelerated domain names. You can query data in the last 90 days.
   * 
   * @remarks
   * You can call this operation up to 100 times per second per account.
   * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * |1 day|366 days|366 days|04:00 on the next day|
   * 
   * @param request - DescribeDcdnDomainBpsDataRequest
   * @returns DescribeDcdnDomainBpsDataResponse
   */
  async describeDcdnDomainBpsData(request: DescribeDcdnDomainBpsDataRequest): Promise<DescribeDcdnDomainBpsDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainBpsDataWithOptions(request, runtime);
  }

  /**
   * Queries bandwidth data of accelerated domain names.
   * 
   * @remarks
   * You can call this operation up to 20 times per second per account.
   * * If you do not set **StartTime** or **EndTime**, the request returns the data collected in the last 24 hours. If you set both **StartTime** and **EndTime**, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the time range to query, as described in the following table.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * |1 day|366 days|366 days|04:00 on the next day|
   * 
   * @param request - DescribeDcdnDomainBpsDataByLayerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainBpsDataByLayerResponse
   */
  async describeDcdnDomainBpsDataByLayerWithOptions(request: DescribeDcdnDomainBpsDataByLayerRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainBpsDataByLayerResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ispNameEn)) {
      query["IspNameEn"] = request.ispNameEn;
    }

    if (!Util.isUnset(request.layer)) {
      query["Layer"] = request.layer;
    }

    if (!Util.isUnset(request.locationNameEn)) {
      query["LocationNameEn"] = request.locationNameEn;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainBpsDataByLayer",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainBpsDataByLayerResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainBpsDataByLayerResponse({}));
  }

  /**
   * Queries bandwidth data of accelerated domain names.
   * 
   * @remarks
   * You can call this operation up to 20 times per second per account.
   * * If you do not set **StartTime** or **EndTime**, the request returns the data collected in the last 24 hours. If you set both **StartTime** and **EndTime**, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the time range to query, as described in the following table.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * |1 day|366 days|366 days|04:00 on the next day|
   * 
   * @param request - DescribeDcdnDomainBpsDataByLayerRequest
   * @returns DescribeDcdnDomainBpsDataByLayerResponse
   */
  async describeDcdnDomainBpsDataByLayer(request: DescribeDcdnDomainBpsDataByLayerRequest): Promise<DescribeDcdnDomainBpsDataByLayerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainBpsDataByLayerWithOptions(request, runtime);
  }

  /**
   * Queries accelerated domain names by SSL certificate.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnDomainByCertificateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainByCertificateResponse
   */
  async describeDcdnDomainByCertificateWithOptions(request: DescribeDcdnDomainByCertificateRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainByCertificateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.exact)) {
      query["Exact"] = request.exact;
    }

    if (!Util.isUnset(request.SSLPub)) {
      query["SSLPub"] = request.SSLPub;
    }

    if (!Util.isUnset(request.SSLStatus)) {
      query["SSLStatus"] = request.SSLStatus;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainByCertificate",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainByCertificateResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainByCertificateResponse({}));
  }

  /**
   * Queries accelerated domain names by SSL certificate.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnDomainByCertificateRequest
   * @returns DescribeDcdnDomainByCertificateResponse
   */
  async describeDcdnDomainByCertificate(request: DescribeDcdnDomainByCertificateRequest): Promise<DescribeDcdnDomainByCertificateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainByCertificateWithOptions(request, runtime);
  }

  /**
   * Queries logs of rate limiting.
   * 
   * @remarks
   * > 
   * *   If you do not configure the StartTime or EndTime parameter, data collected over the last 24 hours is queried. If you configure both the StartTime and EndTime parameters, data collected within the specified time range is queried.
   * *   You can query data collected over the last 30 days.
   * *   You can call the RefreshObjectCaches operation up to 50 times per second per account.
   * 
   * @param request - DescribeDcdnDomainCcActivityLogRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainCcActivityLogResponse
   */
  async describeDcdnDomainCcActivityLogWithOptions(request: DescribeDcdnDomainCcActivityLogRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainCcActivityLogResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.triggerObject)) {
      query["TriggerObject"] = request.triggerObject;
    }

    if (!Util.isUnset(request.value)) {
      query["Value"] = request.value;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainCcActivityLog",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainCcActivityLogResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainCcActivityLogResponse({}));
  }

  /**
   * Queries logs of rate limiting.
   * 
   * @remarks
   * > 
   * *   If you do not configure the StartTime or EndTime parameter, data collected over the last 24 hours is queried. If you configure both the StartTime and EndTime parameters, data collected within the specified time range is queried.
   * *   You can query data collected over the last 30 days.
   * *   You can call the RefreshObjectCaches operation up to 50 times per second per account.
   * 
   * @param request - DescribeDcdnDomainCcActivityLogRequest
   * @returns DescribeDcdnDomainCcActivityLogResponse
   */
  async describeDcdnDomainCcActivityLog(request: DescribeDcdnDomainCcActivityLogRequest): Promise<DescribeDcdnDomainCcActivityLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainCcActivityLogWithOptions(request, runtime);
  }

  /**
   * Queries the certificate information about an accelerated domain name.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnDomainCertificateInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainCertificateInfoResponse
   */
  async describeDcdnDomainCertificateInfoWithOptions(request: DescribeDcdnDomainCertificateInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainCertificateInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainCertificateInfo",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainCertificateInfoResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainCertificateInfoResponse({}));
  }

  /**
   * Queries the certificate information about an accelerated domain name.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnDomainCertificateInfoRequest
   * @returns DescribeDcdnDomainCertificateInfoResponse
   */
  async describeDcdnDomainCertificateInfo(request: DescribeDcdnDomainCertificateInfoRequest): Promise<DescribeDcdnDomainCertificateInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainCertificateInfoWithOptions(request, runtime);
  }

  /**
   * Checks whether CNAME records are configured for one or more accelerated domain names.
   * 
   * @remarks
   * > You can call this operation up to 80 times per second per account.
   * 
   * @param request - DescribeDcdnDomainCnameRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainCnameResponse
   */
  async describeDcdnDomainCnameWithOptions(request: DescribeDcdnDomainCnameRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainCnameResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainCname",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainCnameResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainCnameResponse({}));
  }

  /**
   * Checks whether CNAME records are configured for one or more accelerated domain names.
   * 
   * @remarks
   * > You can call this operation up to 80 times per second per account.
   * 
   * @param request - DescribeDcdnDomainCnameRequest
   * @returns DescribeDcdnDomainCnameResponse
   */
  async describeDcdnDomainCname(request: DescribeDcdnDomainCnameRequest): Promise<DescribeDcdnDomainCnameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainCnameWithOptions(request, runtime);
  }

  /**
   * Queries the configurations of an accelerated domain name.
   * 
   * @remarks
   * > *   You can query the configurations of one or more features in a request.
   * > *   You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeDcdnDomainConfigsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainConfigsResponse
   */
  async describeDcdnDomainConfigsWithOptions(request: DescribeDcdnDomainConfigsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainConfigsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.functionNames)) {
      query["FunctionNames"] = request.functionNames;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainConfigs",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainConfigsResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainConfigsResponse({}));
  }

  /**
   * Queries the configurations of an accelerated domain name.
   * 
   * @remarks
   * > *   You can query the configurations of one or more features in a request.
   * > *   You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeDcdnDomainConfigsRequest
   * @returns DescribeDcdnDomainConfigsResponse
   */
  async describeDcdnDomainConfigs(request: DescribeDcdnDomainConfigsRequest): Promise<DescribeDcdnDomainConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainConfigsWithOptions(request, runtime);
  }

  /**
   * Queries the basic configuration information about an accelerated domain name.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeDcdnDomainDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainDetailResponse
   */
  async describeDcdnDomainDetailWithOptions(request: DescribeDcdnDomainDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainDetail",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainDetailResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainDetailResponse({}));
  }

  /**
   * Queries the basic configuration information about an accelerated domain name.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeDcdnDomainDetailRequest
   * @returns DescribeDcdnDomainDetailResponse
   */
  async describeDcdnDomainDetail(request: DescribeDcdnDomainDetailRequest): Promise<DescribeDcdnDomainDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainDetailWithOptions(request, runtime);
  }

  /**
   * Queries the request hit ratios of one or more accelerated domain names. You can query data collected within the last 90 days.
   * 
   * @remarks
   * #
   * *   You can call this operation up to 100 times per second per account.
   * *   If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * **Time granularity** The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table. |Time granularity |Maximum time range per query |Historical data available |Data delay | -------------- | -------------- | ------ |5 minutes |3 days |93 days |15 minutes |1 hour |31 days |186 days |4 hours |1 day |366 days |366 days |04:00 on the next day
   * 
   * @param request - DescribeDcdnDomainHitRateDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainHitRateDataResponse
   */
  async describeDcdnDomainHitRateDataWithOptions(request: DescribeDcdnDomainHitRateDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainHitRateDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainHitRateData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainHitRateDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainHitRateDataResponse({}));
  }

  /**
   * Queries the request hit ratios of one or more accelerated domain names. You can query data collected within the last 90 days.
   * 
   * @remarks
   * #
   * *   You can call this operation up to 100 times per second per account.
   * *   If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * **Time granularity** The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table. |Time granularity |Maximum time range per query |Historical data available |Data delay | -------------- | -------------- | ------ |5 minutes |3 days |93 days |15 minutes |1 hour |31 days |186 days |4 hours |1 day |366 days |366 days |04:00 on the next day
   * 
   * @param request - DescribeDcdnDomainHitRateDataRequest
   * @returns DescribeDcdnDomainHitRateDataResponse
   */
  async describeDcdnDomainHitRateData(request: DescribeDcdnDomainHitRateDataRequest): Promise<DescribeDcdnDomainHitRateDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainHitRateDataWithOptions(request, runtime);
  }

  /**
   * Queries the total number and proportions of HTTP status codes returned from one or more accelerated domain names. Data is collected every 5 minutes. You can query data in the last 90 days.
   * 
   * @remarks
   * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * * You can call this operation up to 100 times per second per account.
   * **Time granularity**
   * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * |1 day|366 days|366 days|04:00 on the next day|
   * 
   * @param request - DescribeDcdnDomainHttpCodeDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainHttpCodeDataResponse
   */
  async describeDcdnDomainHttpCodeDataWithOptions(request: DescribeDcdnDomainHttpCodeDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainHttpCodeDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ispNameEn)) {
      query["IspNameEn"] = request.ispNameEn;
    }

    if (!Util.isUnset(request.locationNameEn)) {
      query["LocationNameEn"] = request.locationNameEn;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainHttpCodeData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainHttpCodeDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainHttpCodeDataResponse({}));
  }

  /**
   * Queries the total number and proportions of HTTP status codes returned from one or more accelerated domain names. Data is collected every 5 minutes. You can query data in the last 90 days.
   * 
   * @remarks
   * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * * You can call this operation up to 100 times per second per account.
   * **Time granularity**
   * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * |1 day|366 days|366 days|04:00 on the next day|
   * 
   * @param request - DescribeDcdnDomainHttpCodeDataRequest
   * @returns DescribeDcdnDomainHttpCodeDataResponse
   */
  async describeDcdnDomainHttpCodeData(request: DescribeDcdnDomainHttpCodeDataRequest): Promise<DescribeDcdnDomainHttpCodeDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainHttpCodeDataWithOptions(request, runtime);
  }

  /**
   * Queries the distribution of HTTP status codes by protocol.
   * 
   * @remarks
   * You can call this operation up to 20 times per second per account.
   * * You cannot query the distribution of HTTP status codes by IP protocol.
   * * If you do not specify the **StartTime** or **EndTime** parameter, the data that is collected within the last 24 hours is collected. If you specify both the **StartTime** and **EndTime** parameters, the data that is collected within the time range that you specify is collected.
   * **Time granularity**
   * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * |1 day|366 days|366 days|04:00 on the next day|
   * 
   * @param request - DescribeDcdnDomainHttpCodeDataByLayerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainHttpCodeDataByLayerResponse
   */
  async describeDcdnDomainHttpCodeDataByLayerWithOptions(request: DescribeDcdnDomainHttpCodeDataByLayerRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainHttpCodeDataByLayerResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ispNameEn)) {
      query["IspNameEn"] = request.ispNameEn;
    }

    if (!Util.isUnset(request.layer)) {
      query["Layer"] = request.layer;
    }

    if (!Util.isUnset(request.locationNameEn)) {
      query["LocationNameEn"] = request.locationNameEn;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainHttpCodeDataByLayer",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainHttpCodeDataByLayerResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainHttpCodeDataByLayerResponse({}));
  }

  /**
   * Queries the distribution of HTTP status codes by protocol.
   * 
   * @remarks
   * You can call this operation up to 20 times per second per account.
   * * You cannot query the distribution of HTTP status codes by IP protocol.
   * * If you do not specify the **StartTime** or **EndTime** parameter, the data that is collected within the last 24 hours is collected. If you specify both the **StartTime** and **EndTime** parameters, the data that is collected within the time range that you specify is collected.
   * **Time granularity**
   * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * |1 day|366 days|366 days|04:00 on the next day|
   * 
   * @param request - DescribeDcdnDomainHttpCodeDataByLayerRequest
   * @returns DescribeDcdnDomainHttpCodeDataByLayerResponse
   */
  async describeDcdnDomainHttpCodeDataByLayer(request: DescribeDcdnDomainHttpCodeDataByLayerRequest): Promise<DescribeDcdnDomainHttpCodeDataByLayerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainHttpCodeDataByLayerWithOptions(request, runtime);
  }

  /**
   * Queries bandwidth of accelerated domain names for which Layer 4 acceleration is enabled. You can query the data that is collected over the last 90 days.
   * 
   * @remarks
   * > 
   * *   The bandwidth is measured in bit/s.
   * *   If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * *   You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnDomainIpaBpsDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainIpaBpsDataResponse
   */
  async describeDcdnDomainIpaBpsDataWithOptions(request: DescribeDcdnDomainIpaBpsDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainIpaBpsDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.fixTimeGap)) {
      query["FixTimeGap"] = request.fixTimeGap;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ispNameEn)) {
      query["IspNameEn"] = request.ispNameEn;
    }

    if (!Util.isUnset(request.locationNameEn)) {
      query["LocationNameEn"] = request.locationNameEn;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.timeMerge)) {
      query["TimeMerge"] = request.timeMerge;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainIpaBpsData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainIpaBpsDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainIpaBpsDataResponse({}));
  }

  /**
   * Queries bandwidth of accelerated domain names for which Layer 4 acceleration is enabled. You can query the data that is collected over the last 90 days.
   * 
   * @remarks
   * > 
   * *   The bandwidth is measured in bit/s.
   * *   If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * *   You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnDomainIpaBpsDataRequest
   * @returns DescribeDcdnDomainIpaBpsDataResponse
   */
  async describeDcdnDomainIpaBpsData(request: DescribeDcdnDomainIpaBpsDataRequest): Promise<DescribeDcdnDomainIpaBpsDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainIpaBpsDataWithOptions(request, runtime);
  }

  /**
   * Queries the number of IPA user connections.
   * 
   * @remarks
   *   You can call this operation up to 10 times per second per user.
   * *   If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * *   The minimum time granularity at which the data is queried is 5 minutes. The maximum time range for a single query is 31 days. The period within which historical data is available is 366 days. The data latency is no more than 10 minutes.
   * 
   * @param request - DescribeDcdnDomainIpaConnDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainIpaConnDataResponse
   */
  async describeDcdnDomainIpaConnDataWithOptions(request: DescribeDcdnDomainIpaConnDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainIpaConnDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.splitBy)) {
      query["SplitBy"] = request.splitBy;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainIpaConnData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainIpaConnDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainIpaConnDataResponse({}));
  }

  /**
   * Queries the number of IPA user connections.
   * 
   * @remarks
   *   You can call this operation up to 10 times per second per user.
   * *   If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * *   The minimum time granularity at which the data is queried is 5 minutes. The maximum time range for a single query is 31 days. The period within which historical data is available is 366 days. The data latency is no more than 10 minutes.
   * 
   * @param request - DescribeDcdnDomainIpaConnDataRequest
   * @returns DescribeDcdnDomainIpaConnDataResponse
   */
  async describeDcdnDomainIpaConnData(request: DescribeDcdnDomainIpaConnDataRequest): Promise<DescribeDcdnDomainIpaConnDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainIpaConnDataWithOptions(request, runtime);
  }

  /**
   * Queries traffic of one or more accelerated domain names for which Layer 4 acceleration is enabled. You can query the data that is collected over the last 90 days.
   * 
   * @remarks
   * > 
   * *   If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * *   Unit: bytes.
   * *   You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnDomainIpaTrafficDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainIpaTrafficDataResponse
   */
  async describeDcdnDomainIpaTrafficDataWithOptions(request: DescribeDcdnDomainIpaTrafficDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainIpaTrafficDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.fixTimeGap)) {
      query["FixTimeGap"] = request.fixTimeGap;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ispNameEn)) {
      query["IspNameEn"] = request.ispNameEn;
    }

    if (!Util.isUnset(request.locationNameEn)) {
      query["LocationNameEn"] = request.locationNameEn;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.timeMerge)) {
      query["TimeMerge"] = request.timeMerge;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainIpaTrafficData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainIpaTrafficDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainIpaTrafficDataResponse({}));
  }

  /**
   * Queries traffic of one or more accelerated domain names for which Layer 4 acceleration is enabled. You can query the data that is collected over the last 90 days.
   * 
   * @remarks
   * > 
   * *   If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * *   Unit: bytes.
   * *   You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnDomainIpaTrafficDataRequest
   * @returns DescribeDcdnDomainIpaTrafficDataResponse
   */
  async describeDcdnDomainIpaTrafficData(request: DescribeDcdnDomainIpaTrafficDataRequest): Promise<DescribeDcdnDomainIpaTrafficDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainIpaTrafficDataWithOptions(request, runtime);
  }

  /**
   * Queries the proportions of data usage of different Internet service providers (ISPs). You can query data within the last 90 days.
   * 
   * @remarks
   * > 
   * *   You can call this operation up to 100 times per second per account.
   * *   If **StartTime** is set but **EndTime** is not set, the data within the hour that starts from **StartTime** is queried.
   * *   If **EndTime** is set but **StartTime** is not set, the data within the last hour that precedes **EndTime** is queried.
   * *   You can query data of a domain name or all domain names that belong to your account.
   * *   You can view data that is collected over the last seven days. The interval at which data is queried is based on the time range specified by **StartTime** and **EndTime**.
   *     *   **If the time range is shorter than or equal to one hour**, data is queried every minute.
   *     *   **If the time range is longer than 1 hour but shorter than or equal to three days**, data is queried every five minutes.
   *     *   **If the time range is longer than three days but shorter than or equal to seven days**, data is queried every hour.
   * 
   * @param request - DescribeDcdnDomainIspDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainIspDataResponse
   */
  async describeDcdnDomainIspDataWithOptions(request: DescribeDcdnDomainIspDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainIspDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainIspData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainIspDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainIspDataResponse({}));
  }

  /**
   * Queries the proportions of data usage of different Internet service providers (ISPs). You can query data within the last 90 days.
   * 
   * @remarks
   * > 
   * *   You can call this operation up to 100 times per second per account.
   * *   If **StartTime** is set but **EndTime** is not set, the data within the hour that starts from **StartTime** is queried.
   * *   If **EndTime** is set but **StartTime** is not set, the data within the last hour that precedes **EndTime** is queried.
   * *   You can query data of a domain name or all domain names that belong to your account.
   * *   You can view data that is collected over the last seven days. The interval at which data is queried is based on the time range specified by **StartTime** and **EndTime**.
   *     *   **If the time range is shorter than or equal to one hour**, data is queried every minute.
   *     *   **If the time range is longer than 1 hour but shorter than or equal to three days**, data is queried every five minutes.
   *     *   **If the time range is longer than three days but shorter than or equal to seven days**, data is queried every hour.
   * 
   * @param request - DescribeDcdnDomainIspDataRequest
   * @returns DescribeDcdnDomainIspDataResponse
   */
  async describeDcdnDomainIspData(request: DescribeDcdnDomainIspDataRequest): Promise<DescribeDcdnDomainIspDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainIspDataWithOptions(request, runtime);
  }

  /**
   * Queries the address where you can download the log data of a specific domain name.
   * 
   * @remarks
   * > 
   * *   If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.********
   * *   You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnDomainLogRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainLogResponse
   */
  async describeDcdnDomainLogWithOptions(request: DescribeDcdnDomainLogRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainLogResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainLog",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainLogResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainLogResponse({}));
  }

  /**
   * Queries the address where you can download the log data of a specific domain name.
   * 
   * @remarks
   * > 
   * *   If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.********
   * *   You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnDomainLogRequest
   * @returns DescribeDcdnDomainLogResponse
   */
  async describeDcdnDomainLog(request: DescribeDcdnDomainLogRequest): Promise<DescribeDcdnDomainLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainLogWithOptions(request, runtime);
  }

  /**
   * @param request - DescribeDcdnDomainLogExTtlRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainLogExTtlResponse
   */
  async describeDcdnDomainLogExTtlWithOptions(request: DescribeDcdnDomainLogExTtlRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainLogExTtlResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainLogExTtl",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainLogExTtlResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainLogExTtlResponse({}));
  }

  /**
   * @param request - DescribeDcdnDomainLogExTtlRequest
   * @returns DescribeDcdnDomainLogExTtlResponse
   */
  async describeDcdnDomainLogExTtl(request: DescribeDcdnDomainLogExTtlRequest): Promise<DescribeDcdnDomainLogExTtlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainLogExTtlWithOptions(request, runtime);
  }

  /**
   * Queries the billable items of accelerated domain names. The data is collected at least every 5 minutes. The billable items do not include non-request items.
   * 
   * @remarks
   *   If you do not set the StartTime or EndTime parameter, data within the last 10 minutes is queried. You can set both the StartTime and EndTime parameters to specify a time range.
   * *   You can specify one or more accelerated domain names. Separate domain names with commas (,).
   * *   You can query data within the last 90 days.
   * *   The time range cannot exceed 1 hour.
   * 
   * @param request - DescribeDcdnDomainMultiUsageDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainMultiUsageDataResponse
   */
  async describeDcdnDomainMultiUsageDataWithOptions(request: DescribeDcdnDomainMultiUsageDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainMultiUsageDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainMultiUsageData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainMultiUsageDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainMultiUsageDataResponse({}));
  }

  /**
   * Queries the billable items of accelerated domain names. The data is collected at least every 5 minutes. The billable items do not include non-request items.
   * 
   * @remarks
   *   If you do not set the StartTime or EndTime parameter, data within the last 10 minutes is queried. You can set both the StartTime and EndTime parameters to specify a time range.
   * *   You can specify one or more accelerated domain names. Separate domain names with commas (,).
   * *   You can query data within the last 90 days.
   * *   The time range cannot exceed 1 hour.
   * 
   * @param request - DescribeDcdnDomainMultiUsageDataRequest
   * @returns DescribeDcdnDomainMultiUsageDataResponse
   */
  async describeDcdnDomainMultiUsageData(request: DescribeDcdnDomainMultiUsageDataRequest): Promise<DescribeDcdnDomainMultiUsageDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainMultiUsageDataWithOptions(request, runtime);
  }

  /**
   * Queries the origin bandwidth data for one or more accelerated domain names. You can query data in the last 90 days.
   * 
   * @remarks
   * You can call this operation up to 100 times per second per account.
   * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * |1 day|366 days|366 days|04:00 on the next day|
   * 
   * @param request - DescribeDcdnDomainOriginBpsDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainOriginBpsDataResponse
   */
  async describeDcdnDomainOriginBpsDataWithOptions(request: DescribeDcdnDomainOriginBpsDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainOriginBpsDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainOriginBpsData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainOriginBpsDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainOriginBpsDataResponse({}));
  }

  /**
   * Queries the origin bandwidth data for one or more accelerated domain names. You can query data in the last 90 days.
   * 
   * @remarks
   * You can call this operation up to 100 times per second per account.
   * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * |1 day|366 days|366 days|04:00 on the next day|
   * 
   * @param request - DescribeDcdnDomainOriginBpsDataRequest
   * @returns DescribeDcdnDomainOriginBpsDataResponse
   */
  async describeDcdnDomainOriginBpsData(request: DescribeDcdnDomainOriginBpsDataRequest): Promise<DescribeDcdnDomainOriginBpsDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainOriginBpsDataWithOptions(request, runtime);
  }

  /**
   * Queries the back-to-origin traffic of one or more accelerated domain names.
   * 
   * @remarks
   * - You can call this operation up to 100 times per second per account.
   * - If you do not set the **StartTime** or **EndTime** parameters, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity supported by the Interval parameter varies with the maximum time range per query. The following table describes the time period within which historical data is available and the data delay. 
   * | Time granularity | Maximum time range per query | Historical data available | Data delay |
   * | ---------------- | ---------------------------- | ------------------------- | ---------- |
   * | 5 minutes | 3 days | 93 days | 15 minutes |
   * | 1 hour | 31 days | 186 days | 4 hours |
   * | 1 day | 366 days | 366 days | 04:00 on the next day |
   * 
   * @param request - DescribeDcdnDomainOriginTrafficDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainOriginTrafficDataResponse
   */
  async describeDcdnDomainOriginTrafficDataWithOptions(request: DescribeDcdnDomainOriginTrafficDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainOriginTrafficDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainOriginTrafficData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainOriginTrafficDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainOriginTrafficDataResponse({}));
  }

  /**
   * Queries the back-to-origin traffic of one or more accelerated domain names.
   * 
   * @remarks
   * - You can call this operation up to 100 times per second per account.
   * - If you do not set the **StartTime** or **EndTime** parameters, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity supported by the Interval parameter varies with the maximum time range per query. The following table describes the time period within which historical data is available and the data delay. 
   * | Time granularity | Maximum time range per query | Historical data available | Data delay |
   * | ---------------- | ---------------------------- | ------------------------- | ---------- |
   * | 5 minutes | 3 days | 93 days | 15 minutes |
   * | 1 hour | 31 days | 186 days | 4 hours |
   * | 1 day | 366 days | 366 days | 04:00 on the next day |
   * 
   * @param request - DescribeDcdnDomainOriginTrafficDataRequest
   * @returns DescribeDcdnDomainOriginTrafficDataResponse
   */
  async describeDcdnDomainOriginTrafficData(request: DescribeDcdnDomainOriginTrafficDataRequest): Promise<DescribeDcdnDomainOriginTrafficDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainOriginTrafficDataWithOptions(request, runtime);
  }

  /**
   * Queries the protocol type of IP Application Accelerator (IPA).
   * 
   * @remarks
   * > You can call this operation up to 10 times per second per account.
   * 
   * @param request - DescribeDcdnDomainPropertyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainPropertyResponse
   */
  async describeDcdnDomainPropertyWithOptions(request: DescribeDcdnDomainPropertyRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainPropertyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainProperty",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainPropertyResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainPropertyResponse({}));
  }

  /**
   * Queries the protocol type of IP Application Accelerator (IPA).
   * 
   * @remarks
   * > You can call this operation up to 10 times per second per account.
   * 
   * @param request - DescribeDcdnDomainPropertyRequest
   * @returns DescribeDcdnDomainPropertyResponse
   */
  async describeDcdnDomainProperty(request: DescribeDcdnDomainPropertyRequest): Promise<DescribeDcdnDomainPropertyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainPropertyWithOptions(request, runtime);
  }

  /**
   * Queries page view (PV) data of an accelerated domain name. Data can be collected at minimum intervals of one hour.
   * 
   * @param request - DescribeDcdnDomainPvDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainPvDataResponse
   */
  async describeDcdnDomainPvDataWithOptions(request: DescribeDcdnDomainPvDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainPvDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainPvData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainPvDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainPvDataResponse({}));
  }

  /**
   * Queries page view (PV) data of an accelerated domain name. Data can be collected at minimum intervals of one hour.
   * 
   * @param request - DescribeDcdnDomainPvDataRequest
   * @returns DescribeDcdnDomainPvDataResponse
   */
  async describeDcdnDomainPvData(request: DescribeDcdnDomainPvDataRequest): Promise<DescribeDcdnDomainPvDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainPvDataWithOptions(request, runtime);
  }

  /**
   * Queries the number of requests to an accelerated domain name per second. You can query data in the last 90 days.
   * 
   * @remarks
   * You can call this operation up to 100 times per second per account.
   * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * |1 day|366 days|366 days|04:00 on the next day|
   * 
   * @param request - DescribeDcdnDomainQpsDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainQpsDataResponse
   */
  async describeDcdnDomainQpsDataWithOptions(request: DescribeDcdnDomainQpsDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainQpsDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ispNameEn)) {
      query["IspNameEn"] = request.ispNameEn;
    }

    if (!Util.isUnset(request.locationNameEn)) {
      query["LocationNameEn"] = request.locationNameEn;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainQpsData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainQpsDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainQpsDataResponse({}));
  }

  /**
   * Queries the number of requests to an accelerated domain name per second. You can query data in the last 90 days.
   * 
   * @remarks
   * You can call this operation up to 100 times per second per account.
   * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * |1 day|366 days|366 days|04:00 on the next day|
   * 
   * @param request - DescribeDcdnDomainQpsDataRequest
   * @returns DescribeDcdnDomainQpsDataResponse
   */
  async describeDcdnDomainQpsData(request: DescribeDcdnDomainQpsDataRequest): Promise<DescribeDcdnDomainQpsDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainQpsDataWithOptions(request, runtime);
  }

  /**
   * The number of queries per second in the Chinese mainland.
   * 
   * @remarks
   * You can call this operation up to 20 times per second per account.
   * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the time range to query, as described in the following table.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * |1 day|366 days|366 days|04:00 on the next day|
   * 
   * @param request - DescribeDcdnDomainQpsDataByLayerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainQpsDataByLayerResponse
   */
  async describeDcdnDomainQpsDataByLayerWithOptions(request: DescribeDcdnDomainQpsDataByLayerRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainQpsDataByLayerResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ispNameEn)) {
      query["IspNameEn"] = request.ispNameEn;
    }

    if (!Util.isUnset(request.layer)) {
      query["Layer"] = request.layer;
    }

    if (!Util.isUnset(request.locationNameEn)) {
      query["LocationNameEn"] = request.locationNameEn;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainQpsDataByLayer",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainQpsDataByLayerResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainQpsDataByLayerResponse({}));
  }

  /**
   * The number of queries per second in the Chinese mainland.
   * 
   * @remarks
   * You can call this operation up to 20 times per second per account.
   * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the time range to query, as described in the following table.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * |1 day|366 days|366 days|04:00 on the next day|
   * 
   * @param request - DescribeDcdnDomainQpsDataByLayerRequest
   * @returns DescribeDcdnDomainQpsDataByLayerResponse
   */
  async describeDcdnDomainQpsDataByLayer(request: DescribeDcdnDomainQpsDataByLayerRequest): Promise<DescribeDcdnDomainQpsDataByLayerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainQpsDataByLayerWithOptions(request, runtime);
  }

  /**
   * Queries the real-time network bandwidth of a domain name.
   * 
   * @remarks
   * You can call this operation up to 10 times per second per account.
   * * If you do not specify **StartTime** or **EndTime**, the request returns the data collected in the last hour by default. If you specify both parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |1 minute|1 hour|7 days|5 minutes|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|3 to 4 hours|
   * 
   * @param request - DescribeDcdnDomainRealTimeBpsDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainRealTimeBpsDataResponse
   */
  async describeDcdnDomainRealTimeBpsDataWithOptions(request: DescribeDcdnDomainRealTimeBpsDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainRealTimeBpsDataResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainRealTimeBpsData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainRealTimeBpsDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainRealTimeBpsDataResponse({}));
  }

  /**
   * Queries the real-time network bandwidth of a domain name.
   * 
   * @remarks
   * You can call this operation up to 10 times per second per account.
   * * If you do not specify **StartTime** or **EndTime**, the request returns the data collected in the last hour by default. If you specify both parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |1 minute|1 hour|7 days|5 minutes|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|3 to 4 hours|
   * 
   * @param request - DescribeDcdnDomainRealTimeBpsDataRequest
   * @returns DescribeDcdnDomainRealTimeBpsDataResponse
   */
  async describeDcdnDomainRealTimeBpsData(request: DescribeDcdnDomainRealTimeBpsDataRequest): Promise<DescribeDcdnDomainRealTimeBpsDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainRealTimeBpsDataWithOptions(request, runtime);
  }

  /**
   * Queries byte hit ratios at a time granularity of 1 minute.
   * 
   * @remarks
   * You can call this operation up to 10 times per second per account.
   * * The network traffic destined for different domain names may be redirected to the same origin server. Therefore, the byte hit ratios may be inaccurate. The accuracy of query results is based on the actual configurations.
   * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last hour. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
   * | Time granularity | Maximum time range per query | Historical data available | Data delay |
   * |----|------|-----|--------|
   * | 1 minute | 1 hour | 7 days | 5 minutes |
   * | 5 minutes | 3 days | 93 days | 15 minutes |
   * | 1 hour | 31 days | 186 days | 4 hours |
   * 
   * @param request - DescribeDcdnDomainRealTimeByteHitRateDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainRealTimeByteHitRateDataResponse
   */
  async describeDcdnDomainRealTimeByteHitRateDataWithOptions(request: DescribeDcdnDomainRealTimeByteHitRateDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainRealTimeByteHitRateDataResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainRealTimeByteHitRateData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainRealTimeByteHitRateDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainRealTimeByteHitRateDataResponse({}));
  }

  /**
   * Queries byte hit ratios at a time granularity of 1 minute.
   * 
   * @remarks
   * You can call this operation up to 10 times per second per account.
   * * The network traffic destined for different domain names may be redirected to the same origin server. Therefore, the byte hit ratios may be inaccurate. The accuracy of query results is based on the actual configurations.
   * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last hour. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
   * | Time granularity | Maximum time range per query | Historical data available | Data delay |
   * |----|------|-----|--------|
   * | 1 minute | 1 hour | 7 days | 5 minutes |
   * | 5 minutes | 3 days | 93 days | 15 minutes |
   * | 1 hour | 31 days | 186 days | 4 hours |
   * 
   * @param request - DescribeDcdnDomainRealTimeByteHitRateDataRequest
   * @returns DescribeDcdnDomainRealTimeByteHitRateDataResponse
   */
  async describeDcdnDomainRealTimeByteHitRateData(request: DescribeDcdnDomainRealTimeByteHitRateDataRequest): Promise<DescribeDcdnDomainRealTimeByteHitRateDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainRealTimeByteHitRateDataWithOptions(request, runtime);
  }

  /**
   * Queries traffic data and the number of visits of each Internet service provider (ISP) in each region. Data is collected every minute. The maximum time range to query for this operation is 10 minutes.
   * 
   * @remarks
   * > You can call this operation up to 10 times per second per account.
   * 
   * @param request - DescribeDcdnDomainRealTimeDetailDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainRealTimeDetailDataResponse
   */
  async describeDcdnDomainRealTimeDetailDataWithOptions(request: DescribeDcdnDomainRealTimeDetailDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainRealTimeDetailDataResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainRealTimeDetailData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainRealTimeDetailDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainRealTimeDetailDataResponse({}));
  }

  /**
   * Queries traffic data and the number of visits of each Internet service provider (ISP) in each region. Data is collected every minute. The maximum time range to query for this operation is 10 minutes.
   * 
   * @remarks
   * > You can call this operation up to 10 times per second per account.
   * 
   * @param request - DescribeDcdnDomainRealTimeDetailDataRequest
   * @returns DescribeDcdnDomainRealTimeDetailDataResponse
   */
  async describeDcdnDomainRealTimeDetailData(request: DescribeDcdnDomainRealTimeDetailDataRequest): Promise<DescribeDcdnDomainRealTimeDetailDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainRealTimeDetailDataWithOptions(request, runtime);
  }

  /**
   * Queries the total number and proportions of HTTP status codes returned from one or more accelerated domain names.
   * 
   * @remarks
   * You can call this operation up to 10 times per second per account.
   * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |1 minute|1 hour|7 days|5 minutes|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * 
   * @param request - DescribeDcdnDomainRealTimeHttpCodeDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainRealTimeHttpCodeDataResponse
   */
  async describeDcdnDomainRealTimeHttpCodeDataWithOptions(request: DescribeDcdnDomainRealTimeHttpCodeDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainRealTimeHttpCodeDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ispNameEn)) {
      query["IspNameEn"] = request.ispNameEn;
    }

    if (!Util.isUnset(request.locationNameEn)) {
      query["LocationNameEn"] = request.locationNameEn;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainRealTimeHttpCodeData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainRealTimeHttpCodeDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainRealTimeHttpCodeDataResponse({}));
  }

  /**
   * Queries the total number and proportions of HTTP status codes returned from one or more accelerated domain names.
   * 
   * @remarks
   * You can call this operation up to 10 times per second per account.
   * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |1 minute|1 hour|7 days|5 minutes|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * 
   * @param request - DescribeDcdnDomainRealTimeHttpCodeDataRequest
   * @returns DescribeDcdnDomainRealTimeHttpCodeDataResponse
   */
  async describeDcdnDomainRealTimeHttpCodeData(request: DescribeDcdnDomainRealTimeHttpCodeDataRequest): Promise<DescribeDcdnDomainRealTimeHttpCodeDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainRealTimeHttpCodeDataWithOptions(request, runtime);
  }

  /**
   * The number of QPS for one or more accelerated domain names is queried. Data is collected every minute.
   * 
   * @remarks
   * You can call this operation up to 10 times per second per account.
   * * If you do not specify the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you specify both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |1 minute|1 hour|7 days|5 minutes|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * 
   * @param request - DescribeDcdnDomainRealTimeQpsDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainRealTimeQpsDataResponse
   */
  async describeDcdnDomainRealTimeQpsDataWithOptions(request: DescribeDcdnDomainRealTimeQpsDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainRealTimeQpsDataResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainRealTimeQpsData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainRealTimeQpsDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainRealTimeQpsDataResponse({}));
  }

  /**
   * The number of QPS for one or more accelerated domain names is queried. Data is collected every minute.
   * 
   * @remarks
   * You can call this operation up to 10 times per second per account.
   * * If you do not specify the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you specify both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |1 minute|1 hour|7 days|5 minutes|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * 
   * @param request - DescribeDcdnDomainRealTimeQpsDataRequest
   * @returns DescribeDcdnDomainRealTimeQpsDataResponse
   */
  async describeDcdnDomainRealTimeQpsData(request: DescribeDcdnDomainRealTimeQpsDataRequest): Promise<DescribeDcdnDomainRealTimeQpsDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainRealTimeQpsDataWithOptions(request, runtime);
  }

  /**
   * Queries the request hit rates with a time granularity of 1 minute.
   * 
   * @remarks
   * You can call this operation up to 10 times per second per user.
   * * The network traffic destined for different domain names may be redirected to the same origin server. Therefore, the byte hit ratios may be inaccurate. The accuracy of query results is based on the actual configurations.
   * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last hour. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * **Time granularity** The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |1 minute|1 hour|7 days|5 minutes|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * 
   * @param request - DescribeDcdnDomainRealTimeReqHitRateDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainRealTimeReqHitRateDataResponse
   */
  async describeDcdnDomainRealTimeReqHitRateDataWithOptions(request: DescribeDcdnDomainRealTimeReqHitRateDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainRealTimeReqHitRateDataResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainRealTimeReqHitRateData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainRealTimeReqHitRateDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainRealTimeReqHitRateDataResponse({}));
  }

  /**
   * Queries the request hit rates with a time granularity of 1 minute.
   * 
   * @remarks
   * You can call this operation up to 10 times per second per user.
   * * The network traffic destined for different domain names may be redirected to the same origin server. Therefore, the byte hit ratios may be inaccurate. The accuracy of query results is based on the actual configurations.
   * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last hour. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * **Time granularity** The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |1 minute|1 hour|7 days|5 minutes|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * 
   * @param request - DescribeDcdnDomainRealTimeReqHitRateDataRequest
   * @returns DescribeDcdnDomainRealTimeReqHitRateDataResponse
   */
  async describeDcdnDomainRealTimeReqHitRateData(request: DescribeDcdnDomainRealTimeReqHitRateDataRequest): Promise<DescribeDcdnDomainRealTimeReqHitRateDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainRealTimeReqHitRateDataWithOptions(request, runtime);
  }

  /**
   * Queries the bandwidth data of back-to-origin requests. Data is collected every minute. You can query data collected in the last 7 days.
   * 
   * @remarks
   *   You can call this operation up to 10 times per second per account.
   * *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
   * | Time granularity | Maximum time range per query | Historical data available | Data delay | 
   * |-----|-----|-----|--------| 
   * | 1 minute | 1 hour | 7 days | 5 minutes | 
   * | 5 minutes | 3 days | 93 days | 15 minutes | | 1 hour | 31 days | 186 days | 4 hours |
   * 
   * @param request - DescribeDcdnDomainRealTimeSrcBpsDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainRealTimeSrcBpsDataResponse
   */
  async describeDcdnDomainRealTimeSrcBpsDataWithOptions(request: DescribeDcdnDomainRealTimeSrcBpsDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainRealTimeSrcBpsDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainRealTimeSrcBpsData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainRealTimeSrcBpsDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainRealTimeSrcBpsDataResponse({}));
  }

  /**
   * Queries the bandwidth data of back-to-origin requests. Data is collected every minute. You can query data collected in the last 7 days.
   * 
   * @remarks
   *   You can call this operation up to 10 times per second per account.
   * *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
   * | Time granularity | Maximum time range per query | Historical data available | Data delay | 
   * |-----|-----|-----|--------| 
   * | 1 minute | 1 hour | 7 days | 5 minutes | 
   * | 5 minutes | 3 days | 93 days | 15 minutes | | 1 hour | 31 days | 186 days | 4 hours |
   * 
   * @param request - DescribeDcdnDomainRealTimeSrcBpsDataRequest
   * @returns DescribeDcdnDomainRealTimeSrcBpsDataResponse
   */
  async describeDcdnDomainRealTimeSrcBpsData(request: DescribeDcdnDomainRealTimeSrcBpsDataRequest): Promise<DescribeDcdnDomainRealTimeSrcBpsDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainRealTimeSrcBpsDataWithOptions(request, runtime);
  }

  /**
   * Queries the proportions of HTTP status codes based on back-to-origin statistics with a time granularity of one minute.
   * 
   * @remarks
   * You can call this operation up to 10 times per second per account.
   * * If you do not specify the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you specify both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |1 minute|1 hour|7 days|5 minutes|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * 
   * @param request - DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse
   */
  async describeDcdnDomainRealTimeSrcHttpCodeDataWithOptions(request: DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.ispNameEn)) {
      query["IspNameEn"] = request.ispNameEn;
    }

    if (!Util.isUnset(request.locationNameEn)) {
      query["LocationNameEn"] = request.locationNameEn;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainRealTimeSrcHttpCodeData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse({}));
  }

  /**
   * Queries the proportions of HTTP status codes based on back-to-origin statistics with a time granularity of one minute.
   * 
   * @remarks
   * You can call this operation up to 10 times per second per account.
   * * If you do not specify the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you specify both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |1 minute|1 hour|7 days|5 minutes|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * 
   * @param request - DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest
   * @returns DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse
   */
  async describeDcdnDomainRealTimeSrcHttpCodeData(request: DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest): Promise<DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainRealTimeSrcHttpCodeDataWithOptions(request, runtime);
  }

  /**
   * Queries the origin traffic monitoring data for an accelerated domain name. Data is collected every minute. You can query data in the last 90 days.
   * 
   * @remarks
   * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |1 minute|1 hour|7 days|5 minutes|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * 
   * @param request - DescribeDcdnDomainRealTimeSrcTrafficDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainRealTimeSrcTrafficDataResponse
   */
  async describeDcdnDomainRealTimeSrcTrafficDataWithOptions(request: DescribeDcdnDomainRealTimeSrcTrafficDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainRealTimeSrcTrafficDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainRealTimeSrcTrafficData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainRealTimeSrcTrafficDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainRealTimeSrcTrafficDataResponse({}));
  }

  /**
   * Queries the origin traffic monitoring data for an accelerated domain name. Data is collected every minute. You can query data in the last 90 days.
   * 
   * @remarks
   * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |1 minute|1 hour|7 days|5 minutes|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * 
   * @param request - DescribeDcdnDomainRealTimeSrcTrafficDataRequest
   * @returns DescribeDcdnDomainRealTimeSrcTrafficDataResponse
   */
  async describeDcdnDomainRealTimeSrcTrafficData(request: DescribeDcdnDomainRealTimeSrcTrafficDataRequest): Promise<DescribeDcdnDomainRealTimeSrcTrafficDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainRealTimeSrcTrafficDataWithOptions(request, runtime);
  }

  /**
   * Queries the traffic monitoring data of an accelerated domain name. Data is collected every minute.
   * 
   * @remarks
   * You can call this operation up to 50 times per second per user.
   * **Time granularity**
   * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |1 minute|1 hour|7 days|5 minutes|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * 
   * @param request - DescribeDcdnDomainRealTimeTrafficDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainRealTimeTrafficDataResponse
   */
  async describeDcdnDomainRealTimeTrafficDataWithOptions(request: DescribeDcdnDomainRealTimeTrafficDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainRealTimeTrafficDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainRealTimeTrafficData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainRealTimeTrafficDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainRealTimeTrafficDataResponse({}));
  }

  /**
   * Queries the traffic monitoring data of an accelerated domain name. Data is collected every minute.
   * 
   * @remarks
   * You can call this operation up to 50 times per second per user.
   * **Time granularity**
   * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |1 minute|1 hour|7 days|5 minutes|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * 
   * @param request - DescribeDcdnDomainRealTimeTrafficDataRequest
   * @returns DescribeDcdnDomainRealTimeTrafficDataResponse
   */
  async describeDcdnDomainRealTimeTrafficData(request: DescribeDcdnDomainRealTimeTrafficDataRequest): Promise<DescribeDcdnDomainRealTimeTrafficDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainRealTimeTrafficDataWithOptions(request, runtime);
  }

  /**
   * Queries regional distribution of users. Data is collected every day. You can query data within the last 90 days.
   * 
   * @remarks
   * > 
   * *   If you do not specify the StartTime and EndTime parameters, the data within the last 24 hours is queried. If you specify the StartTime and EndTime parameters, the data within the specified time range is queried.
   * *   You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnDomainRegionDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainRegionDataResponse
   */
  async describeDcdnDomainRegionDataWithOptions(request: DescribeDcdnDomainRegionDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainRegionDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainRegionData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainRegionDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainRegionDataResponse({}));
  }

  /**
   * Queries regional distribution of users. Data is collected every day. You can query data within the last 90 days.
   * 
   * @remarks
   * > 
   * *   If you do not specify the StartTime and EndTime parameters, the data within the last 24 hours is queried. If you specify the StartTime and EndTime parameters, the data within the specified time range is queried.
   * *   You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnDomainRegionDataRequest
   * @returns DescribeDcdnDomainRegionDataResponse
   */
  async describeDcdnDomainRegionData(request: DescribeDcdnDomainRegionDataRequest): Promise<DescribeDcdnDomainRegionDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainRegionDataWithOptions(request, runtime);
  }

  /**
   * Queries the environment configuration in the canary release environment.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeDcdnDomainStagingConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainStagingConfigResponse
   */
  async describeDcdnDomainStagingConfigWithOptions(request: DescribeDcdnDomainStagingConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainStagingConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.functionNames)) {
      query["FunctionNames"] = request.functionNames;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainStagingConfig",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainStagingConfigResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainStagingConfigResponse({}));
  }

  /**
   * Queries the environment configuration in the canary release environment.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeDcdnDomainStagingConfigRequest
   * @returns DescribeDcdnDomainStagingConfigResponse
   */
  async describeDcdnDomainStagingConfig(request: DescribeDcdnDomainStagingConfigRequest): Promise<DescribeDcdnDomainStagingConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainStagingConfigWithOptions(request, runtime);
  }

  /**
   * Queries and sorts frequently requested web pages on a specified day. You can query data collected within the last 90 days.
   * 
   * @remarks
   *   If you do not set the StartTime parameter, the data on the previous day is queried.
   * *   You can specify only one domain name.
   * 
   * @param request - DescribeDcdnDomainTopReferVisitRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainTopReferVisitResponse
   */
  async describeDcdnDomainTopReferVisitWithOptions(request: DescribeDcdnDomainTopReferVisitRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainTopReferVisitResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.sortBy)) {
      query["SortBy"] = request.sortBy;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainTopReferVisit",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainTopReferVisitResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainTopReferVisitResponse({}));
  }

  /**
   * Queries and sorts frequently requested web pages on a specified day. You can query data collected within the last 90 days.
   * 
   * @remarks
   *   If you do not set the StartTime parameter, the data on the previous day is queried.
   * *   You can specify only one domain name.
   * 
   * @param request - DescribeDcdnDomainTopReferVisitRequest
   * @returns DescribeDcdnDomainTopReferVisitResponse
   */
  async describeDcdnDomainTopReferVisit(request: DescribeDcdnDomainTopReferVisitRequest): Promise<DescribeDcdnDomainTopReferVisitResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainTopReferVisitWithOptions(request, runtime);
  }

  /**
   * Queries frequently requested URLs on a day.
   * 
   * @remarks
   * > You can query data in the last seven days.
   * 
   * @param request - DescribeDcdnDomainTopUrlVisitRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainTopUrlVisitResponse
   */
  async describeDcdnDomainTopUrlVisitWithOptions(request: DescribeDcdnDomainTopUrlVisitRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainTopUrlVisitResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.sortBy)) {
      query["SortBy"] = request.sortBy;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainTopUrlVisit",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainTopUrlVisitResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainTopUrlVisitResponse({}));
  }

  /**
   * Queries frequently requested URLs on a day.
   * 
   * @remarks
   * > You can query data in the last seven days.
   * 
   * @param request - DescribeDcdnDomainTopUrlVisitRequest
   * @returns DescribeDcdnDomainTopUrlVisitResponse
   */
  async describeDcdnDomainTopUrlVisit(request: DescribeDcdnDomainTopUrlVisitRequest): Promise<DescribeDcdnDomainTopUrlVisitResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainTopUrlVisitWithOptions(request, runtime);
  }

  /**
   * Queries the network traffic of accelerated domain names. You can query data collected in the last 90 days.
   * 
   * @remarks
   * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * * You can call this operation up to 100 times per second per account.
   * **Time granularity**
   * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * |1 day|366 days|366 days|04:00 on the next day|
   * 
   * @param request - DescribeDcdnDomainTrafficDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainTrafficDataResponse
   */
  async describeDcdnDomainTrafficDataWithOptions(request: DescribeDcdnDomainTrafficDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainTrafficDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ispNameEn)) {
      query["IspNameEn"] = request.ispNameEn;
    }

    if (!Util.isUnset(request.locationNameEn)) {
      query["LocationNameEn"] = request.locationNameEn;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainTrafficData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainTrafficDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainTrafficDataResponse({}));
  }

  /**
   * Queries the network traffic of accelerated domain names. You can query data collected in the last 90 days.
   * 
   * @remarks
   * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * * You can call this operation up to 100 times per second per account.
   * **Time granularity**
   * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * |1 day|366 days|366 days|04:00 on the next day|
   * 
   * @param request - DescribeDcdnDomainTrafficDataRequest
   * @returns DescribeDcdnDomainTrafficDataResponse
   */
  async describeDcdnDomainTrafficData(request: DescribeDcdnDomainTrafficDataRequest): Promise<DescribeDcdnDomainTrafficDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainTrafficDataWithOptions(request, runtime);
  }

  /**
   * Queries resource usage about domain names in a billable region.
   * 
   * @remarks
   * You can call this operation up to 10 times per second per account.
   * * Usage data includes traffic (measured in bytes), bandwidth values (measured in bit/s), and the number of requests.
   * **Time granularity**
   * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * |1 day|366 days|366 days|04:00 on the next day|
   * 
   * @param request - DescribeDcdnDomainUsageDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainUsageDataResponse
   */
  async describeDcdnDomainUsageDataWithOptions(request: DescribeDcdnDomainUsageDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainUsageDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.area)) {
      query["Area"] = request.area;
    }

    if (!Util.isUnset(request.dataProtocol)) {
      query["DataProtocol"] = request.dataProtocol;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.field)) {
      query["Field"] = request.field;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainUsageData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainUsageDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainUsageDataResponse({}));
  }

  /**
   * Queries resource usage about domain names in a billable region.
   * 
   * @remarks
   * You can call this operation up to 10 times per second per account.
   * * Usage data includes traffic (measured in bytes), bandwidth values (measured in bit/s), and the number of requests.
   * **Time granularity**
   * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * |1 day|366 days|366 days|04:00 on the next day|
   * 
   * @param request - DescribeDcdnDomainUsageDataRequest
   * @returns DescribeDcdnDomainUsageDataResponse
   */
  async describeDcdnDomainUsageData(request: DescribeDcdnDomainUsageDataRequest): Promise<DescribeDcdnDomainUsageDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainUsageDataWithOptions(request, runtime);
  }

  /**
   * Queries the number of unique visitors (UVs) to an accelerated domain name. Data is collected every hour. You can query data within the last 90 days.
   * 
   * @remarks
   *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
   * *   You can specify only one accelerated domain name or all the accelerated domain names that belong to your Alibaba Cloud account.
   * 
   * @param request - DescribeDcdnDomainUvDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainUvDataResponse
   */
  async describeDcdnDomainUvDataWithOptions(request: DescribeDcdnDomainUvDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainUvDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainUvData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainUvDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainUvDataResponse({}));
  }

  /**
   * Queries the number of unique visitors (UVs) to an accelerated domain name. Data is collected every hour. You can query data within the last 90 days.
   * 
   * @remarks
   *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
   * *   You can specify only one accelerated domain name or all the accelerated domain names that belong to your Alibaba Cloud account.
   * 
   * @param request - DescribeDcdnDomainUvDataRequest
   * @returns DescribeDcdnDomainUvDataResponse
   */
  async describeDcdnDomainUvData(request: DescribeDcdnDomainUvDataRequest): Promise<DescribeDcdnDomainUvDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainUvDataWithOptions(request, runtime);
  }

  /**
   * Queries bandwidth of one or more accelerated domain names for which WebSocket is enabled. You can query the data that is collected over the last 90 days.
   * 
   * @remarks
   * You can call this operation up to 100 times per second per account.
   * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * |1 day|366 days|366 days|04:00 on the next day|
   * 
   * @param request - DescribeDcdnDomainWebsocketBpsDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainWebsocketBpsDataResponse
   */
  async describeDcdnDomainWebsocketBpsDataWithOptions(request: DescribeDcdnDomainWebsocketBpsDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainWebsocketBpsDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ispNameEn)) {
      query["IspNameEn"] = request.ispNameEn;
    }

    if (!Util.isUnset(request.locationNameEn)) {
      query["LocationNameEn"] = request.locationNameEn;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainWebsocketBpsData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainWebsocketBpsDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainWebsocketBpsDataResponse({}));
  }

  /**
   * Queries bandwidth of one or more accelerated domain names for which WebSocket is enabled. You can query the data that is collected over the last 90 days.
   * 
   * @remarks
   * You can call this operation up to 100 times per second per account.
   * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * |1 day|366 days|366 days|04:00 on the next day|
   * 
   * @param request - DescribeDcdnDomainWebsocketBpsDataRequest
   * @returns DescribeDcdnDomainWebsocketBpsDataResponse
   */
  async describeDcdnDomainWebsocketBpsData(request: DescribeDcdnDomainWebsocketBpsDataRequest): Promise<DescribeDcdnDomainWebsocketBpsDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainWebsocketBpsDataWithOptions(request, runtime);
  }

  /**
   * The total number and proportions of HTTP status codes returned from one or more accelerated domain names for which WebSocket is enabled are queried. Data can be collected at minimum intervals of 5 minutes.
   * 
   * @remarks
   * You can call this operation up to 100 times per second per account.
   * **Time granularity**
   * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the time range to query, as described in the following table.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * |1 day|366 days|366 days|04:00 on the next day|
   * 
   * @param request - DescribeDcdnDomainWebsocketHttpCodeDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainWebsocketHttpCodeDataResponse
   */
  async describeDcdnDomainWebsocketHttpCodeDataWithOptions(request: DescribeDcdnDomainWebsocketHttpCodeDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainWebsocketHttpCodeDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ispNameEn)) {
      query["IspNameEn"] = request.ispNameEn;
    }

    if (!Util.isUnset(request.locationNameEn)) {
      query["LocationNameEn"] = request.locationNameEn;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainWebsocketHttpCodeData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainWebsocketHttpCodeDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainWebsocketHttpCodeDataResponse({}));
  }

  /**
   * The total number and proportions of HTTP status codes returned from one or more accelerated domain names for which WebSocket is enabled are queried. Data can be collected at minimum intervals of 5 minutes.
   * 
   * @remarks
   * You can call this operation up to 100 times per second per account.
   * **Time granularity**
   * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the time range to query, as described in the following table.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * |1 day|366 days|366 days|04:00 on the next day|
   * 
   * @param request - DescribeDcdnDomainWebsocketHttpCodeDataRequest
   * @returns DescribeDcdnDomainWebsocketHttpCodeDataResponse
   */
  async describeDcdnDomainWebsocketHttpCodeData(request: DescribeDcdnDomainWebsocketHttpCodeDataRequest): Promise<DescribeDcdnDomainWebsocketHttpCodeDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainWebsocketHttpCodeDataWithOptions(request, runtime);
  }

  /**
   * Queries the traffic monitoring data for an accelerated domain name with WebSocket enabled. You can query data in the last 90 days.
   * 
   * @remarks
   * You can call this operation up to 100 times per second per account.
   * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * |1 day|366 days|366 days|04:00 on the next day|
   * 
   * @param request - DescribeDcdnDomainWebsocketTrafficDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainWebsocketTrafficDataResponse
   */
  async describeDcdnDomainWebsocketTrafficDataWithOptions(request: DescribeDcdnDomainWebsocketTrafficDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainWebsocketTrafficDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.ispNameEn)) {
      query["IspNameEn"] = request.ispNameEn;
    }

    if (!Util.isUnset(request.locationNameEn)) {
      query["LocationNameEn"] = request.locationNameEn;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainWebsocketTrafficData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainWebsocketTrafficDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainWebsocketTrafficDataResponse({}));
  }

  /**
   * Queries the traffic monitoring data for an accelerated domain name with WebSocket enabled. You can query data in the last 90 days.
   * 
   * @remarks
   * You can call this operation up to 100 times per second per account.
   * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
   * **Time granularity**
   * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
   * |Time granularity|Maximum time range per query|Historical data available|Data delay|
   * |---|---|---|---|
   * |5 minutes|3 days|93 days|15 minutes|
   * |1 hour|31 days|186 days|4 hours|
   * |1 day|366 days|366 days|04:00 on the next day|
   * 
   * @param request - DescribeDcdnDomainWebsocketTrafficDataRequest
   * @returns DescribeDcdnDomainWebsocketTrafficDataResponse
   */
  async describeDcdnDomainWebsocketTrafficData(request: DescribeDcdnDomainWebsocketTrafficDataRequest): Promise<DescribeDcdnDomainWebsocketTrafficDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainWebsocketTrafficDataWithOptions(request, runtime);
  }

  /**
   * Queries DCDN-accelerated domain names by origin server.
   * 
   * @param request - DescribeDcdnDomainsBySourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnDomainsBySourceResponse
   */
  async describeDcdnDomainsBySourceWithOptions(request: DescribeDcdnDomainsBySourceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnDomainsBySourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.sources)) {
      query["Sources"] = request.sources;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnDomainsBySource",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnDomainsBySourceResponse>(await this.callApi(params, req, runtime), new DescribeDcdnDomainsBySourceResponse({}));
  }

  /**
   * Queries DCDN-accelerated domain names by origin server.
   * 
   * @param request - DescribeDcdnDomainsBySourceRequest
   * @returns DescribeDcdnDomainsBySourceResponse
   */
  async describeDcdnDomainsBySource(request: DescribeDcdnDomainsBySourceRequest): Promise<DescribeDcdnDomainsBySourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnDomainsBySourceWithOptions(request, runtime);
  }

  /**
   * Queries the number of times that a routine is executed within a specified period of time.
   * 
   * @remarks
   *   You can call this operation up to 10 times per second per account.
   * *   The minimum time granularity for a query is 1 hour. The maximum time span for a query is 24 hours. The time period within which historical data is available for a query is 366 days.
   * 
   * @param request - DescribeDcdnErUsageDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnErUsageDataResponse
   */
  async describeDcdnErUsageDataWithOptions(request: DescribeDcdnErUsageDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnErUsageDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.routineID)) {
      query["RoutineID"] = request.routineID;
    }

    if (!Util.isUnset(request.spec)) {
      query["Spec"] = request.spec;
    }

    if (!Util.isUnset(request.splitBy)) {
      query["SplitBy"] = request.splitBy;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnErUsageData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnErUsageDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnErUsageDataResponse({}));
  }

  /**
   * Queries the number of times that a routine is executed within a specified period of time.
   * 
   * @remarks
   *   You can call this operation up to 10 times per second per account.
   * *   The minimum time granularity for a query is 1 hour. The maximum time span for a query is 24 hours. The time period within which historical data is available for a query is 366 days.
   * 
   * @param request - DescribeDcdnErUsageDataRequest
   * @returns DescribeDcdnErUsageDataResponse
   */
  async describeDcdnErUsageData(request: DescribeDcdnErUsageDataRequest): Promise<DescribeDcdnErUsageDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnErUsageDataWithOptions(request, runtime);
  }

  /**
   * Queries the configurations of blocked IP addresses.
   * 
   * @remarks
   * > *   If you specify IP addresses or CIDR blocks, IP addresses that are effective and the corresponding expiration time are returned. If you do not specify IP addresses or CIDR blocks, all effective IP addresses and the corresponding expiration time are returned.
   * > *   The results are written to OSS and returned as OSS URLs. The content in OSS objects is in the format of `IP address-Corresponding expiration time`. The expiration time is in the YYYY-MM-DD hh:mm:ss format.
   * > *   You can share OSS URLs with others. The shared URLs are valid for three days.
   * 
   * @param request - DescribeDcdnFullDomainsBlockIPConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnFullDomainsBlockIPConfigResponse
   */
  async describeDcdnFullDomainsBlockIPConfigWithOptions(request: DescribeDcdnFullDomainsBlockIPConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnFullDomainsBlockIPConfigResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnFullDomainsBlockIPConfig",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnFullDomainsBlockIPConfigResponse>(await this.callApi(params, req, runtime), new DescribeDcdnFullDomainsBlockIPConfigResponse({}));
  }

  /**
   * Queries the configurations of blocked IP addresses.
   * 
   * @remarks
   * > *   If you specify IP addresses or CIDR blocks, IP addresses that are effective and the corresponding expiration time are returned. If you do not specify IP addresses or CIDR blocks, all effective IP addresses and the corresponding expiration time are returned.
   * > *   The results are written to OSS and returned as OSS URLs. The content in OSS objects is in the format of `IP address-Corresponding expiration time`. The expiration time is in the YYYY-MM-DD hh:mm:ss format.
   * > *   You can share OSS URLs with others. The shared URLs are valid for three days.
   * 
   * @param request - DescribeDcdnFullDomainsBlockIPConfigRequest
   * @returns DescribeDcdnFullDomainsBlockIPConfigResponse
   */
  async describeDcdnFullDomainsBlockIPConfig(request: DescribeDcdnFullDomainsBlockIPConfigRequest): Promise<DescribeDcdnFullDomainsBlockIPConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnFullDomainsBlockIPConfigWithOptions(request, runtime);
  }

  /**
   * 查询用户海量封禁历史
   * 
   * @remarks
   *   For a specified IP addresses and time range, the time when the IP address was delivered to the edge and the corresponding result are returned.
   * *   If a specified IP address or CIDR block has multiple blocking records in a specified time range, the records are sorted by delivery time in descending order.
   * *   The maximum time range to query is 90 days.
   * *   If no blocking record exists or delivery fails for the given IP address and time range, the delivery time is empty.
   * 
   * @param request - DescribeDcdnFullDomainsBlockIPHistoryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnFullDomainsBlockIPHistoryResponse
   */
  async describeDcdnFullDomainsBlockIPHistoryWithOptions(request: DescribeDcdnFullDomainsBlockIPHistoryRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnFullDomainsBlockIPHistoryResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.IPList)) {
      body["IPList"] = request.IPList;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnFullDomainsBlockIPHistory",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnFullDomainsBlockIPHistoryResponse>(await this.callApi(params, req, runtime), new DescribeDcdnFullDomainsBlockIPHistoryResponse({}));
  }

  /**
   * 查询用户海量封禁历史
   * 
   * @remarks
   *   For a specified IP addresses and time range, the time when the IP address was delivered to the edge and the corresponding result are returned.
   * *   If a specified IP address or CIDR block has multiple blocking records in a specified time range, the records are sorted by delivery time in descending order.
   * *   The maximum time range to query is 90 days.
   * *   If no blocking record exists or delivery fails for the given IP address and time range, the delivery time is empty.
   * 
   * @param request - DescribeDcdnFullDomainsBlockIPHistoryRequest
   * @returns DescribeDcdnFullDomainsBlockIPHistoryResponse
   */
  async describeDcdnFullDomainsBlockIPHistory(request: DescribeDcdnFullDomainsBlockIPHistoryRequest): Promise<DescribeDcdnFullDomainsBlockIPHistoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnFullDomainsBlockIPHistoryWithOptions(request, runtime);
  }

  /**
   * Queries information about all certificates that belong to your account.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnHttpsDomainListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnHttpsDomainListResponse
   */
  async describeDcdnHttpsDomainListWithOptions(request: DescribeDcdnHttpsDomainListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnHttpsDomainListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnHttpsDomainList",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnHttpsDomainListResponse>(await this.callApi(params, req, runtime), new DescribeDcdnHttpsDomainListResponse({}));
  }

  /**
   * Queries information about all certificates that belong to your account.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnHttpsDomainListRequest
   * @returns DescribeDcdnHttpsDomainListResponse
   */
  async describeDcdnHttpsDomainList(request: DescribeDcdnHttpsDomainListRequest): Promise<DescribeDcdnHttpsDomainListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnHttpsDomainListWithOptions(request, runtime);
  }

  /**
   * Queries whether an IP address belongs to a POP.
   * 
   * @remarks
   * > You can call this operation up to 50 times per second per account.
   * 
   * @param request - DescribeDcdnIpInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnIpInfoResponse
   */
  async describeDcdnIpInfoWithOptions(request: DescribeDcdnIpInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnIpInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.IP)) {
      query["IP"] = request.IP;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnIpInfo",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnIpInfoResponse>(await this.callApi(params, req, runtime), new DescribeDcdnIpInfoResponse({}));
  }

  /**
   * Queries whether an IP address belongs to a POP.
   * 
   * @remarks
   * > You can call this operation up to 50 times per second per account.
   * 
   * @param request - DescribeDcdnIpInfoRequest
   * @returns DescribeDcdnIpInfoResponse
   */
  async describeDcdnIpInfo(request: DescribeDcdnIpInfoRequest): Promise<DescribeDcdnIpInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnIpInfoWithOptions(request, runtime);
  }

  /**
   * Queries the back-to-origin CIDR blocks of IPA-accelerated domain names. If you want to call this API operation, you must submit a ticket to apply for the required permissions.
   * 
   * @remarks
   * >  This operation can be called globally up to 50 times per second. This operation can be called up to 10 times per second per account.
   * 
   * @param request - DescribeDcdnIpaDomainCidrRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnIpaDomainCidrResponse
   */
  async describeDcdnIpaDomainCidrWithOptions(request: DescribeDcdnIpaDomainCidrRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnIpaDomainCidrResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnIpaDomainCidr",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnIpaDomainCidrResponse>(await this.callApi(params, req, runtime), new DescribeDcdnIpaDomainCidrResponse({}));
  }

  /**
   * Queries the back-to-origin CIDR blocks of IPA-accelerated domain names. If you want to call this API operation, you must submit a ticket to apply for the required permissions.
   * 
   * @remarks
   * >  This operation can be called globally up to 50 times per second. This operation can be called up to 10 times per second per account.
   * 
   * @param request - DescribeDcdnIpaDomainCidrRequest
   * @returns DescribeDcdnIpaDomainCidrResponse
   */
  async describeDcdnIpaDomainCidr(request: DescribeDcdnIpaDomainCidrRequest): Promise<DescribeDcdnIpaDomainCidrResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnIpaDomainCidrWithOptions(request, runtime);
  }

  /**
   * Queries the configurations of an accelerated domain name. You can query the configurations of one or more features in each request.
   * 
   * @remarks
   * > You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeDcdnIpaDomainConfigsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnIpaDomainConfigsResponse
   */
  async describeDcdnIpaDomainConfigsWithOptions(request: DescribeDcdnIpaDomainConfigsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnIpaDomainConfigsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.functionNames)) {
      query["FunctionNames"] = request.functionNames;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnIpaDomainConfigs",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnIpaDomainConfigsResponse>(await this.callApi(params, req, runtime), new DescribeDcdnIpaDomainConfigsResponse({}));
  }

  /**
   * Queries the configurations of an accelerated domain name. You can query the configurations of one or more features in each request.
   * 
   * @remarks
   * > You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeDcdnIpaDomainConfigsRequest
   * @returns DescribeDcdnIpaDomainConfigsResponse
   */
  async describeDcdnIpaDomainConfigs(request: DescribeDcdnIpaDomainConfigsRequest): Promise<DescribeDcdnIpaDomainConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnIpaDomainConfigsWithOptions(request, runtime);
  }

  /**
   * Queries the basic configuration information about an accelerated domain name.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeDcdnIpaDomainDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnIpaDomainDetailResponse
   */
  async describeDcdnIpaDomainDetailWithOptions(request: DescribeDcdnIpaDomainDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnIpaDomainDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnIpaDomainDetail",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnIpaDomainDetailResponse>(await this.callApi(params, req, runtime), new DescribeDcdnIpaDomainDetailResponse({}));
  }

  /**
   * Queries the basic configuration information about an accelerated domain name.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeDcdnIpaDomainDetailRequest
   * @returns DescribeDcdnIpaDomainDetailResponse
   */
  async describeDcdnIpaDomainDetail(request: DescribeDcdnIpaDomainDetailRequest): Promise<DescribeDcdnIpaDomainDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnIpaDomainDetailWithOptions(request, runtime);
  }

  /**
   * Queries the status of IPA. The information includes the time when the service was activated, the current service status, the current billing method, and the billing method of the next cycle.
   * 
   * @remarks
   * *
   * **The maximum number of times that each user can call this operation per second is 20.
   * 
   * @param request - DescribeDcdnIpaServiceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnIpaServiceResponse
   */
  async describeDcdnIpaServiceWithOptions(request: DescribeDcdnIpaServiceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnIpaServiceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnIpaService",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnIpaServiceResponse>(await this.callApi(params, req, runtime), new DescribeDcdnIpaServiceResponse({}));
  }

  /**
   * Queries the status of IPA. The information includes the time when the service was activated, the current service status, the current billing method, and the billing method of the next cycle.
   * 
   * @remarks
   * *
   * **The maximum number of times that each user can call this operation per second is 20.
   * 
   * @param request - DescribeDcdnIpaServiceRequest
   * @returns DescribeDcdnIpaServiceResponse
   */
  async describeDcdnIpaService(request: DescribeDcdnIpaServiceRequest): Promise<DescribeDcdnIpaServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnIpaServiceWithOptions(request, runtime);
  }

  /**
   * Queries information about all domain names that are accelerated by IP Application Accelerator (IPA) in your account. Fuzzy search and filtering by domain status are supported.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeDcdnIpaUserDomainsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnIpaUserDomainsResponse
   */
  async describeDcdnIpaUserDomainsWithOptions(request: DescribeDcdnIpaUserDomainsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnIpaUserDomainsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkDomainShow)) {
      query["CheckDomainShow"] = request.checkDomainShow;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.domainSearchType)) {
      query["DomainSearchType"] = request.domainSearchType;
    }

    if (!Util.isUnset(request.domainStatus)) {
      query["DomainStatus"] = request.domainStatus;
    }

    if (!Util.isUnset(request.funcFilter)) {
      query["FuncFilter"] = request.funcFilter;
    }

    if (!Util.isUnset(request.funcId)) {
      query["FuncId"] = request.funcId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnIpaUserDomains",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnIpaUserDomainsResponse>(await this.callApi(params, req, runtime), new DescribeDcdnIpaUserDomainsResponse({}));
  }

  /**
   * Queries information about all domain names that are accelerated by IP Application Accelerator (IPA) in your account. Fuzzy search and filtering by domain status are supported.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeDcdnIpaUserDomainsRequest
   * @returns DescribeDcdnIpaUserDomainsResponse
   */
  async describeDcdnIpaUserDomains(request: DescribeDcdnIpaUserDomainsRequest): Promise<DescribeDcdnIpaUserDomainsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnIpaUserDomainsWithOptions(request, runtime);
  }

  /**
   * Queries the information about the key-value pairs that belong to your account.
   * 
   * @param request - DescribeDcdnKvAccountRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnKvAccountResponse
   */
  async describeDcdnKvAccountWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeDcdnKvAccountResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnKvAccount",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnKvAccountResponse>(await this.callApi(params, req, runtime), new DescribeDcdnKvAccountResponse({}));
  }

  /**
   * Queries the information about the key-value pairs that belong to your account.
   * @returns DescribeDcdnKvAccountResponse
   */
  async describeDcdnKvAccount(): Promise<DescribeDcdnKvAccountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnKvAccountWithOptions(runtime);
  }

  /**
   * Queries the KV status of an account.
   * 
   * @param request - DescribeDcdnKvAccountStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnKvAccountStatusResponse
   */
  async describeDcdnKvAccountStatusWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeDcdnKvAccountStatusResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnKvAccountStatus",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnKvAccountStatusResponse>(await this.callApi(params, req, runtime), new DescribeDcdnKvAccountStatusResponse({}));
  }

  /**
   * Queries the KV status of an account.
   * @returns DescribeDcdnKvAccountStatusResponse
   */
  async describeDcdnKvAccountStatus(): Promise<DescribeDcdnKvAccountStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnKvAccountStatusWithOptions(runtime);
  }

  /**
   * Queries the information about a namespace.
   * 
   * @param request - DescribeDcdnKvNamespaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnKvNamespaceResponse
   */
  async describeDcdnKvNamespaceWithOptions(request: DescribeDcdnKvNamespaceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnKvNamespaceResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnKvNamespace",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnKvNamespaceResponse>(await this.callApi(params, req, runtime), new DescribeDcdnKvNamespaceResponse({}));
  }

  /**
   * Queries the information about a namespace.
   * 
   * @param request - DescribeDcdnKvNamespaceRequest
   * @returns DescribeDcdnKvNamespaceResponse
   */
  async describeDcdnKvNamespace(request: DescribeDcdnKvNamespaceRequest): Promise<DescribeDcdnKvNamespaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnKvNamespaceWithOptions(request, runtime);
  }

  /**
   * Queries CIDR blocks of Dynamic Content Delivery Network (DCDN) points of presence (POPs).
   * 
   * @remarks
   * > *   To use this operation, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.2020520001.aliyun_topbar.18.dbd44bd3e4f845#/ticket/createIndex).
   * > *   You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnL2IpsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnL2IpsResponse
   */
  async describeDcdnL2IpsWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeDcdnL2IpsResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnL2Ips",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnL2IpsResponse>(await this.callApi(params, req, runtime), new DescribeDcdnL2IpsResponse({}));
  }

  /**
   * Queries CIDR blocks of Dynamic Content Delivery Network (DCDN) points of presence (POPs).
   * 
   * @remarks
   * > *   To use this operation, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.2020520001.aliyun_topbar.18.dbd44bd3e4f845#/ticket/createIndex).
   * > *   You can call this operation up to 100 times per second per account.
   * @returns DescribeDcdnL2IpsResponse
   */
  async describeDcdnL2Ips(): Promise<DescribeDcdnL2IpsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnL2IpsWithOptions(runtime);
  }

  /**
   * Queries the origin CIDR blocks by domain name. The CIDR blocks include IPv4 and IPv6 CIDR blocks.
   * 
   * @param request - DescribeDcdnL2VipsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnL2VipsResponse
   */
  async describeDcdnL2VipsWithOptions(request: DescribeDcdnL2VipsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnL2VipsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnL2Vips",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnL2VipsResponse>(await this.callApi(params, req, runtime), new DescribeDcdnL2VipsResponse({}));
  }

  /**
   * Queries the origin CIDR blocks by domain name. The CIDR blocks include IPv4 and IPv6 CIDR blocks.
   * 
   * @param request - DescribeDcdnL2VipsRequest
   * @returns DescribeDcdnL2VipsResponse
   */
  async describeDcdnL2Vips(request: DescribeDcdnL2VipsRequest): Promise<DescribeDcdnL2VipsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnL2VipsWithOptions(request, runtime);
  }

  /**
   * Queries the status of the origin server for a DCDN-accelerated domain name.
   * 
   * @param request - DescribeDcdnOriginSiteHealthStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnOriginSiteHealthStatusResponse
   */
  async describeDcdnOriginSiteHealthStatusWithOptions(request: DescribeDcdnOriginSiteHealthStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnOriginSiteHealthStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnOriginSiteHealthStatus",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnOriginSiteHealthStatusResponse>(await this.callApi(params, req, runtime), new DescribeDcdnOriginSiteHealthStatusResponse({}));
  }

  /**
   * Queries the status of the origin server for a DCDN-accelerated domain name.
   * 
   * @param request - DescribeDcdnOriginSiteHealthStatusRequest
   * @returns DescribeDcdnOriginSiteHealthStatusResponse
   */
  async describeDcdnOriginSiteHealthStatus(request: DescribeDcdnOriginSiteHealthStatusRequest): Promise<DescribeDcdnOriginSiteHealthStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnOriginSiteHealthStatusWithOptions(request, runtime);
  }

  /**
   * Queries the fields in real-time log entries.
   * 
   * @remarks
   * >  You can call this API operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnRealTimeDeliveryFieldRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnRealTimeDeliveryFieldResponse
   */
  async describeDcdnRealTimeDeliveryFieldWithOptions(request: DescribeDcdnRealTimeDeliveryFieldRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnRealTimeDeliveryFieldResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.businessType)) {
      query["BusinessType"] = request.businessType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnRealTimeDeliveryField",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnRealTimeDeliveryFieldResponse>(await this.callApi(params, req, runtime), new DescribeDcdnRealTimeDeliveryFieldResponse({}));
  }

  /**
   * Queries the fields in real-time log entries.
   * 
   * @remarks
   * >  You can call this API operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnRealTimeDeliveryFieldRequest
   * @returns DescribeDcdnRealTimeDeliveryFieldResponse
   */
  async describeDcdnRealTimeDeliveryField(request: DescribeDcdnRealTimeDeliveryFieldRequest): Promise<DescribeDcdnRealTimeDeliveryFieldResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnRealTimeDeliveryFieldWithOptions(request, runtime);
  }

  /**
   * Queries the maximum number and the remaining number of URLs and directories that can be refreshed or the maximum number and the remaining number of URLs that can be prefetched per day.
   * 
   * @remarks
   * > 
   * *   You can call the **RefreshDcdnObjectCaches** operation to refresh content and call the **PreloadDcdnObjectCaches** operation to prefetch content.
   * *   You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeDcdnRefreshQuotaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnRefreshQuotaResponse
   */
  async describeDcdnRefreshQuotaWithOptions(request: DescribeDcdnRefreshQuotaRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnRefreshQuotaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnRefreshQuota",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnRefreshQuotaResponse>(await this.callApi(params, req, runtime), new DescribeDcdnRefreshQuotaResponse({}));
  }

  /**
   * Queries the maximum number and the remaining number of URLs and directories that can be refreshed or the maximum number and the remaining number of URLs that can be prefetched per day.
   * 
   * @remarks
   * > 
   * *   You can call the **RefreshDcdnObjectCaches** operation to refresh content and call the **PreloadDcdnObjectCaches** operation to prefetch content.
   * *   You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeDcdnRefreshQuotaRequest
   * @returns DescribeDcdnRefreshQuotaResponse
   */
  async describeDcdnRefreshQuota(request: DescribeDcdnRefreshQuotaRequest): Promise<DescribeDcdnRefreshQuotaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnRefreshQuotaWithOptions(request, runtime);
  }

  /**
   * Queries the status of refresh or prefetch tasks by task ID.
   * 
   * @remarks
   * > 
   * *   You can query data within the last three days.
   * *   You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeDcdnRefreshTaskByIdRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnRefreshTaskByIdResponse
   */
  async describeDcdnRefreshTaskByIdWithOptions(request: DescribeDcdnRefreshTaskByIdRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnRefreshTaskByIdResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnRefreshTaskById",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnRefreshTaskByIdResponse>(await this.callApi(params, req, runtime), new DescribeDcdnRefreshTaskByIdResponse({}));
  }

  /**
   * Queries the status of refresh or prefetch tasks by task ID.
   * 
   * @remarks
   * > 
   * *   You can query data within the last three days.
   * *   You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeDcdnRefreshTaskByIdRequest
   * @returns DescribeDcdnRefreshTaskByIdResponse
   */
  async describeDcdnRefreshTaskById(request: DescribeDcdnRefreshTaskByIdRequest): Promise<DescribeDcdnRefreshTaskByIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnRefreshTaskByIdWithOptions(request, runtime);
  }

  /**
   * Queries the refresh or prefetch tasks. You can query the tasks in the last three days.
   * 
   * @remarks
   *   You can query the refresh or prefetch tasks by ID or URL.
   * *   You can set both **TaskId** and **ObjectPath** in a request. If you do not set **TaskId** or **ObjectPath**, the data in the last 3 days on the first page is returned. By default, a maximum of 20 entries can be displayed on each page.
   * *   If you specify **DomainName** or **Status**, you must also specify **ObjectType**.
   * *   You can call this operation up to 10 times per second per account.
   * 
   * @param request - DescribeDcdnRefreshTasksRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnRefreshTasksResponse
   */
  async describeDcdnRefreshTasksWithOptions(request: DescribeDcdnRefreshTasksRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnRefreshTasksResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.objectPath)) {
      query["ObjectPath"] = request.objectPath;
    }

    if (!Util.isUnset(request.objectType)) {
      query["ObjectType"] = request.objectType;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnRefreshTasks",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnRefreshTasksResponse>(await this.callApi(params, req, runtime), new DescribeDcdnRefreshTasksResponse({}));
  }

  /**
   * Queries the refresh or prefetch tasks. You can query the tasks in the last three days.
   * 
   * @remarks
   *   You can query the refresh or prefetch tasks by ID or URL.
   * *   You can set both **TaskId** and **ObjectPath** in a request. If you do not set **TaskId** or **ObjectPath**, the data in the last 3 days on the first page is returned. By default, a maximum of 20 entries can be displayed on each page.
   * *   If you specify **DomainName** or **Status**, you must also specify **ObjectType**.
   * *   You can call this operation up to 10 times per second per account.
   * 
   * @param request - DescribeDcdnRefreshTasksRequest
   * @returns DescribeDcdnRefreshTasksResponse
   */
  async describeDcdnRefreshTasks(request: DescribeDcdnRefreshTasksRequest): Promise<DescribeDcdnRefreshTasksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnRefreshTasksWithOptions(request, runtime);
  }

  /**
   * Queries the list of Internet service providers (ISPs) and regions.
   * 
   * @remarks
   * >  You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeDcdnRegionAndIspRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnRegionAndIspResponse
   */
  async describeDcdnRegionAndIspWithOptions(request: DescribeDcdnRegionAndIspRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnRegionAndIspResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnRegionAndIsp",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnRegionAndIspResponse>(await this.callApi(params, req, runtime), new DescribeDcdnRegionAndIspResponse({}));
  }

  /**
   * Queries the list of Internet service providers (ISPs) and regions.
   * 
   * @remarks
   * >  You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeDcdnRegionAndIspRequest
   * @returns DescribeDcdnRegionAndIspResponse
   */
  async describeDcdnRegionAndIsp(request: DescribeDcdnRegionAndIspRequest): Promise<DescribeDcdnRegionAndIspResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnRegionAndIspWithOptions(request, runtime);
  }

  /**
   * Queries the content of an operations report.
   * 
   * @remarks
   * > You can call this operation up to three times per second per account.
   * 
   * @param request - DescribeDcdnReportRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnReportResponse
   */
  async describeDcdnReportWithOptions(request: DescribeDcdnReportRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnReportResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.area)) {
      query["Area"] = request.area;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.httpCode)) {
      query["HttpCode"] = request.httpCode;
    }

    if (!Util.isUnset(request.isOverseas)) {
      query["IsOverseas"] = request.isOverseas;
    }

    if (!Util.isUnset(request.reportId)) {
      query["ReportId"] = request.reportId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnReport",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnReportResponse>(await this.callApi(params, req, runtime), new DescribeDcdnReportResponse({}));
  }

  /**
   * Queries the content of an operations report.
   * 
   * @remarks
   * > You can call this operation up to three times per second per account.
   * 
   * @param request - DescribeDcdnReportRequest
   * @returns DescribeDcdnReportResponse
   */
  async describeDcdnReport(request: DescribeDcdnReportRequest): Promise<DescribeDcdnReportResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnReportWithOptions(request, runtime);
  }

  /**
   * Queries custom operations reports.
   * 
   * @remarks
   * > * This operation queries the metadata of all operations reports. The statistics in the reports are not returned.
   * > * You can call this operation up to three times per second per account.
   * 
   * @param request - DescribeDcdnReportListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnReportListResponse
   */
  async describeDcdnReportListWithOptions(request: DescribeDcdnReportListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnReportListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.reportId)) {
      query["ReportId"] = request.reportId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnReportList",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnReportListResponse>(await this.callApi(params, req, runtime), new DescribeDcdnReportListResponse({}));
  }

  /**
   * Queries custom operations reports.
   * 
   * @remarks
   * > * This operation queries the metadata of all operations reports. The statistics in the reports are not returned.
   * > * You can call this operation up to three times per second per account.
   * 
   * @param request - DescribeDcdnReportListRequest
   * @returns DescribeDcdnReportListResponse
   */
  async describeDcdnReportList(request: DescribeDcdnReportListRequest): Promise<DescribeDcdnReportListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnReportListWithOptions(request, runtime);
  }

  /**
   * Queries supported types of real-time logs.
   * 
   * @param request - DescribeDcdnSLSRealTimeLogTypeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnSLSRealTimeLogTypeResponse
   */
  async describeDcdnSLSRealTimeLogTypeWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeDcdnSLSRealTimeLogTypeResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnSLSRealTimeLogType",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnSLSRealTimeLogTypeResponse>(await this.callApi(params, req, runtime), new DescribeDcdnSLSRealTimeLogTypeResponse({}));
  }

  /**
   * Queries supported types of real-time logs.
   * @returns DescribeDcdnSLSRealTimeLogTypeResponse
   */
  async describeDcdnSLSRealTimeLogType(): Promise<DescribeDcdnSLSRealTimeLogTypeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnSLSRealTimeLogTypeWithOptions(runtime);
  }

  /**
   * Queries a real-time log delivery project.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnSLSRealtimeLogDeliveryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnSLSRealtimeLogDeliveryResponse
   */
  async describeDcdnSLSRealtimeLogDeliveryWithOptions(request: DescribeDcdnSLSRealtimeLogDeliveryRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnSLSRealtimeLogDeliveryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.projectName)) {
      query["ProjectName"] = request.projectName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnSLSRealtimeLogDelivery",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnSLSRealtimeLogDeliveryResponse>(await this.callApi(params, req, runtime), new DescribeDcdnSLSRealtimeLogDeliveryResponse({}));
  }

  /**
   * Queries a real-time log delivery project.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnSLSRealtimeLogDeliveryRequest
   * @returns DescribeDcdnSLSRealtimeLogDeliveryResponse
   */
  async describeDcdnSLSRealtimeLogDelivery(request: DescribeDcdnSLSRealtimeLogDeliveryRequest): Promise<DescribeDcdnSLSRealtimeLogDeliveryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnSLSRealtimeLogDeliveryWithOptions(request, runtime);
  }

  /**
   * Queries the details about a ShangMi (SM) certificate.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeDcdnSMCertificateDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnSMCertificateDetailResponse
   */
  async describeDcdnSMCertificateDetailWithOptions(request: DescribeDcdnSMCertificateDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnSMCertificateDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.certIdentifier)) {
      query["CertIdentifier"] = request.certIdentifier;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnSMCertificateDetail",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnSMCertificateDetailResponse>(await this.callApi(params, req, runtime), new DescribeDcdnSMCertificateDetailResponse({}));
  }

  /**
   * Queries the details about a ShangMi (SM) certificate.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeDcdnSMCertificateDetailRequest
   * @returns DescribeDcdnSMCertificateDetailResponse
   */
  async describeDcdnSMCertificateDetail(request: DescribeDcdnSMCertificateDetailRequest): Promise<DescribeDcdnSMCertificateDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnSMCertificateDetailWithOptions(request, runtime);
  }

  /**
   * Queries the ShangMi (SM) certificates of an accelerated domain name.
   * 
   * @remarks
   * >  You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeDcdnSMCertificateListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnSMCertificateListResponse
   */
  async describeDcdnSMCertificateListWithOptions(request: DescribeDcdnSMCertificateListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnSMCertificateListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnSMCertificateList",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnSMCertificateListResponse>(await this.callApi(params, req, runtime), new DescribeDcdnSMCertificateListResponse({}));
  }

  /**
   * Queries the ShangMi (SM) certificates of an accelerated domain name.
   * 
   * @remarks
   * >  You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeDcdnSMCertificateListRequest
   * @returns DescribeDcdnSMCertificateListResponse
   */
  async describeDcdnSMCertificateList(request: DescribeDcdnSMCertificateListRequest): Promise<DescribeDcdnSMCertificateListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnSMCertificateListWithOptions(request, runtime);
  }

  /**
   * Queries the certificates of accelerated domain names.
   * 
   * @param request - DescribeDcdnSSLCertificateListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnSSLCertificateListResponse
   */
  async describeDcdnSSLCertificateListWithOptions(request: DescribeDcdnSSLCertificateListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnSSLCertificateListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchKeyword)) {
      query["SearchKeyword"] = request.searchKeyword;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnSSLCertificateList",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnSSLCertificateListResponse>(await this.callApi(params, req, runtime), new DescribeDcdnSSLCertificateListResponse({}));
  }

  /**
   * Queries the certificates of accelerated domain names.
   * 
   * @param request - DescribeDcdnSSLCertificateListRequest
   * @returns DescribeDcdnSSLCertificateListResponse
   */
  async describeDcdnSSLCertificateList(request: DescribeDcdnSSLCertificateListRequest): Promise<DescribeDcdnSSLCertificateListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnSSLCertificateListWithOptions(request, runtime);
  }

  /**
   * Creates an edge security drop-down list in the Dynamic Content Delivery Network (DCDN) console.
   * 
   * @remarks
   * > You can call this operation up to 50 times per second per account.
   * 
   * @param request - DescribeDcdnSecFuncInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnSecFuncInfoResponse
   */
  async describeDcdnSecFuncInfoWithOptions(request: DescribeDcdnSecFuncInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnSecFuncInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.secFuncType)) {
      query["SecFuncType"] = request.secFuncType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnSecFuncInfo",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnSecFuncInfoResponse>(await this.callApi(params, req, runtime), new DescribeDcdnSecFuncInfoResponse({}));
  }

  /**
   * Creates an edge security drop-down list in the Dynamic Content Delivery Network (DCDN) console.
   * 
   * @remarks
   * > You can call this operation up to 50 times per second per account.
   * 
   * @param request - DescribeDcdnSecFuncInfoRequest
   * @returns DescribeDcdnSecFuncInfoResponse
   */
  async describeDcdnSecFuncInfo(request: DescribeDcdnSecFuncInfoRequest): Promise<DescribeDcdnSecFuncInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnSecFuncInfoWithOptions(request, runtime);
  }

  /**
   * Queries the version of secure Dynamic Route for CDN (DCDN) and the security rules.
   * 
   * @remarks
   * > You can call this operation up to 50 times per second per account.
   * 
   * @param request - DescribeDcdnSecSpecInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnSecSpecInfoResponse
   */
  async describeDcdnSecSpecInfoWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeDcdnSecSpecInfoResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnSecSpecInfo",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnSecSpecInfoResponse>(await this.callApi(params, req, runtime), new DescribeDcdnSecSpecInfoResponse({}));
  }

  /**
   * Queries the version of secure Dynamic Route for CDN (DCDN) and the security rules.
   * 
   * @remarks
   * > You can call this operation up to 50 times per second per account.
   * @returns DescribeDcdnSecSpecInfoResponse
   */
  async describeDcdnSecSpecInfo(): Promise<DescribeDcdnSecSpecInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnSecSpecInfoWithOptions(runtime);
  }

  /**
   * Queries information about the Dynamic Content Delivery Network (DCDN) service. The information includes the time when the service was activated, the current service status, the current billing method, and the billing method of the next cycle.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeDcdnServiceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnServiceResponse
   */
  async describeDcdnServiceWithOptions(request: DescribeDcdnServiceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnServiceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnService",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnServiceResponse>(await this.callApi(params, req, runtime), new DescribeDcdnServiceResponse({}));
  }

  /**
   * Queries information about the Dynamic Content Delivery Network (DCDN) service. The information includes the time when the service was activated, the current service status, the current billing method, and the billing method of the next cycle.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeDcdnServiceRequest
   * @returns DescribeDcdnServiceResponse
   */
  async describeDcdnService(request: DescribeDcdnServiceRequest): Promise<DescribeDcdnServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnServiceWithOptions(request, runtime);
  }

  /**
   * Queries valid virtual IP addresses (VIPs) in the staging environment.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeDcdnStagingIpRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnStagingIpResponse
   */
  async describeDcdnStagingIpWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeDcdnStagingIpResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnStagingIp",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnStagingIpResponse>(await this.callApi(params, req, runtime), new DescribeDcdnStagingIpResponse({}));
  }

  /**
   * Queries valid virtual IP addresses (VIPs) in the staging environment.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * @returns DescribeDcdnStagingIpResponse
   */
  async describeDcdnStagingIp(): Promise<DescribeDcdnStagingIpResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnStagingIpWithOptions(runtime);
  }

  /**
   * Queries custom operations reports.
   * 
   * @remarks
   * > *   By default, this operation queries all custom operations reports. However, only one operations report can be displayed. Therefore, only one operations report is returned.
   * > *   You can call this API operation up to three times per second per account.
   * 
   * @param request - DescribeDcdnSubListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnSubListResponse
   */
  async describeDcdnSubListWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeDcdnSubListResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnSubList",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnSubListResponse>(await this.callApi(params, req, runtime), new DescribeDcdnSubListResponse({}));
  }

  /**
   * Queries custom operations reports.
   * 
   * @remarks
   * > *   By default, this operation queries all custom operations reports. However, only one operations report can be displayed. Therefore, only one operations report is returned.
   * > *   You can call this API operation up to three times per second per account.
   * @returns DescribeDcdnSubListResponse
   */
  async describeDcdnSubList(): Promise<DescribeDcdnSubListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnSubListWithOptions(runtime);
  }

  /**
   * Queries the tags of one or more resources.
   * 
   * @remarks
   * > You can call this operation up to 10 times per second per account.
   * 
   * @param request - DescribeDcdnTagResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnTagResourcesResponse
   */
  async describeDcdnTagResourcesWithOptions(request: DescribeDcdnTagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnTagResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnTagResources",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnTagResourcesResponse>(await this.callApi(params, req, runtime), new DescribeDcdnTagResourcesResponse({}));
  }

  /**
   * Queries the tags of one or more resources.
   * 
   * @remarks
   * > You can call this operation up to 10 times per second per account.
   * 
   * @param request - DescribeDcdnTagResourcesRequest
   * @returns DescribeDcdnTagResourcesResponse
   */
  async describeDcdnTagResources(request: DescribeDcdnTagResourcesRequest): Promise<DescribeDcdnTagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnTagResourcesWithOptions(request, runtime);
  }

  /**
   * Queries domain names ranked by network traffic. You can query data within the last 90 days.
   * 
   * @remarks
   * If you do not specify the StartTime and EndTime parameters, the data within the current month is queried. If you specify the StartTime and EndTime parameters, the data within the specified time range is queried.
   * 
   * @param request - DescribeDcdnTopDomainsByFlowRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnTopDomainsByFlowResponse
   */
  async describeDcdnTopDomainsByFlowWithOptions(request: DescribeDcdnTopDomainsByFlowRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnTopDomainsByFlowResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.limit)) {
      query["Limit"] = request.limit;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnTopDomainsByFlow",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnTopDomainsByFlowResponse>(await this.callApi(params, req, runtime), new DescribeDcdnTopDomainsByFlowResponse({}));
  }

  /**
   * Queries domain names ranked by network traffic. You can query data within the last 90 days.
   * 
   * @remarks
   * If you do not specify the StartTime and EndTime parameters, the data within the current month is queried. If you specify the StartTime and EndTime parameters, the data within the specified time range is queried.
   * 
   * @param request - DescribeDcdnTopDomainsByFlowRequest
   * @returns DescribeDcdnTopDomainsByFlowResponse
   */
  async describeDcdnTopDomainsByFlow(request: DescribeDcdnTopDomainsByFlowRequest): Promise<DescribeDcdnTopDomainsByFlowResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnTopDomainsByFlowWithOptions(request, runtime);
  }

  /**
   * Queries the billing records of an Alibaba Cloud account. The maximum time range that you can specify is one month.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnUserBillHistoryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnUserBillHistoryResponse
   */
  async describeDcdnUserBillHistoryWithOptions(request: DescribeDcdnUserBillHistoryRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnUserBillHistoryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnUserBillHistory",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnUserBillHistoryResponse>(await this.callApi(params, req, runtime), new DescribeDcdnUserBillHistoryResponse({}));
  }

  /**
   * Queries the billing records of an Alibaba Cloud account. The maximum time range that you can specify is one month.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnUserBillHistoryRequest
   * @returns DescribeDcdnUserBillHistoryResponse
   */
  async describeDcdnUserBillHistory(request: DescribeDcdnUserBillHistoryRequest): Promise<DescribeDcdnUserBillHistoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnUserBillHistoryWithOptions(request, runtime);
  }

  /**
   * Queries the metering method that is used in Dynamic Content Delivery Network (DCDN).
   * 
   * @param request - DescribeDcdnUserBillTypeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnUserBillTypeResponse
   */
  async describeDcdnUserBillTypeWithOptions(request: DescribeDcdnUserBillTypeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnUserBillTypeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnUserBillType",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnUserBillTypeResponse>(await this.callApi(params, req, runtime), new DescribeDcdnUserBillTypeResponse({}));
  }

  /**
   * Queries the metering method that is used in Dynamic Content Delivery Network (DCDN).
   * 
   * @param request - DescribeDcdnUserBillTypeRequest
   * @returns DescribeDcdnUserBillTypeResponse
   */
  async describeDcdnUserBillType(request: DescribeDcdnUserBillTypeRequest): Promise<DescribeDcdnUserBillTypeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnUserBillTypeWithOptions(request, runtime);
  }

  /**
   * Queries the number of domain names whose SSL certificates are about to expire or have already expired.
   * 
   * @remarks
   * You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnUserCertificateExpireCountRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnUserCertificateExpireCountResponse
   */
  async describeDcdnUserCertificateExpireCountWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeDcdnUserCertificateExpireCountResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnUserCertificateExpireCount",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnUserCertificateExpireCountResponse>(await this.callApi(params, req, runtime), new DescribeDcdnUserCertificateExpireCountResponse({}));
  }

  /**
   * Queries the number of domain names whose SSL certificates are about to expire or have already expired.
   * 
   * @remarks
   * You can call this operation up to 100 times per second per account.
   * @returns DescribeDcdnUserCertificateExpireCountResponse
   */
  async describeDcdnUserCertificateExpireCount(): Promise<DescribeDcdnUserCertificateExpireCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnUserCertificateExpireCountWithOptions(runtime);
  }

  /**
   * Queries the configurations of security features.
   * 
   * @remarks
   * You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeDcdnUserConfigsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnUserConfigsResponse
   */
  async describeDcdnUserConfigsWithOptions(request: DescribeDcdnUserConfigsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnUserConfigsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.functionName)) {
      query["FunctionName"] = request.functionName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnUserConfigs",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnUserConfigsResponse>(await this.callApi(params, req, runtime), new DescribeDcdnUserConfigsResponse({}));
  }

  /**
   * Queries the configurations of security features.
   * 
   * @remarks
   * You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeDcdnUserConfigsRequest
   * @returns DescribeDcdnUserConfigsResponse
   */
  async describeDcdnUserConfigs(request: DescribeDcdnUserConfigsRequest): Promise<DescribeDcdnUserConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnUserConfigsWithOptions(request, runtime);
  }

  /**
   * Queries the accelerated domain names that belong to your Alibaba Cloud account. You can filter domains by name or by status. Fuzzy match is supported when you filter domains by name.
   * 
   * @remarks
   * > You can call this operation up to 80 times per second per account.
   * 
   * @param request - DescribeDcdnUserDomainsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnUserDomainsResponse
   */
  async describeDcdnUserDomainsWithOptions(request: DescribeDcdnUserDomainsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnUserDomainsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.changeEndTime)) {
      query["ChangeEndTime"] = request.changeEndTime;
    }

    if (!Util.isUnset(request.changeStartTime)) {
      query["ChangeStartTime"] = request.changeStartTime;
    }

    if (!Util.isUnset(request.checkDomainShow)) {
      query["CheckDomainShow"] = request.checkDomainShow;
    }

    if (!Util.isUnset(request.coverage)) {
      query["Coverage"] = request.coverage;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.domainSearchType)) {
      query["DomainSearchType"] = request.domainSearchType;
    }

    if (!Util.isUnset(request.domainStatus)) {
      query["DomainStatus"] = request.domainStatus;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.webSiteType)) {
      query["WebSiteType"] = request.webSiteType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnUserDomains",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnUserDomainsResponse>(await this.callApi(params, req, runtime), new DescribeDcdnUserDomainsResponse({}));
  }

  /**
   * Queries the accelerated domain names that belong to your Alibaba Cloud account. You can filter domains by name or by status. Fuzzy match is supported when you filter domains by name.
   * 
   * @remarks
   * > You can call this operation up to 80 times per second per account.
   * 
   * @param request - DescribeDcdnUserDomainsRequest
   * @returns DescribeDcdnUserDomainsResponse
   */
  async describeDcdnUserDomains(request: DescribeDcdnUserDomainsRequest): Promise<DescribeDcdnUserDomainsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnUserDomainsWithOptions(request, runtime);
  }

  /**
   * Queries all accelerated domain names with specified features configured that belong to your Alibaba Cloud account based on the FuncId parameter.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnUserDomainsByFuncRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnUserDomainsByFuncResponse
   */
  async describeDcdnUserDomainsByFuncWithOptions(request: DescribeDcdnUserDomainsByFuncRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnUserDomainsByFuncResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.funcFilter)) {
      query["FuncFilter"] = request.funcFilter;
    }

    if (!Util.isUnset(request.funcId)) {
      query["FuncId"] = request.funcId;
    }

    if (!Util.isUnset(request.matchType)) {
      query["MatchType"] = request.matchType;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnUserDomainsByFunc",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnUserDomainsByFuncResponse>(await this.callApi(params, req, runtime), new DescribeDcdnUserDomainsByFuncResponse({}));
  }

  /**
   * Queries all accelerated domain names with specified features configured that belong to your Alibaba Cloud account based on the FuncId parameter.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnUserDomainsByFuncRequest
   * @returns DescribeDcdnUserDomainsByFuncResponse
   */
  async describeDcdnUserDomainsByFunc(request: DescribeDcdnUserDomainsByFuncRequest): Promise<DescribeDcdnUserDomainsByFuncResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnUserDomainsByFuncWithOptions(request, runtime);
  }

  /**
   * Queries the resource quotas and the used resources.
   * 
   * @remarks
   * >  The maximum number of times that each user can call this operation per second is 30.
   * 
   * @param request - DescribeDcdnUserQuotaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnUserQuotaResponse
   */
  async describeDcdnUserQuotaWithOptions(request: DescribeDcdnUserQuotaRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnUserQuotaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnUserQuota",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnUserQuotaResponse>(await this.callApi(params, req, runtime), new DescribeDcdnUserQuotaResponse({}));
  }

  /**
   * Queries the resource quotas and the used resources.
   * 
   * @remarks
   * >  The maximum number of times that each user can call this operation per second is 30.
   * 
   * @param request - DescribeDcdnUserQuotaRequest
   * @returns DescribeDcdnUserQuotaResponse
   */
  async describeDcdnUserQuota(request: DescribeDcdnUserQuotaRequest): Promise<DescribeDcdnUserQuotaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnUserQuotaWithOptions(request, runtime);
  }

  /**
   * Queries the fields that are selected.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnUserRealTimeDeliveryFieldRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnUserRealTimeDeliveryFieldResponse
   */
  async describeDcdnUserRealTimeDeliveryFieldWithOptions(request: DescribeDcdnUserRealTimeDeliveryFieldRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnUserRealTimeDeliveryFieldResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnUserRealTimeDeliveryField",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnUserRealTimeDeliveryFieldResponse>(await this.callApi(params, req, runtime), new DescribeDcdnUserRealTimeDeliveryFieldResponse({}));
  }

  /**
   * Queries the fields that are selected.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnUserRealTimeDeliveryFieldRequest
   * @returns DescribeDcdnUserRealTimeDeliveryFieldResponse
   */
  async describeDcdnUserRealTimeDeliveryField(request: DescribeDcdnUserRealTimeDeliveryFieldRequest): Promise<DescribeDcdnUserRealTimeDeliveryFieldResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnUserRealTimeDeliveryFieldWithOptions(request, runtime);
  }

  /**
   * Queries information about the resource plans in your Alibaba Cloud account.
   * 
   * @remarks
   * The maximum number of times that each user can call this operation per second is 30.
   * 
   * @param request - DescribeDcdnUserResourcePackageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnUserResourcePackageResponse
   */
  async describeDcdnUserResourcePackageWithOptions(request: DescribeDcdnUserResourcePackageRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnUserResourcePackageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnUserResourcePackage",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnUserResourcePackageResponse>(await this.callApi(params, req, runtime), new DescribeDcdnUserResourcePackageResponse({}));
  }

  /**
   * Queries information about the resource plans in your Alibaba Cloud account.
   * 
   * @remarks
   * The maximum number of times that each user can call this operation per second is 30.
   * 
   * @param request - DescribeDcdnUserResourcePackageRequest
   * @returns DescribeDcdnUserResourcePackageResponse
   */
  async describeDcdnUserResourcePackage(request: DescribeDcdnUserResourcePackageRequest): Promise<DescribeDcdnUserResourcePackageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnUserResourcePackageWithOptions(request, runtime);
  }

  /**
   * Queries the number of packets blocked by a specified security feature.
   * 
   * @remarks
   * > You can call this operation up to 50 times per second per account.
   * 
   * @param request - DescribeDcdnUserSecDropRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnUserSecDropResponse
   */
  async describeDcdnUserSecDropWithOptions(request: DescribeDcdnUserSecDropRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnUserSecDropResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.data)) {
      query["Data"] = request.data;
    }

    if (!Util.isUnset(request.metric)) {
      query["Metric"] = request.metric;
    }

    if (!Util.isUnset(request.secFunc)) {
      query["SecFunc"] = request.secFunc;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnUserSecDrop",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnUserSecDropResponse>(await this.callApi(params, req, runtime), new DescribeDcdnUserSecDropResponse({}));
  }

  /**
   * Queries the number of packets blocked by a specified security feature.
   * 
   * @remarks
   * > You can call this operation up to 50 times per second per account.
   * 
   * @param request - DescribeDcdnUserSecDropRequest
   * @returns DescribeDcdnUserSecDropResponse
   */
  async describeDcdnUserSecDrop(request: DescribeDcdnUserSecDropRequest): Promise<DescribeDcdnUserSecDropResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnUserSecDropWithOptions(request, runtime);
  }

  /**
   * Queries the number of packets that are blocked by security features at the application layer in a specific time range.
   * 
   * @remarks
   * > You can call this operation up to 50 times per second per account.
   * 
   * @param request - DescribeDcdnUserSecDropByMinuteRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnUserSecDropByMinuteResponse
   */
  async describeDcdnUserSecDropByMinuteWithOptions(request: DescribeDcdnUserSecDropByMinuteRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnUserSecDropByMinuteResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.object)) {
      query["Object"] = request.object;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.secFunc)) {
      query["SecFunc"] = request.secFunc;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnUserSecDropByMinute",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnUserSecDropByMinuteResponse>(await this.callApi(params, req, runtime), new DescribeDcdnUserSecDropByMinuteResponse({}));
  }

  /**
   * Queries the number of packets that are blocked by security features at the application layer in a specific time range.
   * 
   * @remarks
   * > You can call this operation up to 50 times per second per account.
   * 
   * @param request - DescribeDcdnUserSecDropByMinuteRequest
   * @returns DescribeDcdnUserSecDropByMinuteResponse
   */
  async describeDcdnUserSecDropByMinute(request: DescribeDcdnUserSecDropByMinuteRequest): Promise<DescribeDcdnUserSecDropByMinuteResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnUserSecDropByMinuteWithOptions(request, runtime);
  }

  /**
   * Queries user tags.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnUserTagsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnUserTagsResponse
   */
  async describeDcdnUserTagsWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeDcdnUserTagsResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnUserTags",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnUserTagsResponse>(await this.callApi(params, req, runtime), new DescribeDcdnUserTagsResponse({}));
  }

  /**
   * Queries user tags.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * @returns DescribeDcdnUserTagsResponse
   */
  async describeDcdnUserTags(): Promise<DescribeDcdnUserTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnUserTagsWithOptions(runtime);
  }

  /**
   * Queries virtual IP addresses of the POPs by domain name.
   * 
   * @remarks
   * >  You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeDcdnUserVipsByDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnUserVipsByDomainResponse
   */
  async describeDcdnUserVipsByDomainWithOptions(request: DescribeDcdnUserVipsByDomainRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnUserVipsByDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.available)) {
      query["Available"] = request.available;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnUserVipsByDomain",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnUserVipsByDomainResponse>(await this.callApi(params, req, runtime), new DescribeDcdnUserVipsByDomainResponse({}));
  }

  /**
   * Queries virtual IP addresses of the POPs by domain name.
   * 
   * @remarks
   * >  You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeDcdnUserVipsByDomainRequest
   * @returns DescribeDcdnUserVipsByDomainResponse
   */
  async describeDcdnUserVipsByDomain(request: DescribeDcdnUserVipsByDomainRequest): Promise<DescribeDcdnUserVipsByDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnUserVipsByDomainWithOptions(request, runtime);
  }

  /**
   * Queries the ownership verification content of a domain name.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnVerifyContentRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnVerifyContentResponse
   */
  async describeDcdnVerifyContentWithOptions(request: DescribeDcdnVerifyContentRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnVerifyContentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnVerifyContent",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnVerifyContentResponse>(await this.callApi(params, req, runtime), new DescribeDcdnVerifyContentResponse({}));
  }

  /**
   * Queries the ownership verification content of a domain name.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnVerifyContentRequest
   * @returns DescribeDcdnVerifyContentResponse
   */
  async describeDcdnVerifyContent(request: DescribeDcdnVerifyContentRequest): Promise<DescribeDcdnVerifyContentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnVerifyContentWithOptions(request, runtime);
  }

  /**
   * Queries the SDK authentication key for the Alibaba Cloud account. You can also use the SDK authentication key to send SDK initialization requests. The key must be included in the integration code.
   * 
   * @param request - DescribeDcdnWafBotAppKeyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnWafBotAppKeyResponse
   */
  async describeDcdnWafBotAppKeyWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeDcdnWafBotAppKeyResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnWafBotAppKey",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnWafBotAppKeyResponse>(await this.callApi(params, req, runtime), new DescribeDcdnWafBotAppKeyResponse({}));
  }

  /**
   * Queries the SDK authentication key for the Alibaba Cloud account. You can also use the SDK authentication key to send SDK initialization requests. The key must be included in the integration code.
   * @returns DescribeDcdnWafBotAppKeyResponse
   */
  async describeDcdnWafBotAppKey(): Promise<DescribeDcdnWafBotAppKeyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnWafBotAppKeyWithOptions(runtime);
  }

  /**
   * Queries the default configurations of a WAF rule.
   * 
   * @param request - DescribeDcdnWafDefaultRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnWafDefaultRulesResponse
   */
  async describeDcdnWafDefaultRulesWithOptions(request: DescribeDcdnWafDefaultRulesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnWafDefaultRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.queryArgs)) {
      query["QueryArgs"] = request.queryArgs;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnWafDefaultRules",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnWafDefaultRulesResponse>(await this.callApi(params, req, runtime), new DescribeDcdnWafDefaultRulesResponse({}));
  }

  /**
   * Queries the default configurations of a WAF rule.
   * 
   * @param request - DescribeDcdnWafDefaultRulesRequest
   * @returns DescribeDcdnWafDefaultRulesResponse
   */
  async describeDcdnWafDefaultRules(request: DescribeDcdnWafDefaultRulesRequest): Promise<DescribeDcdnWafDefaultRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnWafDefaultRulesWithOptions(request, runtime);
  }

  /**
   * Queries domain names that have Web Application Firewall (WAF) enabled and the relevant information, including the status of the access control list (ACL), protection against HTTP flood attacks, domain name, and WAF.
   * 
   * @remarks
   * > You can call this operation up to 50 times per second per account.
   * 
   * @param request - DescribeDcdnWafDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnWafDomainResponse
   */
  async describeDcdnWafDomainWithOptions(request: DescribeDcdnWafDomainRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnWafDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnWafDomain",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnWafDomainResponse>(await this.callApi(params, req, runtime), new DescribeDcdnWafDomainResponse({}));
  }

  /**
   * Queries domain names that have Web Application Firewall (WAF) enabled and the relevant information, including the status of the access control list (ACL), protection against HTTP flood attacks, domain name, and WAF.
   * 
   * @remarks
   * > You can call this operation up to 50 times per second per account.
   * 
   * @param request - DescribeDcdnWafDomainRequest
   * @returns DescribeDcdnWafDomainResponse
   */
  async describeDcdnWafDomain(request: DescribeDcdnWafDomainRequest): Promise<DescribeDcdnWafDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnWafDomainWithOptions(request, runtime);
  }

  /**
   * Queries the information about the protection policy of a domain name.
   * 
   * @remarks
   * You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeDcdnWafDomainDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnWafDomainDetailResponse
   */
  async describeDcdnWafDomainDetailWithOptions(request: DescribeDcdnWafDomainDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnWafDomainDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnWafDomainDetail",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnWafDomainDetailResponse>(await this.callApi(params, req, runtime), new DescribeDcdnWafDomainDetailResponse({}));
  }

  /**
   * Queries the information about the protection policy of a domain name.
   * 
   * @remarks
   * You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeDcdnWafDomainDetailRequest
   * @returns DescribeDcdnWafDomainDetailResponse
   */
  async describeDcdnWafDomainDetail(request: DescribeDcdnWafDomainDetailRequest): Promise<DescribeDcdnWafDomainDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnWafDomainDetailWithOptions(request, runtime);
  }

  /**
   * Queries the accelerated domain names that are protected by Web Application Firewall (WAF). Fuzzy search is supported.
   * 
   * @remarks
   * You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeDcdnWafDomainsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnWafDomainsResponse
   */
  async describeDcdnWafDomainsWithOptions(request: DescribeDcdnWafDomainsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnWafDomainsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.queryArgs)) {
      query["QueryArgs"] = request.queryArgs;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnWafDomains",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnWafDomainsResponse>(await this.callApi(params, req, runtime), new DescribeDcdnWafDomainsResponse({}));
  }

  /**
   * Queries the accelerated domain names that are protected by Web Application Firewall (WAF). Fuzzy search is supported.
   * 
   * @remarks
   * You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeDcdnWafDomainsRequest
   * @returns DescribeDcdnWafDomainsResponse
   */
  async describeDcdnWafDomains(request: DescribeDcdnWafDomainsRequest): Promise<DescribeDcdnWafDomainsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnWafDomainsWithOptions(request, runtime);
  }

  /**
   * Queries the information about match conditions in a custom protection rule, such as the match fields, logical characters, and match content.
   * 
   * @remarks
   * You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeDcdnWafFilterInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnWafFilterInfoResponse
   */
  async describeDcdnWafFilterInfoWithOptions(request: DescribeDcdnWafFilterInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnWafFilterInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.defenseScenes)) {
      query["DefenseScenes"] = request.defenseScenes;
    }

    if (!Util.isUnset(request.language)) {
      query["Language"] = request.language;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnWafFilterInfo",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnWafFilterInfoResponse>(await this.callApi(params, req, runtime), new DescribeDcdnWafFilterInfoResponse({}));
  }

  /**
   * Queries the information about match conditions in a custom protection rule, such as the match fields, logical characters, and match content.
   * 
   * @remarks
   * You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeDcdnWafFilterInfoRequest
   * @returns DescribeDcdnWafFilterInfoResponse
   */
  async describeDcdnWafFilterInfo(request: DescribeDcdnWafFilterInfoRequest): Promise<DescribeDcdnWafFilterInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnWafFilterInfoWithOptions(request, runtime);
  }

  /**
   * Queries the countries and regions that can be added to the blacklist of Web Application Firewall (WAF).
   * 
   * @remarks
   * > You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeDcdnWafGeoInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnWafGeoInfoResponse
   */
  async describeDcdnWafGeoInfoWithOptions(request: DescribeDcdnWafGeoInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnWafGeoInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.language)) {
      query["Language"] = request.language;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnWafGeoInfo",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnWafGeoInfoResponse>(await this.callApi(params, req, runtime), new DescribeDcdnWafGeoInfoResponse({}));
  }

  /**
   * Queries the countries and regions that can be added to the blacklist of Web Application Firewall (WAF).
   * 
   * @remarks
   * > You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeDcdnWafGeoInfoRequest
   * @returns DescribeDcdnWafGeoInfoResponse
   */
  async describeDcdnWafGeoInfo(request: DescribeDcdnWafGeoInfoRequest): Promise<DescribeDcdnWafGeoInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnWafGeoInfoWithOptions(request, runtime);
  }

  /**
   * Queries the details of a custom WAF rule group by page.
   * 
   * @param request - DescribeDcdnWafGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnWafGroupResponse
   */
  async describeDcdnWafGroupWithOptions(request: DescribeDcdnWafGroupRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnWafGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.language)) {
      query["Language"] = request.language;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.queryArgs)) {
      query["QueryArgs"] = request.queryArgs;
    }

    if (!Util.isUnset(request.scope)) {
      query["Scope"] = request.scope;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnWafGroup",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnWafGroupResponse>(await this.callApi(params, req, runtime), new DescribeDcdnWafGroupResponse({}));
  }

  /**
   * Queries the details of a custom WAF rule group by page.
   * 
   * @param request - DescribeDcdnWafGroupRequest
   * @returns DescribeDcdnWafGroupResponse
   */
  async describeDcdnWafGroup(request: DescribeDcdnWafGroupRequest): Promise<DescribeDcdnWafGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnWafGroupWithOptions(request, runtime);
  }

  /**
   * Queries custom Web Application Firewall (WAF) rule groups.
   * 
   * @param request - DescribeDcdnWafGroupsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnWafGroupsResponse
   */
  async describeDcdnWafGroupsWithOptions(request: DescribeDcdnWafGroupsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnWafGroupsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.language)) {
      query["Language"] = request.language;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.queryArgs)) {
      query["QueryArgs"] = request.queryArgs;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnWafGroups",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnWafGroupsResponse>(await this.callApi(params, req, runtime), new DescribeDcdnWafGroupsResponse({}));
  }

  /**
   * Queries custom Web Application Firewall (WAF) rule groups.
   * 
   * @param request - DescribeDcdnWafGroupsRequest
   * @returns DescribeDcdnWafGroupsResponse
   */
  async describeDcdnWafGroups(request: DescribeDcdnWafGroupsRequest): Promise<DescribeDcdnWafGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnWafGroupsWithOptions(request, runtime);
  }

  /**
   * Queries the address from which you can download the Web Application Firewall (WAF) logs of a domain name.
   * 
   * @remarks
   * > 
   * *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
   * *   The log data is collected every hour.
   * *   You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnWafLogsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnWafLogsResponse
   */
  async describeDcdnWafLogsWithOptions(request: DescribeDcdnWafLogsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnWafLogsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnWafLogs",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnWafLogsResponse>(await this.callApi(params, req, runtime), new DescribeDcdnWafLogsResponse({}));
  }

  /**
   * Queries the address from which you can download the Web Application Firewall (WAF) logs of a domain name.
   * 
   * @remarks
   * > 
   * *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
   * *   The log data is collected every hour.
   * *   You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeDcdnWafLogsRequest
   * @returns DescribeDcdnWafLogsResponse
   */
  async describeDcdnWafLogs(request: DescribeDcdnWafLogsRequest): Promise<DescribeDcdnWafLogsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnWafLogsWithOptions(request, runtime);
  }

  /**
   * Queries the details of the Web Application Firewall (WAF) protection policies that you configured.
   * 
   * @remarks
   * You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeDcdnWafPoliciesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnWafPoliciesResponse
   */
  async describeDcdnWafPoliciesWithOptions(request: DescribeDcdnWafPoliciesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnWafPoliciesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.queryArgs)) {
      query["QueryArgs"] = request.queryArgs;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnWafPolicies",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnWafPoliciesResponse>(await this.callApi(params, req, runtime), new DescribeDcdnWafPoliciesResponse({}));
  }

  /**
   * Queries the details of the Web Application Firewall (WAF) protection policies that you configured.
   * 
   * @remarks
   * You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeDcdnWafPoliciesRequest
   * @returns DescribeDcdnWafPoliciesResponse
   */
  async describeDcdnWafPolicies(request: DescribeDcdnWafPoliciesRequest): Promise<DescribeDcdnWafPoliciesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnWafPoliciesWithOptions(request, runtime);
  }

  /**
   * Queries the details of a protection policy.
   * 
   * @remarks
   * > You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeDcdnWafPolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnWafPolicyResponse
   */
  async describeDcdnWafPolicyWithOptions(request: DescribeDcdnWafPolicyRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnWafPolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnWafPolicy",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnWafPolicyResponse>(await this.callApi(params, req, runtime), new DescribeDcdnWafPolicyResponse({}));
  }

  /**
   * Queries the details of a protection policy.
   * 
   * @remarks
   * > You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeDcdnWafPolicyRequest
   * @returns DescribeDcdnWafPolicyResponse
   */
  async describeDcdnWafPolicy(request: DescribeDcdnWafPolicyRequest): Promise<DescribeDcdnWafPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnWafPolicyWithOptions(request, runtime);
  }

  /**
   * Queries the accelerated domain names that are protected by a specified Web Application Firewall (WAF) protection policy.
   * 
   * @remarks
   * You can call this operation up to 20 times per second per user.
   * 
   * @param request - DescribeDcdnWafPolicyDomainsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnWafPolicyDomainsResponse
   */
  async describeDcdnWafPolicyDomainsWithOptions(request: DescribeDcdnWafPolicyDomainsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnWafPolicyDomainsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnWafPolicyDomains",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnWafPolicyDomainsResponse>(await this.callApi(params, req, runtime), new DescribeDcdnWafPolicyDomainsResponse({}));
  }

  /**
   * Queries the accelerated domain names that are protected by a specified Web Application Firewall (WAF) protection policy.
   * 
   * @remarks
   * You can call this operation up to 20 times per second per user.
   * 
   * @param request - DescribeDcdnWafPolicyDomainsRequest
   * @returns DescribeDcdnWafPolicyDomainsResponse
   */
  async describeDcdnWafPolicyDomains(request: DescribeDcdnWafPolicyDomainsRequest): Promise<DescribeDcdnWafPolicyDomainsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnWafPolicyDomainsWithOptions(request, runtime);
  }

  /**
   * Queries the domain names that can be bound to a custom protection policy.
   * 
   * @remarks
   * You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeDcdnWafPolicyValidDomainsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnWafPolicyValidDomainsResponse
   */
  async describeDcdnWafPolicyValidDomainsWithOptions(request: DescribeDcdnWafPolicyValidDomainsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnWafPolicyValidDomainsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.defenseScene)) {
      query["DefenseScene"] = request.defenseScene;
    }

    if (!Util.isUnset(request.domainNameLike)) {
      query["DomainNameLike"] = request.domainNameLike;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnWafPolicyValidDomains",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnWafPolicyValidDomainsResponse>(await this.callApi(params, req, runtime), new DescribeDcdnWafPolicyValidDomainsResponse({}));
  }

  /**
   * Queries the domain names that can be bound to a custom protection policy.
   * 
   * @remarks
   * You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeDcdnWafPolicyValidDomainsRequest
   * @returns DescribeDcdnWafPolicyValidDomainsResponse
   */
  async describeDcdnWafPolicyValidDomains(request: DescribeDcdnWafPolicyValidDomainsRequest): Promise<DescribeDcdnWafPolicyValidDomainsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnWafPolicyValidDomainsWithOptions(request, runtime);
  }

  /**
   * Queries the details of a specified protection rule.
   * 
   * @remarks
   * #
   * You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeDcdnWafRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnWafRuleResponse
   */
  async describeDcdnWafRuleWithOptions(request: DescribeDcdnWafRuleRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnWafRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnWafRule",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnWafRuleResponse>(await this.callApi(params, req, runtime), new DescribeDcdnWafRuleResponse({}));
  }

  /**
   * Queries the details of a specified protection rule.
   * 
   * @remarks
   * #
   * You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeDcdnWafRuleRequest
   * @returns DescribeDcdnWafRuleResponse
   */
  async describeDcdnWafRule(request: DescribeDcdnWafRuleRequest): Promise<DescribeDcdnWafRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnWafRuleWithOptions(request, runtime);
  }

  /**
   * Queries the details of the protection rules that you configured.
   * 
   * @remarks
   * You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeDcdnWafRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnWafRulesResponse
   */
  async describeDcdnWafRulesWithOptions(request: DescribeDcdnWafRulesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnWafRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.queryArgs)) {
      query["QueryArgs"] = request.queryArgs;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnWafRules",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnWafRulesResponse>(await this.callApi(params, req, runtime), new DescribeDcdnWafRulesResponse({}));
  }

  /**
   * Queries the details of the protection rules that you configured.
   * 
   * @remarks
   * You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeDcdnWafRulesRequest
   * @returns DescribeDcdnWafRulesResponse
   */
  async describeDcdnWafRules(request: DescribeDcdnWafRulesRequest): Promise<DescribeDcdnWafRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnWafRulesWithOptions(request, runtime);
  }

  /**
   * Queries the information about the type of the protection policy that you use.
   * 
   * @remarks
   * You can call this operation up to 20 times per second per user.
   * 
   * @param request - DescribeDcdnWafScenesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnWafScenesResponse
   */
  async describeDcdnWafScenesWithOptions(request: DescribeDcdnWafScenesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnWafScenesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.defenseScenes)) {
      query["DefenseScenes"] = request.defenseScenes;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnWafScenes",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnWafScenesResponse>(await this.callApi(params, req, runtime), new DescribeDcdnWafScenesResponse({}));
  }

  /**
   * Queries the information about the type of the protection policy that you use.
   * 
   * @remarks
   * You can call this operation up to 20 times per second per user.
   * 
   * @param request - DescribeDcdnWafScenesRequest
   * @returns DescribeDcdnWafScenesResponse
   */
  async describeDcdnWafScenes(request: DescribeDcdnWafScenesRequest): Promise<DescribeDcdnWafScenesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnWafScenesWithOptions(request, runtime);
  }

  /**
   * Queries the information about Dynamic Content Delivery Network (DCDN) Web Application Firewall WAF), including the time when WAF is enabled, edition of WAF, current status of WAF, metering method for requests, and metering method for rules.
   * 
   * @remarks
   * # Usage notes
   * You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeDcdnWafServiceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnWafServiceResponse
   */
  async describeDcdnWafServiceWithOptions(request: DescribeDcdnWafServiceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnWafServiceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnWafService",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnWafServiceResponse>(await this.callApi(params, req, runtime), new DescribeDcdnWafServiceResponse({}));
  }

  /**
   * Queries the information about Dynamic Content Delivery Network (DCDN) Web Application Firewall WAF), including the time when WAF is enabled, edition of WAF, current status of WAF, metering method for requests, and metering method for rules.
   * 
   * @remarks
   * # Usage notes
   * You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeDcdnWafServiceRequest
   * @returns DescribeDcdnWafServiceResponse
   */
  async describeDcdnWafService(request: DescribeDcdnWafServiceRequest): Promise<DescribeDcdnWafServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnWafServiceWithOptions(request, runtime);
  }

  /**
   * Queries the version of Web Application Firewall (WAF) used in Dynamic Content Delivery Network (DCDN).
   * 
   * @remarks
   * You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeDcdnWafSpecInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnWafSpecInfoResponse
   */
  async describeDcdnWafSpecInfoWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeDcdnWafSpecInfoResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnWafSpecInfo",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnWafSpecInfoResponse>(await this.callApi(params, req, runtime), new DescribeDcdnWafSpecInfoResponse({}));
  }

  /**
   * Queries the version of Web Application Firewall (WAF) used in Dynamic Content Delivery Network (DCDN).
   * 
   * @remarks
   * You can call this operation up to 20 times per second per account.
   * @returns DescribeDcdnWafSpecInfoResponse
   */
  async describeDcdnWafSpecInfo(): Promise<DescribeDcdnWafSpecInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnWafSpecInfoWithOptions(runtime);
  }

  /**
   * The number of used SeCUs.
   * 
   * @remarks
   *   You can call this operation up to 10 times per second per account.
   * *   The minimum time granularity for a query is 5 minutes. The maximum time span for a query is 31 days. The time period within which historical data is available for a query is 90 days.
   * 
   * @param request - DescribeDcdnWafUsageDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnWafUsageDataResponse
   */
  async describeDcdnWafUsageDataWithOptions(request: DescribeDcdnWafUsageDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnWafUsageDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!Util.isUnset(request.splitBy)) {
      query["SplitBy"] = request.splitBy;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnWafUsageData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnWafUsageDataResponse>(await this.callApi(params, req, runtime), new DescribeDcdnWafUsageDataResponse({}));
  }

  /**
   * The number of used SeCUs.
   * 
   * @remarks
   *   You can call this operation up to 10 times per second per account.
   * *   The minimum time granularity for a query is 5 minutes. The maximum time span for a query is 31 days. The time period within which historical data is available for a query is 90 days.
   * 
   * @param request - DescribeDcdnWafUsageDataRequest
   * @returns DescribeDcdnWafUsageDataResponse
   */
  async describeDcdnWafUsageData(request: DescribeDcdnWafUsageDataRequest): Promise<DescribeDcdnWafUsageDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnWafUsageDataWithOptions(request, runtime);
  }

  /**
   * Queries the information about Dynamic Content Delivery Network (DCDN), such as the service activation time, the expiration time, and the current status.
   * 
   * @remarks
   * > You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeDcdnsecServiceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDcdnsecServiceResponse
   */
  async describeDcdnsecServiceWithOptions(request: DescribeDcdnsecServiceRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDcdnsecServiceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDcdnsecService",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDcdnsecServiceResponse>(await this.callApi(params, req, runtime), new DescribeDcdnsecServiceResponse({}));
  }

  /**
   * Queries the information about Dynamic Content Delivery Network (DCDN), such as the service activation time, the expiration time, and the current status.
   * 
   * @remarks
   * > You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeDcdnsecServiceRequest
   * @returns DescribeDcdnsecServiceResponse
   */
  async describeDcdnsecService(request: DescribeDcdnsecServiceRequest): Promise<DescribeDcdnsecServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDcdnsecServiceWithOptions(request, runtime);
  }

  /**
   * Queries attack events.
   * 
   * @param request - DescribeDdosAllEventListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDdosAllEventListResponse
   */
  async describeDdosAllEventListWithOptions(request: DescribeDdosAllEventListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDdosAllEventListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.eventType)) {
      query["EventType"] = request.eventType;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDdosAllEventList",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDdosAllEventListResponse>(await this.callApi(params, req, runtime), new DescribeDdosAllEventListResponse({}));
  }

  /**
   * Queries attack events.
   * 
   * @param request - DescribeDdosAllEventListRequest
   * @returns DescribeDdosAllEventListResponse
   */
  async describeDdosAllEventList(request: DescribeDdosAllEventListRequest): Promise<DescribeDdosAllEventListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDdosAllEventListWithOptions(request, runtime);
  }

  /**
   * Queries the encrypted RoutineUid of a routine.
   * 
   * @param request - DescribeEncryptRoutineUidRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeEncryptRoutineUidResponse
   */
  async describeEncryptRoutineUidWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeEncryptRoutineUidResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeEncryptRoutineUid",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeEncryptRoutineUidResponse>(await this.callApi(params, req, runtime), new DescribeEncryptRoutineUidResponse({}));
  }

  /**
   * Queries the encrypted RoutineUid of a routine.
   * @returns DescribeEncryptRoutineUidResponse
   */
  async describeEncryptRoutineUid(): Promise<DescribeEncryptRoutineUidResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEncryptRoutineUidWithOptions(runtime);
  }

  /**
   * Queries the highlighted data of attack details. You can query the reasons for which requests are blocked based on TraceIDs in logs of requests that are blocked by Basic Web Protection. The highlighted data matches the content blocked by the basic web protection module.
   * 
   * @param request - DescribeHighlightInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeHighlightInfoResponse
   */
  async describeHighlightInfoWithOptions(request: DescribeHighlightInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeHighlightInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.traceId)) {
      query["TraceId"] = request.traceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeHighlightInfo",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeHighlightInfoResponse>(await this.callApi(params, req, runtime), new DescribeHighlightInfoResponse({}));
  }

  /**
   * Queries the highlighted data of attack details. You can query the reasons for which requests are blocked based on TraceIDs in logs of requests that are blocked by Basic Web Protection. The highlighted data matches the content blocked by the basic web protection module.
   * 
   * @param request - DescribeHighlightInfoRequest
   * @returns DescribeHighlightInfoResponse
   */
  async describeHighlightInfo(request: DescribeHighlightInfoRequest): Promise<DescribeHighlightInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeHighlightInfoWithOptions(request, runtime);
  }

  /**
   * Queries the usage data of KV storage.
   * 
   * @remarks
   * *Note*** You can call this operation up to 5 times per second per account.
   * * The usage data indicates the number of requests.
   * **Time granularity:** This operation supports only the time granularity of 1 hour.
   * |Time granularity|Time range to query|Historical data available|Data latency|
   * |---|---|---|---|
   * |1 hour|31 days|90 days|3 to 4 hours|
   * 
   * @param request - DescribeKvUsageDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeKvUsageDataResponse
   */
  async describeKvUsageDataWithOptions(request: DescribeKvUsageDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeKvUsageDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.accessType)) {
      query["AccessType"] = request.accessType;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.field)) {
      query["Field"] = request.field;
    }

    if (!Util.isUnset(request.namespaceId)) {
      query["NamespaceId"] = request.namespaceId;
    }

    if (!Util.isUnset(request.responseType)) {
      query["ResponseType"] = request.responseType;
    }

    if (!Util.isUnset(request.splitBy)) {
      query["SplitBy"] = request.splitBy;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeKvUsageData",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeKvUsageDataResponse>(await this.callApi(params, req, runtime), new DescribeKvUsageDataResponse({}));
  }

  /**
   * Queries the usage data of KV storage.
   * 
   * @remarks
   * *Note*** You can call this operation up to 5 times per second per account.
   * * The usage data indicates the number of requests.
   * **Time granularity:** This operation supports only the time granularity of 1 hour.
   * |Time granularity|Time range to query|Historical data available|Data latency|
   * |---|---|---|---|
   * |1 hour|31 days|90 days|3 to 4 hours|
   * 
   * @param request - DescribeKvUsageDataRequest
   * @returns DescribeKvUsageDataResponse
   */
  async describeKvUsageData(request: DescribeKvUsageDataRequest): Promise<DescribeKvUsageDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeKvUsageDataWithOptions(request, runtime);
  }

  /**
   * Queries the feature configurations of an accelerated domain name in the resource directory.
   * 
   * @param request - DescribeRDDomainConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeRDDomainConfigResponse
   */
  async describeRDDomainConfigWithOptions(request: DescribeRDDomainConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRDDomainConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.functionName)) {
      query["FunctionName"] = request.functionName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRDDomainConfig",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRDDomainConfigResponse>(await this.callApi(params, req, runtime), new DescribeRDDomainConfigResponse({}));
  }

  /**
   * Queries the feature configurations of an accelerated domain name in the resource directory.
   * 
   * @param request - DescribeRDDomainConfigRequest
   * @returns DescribeRDDomainConfigResponse
   */
  async describeRDDomainConfig(request: DescribeRDDomainConfigRequest): Promise<DescribeRDDomainConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRDDomainConfigWithOptions(request, runtime);
  }

  /**
   * Queries all domain names of Alibaba Cloud CDN and Dynamic Content Delivery Network (DCDN) in a Resource Directory (RD).
   * 
   * @remarks
   * A domain name can be in one of the following states:
   * *   online
   * *   offline
   * *   configuring
   * *   configure_failed
   * *   checking
   * *   check_failed
   * 
   * @param request - DescribeRDDomainsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeRDDomainsResponse
   */
  async describeRDDomainsWithOptions(request: DescribeRDDomainsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRDDomainsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRDDomains",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRDDomainsResponse>(await this.callApi(params, req, runtime), new DescribeRDDomainsResponse({}));
  }

  /**
   * Queries all domain names of Alibaba Cloud CDN and Dynamic Content Delivery Network (DCDN) in a Resource Directory (RD).
   * 
   * @remarks
   * A domain name can be in one of the following states:
   * *   online
   * *   offline
   * *   configuring
   * *   configure_failed
   * *   checking
   * *   check_failed
   * 
   * @param request - DescribeRDDomainsRequest
   * @returns DescribeRDDomainsResponse
   */
  async describeRDDomains(request: DescribeRDDomainsRequest): Promise<DescribeRDDomainsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRDDomainsWithOptions(request, runtime);
  }

  /**
   * Queries the metadata of a specified routine. The metadata includes the routine configuration, configuration version, and code version.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeRoutineRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeRoutineResponse
   */
  async describeRoutineWithOptions(request: DescribeRoutineRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRoutineResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRoutine",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRoutineResponse>(await this.callApi(params, req, runtime), new DescribeRoutineResponse({}));
  }

  /**
   * Queries the metadata of a specified routine. The metadata includes the routine configuration, configuration version, and code version.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeRoutineRequest
   * @returns DescribeRoutineResponse
   */
  async describeRoutine(request: DescribeRoutineRequest): Promise<DescribeRoutineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRoutineWithOptions(request, runtime);
  }

  /**
   * Queries the canary release environments that are supported by a routine.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeRoutineCanaryEnvsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeRoutineCanaryEnvsResponse
   */
  async describeRoutineCanaryEnvsWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeRoutineCanaryEnvsResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeRoutineCanaryEnvs",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRoutineCanaryEnvsResponse>(await this.callApi(params, req, runtime), new DescribeRoutineCanaryEnvsResponse({}));
  }

  /**
   * Queries the canary release environments that are supported by a routine.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * @returns DescribeRoutineCanaryEnvsResponse
   */
  async describeRoutineCanaryEnvs(): Promise<DescribeRoutineCanaryEnvsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRoutineCanaryEnvsWithOptions(runtime);
  }

  /**
   * Queries the JavaScript code version of a routine.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeRoutineCodeRevisionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeRoutineCodeRevisionResponse
   */
  async describeRoutineCodeRevisionWithOptions(request: DescribeRoutineCodeRevisionRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRoutineCodeRevisionResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.selectCodeRevision)) {
      body["SelectCodeRevision"] = request.selectCodeRevision;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRoutineCodeRevision",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRoutineCodeRevisionResponse>(await this.callApi(params, req, runtime), new DescribeRoutineCodeRevisionResponse({}));
  }

  /**
   * Queries the JavaScript code version of a routine.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeRoutineCodeRevisionRequest
   * @returns DescribeRoutineCodeRevisionResponse
   */
  async describeRoutineCodeRevision(request: DescribeRoutineCodeRevisionRequest): Promise<DescribeRoutineCodeRevisionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRoutineCodeRevisionWithOptions(request, runtime);
  }

  /**
   * Queries the list of domain names that are associated with a routine.
   * 
   * @param request - DescribeRoutineRelatedDomainsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeRoutineRelatedDomainsResponse
   */
  async describeRoutineRelatedDomainsWithOptions(request: DescribeRoutineRelatedDomainsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRoutineRelatedDomainsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRoutineRelatedDomains",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRoutineRelatedDomainsResponse>(await this.callApi(params, req, runtime), new DescribeRoutineRelatedDomainsResponse({}));
  }

  /**
   * Queries the list of domain names that are associated with a routine.
   * 
   * @param request - DescribeRoutineRelatedDomainsRequest
   * @returns DescribeRoutineRelatedDomainsResponse
   */
  async describeRoutineRelatedDomains(request: DescribeRoutineRelatedDomainsRequest): Promise<DescribeRoutineRelatedDomainsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRoutineRelatedDomainsWithOptions(request, runtime);
  }

  /**
   * Queries the supported specifications for routines. The private preview supports the following CPU time slice specifications: 5 ms, 50 ms, and 100 ms.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeRoutineSpecRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeRoutineSpecResponse
   */
  async describeRoutineSpecWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeRoutineSpecResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeRoutineSpec",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRoutineSpecResponse>(await this.callApi(params, req, runtime), new DescribeRoutineSpecResponse({}));
  }

  /**
   * Queries the supported specifications for routines. The private preview supports the following CPU time slice specifications: 5 ms, 50 ms, and 100 ms.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * @returns DescribeRoutineSpecResponse
   */
  async describeRoutineSpec(): Promise<DescribeRoutineSpecResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRoutineSpecWithOptions(runtime);
  }

  /**
   * Queries the subdomains and routines that belong to your Alibaba Cloud account.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - DescribeRoutineUserInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeRoutineUserInfoResponse
   */
  async describeRoutineUserInfoWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeRoutineUserInfoResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeRoutineUserInfo",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRoutineUserInfoResponse>(await this.callApi(params, req, runtime), new DescribeRoutineUserInfoResponse({}));
  }

  /**
   * Queries the subdomains and routines that belong to your Alibaba Cloud account.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * @returns DescribeRoutineUserInfoResponse
   */
  async describeRoutineUserInfo(): Promise<DescribeRoutineUserInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRoutineUserInfoWithOptions(runtime);
  }

  /**
   * Whether IPA is enabled and whether you have overdue payments for your IPA are queried.
   * 
   * @remarks
   * *
   * **The maximum number of times that each user can call this operation per second is 20.
   * 
   * @param request - DescribeUserDcdnIpaStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeUserDcdnIpaStatusResponse
   */
  async describeUserDcdnIpaStatusWithOptions(request: DescribeUserDcdnIpaStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeUserDcdnIpaStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeUserDcdnIpaStatus",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeUserDcdnIpaStatusResponse>(await this.callApi(params, req, runtime), new DescribeUserDcdnIpaStatusResponse({}));
  }

  /**
   * Whether IPA is enabled and whether you have overdue payments for your IPA are queried.
   * 
   * @remarks
   * *
   * **The maximum number of times that each user can call this operation per second is 20.
   * 
   * @param request - DescribeUserDcdnIpaStatusRequest
   * @returns DescribeUserDcdnIpaStatusResponse
   */
  async describeUserDcdnIpaStatus(request: DescribeUserDcdnIpaStatusRequest): Promise<DescribeUserDcdnIpaStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeUserDcdnIpaStatusWithOptions(request, runtime);
  }

  /**
   * Queries whether DCDN is activated and whether your account has overdue payments.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeUserDcdnStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeUserDcdnStatusResponse
   */
  async describeUserDcdnStatusWithOptions(request: DescribeUserDcdnStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeUserDcdnStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeUserDcdnStatus",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeUserDcdnStatusResponse>(await this.callApi(params, req, runtime), new DescribeUserDcdnStatusResponse({}));
  }

  /**
   * Queries whether DCDN is activated and whether your account has overdue payments.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeUserDcdnStatusRequest
   * @returns DescribeUserDcdnStatusResponse
   */
  async describeUserDcdnStatus(request: DescribeUserDcdnStatusRequest): Promise<DescribeUserDcdnStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeUserDcdnStatusWithOptions(request, runtime);
  }

  /**
   * Queries whether EdgeRoutine (ER) is activated or has an overdue payment.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeUserErStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeUserErStatusResponse
   */
  async describeUserErStatusWithOptions(request: DescribeUserErStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeUserErStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeUserErStatus",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeUserErStatusResponse>(await this.callApi(params, req, runtime), new DescribeUserErStatusResponse({}));
  }

  /**
   * Queries whether EdgeRoutine (ER) is activated or has an overdue payment.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - DescribeUserErStatusRequest
   * @returns DescribeUserErStatusResponse
   */
  async describeUserErStatus(request: DescribeUserErStatusRequest): Promise<DescribeUserErStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeUserErStatusWithOptions(request, runtime);
  }

  /**
   * Queries whether Log Service is activated and whether you have overdue payments for your Log Service.
   * 
   * @remarks
   * > You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeUserLogserviceStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeUserLogserviceStatusResponse
   */
  async describeUserLogserviceStatusWithOptions(request: DescribeUserLogserviceStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeUserLogserviceStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeUserLogserviceStatus",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeUserLogserviceStatusResponse>(await this.callApi(params, req, runtime), new DescribeUserLogserviceStatusResponse({}));
  }

  /**
   * Queries whether Log Service is activated and whether you have overdue payments for your Log Service.
   * 
   * @remarks
   * > You can call this operation up to 20 times per second per account.
   * 
   * @param request - DescribeUserLogserviceStatusRequest
   * @returns DescribeUserLogserviceStatusResponse
   */
  async describeUserLogserviceStatus(request: DescribeUserLogserviceStatusRequest): Promise<DescribeUserLogserviceStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeUserLogserviceStatusWithOptions(request, runtime);
  }

  /**
   * Modifies the configurations of a routine.
   * 
   * @remarks
   * > 
   * *   This operation modifies only the specified configurations. Other configurations remain unchanged.
   * *   If you want to delete a setting, delete the parameter value.
   * *   This operation can add canary release environments. Make sure that the environment names comply with the naming rules. Otherwise, you will fail to add the environments.
   * *   Dynamic Route for CDN (DCDN) provides 35 canary release environments. Among these environments, 34 are deployed in China and 1 is deployed outside China. The canary release environments are:
   *     *   Outside China: presetCanaryOverseas.
   *     *   In China: The 34 canary release environments are named in the format of presetCanaryXX. For example, presetCanaryBeijing represents the canary release environment in Beijing. A canary release environment is in each of the following regions: Anhui, Beijing, Chongqing, Fujian, Gansu, Guangdong, Guangxi, Guizhou, Hainan, Hebei, Heilongjiang, Henan, Hong Kong, Hubei, Hunan, Jiangsu, Jiangxi, Jilin, Liaoning, Macao, Neimenggu, Ningxia, Qinghai, Shaanxi, Shandong, Shanghai, Shanxi, Sichuan, Taiwan, Tianjin, Xinjiang, Xizang, Yunan, and Zhejiang.
   * *   You can call this operation up to 100 times per second per account.
   * 
   * @param tmpReq - EditRoutineConfRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EditRoutineConfResponse
   */
  async editRoutineConfWithOptions(tmpReq: EditRoutineConfRequest, runtime: $Util.RuntimeOptions): Promise<EditRoutineConfResponse> {
    Util.validateModel(tmpReq);
    let request = new EditRoutineConfShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.envConf)) {
      request.envConfShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.envConf, "EnvConf", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.envConfShrink)) {
      body["EnvConf"] = request.envConfShrink;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "EditRoutineConf",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EditRoutineConfResponse>(await this.callApi(params, req, runtime), new EditRoutineConfResponse({}));
  }

  /**
   * Modifies the configurations of a routine.
   * 
   * @remarks
   * > 
   * *   This operation modifies only the specified configurations. Other configurations remain unchanged.
   * *   If you want to delete a setting, delete the parameter value.
   * *   This operation can add canary release environments. Make sure that the environment names comply with the naming rules. Otherwise, you will fail to add the environments.
   * *   Dynamic Route for CDN (DCDN) provides 35 canary release environments. Among these environments, 34 are deployed in China and 1 is deployed outside China. The canary release environments are:
   *     *   Outside China: presetCanaryOverseas.
   *     *   In China: The 34 canary release environments are named in the format of presetCanaryXX. For example, presetCanaryBeijing represents the canary release environment in Beijing. A canary release environment is in each of the following regions: Anhui, Beijing, Chongqing, Fujian, Gansu, Guangdong, Guangxi, Guizhou, Hainan, Hebei, Heilongjiang, Henan, Hong Kong, Hubei, Hunan, Jiangsu, Jiangxi, Jilin, Liaoning, Macao, Neimenggu, Ningxia, Qinghai, Shaanxi, Shandong, Shanghai, Shanxi, Sichuan, Taiwan, Tianjin, Xinjiang, Xizang, Yunan, and Zhejiang.
   * *   You can call this operation up to 100 times per second per account.
   * 
   * @param request - EditRoutineConfRequest
   * @returns EditRoutineConfResponse
   */
  async editRoutineConf(request: EditRoutineConfRequest): Promise<EditRoutineConfResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.editRoutineConfWithOptions(request, runtime);
  }

  /**
   * Queries the value of a key in a key-value pair.
   * 
   * @param request - GetDcdnKvRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDcdnKvResponse
   */
  async getDcdnKvWithOptions(request: GetDcdnKvRequest, runtime: $Util.RuntimeOptions): Promise<GetDcdnKvResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDcdnKv",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDcdnKvResponse>(await this.callApi(params, req, runtime), new GetDcdnKvResponse({}));
  }

  /**
   * Queries the value of a key in a key-value pair.
   * 
   * @param request - GetDcdnKvRequest
   * @returns GetDcdnKvResponse
   */
  async getDcdnKv(request: GetDcdnKvRequest): Promise<GetDcdnKvResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDcdnKvWithOptions(request, runtime);
  }

  /**
   * Queries the KV status by key value.
   * 
   * @param request - GetDcdnKvStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDcdnKvStatusResponse
   */
  async getDcdnKvStatusWithOptions(request: GetDcdnKvStatusRequest, runtime: $Util.RuntimeOptions): Promise<GetDcdnKvStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.key)) {
      query["Key"] = request.key;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDcdnKvStatus",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDcdnKvStatusResponse>(await this.callApi(params, req, runtime), new GetDcdnKvStatusResponse({}));
  }

  /**
   * Queries the KV status by key value.
   * 
   * @param request - GetDcdnKvStatusRequest
   * @returns GetDcdnKvStatusResponse
   */
  async getDcdnKvStatus(request: GetDcdnKvStatusRequest): Promise<GetDcdnKvStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDcdnKvStatusWithOptions(request, runtime);
  }

  /**
   * Traverses the values of keys in a namespace.
   * 
   * @param request - ListDcdnKvRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDcdnKvResponse
   */
  async listDcdnKvWithOptions(request: ListDcdnKvRequest, runtime: $Util.RuntimeOptions): Promise<ListDcdnKvResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDcdnKv",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDcdnKvResponse>(await this.callApi(params, req, runtime), new ListDcdnKvResponse({}));
  }

  /**
   * Traverses the values of keys in a namespace.
   * 
   * @param request - ListDcdnKvRequest
   * @returns ListDcdnKvResponse
   */
  async listDcdnKv(request: ListDcdnKvRequest): Promise<ListDcdnKvResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDcdnKvWithOptions(request, runtime);
  }

  /**
   * Queries information about a real-time log delivery project.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - ListDcdnRealTimeDeliveryProjectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDcdnRealTimeDeliveryProjectResponse
   */
  async listDcdnRealTimeDeliveryProjectWithOptions(request: ListDcdnRealTimeDeliveryProjectRequest, runtime: $Util.RuntimeOptions): Promise<ListDcdnRealTimeDeliveryProjectResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.businessType)) {
      query["BusinessType"] = request.businessType;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDcdnRealTimeDeliveryProject",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDcdnRealTimeDeliveryProjectResponse>(await this.callApi(params, req, runtime), new ListDcdnRealTimeDeliveryProjectResponse({}));
  }

  /**
   * Queries information about a real-time log delivery project.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - ListDcdnRealTimeDeliveryProjectRequest
   * @returns ListDcdnRealTimeDeliveryProjectResponse
   */
  async listDcdnRealTimeDeliveryProject(request: ListDcdnRealTimeDeliveryProjectRequest): Promise<ListDcdnRealTimeDeliveryProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDcdnRealTimeDeliveryProjectWithOptions(request, runtime);
  }

  /**
   * Changes the acceleration region.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - ModifyDCdnDomainSchdmByPropertyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyDCdnDomainSchdmByPropertyResponse
   */
  async modifyDCdnDomainSchdmByPropertyWithOptions(request: ModifyDCdnDomainSchdmByPropertyRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDCdnDomainSchdmByPropertyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.property)) {
      query["Property"] = request.property;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyDCdnDomainSchdmByProperty",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyDCdnDomainSchdmByPropertyResponse>(await this.callApi(params, req, runtime), new ModifyDCdnDomainSchdmByPropertyResponse({}));
  }

  /**
   * Changes the acceleration region.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - ModifyDCdnDomainSchdmByPropertyRequest
   * @returns ModifyDCdnDomainSchdmByPropertyResponse
   */
  async modifyDCdnDomainSchdmByProperty(request: ModifyDCdnDomainSchdmByPropertyRequest): Promise<ModifyDCdnDomainSchdmByPropertyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDCdnDomainSchdmByPropertyWithOptions(request, runtime);
  }

  /**
   * Modifies a custom Web Application Firewall (WAF) rule group.
   * 
   * @param request - ModifyDcdnWafGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyDcdnWafGroupResponse
   */
  async modifyDcdnWafGroupWithOptions(request: ModifyDcdnWafGroupRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDcdnWafGroupResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.rules)) {
      body["Rules"] = request.rules;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyDcdnWafGroup",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyDcdnWafGroupResponse>(await this.callApi(params, req, runtime), new ModifyDcdnWafGroupResponse({}));
  }

  /**
   * Modifies a custom Web Application Firewall (WAF) rule group.
   * 
   * @param request - ModifyDcdnWafGroupRequest
   * @returns ModifyDcdnWafGroupResponse
   */
  async modifyDcdnWafGroup(request: ModifyDcdnWafGroupRequest): Promise<ModifyDcdnWafGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDcdnWafGroupWithOptions(request, runtime);
  }

  /**
   * Changes the name or the status of a protection policy.
   * 
   * @remarks
   *   You can call this operation up to 20 times per second per account.
   * *   Alibaba Cloud Dynamic Content Delivery Network (DCDN) supports POST requests.
   * 
   * @param request - ModifyDcdnWafPolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyDcdnWafPolicyResponse
   */
  async modifyDcdnWafPolicyWithOptions(request: ModifyDcdnWafPolicyRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDcdnWafPolicyResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.policyId)) {
      body["PolicyId"] = request.policyId;
    }

    if (!Util.isUnset(request.policyName)) {
      body["PolicyName"] = request.policyName;
    }

    if (!Util.isUnset(request.policyStatus)) {
      body["PolicyStatus"] = request.policyStatus;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyDcdnWafPolicy",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyDcdnWafPolicyResponse>(await this.callApi(params, req, runtime), new ModifyDcdnWafPolicyResponse({}));
  }

  /**
   * Changes the name or the status of a protection policy.
   * 
   * @remarks
   *   You can call this operation up to 20 times per second per account.
   * *   Alibaba Cloud Dynamic Content Delivery Network (DCDN) supports POST requests.
   * 
   * @param request - ModifyDcdnWafPolicyRequest
   * @returns ModifyDcdnWafPolicyResponse
   */
  async modifyDcdnWafPolicy(request: ModifyDcdnWafPolicyRequest): Promise<ModifyDcdnWafPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDcdnWafPolicyWithOptions(request, runtime);
  }

  /**
   * Changes the accelerated domain names that are bound to a protection policy.
   * 
   * @remarks
   * # Usage notes
   * *   You can call this operation up to 20 times per second per account.
   * *   Alibaba Cloud Dynamic Route for CDN (DCDN) supports POST requests.
   * 
   * @param request - ModifyDcdnWafPolicyDomainsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyDcdnWafPolicyDomainsResponse
   */
  async modifyDcdnWafPolicyDomainsWithOptions(request: ModifyDcdnWafPolicyDomainsRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDcdnWafPolicyDomainsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bindDomains)) {
      body["BindDomains"] = request.bindDomains;
    }

    if (!Util.isUnset(request.method)) {
      body["Method"] = request.method;
    }

    if (!Util.isUnset(request.policyId)) {
      body["PolicyId"] = request.policyId;
    }

    if (!Util.isUnset(request.unbindDomains)) {
      body["UnbindDomains"] = request.unbindDomains;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyDcdnWafPolicyDomains",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyDcdnWafPolicyDomainsResponse>(await this.callApi(params, req, runtime), new ModifyDcdnWafPolicyDomainsResponse({}));
  }

  /**
   * Changes the accelerated domain names that are bound to a protection policy.
   * 
   * @remarks
   * # Usage notes
   * *   You can call this operation up to 20 times per second per account.
   * *   Alibaba Cloud Dynamic Route for CDN (DCDN) supports POST requests.
   * 
   * @param request - ModifyDcdnWafPolicyDomainsRequest
   * @returns ModifyDcdnWafPolicyDomainsResponse
   */
  async modifyDcdnWafPolicyDomains(request: ModifyDcdnWafPolicyDomainsRequest): Promise<ModifyDcdnWafPolicyDomainsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDcdnWafPolicyDomainsWithOptions(request, runtime);
  }

  /**
   * Changes the name, status, or configurations of a protection rule.
   * 
   * @remarks
   *   You can call this operation up to 20 times per second per account.
   * *   Alibaba Cloud Dynamic Content Delivery Network (DCDN) supports POST requests.
   * *   You must configure at least one of the **RuleStatus**, **RuleName** and **RuleConfig** parameters.
   * 
   * @param request - ModifyDcdnWafRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ModifyDcdnWafRuleResponse
   */
  async modifyDcdnWafRuleWithOptions(request: ModifyDcdnWafRuleRequest, runtime: $Util.RuntimeOptions): Promise<ModifyDcdnWafRuleResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.ruleConfig)) {
      body["RuleConfig"] = request.ruleConfig;
    }

    if (!Util.isUnset(request.ruleId)) {
      body["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.ruleName)) {
      body["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.ruleStatus)) {
      body["RuleStatus"] = request.ruleStatus;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyDcdnWafRule",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyDcdnWafRuleResponse>(await this.callApi(params, req, runtime), new ModifyDcdnWafRuleResponse({}));
  }

  /**
   * Changes the name, status, or configurations of a protection rule.
   * 
   * @remarks
   *   You can call this operation up to 20 times per second per account.
   * *   Alibaba Cloud Dynamic Content Delivery Network (DCDN) supports POST requests.
   * *   You must configure at least one of the **RuleStatus**, **RuleName** and **RuleConfig** parameters.
   * 
   * @param request - ModifyDcdnWafRuleRequest
   * @returns ModifyDcdnWafRuleResponse
   */
  async modifyDcdnWafRule(request: ModifyDcdnWafRuleRequest): Promise<ModifyDcdnWafRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyDcdnWafRuleWithOptions(request, runtime);
  }

  /**
   * Activates Dynamic Route for CDN (DCDN).
   * 
   * @remarks
   * > 
   * *   DCDN can be activated only once per Alibaba Cloud account. The Alibaba Cloud account must pass real-name verification.
   * *   You can call this operation up to five times per second per user.
   * 
   * @param request - OpenDcdnServiceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns OpenDcdnServiceResponse
   */
  async openDcdnServiceWithOptions(request: OpenDcdnServiceRequest, runtime: $Util.RuntimeOptions): Promise<OpenDcdnServiceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.billType)) {
      query["BillType"] = request.billType;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.websocketBillType)) {
      query["WebsocketBillType"] = request.websocketBillType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "OpenDcdnService",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<OpenDcdnServiceResponse>(await this.callApi(params, req, runtime), new OpenDcdnServiceResponse({}));
  }

  /**
   * Activates Dynamic Route for CDN (DCDN).
   * 
   * @remarks
   * > 
   * *   DCDN can be activated only once per Alibaba Cloud account. The Alibaba Cloud account must pass real-name verification.
   * *   You can call this operation up to five times per second per user.
   * 
   * @param request - OpenDcdnServiceRequest
   * @returns OpenDcdnServiceResponse
   */
  async openDcdnService(request: OpenDcdnServiceRequest): Promise<OpenDcdnServiceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.openDcdnServiceWithOptions(request, runtime);
  }

  /**
   * Prefetches content from origin servers to points of presence (POPs). This reduces workloads on origin servers because users can hit cache upon their first visits.
   * 
   * @remarks
   *   You can call the [RefreshDcdnObjectCaches](https://help.aliyun.com/document_detail/130620.html) operation to refresh content and call the [PreloadDcdnObjectCaches](https://help.aliyun.com/document_detail/130636.html) operation to prefetch content.
   * *   Dynamic Content Delivery Network (DCDN) supports POST requests in which parameters are sent as a form.
   * *   By default, each Alibaba Cloud account can submit up to 1,000 URLs per day. If the daily peak bandwidth value of your workloads exceeds 200 Mbit/s, you can [submit a ticket](https://account.alibabacloud.com/login/login.htm?oauth_callback=https%3A//ticket-intl.console.aliyun.com/%23/ticket/createIndex) to increase your daily quota. Alibaba Cloud reviews your application and then increases the quota accordingly.
   * *   You can specify up to 100 URLs to prefetch.
   * *   The prefetch queue of each Alibaba Cloud account can contain up to 100,000 URLs. DCDN executes prefetch tasks based on the time at which you submit the URLs.
   * *   You can call this operation up to 15 times per second per account.
   * ## Description
   * *   After a refresh task is submitted and completed, the POPs immediately start to retrieve resources from the origin server. Therefore, a large number of refresh tasks cause a large number of concurrent download tasks. This increases the number of requests that are redirected to the origin server. The back-to-origin routing process consumes more bandwidth resources and the origin server may be overwhelmed.
   * *   The time required for a prefetch task to complete is proportional to the size of the prefetched file. In actual practice, most prefetch tasks require 5 to 30 minutes to complete. A task with a smaller average file size requires less time.
   * *   To allow RAM users to perform this operation, you need to first grant them the required permissions. For more information, see [Authorize a RAM user to prefetch and refresh resources](https://help.aliyun.com/document_detail/445051.html).
   * 
   * @param request - PreloadDcdnObjectCachesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PreloadDcdnObjectCachesResponse
   */
  async preloadDcdnObjectCachesWithOptions(request: PreloadDcdnObjectCachesRequest, runtime: $Util.RuntimeOptions): Promise<PreloadDcdnObjectCachesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.area)) {
      query["Area"] = request.area;
    }

    if (!Util.isUnset(request.l2Preload)) {
      query["L2Preload"] = request.l2Preload;
    }

    if (!Util.isUnset(request.objectPath)) {
      query["ObjectPath"] = request.objectPath;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.withHeader)) {
      query["WithHeader"] = request.withHeader;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PreloadDcdnObjectCaches",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PreloadDcdnObjectCachesResponse>(await this.callApi(params, req, runtime), new PreloadDcdnObjectCachesResponse({}));
  }

  /**
   * Prefetches content from origin servers to points of presence (POPs). This reduces workloads on origin servers because users can hit cache upon their first visits.
   * 
   * @remarks
   *   You can call the [RefreshDcdnObjectCaches](https://help.aliyun.com/document_detail/130620.html) operation to refresh content and call the [PreloadDcdnObjectCaches](https://help.aliyun.com/document_detail/130636.html) operation to prefetch content.
   * *   Dynamic Content Delivery Network (DCDN) supports POST requests in which parameters are sent as a form.
   * *   By default, each Alibaba Cloud account can submit up to 1,000 URLs per day. If the daily peak bandwidth value of your workloads exceeds 200 Mbit/s, you can [submit a ticket](https://account.alibabacloud.com/login/login.htm?oauth_callback=https%3A//ticket-intl.console.aliyun.com/%23/ticket/createIndex) to increase your daily quota. Alibaba Cloud reviews your application and then increases the quota accordingly.
   * *   You can specify up to 100 URLs to prefetch.
   * *   The prefetch queue of each Alibaba Cloud account can contain up to 100,000 URLs. DCDN executes prefetch tasks based on the time at which you submit the URLs.
   * *   You can call this operation up to 15 times per second per account.
   * ## Description
   * *   After a refresh task is submitted and completed, the POPs immediately start to retrieve resources from the origin server. Therefore, a large number of refresh tasks cause a large number of concurrent download tasks. This increases the number of requests that are redirected to the origin server. The back-to-origin routing process consumes more bandwidth resources and the origin server may be overwhelmed.
   * *   The time required for a prefetch task to complete is proportional to the size of the prefetched file. In actual practice, most prefetch tasks require 5 to 30 minutes to complete. A task with a smaller average file size requires less time.
   * *   To allow RAM users to perform this operation, you need to first grant them the required permissions. For more information, see [Authorize a RAM user to prefetch and refresh resources](https://help.aliyun.com/document_detail/445051.html).
   * 
   * @param request - PreloadDcdnObjectCachesRequest
   * @returns PreloadDcdnObjectCachesResponse
   */
  async preloadDcdnObjectCaches(request: PreloadDcdnObjectCachesRequest): Promise<PreloadDcdnObjectCachesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.preloadDcdnObjectCachesWithOptions(request, runtime);
  }

  /**
   * Publishes the configurations of an accelerated domain name from the staging environment to the production environment.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - PublishDcdnStagingConfigToProductionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PublishDcdnStagingConfigToProductionResponse
   */
  async publishDcdnStagingConfigToProductionWithOptions(request: PublishDcdnStagingConfigToProductionRequest, runtime: $Util.RuntimeOptions): Promise<PublishDcdnStagingConfigToProductionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.functionName)) {
      query["FunctionName"] = request.functionName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PublishDcdnStagingConfigToProduction",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PublishDcdnStagingConfigToProductionResponse>(await this.callApi(params, req, runtime), new PublishDcdnStagingConfigToProductionResponse({}));
  }

  /**
   * Publishes the configurations of an accelerated domain name from the staging environment to the production environment.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - PublishDcdnStagingConfigToProductionRequest
   * @returns PublishDcdnStagingConfigToProductionResponse
   */
  async publishDcdnStagingConfigToProduction(request: PublishDcdnStagingConfigToProductionRequest): Promise<PublishDcdnStagingConfigToProductionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.publishDcdnStagingConfigToProductionWithOptions(request, runtime);
  }

  /**
   * Publishes a specified version of routine code to an environment.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param tmpReq - PublishRoutineCodeRevisionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PublishRoutineCodeRevisionResponse
   */
  async publishRoutineCodeRevisionWithOptions(tmpReq: PublishRoutineCodeRevisionRequest, runtime: $Util.RuntimeOptions): Promise<PublishRoutineCodeRevisionResponse> {
    Util.validateModel(tmpReq);
    let request = new PublishRoutineCodeRevisionShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.envs)) {
      request.envsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.envs, "Envs", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.envsShrink)) {
      body["Envs"] = request.envsShrink;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.selectCodeRevision)) {
      body["SelectCodeRevision"] = request.selectCodeRevision;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "PublishRoutineCodeRevision",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PublishRoutineCodeRevisionResponse>(await this.callApi(params, req, runtime), new PublishRoutineCodeRevisionResponse({}));
  }

  /**
   * Publishes a specified version of routine code to an environment.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - PublishRoutineCodeRevisionRequest
   * @returns PublishRoutineCodeRevisionResponse
   */
  async publishRoutineCodeRevision(request: PublishRoutineCodeRevisionRequest): Promise<PublishRoutineCodeRevisionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.publishRoutineCodeRevisionWithOptions(request, runtime);
  }

  /**
   * Sets key-value pairs in a namespace.
   * 
   * @param request - PutDcdnKvRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PutDcdnKvResponse
   */
  async putDcdnKvWithOptions(request: PutDcdnKvRequest, runtime: $Util.RuntimeOptions): Promise<PutDcdnKvResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.expiration)) {
      query["Expiration"] = request.expiration;
    }

    if (!Util.isUnset(request.expirationTtl)) {
      query["ExpirationTtl"] = request.expirationTtl;
    }

    if (!Util.isUnset(request.key)) {
      query["Key"] = request.key;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.value)) {
      body["Value"] = request.value;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "PutDcdnKv",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PutDcdnKvResponse>(await this.callApi(params, req, runtime), new PutDcdnKvResponse({}));
  }

  /**
   * Sets key-value pairs in a namespace.
   * 
   * @param request - PutDcdnKvRequest
   * @returns PutDcdnKvResponse
   */
  async putDcdnKv(request: PutDcdnKvRequest): Promise<PutDcdnKvResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.putDcdnKvWithOptions(request, runtime);
  }

  /**
   * Adds namespaces to your account.
   * 
   * @param request - PutDcdnKvNamespaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PutDcdnKvNamespaceResponse
   */
  async putDcdnKvNamespaceWithOptions(request: PutDcdnKvNamespaceRequest, runtime: $Util.RuntimeOptions): Promise<PutDcdnKvNamespaceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.namespace)) {
      body["Namespace"] = request.namespace;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "PutDcdnKvNamespace",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PutDcdnKvNamespaceResponse>(await this.callApi(params, req, runtime), new PutDcdnKvNamespaceResponse({}));
  }

  /**
   * Adds namespaces to your account.
   * 
   * @param request - PutDcdnKvNamespaceRequest
   * @returns PutDcdnKvNamespaceResponse
   */
  async putDcdnKvNamespace(request: PutDcdnKvNamespaceRequest): Promise<PutDcdnKvNamespaceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.putDcdnKvNamespaceWithOptions(request, runtime);
  }

  /**
   * 设置Namespace的key-value对，支持最大25M的请求体
   * 
   * @param request - PutDcdnKvWithHighCapacityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PutDcdnKvWithHighCapacityResponse
   */
  async putDcdnKvWithHighCapacityWithOptions(request: PutDcdnKvWithHighCapacityRequest, runtime: $Util.RuntimeOptions): Promise<PutDcdnKvWithHighCapacityResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.key)) {
      query["Key"] = request.key;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.url)) {
      query["Url"] = request.url;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PutDcdnKvWithHighCapacity",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PutDcdnKvWithHighCapacityResponse>(await this.callApi(params, req, runtime), new PutDcdnKvWithHighCapacityResponse({}));
  }

  /**
   * 设置Namespace的key-value对，支持最大25M的请求体
   * 
   * @param request - PutDcdnKvWithHighCapacityRequest
   * @returns PutDcdnKvWithHighCapacityResponse
   */
  async putDcdnKvWithHighCapacity(request: PutDcdnKvWithHighCapacityRequest): Promise<PutDcdnKvWithHighCapacityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.putDcdnKvWithHighCapacityWithOptions(request, runtime);
  }

  /**
   * 指定缓存tag刷新节点上的文件内容
   * 
   * @param request - RefreshDcdnObjectCacheByCacheTagRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RefreshDcdnObjectCacheByCacheTagResponse
   */
  async refreshDcdnObjectCacheByCacheTagWithOptions(request: RefreshDcdnObjectCacheByCacheTagRequest, runtime: $Util.RuntimeOptions): Promise<RefreshDcdnObjectCacheByCacheTagResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.cacheTag)) {
      query["CacheTag"] = request.cacheTag;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.force)) {
      query["Force"] = request.force;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RefreshDcdnObjectCacheByCacheTag",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RefreshDcdnObjectCacheByCacheTagResponse>(await this.callApi(params, req, runtime), new RefreshDcdnObjectCacheByCacheTagResponse({}));
  }

  /**
   * 指定缓存tag刷新节点上的文件内容
   * 
   * @param request - RefreshDcdnObjectCacheByCacheTagRequest
   * @returns RefreshDcdnObjectCacheByCacheTagResponse
   */
  async refreshDcdnObjectCacheByCacheTag(request: RefreshDcdnObjectCacheByCacheTagRequest): Promise<RefreshDcdnObjectCacheByCacheTagResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.refreshDcdnObjectCacheByCacheTagWithOptions(request, runtime);
  }

  /**
   * Refreshes specified objects on points of presence (POPs). The objects can be included in the content of files or URLs. You can refresh multiple URLs in each request.
   * 
   * @remarks
   *   Dynamic Content Delivery Network (DCDN) supports POST requests in which parameters are sent as a form.
   * *   You can call the [RefreshDcdnObjectCaches](https://help.aliyun.com/document_detail/130620.html) operation to purge content and call the [PreloadDcdnObjectCaches](https://help.aliyun.com/document_detail/130636.html) operation to prefetch content.
   * *   By default, each Alibaba Cloud account can purge content from a maximum of 10,000 URLs and 100 directories including subdirectories per day. If the daily peak bandwidth of your Alibaba Cloud account exceeds 200 Mbit/s, [submit a ticket](https://account.alibabacloud.com/login/login.htm?oauth_callback=https%3A//ticket-intl.console.aliyun.com/%23/ticket/createIndex) to request a quota increase. Alibaba Cloud determines whether to approve your application based on your workloads.
   * *   You can specify up to 1,000 URLs or 100 directories that you want to purge in each request.
   * *   You can specify up to 1,000 URLs that you want to purge per minute for each domain name.
   * *   You can call this operation up to 30 times per second per account.
   * #### [](#)Precautions
   * *   After a purge task is completed, your resources that are cached on points of presence (POPs) are removed. When a POP receives a request for your resources, the request is redirected to the origin server to retrieve the resources. Then, the resources are returned to the client and cached on POPs. If you frequently run purge tasks, more requests are redirected to the origin server for resources. This results in high bandwidth costs and more loads on the origin server.
   * *   A purge task takes effect 5 to 6 minutes after being submitted. If the resource you want to purge has a TTL of less than 5 minutes, you wait for it to expire instead of manually running a purge task.
   * *   To allow RAM users to perform this operation, you need to first grant them the required permissions. For more information, see [Authorize a RAM user to prefetch and refresh resources](https://help.aliyun.com/document_detail/445051.html).
   * 
   * @param request - RefreshDcdnObjectCachesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RefreshDcdnObjectCachesResponse
   */
  async refreshDcdnObjectCachesWithOptions(request: RefreshDcdnObjectCachesRequest, runtime: $Util.RuntimeOptions): Promise<RefreshDcdnObjectCachesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.force)) {
      query["Force"] = request.force;
    }

    if (!Util.isUnset(request.objectPath)) {
      query["ObjectPath"] = request.objectPath;
    }

    if (!Util.isUnset(request.objectType)) {
      query["ObjectType"] = request.objectType;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RefreshDcdnObjectCaches",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RefreshDcdnObjectCachesResponse>(await this.callApi(params, req, runtime), new RefreshDcdnObjectCachesResponse({}));
  }

  /**
   * Refreshes specified objects on points of presence (POPs). The objects can be included in the content of files or URLs. You can refresh multiple URLs in each request.
   * 
   * @remarks
   *   Dynamic Content Delivery Network (DCDN) supports POST requests in which parameters are sent as a form.
   * *   You can call the [RefreshDcdnObjectCaches](https://help.aliyun.com/document_detail/130620.html) operation to purge content and call the [PreloadDcdnObjectCaches](https://help.aliyun.com/document_detail/130636.html) operation to prefetch content.
   * *   By default, each Alibaba Cloud account can purge content from a maximum of 10,000 URLs and 100 directories including subdirectories per day. If the daily peak bandwidth of your Alibaba Cloud account exceeds 200 Mbit/s, [submit a ticket](https://account.alibabacloud.com/login/login.htm?oauth_callback=https%3A//ticket-intl.console.aliyun.com/%23/ticket/createIndex) to request a quota increase. Alibaba Cloud determines whether to approve your application based on your workloads.
   * *   You can specify up to 1,000 URLs or 100 directories that you want to purge in each request.
   * *   You can specify up to 1,000 URLs that you want to purge per minute for each domain name.
   * *   You can call this operation up to 30 times per second per account.
   * #### [](#)Precautions
   * *   After a purge task is completed, your resources that are cached on points of presence (POPs) are removed. When a POP receives a request for your resources, the request is redirected to the origin server to retrieve the resources. Then, the resources are returned to the client and cached on POPs. If you frequently run purge tasks, more requests are redirected to the origin server for resources. This results in high bandwidth costs and more loads on the origin server.
   * *   A purge task takes effect 5 to 6 minutes after being submitted. If the resource you want to purge has a TTL of less than 5 minutes, you wait for it to expire instead of manually running a purge task.
   * *   To allow RAM users to perform this operation, you need to first grant them the required permissions. For more information, see [Authorize a RAM user to prefetch and refresh resources](https://help.aliyun.com/document_detail/445051.html).
   * 
   * @param request - RefreshDcdnObjectCachesRequest
   * @returns RefreshDcdnObjectCachesResponse
   */
  async refreshDcdnObjectCaches(request: RefreshDcdnObjectCachesRequest): Promise<RefreshDcdnObjectCachesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.refreshDcdnObjectCachesWithOptions(request, runtime);
  }

  /**
   * Refreshes the cache that is written by calling the cache operation of EdgeRoutine. You can refresh multiple URLs in each request.
   * 
   * @remarks
   * > *   Dynamic Content Delivery Network (DCDN) supports POST requests in which parameters are sent as a form.
   * > *   Related operation: [RefreshDcdnObjectCaches](https://help.aliyun.com/document_detail/130620.html).
   * > *   By default, each Alibaba Cloud account can purge content from a maxim> um of 10,000 URLs and 100 directories including subdirectories per day.
   * > *   You can specify up to 1,000 URLs or 100 directories that you want to purge in each request.
   * > *   You can specify up to 1,000 URLs that you want to purge per minute for each domain name.
   * > *   You can call this operation up to 30 times per second per account.
   * 
   * @param request - RefreshErObjectCachesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RefreshErObjectCachesResponse
   */
  async refreshErObjectCachesWithOptions(request: RefreshErObjectCachesRequest, runtime: $Util.RuntimeOptions): Promise<RefreshErObjectCachesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.force)) {
      query["Force"] = request.force;
    }

    if (!Util.isUnset(request.mergeDomainName)) {
      query["MergeDomainName"] = request.mergeDomainName;
    }

    if (!Util.isUnset(request.objectPath)) {
      query["ObjectPath"] = request.objectPath;
    }

    if (!Util.isUnset(request.objectType)) {
      query["ObjectType"] = request.objectType;
    }

    if (!Util.isUnset(request.routineId)) {
      query["RoutineId"] = request.routineId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RefreshErObjectCaches",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RefreshErObjectCachesResponse>(await this.callApi(params, req, runtime), new RefreshErObjectCachesResponse({}));
  }

  /**
   * Refreshes the cache that is written by calling the cache operation of EdgeRoutine. You can refresh multiple URLs in each request.
   * 
   * @remarks
   * > *   Dynamic Content Delivery Network (DCDN) supports POST requests in which parameters are sent as a form.
   * > *   Related operation: [RefreshDcdnObjectCaches](https://help.aliyun.com/document_detail/130620.html).
   * > *   By default, each Alibaba Cloud account can purge content from a maxim> um of 10,000 URLs and 100 directories including subdirectories per day.
   * > *   You can specify up to 1,000 URLs or 100 directories that you want to purge in each request.
   * > *   You can specify up to 1,000 URLs that you want to purge per minute for each domain name.
   * > *   You can call this operation up to 30 times per second per account.
   * 
   * @param request - RefreshErObjectCachesRequest
   * @returns RefreshErObjectCachesResponse
   */
  async refreshErObjectCaches(request: RefreshErObjectCachesRequest): Promise<RefreshErObjectCachesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.refreshErObjectCachesWithOptions(request, runtime);
  }

  /**
   * Rolls back the configurations of an accelerated domain name from the staging environment to the production environment.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - RollbackDcdnStagingConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RollbackDcdnStagingConfigResponse
   */
  async rollbackDcdnStagingConfigWithOptions(request: RollbackDcdnStagingConfigRequest, runtime: $Util.RuntimeOptions): Promise<RollbackDcdnStagingConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RollbackDcdnStagingConfig",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RollbackDcdnStagingConfigResponse>(await this.callApi(params, req, runtime), new RollbackDcdnStagingConfigResponse({}));
  }

  /**
   * Rolls back the configurations of an accelerated domain name from the staging environment to the production environment.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - RollbackDcdnStagingConfigRequest
   * @returns RollbackDcdnStagingConfigResponse
   */
  async rollbackDcdnStagingConfig(request: RollbackDcdnStagingConfigRequest): Promise<RollbackDcdnStagingConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.rollbackDcdnStagingConfigWithOptions(request, runtime);
  }

  /**
   * Configures an SSL certificate for a specified domain name.
   * 
   * @param request - SetDcdnDomainCSRCertificateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetDcdnDomainCSRCertificateResponse
   */
  async setDcdnDomainCSRCertificateWithOptions(request: SetDcdnDomainCSRCertificateRequest, runtime: $Util.RuntimeOptions): Promise<SetDcdnDomainCSRCertificateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.serverCertificate)) {
      query["ServerCertificate"] = request.serverCertificate;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetDcdnDomainCSRCertificate",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetDcdnDomainCSRCertificateResponse>(await this.callApi(params, req, runtime), new SetDcdnDomainCSRCertificateResponse({}));
  }

  /**
   * Configures an SSL certificate for a specified domain name.
   * 
   * @param request - SetDcdnDomainCSRCertificateRequest
   * @returns SetDcdnDomainCSRCertificateResponse
   */
  async setDcdnDomainCSRCertificate(request: SetDcdnDomainCSRCertificateRequest): Promise<SetDcdnDomainCSRCertificateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDcdnDomainCSRCertificateWithOptions(request, runtime);
  }

  /**
   * Enables or disables the SSL certificate for a domain name and modifies certificate details.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @deprecated OpenAPI SetDcdnDomainCertificate is deprecated, please use dcdn::2018-01-15::SetDcdnDomainSSLCertificate instead.
   * 
   * @param request - SetDcdnDomainCertificateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetDcdnDomainCertificateResponse
   */
  // Deprecated
  async setDcdnDomainCertificateWithOptions(request: SetDcdnDomainCertificateRequest, runtime: $Util.RuntimeOptions): Promise<SetDcdnDomainCertificateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.certName)) {
      query["CertName"] = request.certName;
    }

    if (!Util.isUnset(request.certType)) {
      query["CertType"] = request.certType;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.forceSet)) {
      query["ForceSet"] = request.forceSet;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.SSLPri)) {
      query["SSLPri"] = request.SSLPri;
    }

    if (!Util.isUnset(request.SSLProtocol)) {
      query["SSLProtocol"] = request.SSLProtocol;
    }

    if (!Util.isUnset(request.SSLPub)) {
      query["SSLPub"] = request.SSLPub;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetDcdnDomainCertificate",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetDcdnDomainCertificateResponse>(await this.callApi(params, req, runtime), new SetDcdnDomainCertificateResponse({}));
  }

  /**
   * Enables or disables the SSL certificate for a domain name and modifies certificate details.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @deprecated OpenAPI SetDcdnDomainCertificate is deprecated, please use dcdn::2018-01-15::SetDcdnDomainSSLCertificate instead.
   * 
   * @param request - SetDcdnDomainCertificateRequest
   * @returns SetDcdnDomainCertificateResponse
   */
  // Deprecated
  async setDcdnDomainCertificate(request: SetDcdnDomainCertificateRequest): Promise<SetDcdnDomainCertificateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDcdnDomainCertificateWithOptions(request, runtime);
  }

  /**
   * Enables or disables the ShangMi (SM) certificate for a domain name.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - SetDcdnDomainSMCertificateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetDcdnDomainSMCertificateResponse
   */
  async setDcdnDomainSMCertificateWithOptions(request: SetDcdnDomainSMCertificateRequest, runtime: $Util.RuntimeOptions): Promise<SetDcdnDomainSMCertificateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.certIdentifier)) {
      query["CertIdentifier"] = request.certIdentifier;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.SSLProtocol)) {
      query["SSLProtocol"] = request.SSLProtocol;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetDcdnDomainSMCertificate",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetDcdnDomainSMCertificateResponse>(await this.callApi(params, req, runtime), new SetDcdnDomainSMCertificateResponse({}));
  }

  /**
   * Enables or disables the ShangMi (SM) certificate for a domain name.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - SetDcdnDomainSMCertificateRequest
   * @returns SetDcdnDomainSMCertificateResponse
   */
  async setDcdnDomainSMCertificate(request: SetDcdnDomainSMCertificateRequest): Promise<SetDcdnDomainSMCertificateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDcdnDomainSMCertificateWithOptions(request, runtime);
  }

  /**
   * Enables or disables the SSL certificate for a domain name and updates certificate details.
   * 
   * @param request - SetDcdnDomainSSLCertificateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetDcdnDomainSSLCertificateResponse
   */
  async setDcdnDomainSSLCertificateWithOptions(request: SetDcdnDomainSSLCertificateRequest, runtime: $Util.RuntimeOptions): Promise<SetDcdnDomainSSLCertificateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.certId)) {
      query["CertId"] = request.certId;
    }

    if (!Util.isUnset(request.certName)) {
      query["CertName"] = request.certName;
    }

    if (!Util.isUnset(request.certRegion)) {
      query["CertRegion"] = request.certRegion;
    }

    if (!Util.isUnset(request.certType)) {
      query["CertType"] = request.certType;
    }

    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.env)) {
      query["Env"] = request.env;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.SSLPri)) {
      query["SSLPri"] = request.SSLPri;
    }

    if (!Util.isUnset(request.SSLProtocol)) {
      query["SSLProtocol"] = request.SSLProtocol;
    }

    if (!Util.isUnset(request.SSLPub)) {
      query["SSLPub"] = request.SSLPub;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetDcdnDomainSSLCertificate",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetDcdnDomainSSLCertificateResponse>(await this.callApi(params, req, runtime), new SetDcdnDomainSSLCertificateResponse({}));
  }

  /**
   * Enables or disables the SSL certificate for a domain name and updates certificate details.
   * 
   * @param request - SetDcdnDomainSSLCertificateRequest
   * @returns SetDcdnDomainSSLCertificateResponse
   */
  async setDcdnDomainSSLCertificate(request: SetDcdnDomainSSLCertificateRequest): Promise<SetDcdnDomainSSLCertificateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDcdnDomainSSLCertificateWithOptions(request, runtime);
  }

  /**
   * Sets or modifies the domain name configuration in the canary release environment.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - SetDcdnDomainStagingConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetDcdnDomainStagingConfigResponse
   */
  async setDcdnDomainStagingConfigWithOptions(request: SetDcdnDomainStagingConfigRequest, runtime: $Util.RuntimeOptions): Promise<SetDcdnDomainStagingConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.functions)) {
      query["Functions"] = request.functions;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetDcdnDomainStagingConfig",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetDcdnDomainStagingConfigResponse>(await this.callApi(params, req, runtime), new SetDcdnDomainStagingConfigResponse({}));
  }

  /**
   * Sets or modifies the domain name configuration in the canary release environment.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - SetDcdnDomainStagingConfigRequest
   * @returns SetDcdnDomainStagingConfigResponse
   */
  async setDcdnDomainStagingConfig(request: SetDcdnDomainStagingConfigRequest): Promise<SetDcdnDomainStagingConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDcdnDomainStagingConfigWithOptions(request, runtime);
  }

  /**
   * Blocks or unblocks IP addresses or CIDR blocks.
   * 
   * @remarks
   * >  You can call this operation to block or unblock a large number of IP addresses or CIDR blocks. You can block or unblock up to 1,000 IP addresses or CIDR blocks in a request.
   * 
   * @param request - SetDcdnFullDomainsBlockIPRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetDcdnFullDomainsBlockIPResponse
   */
  async setDcdnFullDomainsBlockIPWithOptions(request: SetDcdnFullDomainsBlockIPRequest, runtime: $Util.RuntimeOptions): Promise<SetDcdnFullDomainsBlockIPResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.blockInterval)) {
      body["BlockInterval"] = request.blockInterval;
    }

    if (!Util.isUnset(request.IPList)) {
      body["IPList"] = request.IPList;
    }

    if (!Util.isUnset(request.operationType)) {
      body["OperationType"] = request.operationType;
    }

    if (!Util.isUnset(request.updateType)) {
      body["UpdateType"] = request.updateType;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SetDcdnFullDomainsBlockIP",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetDcdnFullDomainsBlockIPResponse>(await this.callApi(params, req, runtime), new SetDcdnFullDomainsBlockIPResponse({}));
  }

  /**
   * Blocks or unblocks IP addresses or CIDR blocks.
   * 
   * @remarks
   * >  You can call this operation to block or unblock a large number of IP addresses or CIDR blocks. You can block or unblock up to 1,000 IP addresses or CIDR blocks in a request.
   * 
   * @param request - SetDcdnFullDomainsBlockIPRequest
   * @returns SetDcdnFullDomainsBlockIPResponse
   */
  async setDcdnFullDomainsBlockIP(request: SetDcdnFullDomainsBlockIPRequest): Promise<SetDcdnFullDomainsBlockIPResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDcdnFullDomainsBlockIPWithOptions(request, runtime);
  }

  /**
   * Configures features for a user.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - SetDcdnUserConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetDcdnUserConfigResponse
   */
  async setDcdnUserConfigWithOptions(request: SetDcdnUserConfigRequest, runtime: $Util.RuntimeOptions): Promise<SetDcdnUserConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.configs)) {
      query["Configs"] = request.configs;
    }

    if (!Util.isUnset(request.functionId)) {
      query["FunctionId"] = request.functionId;
    }

    if (!Util.isUnset(request.ownerAccount)) {
      query["OwnerAccount"] = request.ownerAccount;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetDcdnUserConfig",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetDcdnUserConfigResponse>(await this.callApi(params, req, runtime), new SetDcdnUserConfigResponse({}));
  }

  /**
   * Configures features for a user.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - SetDcdnUserConfigRequest
   * @returns SetDcdnUserConfigResponse
   */
  async setDcdnUserConfig(request: SetDcdnUserConfigRequest): Promise<SetDcdnUserConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDcdnUserConfigWithOptions(request, runtime);
  }

  /**
   * Configures a subdomain for a routine.
   * 
   * @remarks
   * > 
   * *   Each subdomain is globally unique. Resource Access Management (RAM) users cannot create duplicate subdomains.
   * *   You can call this operation up to 100 times per second per account.
   * 
   * @param tmpReq - SetRoutineSubdomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetRoutineSubdomainResponse
   */
  async setRoutineSubdomainWithOptions(tmpReq: SetRoutineSubdomainRequest, runtime: $Util.RuntimeOptions): Promise<SetRoutineSubdomainResponse> {
    Util.validateModel(tmpReq);
    let request = new SetRoutineSubdomainShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.subdomains)) {
      request.subdomainsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.subdomains, "Subdomains", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.subdomainsShrink)) {
      body["Subdomains"] = request.subdomainsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SetRoutineSubdomain",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetRoutineSubdomainResponse>(await this.callApi(params, req, runtime), new SetRoutineSubdomainResponse({}));
  }

  /**
   * Configures a subdomain for a routine.
   * 
   * @remarks
   * > 
   * *   Each subdomain is globally unique. Resource Access Management (RAM) users cannot create duplicate subdomains.
   * *   You can call this operation up to 100 times per second per account.
   * 
   * @param request - SetRoutineSubdomainRequest
   * @returns SetRoutineSubdomainResponse
   */
  async setRoutineSubdomain(request: SetRoutineSubdomainRequest): Promise<SetRoutineSubdomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setRoutineSubdomainWithOptions(request, runtime);
  }

  /**
   * Enables a specified disabled accelerated domain. After the accelerated domain is enabled, the value of the DomainStatus parameter changes to Online for the domain.
   * 
   * @remarks
   * > 
   * *   If an accelerated domain name is in invalid state or your account has an overdue payment, the accelerated domain name cannot be enabled.
   * *   You can call this operation up to 30 times per second per account.
   * 
   * @param request - StartDcdnDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StartDcdnDomainResponse
   */
  async startDcdnDomainWithOptions(request: StartDcdnDomainRequest, runtime: $Util.RuntimeOptions): Promise<StartDcdnDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StartDcdnDomain",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StartDcdnDomainResponse>(await this.callApi(params, req, runtime), new StartDcdnDomainResponse({}));
  }

  /**
   * Enables a specified disabled accelerated domain. After the accelerated domain is enabled, the value of the DomainStatus parameter changes to Online for the domain.
   * 
   * @remarks
   * > 
   * *   If an accelerated domain name is in invalid state or your account has an overdue payment, the accelerated domain name cannot be enabled.
   * *   You can call this operation up to 30 times per second per account.
   * 
   * @param request - StartDcdnDomainRequest
   * @returns StartDcdnDomainResponse
   */
  async startDcdnDomain(request: StartDcdnDomainRequest): Promise<StartDcdnDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startDcdnDomainWithOptions(request, runtime);
  }

  /**
   * Enables one or more accelerated domain names. After the accelerated domain names are enabled, the value of the DomainStatus parameter for the domain names changes to Online.
   * 
   * @remarks
   *   If an accelerated domain name is in invalid state or your account has an overdue payment, the accelerated domain name cannot be enabled.
   * *   You can call this operation up to 20 times per second per account.
   * 
   * @param request - StartDcdnIpaDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StartDcdnIpaDomainResponse
   */
  async startDcdnIpaDomainWithOptions(request: StartDcdnIpaDomainRequest, runtime: $Util.RuntimeOptions): Promise<StartDcdnIpaDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StartDcdnIpaDomain",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StartDcdnIpaDomainResponse>(await this.callApi(params, req, runtime), new StartDcdnIpaDomainResponse({}));
  }

  /**
   * Enables one or more accelerated domain names. After the accelerated domain names are enabled, the value of the DomainStatus parameter for the domain names changes to Online.
   * 
   * @remarks
   *   If an accelerated domain name is in invalid state or your account has an overdue payment, the accelerated domain name cannot be enabled.
   * *   You can call this operation up to 20 times per second per account.
   * 
   * @param request - StartDcdnIpaDomainRequest
   * @returns StartDcdnIpaDomainResponse
   */
  async startDcdnIpaDomain(request: StartDcdnIpaDomainRequest): Promise<StartDcdnIpaDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startDcdnIpaDomainWithOptions(request, runtime);
  }

  /**
   * Disables a specified accelerated domain. After the accelerated domain is disabled,
   *                   the value of the DomainStatus parameter changes to Offline for the domain.
   * 
   * @remarks
   * > 
   * *   After an accelerated domain is disabled, Dynamic Content Delivery Network (DCDN) retains its information and routes all the requests that are destined for the accelerated domain to the origin server.
   * *   You can call this operation up to 30 times per second per account.
   * 
   * @param request - StopDcdnDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StopDcdnDomainResponse
   */
  async stopDcdnDomainWithOptions(request: StopDcdnDomainRequest, runtime: $Util.RuntimeOptions): Promise<StopDcdnDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StopDcdnDomain",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StopDcdnDomainResponse>(await this.callApi(params, req, runtime), new StopDcdnDomainResponse({}));
  }

  /**
   * Disables a specified accelerated domain. After the accelerated domain is disabled,
   *                   the value of the DomainStatus parameter changes to Offline for the domain.
   * 
   * @remarks
   * > 
   * *   After an accelerated domain is disabled, Dynamic Content Delivery Network (DCDN) retains its information and routes all the requests that are destined for the accelerated domain to the origin server.
   * *   You can call this operation up to 30 times per second per account.
   * 
   * @param request - StopDcdnDomainRequest
   * @returns StopDcdnDomainResponse
   */
  async stopDcdnDomain(request: StopDcdnDomainRequest): Promise<StopDcdnDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopDcdnDomainWithOptions(request, runtime);
  }

  /**
   * Disables an accelerated domain name. After an accelerated domain name is disabled, the value of the DomainStatus parameter for the domain name changes to Offline.
   * 
   * @remarks
   * > 
   * *   If you disable an accelerated domain, the configurations of the accelerated domain are still retained. The system automatically forwards all the requests that are destined for this domain to the origin.
   * *   You can call this operation up to 20 times per second per account.
   * 
   * @param request - StopDcdnIpaDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StopDcdnIpaDomainResponse
   */
  async stopDcdnIpaDomainWithOptions(request: StopDcdnIpaDomainRequest, runtime: $Util.RuntimeOptions): Promise<StopDcdnIpaDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StopDcdnIpaDomain",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StopDcdnIpaDomainResponse>(await this.callApi(params, req, runtime), new StopDcdnIpaDomainResponse({}));
  }

  /**
   * Disables an accelerated domain name. After an accelerated domain name is disabled, the value of the DomainStatus parameter for the domain name changes to Offline.
   * 
   * @remarks
   * > 
   * *   If you disable an accelerated domain, the configurations of the accelerated domain are still retained. The system automatically forwards all the requests that are destined for this domain to the origin.
   * *   You can call this operation up to 20 times per second per account.
   * 
   * @param request - StopDcdnIpaDomainRequest
   * @returns StopDcdnIpaDomainResponse
   */
  async stopDcdnIpaDomain(request: StopDcdnIpaDomainRequest): Promise<StopDcdnIpaDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopDcdnIpaDomainWithOptions(request, runtime);
  }

  /**
   * Adds one or more tags to a resource.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - TagDcdnResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns TagDcdnResourcesResponse
   */
  async tagDcdnResourcesWithOptions(request: TagDcdnResourcesRequest, runtime: $Util.RuntimeOptions): Promise<TagDcdnResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "TagDcdnResources",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<TagDcdnResourcesResponse>(await this.callApi(params, req, runtime), new TagDcdnResourcesResponse({}));
  }

  /**
   * Adds one or more tags to a resource.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - TagDcdnResourcesRequest
   * @returns TagDcdnResourcesResponse
   */
  async tagDcdnResources(request: TagDcdnResourcesRequest): Promise<TagDcdnResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.tagDcdnResourcesWithOptions(request, runtime);
  }

  /**
   * Removes one or more tags from a resource.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - UntagDcdnResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UntagDcdnResourcesResponse
   */
  async untagDcdnResourcesWithOptions(request: UntagDcdnResourcesRequest, runtime: $Util.RuntimeOptions): Promise<UntagDcdnResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.all)) {
      query["All"] = request.all;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.tagKey)) {
      query["TagKey"] = request.tagKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UntagDcdnResources",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UntagDcdnResourcesResponse>(await this.callApi(params, req, runtime), new UntagDcdnResourcesResponse({}));
  }

  /**
   * Removes one or more tags from a resource.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - UntagDcdnResourcesRequest
   * @returns UntagDcdnResourcesResponse
   */
  async untagDcdnResources(request: UntagDcdnResourcesRequest): Promise<UntagDcdnResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.untagDcdnResourcesWithOptions(request, runtime);
  }

  /**
   * Updates a tracking task by task ID.
   * 
   * @remarks
   * > You can call this operation up to three times per second per account.
   * 
   * @param request - UpdateDcdnDeliverTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateDcdnDeliverTaskResponse
   */
  async updateDcdnDeliverTaskWithOptions(request: UpdateDcdnDeliverTaskRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDcdnDeliverTaskResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.deliver)) {
      body["Deliver"] = request.deliver;
    }

    if (!Util.isUnset(request.deliverId)) {
      body["DeliverId"] = request.deliverId;
    }

    if (!Util.isUnset(request.domainName)) {
      body["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.reports)) {
      body["Reports"] = request.reports;
    }

    if (!Util.isUnset(request.schedule)) {
      body["Schedule"] = request.schedule;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDcdnDeliverTask",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDcdnDeliverTaskResponse>(await this.callApi(params, req, runtime), new UpdateDcdnDeliverTaskResponse({}));
  }

  /**
   * Updates a tracking task by task ID.
   * 
   * @remarks
   * > You can call this operation up to three times per second per account.
   * 
   * @param request - UpdateDcdnDeliverTaskRequest
   * @returns UpdateDcdnDeliverTaskResponse
   */
  async updateDcdnDeliverTask(request: UpdateDcdnDeliverTaskRequest): Promise<UpdateDcdnDeliverTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDcdnDeliverTaskWithOptions(request, runtime);
  }

  /**
   * Modifies an accelerated domain name.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - UpdateDcdnDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateDcdnDomainResponse
   */
  async updateDcdnDomainWithOptions(request: UpdateDcdnDomainRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDcdnDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.sources)) {
      query["Sources"] = request.sources;
    }

    if (!Util.isUnset(request.topLevelDomain)) {
      query["TopLevelDomain"] = request.topLevelDomain;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDcdnDomain",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDcdnDomainResponse>(await this.callApi(params, req, runtime), new UpdateDcdnDomainResponse({}));
  }

  /**
   * Modifies an accelerated domain name.
   * 
   * @remarks
   * > You can call this operation up to 30 times per second per account.
   * 
   * @param request - UpdateDcdnDomainRequest
   * @returns UpdateDcdnDomainResponse
   */
  async updateDcdnDomain(request: UpdateDcdnDomainRequest): Promise<UpdateDcdnDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDcdnDomainWithOptions(request, runtime);
  }

  /**
   * Modifies a domain name that is accelerated by IP Application Accelerator (IPA).
   * 
   * @remarks
   * >  You can call this operation up to 20 times per second per account.
   * 
   * @param request - UpdateDcdnIpaDomainRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateDcdnIpaDomainResponse
   */
  async updateDcdnIpaDomainWithOptions(request: UpdateDcdnIpaDomainRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDcdnIpaDomainResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!Util.isUnset(request.sources)) {
      query["Sources"] = request.sources;
    }

    if (!Util.isUnset(request.topLevelDomain)) {
      query["TopLevelDomain"] = request.topLevelDomain;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDcdnIpaDomain",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDcdnIpaDomainResponse>(await this.callApi(params, req, runtime), new UpdateDcdnIpaDomainResponse({}));
  }

  /**
   * Modifies a domain name that is accelerated by IP Application Accelerator (IPA).
   * 
   * @remarks
   * >  You can call this operation up to 20 times per second per account.
   * 
   * @param request - UpdateDcdnIpaDomainRequest
   * @returns UpdateDcdnIpaDomainResponse
   */
  async updateDcdnIpaDomain(request: UpdateDcdnIpaDomainRequest): Promise<UpdateDcdnIpaDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDcdnIpaDomainWithOptions(request, runtime);
  }

  /**
   * Updates a real-time log delivery project.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - UpdateDcdnSLSRealtimeLogDeliveryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateDcdnSLSRealtimeLogDeliveryResponse
   */
  async updateDcdnSLSRealtimeLogDeliveryWithOptions(request: UpdateDcdnSLSRealtimeLogDeliveryRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDcdnSLSRealtimeLogDeliveryResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.dataCenter)) {
      body["DataCenter"] = request.dataCenter;
    }

    if (!Util.isUnset(request.domainName)) {
      body["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.projectName)) {
      body["ProjectName"] = request.projectName;
    }

    if (!Util.isUnset(request.SLSLogStore)) {
      body["SLSLogStore"] = request.SLSLogStore;
    }

    if (!Util.isUnset(request.SLSProject)) {
      body["SLSProject"] = request.SLSProject;
    }

    if (!Util.isUnset(request.SLSRegion)) {
      body["SLSRegion"] = request.SLSRegion;
    }

    if (!Util.isUnset(request.samplingRate)) {
      body["SamplingRate"] = request.samplingRate;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDcdnSLSRealtimeLogDelivery",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDcdnSLSRealtimeLogDeliveryResponse>(await this.callApi(params, req, runtime), new UpdateDcdnSLSRealtimeLogDeliveryResponse({}));
  }

  /**
   * Updates a real-time log delivery project.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - UpdateDcdnSLSRealtimeLogDeliveryRequest
   * @returns UpdateDcdnSLSRealtimeLogDeliveryResponse
   */
  async updateDcdnSLSRealtimeLogDelivery(request: UpdateDcdnSLSRealtimeLogDeliveryRequest): Promise<UpdateDcdnSLSRealtimeLogDeliveryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDcdnSLSRealtimeLogDeliveryWithOptions(request, runtime);
  }

  /**
   * Updates one or more operations reports.
   * 
   * @remarks
   * > You can call this operation up to three times per second per account.
   * 
   * @param request - UpdateDcdnSubTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateDcdnSubTaskResponse
   */
  async updateDcdnSubTaskWithOptions(request: UpdateDcdnSubTaskRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDcdnSubTaskResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.domainName)) {
      body["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.reportIds)) {
      body["ReportIds"] = request.reportIds;
    }

    if (!Util.isUnset(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDcdnSubTask",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDcdnSubTaskResponse>(await this.callApi(params, req, runtime), new UpdateDcdnSubTaskResponse({}));
  }

  /**
   * Updates one or more operations reports.
   * 
   * @remarks
   * > You can call this operation up to three times per second per account.
   * 
   * @param request - UpdateDcdnSubTaskRequest
   * @returns UpdateDcdnSubTaskResponse
   */
  async updateDcdnSubTask(request: UpdateDcdnSubTaskRequest): Promise<UpdateDcdnSubTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDcdnSubTaskWithOptions(request, runtime);
  }

  /**
   * Updates the fields in real-time log entries.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - UpdateDcdnUserRealTimeDeliveryFieldRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateDcdnUserRealTimeDeliveryFieldResponse
   */
  async updateDcdnUserRealTimeDeliveryFieldWithOptions(request: UpdateDcdnUserRealTimeDeliveryFieldRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDcdnUserRealTimeDeliveryFieldResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.businessType)) {
      query["BusinessType"] = request.businessType;
    }

    if (!Util.isUnset(request.fields)) {
      query["Fields"] = request.fields;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDcdnUserRealTimeDeliveryField",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDcdnUserRealTimeDeliveryFieldResponse>(await this.callApi(params, req, runtime), new UpdateDcdnUserRealTimeDeliveryFieldResponse({}));
  }

  /**
   * Updates the fields in real-time log entries.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - UpdateDcdnUserRealTimeDeliveryFieldRequest
   * @returns UpdateDcdnUserRealTimeDeliveryFieldResponse
   */
  async updateDcdnUserRealTimeDeliveryField(request: UpdateDcdnUserRealTimeDeliveryFieldRequest): Promise<UpdateDcdnUserRealTimeDeliveryFieldResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDcdnUserRealTimeDeliveryFieldWithOptions(request, runtime);
  }

  /**
   * Uploads code to EdgeRoutine (ER).
   * 
   * @remarks
   * > 
   * *   Each time you submit code, a version of the code is generated. You can manage and publish code by version.
   * *   Each routine can retain at most 10 versions. If the upper limit is reached, you must call the DeleteRoutineCodeRevision operation to manually delete versions that are no longer needed before new versions can be saved.
   * *   You can call this operation up to 100 times per second per account.
   * 
   * @param request - UploadRoutineCodeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UploadRoutineCodeResponse
   */
  async uploadRoutineCodeWithOptions(request: UploadRoutineCodeRequest, runtime: $Util.RuntimeOptions): Promise<UploadRoutineCodeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.codeDescription)) {
      body["CodeDescription"] = request.codeDescription;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UploadRoutineCode",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UploadRoutineCodeResponse>(await this.callApi(params, req, runtime), new UploadRoutineCodeResponse({}));
  }

  /**
   * Uploads code to EdgeRoutine (ER).
   * 
   * @remarks
   * > 
   * *   Each time you submit code, a version of the code is generated. You can manage and publish code by version.
   * *   Each routine can retain at most 10 versions. If the upper limit is reached, you must call the DeleteRoutineCodeRevision operation to manually delete versions that are no longer needed before new versions can be saved.
   * *   You can call this operation up to 100 times per second per account.
   * 
   * @param request - UploadRoutineCodeRequest
   * @returns UploadRoutineCodeResponse
   */
  async uploadRoutineCode(request: UploadRoutineCodeRequest): Promise<UploadRoutineCodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.uploadRoutineCodeWithOptions(request, runtime);
  }

  /**
   * Uploads code to a routine for testing.
   * 
   * @remarks
   * > 
   * *   Each time you upload code to a routine, a version is generated. The number of versions is counted by CodeRev. The uploaded code is used only for testing.
   * *   The code is automatically published to a staging environment.
   * *   Each routine can retain at most 10 versions. If the upper limit is reached, you need to call the DeleteRoutineCodeRevision operation to manually delete versions that are no longer needed before new versions can be saved.
   * *   You can call this operation up to 100 times per second per account.
   * 
   * @param request - UploadStagingRoutineCodeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UploadStagingRoutineCodeResponse
   */
  async uploadStagingRoutineCodeWithOptions(request: UploadStagingRoutineCodeRequest, runtime: $Util.RuntimeOptions): Promise<UploadStagingRoutineCodeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.codeDescription)) {
      body["CodeDescription"] = request.codeDescription;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UploadStagingRoutineCode",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UploadStagingRoutineCodeResponse>(await this.callApi(params, req, runtime), new UploadStagingRoutineCodeResponse({}));
  }

  /**
   * Uploads code to a routine for testing.
   * 
   * @remarks
   * > 
   * *   Each time you upload code to a routine, a version is generated. The number of versions is counted by CodeRev. The uploaded code is used only for testing.
   * *   The code is automatically published to a staging environment.
   * *   Each routine can retain at most 10 versions. If the upper limit is reached, you need to call the DeleteRoutineCodeRevision operation to manually delete versions that are no longer needed before new versions can be saved.
   * *   You can call this operation up to 100 times per second per account.
   * 
   * @param request - UploadStagingRoutineCodeRequest
   * @returns UploadStagingRoutineCodeResponse
   */
  async uploadStagingRoutineCode(request: UploadStagingRoutineCodeRequest): Promise<UploadStagingRoutineCodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.uploadStagingRoutineCodeWithOptions(request, runtime);
  }

  /**
   * Verifies the ownership of a domain name.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - VerifyDcdnDomainOwnerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns VerifyDcdnDomainOwnerResponse
   */
  async verifyDcdnDomainOwnerWithOptions(request: VerifyDcdnDomainOwnerRequest, runtime: $Util.RuntimeOptions): Promise<VerifyDcdnDomainOwnerResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.verifyType)) {
      query["VerifyType"] = request.verifyType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "VerifyDcdnDomainOwner",
      version: "2018-01-15",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<VerifyDcdnDomainOwnerResponse>(await this.callApi(params, req, runtime), new VerifyDcdnDomainOwnerResponse({}));
  }

  /**
   * Verifies the ownership of a domain name.
   * 
   * @remarks
   * > You can call this operation up to 100 times per second per account.
   * 
   * @param request - VerifyDcdnDomainOwnerRequest
   * @returns VerifyDcdnDomainOwnerResponse
   */
  async verifyDcdnDomainOwner(request: VerifyDcdnDomainOwnerRequest): Promise<VerifyDcdnDomainOwnerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.verifyDcdnDomainOwnerWithOptions(request, runtime);
  }

}
