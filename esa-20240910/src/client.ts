// This file is auto-generated, don't edit it
/**
 */
import OSS, * as $OSS from '@alicloud/oss-client';
import OpenPlatform, * as $OpenPlatform from '@alicloud/openplatform20191219';
import OSSUtil, * as $OSSUtil from '@alicloud/oss-util';
import FileForm, * as $FileForm from '@alicloud/tea-fileform';
import OpenApi from '@alicloud/openapi-core';
import { OpenApiUtil, $OpenApiUtil } from '@alicloud/openapi-core';
import { Readable } from 'stream';
import * as $dara from '@darabonba/typescript';

export class WafBatchRuleSharedActionsResponse extends $dara.Model {
  code?: number;
  id?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      id: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafBatchRuleSharedActions extends $dara.Model {
  response?: WafBatchRuleSharedActionsResponse;
  static names(): { [key: string]: string } {
    return {
      response: 'Response',
    };
  }

  static types(): { [key: string]: any } {
    return {
      response: WafBatchRuleSharedActionsResponse,
    };
  }

  validate() {
    if(this.response && typeof (this.response as any).validate === 'function') {
      (this.response as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleConfigActionsBypass extends $dara.Model {
  customRules?: number[];
  regularRules?: number[];
  regularTypes?: string[];
  skip?: string;
  tags?: string[];
  static names(): { [key: string]: string } {
    return {
      customRules: 'CustomRules',
      regularRules: 'RegularRules',
      regularTypes: 'RegularTypes',
      skip: 'Skip',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customRules: { 'type': 'array', 'itemType': 'number' },
      regularRules: { 'type': 'array', 'itemType': 'number' },
      regularTypes: { 'type': 'array', 'itemType': 'string' },
      skip: 'string',
      tags: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.customRules)) {
      $dara.Model.validateArray(this.customRules);
    }
    if(Array.isArray(this.regularRules)) {
      $dara.Model.validateArray(this.regularRules);
    }
    if(Array.isArray(this.regularTypes)) {
      $dara.Model.validateArray(this.regularTypes);
    }
    if(Array.isArray(this.tags)) {
      $dara.Model.validateArray(this.tags);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleConfigActionsResponse extends $dara.Model {
  code?: number;
  id?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      id: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleConfigActions extends $dara.Model {
  bypass?: WafRuleConfigActionsBypass;
  response?: WafRuleConfigActionsResponse;
  static names(): { [key: string]: string } {
    return {
      bypass: 'Bypass',
      response: 'Response',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bypass: WafRuleConfigActionsBypass,
      response: WafRuleConfigActionsResponse,
    };
  }

  validate() {
    if(this.bypass && typeof (this.bypass as any).validate === 'function') {
      (this.bypass as any).validate();
    }
    if(this.response && typeof (this.response as any).validate === 'function') {
      (this.response as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleConfigAppPackagePackageSigns extends $dara.Model {
  name?: string;
  sign?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      sign: 'Sign',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      sign: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleConfigAppPackage extends $dara.Model {
  packageSigns?: WafRuleConfigAppPackagePackageSigns[];
  static names(): { [key: string]: string } {
    return {
      packageSigns: 'PackageSigns',
    };
  }

  static types(): { [key: string]: any } {
    return {
      packageSigns: { 'type': 'array', 'itemType': WafRuleConfigAppPackagePackageSigns },
    };
  }

  validate() {
    if(Array.isArray(this.packageSigns)) {
      $dara.Model.validateArray(this.packageSigns);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleConfigAppSdkCustomSign extends $dara.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleConfigAppSdk extends $dara.Model {
  customSign?: WafRuleConfigAppSdkCustomSign;
  customSignStatus?: string;
  featureAbnormal?: string[];
  static names(): { [key: string]: string } {
    return {
      customSign: 'CustomSign',
      customSignStatus: 'CustomSignStatus',
      featureAbnormal: 'FeatureAbnormal',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customSign: WafRuleConfigAppSdkCustomSign,
      customSignStatus: 'string',
      featureAbnormal: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(this.customSign && typeof (this.customSign as any).validate === 'function') {
      (this.customSign as any).validate();
    }
    if(Array.isArray(this.featureAbnormal)) {
      $dara.Model.validateArray(this.featureAbnormal);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleConfigManagedRulesetsManagedRules extends $dara.Model {
  action?: string;
  id?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      id: 'Id',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      id: 'number',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleConfigManagedRulesets extends $dara.Model {
  action?: string;
  attackType?: number;
  managedRules?: WafRuleConfigManagedRulesetsManagedRules[];
  numberEnabled?: number;
  numberTotal?: number;
  protectionLevel?: number;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      attackType: 'AttackType',
      managedRules: 'ManagedRules',
      numberEnabled: 'NumberEnabled',
      numberTotal: 'NumberTotal',
      protectionLevel: 'ProtectionLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      attackType: 'number',
      managedRules: { 'type': 'array', 'itemType': WafRuleConfigManagedRulesetsManagedRules },
      numberEnabled: 'number',
      numberTotal: 'number',
      protectionLevel: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.managedRules)) {
      $dara.Model.validateArray(this.managedRules);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleConfigRateLimitThresholdResponseStatus extends $dara.Model {
  code?: number;
  count?: number;
  ratio?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      count: 'Count',
      ratio: 'Ratio',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'number',
      count: 'number',
      ratio: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleConfigRateLimitThreshold extends $dara.Model {
  distinctManagedRules?: number;
  managedRulesBlocked?: number;
  request?: number;
  responseStatus?: WafRuleConfigRateLimitThresholdResponseStatus;
  traffic?: string;
  static names(): { [key: string]: string } {
    return {
      distinctManagedRules: 'DistinctManagedRules',
      managedRulesBlocked: 'ManagedRulesBlocked',
      request: 'Request',
      responseStatus: 'ResponseStatus',
      traffic: 'Traffic',
    };
  }

  static types(): { [key: string]: any } {
    return {
      distinctManagedRules: 'number',
      managedRulesBlocked: 'number',
      request: 'number',
      responseStatus: WafRuleConfigRateLimitThresholdResponseStatus,
      traffic: 'string',
    };
  }

  validate() {
    if(this.responseStatus && typeof (this.responseStatus as any).validate === 'function') {
      (this.responseStatus as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleConfigRateLimit extends $dara.Model {
  characteristics?: WafRuleMatch2;
  interval?: number;
  onHit?: boolean;
  TTL?: number;
  threshold?: WafRuleConfigRateLimitThreshold;
  static names(): { [key: string]: string } {
    return {
      characteristics: 'Characteristics',
      interval: 'Interval',
      onHit: 'OnHit',
      TTL: 'TTL',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      characteristics: WafRuleMatch2,
      interval: 'number',
      onHit: 'boolean',
      TTL: 'number',
      threshold: WafRuleConfigRateLimitThreshold,
    };
  }

  validate() {
    if(this.characteristics && typeof (this.characteristics as any).validate === 'function') {
      (this.characteristics as any).validate();
    }
    if(this.threshold && typeof (this.threshold as any).validate === 'function') {
      (this.threshold as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleMatch2CriteriaCriteriaCriteria extends $dara.Model {
  convertToLower?: boolean;
  matchOperator?: string;
  matchType?: string;
  matchValue?: any;
  negate?: boolean;
  static names(): { [key: string]: string } {
    return {
      convertToLower: 'ConvertToLower',
      matchOperator: 'MatchOperator',
      matchType: 'MatchType',
      matchValue: 'MatchValue',
      negate: 'Negate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      convertToLower: 'boolean',
      matchOperator: 'string',
      matchType: 'string',
      matchValue: 'any',
      negate: 'boolean',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleMatch2CriteriaCriteria extends $dara.Model {
  convertToLower?: boolean;
  criteria?: WafRuleMatch2CriteriaCriteriaCriteria[];
  logic?: string;
  matchOperator?: string;
  matchType?: string;
  matchValue?: any;
  negate?: boolean;
  static names(): { [key: string]: string } {
    return {
      convertToLower: 'ConvertToLower',
      criteria: 'Criteria',
      logic: 'Logic',
      matchOperator: 'MatchOperator',
      matchType: 'MatchType',
      matchValue: 'MatchValue',
      negate: 'Negate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      convertToLower: 'boolean',
      criteria: { 'type': 'array', 'itemType': WafRuleMatch2CriteriaCriteriaCriteria },
      logic: 'string',
      matchOperator: 'string',
      matchType: 'string',
      matchValue: 'any',
      negate: 'boolean',
    };
  }

  validate() {
    if(Array.isArray(this.criteria)) {
      $dara.Model.validateArray(this.criteria);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleMatch2Criteria extends $dara.Model {
  convertToLower?: boolean;
  criteria?: WafRuleMatch2CriteriaCriteria[];
  logic?: string;
  matchOperator?: string;
  matchType?: string;
  matchValue?: any;
  negate?: boolean;
  static names(): { [key: string]: string } {
    return {
      convertToLower: 'ConvertToLower',
      criteria: 'Criteria',
      logic: 'Logic',
      matchOperator: 'MatchOperator',
      matchType: 'MatchType',
      matchValue: 'MatchValue',
      negate: 'Negate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      convertToLower: 'boolean',
      criteria: { 'type': 'array', 'itemType': WafRuleMatch2CriteriaCriteria },
      logic: 'string',
      matchOperator: 'string',
      matchType: 'string',
      matchValue: 'any',
      negate: 'boolean',
    };
  }

  validate() {
    if(Array.isArray(this.criteria)) {
      $dara.Model.validateArray(this.criteria);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafSiteSettingsAddBotProtectionHeaders extends $dara.Model {
  enable?: boolean;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'boolean',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafSiteSettingsAddSecurityHeaders extends $dara.Model {
  enable?: boolean;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'boolean',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafSiteSettingsBotManagementDefiniteBots extends $dara.Model {
  action?: string;
  id?: number;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      id: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafSiteSettingsBotManagementEffectOnStatic extends $dara.Model {
  enable?: boolean;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'boolean',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafSiteSettingsBotManagementJSDetection extends $dara.Model {
  enable?: boolean;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'boolean',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafSiteSettingsBotManagementLikelyBots extends $dara.Model {
  action?: string;
  id?: number;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      id: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafSiteSettingsBotManagementVerifiedBots extends $dara.Model {
  action?: string;
  id?: number;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      id: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafSiteSettingsBotManagement extends $dara.Model {
  definiteBots?: WafSiteSettingsBotManagementDefiniteBots;
  effectOnStatic?: WafSiteSettingsBotManagementEffectOnStatic;
  JSDetection?: WafSiteSettingsBotManagementJSDetection;
  likelyBots?: WafSiteSettingsBotManagementLikelyBots;
  verifiedBots?: WafSiteSettingsBotManagementVerifiedBots;
  static names(): { [key: string]: string } {
    return {
      definiteBots: 'DefiniteBots',
      effectOnStatic: 'EffectOnStatic',
      JSDetection: 'JSDetection',
      likelyBots: 'LikelyBots',
      verifiedBots: 'VerifiedBots',
    };
  }

  static types(): { [key: string]: any } {
    return {
      definiteBots: WafSiteSettingsBotManagementDefiniteBots,
      effectOnStatic: WafSiteSettingsBotManagementEffectOnStatic,
      JSDetection: WafSiteSettingsBotManagementJSDetection,
      likelyBots: WafSiteSettingsBotManagementLikelyBots,
      verifiedBots: WafSiteSettingsBotManagementVerifiedBots,
    };
  }

  validate() {
    if(this.definiteBots && typeof (this.definiteBots as any).validate === 'function') {
      (this.definiteBots as any).validate();
    }
    if(this.effectOnStatic && typeof (this.effectOnStatic as any).validate === 'function') {
      (this.effectOnStatic as any).validate();
    }
    if(this.JSDetection && typeof (this.JSDetection as any).validate === 'function') {
      (this.JSDetection as any).validate();
    }
    if(this.likelyBots && typeof (this.likelyBots as any).validate === 'function') {
      (this.likelyBots as any).validate();
    }
    if(this.verifiedBots && typeof (this.verifiedBots as any).validate === 'function') {
      (this.verifiedBots as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafSiteSettingsClientIpIdentifier extends $dara.Model {
  headers?: string[];
  mode?: string;
  static names(): { [key: string]: string } {
    return {
      headers: 'Headers',
      mode: 'Mode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'array', 'itemType': 'string' },
      mode: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.headers)) {
      $dara.Model.validateArray(this.headers);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafSiteSettingsSecurityLevel extends $dara.Model {
  value?: string;
  static names(): { [key: string]: string } {
    return {
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      value: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafTimerPeriods extends $dara.Model {
  end?: string;
  start?: string;
  static names(): { [key: string]: string } {
    return {
      end: 'End',
      start: 'Start',
    };
  }

  static types(): { [key: string]: any } {
    return {
      end: 'string',
      start: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafTimerWeeklyPeriodsDailyPeriods extends $dara.Model {
  end?: string;
  start?: string;
  static names(): { [key: string]: string } {
    return {
      end: 'End',
      start: 'Start',
    };
  }

  static types(): { [key: string]: any } {
    return {
      end: 'string',
      start: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafTimerWeeklyPeriods extends $dara.Model {
  dailyPeriods?: WafTimerWeeklyPeriodsDailyPeriods[];
  days?: string;
  static names(): { [key: string]: string } {
    return {
      dailyPeriods: 'DailyPeriods',
      days: 'Days',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dailyPeriods: { 'type': 'array', 'itemType': WafTimerWeeklyPeriodsDailyPeriods },
      days: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.dailyPeriods)) {
      $dara.Model.validateArray(this.dailyPeriods);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FieldContentValueFieldList extends $dara.Model {
  /**
   * @remarks
   * The field name.
   * 
   * @example
   * ClientIp
   */
  fieldName?: string;
  /**
   * @remarks
   * The description of the field in English.
   * 
   * @example
   * IP address of the client.
   */
  description?: string;
  /**
   * @remarks
   * The description of the field in Chinese.
   */
  descriptionCn?: string;
  /**
   * @remarks
   * The category of the field.
   * 
   * @example
   * Client
   */
  category?: string;
  /**
   * @remarks
   * The data type of the field.
   * 
   * @example
   * String
   */
  dataType?: string;
  /**
   * @remarks
   * The sequence number of the field.
   * 
   * @example
   * 1
   */
  sortOrder?: number;
  /**
   * @remarks
   * Indicates whether the field is available by default.
   * 
   * @example
   * true
   */
  isDefault?: boolean;
  static names(): { [key: string]: string } {
    return {
      fieldName: 'FieldName',
      description: 'Description',
      descriptionCn: 'DescriptionCn',
      category: 'Category',
      dataType: 'DataType',
      sortOrder: 'SortOrder',
      isDefault: 'IsDefault',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldName: 'string',
      description: 'string',
      descriptionCn: 'string',
      category: 'string',
      dataType: 'string',
      sortOrder: 'number',
      isDefault: 'boolean',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyCertificateResponseBodyResult extends $dara.Model {
  /**
   * @example
   * *.example.com
   */
  domain?: string;
  /**
   * @example
   * 30000478
   */
  id?: string;
  /**
   * @example
   * Applying
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      id: 'Id',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      id: 'string',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateRecordsRequestRecordListAuthConf extends $dara.Model {
  accessKey?: string;
  authType?: string;
  region?: string;
  secretKey?: string;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      accessKey: 'AccessKey',
      authType: 'AuthType',
      region: 'Region',
      secretKey: 'SecretKey',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKey: 'string',
      authType: 'string',
      region: 'string',
      secretKey: 'string',
      version: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateRecordsRequestRecordListData extends $dara.Model {
  /**
   * @remarks
   * The encryption algorithm used for the record. Valid values: 0 to 255. Applicable to CERT and SSHFP records.
   * 
   * @example
   * 0
   */
  algorithm?: number;
  /**
   * @remarks
   * The public key of the certificate. Applicable to CERT, SMIMEA, and TLSA records.
   * 
   * @example
   * dGVzdGFkYWxrcw==
   */
  certificate?: string;
  /**
   * @remarks
   * The public key fingerprint of the record. Applicable to SSHFP records.
   * 
   * @example
   * abcdef1234567890
   */
  fingerprint?: string;
  /**
   * @remarks
   * The Flag for a CAA record indicates its priority and how it is processed. Valid values: 0 to 255.
   * 
   * @example
   * 128
   */
  flag?: number;
  /**
   * @remarks
   * The public key identification for the record. Valid values: 0 to 65535. Applicable to CERT records.
   * 
   * @example
   * 0
   */
  keyTag?: number;
  /**
   * @remarks
   * The algorithm policy used to match or validate the certificate. Valid values: 0 to 255. Applicable to SMIMEA, and TLSA records.
   * 
   * @example
   * 0
   */
  matchingType?: number;
  /**
   * @remarks
   * The port of the record. Valid values: 0 to 65535. Exclusive to SRV records.
   * 
   * @example
   * 0
   */
  port?: number;
  /**
   * @remarks
   * The priority of the record. Valid values: 0 to 65535. A smaller value indicates a higher priority. This parameter is required when you add MX, SRV, and URI records.
   * 
   * @example
   * 2
   */
  priority?: number;
  /**
   * @remarks
   * The type of certificate or public key. Valid values: 0 to 255. Applicable to SMIMEA and TLSA records.
   * 
   * @example
   * 0
   */
  selector?: number;
  /**
   * @remarks
   * The tag of a CAA record, which indicates its specific type and purpose, such as issue, issuewild, and iodef.
   * 
   * @example
   * issue
   */
  tag?: string;
  /**
   * @remarks
   * The certificate type of the record (in CERT records), or the public key type (in SSHFP records).
   * 
   * @example
   * 0
   */
  type?: number;
  /**
   * @remarks
   * The usage identifier of the record. Valid values: 0 to 255. Applicable to SMIMEA and TLSA records.
   * 
   * @example
   * 0
   */
  usage?: number;
  /**
   * @remarks
   * The record value or part of the record content. A/AAAA: the IP address being pointed to. CNAME: the target domain name being pointed to. MX: valid target mail server domain name. TXT: valid text string. CAA: valid certificate authority domain name. SRV: valid target host domain name. URI: valid URI string.
   * 
   * @example
   * example.com
   */
  value?: string;
  /**
   * @remarks
   * The weight of the record. Valid values: 0 to 65,535. Applicable to SRV and URI records.
   * 
   * @example
   * 0
   */
  weight?: number;
  static names(): { [key: string]: string } {
    return {
      algorithm: 'Algorithm',
      certificate: 'Certificate',
      fingerprint: 'Fingerprint',
      flag: 'Flag',
      keyTag: 'KeyTag',
      matchingType: 'MatchingType',
      port: 'Port',
      priority: 'Priority',
      selector: 'Selector',
      tag: 'Tag',
      type: 'Type',
      usage: 'Usage',
      value: 'Value',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      algorithm: 'number',
      certificate: 'string',
      fingerprint: 'string',
      flag: 'number',
      keyTag: 'number',
      matchingType: 'number',
      port: 'number',
      priority: 'number',
      selector: 'number',
      tag: 'string',
      type: 'number',
      usage: 'number',
      value: 'string',
      weight: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateRecordsRequestRecordList extends $dara.Model {
  authConf?: BatchCreateRecordsRequestRecordListAuthConf;
  /**
   * @remarks
   * The business scenario of the record for acceleration. Valid values:
   * 
   * *   **image_video**
   * *   **api**
   * *   **web**
   * 
   * @example
   * web
   */
  bizName?: string;
  /**
   * @remarks
   * The DNS information of the record. Enter fields based on the record type.
   * 
   * This parameter is required.
   * 
   * @example
   * {
   *     "value":"2.2.2.2"
   * }
   */
  data?: BatchCreateRecordsRequestRecordListData;
  /**
   * @remarks
   * Specifies whether to proxy the record. Only CNAME and A/AAAA records can be proxied. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  proxied?: boolean;
  /**
   * @remarks
   * The record name.
   * 
   * This parameter is required.
   * 
   * @example
   * www.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The origin type for the CNAME record. This parameter is required when you add a CNAME record. Valid values:
   * 
   * *   **OSS**: OSS bucket.
   * *   **S3**: S3 bucket.
   * *   **LB**: load balancer.
   * *   **OP**: origin pool.
   * *   **Domain**: domain name.
   * 
   * If you do not pass this parameter or if you leave its value empty, Domain is used by default.
   * 
   * @example
   * OSS
   */
  sourceType?: string;
  /**
   * @remarks
   * The TTL of the record. Unit: seconds. If the value is 1, the TTL of the record is determined by the system.
   * 
   * This parameter is required.
   * 
   * @example
   * 60
   */
  ttl?: number;
  /**
   * @remarks
   * The DNS type of the record.
   * 
   * This parameter is required.
   * 
   * @example
   * A/AAAA
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      authConf: 'AuthConf',
      bizName: 'BizName',
      data: 'Data',
      proxied: 'Proxied',
      recordName: 'RecordName',
      sourceType: 'SourceType',
      ttl: 'Ttl',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authConf: BatchCreateRecordsRequestRecordListAuthConf,
      bizName: 'string',
      data: BatchCreateRecordsRequestRecordListData,
      proxied: 'boolean',
      recordName: 'string',
      sourceType: 'string',
      ttl: 'number',
      type: 'string',
    };
  }

  validate() {
    if(this.authConf && typeof (this.authConf as any).validate === 'function') {
      (this.authConf as any).validate();
    }
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateRecordsResponseBodyRecordResultListFailedData extends $dara.Model {
  /**
   * @remarks
   * The encryption algorithm used for the record. Valid values: 0 to 255. Applicable to CERT and SSHFP records.
   * 
   * @example
   * 0
   */
  algorithm?: number;
  /**
   * @remarks
   * The public key of the certificate. Applicable to CERT, SMIMEA, and TLSA records.
   * 
   * @example
   * dGVzdGFkYWxrcw==
   */
  certificate?: string;
  /**
   * @remarks
   * The public key fingerprint of the record. Applicable to SSHFP records.
   * 
   * @example
   * abcdef1234567890
   */
  fingerprint?: string;
  /**
   * @remarks
   * The flag bit of the record. Indicates its priority and handling method, used in CAA records.
   * 
   * @example
   * 128
   */
  flag?: number;
  /**
   * @remarks
   * The public key identification for the record. Valid values: 0 to 65535. Applicable to CERT records.
   * 
   * @example
   * 0
   */
  keyTag?: number;
  /**
   * @remarks
   * The algorithm policy used to match or validate the certificate. Valid values: 0 to 255. Applicable to SMIMEA and TLSA records.
   * 
   * @example
   * RSA
   */
  matchingType?: number;
  /**
   * @remarks
   * The port number of the record, associated with the SRV record. Exclusive to SRV records.
   * 
   * @example
   * 0
   */
  port?: number;
  /**
   * @remarks
   * The priority of the record. Valid values: 0 to 65535. A smaller value indicates a higher priority. Applicable to MX, SRV, and URI records.
   * 
   * @example
   * 10
   */
  priority?: number;
  /**
   * @remarks
   * The type of certificate or public key. Valid values: 0 to 255. Applicable to SMIMEA and TLSA records.
   * 
   * @example
   * 0
   */
  selector?: number;
  /**
   * @remarks
   * Indicates its priority and handling method, used in CAA records.
   * 
   * @example
   * issue
   */
  tag?: string;
  /**
   * @remarks
   * The certificate type of the record (in CERT records), or the public key type (in SSHFP records).
   * 
   * @example
   * 0
   */
  type?: number;
  /**
   * @remarks
   * The usage identifier of the record. Valid values: 0 to 255. Applicable to SMIMEA and TLSA records.
   * 
   * @example
   * 0
   */
  usage?: number;
  /**
   * @remarks
   * The record value or part of the record content. This value is returned when the record is A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, or URI. It has different meanings based on types of records:
   * 
   * *   **A/AAAA**: the IP addresses. IP addresses are separated by commas (,). There is at least one IPv4 address.
   * *   **CNAME**: the mapped domain name.
   * *   **NS**: the nameservers for the domain name.
   * *   **MX**: a valid domain name of the target mail server.
   * *   **TXT**: a valid text string.
   * *   **CAA**: a valid domain name of the certificate authority.
   * *   **SRV**: a valid domain name of the target host.
   * *   **URI**: a valid URI string.
   * 
   * @example
   * example.com
   */
  value?: string;
  /**
   * @remarks
   * The weight of the record. Applicable to SRV and URI records.
   * 
   * @example
   * 0
   */
  weight?: number;
  static names(): { [key: string]: string } {
    return {
      algorithm: 'Algorithm',
      certificate: 'Certificate',
      fingerprint: 'Fingerprint',
      flag: 'Flag',
      keyTag: 'KeyTag',
      matchingType: 'MatchingType',
      port: 'Port',
      priority: 'Priority',
      selector: 'Selector',
      tag: 'Tag',
      type: 'Type',
      usage: 'Usage',
      value: 'Value',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      algorithm: 'number',
      certificate: 'string',
      fingerprint: 'string',
      flag: 'number',
      keyTag: 'number',
      matchingType: 'number',
      port: 'number',
      priority: 'number',
      selector: 'number',
      tag: 'string',
      type: 'number',
      usage: 'number',
      value: 'string',
      weight: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateRecordsResponseBodyRecordResultListFailed extends $dara.Model {
  /**
   * @remarks
   * The business scenario of the record for acceleration. Valid values:
   * 
   * *   **image_video**
   * *   **api**
   * *   **web**
   * 
   * @example
   * web
   */
  bizName?: string;
  /**
   * @remarks
   * The DNS information about the record, which contains various types of record values and their related attributes.
   * 
   * @example
   * {"value":"2.2.2.2"}
   */
  data?: BatchCreateRecordsResponseBodyRecordResultListFailedData;
  /**
   * @remarks
   * The result description.
   */
  description?: string;
  /**
   * @remarks
   * Indicates whether the record is proxied. Only CNAME and A/AAAA records can be proxied. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  proxied?: boolean;
  /**
   * @remarks
   * The record ID.
   * 
   * @example
   * 1234567890123
   */
  recordId?: number;
  /**
   * @remarks
   * The record name.
   * 
   * @example
   * a.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The DNS type of the record, such as **A/AAAA, CNAME, and TXT**.
   * 
   * @example
   * A/AAAA
   */
  recordType?: string;
  /**
   * @remarks
   * The origin type of the CNAME record. This field is left empty for other types of records. The type of the origin server. Valid values:
   * 
   * *   **OSS**: OSS bucket.
   * *   **S3**: S3 bucket.
   * *   **LB**: load balancer.
   * *   **OP**: origin pool.
   * *   **Domain**: domain name.
   * 
   * @example
   * OSS
   */
  sourceType?: string;
  /**
   * @remarks
   * The TTL of the record. Unit: seconds. If the value is 1, the TTL of the record is determined by the system.
   * 
   * @example
   * 60
   */
  ttl?: number;
  static names(): { [key: string]: string } {
    return {
      bizName: 'BizName',
      data: 'Data',
      description: 'Description',
      proxied: 'Proxied',
      recordId: 'RecordId',
      recordName: 'RecordName',
      recordType: 'RecordType',
      sourceType: 'SourceType',
      ttl: 'Ttl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizName: 'string',
      data: BatchCreateRecordsResponseBodyRecordResultListFailedData,
      description: 'string',
      proxied: 'boolean',
      recordId: 'number',
      recordName: 'string',
      recordType: 'string',
      sourceType: 'string',
      ttl: 'number',
    };
  }

  validate() {
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateRecordsResponseBodyRecordResultListSuccessData extends $dara.Model {
  /**
   * @remarks
   * The encryption algorithm used for the record. Valid values: 0 to 255. Applicable to CERT and SSHFP records.
   * 
   * @example
   * 0
   */
  algorithm?: number;
  /**
   * @remarks
   * The public key of the certificate. Applicable to CERT, SMIMEA, and TLSA records.
   * 
   * @example
   * dGVzdGFkYWxrcw==
   */
  certificate?: string;
  /**
   * @remarks
   * The public key fingerprint of the record. Applicable to SSHFP records.
   * 
   * @example
   * abcdef1234567890
   */
  fingerprint?: string;
  /**
   * @remarks
   * The flag bit of the record. Indicates its priority and handling method, used in CAA records.
   * 
   * @example
   * 128
   */
  flag?: number;
  /**
   * @remarks
   * The public key identification for the record. Valid values: 0 to 65535. Applicable to CERT records.
   * 
   * @example
   * 0
   */
  keyTag?: number;
  /**
   * @remarks
   * The algorithm policy used to match or validate the certificate. Valid values: 0 to 255. Applicable to SMIMEA and TLSA records.
   * 
   * @example
   * 0
   */
  matchingType?: number;
  /**
   * @remarks
   * The port of the record. Valid values: 0 to 65535. Exclusive to SRV records.
   * 
   * @example
   * 0
   */
  port?: number;
  /**
   * @remarks
   * The priority of the record. Valid values: 0 to 65535. A smaller value indicates a higher priority. Applicable to MX, SRV, and URI records.
   * 
   * @example
   * 10
   */
  priority?: number;
  /**
   * @remarks
   * The type of certificate or public key. Valid values: 0 to 255. Applicable to SMIMEA and TLSA records.
   * 
   * @example
   * 0
   */
  selector?: number;
  /**
   * @remarks
   * The label of a CAA record, which indicates its specific type and purpose, such as issue, issuewild, and iodef.
   * 
   * @example
   * issue
   */
  tag?: string;
  /**
   * @remarks
   * The certificate type of the record (in CERT records), or the public key type (in SSHFP records).
   * 
   * @example
   * 0
   */
  type?: number;
  /**
   * @remarks
   * The usage identifier of the record. Valid values: 0 to 255. Applicable to SMIMEA and TLSA records.
   * 
   * @example
   * 0
   */
  usage?: number;
  /**
   * @remarks
   * The record value or part of the record content. This value is returned when the record is A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, or URI. It has different meanings based on types of records:
   * 
   * *   **A/AAAA**: the IP addresses. Multiple IPs are separated by commas (,). There is at least one IPv4 address.
   * *   **CNAME**: the mapped domain name.
   * *   **NS**: the nameservers for the domain name.
   * *   **MX**: a valid domain name of the target mail server.
   * *   **TXT**: a valid text string.
   * *   **CAA**: a valid domain name of the certificate authority.
   * *   **SRV**: a valid domain name of the target host.
   * *   **URI**: a valid URI string.
   * 
   * @example
   * example.com
   */
  value?: string;
  /**
   * @remarks
   * The weight of the record. Valid values: 0 to 65535. Applicable to SRV and URI records.
   * 
   * @example
   * 0
   */
  weight?: number;
  static names(): { [key: string]: string } {
    return {
      algorithm: 'Algorithm',
      certificate: 'Certificate',
      fingerprint: 'Fingerprint',
      flag: 'Flag',
      keyTag: 'KeyTag',
      matchingType: 'MatchingType',
      port: 'Port',
      priority: 'Priority',
      selector: 'Selector',
      tag: 'Tag',
      type: 'Type',
      usage: 'Usage',
      value: 'Value',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      algorithm: 'number',
      certificate: 'string',
      fingerprint: 'string',
      flag: 'number',
      keyTag: 'number',
      matchingType: 'number',
      port: 'number',
      priority: 'number',
      selector: 'number',
      tag: 'string',
      type: 'number',
      usage: 'number',
      value: 'string',
      weight: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateRecordsResponseBodyRecordResultListSuccess extends $dara.Model {
  /**
   * @remarks
   * The business scenario of the record for acceleration. Valid values:
   * 
   * *   **image_video**
   * *   **api**
   * *   **web**
   * 
   * @example
   * web
   */
  bizName?: string;
  /**
   * @remarks
   * The DNS record information.
   * 
   * @example
   * {"value":"1.1.1.1"}
   */
  data?: BatchCreateRecordsResponseBodyRecordResultListSuccessData;
  /**
   * @remarks
   * The result description.
   * 
   * @example
   * success
   */
  description?: string;
  /**
   * @remarks
   * Indicates whether the record is proxied. Only CNAME and A/AAAA records can be proxied. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  proxied?: boolean;
  /**
   * @remarks
   * The record ID.
   * 
   * @example
   * 1234567890123
   */
  recordId?: number;
  /**
   * @remarks
   * The record name.
   * 
   * @example
   * www.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The DNS type of the record, such as **A/AAAA, CNAME, and TXT**.
   * 
   * @example
   * A/AAAA
   */
  recordType?: string;
  /**
   * @remarks
   * The origin type of the CNAME record. This field is left empty for other types of records. The type of the origin server. Valid values:
   * 
   * *   **OSS**: OSS bucket.
   * *   **S3**: S3 bucket.
   * *   **LB**: load balancer.
   * *   **OP**: origin pool.
   * *   **Domain**: domain name.
   * 
   * @example
   * OSS
   */
  sourceType?: string;
  /**
   * @remarks
   * The TTL of the record. Unit: seconds. If the value is 1, the TTL of the record is determined by the system.
   * 
   * @example
   * 60
   */
  ttl?: number;
  static names(): { [key: string]: string } {
    return {
      bizName: 'BizName',
      data: 'Data',
      description: 'Description',
      proxied: 'Proxied',
      recordId: 'RecordId',
      recordName: 'RecordName',
      recordType: 'RecordType',
      sourceType: 'SourceType',
      ttl: 'Ttl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizName: 'string',
      data: BatchCreateRecordsResponseBodyRecordResultListSuccessData,
      description: 'string',
      proxied: 'boolean',
      recordId: 'number',
      recordName: 'string',
      recordType: 'string',
      sourceType: 'string',
      ttl: 'number',
    };
  }

  validate() {
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateRecordsResponseBodyRecordResultList extends $dara.Model {
  /**
   * @remarks
   * The records that failed to be created.
   */
  failed?: BatchCreateRecordsResponseBodyRecordResultListFailed[];
  /**
   * @remarks
   * The records that have been created.
   */
  success?: BatchCreateRecordsResponseBodyRecordResultListSuccess[];
  /**
   * @remarks
   * The total number of returned records.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      failed: 'Failed',
      success: 'Success',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failed: { 'type': 'array', 'itemType': BatchCreateRecordsResponseBodyRecordResultListFailed },
      success: { 'type': 'array', 'itemType': BatchCreateRecordsResponseBodyRecordResultListSuccess },
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.failed)) {
      $dara.Model.validateArray(this.failed);
    }
    if(Array.isArray(this.success)) {
      $dara.Model.validateArray(this.success);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetExpressionFieldsRequestExpressions extends $dara.Model {
  /**
   * @remarks
   * The content of the regular expression.
   * 
   * @example
   * ip.src eq 1.1.1.1
   */
  expression?: string;
  /**
   * @remarks
   * The ID of the regular expression.
   * 
   * @example
   * 1
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      expression: 'Expression',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expression: 'string',
      id: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetExpressionFieldsResponseBodyFields extends $dara.Model {
  /**
   * @remarks
   * The fields that match the regular expression.
   */
  fields?: string[];
  /**
   * @remarks
   * The ID of the regular expression, which corresponds to the expression ID in the request parameter.
   * 
   * @example
   * 1
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      fields: 'Fields',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fields: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.fields)) {
      $dara.Model.validateArray(this.fields);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPutKvRequestKvList extends $dara.Model {
  /**
   * @remarks
   * The time when the key-value pair expires, which cannot be earlier than the current time. The value is a timestamp in seconds. If you specify both Expiration and ExpirationTtl, only ExpirationTtl takes effect.
   * 
   * @example
   * 1690081381
   */
  expiration?: number;
  /**
   * @remarks
   * The relative expiration time. Unit: seconds. If you specify both Expiration and ExpirationTtl, only ExpirationTtl takes effect.
   * 
   * @example
   * 3600
   */
  expirationTtl?: number;
  /**
   * @remarks
   * The key name. The name can be up to 512 characters in length and cannot contain spaces or backslashes (\\\\).
   * 
   * This parameter is required.
   * 
   * @example
   * test_key
   */
  key?: string;
  /**
   * @remarks
   * The key content.
   * 
   * This parameter is required.
   * 
   * @example
   * test_value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      expiration: 'Expiration',
      expirationTtl: 'ExpirationTtl',
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expiration: 'number',
      expirationTtl: 'number',
      key: 'string',
      value: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeContainerAppVersionRequestContainersACRImageInfo extends $dara.Model {
  /**
   * @remarks
   * The domain name of the Container Registry image.
   * 
   * @example
   * 1500.***.net
   */
  domain?: string;
  /**
   * @remarks
   * The ID of the Container Registry instance.
   * 
   * @example
   * xcdn-9axbo****
   */
  instanceId?: string;
  /**
   * @remarks
   * Specifies whether the image is an enterprise-level Container Registry image.
   * 
   * @example
   * false
   */
  isEnterpriseRegistry?: boolean;
  /**
   * @remarks
   * The regions in which the Container Registry instance resides.
   * 
   * @example
   * cn-shanghai
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the image repository.
   * 
   * @example
   * crr-h1ghghu60ct****
   */
  repoId?: string;
  /**
   * @remarks
   * The name of the image repository.
   * 
   * @example
   * test_71
   */
  repoName?: string;
  /**
   * @remarks
   * The namespace to which the image repository belongs.
   * 
   * @example
   * safeline
   */
  repoNamespace?: string;
  /**
   * @remarks
   * The tag of the Container Registry image.
   * 
   * @example
   * 3.40.2
   */
  tag?: string;
  /**
   * @remarks
   * The URL of the Container Registry image tag.
   */
  tagUrl?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      instanceId: 'InstanceId',
      isEnterpriseRegistry: 'IsEnterpriseRegistry',
      regionId: 'RegionId',
      repoId: 'RepoId',
      repoName: 'RepoName',
      repoNamespace: 'RepoNamespace',
      tag: 'Tag',
      tagUrl: 'TagUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      instanceId: 'string',
      isEnterpriseRegistry: 'boolean',
      regionId: 'string',
      repoId: 'string',
      repoName: 'string',
      repoNamespace: 'string',
      tag: 'string',
      tagUrl: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeContainerAppVersionRequestContainersProbeContent extends $dara.Model {
  /**
   * @remarks
   * The command of the exec type probe.
   * 
   * @example
   * echo ok
   */
  command?: string;
  /**
   * @remarks
   * The number of consecutive failed health checks required for a container to be considered as unhealthy.
   * 
   * @example
   * 3
   */
  failureThreshold?: number;
  /**
   * @remarks
   * The domain name that is used for health checks.
   * 
   * @example
   * www.rewrite.com
   */
  host?: string;
  /**
   * @remarks
   * The request headers that are included in the container health check request.
   * 
   * @example
   * [{\\"Content-Type\\":\\"application/json\\"}]
   */
  httpHeaders?: string;
  /**
   * @remarks
   * The latency for container probe initialization.
   * 
   * @example
   * 1
   */
  initialDelaySeconds?: number;
  /**
   * @remarks
   * The health check path.
   * 
   * @example
   * /
   */
  path?: string;
  /**
   * @remarks
   * The interval between container health checks.
   * 
   * @example
   * 1
   */
  periodSeconds?: number;
  /**
   * @remarks
   * The health check port.
   * 
   * @example
   * 9991
   */
  port?: number;
  /**
   * @remarks
   * The protocol that the container health check request uses.
   * 
   * @example
   * http
   */
  scheme?: string;
  /**
   * @remarks
   * The number of consecutive successful health checks required for a container to be considered as healthy.
   * 
   * @example
   * 1
   */
  successThreshold?: number;
  /**
   * @remarks
   * The timeout period of the container health check.
   * 
   * @example
   * 1
   */
  timeoutSeconds?: number;
  static names(): { [key: string]: string } {
    return {
      command: 'Command',
      failureThreshold: 'FailureThreshold',
      host: 'Host',
      httpHeaders: 'HttpHeaders',
      initialDelaySeconds: 'InitialDelaySeconds',
      path: 'Path',
      periodSeconds: 'PeriodSeconds',
      port: 'Port',
      scheme: 'Scheme',
      successThreshold: 'SuccessThreshold',
      timeoutSeconds: 'TimeoutSeconds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      command: 'string',
      failureThreshold: 'number',
      host: 'string',
      httpHeaders: 'string',
      initialDelaySeconds: 'number',
      path: 'string',
      periodSeconds: 'number',
      port: 'number',
      scheme: 'string',
      successThreshold: 'number',
      timeoutSeconds: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeContainerAppVersionRequestContainers extends $dara.Model {
  /**
   * @remarks
   * The information about the Container Registry image.
   */
  ACRImageInfo?: CreateEdgeContainerAppVersionRequestContainersACRImageInfo;
  /**
   * @remarks
   * The arguments that are passed to the container startup command. Separate the parameters with spaces.
   * 
   * @example
   * -a
   */
  args?: string;
  /**
   * @remarks
   * The command that is used to start the container. Separate the arguments with spaces.
   * 
   * @example
   * nginx
   */
  command?: string;
  /**
   * @remarks
   * The environment variables. Separate the environment variables with commas (,).
   * 
   * @example
   * VITE_APP_TITLE=My App
   */
  envVariables?: string;
  /**
   * @remarks
   * The address of the image.
   * 
   * This parameter is required.
   * 
   * @example
   * registry-vpc.cn-shenzhen.aliyuncs.com/lihe****h/ea****ts_serv****am:3.**
   */
  image?: string;
  /**
   * @remarks
   * Specifies whether the image is a Container Registry image.
   * 
   * This parameter is required.
   * 
   * @example
   * false
   */
  isACRImage?: boolean;
  /**
   * @remarks
   * The name of the container. The name must be unique in the same container group.
   * 
   * This parameter is required.
   * 
   * @example
   * lxg-demo-er
   */
  name?: string;
  /**
   * @remarks
   * The command that is run before the container is started. Separate the arguments with spaces.
   * 
   * @example
   * sh poststart.sh "echo hello world"
   */
  postStart?: string;
  /**
   * @remarks
   * The command that is run before the container is stopped. Separate the arguments with spaces.
   * 
   * @example
   * sh prestop.sh "echo hello world"
   */
  preStop?: string;
  /**
   * @remarks
   * The content of the container health probe.
   * 
   * This parameter is required.
   */
  probeContent?: CreateEdgeContainerAppVersionRequestContainersProbeContent;
  /**
   * @remarks
   * The type of the probe. Valid values:
   * 
   * *   exec: the command type.
   * *   tcpSocket: the TCP probe type.
   * *   httpGet: the HTTP access type.
   * 
   * This parameter is required.
   * 
   * @example
   * exec
   */
  probeType?: string;
  /**
   * @remarks
   * The compute specification of the container. Valid values: 1C2G, 2C4G, 2C8G, 4C8G, 4C16G, 8C16G, and 8C32G.
   * 
   * This parameter is required.
   * 
   * @example
   * 1C2G
   */
  spec?: string;
  /**
   * @remarks
   * The storage capacity. Valid values: 0.5G, 10G, 20G, and 30G.
   * 
   * This parameter is required.
   * 
   * @example
   * 0.5G
   */
  storage?: string;
  static names(): { [key: string]: string } {
    return {
      ACRImageInfo: 'ACRImageInfo',
      args: 'Args',
      command: 'Command',
      envVariables: 'EnvVariables',
      image: 'Image',
      isACRImage: 'IsACRImage',
      name: 'Name',
      postStart: 'PostStart',
      preStop: 'PreStop',
      probeContent: 'ProbeContent',
      probeType: 'ProbeType',
      spec: 'Spec',
      storage: 'Storage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ACRImageInfo: CreateEdgeContainerAppVersionRequestContainersACRImageInfo,
      args: 'string',
      command: 'string',
      envVariables: 'string',
      image: 'string',
      isACRImage: 'boolean',
      name: 'string',
      postStart: 'string',
      preStop: 'string',
      probeContent: CreateEdgeContainerAppVersionRequestContainersProbeContent,
      probeType: 'string',
      spec: 'string',
      storage: 'string',
    };
  }

  validate() {
    if(this.ACRImageInfo && typeof (this.ACRImageInfo as any).validate === 'function') {
      (this.ACRImageInfo as any).validate();
    }
    if(this.probeContent && typeof (this.probeContent as any).validate === 'function') {
      (this.probeContent as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHttpRequestHeaderModificationRuleRequestRequestHeaderModification extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * headername
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * add
   */
  operation?: string;
  /**
   * @example
   * headervalue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      operation: 'Operation',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      operation: 'string',
      value: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHttpResponseHeaderModificationRuleRequestResponseHeaderModification extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * headername
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * add
   */
  operation?: string;
  /**
   * @example
   * headervalue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      operation: 'Operation',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      operation: 'string',
      value: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLoadBalancerRequestAdaptiveRouting extends $dara.Model {
  failoverAcrossPools?: boolean;
  static names(): { [key: string]: string } {
    return {
      failoverAcrossPools: 'FailoverAcrossPools',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failoverAcrossPools: 'boolean',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLoadBalancerRequestMonitor extends $dara.Model {
  consecutiveDown?: number;
  consecutiveUp?: number;
  expectedCodes?: string;
  followRedirects?: boolean;
  header?: any;
  interval?: number;
  method?: string;
  path?: string;
  port?: number;
  timeout?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      consecutiveDown: 'ConsecutiveDown',
      consecutiveUp: 'ConsecutiveUp',
      expectedCodes: 'ExpectedCodes',
      followRedirects: 'FollowRedirects',
      header: 'Header',
      interval: 'Interval',
      method: 'Method',
      path: 'Path',
      port: 'Port',
      timeout: 'Timeout',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consecutiveDown: 'number',
      consecutiveUp: 'number',
      expectedCodes: 'string',
      followRedirects: 'boolean',
      header: 'any',
      interval: 'number',
      method: 'string',
      path: 'string',
      port: 'number',
      timeout: 'number',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLoadBalancerRequestRandomSteering extends $dara.Model {
  defaultWeight?: number;
  poolWeights?: { [key: string]: number };
  static names(): { [key: string]: string } {
    return {
      defaultWeight: 'DefaultWeight',
      poolWeights: 'PoolWeights',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultWeight: 'number',
      poolWeights: { 'type': 'map', 'keyType': 'string', 'valueType': 'number' },
    };
  }

  validate() {
    if(this.poolWeights) {
      $dara.Model.validateMap(this.poolWeights);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLoadBalancerRequestRulesFixedResponse extends $dara.Model {
  contentType?: string;
  location?: string;
  messageBody?: string;
  statusCode?: number;
  static names(): { [key: string]: string } {
    return {
      contentType: 'ContentType',
      location: 'Location',
      messageBody: 'MessageBody',
      statusCode: 'StatusCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentType: 'string',
      location: 'string',
      messageBody: 'string',
      statusCode: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLoadBalancerRequestRules extends $dara.Model {
  fixedResponse?: CreateLoadBalancerRequestRulesFixedResponse;
  overrides?: any;
  rule?: string;
  ruleEnable?: string;
  ruleName?: string;
  sequence?: number;
  terminates?: boolean;
  static names(): { [key: string]: string } {
    return {
      fixedResponse: 'FixedResponse',
      overrides: 'Overrides',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      terminates: 'Terminates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fixedResponse: CreateLoadBalancerRequestRulesFixedResponse,
      overrides: 'any',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'number',
      terminates: 'boolean',
    };
  }

  validate() {
    if(this.fixedResponse && typeof (this.fixedResponse as any).validate === 'function') {
      (this.fixedResponse as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOriginPoolRequestOriginsAuthConf extends $dara.Model {
  accessKey?: string;
  authType?: string;
  region?: string;
  secretKey?: string;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      accessKey: 'AccessKey',
      authType: 'AuthType',
      region: 'Region',
      secretKey: 'SecretKey',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKey: 'string',
      authType: 'string',
      region: 'string',
      secretKey: 'string',
      version: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOriginPoolRequestOrigins extends $dara.Model {
  address?: string;
  authConf?: CreateOriginPoolRequestOriginsAuthConf;
  enabled?: boolean;
  header?: any;
  name?: string;
  type?: string;
  weight?: number;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      authConf: 'AuthConf',
      enabled: 'Enabled',
      header: 'Header',
      name: 'Name',
      type: 'Type',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      authConf: CreateOriginPoolRequestOriginsAuthConf,
      enabled: 'boolean',
      header: 'any',
      name: 'string',
      type: 'string',
      weight: 'number',
    };
  }

  validate() {
    if(this.authConf && typeof (this.authConf as any).validate === 'function') {
      (this.authConf as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRecordRequestAuthConf extends $dara.Model {
  /**
   * @remarks
   * The access key of the account to which the origin server belongs. This parameter is required when the SourceType is OSS, and AuthType is private_cross_account, or when the SourceType is S3 and AuthType is private.
   * 
   * @example
   * u0Nkg5gBK*******QF5wvKMM504JUHt
   */
  accessKey?: string;
  /**
   * @remarks
   * The authentication type of the origin server. Different origins support different authentication types. The type of origin refers to the SourceType parameter in this operation. If the type of origin is OSS or S3, you must specify the authentication type of the origin. Valid values:
   * 
   * *   **public**: public read. Select this value when the origin type is OSS or S3 and the origin access is public read.
   * *   **private**: private read. Select this value when the origin type is S3 and the origin access is private read.
   * *   **private_same_account**: private read under the same account. Select this value when the origin type is OSS, the origins belong to the same Alibaba Cloud account, and the origins have private read access.
   * *   **private_cross_account**: private read cross accounts. Select this value when the origin type is OSS, the origins belong to different Alibaba Cloud accounts, and the origins have private read access.
   * 
   * @example
   * private
   */
  authType?: string;
  /**
   * @remarks
   * The region of the origin. If the origin type is S3, you must specify this value. You can get the region information from the official website of S3.
   * 
   * @example
   * us-east-1
   */
  region?: string;
  /**
   * @remarks
   * The secret access key of the account to which the origin server belongs. This parameter is required when the SourceType is OSS, and AuthType is private_same_account, or when the SourceType is S3 and AuthType is private.
   * 
   * @example
   * VIxuvJSA2S03f******kp208dy5w7
   */
  secretKey?: string;
  /**
   * @remarks
   * The version of the signature algorithm. This parameter is required when the origin type is S3 and AuthType is private. The following two types are supported:
   * 
   * *   **v2**
   * *   **v4**
   * 
   * If you leave this parameter empty, the default value v4 is used.
   * 
   * @example
   * v4
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      accessKey: 'AccessKey',
      authType: 'AuthType',
      region: 'Region',
      secretKey: 'SecretKey',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKey: 'string',
      authType: 'string',
      region: 'string',
      secretKey: 'string',
      version: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRecordRequestData extends $dara.Model {
  /**
   * @remarks
   * The encryption algorithm used for the record, specified within the range from 0 to 255. This parameter is required when you add CERT or SSHFP records.
   * 
   * @example
   * 1
   */
  algorithm?: number;
  /**
   * @remarks
   * The public key of the certificate. This parameter is required when you add CERT, SMIMEA, or TLSA records.
   * 
   * @example
   * dGVzdGFkYWxrcw==
   */
  certificate?: string;
  /**
   * @remarks
   * The public key fingerprint of the record. This parameter is required when you add a SSHFP record.
   * 
   * @example
   * abcdef1234567890
   */
  fingerprint?: string;
  /**
   * @remarks
   * The flag bit of the record. The Flag for a CAA record indicates its priority and how it is processed, specified within the range of 0 to 255. This parameter is required when you add a CAA record.
   * 
   * @example
   * 128
   */
  flag?: number;
  /**
   * @remarks
   * The public key identification for the record, specified within the range of 0 to 65,535. This parameter is required when you add a CAA record.
   * 
   * @example
   * 0
   */
  keyTag?: number;
  /**
   * @remarks
   * The algorithm policy used to match or validate the certificate, specified within the range 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
   * 
   * @example
   * 1
   */
  matchingType?: number;
  /**
   * @remarks
   * The port of the record, specified within the range of 0 to 65,535. This parameter is required when you add an SRV record.
   * 
   * @example
   * 0
   */
  port?: number;
  /**
   * @remarks
   * The priority of the record, specified within the range of 0 to 65,535. A smaller value indicates a higher priority. This parameter is required when you add MX, SRV, and URI records.
   * 
   * @example
   * 10
   */
  priority?: number;
  /**
   * @remarks
   * The type of certificate or public key, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
   * 
   * @example
   * 1
   */
  selector?: number;
  /**
   * @remarks
   * The label of the record. The Tag of a CAA record indicate its specific type and usage. This parameter is required when you add a CAA record. Valid values:
   * 
   * *   **issue**: indicates that a CA is authorized to issue a certificate for the domain name. This is usually followed by the domain name of the CA.
   * *   **issuewild**: indicates that a CA is authorized to issue a wildcard certificate (such as \\*.example.com) for the domain name.
   * *   **iodef**: specifies a URI to receive reports about CAA record violations.
   * 
   * @example
   * issue
   */
  tag?: string;
  /**
   * @remarks
   * The certificate type of the record (in CERT records), or the public key type (in SSHFP records). This parameter is required when you add CERT or SSHFP records.
   * 
   * @example
   * RSA
   */
  type?: number;
  /**
   * @remarks
   * The usage identifier of the record, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
   * 
   * @example
   * 1
   */
  usage?: number;
  /**
   * @remarks
   * Record value or part of the record content. This parameter is required when you add A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, and URI records. It has different meanings based on types of records:
   * 
   * *   **A/AAAA**: the IP address(es). Separate IP addresses with commas (,). You must have at least one IPv4 address.
   * *   **CNAME**: the target domain name.
   * *   **NS**: the name servers for the domain name.
   * *   **MX**: a valid domain name of the target mail server.
   * *   **TXT**: a valid text string.
   * *   **CAA**: a valid domain name of the certificate authority.
   * *   **SRV**: a valid domain name of the target host.
   * *   **URI**: a valid URI string.
   * 
   * @example
   * example.com
   */
  value?: string;
  /**
   * @remarks
   * The weight of the record, specified within the range of 0 to 65,535. This parameter is required when you add SRV or URI records.
   * 
   * @example
   * 0
   */
  weight?: number;
  static names(): { [key: string]: string } {
    return {
      algorithm: 'Algorithm',
      certificate: 'Certificate',
      fingerprint: 'Fingerprint',
      flag: 'Flag',
      keyTag: 'KeyTag',
      matchingType: 'MatchingType',
      port: 'Port',
      priority: 'Priority',
      selector: 'Selector',
      tag: 'Tag',
      type: 'Type',
      usage: 'Usage',
      value: 'Value',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      algorithm: 'number',
      certificate: 'string',
      fingerprint: 'string',
      flag: 'number',
      keyTag: 'number',
      matchingType: 'number',
      port: 'number',
      priority: 'number',
      selector: 'number',
      tag: 'string',
      type: 'number',
      usage: 'number',
      value: 'string',
      weight: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduledPreloadExecutionsRequestExecutions extends $dara.Model {
  /**
   * @remarks
   * The end time of the prefetch plans.
   * 
   * @example
   * 2024-06-04T02:02:09Z
   */
  endTime?: string;
  /**
   * @remarks
   * The time interval between each batch execution. Unit: seconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 30
   */
  interval?: number;
  /**
   * @remarks
   * The number of URLs prefetched in each batch.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  sliceLen?: number;
  /**
   * @remarks
   * The start time of the prefetch plans.
   * 
   * @example
   * 2024-06-03T16:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      interval: 'Interval',
      sliceLen: 'SliceLen',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      interval: 'number',
      sliceLen: 'number',
      startTime: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduledPreloadExecutionsResponseBodyFailedExecutions extends $dara.Model {
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 15685865xxx14622
   */
  aliUid?: string;
  /**
   * @remarks
   * The end time of the prefetch plans.
   * 
   * @example
   * 2024-06-03T02:43:35Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the prefetch plan.
   * 
   * @example
   * 66599bd7397885b43804901c
   */
  id?: string;
  /**
   * @remarks
   * The time interval between each batch execution. Unit: seconds.
   * 
   * @example
   * 60
   */
  interval?: number;
  /**
   * @remarks
   * The ID of the prefetch task.
   * 
   * @example
   * 665d3af3621bccf3fe29e1a4
   */
  jobId?: string;
  /**
   * @remarks
   * The number of URLs prefetched in each batch.
   * 
   * @example
   * 10
   */
  sliceLen?: number;
  /**
   * @remarks
   * The start time of the prefetch plans.
   * 
   * @example
   * 2024-06-02T02:43:35Z
   */
  startTime?: string;
  /**
   * @remarks
   * The status of the prefetch plan. Valid values:
   * 
   * *   **waiting**
   * *   **running**
   * *   **finished**
   * *   **failed**
   * *   **stopped**
   * 
   * @example
   * running
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      aliUid: 'AliUid',
      endTime: 'EndTime',
      id: 'Id',
      interval: 'Interval',
      jobId: 'JobId',
      sliceLen: 'SliceLen',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliUid: 'string',
      endTime: 'string',
      id: 'string',
      interval: 'number',
      jobId: 'string',
      sliceLen: 'number',
      startTime: 'string',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduledPreloadExecutionsResponseBodySuccessExecutions extends $dara.Model {
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 15685865xxx14622
   */
  aliUid?: string;
  /**
   * @remarks
   * The end time of the prefetch plans.
   * 
   * @example
   * 2024-06-03T02:43:35Z
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the prefetch plan.
   * 
   * @example
   * 66599bd7397885b43804901c
   */
  id?: string;
  /**
   * @remarks
   * The time interval between each batch execution. Unit: seconds.
   * 
   * @example
   * 60
   */
  interval?: number;
  /**
   * @remarks
   * The ID of the prefetch task.
   * 
   * @example
   * 665d3af3621bccf3fe29e1a4
   */
  jobId?: string;
  /**
   * @remarks
   * The number of URLs prefetched in each batch.
   * 
   * @example
   * 10
   */
  sliceLen?: number;
  /**
   * @remarks
   * The start time of the prefetch plans.
   * 
   * @example
   * 2024-06-02T02:43:35Z
   */
  startTime?: string;
  /**
   * @remarks
   * The status of the prefetch plan. Valid values:
   * 
   * *   **waiting**
   * *   **running**
   * *   **finished**
   * *   **failed**
   * *   **stopped**
   * 
   * @example
   * failed
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      aliUid: 'AliUid',
      endTime: 'EndTime',
      id: 'Id',
      interval: 'Interval',
      jobId: 'JobId',
      sliceLen: 'SliceLen',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliUid: 'string',
      endTime: 'string',
      id: 'string',
      interval: 'number',
      jobId: 'string',
      sliceLen: 'number',
      startTime: 'string',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteDeliveryTaskRequestHttpDeliveryStandardAuthParam extends $dara.Model {
  /**
   * @remarks
   * The validity period of the signature.
   * 
   * >  The value must be greater than 0. We recommend that you specify a value that is greater than 300.
   * 
   * @example
   * 300
   */
  expiredTime?: number;
  /**
   * @remarks
   * The private key.
   * 
   * @example
   * ***
   */
  privateKey?: string;
  /**
   * @remarks
   * The URI path for server authentication.
   * 
   * @example
   * v1/log/upload
   */
  urlPath?: string;
  static names(): { [key: string]: string } {
    return {
      expiredTime: 'ExpiredTime',
      privateKey: 'PrivateKey',
      urlPath: 'UrlPath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expiredTime: 'number',
      privateKey: 'string',
      urlPath: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteDeliveryTaskRequestHttpDelivery extends $dara.Model {
  /**
   * @remarks
   * The compression method. By default, data is not compressed.
   * 
   * @example
   * gzip
   */
  compress?: string;
  /**
   * @remarks
   * The address of the HTTP server.
   * 
   * @example
   * http://xxx.aliyun.com/v1/log/upload
   */
  destUrl?: string;
  /**
   * @remarks
   * The custom headers.
   */
  headerParam?: { [key: string]: HttpDeliveryHeaderParamValue };
  /**
   * @remarks
   * The prefix of the log delivery package.
   * 
   * @example
   * cdnVersion:1.0
   */
  logBodyPrefix?: string;
  /**
   * @remarks
   * The suffix of the log delivery package.
   * 
   * @example
   * cdnVersion:1.0
   */
  logBodySuffix?: string;
  /**
   * @remarks
   * The maximum size of data for each delivery. Unit: MB.
   * 
   * @example
   * 5
   */
  maxBatchMB?: number;
  /**
   * @remarks
   * The maximum number of entries for each delivery.
   * 
   * @example
   * 1000
   */
  maxBatchSize?: number;
  /**
   * @remarks
   * The maximum number of retries.
   * 
   * @example
   * 3
   */
  maxRetry?: number;
  /**
   * @remarks
   * The custom query parameters.
   */
  queryParam?: { [key: string]: HttpDeliveryQueryParamValue };
  /**
   * @remarks
   * Specifies whether to use server authentication.
   * 
   * @example
   * true
   */
  standardAuthOn?: boolean;
  /**
   * @remarks
   * The authentication configurations.
   */
  standardAuthParam?: CreateSiteDeliveryTaskRequestHttpDeliveryStandardAuthParam;
  /**
   * @remarks
   * The timeout period. Unit: seconds.
   * 
   * @example
   * 10
   */
  transformTimeout?: number;
  static names(): { [key: string]: string } {
    return {
      compress: 'Compress',
      destUrl: 'DestUrl',
      headerParam: 'HeaderParam',
      logBodyPrefix: 'LogBodyPrefix',
      logBodySuffix: 'LogBodySuffix',
      maxBatchMB: 'MaxBatchMB',
      maxBatchSize: 'MaxBatchSize',
      maxRetry: 'MaxRetry',
      queryParam: 'QueryParam',
      standardAuthOn: 'StandardAuthOn',
      standardAuthParam: 'StandardAuthParam',
      transformTimeout: 'TransformTimeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      compress: 'string',
      destUrl: 'string',
      headerParam: { 'type': 'map', 'keyType': 'string', 'valueType': HttpDeliveryHeaderParamValue },
      logBodyPrefix: 'string',
      logBodySuffix: 'string',
      maxBatchMB: 'number',
      maxBatchSize: 'number',
      maxRetry: 'number',
      queryParam: { 'type': 'map', 'keyType': 'string', 'valueType': HttpDeliveryQueryParamValue },
      standardAuthOn: 'boolean',
      standardAuthParam: CreateSiteDeliveryTaskRequestHttpDeliveryStandardAuthParam,
      transformTimeout: 'number',
    };
  }

  validate() {
    if(this.headerParam) {
      $dara.Model.validateMap(this.headerParam);
    }
    if(this.queryParam) {
      $dara.Model.validateMap(this.queryParam);
    }
    if(this.standardAuthParam && typeof (this.standardAuthParam as any).validate === 'function') {
      (this.standardAuthParam as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteDeliveryTaskRequestKafkaDelivery extends $dara.Model {
  /**
   * @remarks
   * The load balancing method.
   * 
   * @example
   * kafka.LeastBytes
   */
  balancer?: string;
  /**
   * @remarks
   * The brokers.
   */
  brokers?: string[];
  /**
   * @remarks
   * The compression method.
   * 
   * @example
   * gzip
   */
  compress?: string;
  /**
   * @remarks
   * The encryption method.
   * 
   * @example
   * plain
   */
  machanismType?: string;
  /**
   * @remarks
   * The password.
   * 
   * @example
   * ***
   */
  password?: string;
  /**
   * @remarks
   * The topic.
   * 
   * @example
   * dqc_test2
   */
  topic?: string;
  /**
   * @remarks
   * Specifies whether to enable authentication.
   * 
   * @example
   * true
   */
  userAuth?: boolean;
  /**
   * @remarks
   * The username.
   * 
   * @example
   * xxx
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      balancer: 'Balancer',
      brokers: 'Brokers',
      compress: 'Compress',
      machanismType: 'MachanismType',
      password: 'Password',
      topic: 'Topic',
      userAuth: 'UserAuth',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      balancer: 'string',
      brokers: { 'type': 'array', 'itemType': 'string' },
      compress: 'string',
      machanismType: 'string',
      password: 'string',
      topic: 'string',
      userAuth: 'boolean',
      userName: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.brokers)) {
      $dara.Model.validateArray(this.brokers);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteDeliveryTaskRequestOssDelivery extends $dara.Model {
  /**
   * @remarks
   * The ID of your Alibaba Cloud account.
   * 
   * @example
   * 1234***
   */
  aliuid?: string;
  /**
   * @remarks
   * The name of the OSS bucket.
   * 
   * @example
   * test_rlog
   */
  bucketName?: string;
  /**
   * @remarks
   * The prefix of the path in which you want to store logs.
   * 
   * @example
   * logriver-test/log
   */
  prefixPath?: string;
  /**
   * @remarks
   * The region in which the bucket is located.
   * 
   * @example
   * cn-beijing
   */
  region?: string;
  static names(): { [key: string]: string } {
    return {
      aliuid: 'Aliuid',
      bucketName: 'BucketName',
      prefixPath: 'PrefixPath',
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliuid: 'string',
      bucketName: 'string',
      prefixPath: 'string',
      region: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteDeliveryTaskRequestS3Delivery extends $dara.Model {
  /**
   * @remarks
   * The access key ID of your Amazon S3 account.
   * 
   * @example
   * LTAIKh***
   */
  accessKey?: string;
  /**
   * @remarks
   * The directory in the bucket.
   * 
   * @example
   * logriver-test/log
   */
  bucketPath?: string;
  /**
   * @remarks
   * The endpoint. This parameter is required when the S3Cmpt parameter is set to true.
   * 
   * @example
   * https://s3.oss-cn-hangzhou.aliyuncs.com
   */
  endpoint?: string;
  /**
   * @remarks
   * The prefix of the path in which you want to store logs.
   * 
   * @example
   * logriver-test/log
   */
  prefixPath?: string;
  /**
   * @remarks
   * The region ID of the service.
   * 
   * @example
   * cn-beijing
   */
  region?: string;
  /**
   * @remarks
   * Specifies whether the service is compatible with Amazon S3.
   * 
   * @example
   * true
   */
  s3Cmpt?: boolean;
  /**
   * @remarks
   * The secret access key of your Amazon S3 account.
   * 
   * @example
   * LDSIKh***
   */
  secretKey?: string;
  serverSideEncryption?: boolean;
  vertifyType?: string;
  static names(): { [key: string]: string } {
    return {
      accessKey: 'AccessKey',
      bucketPath: 'BucketPath',
      endpoint: 'Endpoint',
      prefixPath: 'PrefixPath',
      region: 'Region',
      s3Cmpt: 'S3Cmpt',
      secretKey: 'SecretKey',
      serverSideEncryption: 'ServerSideEncryption',
      vertifyType: 'VertifyType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKey: 'string',
      bucketPath: 'string',
      endpoint: 'string',
      prefixPath: 'string',
      region: 'string',
      s3Cmpt: 'boolean',
      secretKey: 'string',
      serverSideEncryption: 'boolean',
      vertifyType: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteDeliveryTaskRequestSlsDelivery extends $dara.Model {
  /**
   * @remarks
   * The name of the Logstore.
   * 
   * @example
   * accesslog-test
   */
  SLSLogStore?: string;
  /**
   * @remarks
   * The name of the SLS project.
   * 
   * @example
   * dcdn-test20240417
   */
  SLSProject?: string;
  /**
   * @remarks
   * The region in which the SLS project resides.
   * 
   * @example
   * cn-hangzhou
   */
  SLSRegion?: string;
  static names(): { [key: string]: string } {
    return {
      SLSLogStore: 'SLSLogStore',
      SLSProject: 'SLSProject',
      SLSRegion: 'SLSRegion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      SLSLogStore: 'string',
      SLSProject: 'string',
      SLSRegion: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserDeliveryTaskRequestHttpDeliveryStandardAuthParam extends $dara.Model {
  /**
   * @remarks
   * The validity period of the signature.
   * 
   * @example
   * 300
   */
  expiredTime?: number;
  /**
   * @remarks
   * The private key.
   * 
   * @example
   * xxxx
   */
  privateKey?: string;
  /**
   * @remarks
   * The URL path.
   * 
   * @example
   * v1/log/upload
   */
  urlPath?: string;
  static names(): { [key: string]: string } {
    return {
      expiredTime: 'ExpiredTime',
      privateKey: 'PrivateKey',
      urlPath: 'UrlPath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expiredTime: 'number',
      privateKey: 'string',
      urlPath: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserDeliveryTaskRequestHttpDelivery extends $dara.Model {
  /**
   * @remarks
   * The compression method.
   * 
   * @example
   * gzip
   */
  compress?: string;
  /**
   * @remarks
   * The address of the HTTP server.
   * 
   * @example
   * http://xxx.aliyun.com/v1/log/upload
   */
  destUrl?: string;
  /**
   * @remarks
   * The custom headers.
   */
  headerParam?: { [key: string]: HttpDeliveryHeaderParamValue };
  /**
   * @remarks
   * The ending separator.
   * 
   * @example
   * \\n
   */
  lastLogSplit?: string;
  /**
   * @remarks
   * The prefix of the log delivery package.
   * 
   * @example
   * cdnVersion:1.0
   */
  logBodyPrefix?: string;
  /**
   * @remarks
   * The suffix of the log delivery package.
   * 
   * @example
   * cdnVersion:1.0
   */
  logBodySuffix?: string;
  /**
   * @remarks
   * Specifies whether to enable log splitting. Default value: true.
   * 
   * @example
   * true
   */
  logSplit?: string;
  /**
   * @remarks
   * The log separator.
   * 
   * @example
   * \\n
   */
  logSplitWords?: string;
  /**
   * @remarks
   * The maximum backoff time. Unit: milliseconds.
   * 
   * @example
   * 1000
   */
  maxBackoffMS?: number;
  /**
   * @remarks
   * The maximum size of data for each delivery. Unit: MB.
   * 
   * @example
   * 5
   */
  maxBatchMB?: number;
  /**
   * @remarks
   * The maximum number of entries for each delivery.
   * 
   * @example
   * 1000
   */
  maxBatchSize?: number;
  /**
   * @remarks
   * The maximum number of retries.
   * 
   * @example
   * 3
   */
  maxRetry?: number;
  /**
   * @remarks
   * The minimum backoff time. Unit: milliseconds.
   * 
   * @example
   * 100
   */
  minBackoffMS?: number;
  /**
   * @remarks
   * The custom query parameters.
   */
  queryParam?: { [key: string]: HttpDeliveryQueryParamValue };
  /**
   * @remarks
   * The response field key used for success check.
   * 
   * @example
   * err_code
   */
  responseBodyKey?: string;
  /**
   * @remarks
   * Specifies whether to use server authentication.
   * 
   * @example
   * true
   */
  standardAuthOn?: boolean;
  /**
   * @remarks
   * The authentication configurations.
   */
  standardAuthParam?: CreateUserDeliveryTaskRequestHttpDeliveryStandardAuthParam;
  /**
   * @remarks
   * The custom code for a success.
   * 
   * @example
   * 200
   */
  successCode?: number;
  /**
   * @remarks
   * The timeout period. Unit: seconds.
   * 
   * @example
   * 10
   */
  transformTimeout?: number;
  static names(): { [key: string]: string } {
    return {
      compress: 'Compress',
      destUrl: 'DestUrl',
      headerParam: 'HeaderParam',
      lastLogSplit: 'LastLogSplit',
      logBodyPrefix: 'LogBodyPrefix',
      logBodySuffix: 'LogBodySuffix',
      logSplit: 'LogSplit',
      logSplitWords: 'LogSplitWords',
      maxBackoffMS: 'MaxBackoffMS',
      maxBatchMB: 'MaxBatchMB',
      maxBatchSize: 'MaxBatchSize',
      maxRetry: 'MaxRetry',
      minBackoffMS: 'MinBackoffMS',
      queryParam: 'QueryParam',
      responseBodyKey: 'ResponseBodyKey',
      standardAuthOn: 'StandardAuthOn',
      standardAuthParam: 'StandardAuthParam',
      successCode: 'SuccessCode',
      transformTimeout: 'TransformTimeout',
    };
  }

  static types(): { [key: string]: any } {
    return {
      compress: 'string',
      destUrl: 'string',
      headerParam: { 'type': 'map', 'keyType': 'string', 'valueType': HttpDeliveryHeaderParamValue },
      lastLogSplit: 'string',
      logBodyPrefix: 'string',
      logBodySuffix: 'string',
      logSplit: 'string',
      logSplitWords: 'string',
      maxBackoffMS: 'number',
      maxBatchMB: 'number',
      maxBatchSize: 'number',
      maxRetry: 'number',
      minBackoffMS: 'number',
      queryParam: { 'type': 'map', 'keyType': 'string', 'valueType': HttpDeliveryQueryParamValue },
      responseBodyKey: 'string',
      standardAuthOn: 'boolean',
      standardAuthParam: CreateUserDeliveryTaskRequestHttpDeliveryStandardAuthParam,
      successCode: 'number',
      transformTimeout: 'number',
    };
  }

  validate() {
    if(this.headerParam) {
      $dara.Model.validateMap(this.headerParam);
    }
    if(this.queryParam) {
      $dara.Model.validateMap(this.queryParam);
    }
    if(this.standardAuthParam && typeof (this.standardAuthParam as any).validate === 'function') {
      (this.standardAuthParam as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserDeliveryTaskRequestKafkaDelivery extends $dara.Model {
  /**
   * @remarks
   * The load balancing method.
   * 
   * @example
   * kafka.LeastBytes
   */
  balancer?: string;
  /**
   * @remarks
   * The brokers.
   */
  brokers?: string[];
  /**
   * @remarks
   * The compression method. By default, data is not compressed.
   * 
   * @example
   * gzip
   */
  compress?: string;
  /**
   * @remarks
   * The encryption method.
   * 
   * @example
   * plain
   */
  machanismType?: string;
  /**
   * @remarks
   * The password.
   * 
   * @example
   * xxx
   */
  password?: string;
  /**
   * @remarks
   * The topic.
   * 
   * @example
   * dqc_test2
   */
  topic?: string;
  /**
   * @remarks
   * Specifies whether to enable authentication.
   * 
   * @example
   * true
   */
  userAuth?: boolean;
  /**
   * @remarks
   * The username.
   * 
   * @example
   * xxx
   */
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      balancer: 'Balancer',
      brokers: 'Brokers',
      compress: 'Compress',
      machanismType: 'MachanismType',
      password: 'Password',
      topic: 'Topic',
      userAuth: 'UserAuth',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      balancer: 'string',
      brokers: { 'type': 'array', 'itemType': 'string' },
      compress: 'string',
      machanismType: 'string',
      password: 'string',
      topic: 'string',
      userAuth: 'boolean',
      userName: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.brokers)) {
      $dara.Model.validateArray(this.brokers);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserDeliveryTaskRequestOssDelivery extends $dara.Model {
  /**
   * @remarks
   * The ID of your Alibaba Cloud account.
   * 
   * @example
   * 1234***
   */
  aliuid?: string;
  /**
   * @remarks
   * The name of the OSS bucket.
   * 
   * @example
   * test_rlog
   */
  bucketName?: string;
  /**
   * @remarks
   * The prefix of the path in which you want to store logs.
   * 
   * @example
   * logriver-test/log
   */
  prefixPath?: string;
  /**
   * @remarks
   * The region in which the bucket is located.
   * 
   * @example
   * cn-shanghai
   */
  region?: string;
  static names(): { [key: string]: string } {
    return {
      aliuid: 'Aliuid',
      bucketName: 'BucketName',
      prefixPath: 'PrefixPath',
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliuid: 'string',
      bucketName: 'string',
      prefixPath: 'string',
      region: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserDeliveryTaskRequestS3Delivery extends $dara.Model {
  /**
   * @remarks
   * The access key ID of your Amazon S3 account.
   * 
   * @example
   * g0f46623ll0g0
   */
  accessKey?: string;
  /**
   * @remarks
   * The directory in the bucket.
   * 
   * @example
   * logriver-test/log
   */
  bucketPath?: string;
  /**
   * @remarks
   * The endpoint.
   * 
   * @example
   * https://s3.oss-cn-hangzhou.aliyuncs.com
   */
  endpoint?: string;
  /**
   * @remarks
   * The prefix of the path in which you want to store logs.
   * 
   * @example
   * logriver-test/log
   */
  prefixPath?: string;
  /**
   * @remarks
   * The region ID of the service.
   * 
   * @example
   * cn-shanghai
   */
  region?: string;
  /**
   * @remarks
   * Specifies whether the service is compatible with Amazon S3.
   * 
   * @example
   * true
   */
  s3Cmpt?: boolean;
  /**
   * @remarks
   * The secret access key of your Amazon S3 account.
   * 
   * @example
   * ***
   */
  secretKey?: string;
  serverSideEncryption?: boolean;
  vertifyType?: string;
  static names(): { [key: string]: string } {
    return {
      accessKey: 'AccessKey',
      bucketPath: 'BucketPath',
      endpoint: 'Endpoint',
      prefixPath: 'PrefixPath',
      region: 'Region',
      s3Cmpt: 'S3Cmpt',
      secretKey: 'SecretKey',
      serverSideEncryption: 'ServerSideEncryption',
      vertifyType: 'VertifyType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKey: 'string',
      bucketPath: 'string',
      endpoint: 'string',
      prefixPath: 'string',
      region: 'string',
      s3Cmpt: 'boolean',
      secretKey: 'string',
      serverSideEncryption: 'boolean',
      vertifyType: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserDeliveryTaskRequestSlsDelivery extends $dara.Model {
  /**
   * @remarks
   * The name of the SLS Logstore.
   * 
   * @example
   * accesslog-test
   */
  SLSLogStore?: string;
  /**
   * @remarks
   * The name of the SLS project.
   * 
   * @example
   * dcdn-test20240417
   */
  SLSProject?: string;
  /**
   * @remarks
   * The region in which the SLS project resides.
   * 
   * @example
   * cn-hangzhou
   */
  SLSRegion?: string;
  static names(): { [key: string]: string } {
    return {
      SLSLogStore: 'SLSLogStore',
      SLSProject: 'SLSProject',
      SLSRegion: 'SLSRegion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      SLSLogStore: 'string',
      SLSProject: 'string',
      SLSRegion: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingRoomRequestHostNameAndPath extends $dara.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  domain?: string;
  /**
   * @remarks
   * The path.
   * 
   * This parameter is required.
   * 
   * @example
   * /test
   */
  path?: string;
  /**
   * @remarks
   * The subdomain.
   * 
   * This parameter is required.
   * 
   * @example
   * test.
   */
  subdomain?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      path: 'Path',
      subdomain: 'Subdomain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      path: 'string',
      subdomain: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomScenePoliciesResponseBodyDataModule extends $dara.Model {
  /**
   * @remarks
   * The time when the policy expires.
   * 
   * The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-03-06T16:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The name of the scenario-specific policy.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The IDs of websites that are associated with the policy.
   */
  objects?: string[];
  /**
   * @remarks
   * The policy ID.
   * 
   * @example
   * 1234****
   */
  policyId?: number;
  /**
   * @remarks
   * The time when the policy takes effect.
   * 
   * The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-03-04T16:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The status of the policy. Valid values:
   * 
   * *   **Disabled**
   * *   **Pending**
   * *   **Running**
   * *   **Expired**
   * 
   * @example
   * Expired
   */
  status?: string;
  /**
   * @remarks
   * The name of the policy template. Valid value:
   * 
   * *   **promotion**: major events.
   * 
   * @example
   * promotion
   */
  template?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      name: 'Name',
      objects: 'Objects',
      policyId: 'PolicyId',
      startTime: 'StartTime',
      status: 'Status',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      name: 'string',
      objects: { 'type': 'array', 'itemType': 'string' },
      policyId: 'number',
      startTime: 'string',
      status: 'string',
      template: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.objects)) {
      $dara.Model.validateArray(this.objects);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDoSAllEventListResponseBodyDataList extends $dara.Model {
  /**
   * @remarks
   * The peak of volumetric attacks. Unit: bit/s.
   * 
   * @example
   * 800
   */
  bps?: number;
  coverage?: string;
  /**
   * @remarks
   * The peak of connection flood attacks. Unit: connections per seconds (CPS).
   * 
   * @example
   * 50
   */
  cps?: number;
  /**
   * @remarks
   * The time when the DDoS attack ends.
   * 
   * The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-02-12T15:59:59Z
   */
  endTime?: string;
  /**
   * @remarks
   * The attack event ID.
   * 
   * @example
   * web-cc_1
   */
  eventId?: string;
  eventResult?: string;
  /**
   * @remarks
   * The type of DDoS attacks that was queried. Valid values:
   * 
   * *   **web-cc**: web resource exhaustion attacks.
   * *   **cc**: connection flood attacks.
   * *   **traffic**: volumetric attacks.
   * 
   * @example
   * web-cc
   */
  eventType?: string;
  /**
   * @remarks
   * The peak of volumetric attacks. Unit: packets per second (PPS).
   * 
   * @example
   * 12000
   */
  pps?: number;
  /**
   * @remarks
   * The peak QPS of web resource exhaustion attacks.
   * 
   * @example
   * 7692
   */
  qps?: number;
  /**
   * @remarks
   * The time when the DDoS attack starts.
   * 
   * The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-02-12T15:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The attack target.
   * 
   * @example
   * example.com
   */
  target?: string;
  /**
   * @remarks
   * The ID of the web resource exhaustion attack target.
   * 
   * @example
   * 000000000155****
   */
  targetId?: string;
  static names(): { [key: string]: string } {
    return {
      bps: 'Bps',
      coverage: 'Coverage',
      cps: 'Cps',
      endTime: 'EndTime',
      eventId: 'EventId',
      eventResult: 'EventResult',
      eventType: 'EventType',
      pps: 'Pps',
      qps: 'Qps',
      startTime: 'StartTime',
      target: 'Target',
      targetId: 'TargetId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bps: 'number',
      coverage: 'string',
      cps: 'number',
      endTime: 'string',
      eventId: 'string',
      eventResult: 'string',
      eventType: 'string',
      pps: 'number',
      qps: 'number',
      startTime: 'string',
      target: 'string',
      targetId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDoSBpsListResponseBodyDataModule extends $dara.Model {
  /**
   * @example
   * 9000000000
   */
  attackBps?: number;
  /**
   * @example
   * 9000000
   */
  attackPps?: number;
  /**
   * @example
   * 1000000000
   */
  normalBps?: number;
  /**
   * @example
   * 1000000
   */
  normalPps?: number;
  /**
   * @example
   * 2023-05-14T17:00:00Z
   */
  timeStamp?: string;
  /**
   * @example
   * 10000000000
   */
  totalBps?: number;
  /**
   * @example
   * 100000000
   */
  totalPps?: number;
  static names(): { [key: string]: string } {
    return {
      attackBps: 'AttackBps',
      attackPps: 'AttackPps',
      normalBps: 'NormalBps',
      normalPps: 'NormalPps',
      timeStamp: 'TimeStamp',
      totalBps: 'TotalBps',
      totalPps: 'TotalPps',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attackBps: 'number',
      attackPps: 'number',
      normalBps: 'number',
      normalPps: 'number',
      timeStamp: 'string',
      totalBps: 'number',
      totalPps: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDoSL7QpsListResponseBodyDataModule extends $dara.Model {
  /**
   * @example
   * 5
   */
  attack?: number;
  /**
   * @example
   * 4
   */
  normal?: number;
  /**
   * @example
   * 2023-04-19T16:00:00Z
   */
  timeStamp?: string;
  /**
   * @example
   * 9
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      attack: 'Attack',
      normal: 'Normal',
      timeStamp: 'TimeStamp',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attack: 'number',
      normal: 'number',
      timeStamp: 'string',
      total: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePreloadTasksResponseBodyTasks extends $dara.Model {
  /**
   * @remarks
   * The prefetched content.
   * 
   * @example
   * http://a.com/1.jpg?b=2
   */
  content?: string;
  /**
   * @remarks
   * The time when the task was created.
   * 
   * @example
   * 2023-03-28 14:28:57
   */
  createTime?: string;
  /**
   * @remarks
   * The error message returned upon a prefetch task failure. Valid values:
   * 
   * *   **Internal Error**
   * *   **Origin Timeout**
   * *   **Origin Return StatusCode 5XX**
   * 
   * @example
   * Internal Error
   */
  description?: string;
  /**
   * @remarks
   * The progress of the task, in percentage.
   * 
   * @example
   * 100%
   */
  process?: string;
  /**
   * @remarks
   * The task status.
   * 
   * *   **Complete**: The task is complete.
   * *   **Refreshing**: The task is in progress.
   * *   **Failed**: The task failed.
   * 
   * @example
   * Complete
   */
  status?: string;
  /**
   * @remarks
   * The ID of the queried task.
   * 
   * @example
   * 1597854579687428
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      createTime: 'CreateTime',
      description: 'Description',
      process: 'Process',
      status: 'Status',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      createTime: 'string',
      description: 'string',
      process: 'string',
      status: 'string',
      taskId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePurgeTasksResponseBodyTasks extends $dara.Model {
  /**
   * @remarks
   * The purged content.
   * 
   * @example
   * http://a.com/1.jpg?b=1
   */
  content?: string;
  /**
   * @remarks
   * The time when the task was created.
   * 
   * @example
   * 2023-07-26T01:56:15Z
   */
  createTime?: string;
  /**
   * @remarks
   * The error description returned when the purge task failed.
   * 
   * @example
   * Internal Error
   */
  description?: string;
  /**
   * @remarks
   * The progress of the task, in percentage.
   * 
   * @example
   * 100%
   */
  process?: string;
  /**
   * @remarks
   * The task status.
   * 
   * *   **Complete**: The task is complete.
   * *   **Refreshing**: The task is in progress.
   * *   **Failed**: The task failed.
   * 
   * @example
   * Complete
   */
  status?: string;
  /**
   * @remarks
   * The task ID.
   * 
   * @example
   * 16346513304
   */
  taskId?: string;
  /**
   * @remarks
   * The type of the purge task. Valid values:
   * 
   * *   **file** (default): purges the cache by file.
   * *   **cachetag**: purges the cache by cache tag.
   * *   **directory**: purges the cache by directory.
   * *   **ignoreParams**: purges the cache by URL with specified parameters ignored.
   * *   **hostname**: purges the cache by hostname.
   * *   **purgeall**: purges all cache.
   * 
   * @example
   * file
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      createTime: 'CreateTime',
      description: 'Description',
      process: 'Process',
      status: 'Status',
      taskId: 'TaskId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      createTime: 'string',
      description: 'string',
      process: 'string',
      status: 'string',
      taskId: 'string',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCertificateResponseBodyResultDCV extends $dara.Model {
  /**
   * @remarks
   * DCV ID.
   * 
   * @example
   * bababf7cdd1546a2ad04c0def1f4c980
   */
  id?: string;
  /**
   * @example
   * http://www.example.com/.well-known/acme-challenge/pH20CqwS5L3ZnvkhI436DCzadKFuG7QcUcvB_4KsAow
   */
  key?: string;
  /**
   * @example
   * pending
   */
  status?: string;
  /**
   * @example
   * HTTP
   */
  type?: string;
  /**
   * @example
   * pH20CqwS5L3ZnvkhI436DCzadKFuG7QcUcvB_4KsAow.KfzYo4LH3EgOt7a73G-RqZkbR0eYtLfEUmtmqGmr4FQ
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      key: 'Key',
      status: 'Status',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      key: 'string',
      status: 'string',
      type: 'string',
      value: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCertificateResponseBodyResult extends $dara.Model {
  /**
   * @example
   * 2
   */
  applyCode?: number;
  /**
   * @example
   * canceled
   */
  applyMessage?: string;
  /**
   * @remarks
   * The certificate ID on Certificate Management Service.
   * 
   * @example
   * 30000478
   */
  casId?: string;
  /**
   * @remarks
   * The Common Name of the certificate.
   * 
   * @example
   * www.example.com
   */
  commonName?: string;
  /**
   * @remarks
   * The time when the certificate was created.
   * 
   * @example
   * 2020-05-12 02:00:53
   */
  createTime?: string;
  DCV?: GetCertificateResponseBodyResultDCV[];
  /**
   * @remarks
   * The SHA-256 fingerprint of the certificate.
   * 
   * @example
   * 1dc5fc9af4eead2570c70d94b416130baeb6d4429b51fd3557379588456aca66
   */
  fingerprintSha256?: string;
  /**
   * @remarks
   * The certificate ID on ESA.
   * 
   * @example
   * babaded901474b9693acf530e0fb1d95
   */
  id?: string;
  /**
   * @remarks
   * The certificate authority (CA) that issued the certificate.
   * 
   * @example
   * DigiCert
   */
  issuer?: string;
  /**
   * @remarks
   * The Common Name of the CA that issued the certificate.
   * 
   * @example
   * DigiCert Global Root CA
   */
  issuerCN?: string;
  /**
   * @remarks
   * The certificate name.
   * 
   * @example
   * yourCertName
   */
  name?: string;
  /**
   * @remarks
   * The time when the certificate expires.
   * 
   * @example
   * 2023-11-26T16:00:00Z
   */
  notAfter?: string;
  /**
   * @remarks
   * The time when the certificate takes effect.
   * 
   * @example
   * 2023-11-26T16:00:00Z
   */
  notBefore?: string;
  /**
   * @remarks
   * The public-key algorithm of the certificate.
   * 
   * @example
   * ECDSA
   */
  pubAlg?: string;
  /**
   * @remarks
   * The region.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @remarks
   * The Subject Alternative Name (SAN) of the certificate.
   * 
   * @example
   * www.example.com,*.example.com
   */
  SAN?: string;
  /**
   * @remarks
   * The serial number of the certificate.
   * 
   * @example
   * babaded901474b9693acf530e0fb1daa
   */
  serialNumber?: string;
  /**
   * @remarks
   * The signature algorithm of the certificate.
   * 
   * @example
   * ECDSA-SHA1
   */
  sigAlg?: string;
  /**
   * @remarks
   * The certificate status.
   * 
   * @example
   * OK
   */
  status?: string;
  /**
   * @remarks
   * The certificate type.
   * 
   * @example
   * free
   */
  type?: string;
  /**
   * @remarks
   * The time when the certificate was updated.
   * 
   * @example
   * 2022-09-22 05:33:13
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      applyCode: 'ApplyCode',
      applyMessage: 'ApplyMessage',
      casId: 'CasId',
      commonName: 'CommonName',
      createTime: 'CreateTime',
      DCV: 'DCV',
      fingerprintSha256: 'FingerprintSha256',
      id: 'Id',
      issuer: 'Issuer',
      issuerCN: 'IssuerCN',
      name: 'Name',
      notAfter: 'NotAfter',
      notBefore: 'NotBefore',
      pubAlg: 'PubAlg',
      region: 'Region',
      SAN: 'SAN',
      serialNumber: 'SerialNumber',
      sigAlg: 'SigAlg',
      status: 'Status',
      type: 'Type',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyCode: 'number',
      applyMessage: 'string',
      casId: 'string',
      commonName: 'string',
      createTime: 'string',
      DCV: { 'type': 'array', 'itemType': GetCertificateResponseBodyResultDCV },
      fingerprintSha256: 'string',
      id: 'string',
      issuer: 'string',
      issuerCN: 'string',
      name: 'string',
      notAfter: 'string',
      notBefore: 'string',
      pubAlg: 'string',
      region: 'string',
      SAN: 'string',
      serialNumber: 'string',
      sigAlg: 'string',
      status: 'string',
      type: 'string',
      updateTime: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.DCV)) {
      $dara.Model.validateArray(this.DCV);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCertificateQuotaResponseBodySiteUsage extends $dara.Model {
  /**
   * @example
   * 165929521496928
   */
  siteId?: string;
  /**
   * @example
   * example.com
   */
  siteName?: string;
  /**
   * @example
   * 5
   */
  siteUsage?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      siteName: 'SiteName',
      siteUsage: 'SiteUsage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'string',
      siteName: 'string',
      siteUsage: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientCaCertificateResponseBodyResult extends $dara.Model {
  /**
   * @example
   * www.example.com
   */
  commonName?: string;
  /**
   * @example
   * 2024-03-05 18:24:04
   */
  createTime?: string;
  /**
   * @example
   * babab9db65ee5efcca9f3d41d4b5****
   */
  id?: string;
  /**
   * @example
   * GlobalSign nv-sa
   */
  issuer?: string;
  /**
   * @example
   * yourCertName
   */
  name?: string;
  /**
   * @example
   * 2024-03-31 02:08:00
   */
  notAfter?: string;
  /**
   * @example
   * 2023-03-31 02:08:00
   */
  notBefore?: string;
  /**
   * @example
   * RSA
   */
  pubkeyAlgorithm?: string;
  /**
   * @example
   * www.example.com,*.example.com
   */
  SAN?: string;
  /**
   * @example
   * SHA256-RSA
   */
  signatureAlgorithm?: string;
  /**
   * @example
   * OK
   */
  status?: string;
  /**
   * @example
   * upload
   */
  type?: string;
  /**
   * @example
   * 2024-03-05 18:24:04
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      commonName: 'CommonName',
      createTime: 'CreateTime',
      id: 'Id',
      issuer: 'Issuer',
      name: 'Name',
      notAfter: 'NotAfter',
      notBefore: 'NotBefore',
      pubkeyAlgorithm: 'PubkeyAlgorithm',
      SAN: 'SAN',
      signatureAlgorithm: 'SignatureAlgorithm',
      status: 'Status',
      type: 'Type',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonName: 'string',
      createTime: 'string',
      id: 'string',
      issuer: 'string',
      name: 'string',
      notAfter: 'string',
      notBefore: 'string',
      pubkeyAlgorithm: 'string',
      SAN: 'string',
      signatureAlgorithm: 'string',
      status: 'string',
      type: 'string',
      updateTime: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientCertificateResponseBodyResult extends $dara.Model {
  /**
   * @remarks
   * The ID of the CA certificate.
   * 
   * @example
   * babab9db65ee5efcca9f3d41d4b50d66
   */
  CACertificateId?: string;
  /**
   * @remarks
   * The Common Name of the certificate.
   * 
   * @example
   * www.example.com
   */
  commonName?: string;
  /**
   * @remarks
   * The time when the certificate was created.
   * 
   * @example
   * 2024-06-24 07:48:51
   */
  createTime?: string;
  /**
   * @remarks
   * The certificate ID.
   * 
   * @example
   * baba39055622c008b90285a8838ed09a
   */
  id?: string;
  /**
   * @remarks
   * The certificate authority (CA) that issued the certificate.
   * 
   * @example
   * GlobalSign nv-sa
   */
  issuer?: string;
  /**
   * @remarks
   * The certificate name.
   * 
   * @example
   * yourCertName
   */
  name?: string;
  /**
   * @remarks
   * The time when the certificate expires.
   * 
   * @example
   * 2024-03-31 02:08:00
   */
  notAfter?: string;
  /**
   * @remarks
   * The time when the certificate takes effect.
   * 
   * @example
   * 2023-03-31 02:08:00
   */
  notBefore?: string;
  /**
   * @remarks
   * The public-key algorithm of the certificate.
   * 
   * @example
   * RSA
   */
  pubkeyAlgorithm?: string;
  /**
   * @remarks
   * The Subject Alternative Name (SAN) of the certificate.
   * 
   * @example
   * www.example.com,*.example.com
   */
  SAN?: string;
  /**
   * @remarks
   * The signature algorithm of the certificate.
   * 
   * @example
   * SHA256-RSA
   */
  signatureAlgorithm?: string;
  /**
   * @remarks
   * The certificate status.
   * 
   * @example
   * active
   */
  status?: string;
  /**
   * @remarks
   * The certificate type.
   * 
   * @example
   * dcdn
   */
  type?: string;
  /**
   * @remarks
   * The time when the certificate was updated.
   * 
   * @example
   * 2024-09-22 05:33:13
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      CACertificateId: 'CACertificateId',
      commonName: 'CommonName',
      createTime: 'CreateTime',
      id: 'Id',
      issuer: 'Issuer',
      name: 'Name',
      notAfter: 'NotAfter',
      notBefore: 'NotBefore',
      pubkeyAlgorithm: 'PubkeyAlgorithm',
      SAN: 'SAN',
      signatureAlgorithm: 'SignatureAlgorithm',
      status: 'Status',
      type: 'Type',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      CACertificateId: 'string',
      commonName: 'string',
      createTime: 'string',
      id: 'string',
      issuer: 'string',
      name: 'string',
      notAfter: 'string',
      notBefore: 'string',
      pubkeyAlgorithm: 'string',
      SAN: 'string',
      signatureAlgorithm: 'string',
      status: 'string',
      type: 'string',
      updateTime: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppResponseBodyAppHealthCheck extends $dara.Model {
  /**
   * @remarks
   * The number of consecutive failed health checks required for an application to be considered as unhealthy.
   * 
   * @example
   * 5
   */
  failTimes?: number;
  /**
   * @remarks
   * The domain name that is used for health checks.
   * 
   * @example
   * test.com
   */
  host?: string;
  /**
   * @remarks
   * The range of health check status codes that indicate successful health checks.
   * 
   * @example
   * http_2xx
   */
  httpCode?: string;
  /**
   * @remarks
   * The interval between health checks. Unit: seconds.
   * 
   * @example
   * 5
   */
  interval?: number;
  /**
   * @remarks
   * The HTTP method that the health check request uses.
   * 
   * @example
   * HEAD
   */
  method?: string;
  /**
   * @remarks
   * The health check port.
   * 
   * @example
   * 80
   */
  port?: number;
  /**
   * @remarks
   * The number of consecutive successful health checks required for an application to be considered as healthy.
   * 
   * @example
   * 3
   */
  succTimes?: number;
  /**
   * @remarks
   * The timeout period of the health check. Unit: seconds.
   * 
   * @example
   * 60
   */
  timeout?: number;
  /**
   * @remarks
   * The health check type. Valid values:
   * 
   * *   l7
   * *   l4
   * 
   * @example
   * l7
   */
  type?: string;
  /**
   * @remarks
   * The health check URL.
   * 
   * @example
   * /health_check
   */
  uri?: string;
  static names(): { [key: string]: string } {
    return {
      failTimes: 'FailTimes',
      host: 'Host',
      httpCode: 'HttpCode',
      interval: 'Interval',
      method: 'Method',
      port: 'Port',
      succTimes: 'SuccTimes',
      timeout: 'Timeout',
      type: 'Type',
      uri: 'Uri',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failTimes: 'number',
      host: 'string',
      httpCode: 'string',
      interval: 'number',
      method: 'string',
      port: 'number',
      succTimes: 'number',
      timeout: 'number',
      type: 'string',
      uri: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppResponseBodyApp extends $dara.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The time when the application was created.
   * 
   * @example
   * 2023-07-25T05:58:05Z
   */
  createTime?: string;
  /**
   * @remarks
   * The domain name that is associated with the application. If no domain name is associated with the application, the value is an empty string.
   * 
   * @example
   * www.1feel.cn
   */
  domainName?: string;
  /**
   * @remarks
   * The type of the gateway. Valid values:
   * 
   * *   l7: Layer 7 gateway.
   * *   l4: Layer 4 gateway.
   * 
   * @example
   * l7
   */
  gatewayType?: string;
  /**
   * @remarks
   * The information about health checks.
   */
  healthCheck?: GetEdgeContainerAppResponseBodyAppHealthCheck;
  /**
   * @remarks
   * The application name.
   * 
   * @example
   * test-app1
   */
  name?: string;
  /**
   * @remarks
   * Indicates whether QUIC is enabled.
   * 
   * @example
   * false
   */
  quicCid?: string;
  /**
   * @remarks
   * The remarks about the application.
   * 
   * @example
   * test app
   */
  remarks?: string;
  /**
   * @remarks
   * The server port. Valid values: 1 to 65535.
   * 
   * @example
   * 80
   */
  servicePort?: number;
  /**
   * @remarks
   * The status of the application. Valid values:
   * 
   * *   creating: The application is being created.
   * *   failed: The application failed to be created.
   * *   created: The application is created.
   * 
   * @example
   * created
   */
  status?: string;
  /**
   * @remarks
   * The backend port, which is also the service port of the application. Valid values: 1 to 65535.
   * 
   * @example
   * 80
   */
  targetPort?: number;
  /**
   * @remarks
   * The time when the application was last modified. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2023-03-26T02:35:58Z
   */
  updateTime?: string;
  /**
   * @remarks
   * The number of versions of the application.
   * 
   * @example
   * 1
   */
  versionCount?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      createTime: 'CreateTime',
      domainName: 'DomainName',
      gatewayType: 'GatewayType',
      healthCheck: 'HealthCheck',
      name: 'Name',
      quicCid: 'QuicCid',
      remarks: 'Remarks',
      servicePort: 'ServicePort',
      status: 'Status',
      targetPort: 'TargetPort',
      updateTime: 'UpdateTime',
      versionCount: 'VersionCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      createTime: 'string',
      domainName: 'string',
      gatewayType: 'string',
      healthCheck: GetEdgeContainerAppResponseBodyAppHealthCheck,
      name: 'string',
      quicCid: 'string',
      remarks: 'string',
      servicePort: 'number',
      status: 'string',
      targetPort: 'number',
      updateTime: 'string',
      versionCount: 'number',
    };
  }

  validate() {
    if(this.healthCheck && typeof (this.healthCheck as any).validate === 'function') {
      (this.healthCheck as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppStatusResponseBodyAppStatusRegions extends $dara.Model {
  region?: string[];
  static names(): { [key: string]: string } {
    return {
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      region: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.region)) {
      $dara.Model.validateArray(this.region);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppStatusResponseBodyAppStatus extends $dara.Model {
  /**
   * @remarks
   * The base version of the application.
   * 
   * @example
   * ver-123123123123****
   */
  baseLineVersion?: string;
  /**
   * @remarks
   * The deployment status of the application.
   * 
   * *   **undeploy**: The application is not deployed.
   * *   **deploying**: The application is being deployed.
   * *   **deployed**: The application is deployed.
   * *   **undeploying**: The deployment is being canceled.
   * 
   * @example
   * undeploy
   */
  deployStatus?: string;
  /**
   * @remarks
   * The time when the application was deployed. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2024-07-25T05:58:05Z
   */
  deployTime?: string;
  /**
   * @remarks
   * The release version of the application.
   * 
   * @example
   * ver-123123123123****
   */
  deployedVersion?: string;
  /**
   * @remarks
   * The expected release percentage of the application.
   * 
   * @example
   * 50%
   */
  expectPercentage?: number;
  /**
   * @remarks
   * Specifies whether to fully release the version. This parameter takes effect only when PublishType is set to region.
   * 
   * @example
   * true
   */
  fullRelease?: boolean;
  /**
   * @remarks
   * The environment to which the application was released. Valid values:
   * 
   * *   **prod**: the production environment.
   * *   **staging**: the staging environment.
   * 
   * @example
   * prod
   */
  publishEnv?: string;
  /**
   * @remarks
   * The release percentage of the application.
   * 
   * @example
   * 50%
   */
  publishPercentage?: number;
  /**
   * @remarks
   * The release status of the application. Valid values:
   * 
   * *   **publishing**
   * *   **published**
   * *   **rollbacking**
   * *   **rollbacked**
   * 
   * @example
   * pubishing
   */
  publishStatus?: string;
  /**
   * @remarks
   * The time when the application was released. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2024-07-25T05:58:05Z
   */
  publishTime?: string;
  /**
   * @remarks
   * Specifies how the version is released. Valid values:
   * 
   * *   percentage: releases the version by percentage.
   * *   region: releases the version by region.
   * 
   * If you do not specify this parameter, the version is released by percentage by default.
   * 
   * @example
   * percentage
   */
  publishType?: string;
  /**
   * @remarks
   * The release version of the application.
   * 
   * @example
   * ver-123123123123****
   */
  publishingVersion?: string;
  /**
   * @remarks
   * The regions to which the version is released.
   */
  regions?: GetEdgeContainerAppStatusResponseBodyAppStatusRegions;
  /**
   * @remarks
   * The time when the last rollback was performed.
   * 
   * @example
   * 2024-07-25T05:58:05Z
   */
  rollbackTime?: string;
  /**
   * @remarks
   * The time when the application deployment was canceled. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2024-07-25T05:58:05Z
   */
  unDeployTime?: string;
  static names(): { [key: string]: string } {
    return {
      baseLineVersion: 'BaseLineVersion',
      deployStatus: 'DeployStatus',
      deployTime: 'DeployTime',
      deployedVersion: 'DeployedVersion',
      expectPercentage: 'ExpectPercentage',
      fullRelease: 'FullRelease',
      publishEnv: 'PublishEnv',
      publishPercentage: 'PublishPercentage',
      publishStatus: 'PublishStatus',
      publishTime: 'PublishTime',
      publishType: 'PublishType',
      publishingVersion: 'PublishingVersion',
      regions: 'Regions',
      rollbackTime: 'RollbackTime',
      unDeployTime: 'UnDeployTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baseLineVersion: 'string',
      deployStatus: 'string',
      deployTime: 'string',
      deployedVersion: 'string',
      expectPercentage: 'number',
      fullRelease: 'boolean',
      publishEnv: 'string',
      publishPercentage: 'number',
      publishStatus: 'string',
      publishTime: 'string',
      publishType: 'string',
      publishingVersion: 'string',
      regions: GetEdgeContainerAppStatusResponseBodyAppStatusRegions,
      rollbackTime: 'string',
      unDeployTime: 'string',
    };
  }

  validate() {
    if(this.regions && typeof (this.regions as any).validate === 'function') {
      (this.regions as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppVersionResponseBodyVersionContainersACRImageInfo extends $dara.Model {
  /**
   * @remarks
   * The domain name of the Container Registry image.
   * 
   * @example
   * *.mooc.seewo.com
   */
  domain?: string;
  /**
   * @remarks
   * The ID of the Container Registry instance.
   * 
   * @example
   * xcdn-9ak2thl14z5s
   */
  instanceId?: string;
  /**
   * @remarks
   * Indicates whether the image is an enterprise-level image.
   * 
   * @example
   * false
   */
  isEnterpriseRegistry?: boolean;
  /**
   * @remarks
   * The region ID.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of the image repository.
   * 
   * @example
   * crr-zeu0xyk28alyxozh
   */
  repoId?: string;
  /**
   * @remarks
   * The name of the image repository.
   * 
   * @example
   * test_1
   */
  repoName?: string;
  /**
   * @remarks
   * The namespace to which the image repository belongs.
   * 
   * @example
   * wpy1
   */
  repoNamespace?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * test-healthy-100-soa-1710987653
   */
  tag?: string;
  /**
   * @remarks
   * The URL of the Container Registry image tag.
   * 
   * @example
   * registry-vpc.cn-shenzhen.aliyuncs.com/lihetech/easywits_server_exam:3.40.2
   */
  tagUrl?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      instanceId: 'InstanceId',
      isEnterpriseRegistry: 'IsEnterpriseRegistry',
      regionId: 'RegionId',
      repoId: 'RepoId',
      repoName: 'RepoName',
      repoNamespace: 'RepoNamespace',
      tag: 'Tag',
      tagUrl: 'TagUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      instanceId: 'string',
      isEnterpriseRegistry: 'boolean',
      regionId: 'string',
      repoId: 'string',
      repoName: 'string',
      repoNamespace: 'string',
      tag: 'string',
      tagUrl: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppVersionResponseBodyVersionContainersProbeContent extends $dara.Model {
  /**
   * @remarks
   * The probe command.
   * 
   * @example
   * sh test.sh
   */
  command?: string;
  /**
   * @remarks
   * The number of consecutive failed health checks required for a container to be considered as unhealthy.
   * 
   * @example
   * 3
   */
  failureThreshold?: number;
  /**
   * @remarks
   * The domain name that is used for health checks.
   * 
   * @example
   * test.com
   */
  host?: string;
  /**
   * @remarks
   * The request headers that are included in the container health check request.
   * 
   * @example
   * [{\\"Content-Type\\":\\"application/json
   */
  httpHeaders?: string;
  /**
   * @remarks
   * The latency for container probe initialization.
   * 
   * @example
   * 20
   */
  initialDelaySeconds?: number;
  /**
   * @remarks
   * The path of the container health check.
   * 
   * @example
   * /health_check
   */
  path?: string;
  /**
   * @remarks
   * The interval between container health checks.
   * 
   * @example
   * 5
   */
  periodSeconds?: number;
  /**
   * @remarks
   * The port of the container health check. Valid values: **1** to **65535**.
   * 
   * @example
   * 80
   */
  port?: number;
  /**
   * @remarks
   * The protocol that the container health check request uses.
   * 
   * @example
   * http
   */
  scheme?: string;
  /**
   * @remarks
   * The number of consecutive successful health checks required for a container to be considered as healthy.
   * 
   * @example
   * 1
   */
  successThreshold?: number;
  /**
   * @remarks
   * The timeout period of the container health check.
   * 
   * @example
   * 5
   */
  timeoutSeconds?: number;
  static names(): { [key: string]: string } {
    return {
      command: 'Command',
      failureThreshold: 'FailureThreshold',
      host: 'Host',
      httpHeaders: 'HttpHeaders',
      initialDelaySeconds: 'InitialDelaySeconds',
      path: 'Path',
      periodSeconds: 'PeriodSeconds',
      port: 'Port',
      scheme: 'Scheme',
      successThreshold: 'SuccessThreshold',
      timeoutSeconds: 'TimeoutSeconds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      command: 'string',
      failureThreshold: 'number',
      host: 'string',
      httpHeaders: 'string',
      initialDelaySeconds: 'number',
      path: 'string',
      periodSeconds: 'number',
      port: 'number',
      scheme: 'string',
      successThreshold: 'number',
      timeoutSeconds: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppVersionResponseBodyVersionContainers extends $dara.Model {
  /**
   * @remarks
   * The information about the Container Registry image.
   */
  ACRImageInfo?: GetEdgeContainerAppVersionResponseBodyVersionContainersACRImageInfo;
  /**
   * @remarks
   * The arguments that are passed to the container startup command.
   * 
   * @example
   * -c /path/config.toml
   */
  args?: string;
  /**
   * @remarks
   * The command that is used to start the container.
   * 
   * @example
   * sh abc.sh 1 2 3
   */
  command?: string;
  /**
   * @remarks
   * The environment variables.
   * 
   * @example
   * ENV=prod
   */
  envVariables?: string;
  /**
   * @remarks
   * The image address.
   * 
   * @example
   * nginx:1.14.0
   */
  image?: string;
  /**
   * @remarks
   * Indicates whether the image is a Container Registry image.
   * 
   * @example
   * false
   */
  isACRImage?: boolean;
  /**
   * @remarks
   * The version name.
   * 
   * @example
   * version01
   */
  name?: string;
  /**
   * @remarks
   * The command that is run before the container is started. Format: `{"exec":{"command":["cat","/etc/group"\\]}}`. If you want to cancel this configuration, set the parameter value to `""` or `{}`. If you do not specify this parameter, this configuration is ignored.
   * 
   * @example
   * {\\"exec\\":{\\"command\\":[\\"touch\\",\\"/home/admin/checkpoststartV1\\"]}}
   */
  postStart?: string;
  /**
   * @remarks
   * The command that is run before the container is stopped.
   * 
   * @example
   * sh prestop.sh "echo hello world"
   */
  preStop?: string;
  /**
   * @remarks
   * The probe content.
   */
  probeContent?: GetEdgeContainerAppVersionResponseBodyVersionContainersProbeContent;
  /**
   * @remarks
   * The probe type.
   * 
   * @example
   * httpGet
   */
  probeType?: string;
  /**
   * @remarks
   * The compute specification.
   * 
   * @example
   * 1C2G
   */
  spec?: string;
  /**
   * @remarks
   * The storage capacity of the container. Valid values: 0.5G, 10G, 20G, and 30G.
   */
  storage?: string;
  static names(): { [key: string]: string } {
    return {
      ACRImageInfo: 'ACRImageInfo',
      args: 'Args',
      command: 'Command',
      envVariables: 'EnvVariables',
      image: 'Image',
      isACRImage: 'IsACRImage',
      name: 'Name',
      postStart: 'PostStart',
      preStop: 'PreStop',
      probeContent: 'ProbeContent',
      probeType: 'ProbeType',
      spec: 'Spec',
      storage: 'Storage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ACRImageInfo: GetEdgeContainerAppVersionResponseBodyVersionContainersACRImageInfo,
      args: 'string',
      command: 'string',
      envVariables: 'string',
      image: 'string',
      isACRImage: 'boolean',
      name: 'string',
      postStart: 'string',
      preStop: 'string',
      probeContent: GetEdgeContainerAppVersionResponseBodyVersionContainersProbeContent,
      probeType: 'string',
      spec: 'string',
      storage: 'string',
    };
  }

  validate() {
    if(this.ACRImageInfo && typeof (this.ACRImageInfo as any).validate === 'function') {
      (this.ACRImageInfo as any).validate();
    }
    if(this.probeContent && typeof (this.probeContent as any).validate === 'function') {
      (this.probeContent as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppVersionResponseBodyVersion extends $dara.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The container images deployed for this version.
   */
  containers?: GetEdgeContainerAppVersionResponseBodyVersionContainers[];
  /**
   * @remarks
   * The time when the version was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2022-07-01T09:32:33Z
   */
  createTime?: string;
  /**
   * @remarks
   * The time when the version was last released. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2023-07-25T04:58:05Z
   */
  lastPublishTime?: string;
  /**
   * @remarks
   * The version name.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The time when the version was released. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2022-11-14T02:04:03Z
   */
  publishTime?: string;
  /**
   * @remarks
   * The remarks.
   * 
   * @example
   * aaa
   */
  remarks?: string;
  /**
   * @remarks
   * The status of the current version. Valid values:
   * 
   * *   created: The version is created.
   * *   failed: The version failed to be created.
   * *   creating: The version is being created.
   * 
   * @example
   * created
   */
  status?: string;
  /**
   * @remarks
   * The time when the version was last modified. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2021-12-03T10:52:52Z
   */
  updateTime?: string;
  /**
   * @remarks
   * The ID of the created version.
   * 
   * @example
   * ver-87962637161651****
   */
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      containers: 'Containers',
      createTime: 'CreateTime',
      lastPublishTime: 'LastPublishTime',
      name: 'Name',
      publishTime: 'PublishTime',
      remarks: 'Remarks',
      status: 'Status',
      updateTime: 'UpdateTime',
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      containers: { 'type': 'array', 'itemType': GetEdgeContainerAppVersionResponseBodyVersionContainers },
      createTime: 'string',
      lastPublishTime: 'string',
      name: 'string',
      publishTime: 'string',
      remarks: 'string',
      status: 'string',
      updateTime: 'string',
      versionId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.containers)) {
      $dara.Model.validateArray(this.containers);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerStagingDeployStatusResponseBodyPodRestartState extends $dara.Model {
  /**
   * @remarks
   * The reason for the last restart.
   * 
   * @example
   * OOMKilled
   */
  lastTerminatedReason?: string;
  /**
   * @remarks
   * The number of times that the container restarted.
   * 
   * @example
   * 1
   */
  restartCount?: number;
  static names(): { [key: string]: string } {
    return {
      lastTerminatedReason: 'LastTerminatedReason',
      restartCount: 'RestartCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lastTerminatedReason: 'string',
      restartCount: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHttpRequestHeaderModificationRuleResponseBodyRequestHeaderModification extends $dara.Model {
  /**
   * @remarks
   * The name of the request header.
   * 
   * @example
   * headerName
   */
  name?: string;
  /**
   * @remarks
   * The action. Valid values:
   * 
   * *   add: adds a header.
   * *   del: deletes a header.
   * *   modify: modifies a header.
   * 
   * @example
   * add
   */
  operation?: string;
  /**
   * @remarks
   * The value of the request header.
   * 
   * @example
   * headValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      operation: 'Operation',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      operation: 'string',
      value: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHttpResponseHeaderModificationRuleResponseBodyResponseHeaderModification extends $dara.Model {
  /**
   * @remarks
   * The name of the response header.
   * 
   * @example
   * headerName
   */
  name?: string;
  /**
   * @remarks
   * The action. Valid values:
   * 
   * *   add: adds a response header.
   * *   del: deletes a response header.
   * *   modify: modifies a response header.
   * 
   * @example
   * add
   */
  operation?: string;
  /**
   * @remarks
   * The value of the response header.
   * 
   * @example
   * headerValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      operation: 'Operation',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      operation: 'string',
      value: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetKvAccountResponseBodyNamespaceList extends $dara.Model {
  /**
   * @remarks
   * The available capacity of the namespace. Unit: bytes.
   * 
   * @example
   * 1073741824
   */
  capacity?: number;
  /**
   * @remarks
   * The available capacity of the namespace.
   * 
   * @example
   * 1 GB
   */
  capacityString?: string;
  /**
   * @remarks
   * The used capacity of the namespace. Unit: bytes.
   * 
   * @example
   * 100048576
   */
  capacityUsed?: number;
  /**
   * @remarks
   * The used capacity of the namespace.
   * 
   * @example
   * 100 MB
   */
  capacityUsedString?: string;
  /**
   * @remarks
   * The description of the namespace.
   * 
   * @example
   * the first namespace
   */
  description?: string;
  /**
   * @remarks
   * The name of the namespace.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * 643355322374688768
   */
  namespaceId?: string;
  /**
   * @remarks
   * The status of the namespace. Valid values:
   * 
   * *   **online**: normal.
   * *   **delete**: pending deletion.
   * *   **deleting**: being deleted.
   * *   **deleted**: deleted.
   * 
   * @example
   * online
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      capacity: 'Capacity',
      capacityString: 'CapacityString',
      capacityUsed: 'CapacityUsed',
      capacityUsedString: 'CapacityUsedString',
      description: 'Description',
      namespace: 'Namespace',
      namespaceId: 'NamespaceId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacity: 'number',
      capacityString: 'string',
      capacityUsed: 'number',
      capacityUsedString: 'string',
      description: 'string',
      namespace: 'string',
      namespaceId: 'string',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLoadBalancerResponseBodyAdaptiveRouting extends $dara.Model {
  /**
   * @example
   * true
   */
  failoverAcrossPools?: boolean;
  static names(): { [key: string]: string } {
    return {
      failoverAcrossPools: 'FailoverAcrossPools',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failoverAcrossPools: 'boolean',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLoadBalancerResponseBodyMonitor extends $dara.Model {
  /**
   * @example
   * 5
   */
  consecutiveDown?: number;
  /**
   * @example
   * 3
   */
  consecutiveUp?: number;
  /**
   * @example
   * 200,202
   */
  expectedCodes?: string;
  /**
   * @example
   * true
   */
  followRedirects?: boolean;
  /**
   * @example
   * {
   *         "host": [
   *             "example1.com",
   *             "example2.com"
   *         ]
   *     }
   */
  header?: any;
  /**
   * @example
   * 60
   */
  interval?: number;
  /**
   * @example
   * GET
   */
  method?: string;
  /**
   * @example
   * /
   */
  path?: string;
  /**
   * @example
   * 80
   */
  port?: number;
  /**
   * @example
   * 5
   */
  timeout?: number;
  /**
   * @example
   * HTTP
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      consecutiveDown: 'ConsecutiveDown',
      consecutiveUp: 'ConsecutiveUp',
      expectedCodes: 'ExpectedCodes',
      followRedirects: 'FollowRedirects',
      header: 'Header',
      interval: 'Interval',
      method: 'Method',
      path: 'Path',
      port: 'Port',
      timeout: 'Timeout',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consecutiveDown: 'number',
      consecutiveUp: 'number',
      expectedCodes: 'string',
      followRedirects: 'boolean',
      header: 'any',
      interval: 'number',
      method: 'string',
      path: 'string',
      port: 'number',
      timeout: 'number',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLoadBalancerResponseBodyRandomSteering extends $dara.Model {
  /**
   * @example
   * 50
   */
  defaultWeight?: number;
  poolWeights?: { [key: string]: number };
  static names(): { [key: string]: string } {
    return {
      defaultWeight: 'DefaultWeight',
      poolWeights: 'PoolWeights',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultWeight: 'number',
      poolWeights: { 'type': 'map', 'keyType': 'string', 'valueType': 'number' },
    };
  }

  validate() {
    if(this.poolWeights) {
      $dara.Model.validateMap(this.poolWeights);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLoadBalancerResponseBodyRulesFixedResponse extends $dara.Model {
  /**
   * @example
   * application/json
   */
  contentType?: string;
  /**
   * @example
   * http://www.example.com/index.html
   */
  location?: string;
  /**
   * @example
   * Hello World.
   */
  messageBody?: string;
  /**
   * @example
   * 200
   */
  statusCode?: number;
  static names(): { [key: string]: string } {
    return {
      contentType: 'ContentType',
      location: 'Location',
      messageBody: 'MessageBody',
      statusCode: 'StatusCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentType: 'string',
      location: 'string',
      messageBody: 'string',
      statusCode: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLoadBalancerResponseBodyRules extends $dara.Model {
  fixedResponse?: GetLoadBalancerResponseBodyRulesFixedResponse;
  /**
   * @example
   * {
   *             "adaptive_routing": {
   *                 "failover_across_pools": true
   *             },
   *             "sub_region_pools": {
   *                 "GB": [
   *                     96228666776****
   *                 ],
   *                 "US": [
   *                     96228666776****
   *                 ]
   *             },
   *             "default_pools": [
   *                 96228666776****,
   *                 96228666776****
   *             ],
   *             "fallback_pool": 96228666776****,
   *             "location_strategy": {
   *                 "mode": "resolver_ip",
   *                 "prefer_ecs": "always"
   *             },
   *             "random_steering": {
   *                 "default_weight": 30,
   *                 "pool_weights": {
   *                     "96228666776****": 70,
   *                     "96228666776****": 80
   *                 }
   *             },
   *             "region_pools": {
   *                 "ENAM": [
   *                     96228666776****,
   *                     92843536908****
   *                 ],
   *                 "WNAM": [
   *                     92843536908****
   *                 ]
   *             },
   *             "session_affinity": "cookie",
   *             "session_affinity_attributes": {
   *                 "drain_duration": 100,
   *                 "headers": ["none"],
   *                 "require_all_headers": false,
   *                 "samesite": "Auto",
   *                 "secure": "Auto",
   *                 "zero_downtime_failover": "sticky"
   *             },
   *             "session_affinity_ttl": 1800,
   *             "steering_policy": "dynamic_latency",
   *             "ttl": 30
   *         }
   */
  overrides?: any;
  /**
   * @example
   * http.request.uri.path contains "/testing"
   */
  rule?: string;
  /**
   * @example
   * off
   */
  ruleEnable?: string;
  /**
   * @example
   * r2
   */
  ruleName?: string;
  /**
   * @example
   * 1
   */
  sequence?: number;
  /**
   * @example
   * true
   */
  terminates?: boolean;
  static names(): { [key: string]: string } {
    return {
      fixedResponse: 'FixedResponse',
      overrides: 'Overrides',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      terminates: 'Terminates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fixedResponse: GetLoadBalancerResponseBodyRulesFixedResponse,
      overrides: 'any',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'number',
      terminates: 'boolean',
    };
  }

  validate() {
    if(this.fixedResponse && typeof (this.fixedResponse as any).validate === 'function') {
      (this.fixedResponse as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginPoolResponseBodyOriginsAuthConf extends $dara.Model {
  accessKey?: string;
  authType?: string;
  region?: string;
  secretKey?: string;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      accessKey: 'AccessKey',
      authType: 'AuthType',
      region: 'Region',
      secretKey: 'SecretKey',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKey: 'string',
      authType: 'string',
      region: 'string',
      secretKey: 'string',
      version: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginPoolResponseBodyOrigins extends $dara.Model {
  address?: string;
  authConf?: GetOriginPoolResponseBodyOriginsAuthConf;
  enabled?: boolean;
  header?: any;
  id?: number;
  name?: string;
  type?: string;
  weight?: number;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      authConf: 'AuthConf',
      enabled: 'Enabled',
      header: 'Header',
      id: 'Id',
      name: 'Name',
      type: 'Type',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      authConf: GetOriginPoolResponseBodyOriginsAuthConf,
      enabled: 'boolean',
      header: 'any',
      id: 'number',
      name: 'string',
      type: 'string',
      weight: 'number',
    };
  }

  validate() {
    if(this.authConf && typeof (this.authConf as any).validate === 'function') {
      (this.authConf as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginPoolResponseBodyReferencesDnsRecords extends $dara.Model {
  id?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginPoolResponseBodyReferencesIPARecords extends $dara.Model {
  id?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginPoolResponseBodyReferencesLoadBalancers extends $dara.Model {
  id?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginPoolResponseBodyReferences extends $dara.Model {
  dnsRecords?: GetOriginPoolResponseBodyReferencesDnsRecords[];
  IPARecords?: GetOriginPoolResponseBodyReferencesIPARecords[];
  loadBalancers?: GetOriginPoolResponseBodyReferencesLoadBalancers[];
  static names(): { [key: string]: string } {
    return {
      dnsRecords: 'DnsRecords',
      IPARecords: 'IPARecords',
      loadBalancers: 'LoadBalancers',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dnsRecords: { 'type': 'array', 'itemType': GetOriginPoolResponseBodyReferencesDnsRecords },
      IPARecords: { 'type': 'array', 'itemType': GetOriginPoolResponseBodyReferencesIPARecords },
      loadBalancers: { 'type': 'array', 'itemType': GetOriginPoolResponseBodyReferencesLoadBalancers },
    };
  }

  validate() {
    if(Array.isArray(this.dnsRecords)) {
      $dara.Model.validateArray(this.dnsRecords);
    }
    if(Array.isArray(this.IPARecords)) {
      $dara.Model.validateArray(this.IPARecords);
    }
    if(Array.isArray(this.loadBalancers)) {
      $dara.Model.validateArray(this.loadBalancers);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginProtectionResponseBodyCurrentIPWhitelist extends $dara.Model {
  /**
   * @remarks
   * The IP whitelist for origin protection used by the website, specified as IPv4 addresses or CIDR blocks.
   */
  IPv4?: string[];
  /**
   * @remarks
   * The IP whitelist for origin protection used by the website, specified as IPv6 addresses or CIDR blocks.
   */
  IPv6?: string[];
  static names(): { [key: string]: string } {
    return {
      IPv4: 'IPv4',
      IPv6: 'IPv6',
    };
  }

  static types(): { [key: string]: any } {
    return {
      IPv4: { 'type': 'array', 'itemType': 'string' },
      IPv6: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.IPv4)) {
      $dara.Model.validateArray(this.IPv4);
    }
    if(Array.isArray(this.IPv6)) {
      $dara.Model.validateArray(this.IPv6);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginProtectionResponseBodyDiffIPWhitelistAddedIPWhitelist extends $dara.Model {
  /**
   * @remarks
   * The IP whitelist for origin protection, specified as IPv4 addresses or CIDR blocks.
   */
  IPv4?: string[];
  /**
   * @remarks
   * The IP whitelist for origin protection, specified as IPv6 addresses or CIDR blocks.
   */
  IPv6?: string[];
  static names(): { [key: string]: string } {
    return {
      IPv4: 'IPv4',
      IPv6: 'IPv6',
    };
  }

  static types(): { [key: string]: any } {
    return {
      IPv4: { 'type': 'array', 'itemType': 'string' },
      IPv6: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.IPv4)) {
      $dara.Model.validateArray(this.IPv4);
    }
    if(Array.isArray(this.IPv6)) {
      $dara.Model.validateArray(this.IPv6);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginProtectionResponseBodyDiffIPWhitelistNoChangeIpWhitelist extends $dara.Model {
  /**
   * @remarks
   * The IP whitelist for origin protection, specified as IPv4 addresses or CIDR blocks.
   */
  IPv4?: string[];
  /**
   * @remarks
   * The IP whitelist for origin protection, specified as IPv6 addresses or CIDR blocks.
   */
  IPv6?: string[];
  static names(): { [key: string]: string } {
    return {
      IPv4: 'IPv4',
      IPv6: 'IPv6',
    };
  }

  static types(): { [key: string]: any } {
    return {
      IPv4: { 'type': 'array', 'itemType': 'string' },
      IPv6: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.IPv4)) {
      $dara.Model.validateArray(this.IPv4);
    }
    if(Array.isArray(this.IPv6)) {
      $dara.Model.validateArray(this.IPv6);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginProtectionResponseBodyDiffIPWhitelistRemovedIPWhitelist extends $dara.Model {
  /**
   * @remarks
   * The IP whitelist for origin protection, specified as IPv4 addresses or CIDR blocks.
   */
  IPv4?: string[];
  /**
   * @remarks
   * The IP whitelist for origin protection, specified as IPv6 addresses or CIDR blocks.
   */
  IPv6?: string[];
  static names(): { [key: string]: string } {
    return {
      IPv4: 'IPv4',
      IPv6: 'IPv6',
    };
  }

  static types(): { [key: string]: any } {
    return {
      IPv4: { 'type': 'array', 'itemType': 'string' },
      IPv6: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.IPv4)) {
      $dara.Model.validateArray(this.IPv4);
    }
    if(Array.isArray(this.IPv6)) {
      $dara.Model.validateArray(this.IPv6);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginProtectionResponseBodyDiffIPWhitelist extends $dara.Model {
  /**
   * @remarks
   * The new IP whitelist for origin protection.
   */
  addedIPWhitelist?: GetOriginProtectionResponseBodyDiffIPWhitelistAddedIPWhitelist;
  /**
   * @remarks
   * The IP whitelist for origin protection that remains unchanged.
   */
  noChangeIpWhitelist?: GetOriginProtectionResponseBodyDiffIPWhitelistNoChangeIpWhitelist;
  /**
   * @remarks
   * The IP whitelist for origin protection that has been deleted.
   */
  removedIPWhitelist?: GetOriginProtectionResponseBodyDiffIPWhitelistRemovedIPWhitelist;
  static names(): { [key: string]: string } {
    return {
      addedIPWhitelist: 'AddedIPWhitelist',
      noChangeIpWhitelist: 'NoChangeIpWhitelist',
      removedIPWhitelist: 'RemovedIPWhitelist',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addedIPWhitelist: GetOriginProtectionResponseBodyDiffIPWhitelistAddedIPWhitelist,
      noChangeIpWhitelist: GetOriginProtectionResponseBodyDiffIPWhitelistNoChangeIpWhitelist,
      removedIPWhitelist: GetOriginProtectionResponseBodyDiffIPWhitelistRemovedIPWhitelist,
    };
  }

  validate() {
    if(this.addedIPWhitelist && typeof (this.addedIPWhitelist as any).validate === 'function') {
      (this.addedIPWhitelist as any).validate();
    }
    if(this.noChangeIpWhitelist && typeof (this.noChangeIpWhitelist as any).validate === 'function') {
      (this.noChangeIpWhitelist as any).validate();
    }
    if(this.removedIPWhitelist && typeof (this.removedIPWhitelist as any).validate === 'function') {
      (this.removedIPWhitelist as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginProtectionResponseBodyLatestIPWhitelist extends $dara.Model {
  /**
   * @remarks
   * The latest IP whitelist for origin protection, specified as IPv4 addresses or CIDR blocks.
   */
  IPv4?: string[];
  /**
   * @remarks
   * The latest IP whitelist for origin protection, specified as IPv6 addresses or CIDR blocks.
   */
  IPv6?: string[];
  static names(): { [key: string]: string } {
    return {
      IPv4: 'IPv4',
      IPv6: 'IPv6',
    };
  }

  static types(): { [key: string]: any } {
    return {
      IPv4: { 'type': 'array', 'itemType': 'string' },
      IPv6: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.IPv4)) {
      $dara.Model.validateArray(this.IPv4);
    }
    if(Array.isArray(this.IPv6)) {
      $dara.Model.validateArray(this.IPv6);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRecordResponseBodyRecordModelAuthConf extends $dara.Model {
  /**
   * @remarks
   * The access key ID of the account to which the origin server belongs. This parameter is returned if the origin type is OSS and AuthType is set to private_cross_account, or the origin type is S3 and AuthType is set to private.
   * 
   * @example
   * VIxuvJSA2S03f******kp208dy5w7
   */
  accessKey?: string;
  /**
   * @remarks
   * The authentication type of the origin server. Different origins support different authentication types. The origin type refers to the SourceType parameter in this operation. This parameter is returned if the origin type is OSS or S3Valid values:
   * 
   * *   **public**: public read. This value is returned when the origin is a public OSS or S3 bucket.
   * *   **private**: private read. This value is returned when the origin is a private S3 bucket.
   * *   **private_same_account**: private read in the same account. This value is returned when the origin is a private OSS bucket in your account.
   * *   **private_cross_account**: private read across accounts. This value is returned when the origin is a private OSS bucket in a different Alibaba Cloud account.
   * 
   * @example
   * public
   */
  authType?: string;
  /**
   * @remarks
   * The region of the origin. If the origin type is S3, you must specify this value. You can obtain the region information from the official website of S3.
   * 
   * @example
   * us-east-1
   */
  region?: string;
  /**
   * @remarks
   * The secret access key of the account to which the origin server belongs. This parameter is returned if the origin type is OSS and AuthType is set to private_cross_account, or the origin type is S3 and AuthType is set to private.SecretKey
   * 
   * @example
   * u0Nkg5gBK*******QF5wvKMM504JUHt
   */
  secretKey?: string;
  /**
   * @remarks
   * The version of the signature algorithm. This parameter is returned when the origin type is S3 and AuthType is private. The following two types are supported:
   * 
   * *   **v2**
   * *   **v4**
   * 
   * If this parameter is left empty, the default value v4 is used.
   * 
   * @example
   * v2
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      accessKey: 'AccessKey',
      authType: 'AuthType',
      region: 'Region',
      secretKey: 'SecretKey',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKey: 'string',
      authType: 'string',
      region: 'string',
      secretKey: 'string',
      version: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRecordResponseBodyRecordModelData extends $dara.Model {
  /**
   * @remarks
   * The encryption algorithm used for the record, specified within the range from 0 to 255. This parameter is required when you add CERT or SSHFP records.
   * 
   * @example
   * 1
   */
  algorithm?: number;
  /**
   * @remarks
   * The public key of the certificate. This parameter is required when you add CERT, SMIMEA, or TLSA records.
   * 
   * @example
   * dGVzdGFkYWxrcw==
   */
  certificate?: string;
  /**
   * @remarks
   * The public key fingerprint of the record. This parameter is required when you add a SSHFP record.
   * 
   * @example
   * abcdef1234567890
   */
  fingerprint?: string;
  /**
   * @remarks
   * The flag bit of the record. The Flag for a CAA record indicates its priority and how it is processed, specified within the range of 0 to 255. This parameter is required when you add a CAA record.
   * 
   * @example
   * 128
   */
  flag?: number;
  /**
   * @remarks
   * The public key identification for the record. Valid values: 0 to 65535. This parameter is required when you add a CAA record.
   * 
   * @example
   * 1
   */
  keyTag?: number;
  /**
   * @remarks
   * The algorithm policy used to match or validate the certificate, specified within the range 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
   * 
   * @example
   * 1
   */
  matchingType?: number;
  /**
   * @remarks
   * The port of the record. Valid values: 0 to 65535. This parameter is required when you add an SRV record.
   * 
   * @example
   * 8707
   */
  port?: number;
  /**
   * @remarks
   * The priority of the record. Valid values: 0 to 65535. A smaller value indicates a higher priority. This parameter is required when you add MX, SRV, and URI records.
   * 
   * @example
   * 10
   */
  priority?: number;
  /**
   * @remarks
   * The type of the certificate or public key, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
   * 
   * @example
   * 1
   */
  selector?: number;
  /**
   * @remarks
   * The tag of the record. The Tag of a CAA record indicate its specific type and usage.
   * 
   * @example
   * issue
   */
  tag?: string;
  /**
   * @remarks
   * The certificate type of the record (in CERT records), or the public key type (in SSHFP records). This parameter is required when you add CERT or SSHFP records.
   * 
   * @example
   * RSA
   */
  type?: number;
  /**
   * @remarks
   * The usage identifier of the record, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
   * 
   * @example
   * 0
   */
  usage?: number;
  /**
   * @remarks
   * The record value or part of the record content. This parameter is returned when you add A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, and URI records. It has different meanings based on types of records.
   * 
   * *   **A/AAAA**: the IP address. Multiple IP addresses are separated with commas (,). There is at least one IPv4 address.
   * *   **CNAME**: the target domain name.
   * *   **NS**: the nameserver for the domain name.
   * *   **MX**: a valid domain name of the target mail server.
   * *   **TXT**: a valid text string.
   * *   **CAA**: a valid domain name of the certificate authority.
   * *   **SRV**: a valid domain name of the target host.
   * *   **URI**: a valid URI string.
   * 
   * @example
   * example.com
   */
  value?: string;
  /**
   * @remarks
   * The weight of the record, specified within the range of 0 to 65535. This parameter is required when you add SRV or URI records.
   * 
   * @example
   * 0
   */
  weight?: number;
  static names(): { [key: string]: string } {
    return {
      algorithm: 'Algorithm',
      certificate: 'Certificate',
      fingerprint: 'Fingerprint',
      flag: 'Flag',
      keyTag: 'KeyTag',
      matchingType: 'MatchingType',
      port: 'Port',
      priority: 'Priority',
      selector: 'Selector',
      tag: 'Tag',
      type: 'Type',
      usage: 'Usage',
      value: 'Value',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      algorithm: 'number',
      certificate: 'string',
      fingerprint: 'string',
      flag: 'number',
      keyTag: 'number',
      matchingType: 'number',
      port: 'number',
      priority: 'number',
      selector: 'number',
      tag: 'string',
      type: 'number',
      usage: 'number',
      value: 'string',
      weight: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRecordResponseBodyRecordModel extends $dara.Model {
  /**
   * @remarks
   * The origin authentication information of the CNAME record.
   */
  authConf?: GetRecordResponseBodyRecordModelAuthConf;
  /**
   * @remarks
   * The business scenario of the record for acceleration. Leave this parameter empty if your record is not proxied. Valid values:
   * 
   * *   **image_video**
   * *   **api**
   * *   **web**
   * 
   * @example
   * image_video
   */
  bizName?: string;
  /**
   * @remarks
   * The comments of the record.
   * 
   * @example
   * This is a comment.
   */
  comment?: string;
  /**
   * @remarks
   * The time when the record was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-03-10T13:30:39Z
   */
  createTime?: string;
  /**
   * @remarks
   * The DNS record information. The content returned by this parameter varies based on the record type.
   * 
   * @example
   * {"value":"1.1.1.1"}
   */
  data?: GetRecordResponseBodyRecordModelData;
  /**
   * @remarks
   * The origin host policy. This policy takes effect when the record type is CNAME. Valid values:
   * 
   * *   follow_hostname: matches the requested domain name.
   * *   follow_origin_domain: matches the origin\\"s domain name.
   * 
   * @example
   * follow_origin_domain
   */
  hostPolicy?: string;
  /**
   * @remarks
   * Indicates whether the record is proxied. Only CNAME and A/AAAA records can be proxied. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  proxied?: boolean;
  /**
   * @remarks
   * The CNAME. If you use CNAME setup when you add your website to ESA, the value is the CNAME that you configured then.
   * 
   * @example
   * a.example.com.cnamezone.com
   */
  recordCname?: string;
  /**
   * @remarks
   * The record ID.
   * 
   * @example
   * 1234567890123
   */
  recordId?: number;
  /**
   * @remarks
   * The record name.
   * 
   * @example
   * a.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The origin type for the CNAME record. This parameter is required when you add a CNAME record. Valid values:
   * 
   * *   **OSS**: OSS bucket.
   * *   **S3**: S3 bucket.
   * *   **LB**: load balancer.
   * *   **OP**: origin pool.
   * *   **Domain**: domain name.
   * 
   * If you do not pass this parameter or if you leave its value empty, Domain is returned by default.
   * 
   * @example
   * OSS
   */
  recordSourceType?: string;
  /**
   * @remarks
   * The type of the DNS record, such as **A/AAAA, CNAME, and TXT**.
   * 
   * @example
   * A/AAAA
   */
  recordType?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  /**
   * @remarks
   * The TTL of the record. Unit: seconds. If the value is 1, the TTL of the record is determined by the system.
   * 
   * @example
   * 20
   */
  ttl?: number;
  /**
   * @remarks
   * The time when the record was updated. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-01-27T02:26:22Z
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      authConf: 'AuthConf',
      bizName: 'BizName',
      comment: 'Comment',
      createTime: 'CreateTime',
      data: 'Data',
      hostPolicy: 'HostPolicy',
      proxied: 'Proxied',
      recordCname: 'RecordCname',
      recordId: 'RecordId',
      recordName: 'RecordName',
      recordSourceType: 'RecordSourceType',
      recordType: 'RecordType',
      siteId: 'SiteId',
      siteName: 'SiteName',
      ttl: 'Ttl',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authConf: GetRecordResponseBodyRecordModelAuthConf,
      bizName: 'string',
      comment: 'string',
      createTime: 'string',
      data: GetRecordResponseBodyRecordModelData,
      hostPolicy: 'string',
      proxied: 'boolean',
      recordCname: 'string',
      recordId: 'number',
      recordName: 'string',
      recordSourceType: 'string',
      recordType: 'string',
      siteId: 'number',
      siteName: 'string',
      ttl: 'number',
      updateTime: 'string',
    };
  }

  validate() {
    if(this.authConf && typeof (this.authConf as any).validate === 'function') {
      (this.authConf as any).validate();
    }
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineResponseBodyCodeVersions extends $dara.Model {
  /**
   * @remarks
   * The description of the code version.
   * 
   * @example
   * test ver code desc
   */
  codeDescription?: string;
  /**
   * @remarks
   * The code version.
   * 
   * @example
   * 1710120201067203242
   */
  codeVersion?: string;
  /**
   * @remarks
   * The time when the code version was created.
   * 
   * @example
   * 2024-03-11T01:23:21Z
   */
  createTime?: string;
  static names(): { [key: string]: string } {
    return {
      codeDescription: 'CodeDescription',
      codeVersion: 'CodeVersion',
      createTime: 'CreateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeDescription: 'string',
      codeVersion: 'string',
      createTime: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineResponseBodyEnvs extends $dara.Model {
  /**
   * @remarks
   * The regions for canary release.
   */
  canaryAreaList?: string[];
  /**
   * @remarks
   * The version number for canary release.
   * 
   * @example
   * 1710120201067577628
   */
  canaryCodeVersion?: string;
  /**
   * @remarks
   * The version number of the code in the environment.
   * 
   * @example
   * 1710120201067577628
   */
  codeVersion?: string;
  /**
   * @remarks
   * The environment type.
   * 
   * @example
   * production
   */
  env?: string;
  /**
   * @remarks
   * The specification.
   * 
   * @example
   * 5ms
   */
  specName?: string;
  static names(): { [key: string]: string } {
    return {
      canaryAreaList: 'CanaryAreaList',
      canaryCodeVersion: 'CanaryCodeVersion',
      codeVersion: 'CodeVersion',
      env: 'Env',
      specName: 'SpecName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canaryAreaList: { 'type': 'array', 'itemType': 'string' },
      canaryCodeVersion: 'string',
      codeVersion: 'string',
      env: 'string',
      specName: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.canaryAreaList)) {
      $dara.Model.validateArray(this.canaryAreaList);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineResponseBodyRelatedRecords extends $dara.Model {
  /**
   * @remarks
   * The record ID.
   * 
   * @example
   * 509348423011904
   */
  recordId?: number;
  /**
   * @remarks
   * The record name.
   * 
   * @example
   * test-record-1.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 54362329990032
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  static names(): { [key: string]: string } {
    return {
      recordId: 'RecordId',
      recordName: 'RecordName',
      siteId: 'SiteId',
      siteName: 'SiteName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordId: 'number',
      recordName: 'string',
      siteId: 'number',
      siteName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineResponseBodyRelatedRoutes extends $dara.Model {
  byPass?: string;
  /**
   * @remarks
   * The route.
   * 
   * @example
   * *.example.com/path1*
   */
  route?: string;
  /**
   * @remarks
   * The route ID.
   * 
   * @example
   * d501cb8a2c951f32922d260040780c06
   */
  routeId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 54362329990032
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  static names(): { [key: string]: string } {
    return {
      byPass: 'ByPass',
      route: 'Route',
      routeId: 'RouteId',
      siteId: 'SiteId',
      siteName: 'SiteName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      byPass: 'string',
      route: 'string',
      routeId: 'string',
      siteId: 'number',
      siteName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineUserInfoResponseBodyRoutines extends $dara.Model {
  /**
   * @remarks
   * The time when the routine was created.
   * 
   * @example
   * 2024-03-11T01:23:02.883361712Z
   */
  createTime?: string;
  /**
   * @remarks
   * The routine description, which is Base64-encoded.
   * 
   * @example
   * ZWRpdCByb3V0aW5lIGNvbmZpZyBkZXNjcmlwdGlvbg
   */
  description?: string;
  /**
   * @remarks
   * The routine name.
   * 
   * @example
   * test-routine1
   */
  routineName?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      description: 'Description',
      routineName: 'RoutineName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      description: 'string',
      routineName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteResponseBodySiteModel extends $dara.Model {
  /**
   * @remarks
   * The DNS setup option for the website. Valid values:
   * 
   * *   **NS**
   * *   **CNAME**
   * 
   * @example
   * NS
   */
  accessType?: string;
  /**
   * @remarks
   * The CNAME of the website domain. If you use CNAME setup when you add your website to ESA, the value is the CNAME that you configured then.
   * 
   * @example
   * example.cname.com
   */
  cnameZone?: string;
  /**
   * @remarks
   * The service location. Valid values:
   * 
   * *   **domestic**: the Chinese mainland.
   * *   **global**: global.
   * *   **overseas**: outside the Chinese mainland.
   * 
   * @example
   * domestic
   */
  coverage?: string;
  /**
   * @remarks
   * The time when the WEBsite was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format and is displayed in UTC.
   * 
   * @example
   * 2023-12-24T02:01:11Z
   */
  createTime?: string;
  /**
   * @remarks
   * The plan ID.
   * 
   * @example
   * cas-merge-q6h0bv
   */
  instanceId?: string;
  /**
   * @remarks
   * The nameservers assigned to the website domain. They are separated by commas (,).
   * 
   * @example
   * male1-1.ialicdn.com,female1-1.ialicdn.com
   */
  nameServerList?: string;
  /**
   * @remarks
   * The plan name.
   * 
   * @example
   * plan-168777532****
   */
  planName?: string;
  /**
   * @remarks
   * The specification of the plan associated with the website.
   * 
   * @example
   * normal
   */
  planSpecName?: string;
  /**
   * @remarks
   * The ID of your Alibaba Cloud resource group.
   * 
   * @example
   * rg-aek26g6i6se****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  /**
   * @remarks
   * The website status. Valid values:
   * 
   * *   **pending**: The website is to be configured.
   * *   **active**: The website is active.
   * *   **offline**: The website is suspended.
   * *   **moved**: The website has been added and verified by another Alibaba Cloud account.
   * 
   * @example
   * pending
   */
  status?: string;
  /**
   * @remarks
   * The tags of the website.
   * 
   * @example
   * {"tag1":"value1"}
   */
  tags?: { [key: string]: any };
  /**
   * @remarks
   * The time when the WEBsite was updated. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format and is displayed in UTC.
   * 
   * @example
   * 2023-12-24T02:01:11Z
   */
  updateTime?: string;
  /**
   * @remarks
   * The information about custom nameservers of the website domain. The key is a custom nameserver name, and the value is the IP address of the custom nameserver. Multiple IP addresses are separated by commas (,).
   */
  vanityNSList?: { [key: string]: string };
  /**
   * @remarks
   * The code that is used to verify the website domain ownership. As part of the verification TXT record, this parameter is returned for websites that use CNAME setup.
   * 
   * @example
   * verify_d516cb3740f81f0cef77d162edd1****
   */
  verifyCode?: string;
  /**
   * @remarks
   * The status of version management. If true is returned, version management is enabled for the website.
   * 
   * @example
   * true
   */
  versionManagement?: boolean;
  static names(): { [key: string]: string } {
    return {
      accessType: 'AccessType',
      cnameZone: 'CnameZone',
      coverage: 'Coverage',
      createTime: 'CreateTime',
      instanceId: 'InstanceId',
      nameServerList: 'NameServerList',
      planName: 'PlanName',
      planSpecName: 'PlanSpecName',
      resourceGroupId: 'ResourceGroupId',
      siteId: 'SiteId',
      siteName: 'SiteName',
      status: 'Status',
      tags: 'Tags',
      updateTime: 'UpdateTime',
      vanityNSList: 'VanityNSList',
      verifyCode: 'VerifyCode',
      versionManagement: 'VersionManagement',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessType: 'string',
      cnameZone: 'string',
      coverage: 'string',
      createTime: 'string',
      instanceId: 'string',
      nameServerList: 'string',
      planName: 'string',
      planSpecName: 'string',
      resourceGroupId: 'string',
      siteId: 'number',
      siteName: 'string',
      status: 'string',
      tags: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      updateTime: 'string',
      vanityNSList: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      verifyCode: 'string',
      versionManagement: 'boolean',
    };
  }

  validate() {
    if(this.tags) {
      $dara.Model.validateMap(this.tags);
    }
    if(this.vanityNSList) {
      $dara.Model.validateMap(this.vanityNSList);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteCustomLogResponseBodyLogCustomField extends $dara.Model {
  /**
   * @remarks
   * The cookie fields.
   */
  cookies?: string[];
  /**
   * @remarks
   * The request header fields.
   */
  requestHeaders?: string[];
  /**
   * @remarks
   * The response header fields.
   */
  responseHeaders?: string[];
  static names(): { [key: string]: string } {
    return {
      cookies: 'Cookies',
      requestHeaders: 'RequestHeaders',
      responseHeaders: 'ResponseHeaders',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cookies: { 'type': 'array', 'itemType': 'string' },
      requestHeaders: { 'type': 'array', 'itemType': 'string' },
      responseHeaders: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.cookies)) {
      $dara.Model.validateArray(this.cookies);
    }
    if(Array.isArray(this.requestHeaders)) {
      $dara.Model.validateArray(this.requestHeaders);
    }
    if(Array.isArray(this.responseHeaders)) {
      $dara.Model.validateArray(this.responseHeaders);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafFilterResponseBodyFilterFieldsLogicsValidator extends $dara.Model {
  /**
   * @remarks
   * The error message when the validation fails.
   * 
   * @example
   * Enter a valid expression
   */
  errMsg?: string;
  /**
   * @remarks
   * The length of the value.
   */
  length?: WafQuotaInteger;
  /**
   * @remarks
   * The regular expression pattern of the value, which is used to validate strings.
   * 
   * @example
   * ^example$
   */
  pattern?: string;
  /**
   * @remarks
   * The range of the value, which is used to validate numbers.
   */
  range?: WafQuotaInteger;
  static names(): { [key: string]: string } {
    return {
      errMsg: 'ErrMsg',
      length: 'Length',
      pattern: 'Pattern',
      range: 'Range',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errMsg: 'string',
      length: WafQuotaInteger,
      pattern: 'string',
      range: WafQuotaInteger,
    };
  }

  validate() {
    if(this.length && typeof (this.length as any).validate === 'function') {
      (this.length as any).validate();
    }
    if(this.range && typeof (this.range as any).validate === 'function') {
      (this.range as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafFilterResponseBodyFilterFieldsLogics extends $dara.Model {
  /**
   * @remarks
   * A custom attribute. For example, this parameter can specify whether the value is case-sensitive.
   * 
   * @example
   * 1
   */
  attributes?: number;
  /**
   * @remarks
   * The type of the value input box. Valid values:
   * 
   * *   select:single
   * *   select:multi
   * *   input:single
   * *   input:multi
   * 
   * @example
   * input:single
   */
  kind?: string;
  /**
   * @remarks
   * Indicates whether the match result is inverted.
   */
  negative?: boolean;
  /**
   * @remarks
   * The displayed matching characters.
   * 
   * @example
   * Does not equal
   */
  operator?: string;
  /**
   * @remarks
   * The matching characters in the system.
   * 
   * @example
   * eq
   */
  symbol?: string;
  /**
   * @remarks
   * The tip on how to enter a valid value that is required by the rules.
   * 
   * @example
   * e.g. image/jpeg
   */
  tip?: string;
  /**
   * @remarks
   * The type of the value. Valid values:
   * 
   * *   integer
   * *   integer_slice
   * *   string
   * *   string_slice
   * 
   * @example
   * string
   */
  type?: string;
  /**
   * @remarks
   * The validator, which defines the validation rules for a value.
   */
  validator?: GetWafFilterResponseBodyFilterFieldsLogicsValidator;
  static names(): { [key: string]: string } {
    return {
      attributes: 'Attributes',
      kind: 'Kind',
      negative: 'Negative',
      operator: 'Operator',
      symbol: 'Symbol',
      tip: 'Tip',
      type: 'Type',
      validator: 'Validator',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attributes: 'number',
      kind: 'string',
      negative: 'boolean',
      operator: 'string',
      symbol: 'string',
      tip: 'string',
      type: 'string',
      validator: GetWafFilterResponseBodyFilterFieldsLogicsValidator,
    };
  }

  validate() {
    if(this.validator && typeof (this.validator as any).validate === 'function') {
      (this.validator as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafFilterResponseBodyFilterFieldsSelectorData extends $dara.Model {
  /**
   * @remarks
   * The label of the data.
   * 
   * @example
   * China
   */
  label?: string;
  /**
   * @remarks
   * The value of the data.
   * 
   * @example
   * CN
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      label: 'Label',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      label: 'string',
      value: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafFilterResponseBodyFilterFieldsSelector extends $dara.Model {
  /**
   * @remarks
   * The data. This parameter is available only when the value of the Kind parameter is data.
   */
  data?: GetWafFilterResponseBodyFilterFieldsSelectorData[];
  /**
   * @remarks
   * The type of selector. Valid values: data and others.
   * 
   * @example
   * data
   */
  kind?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      kind: 'Kind',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': GetWafFilterResponseBodyFilterFieldsSelectorData },
      kind: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.data)) {
      $dara.Model.validateArray(this.data);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafFilterResponseBodyFilterFields extends $dara.Model {
  /**
   * @remarks
   * The field for matched objects in the system.
   * 
   * @example
   * http.request.headers
   */
  key?: string;
  /**
   * @remarks
   * The label of the matched object.
   * 
   * @example
   * Header
   */
  label?: string;
  /**
   * @remarks
   * The logical conditions.
   */
  logics?: GetWafFilterResponseBodyFilterFieldsLogics[];
  /**
   * @remarks
   * The selector, which defines how to select a matched object.
   */
  selector?: GetWafFilterResponseBodyFilterFieldsSelector;
  /**
   * @remarks
   * Indicates whether the matched object contains a subfield.
   * 
   * @example
   * true
   */
  sub?: boolean;
  /**
   * @remarks
   * The tip on how to enter a subfield.
   * 
   * @example
   * e.g. Content-Type
   */
  subTip?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      label: 'Label',
      logics: 'Logics',
      selector: 'Selector',
      sub: 'Sub',
      subTip: 'SubTip',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      label: 'string',
      logics: { 'type': 'array', 'itemType': GetWafFilterResponseBodyFilterFieldsLogics },
      selector: GetWafFilterResponseBodyFilterFieldsSelector,
      sub: 'boolean',
      subTip: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.logics)) {
      $dara.Model.validateArray(this.logics);
    }
    if(this.selector && typeof (this.selector as any).validate === 'function') {
      (this.selector as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafFilterResponseBodyFilter extends $dara.Model {
  /**
   * @remarks
   * The matched objects and related properties.
   */
  fields?: GetWafFilterResponseBodyFilterFields[];
  /**
   * @remarks
   * The WAF rule category.
   * 
   * @example
   * http_bot
   */
  phase?: string;
  /**
   * @remarks
   * The condition for matching incoming requests.
   * 
   * @example
   * characteristics
   */
  target?: string;
  /**
   * @remarks
   * The rule type.
   * 
   * @example
   * http_custom_cc
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      fields: 'Fields',
      phase: 'Phase',
      target: 'Target',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fields: { 'type': 'array', 'itemType': GetWafFilterResponseBodyFilterFields },
      phase: 'string',
      target: 'string',
      type: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.fields)) {
      $dara.Model.validateArray(this.fields);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafQuotaResponseBodyQuotaList extends $dara.Model {
  /**
   * @remarks
   * Indicates whether custom lists are enabled.
   */
  enable?: boolean;
  /**
   * @remarks
   * The quota information about all item types in the custom lists.
   */
  items?: { [key: string]: QuotaListItemsValue };
  /**
   * @remarks
   * The maximum number of items in each custom list.
   */
  numberItemsPerList?: WafQuotaInteger;
  /**
   * @remarks
   * The maximum number of items in all custom lists.
   */
  numberItemsTotal?: WafQuotaInteger;
  /**
   * @remarks
   * The maximum number of custom lists.
   */
  numberTotal?: WafQuotaInteger;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
      items: 'Items',
      numberItemsPerList: 'NumberItemsPerList',
      numberItemsTotal: 'NumberItemsTotal',
      numberTotal: 'NumberTotal',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'boolean',
      items: { 'type': 'map', 'keyType': 'string', 'valueType': QuotaListItemsValue },
      numberItemsPerList: WafQuotaInteger,
      numberItemsTotal: WafQuotaInteger,
      numberTotal: WafQuotaInteger,
    };
  }

  validate() {
    if(this.items) {
      $dara.Model.validateMap(this.items);
    }
    if(this.numberItemsPerList && typeof (this.numberItemsPerList as any).validate === 'function') {
      (this.numberItemsPerList as any).validate();
    }
    if(this.numberItemsTotal && typeof (this.numberItemsTotal as any).validate === 'function') {
      (this.numberItemsTotal as any).validate();
    }
    if(this.numberTotal && typeof (this.numberTotal as any).validate === 'function') {
      (this.numberTotal as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafQuotaResponseBodyQuotaManagedRulesGroup extends $dara.Model {
  /**
   * @remarks
   * Indicates whether the WAF managed rule group is enabled.
   */
  enable?: boolean;
  /**
   * @remarks
   * The maximum number of WAF managed rule groups.
   */
  numberTotal?: WafQuotaInteger;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
      numberTotal: 'NumberTotal',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'boolean',
      numberTotal: WafQuotaInteger,
    };
  }

  validate() {
    if(this.numberTotal && typeof (this.numberTotal as any).validate === 'function') {
      (this.numberTotal as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafQuotaResponseBodyQuotaPage extends $dara.Model {
  /**
   * @remarks
   * The quota information about custom error pages of all Content-Types.
   */
  contentTypes?: { [key: string]: QuotaPageContentTypesValue };
  /**
   * @remarks
   * Indicates whether custom error pages are enabled.
   */
  enable?: boolean;
  /**
   * @remarks
   * The maximum number of custom error pages.
   */
  numberTotal?: WafQuotaInteger;
  static names(): { [key: string]: string } {
    return {
      contentTypes: 'ContentTypes',
      enable: 'Enable',
      numberTotal: 'NumberTotal',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentTypes: { 'type': 'map', 'keyType': 'string', 'valueType': QuotaPageContentTypesValue },
      enable: 'boolean',
      numberTotal: WafQuotaInteger,
    };
  }

  validate() {
    if(this.contentTypes) {
      $dara.Model.validateMap(this.contentTypes);
    }
    if(this.numberTotal && typeof (this.numberTotal as any).validate === 'function') {
      (this.numberTotal as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafQuotaResponseBodyQuotaScenePolicy extends $dara.Model {
  /**
   * @remarks
   * Indicates whether scenario-specific policies are enabled.
   */
  enable?: boolean;
  /**
   * @remarks
   * The maximum number of scenario-specific policies.
   */
  numberTotal?: WafQuotaInteger;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
      numberTotal: 'NumberTotal',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'boolean',
      numberTotal: WafQuotaInteger,
    };
  }

  validate() {
    if(this.numberTotal && typeof (this.numberTotal as any).validate === 'function') {
      (this.numberTotal as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafQuotaResponseBodyQuota extends $dara.Model {
  /**
   * @remarks
   * The quota information about custom lists.
   */
  list?: GetWafQuotaResponseBodyQuotaList;
  /**
   * @remarks
   * The quota information about WAF managed rule groups.
   */
  managedRulesGroup?: GetWafQuotaResponseBodyQuotaManagedRulesGroup;
  /**
   * @remarks
   * The quota information about custom error pages.
   */
  page?: GetWafQuotaResponseBodyQuotaPage;
  /**
   * @remarks
   * The quota information about scenario-specific policies.
   */
  scenePolicy?: GetWafQuotaResponseBodyQuotaScenePolicy;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      managedRulesGroup: 'ManagedRulesGroup',
      page: 'Page',
      scenePolicy: 'ScenePolicy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: GetWafQuotaResponseBodyQuotaList,
      managedRulesGroup: GetWafQuotaResponseBodyQuotaManagedRulesGroup,
      page: GetWafQuotaResponseBodyQuotaPage,
      scenePolicy: GetWafQuotaResponseBodyQuotaScenePolicy,
    };
  }

  validate() {
    if(this.list && typeof (this.list as any).validate === 'function') {
      (this.list as any).validate();
    }
    if(this.managedRulesGroup && typeof (this.managedRulesGroup as any).validate === 'function') {
      (this.managedRulesGroup as any).validate();
    }
    if(this.page && typeof (this.page as any).validate === 'function') {
      (this.page as any).validate();
    }
    if(this.scenePolicy && typeof (this.scenePolicy as any).validate === 'function') {
      (this.scenePolicy as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCacheReserveInstancesResponseBodyInstanceInfo extends $dara.Model {
  /**
   * @remarks
   * The capacity of the cache reserve instance. Unit: GB.
   * 
   * @example
   * 512000
   */
  cacheReserveCapacity?: string;
  /**
   * @remarks
   * The region in which the cache reserve instance resides.
   * 
   * @example
   * HK
   */
  cacheReserveRegion?: string;
  /**
   * @remarks
   * The time when the cache reserve instance was purchased.
   * 
   * @example
   * 2024-04-12T05:41:51Z
   */
  createTime?: string;
  /**
   * @remarks
   * The subscription period of the cache reserve instance. Unit: months.
   * 
   * @example
   * 3
   */
  duration?: number;
  /**
   * @remarks
   * The time when the cache reserve instance expires.
   * 
   * @example
   * 2024-10-05T16:00:00Z
   */
  expireTime?: string;
  /**
   * @remarks
   * The ID of the cache reserve instance.
   * 
   * @example
   * sp-xcdn-96wblslz****
   */
  instanceId?: string;
  /**
   * @remarks
   * The status of the cache reserve instance. Valid values:
   * 
   * *   online: The instance is in service.
   * *   offline: The instance has expired within an allowable period. In this state, the plan is unavailable.
   * *   disable: The instance is released.
   * *   overdue: The service was stopped due to overdue payments.
   * 
   * @example
   * online
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      cacheReserveCapacity: 'CacheReserveCapacity',
      cacheReserveRegion: 'CacheReserveRegion',
      createTime: 'CreateTime',
      duration: 'Duration',
      expireTime: 'ExpireTime',
      instanceId: 'InstanceId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cacheReserveCapacity: 'string',
      cacheReserveRegion: 'string',
      createTime: 'string',
      duration: 'number',
      expireTime: 'string',
      instanceId: 'string',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCacheRulesResponseBodyConfigs extends $dara.Model {
  /**
   * @example
   * 2082
   */
  additionalCacheablePorts?: string;
  /**
   * @example
   * no_cache
   */
  browserCacheMode?: string;
  /**
   * @example
   * 300
   */
  browserCacheTtl?: string;
  /**
   * @example
   * cache_all
   */
  bypassCache?: string;
  /**
   * @example
   * on
   */
  cacheDeceptionArmor?: string;
  /**
   * @example
   * bypass_cache_reserve
   */
  cacheReserveEligibility?: string;
  /**
   * @example
   * cookiename
   */
  checkPresenceCookie?: string;
  /**
   * @example
   * headername
   */
  checkPresenceHeader?: string;
  /**
   * @example
   * 395386449776640
   */
  configId?: number;
  /**
   * @example
   * global
   */
  configType?: string;
  /**
   * @example
   * follow_origin
   */
  edgeCacheMode?: string;
  /**
   * @example
   * 300
   */
  edgeCacheTtl?: string;
  /**
   * @example
   * 300
   */
  edgeStatusCodeCacheTtl?: string;
  /**
   * @example
   * cookie_exapmle
   */
  includeCookie?: string;
  /**
   * @example
   * example
   */
  includeHeader?: string;
  /**
   * @example
   * example
   */
  queryString?: string;
  /**
   * @example
   * ignore_all
   */
  queryStringMode?: string;
  /**
   * @example
   * (http.host eq \\"video.example.com\\")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @example
   * 1
   */
  sequence?: number;
  /**
   * @example
   * on
   */
  serveStale?: string;
  /**
   * @example
   * 1
   */
  siteVersion?: number;
  /**
   * @example
   * on
   */
  sortQueryStringForCache?: string;
  /**
   * @example
   * on
   */
  userDeviceType?: string;
  /**
   * @example
   * on
   */
  userGeo?: string;
  /**
   * @example
   * on
   */
  userLanguage?: string;
  static names(): { [key: string]: string } {
    return {
      additionalCacheablePorts: 'AdditionalCacheablePorts',
      browserCacheMode: 'BrowserCacheMode',
      browserCacheTtl: 'BrowserCacheTtl',
      bypassCache: 'BypassCache',
      cacheDeceptionArmor: 'CacheDeceptionArmor',
      cacheReserveEligibility: 'CacheReserveEligibility',
      checkPresenceCookie: 'CheckPresenceCookie',
      checkPresenceHeader: 'CheckPresenceHeader',
      configId: 'ConfigId',
      configType: 'ConfigType',
      edgeCacheMode: 'EdgeCacheMode',
      edgeCacheTtl: 'EdgeCacheTtl',
      edgeStatusCodeCacheTtl: 'EdgeStatusCodeCacheTtl',
      includeCookie: 'IncludeCookie',
      includeHeader: 'IncludeHeader',
      queryString: 'QueryString',
      queryStringMode: 'QueryStringMode',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      serveStale: 'ServeStale',
      siteVersion: 'SiteVersion',
      sortQueryStringForCache: 'SortQueryStringForCache',
      userDeviceType: 'UserDeviceType',
      userGeo: 'UserGeo',
      userLanguage: 'UserLanguage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      additionalCacheablePorts: 'string',
      browserCacheMode: 'string',
      browserCacheTtl: 'string',
      bypassCache: 'string',
      cacheDeceptionArmor: 'string',
      cacheReserveEligibility: 'string',
      checkPresenceCookie: 'string',
      checkPresenceHeader: 'string',
      configId: 'number',
      configType: 'string',
      edgeCacheMode: 'string',
      edgeCacheTtl: 'string',
      edgeStatusCodeCacheTtl: 'string',
      includeCookie: 'string',
      includeHeader: 'string',
      queryString: 'string',
      queryStringMode: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'number',
      serveStale: 'string',
      siteVersion: 'number',
      sortQueryStringForCache: 'string',
      userDeviceType: 'string',
      userGeo: 'string',
      userLanguage: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCertificatesResponseBodyResultDCV extends $dara.Model {
  id?: string;
  key?: string;
  status?: string;
  type?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      key: 'Key',
      status: 'Status',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      key: 'string',
      status: 'string',
      type: 'string',
      value: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCertificatesResponseBodyResult extends $dara.Model {
  applyCode?: number;
  applyMessage?: string;
  /**
   * @example
   * 30000569
   */
  casId?: string;
  /**
   * @example
   * www.example.com
   */
  commonName?: string;
  /**
   * @example
   * 2022-06-24 07:48:51
   */
  createTime?: string;
  DCV?: ListCertificatesResponseBodyResultDCV[];
  /**
   * @example
   * 1dc5fc9af4eead2570c70d94b416130baeb6d4429b51fd3557379588456a****
   */
  fingerprintSha256?: string;
  /**
   * @example
   * baba39055622c008b90285a8838e****
   */
  id?: string;
  /**
   * @example
   * GlobalSign nv-sa
   */
  issuer?: string;
  /**
   * @example
   * GlobalSign Organization Validation CA - SHA256 - G3
   */
  issuerCN?: string;
  /**
   * @example
   * yourCertName
   */
  name?: string;
  /**
   * @example
   * 2024-03-31 02:08:00
   */
  notAfter?: string;
  /**
   * @example
   * 2023-03-31 02:08:00
   */
  notBefore?: string;
  /**
   * @example
   * RSA
   */
  pubAlg?: string;
  /**
   * @example
   * cn-hangzhou
   */
  region?: string;
  /**
   * @example
   * www.example.com,*.example.com
   */
  SAN?: string;
  /**
   * @example
   * babab022c5e9b27bf9c64d7f4b16****
   */
  serialNumber?: string;
  /**
   * @example
   * SHA256-RSA
   */
  sigAlg?: string;
  /**
   * @example
   * OK
   */
  status?: string;
  /**
   * @example
   * free
   */
  type?: string;
  /**
   * @example
   * 2023-04-20 06:18:42
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      applyCode: 'ApplyCode',
      applyMessage: 'ApplyMessage',
      casId: 'CasId',
      commonName: 'CommonName',
      createTime: 'CreateTime',
      DCV: 'DCV',
      fingerprintSha256: 'FingerprintSha256',
      id: 'Id',
      issuer: 'Issuer',
      issuerCN: 'IssuerCN',
      name: 'Name',
      notAfter: 'NotAfter',
      notBefore: 'NotBefore',
      pubAlg: 'PubAlg',
      region: 'Region',
      SAN: 'SAN',
      serialNumber: 'SerialNumber',
      sigAlg: 'SigAlg',
      status: 'Status',
      type: 'Type',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyCode: 'number',
      applyMessage: 'string',
      casId: 'string',
      commonName: 'string',
      createTime: 'string',
      DCV: { 'type': 'array', 'itemType': ListCertificatesResponseBodyResultDCV },
      fingerprintSha256: 'string',
      id: 'string',
      issuer: 'string',
      issuerCN: 'string',
      name: 'string',
      notAfter: 'string',
      notBefore: 'string',
      pubAlg: 'string',
      region: 'string',
      SAN: 'string',
      serialNumber: 'string',
      sigAlg: 'string',
      status: 'string',
      type: 'string',
      updateTime: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.DCV)) {
      $dara.Model.validateArray(this.DCV);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClientCaCertificatesResponseBodyResult extends $dara.Model {
  /**
   * @remarks
   * The Common Name of the certificate.
   * 
   * @example
   * www.example.com
   */
  commonName?: string;
  /**
   * @remarks
   * The time when the certificate was created.
   * 
   * @example
   * 2024-06-24 07:48:51
   */
  createTime?: string;
  /**
   * @remarks
   * The certificate ID.
   * 
   * @example
   * babab9db65ee5efcca9f3d41d4b5****
   */
  id?: string;
  /**
   * @remarks
   * The CA that issued the certificate.
   * 
   * @example
   * GlobalSign nv-sa
   */
  issuer?: string;
  /**
   * @remarks
   * The certificate name.
   * 
   * @example
   * yourCertName
   */
  name?: string;
  /**
   * @remarks
   * The time when the certificate expires.
   * 
   * @example
   * 2024-03-31 02:08:00
   */
  notAfter?: string;
  /**
   * @remarks
   * The time when the certificate takes effect.
   * 
   * @example
   * 2023-03-31 02:08:00
   */
  notBefore?: string;
  /**
   * @remarks
   * The public-key algorithm of the certificate.
   * 
   * @example
   * RSA
   */
  pubkeyAlgorithm?: string;
  /**
   * @remarks
   * The Subject Alternative Name (SAN) of the certificate.
   * 
   * @example
   * www.example.com,*.example.com
   */
  SAN?: string;
  /**
   * @remarks
   * The signature algorithm of the certificate.
   * 
   * @example
   * SHA256-RSA
   */
  signatureAlgorithm?: string;
  /**
   * @remarks
   * The certificate status.
   * 
   * @example
   * OK
   */
  status?: string;
  /**
   * @remarks
   * The certificate type.
   * 
   * @example
   * upload
   */
  type?: string;
  /**
   * @remarks
   * The time when the certificate was updated.
   * 
   * @example
   * 2024-07-20 06:18:42
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      commonName: 'CommonName',
      createTime: 'CreateTime',
      id: 'Id',
      issuer: 'Issuer',
      name: 'Name',
      notAfter: 'NotAfter',
      notBefore: 'NotBefore',
      pubkeyAlgorithm: 'PubkeyAlgorithm',
      SAN: 'SAN',
      signatureAlgorithm: 'SignatureAlgorithm',
      status: 'Status',
      type: 'Type',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonName: 'string',
      createTime: 'string',
      id: 'string',
      issuer: 'string',
      name: 'string',
      notAfter: 'string',
      notBefore: 'string',
      pubkeyAlgorithm: 'string',
      SAN: 'string',
      signatureAlgorithm: 'string',
      status: 'string',
      type: 'string',
      updateTime: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClientCertificatesResponseBodyResult extends $dara.Model {
  /**
   * @remarks
   * The ID of the CA certificate.
   * 
   * @example
   * baba39055622c008b90285a8838ed09a
   */
  CACertificateId?: string;
  /**
   * @remarks
   * The Common Name of the certificate.
   * 
   * @example
   * www.example.com
   */
  commonName?: string;
  /**
   * @remarks
   * The time when the certificate was created.
   * 
   * @example
   * 2024-06-24 07:48:51
   */
  createTime?: string;
  /**
   * @remarks
   * The certificate ID.
   * 
   * @example
   * babab9db65ee5efcca9f3d41d4b50d66
   */
  id?: string;
  /**
   * @remarks
   * The certificate authority (CA) that issued the certificate.
   * 
   * @example
   * GlobalSign nv-sa
   */
  issuer?: string;
  /**
   * @remarks
   * The certificate name.
   * 
   * @example
   * yourCertName
   */
  name?: string;
  /**
   * @remarks
   * The time when the certificate expires.
   * 
   * @example
   * 2024-03-31 02:08:00
   */
  notAfter?: string;
  /**
   * @remarks
   * The time when the certificate takes effect.
   * 
   * @example
   * 2023-03-31 02:08:00
   */
  notBefore?: string;
  /**
   * @remarks
   * The public key algorithm of the certificate.
   * 
   * @example
   * RSA
   */
  pubkeyAlgorithm?: string;
  /**
   * @remarks
   * The Subject Alternative Name (SAN) of the certificate.
   * 
   * @example
   * www.example.com,*.example.com
   */
  SAN?: string;
  /**
   * @remarks
   * The signature algorithm of the certificate.
   * 
   * @example
   * SHA256-RSA
   */
  signatureAlgorithm?: string;
  /**
   * @remarks
   * The certificate status.
   * 
   * @example
   * active
   */
  status?: string;
  /**
   * @remarks
   * The certificate type.
   * 
   * @example
   * dcdn
   */
  type?: string;
  /**
   * @remarks
   * The time when the certificate was updated.
   * 
   * @example
   * 2024-07-20 06:18:42
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      CACertificateId: 'CACertificateId',
      commonName: 'CommonName',
      createTime: 'CreateTime',
      id: 'Id',
      issuer: 'Issuer',
      name: 'Name',
      notAfter: 'NotAfter',
      notBefore: 'NotBefore',
      pubkeyAlgorithm: 'PubkeyAlgorithm',
      SAN: 'SAN',
      signatureAlgorithm: 'SignatureAlgorithm',
      status: 'Status',
      type: 'Type',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      CACertificateId: 'string',
      commonName: 'string',
      createTime: 'string',
      id: 'string',
      issuer: 'string',
      name: 'string',
      notAfter: 'string',
      notBefore: 'string',
      pubkeyAlgorithm: 'string',
      SAN: 'string',
      signatureAlgorithm: 'string',
      status: 'string',
      type: 'string',
      updateTime: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCompressionRulesResponseBodyConfigs extends $dara.Model {
  /**
   * @remarks
   * Indicates whether Brotli compression is enabled. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  brotli?: string;
  /**
   * @remarks
   * The configuration ID.
   * 
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @remarks
   * The type of the configuration. Valid values:
   * 
   * *   global: global configuration.
   * *   rule: rule configuration.
   * 
   * @example
   * rule
   */
  configType?: string;
  /**
   * @remarks
   * Indicates whether Gzip compression is enabled. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  gzip?: string;
  /**
   * @remarks
   * The rule content.
   * 
   * @example
   * (http.host eq "video.example.com")
   */
  rule?: string;
  /**
   * @remarks
   * Indicates whether the rule is enabled. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @remarks
   * The rule name.
   * 
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * The order in which the rule is executed.
   * 
   * @example
   * 1
   */
  sequence?: number;
  /**
   * @remarks
   * The version of the website configurations.
   * 
   * @example
   * 1
   */
  siteVersion?: number;
  zstd?: string;
  static names(): { [key: string]: string } {
    return {
      brotli: 'Brotli',
      configId: 'ConfigId',
      configType: 'ConfigType',
      gzip: 'Gzip',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      siteVersion: 'SiteVersion',
      zstd: 'Zstd',
    };
  }

  static types(): { [key: string]: any } {
    return {
      brotli: 'string',
      configId: 'number',
      configType: 'string',
      gzip: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'number',
      siteVersion: 'number',
      zstd: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppRecordsResponseBodyRecords extends $dara.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The CNAME of the associated domain name.
   * 
   * @example
   * kdxceo****.yun****.com
   */
  cname?: string;
  /**
   * @remarks
   * The configuration ID of the associated domain name.
   * 
   * @example
   * 27522948436****
   */
  configId?: number;
  /**
   * @remarks
   * The time when the domain name was added. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2023-12-24T02:01:11Z
   */
  createTime?: string;
  /**
   * @remarks
   * The record ID of the associated domain name.
   * 
   * @example
   * 266****
   */
  recordId?: number;
  /**
   * @remarks
   * The associated domain name.
   * 
   * @example
   * a.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The scheduling domain ID of the associated domain name.
   * 
   * @example
   * 123456
   */
  schemdId?: number;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 5407498413****
   */
  siteId?: number;
  /**
   * @remarks
   * The time when the scheduling domain ID or CNAME was last modified. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2021-12-22T08:32:02Z
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      cname: 'Cname',
      configId: 'ConfigId',
      createTime: 'CreateTime',
      recordId: 'RecordId',
      recordName: 'RecordName',
      schemdId: 'SchemdId',
      siteId: 'SiteId',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      cname: 'string',
      configId: 'number',
      createTime: 'string',
      recordId: 'number',
      recordName: 'string',
      schemdId: 'number',
      siteId: 'number',
      updateTime: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppVersionsResponseBodyVersionsContainersProbeContent extends $dara.Model {
  /**
   * @remarks
   * The probe command.
   * 
   * @example
   * openresty -g  "daemon off;
   */
  command?: string;
  /**
   * @remarks
   * The number of consecutive failed health checks required for a container to be considered as unhealthy.
   * 
   * @example
   * 3
   */
  failureThreshold?: number;
  /**
   * @remarks
   * The domain name that is used for health checks.
   * 
   * @example
   * test.com
   */
  host?: string;
  /**
   * @remarks
   * The request headers that are included in the container health check request.
   * 
   * @example
   * {\\"Content-Type\\":\\"application/json\\"}
   */
  httpHeaders?: string;
  /**
   * @remarks
   * The latency for container probe initialization.
   * 
   * @example
   * 10
   */
  initialDelaySeconds?: number;
  /**
   * @remarks
   * The path of the container health check.
   * 
   * @example
   * /health_check
   */
  path?: string;
  /**
   * @remarks
   * The interval between container health checks.
   * 
   * @example
   * 5
   */
  periodSeconds?: number;
  /**
   * @remarks
   * The port of the container health check.
   * 
   * @example
   * 80
   */
  port?: number;
  /**
   * @remarks
   * The protocol that the container health check request uses.
   * 
   * @example
   * http
   */
  scheme?: string;
  /**
   * @remarks
   * The number of consecutive successful health checks required for a container to be considered as healthy.
   * 
   * @example
   * 1
   */
  successThreshold?: number;
  /**
   * @remarks
   * The timeout period of the container health check.
   * 
   * @example
   * 30
   */
  timeoutSeconds?: number;
  static names(): { [key: string]: string } {
    return {
      command: 'Command',
      failureThreshold: 'FailureThreshold',
      host: 'Host',
      httpHeaders: 'HttpHeaders',
      initialDelaySeconds: 'InitialDelaySeconds',
      path: 'Path',
      periodSeconds: 'PeriodSeconds',
      port: 'Port',
      scheme: 'Scheme',
      successThreshold: 'SuccessThreshold',
      timeoutSeconds: 'TimeoutSeconds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      command: 'string',
      failureThreshold: 'number',
      host: 'string',
      httpHeaders: 'string',
      initialDelaySeconds: 'number',
      path: 'string',
      periodSeconds: 'number',
      port: 'number',
      scheme: 'string',
      successThreshold: 'number',
      timeoutSeconds: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppVersionsResponseBodyVersionsContainers extends $dara.Model {
  /**
   * @remarks
   * The arguments that are passed to the container startup command.
   * 
   * @example
   * -c a=1
   */
  args?: string;
  /**
   * @remarks
   * The command that is used to start the container.
   * 
   * @example
   * openresty -g \\"daemon off;\\"
   */
  command?: string;
  /**
   * @remarks
   * The environment variables of the container.
   * 
   * @example
   * ENV=prod
   */
  envVariables?: string;
  /**
   * @remarks
   * The address of the container image.
   * 
   * @example
   * nginx
   */
  image?: string;
  /**
   * @remarks
   * The container name.
   * 
   * @example
   * container1
   */
  name?: string;
  /**
   * @remarks
   * The command that is run before the container is started. Format: `{"exec":{"command":["cat","/etc/group"\\]}}`.
   * 
   * If you want to cancel this configuration, set the parameter value to `""` or `{}`. If you do not specify this parameter, this configuration is ignored.
   * 
   * @example
   * {\\"exec\\":{\\"command\\":[\\"bash\\",\\"-c\\",\\"cd /home/admin/
   */
  postStart?: string;
  /**
   * @remarks
   * The command that is run before the container is stopped.
   * 
   * @example
   * sh stop.sh
   */
  preStop?: string;
  /**
   * @remarks
   * The container probe content.
   */
  probeContent?: ListEdgeContainerAppVersionsResponseBodyVersionsContainersProbeContent;
  /**
   * @remarks
   * The probe type of the container.
   * 
   * @example
   * httpGet
   */
  probeType?: string;
  /**
   * @remarks
   * The compute specification of the container.
   * 
   * @example
   * 1C2G
   */
  spec?: string;
  static names(): { [key: string]: string } {
    return {
      args: 'Args',
      command: 'Command',
      envVariables: 'EnvVariables',
      image: 'Image',
      name: 'Name',
      postStart: 'PostStart',
      preStop: 'PreStop',
      probeContent: 'ProbeContent',
      probeType: 'ProbeType',
      spec: 'Spec',
    };
  }

  static types(): { [key: string]: any } {
    return {
      args: 'string',
      command: 'string',
      envVariables: 'string',
      image: 'string',
      name: 'string',
      postStart: 'string',
      preStop: 'string',
      probeContent: ListEdgeContainerAppVersionsResponseBodyVersionsContainersProbeContent,
      probeType: 'string',
      spec: 'string',
    };
  }

  validate() {
    if(this.probeContent && typeof (this.probeContent as any).validate === 'function') {
      (this.probeContent as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppVersionsResponseBodyVersions extends $dara.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The containers in the version.
   */
  containers?: ListEdgeContainerAppVersionsResponseBodyVersionsContainers[];
  /**
   * @remarks
   * The time when the version was created. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2022-11-10T02:53:16Z
   */
  createTime?: string;
  /**
   * @remarks
   * The time when the version was last released. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2023-02-10T02:48:36Z
   */
  lastPublishTime?: string;
  /**
   * @remarks
   * The version name.
   * 
   * @example
   * version01
   */
  name?: string;
  /**
   * @remarks
   * The time when the version was released. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2023-02-10T02:48:36Z
   */
  publishTime?: string;
  /**
   * @remarks
   * The remarks.
   * 
   * @example
   * test version
   */
  remarks?: string;
  /**
   * @remarks
   * The status of the current version. Valid values:
   * 
   * *   **created**
   * *   **failed**
   * *   **creating**
   * 
   * @example
   * created
   */
  status?: string;
  /**
   * @remarks
   * The time when the version was last modified. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2023-04-16 10:51:00
   */
  updateTime?: string;
  /**
   * @remarks
   * The version ID.
   * 
   * @example
   * ver-87962637161651****
   */
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      containers: 'Containers',
      createTime: 'CreateTime',
      lastPublishTime: 'LastPublishTime',
      name: 'Name',
      publishTime: 'PublishTime',
      remarks: 'Remarks',
      status: 'Status',
      updateTime: 'UpdateTime',
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      containers: { 'type': 'array', 'itemType': ListEdgeContainerAppVersionsResponseBodyVersionsContainers },
      createTime: 'string',
      lastPublishTime: 'string',
      name: 'string',
      publishTime: 'string',
      remarks: 'string',
      status: 'string',
      updateTime: 'string',
      versionId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.containers)) {
      $dara.Model.validateArray(this.containers);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppsResponseBodyAppsHealthCheck extends $dara.Model {
  /**
   * @remarks
   * The number of consecutive failed health checks for an application to be considered unhealthy.
   * 
   * @example
   * 5
   */
  failTimes?: number;
  /**
   * @remarks
   * The domain name that is used for health checks.
   * 
   * @example
   * test.com
   */
  host?: string;
  /**
   * @remarks
   * The range of health check status codes that indicate successful health checks.
   * 
   * @example
   * http_2XX
   */
  httpCode?: string;
  /**
   * @remarks
   * The interval between health checks. Unit: seconds.
   * 
   * @example
   * 5
   */
  interval?: number;
  /**
   * @remarks
   * The HTTP method used for health checks.
   * 
   * @example
   * GET
   */
  method?: string;
  /**
   * @remarks
   * The health check port.
   * 
   * @example
   * 8080
   */
  port?: number;
  /**
   * @remarks
   * The number of consecutive successful health checks for an application to be considered healthy.
   * 
   * @example
   * 1
   */
  succTimes?: number;
  /**
   * @remarks
   * The timeout period of health checks. Unit: seconds.
   * 
   * @example
   * 60
   */
  timeout?: number;
  /**
   * @remarks
   * The type of health checks. Valid values:
   * 
   * *   l7
   * *   l4
   * 
   * @example
   * l7
   */
  type?: string;
  /**
   * @remarks
   * The health check URL.
   * 
   * @example
   * /health_check
   */
  uri?: string;
  static names(): { [key: string]: string } {
    return {
      failTimes: 'FailTimes',
      host: 'Host',
      httpCode: 'HttpCode',
      interval: 'Interval',
      method: 'Method',
      port: 'Port',
      succTimes: 'SuccTimes',
      timeout: 'Timeout',
      type: 'Type',
      uri: 'Uri',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failTimes: 'number',
      host: 'string',
      httpCode: 'string',
      interval: 'number',
      method: 'string',
      port: 'number',
      succTimes: 'number',
      timeout: 'number',
      type: 'string',
      uri: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppsResponseBodyApps extends $dara.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The time when the version was created.
   * 
   * @example
   * 2022-12-01T16:16:27.418298794+08:00
   */
  createTime?: string;
  /**
   * @remarks
   * The domain name associated with the application.
   * 
   * @example
   * test.com
   */
  domainName?: string;
  /**
   * @remarks
   * The type of the gateway. Valid values:
   * 
   * *   l7: Layer 7 gateway.
   * *   l4: Layer 4 gateway.
   * 
   * @example
   * l7
   */
  gatewayType?: string;
  /**
   * @remarks
   * The information about health checks.
   */
  healthCheck?: ListEdgeContainerAppsResponseBodyAppsHealthCheck;
  /**
   * @remarks
   * The application name.
   * 
   * @example
   * app-test
   */
  name?: string;
  /**
   * @remarks
   * The progress of the application creation task in percentage.
   * 
   * @example
   * 100
   */
  percentage?: number;
  /**
   * @remarks
   * Indicates whether QUIC is enabled.
   * 
   * @example
   * false
   */
  quicCid?: string;
  /**
   * @remarks
   * The remarks.
   * 
   * @example
   * test app
   */
  remarks?: string;
  /**
   * @remarks
   * The server port. Valid values: 1 to 65535.
   * 
   * @example
   * 80
   */
  servicePort?: number;
  /**
   * @remarks
   * The status of the application. Valid values:
   * 
   * *   creating: The application is being created.
   * *   failed: The application failed to be created.
   * *   created: The application is created.
   * 
   * @example
   * created
   */
  status?: string;
  /**
   * @remarks
   * The backend port, which is also the service port of the application. Valid values: 1 to 65535.
   * 
   * @example
   * 80
   */
  targetPort?: number;
  /**
   * @remarks
   * The time when the application was last modified. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
   * 
   * @example
   * 2023-11-15T12:11:02Z
   */
  updateTime?: string;
  /**
   * @remarks
   * The number of versions of the application.
   * 
   * @example
   * 10
   */
  versionCount?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      createTime: 'CreateTime',
      domainName: 'DomainName',
      gatewayType: 'GatewayType',
      healthCheck: 'HealthCheck',
      name: 'Name',
      percentage: 'Percentage',
      quicCid: 'QuicCid',
      remarks: 'Remarks',
      servicePort: 'ServicePort',
      status: 'Status',
      targetPort: 'TargetPort',
      updateTime: 'UpdateTime',
      versionCount: 'VersionCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      createTime: 'string',
      domainName: 'string',
      gatewayType: 'string',
      healthCheck: ListEdgeContainerAppsResponseBodyAppsHealthCheck,
      name: 'string',
      percentage: 'number',
      quicCid: 'string',
      remarks: 'string',
      servicePort: 'number',
      status: 'string',
      targetPort: 'number',
      updateTime: 'string',
      versionCount: 'number',
    };
  }

  validate() {
    if(this.healthCheck && typeof (this.healthCheck as any).validate === 'function') {
      (this.healthCheck as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerRecordsResponseBodyRecords extends $dara.Model {
  /**
   * @remarks
   * The time when the record was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-12-24T02:01:11Z
   */
  createTime?: string;
  /**
   * @remarks
   * The CNAME. If you use CNAME setup when you add your website to ESA, the value is the CNAME that you configured.
   * 
   * @example
   * a.example.com.cnamezone.com
   */
  recordCname?: string;
  /**
   * @remarks
   * The record name.
   * 
   * @example
   * a.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  /**
   * @remarks
   * The time when the record was updated. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2021-12-22T08:32:02Z
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      recordCname: 'RecordCname',
      recordName: 'RecordName',
      siteId: 'SiteId',
      siteName: 'SiteName',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      recordCname: 'string',
      recordName: 'string',
      siteId: 'number',
      siteName: 'string',
      updateTime: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeRoutinePlansResponseBodyPlanInfo extends $dara.Model {
  /**
   * @remarks
   * The billing method. Valid values:
   * 
   * *   PREPAY: subscription.
   * *   POSTPAY: pay-as-you-go.
   * 
   * @example
   * POSTPAY
   */
  billingMode?: string;
  /**
   * @remarks
   * The maximum number of versions that each routine supports.
   * 
   * @example
   * 20
   */
  erRoutineCodeVersionQuota?: string;
  /**
   * @remarks
   * The maximum of routines that can be created.
   * 
   * @example
   * 100
   */
  erRoutineQuota?: string;
  /**
   * @remarks
   * The maximum number of websites with which each routine can be associated.
   * 
   * @example
   * 100
   */
  erRoutineRouteSiteCountQuota?: string;
  /**
   * @remarks
   * The payment method. Valid values:
   * 
   * *   er_free
   * *   er_pay
   * 
   * @example
   * er_free
   */
  paymentMethod?: string;
  /**
   * @remarks
   * The plan name.
   * 
   * @example
   * test_plan
   */
  planName?: string;
  static names(): { [key: string]: string } {
    return {
      billingMode: 'BillingMode',
      erRoutineCodeVersionQuota: 'ErRoutineCodeVersionQuota',
      erRoutineQuota: 'ErRoutineQuota',
      erRoutineRouteSiteCountQuota: 'ErRoutineRouteSiteCountQuota',
      paymentMethod: 'PaymentMethod',
      planName: 'PlanName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      billingMode: 'string',
      erRoutineCodeVersionQuota: 'string',
      erRoutineQuota: 'string',
      erRoutineRouteSiteCountQuota: 'string',
      paymentMethod: 'string',
      planName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeRoutineRecordsResponseBodyRecords extends $dara.Model {
  /**
   * @remarks
   * The time when the record was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-12-24T02:01:11Z
   */
  createTime?: string;
  /**
   * @remarks
   * The CNAME. If you use CNAME setup when you add your website to ESA, the value is the CNAME that you configured then.
   * 
   * @example
   * a.example.com.cnamezone.com
   */
  recordCname?: string;
  /**
   * @remarks
   * The record name.
   * 
   * @example
   * a.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 5407498413****
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  /**
   * @remarks
   * The time when the record was updated. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-12-22T08:32:02Z
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      recordCname: 'RecordCname',
      recordName: 'RecordName',
      siteId: 'SiteId',
      siteName: 'SiteName',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      recordCname: 'string',
      recordName: 'string',
      siteId: 'number',
      siteName: 'string',
      updateTime: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHttpRequestHeaderModificationRulesResponseBodyConfigsRequestHeaderModification extends $dara.Model {
  /**
   * @example
   * headerName
   */
  name?: string;
  /**
   * @example
   * add
   */
  operation?: string;
  /**
   * @example
   * headerValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      operation: 'Operation',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      operation: 'string',
      value: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHttpRequestHeaderModificationRulesResponseBodyConfigs extends $dara.Model {
  /**
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @example
   * global
   */
  configType?: string;
  requestHeaderModification?: ListHttpRequestHeaderModificationRulesResponseBodyConfigsRequestHeaderModification[];
  /**
   * @example
   * (http.host eq "video.example.com")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @example
   * 1
   */
  sequence?: number;
  /**
   * @example
   * 1
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      configType: 'ConfigType',
      requestHeaderModification: 'RequestHeaderModification',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      configType: 'string',
      requestHeaderModification: { 'type': 'array', 'itemType': ListHttpRequestHeaderModificationRulesResponseBodyConfigsRequestHeaderModification },
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.requestHeaderModification)) {
      $dara.Model.validateArray(this.requestHeaderModification);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHttpResponseHeaderModificationRulesResponseBodyConfigsResponseHeaderModification extends $dara.Model {
  /**
   * @example
   * headerName
   */
  name?: string;
  /**
   * @example
   * add
   */
  operation?: string;
  /**
   * @example
   * headerValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      operation: 'Operation',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      operation: 'string',
      value: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHttpResponseHeaderModificationRulesResponseBodyConfigs extends $dara.Model {
  /**
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @example
   * rule
   */
  configType?: string;
  responseHeaderModification?: ListHttpResponseHeaderModificationRulesResponseBodyConfigsResponseHeaderModification[];
  /**
   * @example
   * (http.host eq "video.example.com")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @example
   * 1
   */
  sequence?: number;
  /**
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      configType: 'ConfigType',
      responseHeaderModification: 'ResponseHeaderModification',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      configType: 'string',
      responseHeaderModification: { 'type': 'array', 'itemType': ListHttpResponseHeaderModificationRulesResponseBodyConfigsResponseHeaderModification },
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.responseHeaderModification)) {
      $dara.Model.validateArray(this.responseHeaderModification);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHttpsApplicationConfigurationsResponseBodyConfigs extends $dara.Model {
  /**
   * @example
   * on
   */
  altSvc?: string;
  /**
   * @example
   * on
   */
  altSvcClear?: string;
  /**
   * @example
   * 86400
   */
  altSvcMa?: string;
  /**
   * @example
   * on
   */
  altSvcPersist?: string;
  /**
   * @example
   * 395386449776640
   */
  configId?: number;
  /**
   * @example
   * global
   */
  configType?: string;
  /**
   * @example
   * on
   */
  hsts?: string;
  /**
   * @example
   * on
   */
  hstsIncludeSubdomains?: string;
  /**
   * @example
   * 3600
   */
  hstsMaxAge?: string;
  /**
   * @example
   * on
   */
  hstsPreload?: string;
  /**
   * @example
   * on
   */
  httpsForce?: string;
  /**
   * @example
   * 301
   */
  httpsForceCode?: string;
  /**
   * @example
   * (http.host eq \\"video.example.com\\")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @example
   * 1
   */
  sequence?: number;
  /**
   * @example
   * 1
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      altSvc: 'AltSvc',
      altSvcClear: 'AltSvcClear',
      altSvcMa: 'AltSvcMa',
      altSvcPersist: 'AltSvcPersist',
      configId: 'ConfigId',
      configType: 'ConfigType',
      hsts: 'Hsts',
      hstsIncludeSubdomains: 'HstsIncludeSubdomains',
      hstsMaxAge: 'HstsMaxAge',
      hstsPreload: 'HstsPreload',
      httpsForce: 'HttpsForce',
      httpsForceCode: 'HttpsForceCode',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      altSvc: 'string',
      altSvcClear: 'string',
      altSvcMa: 'string',
      altSvcPersist: 'string',
      configId: 'number',
      configType: 'string',
      hsts: 'string',
      hstsIncludeSubdomains: 'string',
      hstsMaxAge: 'string',
      hstsPreload: 'string',
      httpsForce: 'string',
      httpsForceCode: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHttpsBasicConfigurationsResponseBodyConfigs extends $dara.Model {
  /**
   * @example
   * TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
   */
  ciphersuite?: string;
  /**
   * @example
   * strict
   */
  ciphersuiteGroup?: string;
  /**
   * @example
   * 395386449776640
   */
  configId?: number;
  /**
   * @example
   * global
   */
  configType?: string;
  /**
   * @example
   * on
   */
  http2?: string;
  /**
   * @example
   * on
   */
  http3?: string;
  /**
   * @example
   * on
   */
  https?: string;
  /**
   * @example
   * on
   */
  ocspStapling?: string;
  /**
   * @example
   * (http.host eq \\"video.example.com\\")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @example
   * 1
   */
  sequence?: number;
  /**
   * @example
   * on
   */
  tls10?: string;
  /**
   * @example
   * on
   */
  tls11?: string;
  /**
   * @example
   * on
   */
  tls12?: string;
  /**
   * @example
   * on
   */
  tls13?: string;
  static names(): { [key: string]: string } {
    return {
      ciphersuite: 'Ciphersuite',
      ciphersuiteGroup: 'CiphersuiteGroup',
      configId: 'ConfigId',
      configType: 'ConfigType',
      http2: 'Http2',
      http3: 'Http3',
      https: 'Https',
      ocspStapling: 'OcspStapling',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      tls10: 'Tls10',
      tls11: 'Tls11',
      tls12: 'Tls12',
      tls13: 'Tls13',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ciphersuite: 'string',
      ciphersuiteGroup: 'string',
      configId: 'number',
      configType: 'string',
      http2: 'string',
      http3: 'string',
      https: 'string',
      ocspStapling: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'number',
      tls10: 'string',
      tls11: 'string',
      tls12: 'string',
      tls13: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListImageTransformsResponseBodyConfigs extends $dara.Model {
  /**
   * @example
   * 395386449776640
   */
  configId?: number;
  /**
   * @example
   * global
   */
  configType?: string;
  /**
   * @example
   * on
   */
  enable?: string;
  /**
   * @example
   * (http.request.uri.path.file_name eq \\"jpg\\")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * test
   */
  ruleName?: string;
  /**
   * @example
   * 1
   */
  sequence?: number;
  /**
   * @example
   * 1
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      configType: 'ConfigType',
      enable: 'Enable',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      configType: 'string',
      enable: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceQuotasResponseBodyQuotas extends $dara.Model {
  /**
   * @remarks
   * The quota name.
   * 
   * @example
   * customHttpCert
   */
  quotaName?: string;
  /**
   * @remarks
   * The quota value.
   * 
   * @example
   * 10
   */
  quotaValue?: string;
  /**
   * @remarks
   * The threshold type of the quota. Valid values:
   * 
   * *   value: enumerates the values of the quota.
   * *   bool: specifies whether the quota is available.
   * *   num: the upper limit of the quota.
   * *   range: the value range for the quota.
   * *   custom: other types than the preceding four quota threshold types.
   * 
   * @example
   * bool
   */
  quotaValueType?: string;
  static names(): { [key: string]: string } {
    return {
      quotaName: 'QuotaName',
      quotaValue: 'QuotaValue',
      quotaValueType: 'QuotaValueType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      quotaName: 'string',
      quotaValue: 'string',
      quotaValueType: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceQuotasWithUsageResponseBodyQuotasSiteUsage extends $dara.Model {
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 34818329392****
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * test.top
   */
  siteName?: string;
  /**
   * @remarks
   * The quota usage of the website.
   * 
   * @example
   * 1
   */
  siteUsage?: string;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      siteName: 'SiteName',
      siteUsage: 'SiteUsage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      siteName: 'string',
      siteUsage: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceQuotasWithUsageResponseBodyQuotas extends $dara.Model {
  /**
   * @remarks
   * The quota name.
   * 
   * @example
   * redirect_rules|rule_quota
   */
  quotaName?: string;
  /**
   * @remarks
   * The quota value.
   * 
   * @example
   * 10
   */
  quotaValue?: string;
  /**
   * @remarks
   * The usage of the quota in each website associated with the plan.
   */
  siteUsage?: ListInstanceQuotasWithUsageResponseBodyQuotasSiteUsage[];
  /**
   * @remarks
   * The quota usage.
   * 
   * @example
   * 3
   */
  usage?: string;
  static names(): { [key: string]: string } {
    return {
      quotaName: 'QuotaName',
      quotaValue: 'QuotaValue',
      siteUsage: 'SiteUsage',
      usage: 'Usage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      quotaName: 'string',
      quotaValue: 'string',
      siteUsage: { 'type': 'array', 'itemType': ListInstanceQuotasWithUsageResponseBodyQuotasSiteUsage },
      usage: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.siteUsage)) {
      $dara.Model.validateArray(this.siteUsage);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListKvsResponseBodyKeys extends $dara.Model {
  /**
   * @remarks
   * The key name.
   * 
   * @example
   * Key1
   */
  name?: string;
  /**
   * @remarks
   * The time when the key was last updated.
   * 
   * @example
   * 2021-12-13T07:46:03Z
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      updateTime: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListListsRequestQueryArgs extends $dara.Model {
  /**
   * @remarks
   * Specifies whether to sort the returned data in descending order.
   * 
   * @example
   * true
   */
  desc?: boolean;
  /**
   * @remarks
   * The list description for fuzzy search.
   * 
   * @example
   * a custom list
   */
  descriptionLike?: string;
  /**
   * @remarks
   * The list ID for fuzzy search.
   * 
   * @example
   * 40000001
   */
  idLike?: string;
  /**
   * @remarks
   * The list content for fuzzy search.
   * 
   * @example
   * 10.1.1.1
   */
  itemLike?: string;
  /**
   * @example
   * ip
   */
  kind?: string;
  /**
   * @remarks
   * The list name and content for fuzzy search.
   * 
   * @example
   * 10.1.1.1
   */
  nameItemLike?: string;
  /**
   * @remarks
   * The list name for fuzzy search.
   * 
   * @example
   * example
   */
  nameLike?: string;
  /**
   * @remarks
   * The column by which you want to sort the returned data.
   * 
   * @example
   * id
   */
  orderBy?: string;
  static names(): { [key: string]: string } {
    return {
      desc: 'Desc',
      descriptionLike: 'DescriptionLike',
      idLike: 'IdLike',
      itemLike: 'ItemLike',
      kind: 'Kind',
      nameItemLike: 'NameItemLike',
      nameLike: 'NameLike',
      orderBy: 'OrderBy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desc: 'boolean',
      descriptionLike: 'string',
      idLike: 'string',
      itemLike: 'string',
      kind: 'string',
      nameItemLike: 'string',
      nameLike: 'string',
      orderBy: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListListsResponseBodyLists extends $dara.Model {
  /**
   * @remarks
   * The list description.
   * 
   * @example
   * a custom list
   */
  description?: string;
  /**
   * @remarks
   * The ID of the custom list.[](~~2850217~~)
   * 
   * @example
   * 40000001
   */
  id?: number;
  /**
   * @remarks
   * The list type.
   * 
   * @example
   * ip
   */
  kind?: string;
  /**
   * @remarks
   * The length of the list information array, which indicates how many items the list contains.
   * 
   * @example
   * 100
   */
  length?: number;
  /**
   * @remarks
   * The list name.
   * 
   * @example
   * example
   */
  name?: string;
  /**
   * @remarks
   * The time when the list was last modified.
   * 
   * @example
   * 2024-01-01T00:00:00Z
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      id: 'Id',
      kind: 'Kind',
      length: 'Length',
      name: 'Name',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      id: 'number',
      kind: 'string',
      length: 'number',
      name: 'string',
      updateTime: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLoadBalancerOriginStatusResponseBodyOriginStatus extends $dara.Model {
  loadBalancerId?: number;
  originId?: number;
  poolId?: number;
  poolType?: string;
  reason?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      loadBalancerId: 'LoadBalancerId',
      originId: 'OriginId',
      poolId: 'PoolId',
      poolType: 'PoolType',
      reason: 'Reason',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      loadBalancerId: 'number',
      originId: 'number',
      poolId: 'number',
      poolType: 'string',
      reason: 'string',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLoadBalancerRegionsResponseBodyRegionsSubRegions extends $dara.Model {
  /**
   * @remarks
   * The Chinese name of the region.
   */
  subRegionCnName?: string;
  /**
   * @remarks
   * The code of the subregion.
   * 
   * @example
   * ID
   */
  subRegionCode?: string;
  /**
   * @remarks
   * The English name of the subregion.
   * 
   * @example
   * Indonesia
   */
  subRegionEnName?: string;
  static names(): { [key: string]: string } {
    return {
      subRegionCnName: 'SubRegionCnName',
      subRegionCode: 'SubRegionCode',
      subRegionEnName: 'SubRegionEnName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      subRegionCnName: 'string',
      subRegionCode: 'string',
      subRegionEnName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLoadBalancerRegionsResponseBodyRegions extends $dara.Model {
  /**
   * @remarks
   * The Chinese name of the region.
   */
  regionCnName?: string;
  /**
   * @remarks
   * The code of the region.
   * 
   * @example
   * SEAS
   */
  regionCode?: string;
  /**
   * @remarks
   * The English name of the region.
   * 
   * @example
   * South East Asia
   */
  regionEnName?: string;
  /**
   * @remarks
   * The subregions of the region.
   */
  subRegions?: ListLoadBalancerRegionsResponseBodyRegionsSubRegions[];
  static names(): { [key: string]: string } {
    return {
      regionCnName: 'RegionCnName',
      regionCode: 'RegionCode',
      regionEnName: 'RegionEnName',
      subRegions: 'SubRegions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionCnName: 'string',
      regionCode: 'string',
      regionEnName: 'string',
      subRegions: { 'type': 'array', 'itemType': ListLoadBalancerRegionsResponseBodyRegionsSubRegions },
    };
  }

  validate() {
    if(Array.isArray(this.subRegions)) {
      $dara.Model.validateArray(this.subRegions);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLoadBalancersResponseBodyLoadBalancersAdaptiveRouting extends $dara.Model {
  /**
   * @example
   * true
   */
  failoverAcrossPools?: boolean;
  static names(): { [key: string]: string } {
    return {
      failoverAcrossPools: 'FailoverAcrossPools',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failoverAcrossPools: 'boolean',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLoadBalancersResponseBodyLoadBalancersMonitor extends $dara.Model {
  /**
   * @example
   * 5
   */
  consecutiveDown?: number;
  /**
   * @example
   * 3
   */
  consecutiveUp?: number;
  /**
   * @example
   * 200,202
   */
  expectedCodes?: string;
  /**
   * @example
   * true
   */
  followRedirects?: boolean;
  /**
   * @example
   * {
   *         "host": [
   *             "example1.com",
   *             "example2.com"
   *         ]
   *     }
   */
  header?: any;
  /**
   * @example
   * 60
   */
  interval?: number;
  /**
   * @example
   * GET
   */
  method?: string;
  /**
   * @example
   * /
   */
  path?: string;
  /**
   * @example
   * 80
   */
  port?: number;
  /**
   * @example
   * 5
   */
  timeout?: number;
  /**
   * @example
   * HTTP
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      consecutiveDown: 'ConsecutiveDown',
      consecutiveUp: 'ConsecutiveUp',
      expectedCodes: 'ExpectedCodes',
      followRedirects: 'FollowRedirects',
      header: 'Header',
      interval: 'Interval',
      method: 'Method',
      path: 'Path',
      port: 'Port',
      timeout: 'Timeout',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consecutiveDown: 'number',
      consecutiveUp: 'number',
      expectedCodes: 'string',
      followRedirects: 'boolean',
      header: 'any',
      interval: 'number',
      method: 'string',
      path: 'string',
      port: 'number',
      timeout: 'number',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLoadBalancersResponseBodyLoadBalancersRandomSteering extends $dara.Model {
  /**
   * @example
   * 50
   */
  defaultWeight?: number;
  poolWeights?: { [key: string]: number };
  static names(): { [key: string]: string } {
    return {
      defaultWeight: 'DefaultWeight',
      poolWeights: 'PoolWeights',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultWeight: 'number',
      poolWeights: { 'type': 'map', 'keyType': 'string', 'valueType': 'number' },
    };
  }

  validate() {
    if(this.poolWeights) {
      $dara.Model.validateMap(this.poolWeights);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLoadBalancersResponseBodyLoadBalancersRulesFixedResponse extends $dara.Model {
  /**
   * @example
   * application/json
   */
  contentType?: string;
  /**
   * @example
   * http://www.example.com/index.html
   */
  location?: string;
  /**
   * @example
   * Hello World.
   */
  messageBody?: string;
  /**
   * @example
   * 200
   */
  statusCode?: number;
  static names(): { [key: string]: string } {
    return {
      contentType: 'ContentType',
      location: 'Location',
      messageBody: 'MessageBody',
      statusCode: 'StatusCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentType: 'string',
      location: 'string',
      messageBody: 'string',
      statusCode: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLoadBalancersResponseBodyLoadBalancersRules extends $dara.Model {
  fixedResponse?: ListLoadBalancersResponseBodyLoadBalancersRulesFixedResponse;
  /**
   * @example
   * {
   *             "adaptive_routing": {
   *                 "failover_across_pools": true
   *             },
   *             "sub_region_pools": {
   *                 "GB": [
   *                     96228666776****
   *                 ],
   *                 "US": [
   *                     96228666776****
   *                 ]
   *             },
   *             "default_pools": [
   *                 96228666776****,
   *                 96228666776****
   *             ],
   *             "fallback_pool": 96228666776****,
   *             "location_strategy": {
   *                 "mode": "resolver_ip",
   *                 "prefer_ecs": "always"
   *             },
   *             "random_steering": {
   *                 "default_weight": 30,
   *                 "pool_weights": {
   *                     "96228666776****": 70,
   *                     "96228666776****": 80
   *                 }
   *             },
   *             "region_pools": {
   *                 "ENAM": [
   *                     96228666776****,
   *                     92843536908****
   *                 ],
   *                 "WNAM": [
   *                     92843536908****
   *                 ]
   *             },
   *             "session_affinity": "cookie",
   *             "session_affinity_attributes": {
   *                 "drain_duration": 100,
   *                 "headers": ["none"],
   *                 "require_all_headers": false,
   *                 "samesite": "Auto",
   *                 "secure": "Auto",
   *                 "zero_downtime_failover": "sticky"
   *             },
   *             "session_affinity_ttl": 1800,
   *             "steering_policy": "dynamic_latency",
   *             "ttl": 30
   *         }
   */
  overrides?: any;
  /**
   * @example
   * http.request.uri.path contains "/testing"
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * r2
   */
  ruleName?: string;
  /**
   * @example
   * 1
   */
  sequence?: number;
  /**
   * @example
   * true
   */
  terminates?: boolean;
  static names(): { [key: string]: string } {
    return {
      fixedResponse: 'FixedResponse',
      overrides: 'Overrides',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      terminates: 'Terminates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fixedResponse: ListLoadBalancersResponseBodyLoadBalancersRulesFixedResponse,
      overrides: 'any',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'number',
      terminates: 'boolean',
    };
  }

  validate() {
    if(this.fixedResponse && typeof (this.fixedResponse as any).validate === 'function') {
      (this.fixedResponse as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLoadBalancersResponseBodyLoadBalancers extends $dara.Model {
  adaptiveRouting?: ListLoadBalancersResponseBodyLoadBalancersAdaptiveRouting;
  defaultPools?: number[];
  /**
   * @example
   * test
   */
  description?: string;
  /**
   * @example
   * false
   */
  enabled?: boolean;
  /**
   * @example
   * 96228666776****
   */
  fallbackPool?: number;
  /**
   * @example
   * 998676487607104
   */
  id?: number;
  monitor?: ListLoadBalancersResponseBodyLoadBalancersMonitor;
  /**
   * @example
   * lb.example.com
   */
  name?: string;
  randomSteering?: ListLoadBalancersResponseBodyLoadBalancersRandomSteering;
  /**
   * @example
   * {
   *   "ENAM": [
   *     12345678****
   *   ],
   *   "WNAM": [
   *     23456789****,
   *     23456789****
   *   ]
   * }
   */
  regionPools?: any;
  rules?: ListLoadBalancersResponseBodyLoadBalancersRules[];
  /**
   * @remarks
   * The session persistence mode. Valid values:
   * 
   * *   off: disables session persistence.
   * *   ip: enables session persistence by IP address.
   * *   cookie: enables session persistence by cookie.
   * 
   * @example
   * ip
   */
  sessionAffinity?: string;
  /**
   * @example
   * 1159101787****
   */
  siteId?: number;
  /**
   * @example
   * healthy
   */
  status?: string;
  /**
   * @example
   * order
   */
  steeringPolicy?: string;
  /**
   * @example
   * {"AL,MO": [92298024898****],"CN-SH,CN-SX,CN-SC":[92304347804****,92843536908****]}
   */
  subRegionPools?: any;
  /**
   * @example
   * 30
   */
  ttl?: number;
  static names(): { [key: string]: string } {
    return {
      adaptiveRouting: 'AdaptiveRouting',
      defaultPools: 'DefaultPools',
      description: 'Description',
      enabled: 'Enabled',
      fallbackPool: 'FallbackPool',
      id: 'Id',
      monitor: 'Monitor',
      name: 'Name',
      randomSteering: 'RandomSteering',
      regionPools: 'RegionPools',
      rules: 'Rules',
      sessionAffinity: 'SessionAffinity',
      siteId: 'SiteId',
      status: 'Status',
      steeringPolicy: 'SteeringPolicy',
      subRegionPools: 'SubRegionPools',
      ttl: 'Ttl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adaptiveRouting: ListLoadBalancersResponseBodyLoadBalancersAdaptiveRouting,
      defaultPools: { 'type': 'array', 'itemType': 'number' },
      description: 'string',
      enabled: 'boolean',
      fallbackPool: 'number',
      id: 'number',
      monitor: ListLoadBalancersResponseBodyLoadBalancersMonitor,
      name: 'string',
      randomSteering: ListLoadBalancersResponseBodyLoadBalancersRandomSteering,
      regionPools: 'any',
      rules: { 'type': 'array', 'itemType': ListLoadBalancersResponseBodyLoadBalancersRules },
      sessionAffinity: 'string',
      siteId: 'number',
      status: 'string',
      steeringPolicy: 'string',
      subRegionPools: 'any',
      ttl: 'number',
    };
  }

  validate() {
    if(this.adaptiveRouting && typeof (this.adaptiveRouting as any).validate === 'function') {
      (this.adaptiveRouting as any).validate();
    }
    if(Array.isArray(this.defaultPools)) {
      $dara.Model.validateArray(this.defaultPools);
    }
    if(this.monitor && typeof (this.monitor as any).validate === 'function') {
      (this.monitor as any).validate();
    }
    if(this.randomSteering && typeof (this.randomSteering as any).validate === 'function') {
      (this.randomSteering as any).validate();
    }
    if(Array.isArray(this.rules)) {
      $dara.Model.validateArray(this.rules);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListManagedRulesGroupsResponseBodyManagedRulesGroups extends $dara.Model {
  /**
   * @remarks
   * The name of the managed rule group.
   * 
   * @example
   * example
   */
  name?: string;
  /**
   * @remarks
   * The number of rules in the managed rule group.
   * 
   * @example
   * 1000
   */
  ruleCount?: number;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      ruleCount: 'RuleCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      ruleCount: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNetworkOptimizationsResponseBodyConfigs extends $dara.Model {
  /**
   * @example
   * 395386449776640
   */
  configId?: number;
  /**
   * @example
   * global
   */
  configType?: string;
  /**
   * @example
   * on
   */
  grpc?: string;
  /**
   * @example
   * on
   */
  http2Origin?: string;
  /**
   * @example
   * (http.host eq \\"video.example.com\\")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @example
   * 1
   */
  sequence?: number;
  /**
   * @example
   * 1
   */
  siteVersion?: number;
  /**
   * @example
   * on
   */
  smartRouting?: string;
  /**
   * @example
   * 500
   */
  uploadMaxFilesize?: string;
  /**
   * @example
   * on
   */
  websocket?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      configType: 'ConfigType',
      grpc: 'Grpc',
      http2Origin: 'Http2Origin',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      siteVersion: 'SiteVersion',
      smartRouting: 'SmartRouting',
      uploadMaxFilesize: 'UploadMaxFilesize',
      websocket: 'Websocket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      configType: 'string',
      grpc: 'string',
      http2Origin: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'number',
      siteVersion: 'number',
      smartRouting: 'string',
      uploadMaxFilesize: 'string',
      websocket: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOriginPoolsResponseBodyOriginPoolsOriginsAuthConf extends $dara.Model {
  accessKey?: string;
  authType?: string;
  region?: string;
  secretKey?: string;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      accessKey: 'AccessKey',
      authType: 'AuthType',
      region: 'Region',
      secretKey: 'SecretKey',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKey: 'string',
      authType: 'string',
      region: 'string',
      secretKey: 'string',
      version: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOriginPoolsResponseBodyOriginPoolsOrigins extends $dara.Model {
  address?: string;
  authConf?: ListOriginPoolsResponseBodyOriginPoolsOriginsAuthConf;
  enabled?: boolean;
  header?: any;
  id?: number;
  name?: string;
  type?: string;
  weight?: number;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      authConf: 'AuthConf',
      enabled: 'Enabled',
      header: 'Header',
      id: 'Id',
      name: 'Name',
      type: 'Type',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      authConf: ListOriginPoolsResponseBodyOriginPoolsOriginsAuthConf,
      enabled: 'boolean',
      header: 'any',
      id: 'number',
      name: 'string',
      type: 'string',
      weight: 'number',
    };
  }

  validate() {
    if(this.authConf && typeof (this.authConf as any).validate === 'function') {
      (this.authConf as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOriginPoolsResponseBodyOriginPoolsReferencesDnsRecords extends $dara.Model {
  id?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOriginPoolsResponseBodyOriginPoolsReferencesIPARecords extends $dara.Model {
  id?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOriginPoolsResponseBodyOriginPoolsReferencesLoadBalancers extends $dara.Model {
  id?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOriginPoolsResponseBodyOriginPoolsReferences extends $dara.Model {
  dnsRecords?: ListOriginPoolsResponseBodyOriginPoolsReferencesDnsRecords[];
  IPARecords?: ListOriginPoolsResponseBodyOriginPoolsReferencesIPARecords[];
  loadBalancers?: ListOriginPoolsResponseBodyOriginPoolsReferencesLoadBalancers[];
  static names(): { [key: string]: string } {
    return {
      dnsRecords: 'DnsRecords',
      IPARecords: 'IPARecords',
      loadBalancers: 'LoadBalancers',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dnsRecords: { 'type': 'array', 'itemType': ListOriginPoolsResponseBodyOriginPoolsReferencesDnsRecords },
      IPARecords: { 'type': 'array', 'itemType': ListOriginPoolsResponseBodyOriginPoolsReferencesIPARecords },
      loadBalancers: { 'type': 'array', 'itemType': ListOriginPoolsResponseBodyOriginPoolsReferencesLoadBalancers },
    };
  }

  validate() {
    if(Array.isArray(this.dnsRecords)) {
      $dara.Model.validateArray(this.dnsRecords);
    }
    if(Array.isArray(this.IPARecords)) {
      $dara.Model.validateArray(this.IPARecords);
    }
    if(Array.isArray(this.loadBalancers)) {
      $dara.Model.validateArray(this.loadBalancers);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOriginPoolsResponseBodyOriginPools extends $dara.Model {
  enabled?: boolean;
  id?: number;
  name?: string;
  origins?: ListOriginPoolsResponseBodyOriginPoolsOrigins[];
  recordName?: string;
  referenceLBCount?: number;
  references?: ListOriginPoolsResponseBodyOriginPoolsReferences;
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      enabled: 'Enabled',
      id: 'Id',
      name: 'Name',
      origins: 'Origins',
      recordName: 'RecordName',
      referenceLBCount: 'ReferenceLBCount',
      references: 'References',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      id: 'number',
      name: 'string',
      origins: { 'type': 'array', 'itemType': ListOriginPoolsResponseBodyOriginPoolsOrigins },
      recordName: 'string',
      referenceLBCount: 'number',
      references: ListOriginPoolsResponseBodyOriginPoolsReferences,
      siteId: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.origins)) {
      $dara.Model.validateArray(this.origins);
    }
    if(this.references && typeof (this.references as any).validate === 'function') {
      (this.references as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOriginRulesResponseBodyConfigs extends $dara.Model {
  /**
   * @example
   * 395386449776640
   */
  configId?: number;
  /**
   * @example
   * global
   */
  configType?: string;
  /**
   * @example
   * test.example.com
   */
  dnsRecord?: string;
  /**
   * @example
   * origin.example.com
   */
  originHost?: string;
  /**
   * @example
   * 8080
   */
  originHttpPort?: string;
  /**
   * @example
   * 4433
   */
  originHttpsPort?: string;
  /**
   * @example
   * http
   */
  originScheme?: string;
  /**
   * @example
   * origin.example.com
   */
  originSni?: string;
  /**
   * @example
   * on
   */
  range?: string;
  /**
   * @example
   * (http.host eq \\"video.example.com\\")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @example
   * 1
   */
  sequence?: number;
  /**
   * @example
   * 1
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      configType: 'ConfigType',
      dnsRecord: 'DnsRecord',
      originHost: 'OriginHost',
      originHttpPort: 'OriginHttpPort',
      originHttpsPort: 'OriginHttpsPort',
      originScheme: 'OriginScheme',
      originSni: 'OriginSni',
      range: 'Range',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      configType: 'string',
      dnsRecord: 'string',
      originHost: 'string',
      originHttpPort: 'string',
      originHttpsPort: 'string',
      originScheme: 'string',
      originSni: 'string',
      range: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPagesRequestQueryArgs extends $dara.Model {
  nameDescriptionLike?: string;
  static names(): { [key: string]: string } {
    return {
      nameDescriptionLike: 'NameDescriptionLike',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nameDescriptionLike: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPagesResponseBodyPages extends $dara.Model {
  /**
   * @remarks
   * The Base64-encoded content of the error page. The content type is specified by the Content-Type field.
   * 
   * This parameter is required.
   * 
   * @example
   * PGh0bWw+aGVsbG8gcGFnZTwvaHRtbD4=
   */
  content?: string;
  /**
   * @remarks
   * The Content-Type field in the HTTP header.
   * 
   * This parameter is required.
   * 
   * @example
   * text/html
   */
  contentType?: string;
  /**
   * @remarks
   * The description of the custom error page.
   * 
   * @example
   * a custom deny page
   */
  description?: string;
  /**
   * @remarks
   * The ID of the custom error page.[](~~2850223~~)
   * 
   * @example
   * 50000001
   */
  id?: number;
  /**
   * @remarks
   * The type of the custom error page.
   * 
   * @example
   * custom
   */
  kind?: string;
  /**
   * @remarks
   * The name of the custom error page.
   * 
   * @example
   * example
   */
  name?: string;
  /**
   * @remarks
   * The time when the custom error page was last modified.
   * 
   * @example
   * 2024-01-01T00:00:00Z
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      contentType: 'ContentType',
      description: 'Description',
      id: 'Id',
      kind: 'Kind',
      name: 'Name',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      contentType: 'string',
      description: 'string',
      id: 'number',
      kind: 'string',
      name: 'string',
      updateTime: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRecordsResponseBodyRecordsAuthConf extends $dara.Model {
  /**
   * @remarks
   * The access key of the account to which the origin server belongs. This value is returned when the SourceType is OSS, and AuthType is private_cross_account, or when the SourceType is S3 and AuthType is private.
   * 
   * @example
   * u0Nkg5gBK***QF5wvKMM504JUHt
   */
  accessKey?: string;
  /**
   * @remarks
   * The authentication type of the origin server. Different origins support different authentication types. The type of origin refers to the SourceType parameter in this operation. If the type of origin is OSS or S3, the authentication type of the origin must be specified. Valid values:
   * 
   * *   **public**: public read. This value is returned when the origin is a public OSS or S3 bucket.
   * *   **private**: private read. This value is returned when the origin is a private S3 bucket.
   * *   **private_same_account**: private read under the same account. This value is returned when the origin is a private OSS bucket in your Alibaba Cloud account.
   * *   **private_cross_account**: private read across accounts. This value is returned when the origin is a private OSS bucket in a different Alibaba Cloud account.
   * 
   * @example
   * private
   */
  authType?: string;
  /**
   * @remarks
   * The region of the origin. This parameter is returned if the origin type is S3. You can get the region information from the official website of Amazon S3.
   * 
   * @example
   * us-east-1
   */
  region?: string;
  /**
   * @remarks
   * The secret access key of the account to which the origin server belongs. This value is returned when the SourceType is OSS, and AuthType is private_same_account, or when the SourceType is S3 and AuthType is private.
   * 
   * @example
   * VIxuvJSA2S03f***kp208dy5w7
   */
  secretKey?: string;
  /**
   * @remarks
   * The version of the signature algorithm. This value is returned when the origin type is S3 and AuthType is private. Valid values:
   * 
   * *   **v2**
   * *   **v4**
   * 
   * If this parameter is left empty, the default value v4 is used.
   * 
   * @example
   * v4
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      accessKey: 'AccessKey',
      authType: 'AuthType',
      region: 'Region',
      secretKey: 'SecretKey',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKey: 'string',
      authType: 'string',
      region: 'string',
      secretKey: 'string',
      version: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRecordsResponseBodyRecordsData extends $dara.Model {
  /**
   * @remarks
   * The encryption algorithm used for the record. Valid values: 0 to 255. Exclusive to CERT and SSHFP records.
   * 
   * @example
   * 0
   */
  algorithm?: number;
  /**
   * @remarks
   * The public key of the certificate. Exclusive to CERT, SMIMEA, and TLSA records.
   * 
   * @example
   * dGVzdGFkYWxrcw==
   */
  certificate?: string;
  /**
   * @remarks
   * The public key fingerprint of the record. Exclusive to SSHFP records.
   * 
   * @example
   * abcdef1234567890
   */
  fingerprint?: string;
  /**
   * @remarks
   * The flag bit of the record. The Flag for a CAA record indicates its priority and how it is processed. Valid values: 0 to 255. Exclusive to CAA records.
   * 
   * @example
   * 128
   */
  flag?: number;
  /**
   * @remarks
   * The public key identification for the record. Valid values: 0 to 65535. Exclusive to CERT records.
   * 
   * @example
   * 0
   */
  keyTag?: number;
  /**
   * @remarks
   * The algorithm policy used to match or validate the certificate. Valid values: 0 to 255. Exclusive to SMIMEA and TLSA records.
   * 
   * @example
   * 0
   */
  matchingType?: number;
  /**
   * @remarks
   * The port of the record. Valid values: 0 to 65535. Exclusive to SRV records.
   * 
   * @example
   * 80
   */
  port?: number;
  /**
   * @remarks
   * The priority of the record. Valid values: 0 to 65535. A smaller value indicates a higher priority. Exclusive to MX, SRV, and URI records.
   * 
   * @example
   * 0
   */
  priority?: number;
  /**
   * @remarks
   * The type of certificate or public key. Valid values: 0 to 255. Exclusive to SMIMEA, and TLSA records.
   * 
   * @example
   * 0
   */
  selector?: number;
  /**
   * @remarks
   * The tag of the record. The Tag of a CAA record indicate its specific type and usage. Exclusive to CAA records.
   * 
   * @example
   * issue
   */
  tag?: string;
  /**
   * @remarks
   * The certificate type of the record (in CERT records), or the public key type (in SSHFP records).
   * 
   * @example
   * 0
   */
  type?: number;
  /**
   * @remarks
   * The usage identifier of the record. Valid values: 0 to 255. Exclusive to SMIMEA, and TLSA records.
   * 
   * @example
   * 0
   */
  usage?: number;
  /**
   * @remarks
   * Record value or part of the record content. This value is returned when the record is A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, or URI. It has different meanings based on types of records:
   * 
   * *   **A/AAAA**: the IP addresses. IP addresses are separated by commas (,). There is at least one IPv4 address.
   * *   **CNAME**: the pointed/mapped domain name.
   * *   **NS**: the nameservers for the domain name.
   * *   **MX**: a valid domain name of the mail server.
   * *   **TXT**: a valid text string.
   * *   **CAA**: a valid domain name of the certificate authority.
   * *   **SRV**: a valid domain name of the target host.
   * *   **URI**: a valid URI string.
   * 
   * @example
   * CNAME
   */
  value?: string;
  /**
   * @remarks
   * The weight of the record. Valid values: 0 to 65535. Exclusive to SRV and URI records.
   * 
   * @example
   * 0
   */
  weight?: number;
  static names(): { [key: string]: string } {
    return {
      algorithm: 'Algorithm',
      certificate: 'Certificate',
      fingerprint: 'Fingerprint',
      flag: 'Flag',
      keyTag: 'KeyTag',
      matchingType: 'MatchingType',
      port: 'Port',
      priority: 'Priority',
      selector: 'Selector',
      tag: 'Tag',
      type: 'Type',
      usage: 'Usage',
      value: 'Value',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      algorithm: 'number',
      certificate: 'string',
      fingerprint: 'string',
      flag: 'number',
      keyTag: 'number',
      matchingType: 'number',
      port: 'number',
      priority: 'number',
      selector: 'number',
      tag: 'string',
      type: 'number',
      usage: 'number',
      value: 'string',
      weight: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRecordsResponseBodyRecords extends $dara.Model {
  /**
   * @remarks
   * The origin authentication information of the CNAME record.
   */
  authConf?: ListRecordsResponseBodyRecordsAuthConf;
  /**
   * @remarks
   * The business scenario of the record for acceleration. Valid values:
   * 
   * *   **image_video**: video and image.
   * *   **api**: API.
   * *   **web**: web page.
   * 
   * @example
   * web
   */
  bizName?: string;
  /**
   * @remarks
   * The comments of the record.
   * 
   * @example
   * this is a remark.
   */
  comment?: string;
  /**
   * @remarks
   * The time when the record was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-12-24T02:01:11Z
   */
  createTime?: string;
  /**
   * @remarks
   * The DNS record information. Different types of records contain different information.
   * 
   * @example
   * {"value":"1.1.1.1"}
   */
  data?: ListRecordsResponseBodyRecordsData;
  /**
   * @remarks
   * The origin host policy. This policy takes effect when the record type is CNAME. Valid values:
   * 
   * *   follow_hostname: matches the requested domain name.
   * *   follow_origin_domain: matches the origin\\"s domain name.
   * 
   * @example
   * follow_origin_domain
   */
  hostPolicy?: string;
  /**
   * @remarks
   * Indicates whether the record is proxied. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  proxied?: boolean;
  /**
   * @remarks
   * The CNAME. If you use CNAME setup when you add your website to ESA, the value is the CNAME that you configured then.
   * 
   * @example
   * a.example.com.cnamezone.com
   */
  recordCname?: string;
  /**
   * @remarks
   * The record ID.
   * 
   * @example
   * 1234567890123
   */
  recordId?: number;
  /**
   * @remarks
   * The record name.
   * 
   * @example
   * a.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The origin type for the CNAME record. This parameter is returned when you add a CNAME record. Valid values:
   * 
   * *   **OSS**: OSS bucket.
   * *   **S3**: S3 bucket.
   * *   **LB**: load balancer.
   * *   **OP**: origin pool.
   * *   **Domain**: domain name.
   * 
   * If you do not pass this parameter or if you leave its value empty, Domain is returned by default.
   * 
   * @example
   * OSS
   */
  recordSourceType?: string;
  /**
   * @remarks
   * The DNS type of the record, such as **A/AAAA, CNAME, and TXT**.
   * 
   * @example
   * A/AAAA
   */
  recordType?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  /**
   * @remarks
   * The TTL of the record. Unit: seconds. If the value is 1, the TTL of the record is determined by the system.
   * 
   * @example
   * 30
   */
  ttl?: number;
  /**
   * @remarks
   * The time when the record was updated. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-06-07T10:02:59Z
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      authConf: 'AuthConf',
      bizName: 'BizName',
      comment: 'Comment',
      createTime: 'CreateTime',
      data: 'Data',
      hostPolicy: 'HostPolicy',
      proxied: 'Proxied',
      recordCname: 'RecordCname',
      recordId: 'RecordId',
      recordName: 'RecordName',
      recordSourceType: 'RecordSourceType',
      recordType: 'RecordType',
      siteId: 'SiteId',
      siteName: 'SiteName',
      ttl: 'Ttl',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authConf: ListRecordsResponseBodyRecordsAuthConf,
      bizName: 'string',
      comment: 'string',
      createTime: 'string',
      data: ListRecordsResponseBodyRecordsData,
      hostPolicy: 'string',
      proxied: 'boolean',
      recordCname: 'string',
      recordId: 'number',
      recordName: 'string',
      recordSourceType: 'string',
      recordType: 'string',
      siteId: 'number',
      siteName: 'string',
      ttl: 'number',
      updateTime: 'string',
    };
  }

  validate() {
    if(this.authConf && typeof (this.authConf as any).validate === 'function') {
      (this.authConf as any).validate();
    }
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRedirectRulesResponseBodyConfigs extends $dara.Model {
  /**
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @example
   * rule
   */
  configType?: string;
  /**
   * @example
   * on
   */
  reserveQueryString?: string;
  /**
   * @example
   * (http.host eq "video.example.com")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @example
   * 1
   */
  sequence?: number;
  /**
   * @example
   * 1
   */
  siteVersion?: number;
  /**
   * @example
   * 301
   */
  statusCode?: string;
  /**
   * @example
   * http://www.exapmle.com/index.html
   */
  targetUrl?: string;
  /**
   * @example
   * static
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      configType: 'ConfigType',
      reserveQueryString: 'ReserveQueryString',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      siteVersion: 'SiteVersion',
      statusCode: 'StatusCode',
      targetUrl: 'TargetUrl',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      configType: 'string',
      reserveQueryString: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'number',
      siteVersion: 'number',
      statusCode: 'string',
      targetUrl: 'string',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRewriteUrlRulesResponseBodyConfigs extends $dara.Model {
  /**
   * @example
   * 39538644977****
   */
  configId?: number;
  /**
   * @example
   * global
   */
  configType?: string;
  /**
   * @example
   * example=123
   */
  queryString?: string;
  /**
   * @example
   * static
   */
  rewriteQueryStringType?: string;
  /**
   * @example
   * static
   */
  rewriteUriType?: string;
  /**
   * @example
   * (http.host eq "video.example.com")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @example
   * 1
   */
  sequence?: number;
  /**
   * @example
   * 0
   */
  siteVersion?: number;
  /**
   * @example
   * /image.example.com/index.html
   */
  uri?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      configType: 'ConfigType',
      queryString: 'QueryString',
      rewriteQueryStringType: 'RewriteQueryStringType',
      rewriteUriType: 'RewriteUriType',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      siteVersion: 'SiteVersion',
      uri: 'Uri',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      configType: 'string',
      queryString: 'string',
      rewriteQueryStringType: 'string',
      rewriteUriType: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'number',
      siteVersion: 'number',
      uri: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRoutineOptionalSpecsResponseBodySpecs extends $dara.Model {
  /**
   * @remarks
   * Indicates whether the specification is available. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  isAvailable?: boolean;
  /**
   * @remarks
   * The specification name.
   * 
   * @example
   * 5ms
   */
  specName?: string;
  static names(): { [key: string]: string } {
    return {
      isAvailable: 'IsAvailable',
      specName: 'SpecName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isAvailable: 'boolean',
      specName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScheduledPreloadExecutionsResponseBodyExecutions extends $dara.Model {
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 15685865xxx14622
   */
  aliUid?: string;
  /**
   * @remarks
   * The end time of the prefetch plan.
   * 
   * @example
   * 2024-05-31T18:10:48.849+08:00
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the prefetch plan.
   * 
   * @example
   * 66599bd7397885b43804901c
   */
  id?: string;
  /**
   * @remarks
   * The time interval between each batch execution in the plan. Unit: seconds.
   * 
   * @example
   * 60
   */
  interval?: number;
  /**
   * @remarks
   * The ID of the prefetch task.
   * 
   * @example
   * 665d3af3621bccf3fe29e1a4
   */
  jobId?: string;
  /**
   * @remarks
   * The number of URLs prefetched in each batch.
   * 
   * @example
   * 10
   */
  sliceLen?: number;
  /**
   * @remarks
   * The start time of the prefetch plan.
   * 
   * @example
   * 2024-05-31T17:10:48.849+08:00
   */
  startTime?: string;
  /**
   * @remarks
   * The status of the prefetch plan. Valid values:
   * 
   * *   **waiting**
   * *   **running**
   * *   **finished**
   * *   **failed**
   * *   **stopped**
   * 
   * @example
   * running
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      aliUid: 'AliUid',
      endTime: 'EndTime',
      id: 'Id',
      interval: 'Interval',
      jobId: 'JobId',
      sliceLen: 'SliceLen',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliUid: 'string',
      endTime: 'string',
      id: 'string',
      interval: 'number',
      jobId: 'string',
      sliceLen: 'number',
      startTime: 'string',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScheduledPreloadJobsResponseBodyJobs extends $dara.Model {
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 15685865xxx14622
   */
  aliUid?: string;
  /**
   * @remarks
   * The time when the task was created.
   * 
   * @example
   * 2024-06-01T08:53:13Z
   */
  createdAt?: string;
  /**
   * @remarks
   * The domain names to be prefetched.
   * 
   * @example
   * testurl.com
   */
  domains?: string;
  /**
   * @remarks
   * The error message that is returned.
   * 
   * @example
   * invalid domain:test.com
   */
  errorInfo?: string;
  /**
   * @remarks
   * The URL of the OSS object that stores a list of URLs that failed the conditional check for prefetching.
   * 
   * @example
   * https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7
   */
  failedFileOss?: string;
  /**
   * @remarks
   * The ID of the URL list file, which can be used during downloads.
   * 
   * @example
   * 665d3b48621bccf3fe29e1a7
   */
  fileId?: string;
  /**
   * @remarks
   * The ID of the prefetch task.
   * 
   * @example
   * 665d3af3621bccf3fe29e1a4
   */
  id?: string;
  /**
   * @remarks
   * The method to submit the URLs to be prefetched.
   * 
   * @example
   * oss
   */
  insertWay?: string;
  /**
   * @remarks
   * The task name.
   * 
   * @example
   * example
   */
  name?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 190007158391808
   */
  siteId?: number;
  /**
   * @remarks
   * The number of submitted prefetch tasks.
   * 
   * @example
   * 1
   */
  taskSubmitted?: number;
  /**
   * @remarks
   * The task type. Valid values: refresh and preload.
   * 
   * @example
   * preload
   */
  taskType?: string;
  /**
   * @remarks
   * The total number of URLs.
   * 
   * @example
   * 2
   */
  urlCount?: number;
  /**
   * @remarks
   * The number of submitted URLs.
   * 
   * @example
   * 1
   */
  urlSubmitted?: number;
  static names(): { [key: string]: string } {
    return {
      aliUid: 'AliUid',
      createdAt: 'CreatedAt',
      domains: 'Domains',
      errorInfo: 'ErrorInfo',
      failedFileOss: 'FailedFileOss',
      fileId: 'FileId',
      id: 'Id',
      insertWay: 'InsertWay',
      name: 'Name',
      siteId: 'SiteId',
      taskSubmitted: 'TaskSubmitted',
      taskType: 'TaskType',
      urlCount: 'UrlCount',
      urlSubmitted: 'UrlSubmitted',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliUid: 'string',
      createdAt: 'string',
      domains: 'string',
      errorInfo: 'string',
      failedFileOss: 'string',
      fileId: 'string',
      id: 'string',
      insertWay: 'string',
      name: 'string',
      siteId: 'number',
      taskSubmitted: 'number',
      taskType: 'string',
      urlCount: 'number',
      urlSubmitted: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteDeliveryTasksResponseBodyTasks extends $dara.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * *   dcdn_log_access_l1 (default): access logs.
   * *   dcdn_log_er: Edge Routine logs.
   * *   dcdn_log_waf: firewall logs.
   * *   dcdn_log_ipa: TCP/UDP proxy logs.
   * 
   * @example
   * dcdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The data center. Valid values:
   * 
   * *   cn: the Chinese mainland.
   * *   sg: outside the Chinese mainland.
   * 
   * @example
   * cn
   */
  dataCenter?: string;
  /**
   * @remarks
   * The destination of the delivery. Valid values:
   * 
   * 1.  sls: Alibaba Cloud Simple Log Service (SLS).
   * 2.  http: HTTP server.
   * 3.  aws3: Amazon Simple Storage Service (S3).
   * 4.  oss: Alibaba Cloud Object Storage Service (OSS).
   * 5.  kafka: Kafka.
   * 6.  aws3cmpt: S3-compatible storage service.
   * 
   * @example
   * sls
   */
  deliveryType?: string;
  /**
   * @remarks
   * The status of the delivery task.
   * 
   * *   **online**
   * *   **offline**
   * 
   * @example
   * online
   */
  status?: string;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * @example
   * cdn-test-task
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      dataCenter: 'DataCenter',
      deliveryType: 'DeliveryType',
      status: 'Status',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      dataCenter: 'string',
      deliveryType: 'string',
      status: 'string',
      taskName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSitesRequestTagFilter extends $dara.Model {
  /**
   * @remarks
   * The tag key. This parameter specifies a filter condition for the query.
   * 
   * @example
   * tag1
   */
  key?: string;
  /**
   * @remarks
   * The tag value. This parameter specifies a filter condition for the query.
   * 
   * @example
   * aaa
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSitesResponseBodySites extends $dara.Model {
  /**
   * @remarks
   * The DNS setup for the website. Valid values:
   * 
   * *   **NS**
   * *   **CNAME**
   * 
   * @example
   * NS
   */
  accessType?: string;
  /**
   * @remarks
   * The CNAME of the website domain. If you use CNAME setup when you add your website to ESA, the value is the CNAME that you configured then.
   * 
   * @example
   * example.cname.com
   */
  cnameZone?: string;
  /**
   * @remarks
   * The service location for the website. Valid values:
   * 
   * *   **domestic**: the Chinese mainland
   * *   **global**: global
   * *   **overseas**: outside the Chinese mainland
   * 
   * @example
   * domestic
   */
  coverage?: string;
  /**
   * @remarks
   * The time when the website was added. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-12-24T02:01:11Z
   */
  createTime?: string;
  /**
   * @remarks
   * The ID of the plan associated with the website.
   * 
   * @example
   * onBvtlmIyeXLbiDw81F9
   */
  instanceId?: string;
  /**
   * @remarks
   * The nameservers assigned to the website domain, which are separated by commas (,).
   * 
   * @example
   * male1-1.ialicdn.com,female1-1.ialicdn.com
   */
  nameServerList?: string;
  /**
   * @remarks
   * The plan name.
   * 
   * @example
   * plan-168656498****
   */
  planName?: string;
  /**
   * @remarks
   * The plan associated with the website.
   * 
   * @example
   * normal
   */
  planSpecName?: string;
  /**
   * @remarks
   * The ID of the resource group.
   * 
   * @example
   * rg-aek26g6i6se6pna
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 123456789****
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  /**
   * @remarks
   * The website status. Valid values:
   * 
   * *   **pending**: The website is to be configured.
   * *   **active**: The website is active.
   * *   **offline**: The website is suspended.
   * *   **moved**: The website has been added and verified by another Alibaba Cloud account.
   * 
   * @example
   * pending
   */
  status?: string;
  /**
   * @remarks
   * The tags of the website.
   * 
   * @example
   * {"tag1":"value1"}
   */
  tags?: { [key: string]: any };
  /**
   * @remarks
   * The time when the website was updated. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-12-24T02:01:11Z
   */
  updateTime?: string;
  /**
   * @remarks
   * The code that is used to verify the website domain ownership. As part of the verification TXT record, this parameter is returned for websites that use CNAME setup.
   * 
   * @example
   * verify_d516cb3740f81f0cef77d162edd1****
   */
  verifyCode?: string;
  /**
   * @remarks
   * null
   * 
   * @example
   * 2023-12-24T02:01:11Z
   */
  visitTime?: string;
  static names(): { [key: string]: string } {
    return {
      accessType: 'AccessType',
      cnameZone: 'CnameZone',
      coverage: 'Coverage',
      createTime: 'CreateTime',
      instanceId: 'InstanceId',
      nameServerList: 'NameServerList',
      planName: 'PlanName',
      planSpecName: 'PlanSpecName',
      resourceGroupId: 'ResourceGroupId',
      siteId: 'SiteId',
      siteName: 'SiteName',
      status: 'Status',
      tags: 'Tags',
      updateTime: 'UpdateTime',
      verifyCode: 'VerifyCode',
      visitTime: 'VisitTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessType: 'string',
      cnameZone: 'string',
      coverage: 'string',
      createTime: 'string',
      instanceId: 'string',
      nameServerList: 'string',
      planName: 'string',
      planSpecName: 'string',
      resourceGroupId: 'string',
      siteId: 'number',
      siteName: 'string',
      status: 'string',
      tags: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      updateTime: 'string',
      verifyCode: 'string',
      visitTime: 'string',
    };
  }

  validate() {
    if(this.tags) {
      $dara.Model.validateMap(this.tags);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesRequestTag extends $dara.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * env
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponseBodyTagResources extends $dara.Model {
  /**
   * @remarks
   * The resource ID.
   * 
   * @example
   * example.com
   */
  resourceId?: string;
  /**
   * @remarks
   * The resource type.
   * 
   * @example
   * site
   */
  resourceType?: string;
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * env
   */
  tagKey?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * value
   */
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceId: 'string',
      resourceType: 'string',
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUploadTasksResponseBodyTasks extends $dara.Model {
  /**
   * @remarks
   * The time when the task was created.
   * 
   * @example
   * 2023-07-26T01:56:15Z
   */
  createTime?: string;
  /**
   * @remarks
   * The error message returned when the file upload task failed.
   * 
   * @example
   * invalid url
   */
  description?: string;
  /**
   * @remarks
   * The error code. Multiple error codes are separated by commas (,).
   * 
   * *   **InvalidUrl**: The URL format is incorrect.
   * *   **InvalidDomain**: The domain ownership fails to be verified.
   * *   **QuotaExcess**: The quota limit has been reached.
   * *   **OtherErrors**: Other errors.
   * 
   * @example
   * InvalidUrl,InvalidDomain
   */
  errorCode?: string;
  /**
   * @remarks
   * The task status.
   * 
   * *   **Complete**: The task is complete.
   * *   **Refreshing**: The task is in progress.
   * *   **Failed**: The task failed.
   * 
   * @example
   * Complete
   */
  status?: string;
  /**
   * @remarks
   * The task type. Valid values:
   * 
   * *   **file**: purges the cache by file URL.
   * *   **preload**: prefetches files.
   * *   **directory**: purges the cache by directory.
   * *   **ignoreparams**: purges the cache by URL with specified parameters ignored.
   * 
   * @example
   * file
   */
  type?: string;
  /**
   * @remarks
   * The ID of the file upload task.
   * 
   * @example
   * 159253299357****
   */
  uploadId?: string;
  /**
   * @remarks
   * The name of the file upload task.
   * 
   * @example
   * purge_file_task
   */
  uploadTaskName?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      description: 'Description',
      errorCode: 'ErrorCode',
      status: 'Status',
      type: 'Type',
      uploadId: 'UploadId',
      uploadTaskName: 'UploadTaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      description: 'string',
      errorCode: 'string',
      status: 'string',
      type: 'string',
      uploadId: 'string',
      uploadTaskName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserDeliveryTasksResponseBodyTasks extends $dara.Model {
  /**
   * @remarks
   * The log category.
   * 
   * @example
   * dcdn_log_er
   */
  businessType?: string;
  /**
   * @remarks
   * The data center. Valid values:
   * 
   * 1.  cn: the Chinese mainland.
   * 2.  sg: outside the Chinese mainland.
   * 
   * @example
   * cn
   */
  dataCenter?: string;
  /**
   * @remarks
   * The delivery destination.
   * 
   * @example
   * oss
   */
  deliveryType?: string;
  /**
   * @remarks
   * The status of the delivery task.
   * 
   * @example
   * online
   */
  status?: string;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * @example
   * testoss11
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      dataCenter: 'DataCenter',
      deliveryType: 'DeliveryType',
      status: 'Status',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      dataCenter: 'string',
      deliveryType: 'string',
      status: 'string',
      taskName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserRatePlanInstancesResponseBodyInstanceInfoSites extends $dara.Model {
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  /**
   * @remarks
   * The website status. Valid values:
   * 
   * *   pending: The website is to be configured.
   * *   active: The website is active.
   * *   offline: The website is suspended.
   * *   moved: The website has been added and verified by another Alibaba Cloud account.
   * 
   * @example
   * pending
   */
  siteStatus?: string;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      siteName: 'SiteName',
      siteStatus: 'SiteStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      siteName: 'string',
      siteStatus: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserRatePlanInstancesResponseBodyInstanceInfo extends $dara.Model {
  /**
   * @remarks
   * The billing method. Valid values:
   * 
   * *   PREPAY: subscription.
   * *   POSTPAY: pay-as-you-go.
   * 
   * @example
   * PREPAY
   */
  billingMode?: string;
  botInstanceLevel?: string;
  botRequest?: string;
  /**
   * @remarks
   * The service locations for the websites that can be associated with the plan. Multiple values are separated by commas (,). Valid values:
   * 
   * *   domestic: the Chinese mainland.
   * *   overseas: outside the Chinese mainland.
   * *   global: global.
   * 
   * @example
   * domestic,overseas
   */
  coverages?: string;
  /**
   * @remarks
   * The time when the plan was purchased.
   * 
   * @example
   * YYYY-MM-DDThh:mm:ssZ
   */
  createTime?: string;
  crossborderTraffic?: string;
  ddosBurstableDomesticProtection?: string;
  ddosBurstableOverseasProtection?: string;
  ddosInstanceLevel?: string;
  /**
   * @remarks
   * The subscription duration of the plan. Unit: month.
   * 
   * @example
   * 3
   */
  duration?: number;
  edgeRoutineRquest?: string;
  edgeWafRequest?: string;
  /**
   * @remarks
   * The time when the plan expires.
   * 
   * @example
   * YYYY-MM-DDThh:mm:ssZ
   */
  expireTime?: string;
  /**
   * @remarks
   * The plan ID.
   * 
   * @example
   * sp-xcdn-96wblslz****
   */
  instanceId?: string;
  layer4Traffic?: string;
  layer4TrafficIntl?: string;
  /**
   * @remarks
   * The plan name.
   * 
   * @example
   * basic
   */
  planName?: string;
  planTraffic?: string;
  /**
   * @remarks
   * The plan type. Valid values:
   * 
   * *   normal
   * *   enterprise
   * 
   * @example
   * normal
   */
  planType?: string;
  /**
   * @remarks
   * The maximum number of websites that can be associated with the plan.
   * 
   * @example
   * 1
   */
  siteQuota?: string;
  /**
   * @remarks
   * The websites that have been associated with the plan.
   */
  sites?: ListUserRatePlanInstancesResponseBodyInstanceInfoSites[];
  smartRoutingRequest?: string;
  staticRequest?: string;
  /**
   * @remarks
   * The plan status. Valid values:
   * 
   * *   online: The plan is in service.
   * *   offline: The plan has expired within an allowable period. In this state, the plan is unavailable.
   * *   disable: The plan is released.
   * 
   * @example
   * online
   */
  status?: string;
  subscribeType?: string;
  static names(): { [key: string]: string } {
    return {
      billingMode: 'BillingMode',
      botInstanceLevel: 'BotInstanceLevel',
      botRequest: 'BotRequest',
      coverages: 'Coverages',
      createTime: 'CreateTime',
      crossborderTraffic: 'CrossborderTraffic',
      ddosBurstableDomesticProtection: 'DdosBurstableDomesticProtection',
      ddosBurstableOverseasProtection: 'DdosBurstableOverseasProtection',
      ddosInstanceLevel: 'DdosInstanceLevel',
      duration: 'Duration',
      edgeRoutineRquest: 'EdgeRoutineRquest',
      edgeWafRequest: 'EdgeWafRequest',
      expireTime: 'ExpireTime',
      instanceId: 'InstanceId',
      layer4Traffic: 'Layer4Traffic',
      layer4TrafficIntl: 'Layer4TrafficIntl',
      planName: 'PlanName',
      planTraffic: 'PlanTraffic',
      planType: 'PlanType',
      siteQuota: 'SiteQuota',
      sites: 'Sites',
      smartRoutingRequest: 'SmartRoutingRequest',
      staticRequest: 'StaticRequest',
      status: 'Status',
      subscribeType: 'SubscribeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      billingMode: 'string',
      botInstanceLevel: 'string',
      botRequest: 'string',
      coverages: 'string',
      createTime: 'string',
      crossborderTraffic: 'string',
      ddosBurstableDomesticProtection: 'string',
      ddosBurstableOverseasProtection: 'string',
      ddosInstanceLevel: 'string',
      duration: 'number',
      edgeRoutineRquest: 'string',
      edgeWafRequest: 'string',
      expireTime: 'string',
      instanceId: 'string',
      layer4Traffic: 'string',
      layer4TrafficIntl: 'string',
      planName: 'string',
      planTraffic: 'string',
      planType: 'string',
      siteQuota: 'string',
      sites: { 'type': 'array', 'itemType': ListUserRatePlanInstancesResponseBodyInstanceInfoSites },
      smartRoutingRequest: 'string',
      staticRequest: 'string',
      status: 'string',
      subscribeType: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.sites)) {
      $dara.Model.validateArray(this.sites);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafManagedRulesRequestQueryArgs extends $dara.Model {
  /**
   * @remarks
   * The action that you want WAF to perform on requests that match the rule.
   * 
   * @example
   * deny
   */
  action?: string;
  /**
   * @remarks
   * The rule ID or name for fuzzy search.
   * 
   * @example
   * example
   */
  idNameLike?: string;
  /**
   * @remarks
   * The protection levels of the rules.
   */
  protectionLevels?: number[];
  /**
   * @remarks
   * The status of the rule.
   * 
   * @example
   * on
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      idNameLike: 'IdNameLike',
      protectionLevels: 'ProtectionLevels',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      idNameLike: 'string',
      protectionLevels: { 'type': 'array', 'itemType': 'number' },
      status: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.protectionLevels)) {
      $dara.Model.validateArray(this.protectionLevels);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafManagedRulesResponseBodyRules extends $dara.Model {
  /**
   * @remarks
   * The action that WAF performs on requests that match the managed rule.
   * 
   * @example
   * deny
   */
  action?: string;
  /**
   * @remarks
   * The ID of the managed rule.
   * 
   * @example
   * 100001
   */
  id?: number;
  /**
   * @remarks
   * The name of the managed rule.
   */
  name?: string;
  /**
   * @remarks
   * The protection level of the managed rule.
   * 
   * @example
   * 1
   */
  protectionLevel?: number;
  /**
   * @remarks
   * The status of the protection rule.
   * 
   * @example
   * on
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      id: 'Id',
      name: 'Name',
      protectionLevel: 'ProtectionLevel',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      id: 'number',
      name: 'string',
      protectionLevel: 'number',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafPhasesResponseBodyPhasesRulesets extends $dara.Model {
  /**
   * @remarks
   * The ID of the WAF ruleset.[](~~2850233~~)
   * 
   * @example
   * 10000001
   */
  id?: number;
  /**
   * @remarks
   * The name of the WAF ruleset.
   * 
   * @example
   * example
   */
  name?: string;
  /**
   * @remarks
   * The rule configurations in the WAF ruleset.
   */
  rules?: WafRuleConfig[];
  /**
   * @remarks
   * The configurations shared by the rules in the WAF ruleset.
   */
  shared?: WafBatchRuleShared;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
      rules: 'Rules',
      shared: 'Shared',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
      rules: { 'type': 'array', 'itemType': WafRuleConfig },
      shared: WafBatchRuleShared,
    };
  }

  validate() {
    if(Array.isArray(this.rules)) {
      $dara.Model.validateArray(this.rules);
    }
    if(this.shared && typeof (this.shared as any).validate === 'function') {
      (this.shared as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafPhasesResponseBodyPhases extends $dara.Model {
  /**
   * @remarks
   * The name of the WAF rule category.
   * 
   * @example
   * http_custom
   */
  phase?: string;
  /**
   * @remarks
   * The WAF rulesets.
   */
  rulesets?: ListWafPhasesResponseBodyPhasesRulesets[];
  static names(): { [key: string]: string } {
    return {
      phase: 'Phase',
      rulesets: 'Rulesets',
    };
  }

  static types(): { [key: string]: any } {
    return {
      phase: 'string',
      rulesets: { 'type': 'array', 'itemType': ListWafPhasesResponseBodyPhasesRulesets },
    };
  }

  validate() {
    if(Array.isArray(this.rulesets)) {
      $dara.Model.validateArray(this.rulesets);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafTemplateRulesRequestQueryArgs extends $dara.Model {
  /**
   * @remarks
   * The rule type.
   * 
   * @example
   * http_directory_traversal
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafTemplateRulesResponseBodyRules extends $dara.Model {
  /**
   * @remarks
   * The configuration of the rule.
   */
  config?: WafRuleConfig;
  /**
   * @remarks
   * The rule name.
   * 
   * @example
   * HTTP Directory Traversal Rule [Template]
   */
  name?: string;
  /**
   * @remarks
   * The WAF rule category.
   * 
   * @example
   * http_anti_scan
   */
  phase?: string;
  /**
   * @remarks
   * Indicates whether the rule is enabled.
   * 
   * @example
   * on
   */
  status?: string;
  /**
   * @remarks
   * The rule type.
   * 
   * @example
   * http_directory_traversal
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      name: 'Name',
      phase: 'Phase',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: WafRuleConfig,
      name: 'string',
      phase: 'string',
      status: 'string',
      type: 'string',
    };
  }

  validate() {
    if(this.config && typeof (this.config as any).validate === 'function') {
      (this.config as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafUsageOfRulesResponseBodySites extends $dara.Model {
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  name?: string;
  /**
   * @remarks
   * The usage of WAF rules or WAF rulesets.
   * 
   * @example
   * 1
   */
  usage?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
      usage: 'Usage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
      usage: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWaitingRoomEventsResponseBodyWaitingRoomEvents extends $dara.Model {
  /**
   * @remarks
   * The content of the custom waiting room page. This parameter is returned when the waiting room type is set to custom. The content is URL-encoded.
   * 
   * @example
   * html-yets-maqi1111
   */
  customPageHtml?: string;
  /**
   * @remarks
   * The event description.
   * 
   * @example
   * terraform-example
   */
  description?: string;
  /**
   * @remarks
   * Indicates whether session renewal is disabled. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * off
   */
  disableSessionRenewalEnable?: string;
  /**
   * @remarks
   * The event status. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  enable?: string;
  /**
   * @remarks
   * The end time of the event. This value is a UNIX timestamp.
   * 
   * @example
   * 1719814497
   */
  endTime?: string;
  /**
   * @remarks
   * Indicates whether JOSN response is enabled. If JSON response is enabled, a JSON body is returned for requests to the waiting room with the header Accept: application/json. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * off
   */
  jsonResponseEnable?: string;
  /**
   * @remarks
   * The language of the waiting room page. This parameter is returned when the waiting room type is set to default. Valid values:
   * 
   * *   enus: English.
   * *   zhcn: Simplified Chinese.
   * *   zhhk: Traditional Chinese.
   * 
   * @example
   * zhcn
   */
  language?: string;
  /**
   * @remarks
   * The custom event name.
   */
  name?: string;
  /**
   * @remarks
   * The maximum number of new users per minute.
   * 
   * @example
   * 11
   */
  newUsersPerMinute?: string;
  /**
   * @remarks
   * Indicates whether pre-queuing is enabled. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  preQueueEnable?: string;
  /**
   * @remarks
   * The start time for pre-queuing. This value is a UNIX timestamp. This parameter is valid only when pre-queuing is enabled.
   * 
   * @example
   * 1719814097
   */
  preQueueStartTime?: string;
  /**
   * @remarks
   * The queuing method. Valid values:
   * 
   * *   random: Users gain access to the origin randomly, regardless of the arrival time.
   * *   fifo: Users gain access to the origin in order of arrival.
   * *   passthrough: Users pass through the waiting room and go straight to the origin.
   * *   reject-all: Users are blocked from reaching the origin.
   * 
   * @example
   * fifo
   */
  queuingMethod?: string;
  /**
   * @remarks
   * The HTTP status code to return while a user is in the queue. Valid values:
   * 
   * *   200
   * *   202
   * *   429
   * 
   * @example
   * 200
   */
  queuingStatusCode?: string;
  /**
   * @remarks
   * Indicates whether random queuing is enabled. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  randomPreQueueEnable?: string;
  /**
   * @remarks
   * The maximum duration for which a session remains valid after a user leaves the origin. Unit: minutes.
   * 
   * @example
   * 3
   */
  sessionDuration?: string;
  /**
   * @remarks
   * The start time of the event. This value is a UNIX timestamp.
   * 
   * @example
   * 1719814398
   */
  startTime?: string;
  /**
   * @remarks
   * The maximum number of active users.
   * 
   * @example
   * 22
   */
  totalActiveUsers?: string;
  /**
   * @remarks
   * The unique ID of the waiting room event.
   * 
   * @example
   * 89677721098****
   */
  waitingRoomEventId?: number;
  /**
   * @remarks
   * The ID of the waiting room associated with the event.
   * 
   * @example
   * 5c938a045c9ca46607163d34966****
   */
  waitingRoomId?: string;
  /**
   * @remarks
   * The type of the waiting room. Valid values:
   * 
   * *   default
   * *   custom
   * 
   * @example
   * custom
   */
  waitingRoomType?: string;
  static names(): { [key: string]: string } {
    return {
      customPageHtml: 'CustomPageHtml',
      description: 'Description',
      disableSessionRenewalEnable: 'DisableSessionRenewalEnable',
      enable: 'Enable',
      endTime: 'EndTime',
      jsonResponseEnable: 'JsonResponseEnable',
      language: 'Language',
      name: 'Name',
      newUsersPerMinute: 'NewUsersPerMinute',
      preQueueEnable: 'PreQueueEnable',
      preQueueStartTime: 'PreQueueStartTime',
      queuingMethod: 'QueuingMethod',
      queuingStatusCode: 'QueuingStatusCode',
      randomPreQueueEnable: 'RandomPreQueueEnable',
      sessionDuration: 'SessionDuration',
      startTime: 'StartTime',
      totalActiveUsers: 'TotalActiveUsers',
      waitingRoomEventId: 'WaitingRoomEventId',
      waitingRoomId: 'WaitingRoomId',
      waitingRoomType: 'WaitingRoomType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customPageHtml: 'string',
      description: 'string',
      disableSessionRenewalEnable: 'string',
      enable: 'string',
      endTime: 'string',
      jsonResponseEnable: 'string',
      language: 'string',
      name: 'string',
      newUsersPerMinute: 'string',
      preQueueEnable: 'string',
      preQueueStartTime: 'string',
      queuingMethod: 'string',
      queuingStatusCode: 'string',
      randomPreQueueEnable: 'string',
      sessionDuration: 'string',
      startTime: 'string',
      totalActiveUsers: 'string',
      waitingRoomEventId: 'number',
      waitingRoomId: 'string',
      waitingRoomType: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWaitingRoomRulesResponseBodyWaitingRoomRules extends $dara.Model {
  /**
   * @remarks
   * The rule content, which is a policy or conditional expression.
   * 
   * @example
   * (http.request.uri.path.file_name eq \\"jpg\\")
   */
  rule?: string;
  /**
   * @remarks
   * Indicates whether the rule is enabled. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @remarks
   * The rule name.
   * 
   * @example
   * ip
   */
  ruleName?: string;
  /**
   * @remarks
   * The rule ID.
   * 
   * @example
   * 37286782688****
   */
  waitingRoomRuleId?: number;
  static names(): { [key: string]: string } {
    return {
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      waitingRoomRuleId: 'WaitingRoomRuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      waitingRoomRuleId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWaitingRoomsResponseBodyWaitingRoomsHostNameAndPath extends $dara.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domain?: string;
  /**
   * @remarks
   * The path.
   * 
   * @example
   * /test
   */
  path?: string;
  /**
   * @remarks
   * The subdomain.
   * 
   * @example
   * test.
   */
  subdomain?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      path: 'Path',
      subdomain: 'Subdomain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      path: 'string',
      subdomain: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWaitingRoomsResponseBodyWaitingRooms extends $dara.Model {
  /**
   * @remarks
   * The name of the custom cookie.
   * 
   * @example
   * __aliwaitingroom_example
   */
  cookieName?: string;
  /**
   * @remarks
   * The HTML content or identifier of the custom queuing page. This parameter is valid only when `WaitingRoomType` is set to `custom`. The content must be URL-encoded.
   */
  customPageHtml?: string;
  /**
   * @remarks
   * The description of the waiting room.
   */
  description?: string;
  /**
   * @remarks
   * Indicates whether session renewal is disabled. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  disableSessionRenewalEnable?: string;
  /**
   * @remarks
   * Indicates whether the waiting room is enabled. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  enable?: string;
  /**
   * @remarks
   * The hostname and path.
   */
  hostNameAndPath?: ListWaitingRoomsResponseBodyWaitingRoomsHostNameAndPath[];
  /**
   * @remarks
   * Indicates whether JSON response is enabled. If you set this parameter to on, a JSON body is returned for requests to the waiting room with the header Accept: application/json. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  jsonResponseEnable?: string;
  /**
   * @remarks
   * The language of the waiting room page. This parameter is returned when the waiting room type is set to default. Valid values:
   * 
   * *   enus: English.
   * *   zhcn: Simplified Chinese.
   * *   zhhk: Traditional Chinese.
   * 
   * @example
   * zhcn
   */
  language?: string;
  /**
   * @remarks
   * The name of the waiting room.
   */
  name?: string;
  /**
   * @remarks
   * The maximum number of new users per minute.
   * 
   * @example
   * 200
   */
  newUsersPerMinute?: string;
  /**
   * @remarks
   * Indicates whether all requests must be queued. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  queueAllEnable?: string;
  /**
   * @remarks
   * The queuing method. Valid values:
   * 
   * *   random: Users gain access to the origin randomly, regardless of the arrival time.
   * *   fifo: Users gain access to the origin in order of arrival.
   * *   passthrough: Users pass through the waiting room and go straight to the origin.
   * *   reject-all: Users are blocked from reaching the origin.
   * 
   * @example
   * random
   */
  queuingMethod?: string;
  /**
   * @remarks
   * The HTTP status code to return while a user is in the queue. Valid values:
   * 
   * *   200
   * *   202
   * *   429
   * 
   * @example
   * 200
   */
  queuingStatusCode?: string;
  /**
   * @remarks
   * The maximum duration for which a session remains valid after a user leaves the origin. Unit: minutes.
   * 
   * @example
   * 3600
   */
  sessionDuration?: string;
  /**
   * @remarks
   * The maximum number of active users.
   * 
   * @example
   * 300
   */
  totalActiveUsers?: string;
  /**
   * @remarks
   * The unique ID of the waiting room.
   * 
   * @example
   * 6a51d5bc6460887abd1291dc7d4d****
   */
  waitingRoomId?: string;
  /**
   * @remarks
   * The type of the waiting room. Valid values:
   * 
   * *   default
   * *   custom
   * 
   * @example
   * default
   */
  waitingRoomType?: string;
  static names(): { [key: string]: string } {
    return {
      cookieName: 'CookieName',
      customPageHtml: 'CustomPageHtml',
      description: 'Description',
      disableSessionRenewalEnable: 'DisableSessionRenewalEnable',
      enable: 'Enable',
      hostNameAndPath: 'HostNameAndPath',
      jsonResponseEnable: 'JsonResponseEnable',
      language: 'Language',
      name: 'Name',
      newUsersPerMinute: 'NewUsersPerMinute',
      queueAllEnable: 'QueueAllEnable',
      queuingMethod: 'QueuingMethod',
      queuingStatusCode: 'QueuingStatusCode',
      sessionDuration: 'SessionDuration',
      totalActiveUsers: 'TotalActiveUsers',
      waitingRoomId: 'WaitingRoomId',
      waitingRoomType: 'WaitingRoomType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cookieName: 'string',
      customPageHtml: 'string',
      description: 'string',
      disableSessionRenewalEnable: 'string',
      enable: 'string',
      hostNameAndPath: { 'type': 'array', 'itemType': ListWaitingRoomsResponseBodyWaitingRoomsHostNameAndPath },
      jsonResponseEnable: 'string',
      language: 'string',
      name: 'string',
      newUsersPerMinute: 'string',
      queueAllEnable: 'string',
      queuingMethod: 'string',
      queuingStatusCode: 'string',
      sessionDuration: 'string',
      totalActiveUsers: 'string',
      waitingRoomId: 'string',
      waitingRoomType: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.hostNameAndPath)) {
      $dara.Model.validateArray(this.hostNameAndPath);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurgeCachesRequestContentCacheKeys extends $dara.Model {
  headers?: { [key: string]: string };
  url?: string;
  static names(): { [key: string]: string } {
    return {
      headers: 'Headers',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      url: 'string',
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurgeCachesRequestContent extends $dara.Model {
  cacheKeys?: PurgeCachesRequestContentCacheKeys[];
  /**
   * @remarks
   * The cache tags that are used to purge the cache. This parameter is required if Type is set to cachetag.
   */
  cacheTags?: string[];
  /**
   * @remarks
   * The directories that are used to purge the cache. This parameter is required if Type is set to directory.
   */
  directories?: string[];
  /**
   * @remarks
   * The files to purge. This parameter is required if Type is set to file.
   */
  files?: any[];
  /**
   * @remarks
   * The hostnames that are used to purge the cache. This parameter is required if Type is set to hostname.
   */
  hostnames?: string[];
  /**
   * @remarks
   * The file URLs with parameters ignored that are used to purge the cache. This parameter is required if Type is set to ignoreParams.
   */
  ignoreParams?: string[];
  /**
   * @remarks
   * Specifies whether to purge all cache of the website. Default value: false. The value is true when Type is set to purgeall.
   * 
   * @example
   * true
   */
  purgeAll?: boolean;
  static names(): { [key: string]: string } {
    return {
      cacheKeys: 'CacheKeys',
      cacheTags: 'CacheTags',
      directories: 'Directories',
      files: 'Files',
      hostnames: 'Hostnames',
      ignoreParams: 'IgnoreParams',
      purgeAll: 'PurgeAll',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cacheKeys: { 'type': 'array', 'itemType': PurgeCachesRequestContentCacheKeys },
      cacheTags: { 'type': 'array', 'itemType': 'string' },
      directories: { 'type': 'array', 'itemType': 'string' },
      files: { 'type': 'array', 'itemType': 'any' },
      hostnames: { 'type': 'array', 'itemType': 'string' },
      ignoreParams: { 'type': 'array', 'itemType': 'string' },
      purgeAll: 'boolean',
    };
  }

  validate() {
    if(Array.isArray(this.cacheKeys)) {
      $dara.Model.validateArray(this.cacheKeys);
    }
    if(Array.isArray(this.cacheTags)) {
      $dara.Model.validateArray(this.cacheTags);
    }
    if(Array.isArray(this.directories)) {
      $dara.Model.validateArray(this.directories);
    }
    if(Array.isArray(this.files)) {
      $dara.Model.validateArray(this.files);
    }
    if(Array.isArray(this.hostnames)) {
      $dara.Model.validateArray(this.hostnames);
    }
    if(Array.isArray(this.ignoreParams)) {
      $dara.Model.validateArray(this.ignoreParams);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHttpRequestHeaderModificationRuleRequestRequestHeaderModification extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * headerName
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * add
   */
  operation?: string;
  /**
   * @example
   * headerValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      operation: 'Operation',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      operation: 'string',
      value: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHttpResponseHeaderModificationRuleRequestResponseHeaderModification extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * headerName
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * add
   */
  operation?: string;
  /**
   * @example
   * headerValue
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      operation: 'Operation',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      operation: 'string',
      value: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLoadBalancerRequestAdaptiveRouting extends $dara.Model {
  /**
   * @example
   * false
   */
  failoverAcrossPools?: boolean;
  static names(): { [key: string]: string } {
    return {
      failoverAcrossPools: 'FailoverAcrossPools',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failoverAcrossPools: 'boolean',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLoadBalancerRequestMonitor extends $dara.Model {
  /**
   * @example
   * 5
   */
  consecutiveDown?: number;
  /**
   * @example
   * 3
   */
  consecutiveUp?: number;
  /**
   * @example
   * 200,202
   */
  expectedCodes?: string;
  /**
   * @example
   * true
   */
  followRedirects?: boolean;
  /**
   * @example
   * {
   *         "host": [
   *             "example1.com",
   *             "example2.com"
   *         ]
   *     }
   */
  header?: any;
  /**
   * @example
   * 100
   */
  interval?: number;
  /**
   * @example
   * GET
   */
  method?: string;
  /**
   * @example
   * /health
   */
  path?: string;
  /**
   * @example
   * 80
   */
  port?: number;
  /**
   * @example
   * 5
   */
  timeout?: number;
  /**
   * @example
   * HTTP
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      consecutiveDown: 'ConsecutiveDown',
      consecutiveUp: 'ConsecutiveUp',
      expectedCodes: 'ExpectedCodes',
      followRedirects: 'FollowRedirects',
      header: 'Header',
      interval: 'Interval',
      method: 'Method',
      path: 'Path',
      port: 'Port',
      timeout: 'Timeout',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consecutiveDown: 'number',
      consecutiveUp: 'number',
      expectedCodes: 'string',
      followRedirects: 'boolean',
      header: 'any',
      interval: 'number',
      method: 'string',
      path: 'string',
      port: 'number',
      timeout: 'number',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLoadBalancerRequestRandomSteering extends $dara.Model {
  /**
   * @example
   * 50
   */
  defaultWeight?: number;
  poolWeights?: { [key: string]: number };
  static names(): { [key: string]: string } {
    return {
      defaultWeight: 'DefaultWeight',
      poolWeights: 'PoolWeights',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultWeight: 'number',
      poolWeights: { 'type': 'map', 'keyType': 'string', 'valueType': 'number' },
    };
  }

  validate() {
    if(this.poolWeights) {
      $dara.Model.validateMap(this.poolWeights);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLoadBalancerRequestRulesFixedResponse extends $dara.Model {
  /**
   * @example
   * application/json
   */
  contentType?: string;
  /**
   * @example
   * http://www.example.com/index.html
   */
  location?: string;
  /**
   * @example
   * Hello World!
   */
  messageBody?: string;
  /**
   * @example
   * 200
   */
  statusCode?: number;
  static names(): { [key: string]: string } {
    return {
      contentType: 'ContentType',
      location: 'Location',
      messageBody: 'MessageBody',
      statusCode: 'StatusCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentType: 'string',
      location: 'string',
      messageBody: 'string',
      statusCode: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLoadBalancerRequestRules extends $dara.Model {
  fixedResponse?: UpdateLoadBalancerRequestRulesFixedResponse;
  /**
   * @example
   * {
   *             "adaptive_routing": {
   *                 "failover_across_pools": true
   *             },
   *             "sub_region_pools": {
   *                 "AL,AT": [
   *                     92298024898****,
   *                     92304347804****
   *                 ],
   *                 "BG,BY": [
   *                     92298024898****
   *                 ]
   *             },
   *             "default_pools": [
   *                 92298024898****,
   *                 92304347804****
   *             ],
   *             "fallback_pool": 92298024898****,
   *             "location_strategy": {
   *                 "mode": "resolver_ip",
   *                 "prefer_ecs": "always"
   *             },
   *             "random_steering": {
   *                 "default_weight": 0.3,
   *                 "pool_weights": {
   *                     "92298024898****": 0.7,
   *                     "92304347804****": 0.8
   *                 }
   *             },
   *             "region_pools": {
   *                 "CN,SEAS": [
   *                     92298024898****,
   *                     92304347804****
   *                 ],
   *                 "SAF,SAS": [
   *                     92304347804****
   *                 ]
   *             },
   *             "session_affinity": "ip",
   *             "steering_policy": "geo",
   *             "ttl": 30
   *         }
   */
  overrides?: any;
  /**
   * @example
   * http.request.method eq "GET"
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_1
   */
  ruleName?: string;
  /**
   * @example
   * 1
   */
  sequence?: number;
  /**
   * @example
   * true
   */
  terminates?: boolean;
  static names(): { [key: string]: string } {
    return {
      fixedResponse: 'FixedResponse',
      overrides: 'Overrides',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      terminates: 'Terminates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fixedResponse: UpdateLoadBalancerRequestRulesFixedResponse,
      overrides: 'any',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'number',
      terminates: 'boolean',
    };
  }

  validate() {
    if(this.fixedResponse && typeof (this.fixedResponse as any).validate === 'function') {
      (this.fixedResponse as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOriginPoolRequestOriginsAuthConf extends $dara.Model {
  accessKey?: string;
  authType?: string;
  region?: string;
  secretKey?: string;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      accessKey: 'AccessKey',
      authType: 'AuthType',
      region: 'Region',
      secretKey: 'SecretKey',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKey: 'string',
      authType: 'string',
      region: 'string',
      secretKey: 'string',
      version: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOriginPoolRequestOrigins extends $dara.Model {
  address?: string;
  authConf?: UpdateOriginPoolRequestOriginsAuthConf;
  enabled?: boolean;
  header?: any;
  name?: string;
  type?: string;
  weight?: number;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      authConf: 'AuthConf',
      enabled: 'Enabled',
      header: 'Header',
      name: 'Name',
      type: 'Type',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      authConf: UpdateOriginPoolRequestOriginsAuthConf,
      enabled: 'boolean',
      header: 'any',
      name: 'string',
      type: 'string',
      weight: 'number',
    };
  }

  validate() {
    if(this.authConf && typeof (this.authConf as any).validate === 'function') {
      (this.authConf as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRecordRequestAuthConf extends $dara.Model {
  /**
   * @remarks
   * The access key of the account to which the origin server belongs. This parameter is required when the SourceType is OSS, and AuthType is private_same_account, or when the SourceType is S3 and AuthType is private.
   * 
   * @example
   * VIxuvJSA2S03f******kp208dy5w7
   */
  accessKey?: string;
  /**
   * @remarks
   * The authentication type of the origin server. Different origins support different authentication types. The type of origin refers to the SourceType parameter in this operation. If the type of origin is OSS or S3, you must specify the authentication type of the origin. Valid values:
   * 
   * *   **public**: public read. Select this value when the origin type is OSS or S3 and the origin access is public read.
   * *   **private**: private read. Select this value when the origin type is S3 and the origin access is private read.
   * *   **private_same_account**: private read under the same account. Select this value when the origin type is OSS, the origins belong to the same Alibaba Cloud account, and the origins have private read access.
   * 
   * @example
   * private
   */
  authType?: string;
  /**
   * @remarks
   * The version of the signature algorithm. This parameter is required when the origin type is S3 and AuthType is private. The following two types are supported:
   * 
   * *   **v2**
   * *   **v4**
   * 
   * If you leave this parameter empty, the default value v4 is used.
   * 
   * @example
   * v2
   */
  region?: string;
  /**
   * @remarks
   * The secret access key of the account to which the origin server belongs. This parameter is required when the SourceType is OSS, and AuthType is private_same_account, or when the SourceType is S3 and AuthType is private.
   * 
   * @example
   * u0Nkg5gBK*******QF5wvKMM504JUHt
   */
  secretKey?: string;
  /**
   * @remarks
   * The region of the origin. If the origin type is S3, you must specify this value. You can get the region information from the official website of S3.
   * 
   * @example
   * us-east-1
   */
  version?: string;
  static names(): { [key: string]: string } {
    return {
      accessKey: 'AccessKey',
      authType: 'AuthType',
      region: 'Region',
      secretKey: 'SecretKey',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKey: 'string',
      authType: 'string',
      region: 'string',
      secretKey: 'string',
      version: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRecordRequestData extends $dara.Model {
  /**
   * @remarks
   * The encryption algorithm used for the record, specified within the range from 0 to 255. This parameter is required when you add CERT or SSHFP records.
   * 
   * @example
   * 0
   */
  algorithm?: number;
  /**
   * @remarks
   * The public key of the certificate. This parameter is required when you add CERT, SMIMEA, or TLSA records.
   * 
   * @example
   * dGVzdGFkYWxrcw==
   */
  certificate?: string;
  /**
   * @remarks
   * The public key fingerprint of the record. This parameter is required when you add a SSHFP record.
   * 
   * @example
   * abcdef1234567890
   */
  fingerprint?: string;
  /**
   * @remarks
   * The flag bit of the record. The Flag for a CAA record indicates its priority and how it is processed, specified within the range of 0 to 255. This parameter is required when you add a CAA record.
   * 
   * @example
   * 128
   */
  flag?: number;
  /**
   * @remarks
   * The public key identification for the record, specified within the range of 0 to 65,535. This parameter is required when you add a CAA record.
   * 
   * @example
   * 0
   */
  keyTag?: number;
  /**
   * @remarks
   * The algorithm policy used to match or validate the certificate, specified within the range 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
   * 
   * @example
   * 0
   */
  matchingType?: number;
  /**
   * @remarks
   * The port of the record, specified within the range of 0 to 65,535. This parameter is required when you add an SRV record.
   * 
   * @example
   * 0
   */
  port?: number;
  /**
   * @remarks
   * The priority of the record, specified within the range of 0 to 65,535. A smaller value indicates a higher priority. This parameter is required when you add MX, SRV, and URI records.
   * 
   * @example
   * 10
   */
  priority?: number;
  /**
   * @remarks
   * The type of certificate or public key, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
   * 
   * @example
   * 0
   */
  selector?: number;
  /**
   * @remarks
   * The label of the record. The Tag of a CAA record indicate its specific type and usage. This parameter is required when you add a CAA record.
   * 
   * @example
   * issue
   */
  tag?: string;
  /**
   * @remarks
   * The certificate type of the record (in CERT records), or the public key type (in SSHFP records). This parameter is required when you add CERT or SSHFP records.
   * 
   * @example
   * 0
   */
  type?: number;
  /**
   * @remarks
   * The usage identifier of the record, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.
   * 
   * @example
   * 0
   */
  usage?: number;
  /**
   * @remarks
   * The record value or part of the record content. This parameter is required when you add A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, and URI records. It has different meanings based on different types of records:
   * 
   * *   **A/AAAA**: the IP address(es). Separate multiple IPs with commas (,). You must have at least one IPv4 address.
   * *   **CNAME**: the target domain name.
   * *   **NS**: the name servers for the domain name.
   * *   **MX**: a valid domain name of the target mail server.
   * *   **TXT**: a valid text string.
   * *   **CAA**: a valid domain name of the certificate authority.
   * *   **SRV**: a valid domain name of the target host.
   * *   **URI**: a valid URI string.
   * 
   * @example
   * example.com
   */
  value?: string;
  /**
   * @remarks
   * The weight of the record, specified within the range of 0 to 65,535. This parameter is required when you add SRV or URI records.
   * 
   * @example
   * 0
   */
  weight?: number;
  static names(): { [key: string]: string } {
    return {
      algorithm: 'Algorithm',
      certificate: 'Certificate',
      fingerprint: 'Fingerprint',
      flag: 'Flag',
      keyTag: 'KeyTag',
      matchingType: 'MatchingType',
      port: 'Port',
      priority: 'Priority',
      selector: 'Selector',
      tag: 'Tag',
      type: 'Type',
      usage: 'Usage',
      value: 'Value',
      weight: 'Weight',
    };
  }

  static types(): { [key: string]: any } {
    return {
      algorithm: 'number',
      certificate: 'string',
      fingerprint: 'string',
      flag: 'number',
      keyTag: 'number',
      matchingType: 'number',
      port: 'number',
      priority: 'number',
      selector: 'number',
      tag: 'string',
      type: 'number',
      usage: 'number',
      value: 'string',
      weight: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaitingRoomRequestHostNameAndPath extends $dara.Model {
  /**
   * @remarks
   * The domain name.
   * 
   * @example
   * example.com
   */
  domain?: string;
  /**
   * @remarks
   * The probe path.
   * 
   * @example
   * /test
   */
  path?: string;
  /**
   * @remarks
   * The subdomain.
   * 
   * @example
   * test.
   */
  subdomain?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      path: 'Path',
      subdomain: 'Subdomain',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      path: 'string',
      subdomain: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafBatchRuleShared extends $dara.Model {
  action?: string;
  actions?: WafBatchRuleSharedActions;
  crossSiteId?: number;
  expression?: string;
  match?: WafRuleMatch2;
  mode?: string;
  name?: string;
  target?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      actions: 'Actions',
      crossSiteId: 'CrossSiteId',
      expression: 'Expression',
      match: 'Match',
      mode: 'Mode',
      name: 'Name',
      target: 'Target',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      actions: WafBatchRuleSharedActions,
      crossSiteId: 'number',
      expression: 'string',
      match: WafRuleMatch2,
      mode: 'string',
      name: 'string',
      target: 'string',
    };
  }

  validate() {
    if(this.actions && typeof (this.actions as any).validate === 'function') {
      (this.actions as any).validate();
    }
    if(this.match && typeof (this.match as any).validate === 'function') {
      (this.match as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafQuotaInteger extends $dara.Model {
  equal?: number;
  greaterThan?: number;
  greaterThanOrEqual?: number;
  lessThan?: number;
  lessThanOrEqual?: number;
  static names(): { [key: string]: string } {
    return {
      equal: 'Equal',
      greaterThan: 'GreaterThan',
      greaterThanOrEqual: 'GreaterThanOrEqual',
      lessThan: 'LessThan',
      lessThanOrEqual: 'LessThanOrEqual',
    };
  }

  static types(): { [key: string]: any } {
    return {
      equal: 'number',
      greaterThan: 'number',
      greaterThanOrEqual: 'number',
      lessThan: 'number',
      lessThanOrEqual: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafQuotaString extends $dara.Model {
  regexp?: string;
  static names(): { [key: string]: string } {
    return {
      regexp: 'Regexp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regexp: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleConfig extends $dara.Model {
  action?: string;
  actions?: WafRuleConfigActions;
  appPackage?: WafRuleConfigAppPackage;
  appSdk?: WafRuleConfigAppSdk;
  expression?: string;
  id?: number;
  managedGroupId?: number;
  managedList?: string;
  managedRulesets?: WafRuleConfigManagedRulesets[];
  name?: string;
  notes?: string;
  rateLimit?: WafRuleConfigRateLimit;
  sigchl?: string[];
  status?: string;
  timer?: WafTimer;
  type?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      actions: 'Actions',
      appPackage: 'AppPackage',
      appSdk: 'AppSdk',
      expression: 'Expression',
      id: 'Id',
      managedGroupId: 'ManagedGroupId',
      managedList: 'ManagedList',
      managedRulesets: 'ManagedRulesets',
      name: 'Name',
      notes: 'Notes',
      rateLimit: 'RateLimit',
      sigchl: 'Sigchl',
      status: 'Status',
      timer: 'Timer',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      actions: WafRuleConfigActions,
      appPackage: WafRuleConfigAppPackage,
      appSdk: WafRuleConfigAppSdk,
      expression: 'string',
      id: 'number',
      managedGroupId: 'number',
      managedList: 'string',
      managedRulesets: { 'type': 'array', 'itemType': WafRuleConfigManagedRulesets },
      name: 'string',
      notes: 'string',
      rateLimit: WafRuleConfigRateLimit,
      sigchl: { 'type': 'array', 'itemType': 'string' },
      status: 'string',
      timer: WafTimer,
      type: 'string',
      value: 'string',
    };
  }

  validate() {
    if(this.actions && typeof (this.actions as any).validate === 'function') {
      (this.actions as any).validate();
    }
    if(this.appPackage && typeof (this.appPackage as any).validate === 'function') {
      (this.appPackage as any).validate();
    }
    if(this.appSdk && typeof (this.appSdk as any).validate === 'function') {
      (this.appSdk as any).validate();
    }
    if(Array.isArray(this.managedRulesets)) {
      $dara.Model.validateArray(this.managedRulesets);
    }
    if(this.rateLimit && typeof (this.rateLimit as any).validate === 'function') {
      (this.rateLimit as any).validate();
    }
    if(Array.isArray(this.sigchl)) {
      $dara.Model.validateArray(this.sigchl);
    }
    if(this.timer && typeof (this.timer as any).validate === 'function') {
      (this.timer as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleMatch extends $dara.Model {
  convertToLower?: boolean;
  criteria?: WafRuleMatch[];
  logic?: string;
  matchOperator?: string;
  matchType?: string;
  matchValue?: any;
  negate?: boolean;
  static names(): { [key: string]: string } {
    return {
      convertToLower: 'ConvertToLower',
      criteria: 'Criteria',
      logic: 'Logic',
      matchOperator: 'MatchOperator',
      matchType: 'MatchType',
      matchValue: 'MatchValue',
      negate: 'Negate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      convertToLower: 'boolean',
      criteria: { 'type': 'array', 'itemType': WafRuleMatch },
      logic: 'string',
      matchOperator: 'string',
      matchType: 'string',
      matchValue: 'any',
      negate: 'boolean',
    };
  }

  validate() {
    if(Array.isArray(this.criteria)) {
      $dara.Model.validateArray(this.criteria);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafRuleMatch2 extends $dara.Model {
  convertToLower?: boolean;
  criteria?: WafRuleMatch2Criteria[];
  logic?: string;
  matchOperator?: string;
  matchType?: string;
  matchValue?: any;
  negate?: boolean;
  static names(): { [key: string]: string } {
    return {
      convertToLower: 'ConvertToLower',
      criteria: 'Criteria',
      logic: 'Logic',
      matchOperator: 'MatchOperator',
      matchType: 'MatchType',
      matchValue: 'MatchValue',
      negate: 'Negate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      convertToLower: 'boolean',
      criteria: { 'type': 'array', 'itemType': WafRuleMatch2Criteria },
      logic: 'string',
      matchOperator: 'string',
      matchType: 'string',
      matchValue: 'any',
      negate: 'boolean',
    };
  }

  validate() {
    if(Array.isArray(this.criteria)) {
      $dara.Model.validateArray(this.criteria);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafSiteSettings extends $dara.Model {
  addBotProtectionHeaders?: WafSiteSettingsAddBotProtectionHeaders;
  addSecurityHeaders?: WafSiteSettingsAddSecurityHeaders;
  botManagement?: WafSiteSettingsBotManagement;
  clientIpIdentifier?: WafSiteSettingsClientIpIdentifier;
  securityLevel?: WafSiteSettingsSecurityLevel;
  static names(): { [key: string]: string } {
    return {
      addBotProtectionHeaders: 'AddBotProtectionHeaders',
      addSecurityHeaders: 'AddSecurityHeaders',
      botManagement: 'BotManagement',
      clientIpIdentifier: 'ClientIpIdentifier',
      securityLevel: 'SecurityLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addBotProtectionHeaders: WafSiteSettingsAddBotProtectionHeaders,
      addSecurityHeaders: WafSiteSettingsAddSecurityHeaders,
      botManagement: WafSiteSettingsBotManagement,
      clientIpIdentifier: WafSiteSettingsClientIpIdentifier,
      securityLevel: WafSiteSettingsSecurityLevel,
    };
  }

  validate() {
    if(this.addBotProtectionHeaders && typeof (this.addBotProtectionHeaders as any).validate === 'function') {
      (this.addBotProtectionHeaders as any).validate();
    }
    if(this.addSecurityHeaders && typeof (this.addSecurityHeaders as any).validate === 'function') {
      (this.addSecurityHeaders as any).validate();
    }
    if(this.botManagement && typeof (this.botManagement as any).validate === 'function') {
      (this.botManagement as any).validate();
    }
    if(this.clientIpIdentifier && typeof (this.clientIpIdentifier as any).validate === 'function') {
      (this.clientIpIdentifier as any).validate();
    }
    if(this.securityLevel && typeof (this.securityLevel as any).validate === 'function') {
      (this.securityLevel as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class WafTimer extends $dara.Model {
  periods?: WafTimerPeriods[];
  scopes?: string;
  weeklyPeriods?: WafTimerWeeklyPeriods[];
  zone?: number;
  static names(): { [key: string]: string } {
    return {
      periods: 'Periods',
      scopes: 'Scopes',
      weeklyPeriods: 'WeeklyPeriods',
      zone: 'Zone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      periods: { 'type': 'array', 'itemType': WafTimerPeriods },
      scopes: 'string',
      weeklyPeriods: { 'type': 'array', 'itemType': WafTimerWeeklyPeriods },
      zone: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.periods)) {
      $dara.Model.validateArray(this.periods);
    }
    if(Array.isArray(this.weeklyPeriods)) {
      $dara.Model.validateArray(this.weeklyPeriods);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class HttpDeliveryHeaderParamValue extends $dara.Model {
  /**
   * @remarks
   * The static variable.
   * 
   * @example
   * alicdn
   */
  staticValue?: string;
  static names(): { [key: string]: string } {
    return {
      staticValue: 'StaticValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      staticValue: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class HttpDeliveryQueryParamValue extends $dara.Model {
  /**
   * @remarks
   * The static variable.
   * 
   * @example
   * alicdn
   */
  staticValue?: string;
  static names(): { [key: string]: string } {
    return {
      staticValue: 'StaticValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      staticValue: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FieldContentValue extends $dara.Model {
  /**
   * @remarks
   * The sequence number of the fields.
   * 
   * @example
   * 1
   */
  sortOrder?: number;
  /**
   * @remarks
   * The fields.
   */
  fieldList?: FieldContentValueFieldList[];
  static names(): { [key: string]: string } {
    return {
      sortOrder: 'SortOrder',
      fieldList: 'FieldList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sortOrder: 'number',
      fieldList: { 'type': 'array', 'itemType': FieldContentValueFieldList },
    };
  }

  validate() {
    if(Array.isArray(this.fieldList)) {
      $dara.Model.validateArray(this.fieldList);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuotaListItemsValue extends $dara.Model {
  /**
   * @remarks
   * Indicates whether the item type is configured in the custom list.
   */
  enable?: boolean;
  /**
   * @remarks
   * The format restrictions for the item type in the custom list.
   */
  value?: WafQuotaString;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'boolean',
      value: WafQuotaString,
    };
  }

  validate() {
    if(this.value && typeof (this.value as any).validate === 'function') {
      (this.value as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuotaPageContentTypesValue extends $dara.Model {
  /**
   * @remarks
   * Indicates whether the custom error pages of the Content-Type are configured.
   */
  enable?: boolean;
  /**
   * @remarks
   * The maximum length of the custom error pages of the Content-Type.
   */
  contentLength?: WafQuotaInteger;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
      contentLength: 'ContentLength',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'boolean',
      contentLength: WafQuotaInteger,
    };
  }

  validate() {
    if(this.contentLength && typeof (this.contentLength as any).validate === 'function') {
      (this.contentLength as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ActivateClientCertificateRequest extends $dara.Model {
  /**
   * @remarks
   * The certificate ID, which can be obtained by calling the [ListClientCertificates](https://help.aliyun.com/document_detail/2852848.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * babaded901474b9693acf530e0fb****
   */
  id?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ActivateClientCertificateResponseBody extends $dara.Model {
  /**
   * @remarks
   * The certificate ID.
   * 
   * @example
   * babaded901474b9693acf530e0fb****
   */
  id?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
      siteId: 'SiteId',
      siteName: 'SiteName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      requestId: 'string',
      siteId: 'number',
      siteName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ActivateClientCertificateResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ActivateClientCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ActivateClientCertificateResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ActivateVersionManagementRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ActivateVersionManagementResponseBody extends $dara.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ActivateVersionManagementResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ActivateVersionManagementResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ActivateVersionManagementResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyCertificateRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * www.example.com,blog.example.com
   */
  domains?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      domains: 'Domains',
      siteId: 'SiteId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domains: 'string',
      siteId: 'number',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyCertificateResponseBody extends $dara.Model {
  /**
   * @example
   * 156A6B-677B1A-4297B7-9187B7-2B44792
   */
  requestId?: string;
  result?: ApplyCertificateResponseBodyResult[];
  /**
   * @example
   * example.com
   */
  siteName?: string;
  /**
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
      siteName: 'SiteName',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ApplyCertificateResponseBodyResult },
      siteName: 'string',
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.result)) {
      $dara.Model.validateArray(this.result);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyCertificateResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ApplyCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ApplyCertificateResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateRecordsRequest extends $dara.Model {
  /**
   * @remarks
   * The list of DNS records to be created.
   * 
   * This parameter is required.
   */
  recordList?: BatchCreateRecordsRequestRecordList[];
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      recordList: 'RecordList',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordList: { 'type': 'array', 'itemType': BatchCreateRecordsRequestRecordList },
      siteId: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.recordList)) {
      $dara.Model.validateArray(this.recordList);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateRecordsShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The list of DNS records to be created.
   * 
   * This parameter is required.
   */
  recordListShrink?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      recordListShrink: 'RecordList',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordListShrink: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateRecordsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The records that have been created and failed to be created.
   */
  recordResultList?: BatchCreateRecordsResponseBodyRecordResultList;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2430E05E-1340-5773-B5E1-B743929F46F2
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      recordResultList: 'RecordResultList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordResultList: BatchCreateRecordsResponseBodyRecordResultList,
      requestId: 'string',
    };
  }

  validate() {
    if(this.recordResultList && typeof (this.recordResultList as any).validate === 'function') {
      (this.recordResultList as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchCreateRecordsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchCreateRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchCreateRecordsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteKvRequest extends $dara.Model {
  /**
   * @remarks
   * The keys that you want to delete. You can delete a maximum of 10,000 key-value pairs at a time.
   * 
   * This parameter is required.
   */
  keys?: string[];
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      keys: 'Keys',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keys: { 'type': 'array', 'itemType': 'string' },
      namespace: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.keys)) {
      $dara.Model.validateArray(this.keys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteKvShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The keys that you want to delete. You can delete a maximum of 10,000 key-value pairs at a time.
   * 
   * This parameter is required.
   */
  keysShrink?: string;
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      keysShrink: 'Keys',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keysShrink: 'string',
      namespace: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteKvResponseBody extends $dara.Model {
  /**
   * @remarks
   * The keys that failed to be deleted.
   */
  failKeys?: string[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * The keys that are deleted.
   */
  successKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      failKeys: 'FailKeys',
      requestId: 'RequestId',
      successKeys: 'SuccessKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failKeys: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
      successKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.failKeys)) {
      $dara.Model.validateArray(this.failKeys);
    }
    if(Array.isArray(this.successKeys)) {
      $dara.Model.validateArray(this.successKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteKvResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchDeleteKvResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchDeleteKvResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteKvWithHighCapacityRequest extends $dara.Model {
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  /**
   * @remarks
   * The download URL of the key-value pairs that you want to delete. This parameter is automatically filled in when you use the SDK to call the operation.
   * 
   * This parameter is required.
   * 
   * @example
   * https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      namespace: 'Namespace',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      namespace: 'string',
      url: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteKvWithHighCapacityAdvanceRequest extends $dara.Model {
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  /**
   * @remarks
   * The download URL of the key-value pairs that you want to delete. This parameter is automatically filled in when you use the SDK to call the operation.
   * 
   * This parameter is required.
   * 
   * @example
   * https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7
   */
  urlObject?: Readable;
  static names(): { [key: string]: string } {
    return {
      namespace: 'Namespace',
      urlObject: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      namespace: 'string',
      urlObject: 'Readable',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteKvWithHighCapacityResponseBody extends $dara.Model {
  /**
   * @remarks
   * The keys that failed to be deleted.
   */
  failKeys?: string[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * The keys that are deleted.
   */
  successKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      failKeys: 'FailKeys',
      requestId: 'RequestId',
      successKeys: 'SuccessKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failKeys: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
      successKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.failKeys)) {
      $dara.Model.validateArray(this.failKeys);
    }
    if(Array.isArray(this.successKeys)) {
      $dara.Model.validateArray(this.successKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchDeleteKvWithHighCapacityResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchDeleteKvWithHighCapacityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchDeleteKvWithHighCapacityResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetExpressionFieldsRequest extends $dara.Model {
  /**
   * @remarks
   * The regular expressions.
   * 
   * @example
   * http_bot
   */
  expressions?: BatchGetExpressionFieldsRequestExpressions[];
  /**
   * @remarks
   * The WAF rule category.
   * 
   * @example
   * http_bot
   */
  phase?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 1
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      expressions: 'Expressions',
      phase: 'Phase',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expressions: { 'type': 'array', 'itemType': BatchGetExpressionFieldsRequestExpressions },
      phase: 'string',
      siteId: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.expressions)) {
      $dara.Model.validateArray(this.expressions);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetExpressionFieldsShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The regular expressions.
   * 
   * @example
   * http_bot
   */
  expressionsShrink?: string;
  /**
   * @remarks
   * The WAF rule category.
   * 
   * @example
   * http_bot
   */
  phase?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 1
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      expressionsShrink: 'Expressions',
      phase: 'Phase',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expressionsShrink: 'string',
      phase: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetExpressionFieldsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The fields that match the regular expressions.
   */
  fields?: BatchGetExpressionFieldsResponseBodyFields[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      fields: 'Fields',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fields: { 'type': 'array', 'itemType': BatchGetExpressionFieldsResponseBodyFields },
      requestId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.fields)) {
      $dara.Model.validateArray(this.fields);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchGetExpressionFieldsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchGetExpressionFieldsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchGetExpressionFieldsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPutKvRequest extends $dara.Model {
  /**
   * @remarks
   * The key-value pairs that you want to configure at a time. The total size can be up to 2 MB (2  1000  1000).
   * 
   * This parameter is required.
   */
  kvList?: BatchPutKvRequestKvList[];
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      kvList: 'KvList',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      kvList: { 'type': 'array', 'itemType': BatchPutKvRequestKvList },
      namespace: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.kvList)) {
      $dara.Model.validateArray(this.kvList);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPutKvShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The key-value pairs that you want to configure at a time. The total size can be up to 2 MB (2  1000  1000).
   * 
   * This parameter is required.
   */
  kvListShrink?: string;
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      kvListShrink: 'KvList',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      kvListShrink: 'string',
      namespace: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPutKvResponseBody extends $dara.Model {
  /**
   * @remarks
   * The keys that failed to be written.
   */
  failKeys?: string[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * The keys that were written.
   */
  successKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      failKeys: 'FailKeys',
      requestId: 'RequestId',
      successKeys: 'SuccessKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failKeys: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
      successKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.failKeys)) {
      $dara.Model.validateArray(this.failKeys);
    }
    if(Array.isArray(this.successKeys)) {
      $dara.Model.validateArray(this.successKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPutKvResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchPutKvResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchPutKvResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPutKvWithHighCapacityRequest extends $dara.Model {
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  /**
   * @remarks
   * The download URL of the key-value pairs that you want to configure. This parameter is automatically filled in when you use the SDK to call the operation.
   * 
   * This parameter is required.
   * 
   * @example
   * https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      namespace: 'Namespace',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      namespace: 'string',
      url: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPutKvWithHighCapacityAdvanceRequest extends $dara.Model {
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  /**
   * @remarks
   * The download URL of the key-value pairs that you want to configure. This parameter is automatically filled in when you use the SDK to call the operation.
   * 
   * This parameter is required.
   * 
   * @example
   * https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7
   */
  urlObject?: Readable;
  static names(): { [key: string]: string } {
    return {
      namespace: 'Namespace',
      urlObject: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      namespace: 'string',
      urlObject: 'Readable',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPutKvWithHighCapacityResponseBody extends $dara.Model {
  /**
   * @remarks
   * The keys that failed to be written.
   */
  failKeys?: string[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * The keys that were written.
   */
  successKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      failKeys: 'FailKeys',
      requestId: 'RequestId',
      successKeys: 'SuccessKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failKeys: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
      successKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.failKeys)) {
      $dara.Model.validateArray(this.failKeys);
    }
    if(Array.isArray(this.successKeys)) {
      $dara.Model.validateArray(this.successKeys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchPutKvWithHighCapacityResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchPutKvWithHighCapacityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchPutKvWithHighCapacityResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BlockObjectRequest extends $dara.Model {
  /**
   * @remarks
   * The content to block.
   * 
   * This parameter is required.
   */
  content?: string[];
  /**
   * @remarks
   * The blocking period that you can extend. Set the value to 2year.
   * 
   * @example
   * 2year
   */
  extension?: string;
  /**
   * @remarks
   * The period of time during which the URL is blocked. Unit: seconds. Specify this parameter if Type is set to block.
   * 
   * @example
   * 864000
   */
  maxage?: number;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * BlockObject
   */
  siteId?: number;
  /**
   * @remarks
   * The type. Valid values:
   * 
   * *   **block**
   * *   **unblock**
   * 
   * This parameter is required.
   * 
   * @example
   * block
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      extension: 'Extension',
      maxage: 'Maxage',
      siteId: 'SiteId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'array', 'itemType': 'string' },
      extension: 'string',
      maxage: 'number',
      siteId: 'number',
      type: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.content)) {
      $dara.Model.validateArray(this.content);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BlockObjectShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The content to block.
   * 
   * This parameter is required.
   */
  contentShrink?: string;
  /**
   * @remarks
   * The blocking period that you can extend. Set the value to 2year.
   * 
   * @example
   * 2year
   */
  extension?: string;
  /**
   * @remarks
   * The period of time during which the URL is blocked. Unit: seconds. Specify this parameter if Type is set to block.
   * 
   * @example
   * 864000
   */
  maxage?: number;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * BlockObject
   */
  siteId?: number;
  /**
   * @remarks
   * The type. Valid values:
   * 
   * *   **block**
   * *   **unblock**
   * 
   * This parameter is required.
   * 
   * @example
   * block
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      contentShrink: 'Content',
      extension: 'Extension',
      maxage: 'Maxage',
      siteId: 'SiteId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentShrink: 'string',
      extension: 'string',
      maxage: 'number',
      siteId: 'number',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BlockObjectResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  /**
   * @remarks
   * The blocking task ID.
   * 
   * @example
   * 15940956620
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      taskId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BlockObjectResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BlockObjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BlockObjectResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckAssumeSlrRoleResponseBody extends $dara.Model {
  /**
   * @example
   * aliuid:xxx assumeOssRole not exist,serviceName:realtimelogpush.dcdnservices.aliyuncs.com
   */
  errorMsg?: string;
  /**
   * @example
   * true
   */
  isExist?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 34DCBC8A-****-****-****-6DAA11D7DDBD
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      errorMsg: 'ErrorMsg',
      isExist: 'IsExist',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorMsg: 'string',
      isExist: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckAssumeSlrRoleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CheckAssumeSlrRoleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CheckAssumeSlrRoleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckSiteNameRequest extends $dara.Model {
  /**
   * @remarks
   * The website name.
   * 
   * This parameter is required.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  static names(): { [key: string]: string } {
    return {
      siteName: 'SiteName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckSiteNameResponseBody extends $dara.Model {
  /**
   * @remarks
   * The description of the verification result. Valid values:
   * 
   * *   **success**: The verification is successful.
   * *   **Site.AlreadyExist**: The website domain name has already been added.
   * *   **Site.InvalidName**: Invalid website domain name.
   * *   **Site.SubSiteUnavailable**: Subdomains are not allowed.
   * *   **Site.InternalError**: An internal error occurs.
   * 
   * @example
   * success
   */
  description?: string;
  /**
   * @remarks
   * Indicates whether a subdomain is specified. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * false
   */
  isSubSite?: boolean;
  /**
   * @remarks
   * The verification message.
   */
  messeage?: string;
  /**
   * @remarks
   * Indicates whether the verification passed.
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  passed?: boolean;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CB1A380B-09F0-41BB-280B-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      isSubSite: 'IsSubSite',
      messeage: 'Messeage',
      passed: 'Passed',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      isSubSite: 'boolean',
      messeage: 'string',
      passed: 'boolean',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckSiteNameResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CheckSiteNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CheckSiteNameResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckSiteProjectNameRequest extends $dara.Model {
  /**
   * @remarks
   * The name of the real-time log delivery task.
   * 
   * This parameter is required.
   * 
   * @example
   * user_log
   */
  projectName?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 12312312213212
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      projectName: 'ProjectName',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectName: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckSiteProjectNameResponseBody extends $dara.Model {
  /**
   * @remarks
   * Indicates whether the task name is valid. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  check?: boolean;
  /**
   * @remarks
   * The result description.
   * 
   * @example
   * project name pass the check
   */
  description?: string;
  /**
   * @remarks
   * The name of the real-time log delivery task.
   * 
   * @example
   * dcdn_waf_userAccount_log
   */
  projectName?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 34DCBC8A-****-****-****-6DAA11D7DDBD
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      check: 'Check',
      description: 'Description',
      projectName: 'ProjectName',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      check: 'boolean',
      description: 'string',
      projectName: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckSiteProjectNameResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CheckSiteProjectNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CheckSiteProjectNameResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckUserProjectNameRequest extends $dara.Model {
  /**
   * @remarks
   * The name of the real-time log delivery task.
   * 
   * This parameter is required.
   * 
   * @example
   * ali-dcdn-log-56
   */
  projectName?: string;
  static names(): { [key: string]: string } {
    return {
      projectName: 'ProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckUserProjectNameResponseBody extends $dara.Model {
  /**
   * @remarks
   * Indicates whether the name is valid. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  check?: boolean;
  /**
   * @remarks
   * The reason why the name passed or failed the check.
   * 
   * @example
   * project name pass the check
   */
  description?: string;
  /**
   * @remarks
   * The name of the real-time log delivery task.
   * 
   * @example
   * ali-dcdn-log-56
   */
  projectName?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 34DCBC8A-****-****-****-6DAA11D7DDBD
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      check: 'Check',
      description: 'Description',
      projectName: 'ProjectName',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      check: 'boolean',
      description: 'string',
      projectName: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckUserProjectNameResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CheckUserProjectNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CheckUserProjectNameResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CommitRoutineStagingCodeRequest extends $dara.Model {
  /**
   * @remarks
   * The description of the code version.
   * 
   * @example
   * description of this code ver
   */
  codeDescription?: string;
  /**
   * @remarks
   * The routine name.
   * 
   * This parameter is required.
   * 
   * @example
   * CommitRoutineStagingCode
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      codeDescription: 'CodeDescription',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeDescription: 'string',
      name: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CommitRoutineStagingCodeResponseBody extends $dara.Model {
  /**
   * @remarks
   * The version number of the newly generated code.
   * 
   * @example
   * 1710120201067203242
   */
  codeVersion?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      codeVersion: 'CodeVersion',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeVersion: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CommitRoutineStagingCodeResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CommitRoutineStagingCodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CommitRoutineStagingCodeResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCacheRuleRequest extends $dara.Model {
  /**
   * @example
   * 8880
   */
  additionalCacheablePorts?: string;
  /**
   * @example
   * follow_origin
   */
  browserCacheMode?: string;
  /**
   * @example
   * 300
   */
  browserCacheTtl?: string;
  /**
   * @example
   * cache_all
   */
  bypassCache?: string;
  /**
   * @example
   * on
   */
  cacheDeceptionArmor?: string;
  /**
   * @example
   * bypass_cache_reserve
   */
  cacheReserveEligibility?: string;
  /**
   * @example
   * cookiename
   */
  checkPresenceCookie?: string;
  /**
   * @example
   * headername
   */
  checkPresenceHeader?: string;
  /**
   * @example
   * follow_origin
   */
  edgeCacheMode?: string;
  /**
   * @example
   * 300
   */
  edgeCacheTtl?: string;
  /**
   * @example
   * 300
   */
  edgeStatusCodeCacheTtl?: string;
  /**
   * @example
   * cookie_exapmle
   */
  includeCookie?: string;
  /**
   * @example
   * example
   */
  includeHeader?: string;
  /**
   * @example
   * example
   */
  queryString?: string;
  /**
   * @example
   * reserve_all
   */
  queryStringMode?: string;
  /**
   * @example
   * (http.host eq \\"video.example.com\\")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @example
   * on
   */
  serveStale?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 340035003106221
   */
  siteId?: number;
  /**
   * @example
   * 1
   */
  siteVersion?: number;
  /**
   * @example
   * on
   */
  sortQueryStringForCache?: string;
  /**
   * @example
   * on
   */
  userDeviceType?: string;
  /**
   * @example
   * on
   */
  userGeo?: string;
  /**
   * @example
   * on
   */
  userLanguage?: string;
  static names(): { [key: string]: string } {
    return {
      additionalCacheablePorts: 'AdditionalCacheablePorts',
      browserCacheMode: 'BrowserCacheMode',
      browserCacheTtl: 'BrowserCacheTtl',
      bypassCache: 'BypassCache',
      cacheDeceptionArmor: 'CacheDeceptionArmor',
      cacheReserveEligibility: 'CacheReserveEligibility',
      checkPresenceCookie: 'CheckPresenceCookie',
      checkPresenceHeader: 'CheckPresenceHeader',
      edgeCacheMode: 'EdgeCacheMode',
      edgeCacheTtl: 'EdgeCacheTtl',
      edgeStatusCodeCacheTtl: 'EdgeStatusCodeCacheTtl',
      includeCookie: 'IncludeCookie',
      includeHeader: 'IncludeHeader',
      queryString: 'QueryString',
      queryStringMode: 'QueryStringMode',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      serveStale: 'ServeStale',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
      sortQueryStringForCache: 'SortQueryStringForCache',
      userDeviceType: 'UserDeviceType',
      userGeo: 'UserGeo',
      userLanguage: 'UserLanguage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      additionalCacheablePorts: 'string',
      browserCacheMode: 'string',
      browserCacheTtl: 'string',
      bypassCache: 'string',
      cacheDeceptionArmor: 'string',
      cacheReserveEligibility: 'string',
      checkPresenceCookie: 'string',
      checkPresenceHeader: 'string',
      edgeCacheMode: 'string',
      edgeCacheTtl: 'string',
      edgeStatusCodeCacheTtl: 'string',
      includeCookie: 'string',
      includeHeader: 'string',
      queryString: 'string',
      queryStringMode: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      serveStale: 'string',
      siteId: 'number',
      siteVersion: 'number',
      sortQueryStringForCache: 'string',
      userDeviceType: 'string',
      userGeo: 'string',
      userLanguage: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCacheRuleResponseBody extends $dara.Model {
  /**
   * @example
   * 352816096987136
   */
  configId?: number;
  /**
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCacheRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateCacheRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateCacheRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClientCertificateRequest extends $dara.Model {
  /**
   * @example
   * -----BEGIN CERTIFICATE REQUEST-----
   */
  CSR?: string;
  /**
   * @example
   * RSA
   */
  pkeyType?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 365
   */
  validityDays?: number;
  static names(): { [key: string]: string } {
    return {
      CSR: 'CSR',
      pkeyType: 'PkeyType',
      siteId: 'SiteId',
      validityDays: 'ValidityDays',
    };
  }

  static types(): { [key: string]: any } {
    return {
      CSR: 'string',
      pkeyType: 'string',
      siteId: 'number',
      validityDays: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClientCertificateResponseBody extends $dara.Model {
  /**
   * @example
   * babaded901474b9693acf530e0fb1dbb
   */
  CACertificateId?: string;
  /**
   * @example
   * -----BEGIN CERTIFICATE-----
   */
  certificate?: string;
  /**
   * @example
   * www.example.com
   */
  commonName?: string;
  /**
   * @example
   * 1dc5fc9af4eead2570c70d94b416130baeb6d4429b51fd3557379588456aca66
   */
  fingerprintSha256?: string;
  /**
   * @example
   * babaded901474b9693acf530e0fb1d95
   */
  id?: string;
  /**
   * @example
   * DCDN CA
   */
  issuer?: string;
  /**
   * @example
   * 2024-12-01T02:12:49Z
   */
  notAfter?: string;
  /**
   * @example
   * 2023-12-01T02:12:49Z
   */
  notBefore?: string;
  /**
   * @example
   * -----BEGIN PRIVATE KEY-----
   */
  privateKey?: string;
  /**
   * @example
   * C370DAF1-C838-4288-A1A0-9A87633D248E
   */
  requestId?: string;
  /**
   * @example
   * babaded901474b9693acf530e0fb1daa
   */
  serialNumber?: string;
  /**
   * @example
   * SHA256-RSA
   */
  signatureAlgorithm?: string;
  /**
   * @example
   * active
   */
  status?: string;
  /**
   * @example
   * 365
   */
  validityDays?: string;
  static names(): { [key: string]: string } {
    return {
      CACertificateId: 'CACertificateId',
      certificate: 'Certificate',
      commonName: 'CommonName',
      fingerprintSha256: 'FingerprintSha256',
      id: 'Id',
      issuer: 'Issuer',
      notAfter: 'NotAfter',
      notBefore: 'NotBefore',
      privateKey: 'PrivateKey',
      requestId: 'RequestId',
      serialNumber: 'SerialNumber',
      signatureAlgorithm: 'SignatureAlgorithm',
      status: 'Status',
      validityDays: 'ValidityDays',
    };
  }

  static types(): { [key: string]: any } {
    return {
      CACertificateId: 'string',
      certificate: 'string',
      commonName: 'string',
      fingerprintSha256: 'string',
      id: 'string',
      issuer: 'string',
      notAfter: 'string',
      notBefore: 'string',
      privateKey: 'string',
      requestId: 'string',
      serialNumber: 'string',
      signatureAlgorithm: 'string',
      status: 'string',
      validityDays: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateClientCertificateResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateClientCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateClientCertificateResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCompressionRuleRequest extends $dara.Model {
  /**
   * @example
   * on
   */
  brotli?: string;
  /**
   * @example
   * on
   */
  gzip?: string;
  /**
   * @example
   * (http.host eq "video.example.com")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1231231221***
   */
  siteId?: number;
  /**
   * @example
   * 0
   */
  siteVersion?: number;
  zstd?: string;
  static names(): { [key: string]: string } {
    return {
      brotli: 'Brotli',
      gzip: 'Gzip',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
      zstd: 'Zstd',
    };
  }

  static types(): { [key: string]: any } {
    return {
      brotli: 'string',
      gzip: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
      siteVersion: 'number',
      zstd: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCompressionRuleResponseBody extends $dara.Model {
  /**
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @example
   * C370DAF1-C838-4288-A1A0-9A87633D248E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCompressionRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateCompressionRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateCompressionRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCustomScenePolicyRequest extends $dara.Model {
  /**
   * @remarks
   * The time when the policy expires.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-11-07T18:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The policy name.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The IDs of the websites that you want to associate with the policy. Separate multiple IDs with commas (,).
   * 
   * @example
   * 7096621098****
   */
  objects?: string;
  /**
   * @remarks
   * The time when the policy takes effect.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-11-07T17:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The name of the policy template. Valid value:
   * 
   * *   **promotion**: major events.
   * 
   * This parameter is required.
   * 
   * @example
   * promotion
   */
  template?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      name: 'Name',
      objects: 'Objects',
      startTime: 'StartTime',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      name: 'string',
      objects: 'string',
      startTime: 'string',
      template: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCustomScenePolicyResponseBody extends $dara.Model {
  /**
   * @remarks
   * The time when the policy expires.
   * 
   * The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2021-11-07T18:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The policy name.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The IDs of websites associated.
   */
  objects?: string[];
  /**
   * @remarks
   * The policy ID.
   * 
   * @example
   * 1
   */
  policyId?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  /**
   * @remarks
   * The time when the policy takes effect.
   * 
   * The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2021-11-07T17:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The name of the policy template.
   * 
   * @example
   * promotion
   */
  template?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      name: 'Name',
      objects: 'Objects',
      policyId: 'PolicyId',
      requestId: 'RequestId',
      startTime: 'StartTime',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      name: 'string',
      objects: { 'type': 'array', 'itemType': 'string' },
      policyId: 'number',
      requestId: 'string',
      startTime: 'string',
      template: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.objects)) {
      $dara.Model.validateArray(this.objects);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCustomScenePolicyResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateCustomScenePolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateCustomScenePolicyResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeContainerAppRequest extends $dara.Model {
  /**
   * @remarks
   * The number of consecutive failed health checks required for an application to be considered as unhealthy. Valid values: 1 to 10. Default value: 5.
   * 
   * @example
   * 3
   */
  healthCheckFailTimes?: number;
  /**
   * @remarks
   * The domain name that is used for health checks. This parameter is empty by default.
   * 
   * @example
   * www.aliyun.com
   */
  healthCheckHost?: string;
  /**
   * @remarks
   * The HTTP status code returned for a successful health check. Valid values:
   * 
   * *   **http_2xx** (default)
   * *   **http_3xx**
   * 
   * @example
   * http_2xx
   */
  healthCheckHttpCode?: string;
  /**
   * @remarks
   * The interval between two consecutive health checks. Unit: seconds. Valid values: **1** to **50**. Default value: **5**.
   * 
   * @example
   * 5
   */
  healthCheckInterval?: number;
  /**
   * @remarks
   * The HTTP request method for health checks. Valid values:
   * 
   * *   **HEAD** (default): requests the headers of the resource.
   * *   **GET**: requests the specified resource and returns both the headers and entity body.
   * 
   * @example
   * HEAD
   */
  healthCheckMethod?: string;
  /**
   * @remarks
   * The port used for health checks. Valid values: 1 to 65535. Default value: 80.
   * 
   * @example
   * 80
   */
  healthCheckPort?: number;
  /**
   * @remarks
   * The number of consecutive successful health checks required for an application to be considered as healthy. Valid values: 1 to 10. Default value: 2.
   * 
   * @example
   * 2
   */
  healthCheckSuccTimes?: number;
  /**
   * @remarks
   * The timeout period of a health check response. If a backend ECS instance does not respond within the specified timeout period, the ECS instance fails the health check. Unit: seconds.\\
   * Valid values: **1** to **100**.\\
   * Default value: **3**.
   * 
   * @example
   * 5
   */
  healthCheckTimeout?: number;
  /**
   * @remarks
   * The health check type. By default, this parameter is left empty.
   * 
   * Valid values:
   * 
   * *   **l4**: Layer 4 health check.
   * *   **l7**: Layer 7 health check.
   * 
   * @example
   * l7
   */
  healthCheckType?: string;
  /**
   * @remarks
   * The URI used for health checks. The URI must be **1** to **80** characters in length. Default value: "/".
   * 
   * @example
   * /health_check
   */
  healthCheckURI?: string;
  /**
   * @remarks
   * The name of the application. The name must start with a lowercase letter and can contain lowercase letters, digits, and hyphens (-). The name must be 6 to 128 characters in length.
   * 
   * This parameter is required.
   * 
   * @example
   * app-test
   */
  name?: string;
  /**
   * @remarks
   * The remarks. This parameter is empty by default.
   * 
   * @example
   * test app
   */
  remarks?: string;
  /**
   * @remarks
   * The server port. Valid values: 1 to 65535.
   * 
   * This parameter is required.
   * 
   * @example
   * 80
   */
  servicePort?: number;
  /**
   * @remarks
   * The backend port, which is also the service port of the application. Valid values: 1 to 65535.
   * 
   * This parameter is required.
   * 
   * @example
   * 80
   */
  targetPort?: number;
  static names(): { [key: string]: string } {
    return {
      healthCheckFailTimes: 'HealthCheckFailTimes',
      healthCheckHost: 'HealthCheckHost',
      healthCheckHttpCode: 'HealthCheckHttpCode',
      healthCheckInterval: 'HealthCheckInterval',
      healthCheckMethod: 'HealthCheckMethod',
      healthCheckPort: 'HealthCheckPort',
      healthCheckSuccTimes: 'HealthCheckSuccTimes',
      healthCheckTimeout: 'HealthCheckTimeout',
      healthCheckType: 'HealthCheckType',
      healthCheckURI: 'HealthCheckURI',
      name: 'Name',
      remarks: 'Remarks',
      servicePort: 'ServicePort',
      targetPort: 'TargetPort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      healthCheckFailTimes: 'number',
      healthCheckHost: 'string',
      healthCheckHttpCode: 'string',
      healthCheckInterval: 'number',
      healthCheckMethod: 'string',
      healthCheckPort: 'number',
      healthCheckSuccTimes: 'number',
      healthCheckTimeout: 'number',
      healthCheckType: 'string',
      healthCheckURI: 'string',
      name: 'string',
      remarks: 'string',
      servicePort: 'number',
      targetPort: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeContainerAppResponseBody extends $dara.Model {
  /**
   * @remarks
   * The ID of the application that is created.
   * 
   * @example
   * app-880688675783794688
   */
  appId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeContainerAppResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateEdgeContainerAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateEdgeContainerAppResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeContainerAppRecordRequest extends $dara.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * This parameter is required.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The associated domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * a.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 5407498413****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      recordName: 'RecordName',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      recordName: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeContainerAppRecordResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeContainerAppRecordResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateEdgeContainerAppRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateEdgeContainerAppRecordResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeContainerAppVersionRequest extends $dara.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The container group to be deployed for this version, which contains information about images.\\
   * The image data contains the image address, startup command, parameters, environment variables, and probe rules. You can specify one or more images. The parameter value is a JSON string.
   * 
   * This parameter is required.
   * 
   * @example
   * [
   *       {
   *             "Name": "container1",
   *             "Image": "image1",
   *             "Spec": "1C2G",
   *             "Command": "/bin/sh",
   *             "Args": "-c hello",
   *             "ProbeType": "tcpSocket",
   *             "ProbeContent": "{\\"Port\\":8080}"
   *       },
   *       {
   *             "Name": "container2",
   *             "Image": "image2",
   *             "Spec": "2C4G",
   *             "ProbeType": "httpGet",
   *             "ProbeContent": "{\\"Path\\":\\"/\\",\\"Port\\":80,\\"InitialDelaySeconds\\":10}"
   *       }
   * ]
   */
  containers?: CreateEdgeContainerAppVersionRequestContainers[];
  /**
   * @remarks
   * The version name, which must be 6 to 128 characters in length.
   * 
   * This parameter is required.
   * 
   * @example
   * verson1
   */
  name?: string;
  /**
   * @remarks
   * The description of the version.
   * 
   * @example
   * test app
   */
  remarks?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      containers: 'Containers',
      name: 'Name',
      remarks: 'Remarks',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      containers: { 'type': 'array', 'itemType': CreateEdgeContainerAppVersionRequestContainers },
      name: 'string',
      remarks: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.containers)) {
      $dara.Model.validateArray(this.containers);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeContainerAppVersionShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The container group to be deployed for this version, which contains information about images.\\
   * The image data contains the image address, startup command, parameters, environment variables, and probe rules. You can specify one or more images. The parameter value is a JSON string.
   * 
   * This parameter is required.
   * 
   * @example
   * [
   *       {
   *             "Name": "container1",
   *             "Image": "image1",
   *             "Spec": "1C2G",
   *             "Command": "/bin/sh",
   *             "Args": "-c hello",
   *             "ProbeType": "tcpSocket",
   *             "ProbeContent": "{\\"Port\\":8080}"
   *       },
   *       {
   *             "Name": "container2",
   *             "Image": "image2",
   *             "Spec": "2C4G",
   *             "ProbeType": "httpGet",
   *             "ProbeContent": "{\\"Path\\":\\"/\\",\\"Port\\":80,\\"InitialDelaySeconds\\":10}"
   *       }
   * ]
   */
  containersShrink?: string;
  /**
   * @remarks
   * The version name, which must be 6 to 128 characters in length.
   * 
   * This parameter is required.
   * 
   * @example
   * verson1
   */
  name?: string;
  /**
   * @remarks
   * The description of the version.
   * 
   * @example
   * test app
   */
  remarks?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      containersShrink: 'Containers',
      name: 'Name',
      remarks: 'Remarks',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      containersShrink: 'string',
      name: 'string',
      remarks: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeContainerAppVersionResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the created version.
   * 
   * @example
   * ver-87962637161651****
   */
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      versionId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEdgeContainerAppVersionResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateEdgeContainerAppVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateEdgeContainerAppVersionResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHttpRequestHeaderModificationRuleRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  requestHeaderModification?: CreateHttpRequestHeaderModificationRuleRequestRequestHeaderModification[];
  /**
   * @example
   * (http.host eq "video.example.com")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5407498413****
   */
  siteId?: number;
  /**
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      requestHeaderModification: 'RequestHeaderModification',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestHeaderModification: { 'type': 'array', 'itemType': CreateHttpRequestHeaderModificationRuleRequestRequestHeaderModification },
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.requestHeaderModification)) {
      $dara.Model.validateArray(this.requestHeaderModification);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHttpRequestHeaderModificationRuleShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  requestHeaderModificationShrink?: string;
  /**
   * @example
   * (http.host eq "video.example.com")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5407498413****
   */
  siteId?: number;
  /**
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      requestHeaderModificationShrink: 'RequestHeaderModification',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestHeaderModificationShrink: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHttpRequestHeaderModificationRuleResponseBody extends $dara.Model {
  /**
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @example
   * CB1A380B-09F0-41BB-280B-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHttpRequestHeaderModificationRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateHttpRequestHeaderModificationRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateHttpRequestHeaderModificationRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHttpResponseHeaderModificationRuleRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  responseHeaderModification?: CreateHttpResponseHeaderModificationRuleRequestResponseHeaderModification[];
  /**
   * @example
   * (http.host eq "video.example.com")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456******
   */
  siteId?: number;
  /**
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      responseHeaderModification: 'ResponseHeaderModification',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      responseHeaderModification: { 'type': 'array', 'itemType': CreateHttpResponseHeaderModificationRuleRequestResponseHeaderModification },
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.responseHeaderModification)) {
      $dara.Model.validateArray(this.responseHeaderModification);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHttpResponseHeaderModificationRuleShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  responseHeaderModificationShrink?: string;
  /**
   * @example
   * (http.host eq "video.example.com")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456******
   */
  siteId?: number;
  /**
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      responseHeaderModificationShrink: 'ResponseHeaderModification',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      responseHeaderModificationShrink: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHttpResponseHeaderModificationRuleResponseBody extends $dara.Model {
  /**
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHttpResponseHeaderModificationRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateHttpResponseHeaderModificationRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateHttpResponseHeaderModificationRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHttpsApplicationConfigurationRequest extends $dara.Model {
  /**
   * @example
   * on
   */
  altSvc?: string;
  /**
   * @example
   * on
   */
  altSvcClear?: string;
  /**
   * @example
   * 86400
   */
  altSvcMa?: string;
  /**
   * @example
   * on
   */
  altSvcPersist?: string;
  /**
   * @example
   * on
   */
  hsts?: string;
  /**
   * @example
   * on
   */
  hstsIncludeSubdomains?: string;
  /**
   * @example
   * 3600
   */
  hstsMaxAge?: string;
  /**
   * @example
   * on
   */
  hstsPreload?: string;
  /**
   * @example
   * on
   */
  httpsForce?: string;
  /**
   * @example
   * 301
   */
  httpsForceCode?: string;
  /**
   * @example
   * (http.host eq \\"video.example.com\\")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @example
   * 1
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      altSvc: 'AltSvc',
      altSvcClear: 'AltSvcClear',
      altSvcMa: 'AltSvcMa',
      altSvcPersist: 'AltSvcPersist',
      hsts: 'Hsts',
      hstsIncludeSubdomains: 'HstsIncludeSubdomains',
      hstsMaxAge: 'HstsMaxAge',
      hstsPreload: 'HstsPreload',
      httpsForce: 'HttpsForce',
      httpsForceCode: 'HttpsForceCode',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      altSvc: 'string',
      altSvcClear: 'string',
      altSvcMa: 'string',
      altSvcPersist: 'string',
      hsts: 'string',
      hstsIncludeSubdomains: 'string',
      hstsMaxAge: 'string',
      hstsPreload: 'string',
      httpsForce: 'string',
      httpsForceCode: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHttpsApplicationConfigurationResponseBody extends $dara.Model {
  /**
   * @example
   * 352816096987136
   */
  configId?: number;
  /**
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHttpsApplicationConfigurationResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateHttpsApplicationConfigurationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateHttpsApplicationConfigurationResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHttpsBasicConfigurationRequest extends $dara.Model {
  /**
   * @example
   * TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
   */
  ciphersuite?: string;
  /**
   * @example
   * all
   */
  ciphersuiteGroup?: string;
  /**
   * @example
   * on
   */
  http2?: string;
  /**
   * @example
   * on
   */
  http3?: string;
  /**
   * @example
   * on
   */
  https?: string;
  /**
   * @example
   * on
   */
  ocspStapling?: string;
  /**
   * @example
   * (http.host eq \\"video.example.com\\")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5407498413****
   */
  siteId?: number;
  /**
   * @example
   * on
   */
  tls10?: string;
  /**
   * @example
   * on
   */
  tls11?: string;
  /**
   * @example
   * on
   */
  tls12?: string;
  /**
   * @example
   * on
   */
  tls13?: string;
  static names(): { [key: string]: string } {
    return {
      ciphersuite: 'Ciphersuite',
      ciphersuiteGroup: 'CiphersuiteGroup',
      http2: 'Http2',
      http3: 'Http3',
      https: 'Https',
      ocspStapling: 'OcspStapling',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      tls10: 'Tls10',
      tls11: 'Tls11',
      tls12: 'Tls12',
      tls13: 'Tls13',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ciphersuite: 'string',
      ciphersuiteGroup: 'string',
      http2: 'string',
      http3: 'string',
      https: 'string',
      ocspStapling: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
      tls10: 'string',
      tls11: 'string',
      tls12: 'string',
      tls13: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHttpsBasicConfigurationResponseBody extends $dara.Model {
  /**
   * @example
   * 352816096987136
   */
  configId?: number;
  /**
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHttpsBasicConfigurationResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateHttpsBasicConfigurationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateHttpsBasicConfigurationResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateImageTransformRequest extends $dara.Model {
  /**
   * @example
   * on
   */
  enable?: string;
  /**
   * @example
   * (http.request.uri.path.file_name eq \\"jpg\\")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * test
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateImageTransformResponseBody extends $dara.Model {
  /**
   * @example
   * 352816096987136
   */
  configId?: number;
  /**
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateImageTransformResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateImageTransformResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateImageTransformResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateKvNamespaceRequest extends $dara.Model {
  /**
   * @remarks
   * The description of the namespace.
   * 
   * @example
   * this is a test namespace.
   */
  description?: string;
  /**
   * @remarks
   * The name of the namespace.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      namespace: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateKvNamespaceResponseBody extends $dara.Model {
  /**
   * @remarks
   * The description of the namespace.
   * 
   * @example
   * this is a test namespace.
   */
  description?: string;
  /**
   * @remarks
   * The name of the namespace.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * 657717877171818496
   */
  namespaceId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * The status of the namespace. Valid values:
   * 
   * *   **online**: working as expected.
   * *   **delete**: pending deletion.
   * *   **deleting**: being deleted.
   * *   **deleted**: deleted.
   * 
   * @example
   * online
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      namespace: 'Namespace',
      namespaceId: 'NamespaceId',
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      namespace: 'string',
      namespaceId: 'string',
      requestId: 'string',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateKvNamespaceResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateKvNamespaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateKvNamespaceResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateListRequest extends $dara.Model {
  /**
   * @remarks
   * The description of the list that you want to create.
   * 
   * @example
   * a custom list
   */
  description?: string;
  /**
   * @remarks
   * The items in the list that you want to create.
   * 
   * @example
   * a custom list
   */
  items?: string[];
  /**
   * @remarks
   * The type of the list that you want to create.
   * 
   * @example
   * ip
   */
  kind?: string;
  /**
   * @remarks
   * The name of the list that you want to create.
   * 
   * This parameter is required.
   * 
   * @example
   * example
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      items: 'Items',
      kind: 'Kind',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      items: { 'type': 'array', 'itemType': 'string' },
      kind: 'string',
      name: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.items)) {
      $dara.Model.validateArray(this.items);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateListShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The description of the list that you want to create.
   * 
   * @example
   * a custom list
   */
  description?: string;
  /**
   * @remarks
   * The items in the list that you want to create.
   * 
   * @example
   * a custom list
   */
  itemsShrink?: string;
  /**
   * @remarks
   * The type of the list that you want to create.
   * 
   * @example
   * ip
   */
  kind?: string;
  /**
   * @remarks
   * The name of the list that you want to create.
   * 
   * This parameter is required.
   * 
   * @example
   * example
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      itemsShrink: 'Items',
      kind: 'Kind',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      itemsShrink: 'string',
      kind: 'string',
      name: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateListResponseBody extends $dara.Model {
  /**
   * @remarks
   * The ID of the custom list.[](~~2850217~~)
   * 
   * @example
   * 40000001
   */
  id?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateListResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateListResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLoadBalancerRequest extends $dara.Model {
  /**
   * @example
   * true
   */
  adaptiveRouting?: CreateLoadBalancerRequestAdaptiveRouting;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * {"AL,MO": [92298024898****],"CN-SH,CN-SX,CN-SC":[92304347804****,92843536908****]}
   */
  defaultPools?: number[];
  description?: string;
  enabled?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123
   */
  fallbackPool?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * order
   */
  monitor?: CreateLoadBalancerRequestMonitor;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * lb.example.com
   */
  name?: string;
  /**
   * @example
   * 123
   */
  randomSteering?: CreateLoadBalancerRequestRandomSteering;
  regionPools?: any;
  /**
   * @example
   * {
   *   "ENAM": [
   *     12345678****
   *   ],
   *   "WNAM": [
   *     23456789****,
   *     23456789****
   *   ]
   * }
   */
  rules?: CreateLoadBalancerRequestRules[];
  sessionAffinity?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  siteId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ip
   */
  steeringPolicy?: string;
  subRegionPools?: any;
  ttl?: number;
  static names(): { [key: string]: string } {
    return {
      adaptiveRouting: 'AdaptiveRouting',
      defaultPools: 'DefaultPools',
      description: 'Description',
      enabled: 'Enabled',
      fallbackPool: 'FallbackPool',
      monitor: 'Monitor',
      name: 'Name',
      randomSteering: 'RandomSteering',
      regionPools: 'RegionPools',
      rules: 'Rules',
      sessionAffinity: 'SessionAffinity',
      siteId: 'SiteId',
      steeringPolicy: 'SteeringPolicy',
      subRegionPools: 'SubRegionPools',
      ttl: 'Ttl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adaptiveRouting: CreateLoadBalancerRequestAdaptiveRouting,
      defaultPools: { 'type': 'array', 'itemType': 'number' },
      description: 'string',
      enabled: 'boolean',
      fallbackPool: 'number',
      monitor: CreateLoadBalancerRequestMonitor,
      name: 'string',
      randomSteering: CreateLoadBalancerRequestRandomSteering,
      regionPools: 'any',
      rules: { 'type': 'array', 'itemType': CreateLoadBalancerRequestRules },
      sessionAffinity: 'string',
      siteId: 'number',
      steeringPolicy: 'string',
      subRegionPools: 'any',
      ttl: 'number',
    };
  }

  validate() {
    if(this.adaptiveRouting && typeof (this.adaptiveRouting as any).validate === 'function') {
      (this.adaptiveRouting as any).validate();
    }
    if(Array.isArray(this.defaultPools)) {
      $dara.Model.validateArray(this.defaultPools);
    }
    if(this.monitor && typeof (this.monitor as any).validate === 'function') {
      (this.monitor as any).validate();
    }
    if(this.randomSteering && typeof (this.randomSteering as any).validate === 'function') {
      (this.randomSteering as any).validate();
    }
    if(Array.isArray(this.rules)) {
      $dara.Model.validateArray(this.rules);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLoadBalancerShrinkRequest extends $dara.Model {
  /**
   * @example
   * true
   */
  adaptiveRoutingShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * {"AL,MO": [92298024898****],"CN-SH,CN-SX,CN-SC":[92304347804****,92843536908****]}
   */
  defaultPoolsShrink?: string;
  description?: string;
  enabled?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123
   */
  fallbackPool?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * order
   */
  monitorShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * lb.example.com
   */
  name?: string;
  /**
   * @example
   * 123
   */
  randomSteeringShrink?: string;
  regionPools?: any;
  /**
   * @example
   * {
   *   "ENAM": [
   *     12345678****
   *   ],
   *   "WNAM": [
   *     23456789****,
   *     23456789****
   *   ]
   * }
   */
  rulesShrink?: string;
  sessionAffinity?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  siteId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ip
   */
  steeringPolicy?: string;
  subRegionPools?: any;
  ttl?: number;
  static names(): { [key: string]: string } {
    return {
      adaptiveRoutingShrink: 'AdaptiveRouting',
      defaultPoolsShrink: 'DefaultPools',
      description: 'Description',
      enabled: 'Enabled',
      fallbackPool: 'FallbackPool',
      monitorShrink: 'Monitor',
      name: 'Name',
      randomSteeringShrink: 'RandomSteering',
      regionPools: 'RegionPools',
      rulesShrink: 'Rules',
      sessionAffinity: 'SessionAffinity',
      siteId: 'SiteId',
      steeringPolicy: 'SteeringPolicy',
      subRegionPools: 'SubRegionPools',
      ttl: 'Ttl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adaptiveRoutingShrink: 'string',
      defaultPoolsShrink: 'string',
      description: 'string',
      enabled: 'boolean',
      fallbackPool: 'number',
      monitorShrink: 'string',
      name: 'string',
      randomSteeringShrink: 'string',
      regionPools: 'any',
      rulesShrink: 'string',
      sessionAffinity: 'string',
      siteId: 'number',
      steeringPolicy: 'string',
      subRegionPools: 'any',
      ttl: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLoadBalancerResponseBody extends $dara.Model {
  /**
   * @example
   * 99867648760****
   */
  id?: number;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateLoadBalancerResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateLoadBalancerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateLoadBalancerResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNetworkOptimizationRequest extends $dara.Model {
  /**
   * @example
   * on
   */
  grpc?: string;
  /**
   * @example
   * on
   */
  http2Origin?: string;
  /**
   * @example
   * (http.host eq \\"video.example.com\\")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 340035003106221
   */
  siteId?: number;
  /**
   * @example
   * 1
   */
  siteVersion?: number;
  /**
   * @example
   * on
   */
  smartRouting?: string;
  /**
   * @example
   * 100
   */
  uploadMaxFilesize?: string;
  /**
   * @example
   * on
   */
  websocket?: string;
  static names(): { [key: string]: string } {
    return {
      grpc: 'Grpc',
      http2Origin: 'Http2Origin',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
      smartRouting: 'SmartRouting',
      uploadMaxFilesize: 'UploadMaxFilesize',
      websocket: 'Websocket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      grpc: 'string',
      http2Origin: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
      siteVersion: 'number',
      smartRouting: 'string',
      uploadMaxFilesize: 'string',
      websocket: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNetworkOptimizationResponseBody extends $dara.Model {
  /**
   * @example
   * 352816096987136
   */
  configId?: number;
  /**
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateNetworkOptimizationResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateNetworkOptimizationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateNetworkOptimizationResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOriginPoolRequest extends $dara.Model {
  enabled?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * CreateOriginPool
   */
  name?: string;
  origins?: CreateOriginPoolRequestOrigins[];
  /**
   * @remarks
   * This parameter is required.
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      enabled: 'Enabled',
      name: 'Name',
      origins: 'Origins',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      name: 'string',
      origins: { 'type': 'array', 'itemType': CreateOriginPoolRequestOrigins },
      siteId: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.origins)) {
      $dara.Model.validateArray(this.origins);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOriginPoolShrinkRequest extends $dara.Model {
  enabled?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * CreateOriginPool
   */
  name?: string;
  originsShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      enabled: 'Enabled',
      name: 'Name',
      originsShrink: 'Origins',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      name: 'string',
      originsShrink: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOriginPoolResponseBody extends $dara.Model {
  id?: number;
  /**
   * @remarks
   * Id of the request
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOriginPoolResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateOriginPoolResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOriginPoolResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOriginProtectionRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOriginProtectionResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CB1A380B-09F0-41BB-A198-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOriginProtectionResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateOriginProtectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOriginProtectionResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOriginRuleRequest extends $dara.Model {
  /**
   * @example
   * test.example.com
   */
  dnsRecord?: string;
  /**
   * @example
   * origin.example.com
   */
  originHost?: string;
  /**
   * @example
   * 8080
   */
  originHttpPort?: string;
  /**
   * @example
   * 4433
   */
  originHttpsPort?: string;
  /**
   * @example
   * http
   */
  originScheme?: string;
  /**
   * @example
   * origin.example.com
   */
  originSni?: string;
  /**
   * @example
   * on
   */
  range?: string;
  /**
   * @example
   * (http.host eq \\"video.example.com\\")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 340035003106221
   */
  siteId?: number;
  /**
   * @example
   * 1
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      dnsRecord: 'DnsRecord',
      originHost: 'OriginHost',
      originHttpPort: 'OriginHttpPort',
      originHttpsPort: 'OriginHttpsPort',
      originScheme: 'OriginScheme',
      originSni: 'OriginSni',
      range: 'Range',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dnsRecord: 'string',
      originHost: 'string',
      originHttpPort: 'string',
      originHttpsPort: 'string',
      originScheme: 'string',
      originSni: 'string',
      range: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOriginRuleResponseBody extends $dara.Model {
  /**
   * @example
   * 352816096987136
   */
  configId?: number;
  /**
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOriginRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateOriginRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOriginRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePageRequest extends $dara.Model {
  /**
   * @remarks
   * The Base64-encoded page content. Example: "PGh0bWw+aGVsbG8gcGFnZTwvaHRtbD4=", which indicates "hello page".
   * 
   * @example
   * PGh0bWw+aGVsbG8gcGFnZTwvaHRtbD4=
   */
  content?: string;
  /**
   * @remarks
   * The Content-Type field in the HTTP header. Valid values:
   * 
   * *   text/html
   * *   application/json
   * 
   * This parameter is required.
   * 
   * @example
   * text/html
   */
  contentType?: string;
  /**
   * @remarks
   * The description of the page.
   * 
   * @example
   * a custom deny page
   */
  description?: string;
  /**
   * @remarks
   * The name of the custom error page.
   * 
   * This parameter is required.
   * 
   * @example
   * example
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      contentType: 'ContentType',
      description: 'Description',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      contentType: 'string',
      description: 'string',
      name: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePageResponseBody extends $dara.Model {
  /**
   * @remarks
   * The ID of the custom error page.[](~~2850223~~)
   * 
   * @example
   * 50000001
   */
  id?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePageResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreatePageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreatePageResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRecordRequest extends $dara.Model {
  /**
   * @remarks
   * The origin authentication information of the CNAME record.
   */
  authConf?: CreateRecordRequestAuthConf;
  /**
   * @remarks
   * The business scenario of the record for acceleration. Leave the parameter empty if your record is not proxied. Valid values:
   * 
   * *   **image_video**: video and image.
   * *   **api**: API.
   * *   **web**: web page.
   * 
   * @example
   * web
   */
  bizName?: string;
  /**
   * @remarks
   * The comment of the record. The maximum length is 100 characters.
   * 
   * @example
   * This is a remark.
   */
  comment?: string;
  /**
   * @remarks
   * The DNS record information. The format of this field varies based on the record type. For more information, see [References](https://www.alibabacloud.com/help/doc-detail/2708761.html) .
   * 
   * This parameter is required.
   * 
   * @example
   * {
   *     "value":"2.2.2.2"
   * }
   */
  data?: CreateRecordRequestData;
  /**
   * @remarks
   * The origin host policy. This policy takes effect when the record type is CNAME. You can set the policy in two modes:
   * 
   * *   **follow_hostname**: Follow the host record.
   * *   **follow_origin_domain**: match the origin\\"s domain name.
   * 
   * @example
   * follow_origin_domain
   */
  hostPolicy?: string;
  /**
   * @remarks
   * Specifies whether to proxy the record. Only CNAME and A/AAAA records can be proxied. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  proxied?: boolean;
  /**
   * @remarks
   * The record name.
   * 
   * This parameter is required.
   * 
   * @example
   * www.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The origin type for the CNAME record. This parameter is required when you add a CNAME record. Valid values:
   * 
   * *   **OSS**: OSS bucket.
   * *   **S3**: S3 bucket.
   * *   **LB**: load balancer.
   * *   **OP**: origin pool.
   * *   **Domain**: domain name.
   * 
   * If you do not pass this parameter or if you leave its value empty, Domain is used by default.
   * 
   * @example
   * OSS
   */
  sourceType?: string;
  /**
   * @remarks
   * The TTL of the record. Unit: seconds. If the value is 1, the TTL of the record is determined by the system.
   * 
   * @example
   * 30
   */
  ttl?: number;
  /**
   * @remarks
   * The type of the DNS record. For example, A/AAAA, TXT, MX, or CNAME.
   * 
   * This parameter is required.
   * 
   * @example
   * A/AAAA
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      authConf: 'AuthConf',
      bizName: 'BizName',
      comment: 'Comment',
      data: 'Data',
      hostPolicy: 'HostPolicy',
      proxied: 'Proxied',
      recordName: 'RecordName',
      siteId: 'SiteId',
      sourceType: 'SourceType',
      ttl: 'Ttl',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authConf: CreateRecordRequestAuthConf,
      bizName: 'string',
      comment: 'string',
      data: CreateRecordRequestData,
      hostPolicy: 'string',
      proxied: 'boolean',
      recordName: 'string',
      siteId: 'number',
      sourceType: 'string',
      ttl: 'number',
      type: 'string',
    };
  }

  validate() {
    if(this.authConf && typeof (this.authConf as any).validate === 'function') {
      (this.authConf as any).validate();
    }
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRecordShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The origin authentication information of the CNAME record.
   */
  authConfShrink?: string;
  /**
   * @remarks
   * The business scenario of the record for acceleration. Leave the parameter empty if your record is not proxied. Valid values:
   * 
   * *   **image_video**: video and image.
   * *   **api**: API.
   * *   **web**: web page.
   * 
   * @example
   * web
   */
  bizName?: string;
  /**
   * @remarks
   * The comment of the record. The maximum length is 100 characters.
   * 
   * @example
   * This is a remark.
   */
  comment?: string;
  /**
   * @remarks
   * The DNS record information. The format of this field varies based on the record type. For more information, see [References](https://www.alibabacloud.com/help/doc-detail/2708761.html) .
   * 
   * This parameter is required.
   * 
   * @example
   * {
   *     "value":"2.2.2.2"
   * }
   */
  dataShrink?: string;
  /**
   * @remarks
   * The origin host policy. This policy takes effect when the record type is CNAME. You can set the policy in two modes:
   * 
   * *   **follow_hostname**: Follow the host record.
   * *   **follow_origin_domain**: match the origin\\"s domain name.
   * 
   * @example
   * follow_origin_domain
   */
  hostPolicy?: string;
  /**
   * @remarks
   * Specifies whether to proxy the record. Only CNAME and A/AAAA records can be proxied. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  proxied?: boolean;
  /**
   * @remarks
   * The record name.
   * 
   * This parameter is required.
   * 
   * @example
   * www.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The origin type for the CNAME record. This parameter is required when you add a CNAME record. Valid values:
   * 
   * *   **OSS**: OSS bucket.
   * *   **S3**: S3 bucket.
   * *   **LB**: load balancer.
   * *   **OP**: origin pool.
   * *   **Domain**: domain name.
   * 
   * If you do not pass this parameter or if you leave its value empty, Domain is used by default.
   * 
   * @example
   * OSS
   */
  sourceType?: string;
  /**
   * @remarks
   * The TTL of the record. Unit: seconds. If the value is 1, the TTL of the record is determined by the system.
   * 
   * @example
   * 30
   */
  ttl?: number;
  /**
   * @remarks
   * The type of the DNS record. For example, A/AAAA, TXT, MX, or CNAME.
   * 
   * This parameter is required.
   * 
   * @example
   * A/AAAA
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      authConfShrink: 'AuthConf',
      bizName: 'BizName',
      comment: 'Comment',
      dataShrink: 'Data',
      hostPolicy: 'HostPolicy',
      proxied: 'Proxied',
      recordName: 'RecordName',
      siteId: 'SiteId',
      sourceType: 'SourceType',
      ttl: 'Ttl',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authConfShrink: 'string',
      bizName: 'string',
      comment: 'string',
      dataShrink: 'string',
      hostPolicy: 'string',
      proxied: 'boolean',
      recordName: 'string',
      siteId: 'number',
      sourceType: 'string',
      ttl: 'number',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRecordResponseBody extends $dara.Model {
  /**
   * @remarks
   * The record ID.
   * 
   * @example
   * 1234567890123
   */
  recordId?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F61CDR30-E83C-4FDA-BF73-9A94CDD44229
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      recordId: 'RecordId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordId: 'number',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRecordResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateRecordResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRedirectRuleRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * on
   */
  reserveQueryString?: string;
  /**
   * @example
   * (http.host eq "video.example.com")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @example
   * 0
   */
  siteVersion?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 301
   */
  statusCode?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * http://www.exapmle.com/index.html
   */
  targetUrl?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * static
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      reserveQueryString: 'ReserveQueryString',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
      statusCode: 'StatusCode',
      targetUrl: 'TargetUrl',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      reserveQueryString: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
      siteVersion: 'number',
      statusCode: 'string',
      targetUrl: 'string',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRedirectRuleResponseBody extends $dara.Model {
  /**
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @example
   * 1FCB0DA6-9B6D-509D-B91C-B9B9F0780D0E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRedirectRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateRedirectRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateRedirectRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRewriteUrlRuleRequest extends $dara.Model {
  /**
   * @example
   * example=123
   */
  queryString?: string;
  /**
   * @example
   * static
   * 
   * **if can be null:**
   * false
   */
  rewriteQueryStringType?: string;
  /**
   * @example
   * static
   * 
   * **if can be null:**
   * false
   */
  rewriteUriType?: string;
  /**
   * @example
   * (http.host eq "video.example.com")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @example
   * 0
   */
  siteVersion?: number;
  /**
   * @example
   * /image/example.jpg
   */
  uri?: string;
  static names(): { [key: string]: string } {
    return {
      queryString: 'QueryString',
      rewriteQueryStringType: 'RewriteQueryStringType',
      rewriteUriType: 'RewriteUriType',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
      uri: 'Uri',
    };
  }

  static types(): { [key: string]: any } {
    return {
      queryString: 'string',
      rewriteQueryStringType: 'string',
      rewriteUriType: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
      siteVersion: 'number',
      uri: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRewriteUrlRuleResponseBody extends $dara.Model {
  /**
   * @example
   * 39237781679****
   */
  configId?: number;
  /**
   * @example
   * CB1A380B-09F0-41BB-280B-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRewriteUrlRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateRewriteUrlRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateRewriteUrlRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRoutineRequest extends $dara.Model {
  /**
   * @remarks
   * The routine description.
   * 
   * @example
   * the description of this routine
   */
  description?: string;
  /**
   * @remarks
   * The routine name, which must be unique in the same account.
   * 
   * This parameter is required.
   * 
   * @example
   * test-routine1
   */
  name?: string;
  /**
   * @remarks
   * The specification of the routine.
   * 
   * This parameter is required.
   * 
   * @example
   * 5ms
   */
  specName?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      specName: 'SpecName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      specName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRoutineResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the operation is successful.
   * 
   * @example
   * OK
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRoutineResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateRoutineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateRoutineResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRoutineRelatedRecordRequest extends $dara.Model {
  /**
   * @remarks
   * The routine name.
   * 
   * This parameter is required.
   * 
   * @example
   * CreateRoutineRelatedRecord
   */
  name?: string;
  /**
   * @remarks
   * The record name.
   * 
   * This parameter is required.
   * 
   * @example
   * test-record-1.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 54362329990032
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      recordName: 'RecordName',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      recordName: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRoutineRelatedRecordResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the operation is successful.
   * 
   * @example
   * OK
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRoutineRelatedRecordResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateRoutineRelatedRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateRoutineRelatedRecordResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRoutineRelatedRouteRequest extends $dara.Model {
  byPass?: string;
  /**
   * @remarks
   * The routine name.
   * 
   * This parameter is required.
   * 
   * @example
   * CreateRoutineRelatedRoute
   */
  name?: string;
  /**
   * @remarks
   * The route.
   * 
   * This parameter is required.
   * 
   * @example
   * *.example.com/path1*
   */
  route?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 54362329990032
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      byPass: 'ByPass',
      name: 'Name',
      route: 'Route',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      byPass: 'string',
      name: 'string',
      route: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRoutineRelatedRouteResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the operation is successful.
   * 
   * @example
   * OK
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRoutineRelatedRouteResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateRoutineRelatedRouteResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateRoutineRelatedRouteResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduledPreloadExecutionsRequest extends $dara.Model {
  /**
   * @remarks
   * The scheduled prefetch plans to create.
   * 
   * This parameter is required.
   */
  executions?: CreateScheduledPreloadExecutionsRequestExecutions[];
  /**
   * @remarks
   * The ID of the prefetch task, which is generated by calling the [CreateScheduledPreloadJob](https://help.aliyun.com/document_detail/2850459.html) operation.
   * 
   * @example
   * CreateScheduledPreloadExecutions
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      executions: 'Executions',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      executions: { 'type': 'array', 'itemType': CreateScheduledPreloadExecutionsRequestExecutions },
      id: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.executions)) {
      $dara.Model.validateArray(this.executions);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduledPreloadExecutionsShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The scheduled prefetch plans to create.
   * 
   * This parameter is required.
   */
  executionsShrink?: string;
  /**
   * @remarks
   * The ID of the prefetch task, which is generated by calling the [CreateScheduledPreloadJob](https://help.aliyun.com/document_detail/2850459.html) operation.
   * 
   * @example
   * CreateScheduledPreloadExecutions
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      executionsShrink: 'Executions',
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      executionsShrink: 'string',
      id: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduledPreloadExecutionsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The information about prefetch plans that failed to be created.
   */
  failedExecutions?: CreateScheduledPreloadExecutionsResponseBodyFailedExecutions[];
  /**
   * @remarks
   * The information about plan failures.
   */
  failedMessages?: string[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F61CDR30-E83C-4FDA-BF73-9A94CDD44229
   */
  requestId?: string;
  /**
   * @remarks
   * The number of prefetch plans that are created.
   * 
   * @example
   * 12
   */
  successCount?: number;
  /**
   * @remarks
   * The information about created prefetch plans.
   */
  successExecutions?: CreateScheduledPreloadExecutionsResponseBodySuccessExecutions[];
  /**
   * @remarks
   * The total number of new plans requested.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      failedExecutions: 'FailedExecutions',
      failedMessages: 'FailedMessages',
      requestId: 'RequestId',
      successCount: 'SuccessCount',
      successExecutions: 'SuccessExecutions',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failedExecutions: { 'type': 'array', 'itemType': CreateScheduledPreloadExecutionsResponseBodyFailedExecutions },
      failedMessages: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
      successCount: 'number',
      successExecutions: { 'type': 'array', 'itemType': CreateScheduledPreloadExecutionsResponseBodySuccessExecutions },
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.failedExecutions)) {
      $dara.Model.validateArray(this.failedExecutions);
    }
    if(Array.isArray(this.failedMessages)) {
      $dara.Model.validateArray(this.failedMessages);
    }
    if(Array.isArray(this.successExecutions)) {
      $dara.Model.validateArray(this.successExecutions);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduledPreloadExecutionsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateScheduledPreloadExecutionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateScheduledPreloadExecutionsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduledPreloadJobRequest extends $dara.Model {
  /**
   * @remarks
   * The method to submit URLs to be prefetched.
   * 
   * Valid values:
   * 
   * *   **textBox**
   * *   **oss**
   * 
   * This parameter is required.
   * 
   * @example
   * oss
   */
  insertWay?: string;
  /**
   * @remarks
   * The name of the scheduled prefetch task.
   * 
   * This parameter is required.
   * 
   * @example
   * example
   */
  name?: string;
  /**
   * @remarks
   * The URL of the OSS object that stores the URLs to be prefetched.
   * 
   * @example
   * https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7
   */
  ossUrl?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 190007158391808
   */
  siteId?: number;
  /**
   * @remarks
   * The URLs to be prefetched. This parameter is required if you set InsertWay to textBox.
   * 
   * @example
   * http://testurl.com/a.txt
   * http://testurl.com/b.txt
   */
  urlList?: string;
  static names(): { [key: string]: string } {
    return {
      insertWay: 'InsertWay',
      name: 'Name',
      ossUrl: 'OssUrl',
      siteId: 'SiteId',
      urlList: 'UrlList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      insertWay: 'string',
      name: 'string',
      ossUrl: 'string',
      siteId: 'number',
      urlList: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduledPreloadJobResponseBody extends $dara.Model {
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 15685865xxx14622
   */
  aliUid?: string;
  /**
   * @remarks
   * The time when the task was created.
   * 
   * @example
   * 2023-06-05T10:04:20+0800
   */
  createdAt?: string;
  /**
   * @remarks
   * The domain names to be prefetched.
   * 
   * @example
   * testurl.com
   */
  domains?: string;
  /**
   * @remarks
   * The error message. Multiple error messages are separated by commas (,). Valid values:
   * 
   * *   **InvalidUrl**: The URL format is invalid.
   * *   **InvalidDomain**: The domain name fails the domain ownership verification.
   * *   **QuotaExcess**: the quota limit has been reached.
   * *   **OtherErrors**: other errors.
   * 
   * @example
   * InvalidDomain
   */
  errorInfo?: string;
  /**
   * @remarks
   * The URL of the OSS object that stores a list of URLs that failed the conditional check for prefetching.
   * 
   * @example
   * https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7
   */
  failedFileOss?: string;
  /**
   * @remarks
   * The ID of the URL list file, which can be used during downloads.
   * 
   * @example
   * 665d3b48621bccf3fe29e1a7
   */
  fileId?: string;
  /**
   * @remarks
   * The ID of the scheduled prefetch task.
   * 
   * @example
   * 665d3af3621bccf3fe29e1a4
   */
  id?: string;
  /**
   * @remarks
   * The method to submit the URLs to be prefetched.
   * 
   * @example
   * oss
   */
  insertWay?: string;
  /**
   * @remarks
   * The task name.
   * 
   * @example
   * example
   */
  name?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247B78
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 190007158391808
   */
  siteId?: number;
  /**
   * @remarks
   * The number of submitted prefetch tasks.
   * 
   * @example
   * 1
   */
  taskSubmitted?: number;
  /**
   * @remarks
   * The task type (refresh or preload).
   * 
   * @example
   * preload
   */
  taskType?: string;
  /**
   * @remarks
   * The total number of URLs.
   * 
   * @example
   * 2
   */
  urlCount?: number;
  /**
   * @remarks
   * The number of submitted URLs.
   * 
   * @example
   * 1
   */
  urlSubmitted?: number;
  static names(): { [key: string]: string } {
    return {
      aliUid: 'AliUid',
      createdAt: 'CreatedAt',
      domains: 'Domains',
      errorInfo: 'ErrorInfo',
      failedFileOss: 'FailedFileOss',
      fileId: 'FileId',
      id: 'Id',
      insertWay: 'InsertWay',
      name: 'Name',
      requestId: 'RequestId',
      siteId: 'SiteId',
      taskSubmitted: 'TaskSubmitted',
      taskType: 'TaskType',
      urlCount: 'UrlCount',
      urlSubmitted: 'UrlSubmitted',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliUid: 'string',
      createdAt: 'string',
      domains: 'string',
      errorInfo: 'string',
      failedFileOss: 'string',
      fileId: 'string',
      id: 'string',
      insertWay: 'string',
      name: 'string',
      requestId: 'string',
      siteId: 'number',
      taskSubmitted: 'number',
      taskType: 'string',
      urlCount: 'number',
      urlSubmitted: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateScheduledPreloadJobResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateScheduledPreloadJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateScheduledPreloadJobResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteRequest extends $dara.Model {
  /**
   * @remarks
   * The DNS setup. Valid values:
   * 
   * *   **NS**
   * *   **CNAME**
   * 
   * This parameter is required.
   * 
   * @example
   * NS
   */
  accessType?: string;
  /**
   * @remarks
   * The service location. Valid values:
   * 
   * *   **domestic**: the Chinese mainland
   * *   **global**: global
   * *   **overseas**: outside the Chinese mainland
   * 
   * This parameter is required.
   * 
   * @example
   * domestic
   */
  coverage?: string;
  /**
   * @remarks
   * The instance ID, which can be obtained by calling the [ListUserRatePlanInstances](https://help.aliyun.com/document_detail/2852398.html) operation. Specify at least one of the instance ID and website ID. If you specify both of them, the instance ID is used.
   * 
   * This parameter is required.
   * 
   * @example
   * dbaudit-cn-nwy349jdb03
   */
  instanceId?: string;
  /**
   * @remarks
   * The ID of the resource group. If you leave this parameter empty, the system uses the default resource group ID.
   * 
   * @example
   * rg-acfmw4znnok****
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The website name.
   * 
   * This parameter is required.
   * 
   * @example
   * CreateSite
   */
  siteName?: string;
  static names(): { [key: string]: string } {
    return {
      accessType: 'AccessType',
      coverage: 'Coverage',
      instanceId: 'InstanceId',
      resourceGroupId: 'ResourceGroupId',
      siteName: 'SiteName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessType: 'string',
      coverage: 'string',
      instanceId: 'string',
      resourceGroupId: 'string',
      siteName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteResponseBody extends $dara.Model {
  /**
   * @remarks
   * The nameservers assigned by ESA. The values are separated by commas (,). This parameter is returned if you set AccessType to NS. In this case, you must change the nameservers of your domain to the assigned ones. Then, you can verify the domain ownership and activate your website.
   * 
   * @example
   * ns1.example.com,ns2.example.com
   */
  nameServerList?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CB1A380B-09F0-41BB-3C82-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The verification code for the website. If you set AccessType to CNAME, you need to add a TXT record whose hostname is **_esaauth.[websiteDomainName]** and record value is the value of VerifyCode to the DNS records of your domain. ****Then, you can verify the domain ownership and activate your website.
   * 
   * @example
   * verify_aah9dioasmov****
   */
  verifyCode?: string;
  static names(): { [key: string]: string } {
    return {
      nameServerList: 'NameServerList',
      requestId: 'RequestId',
      siteId: 'SiteId',
      verifyCode: 'VerifyCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nameServerList: 'string',
      requestId: 'string',
      siteId: 'number',
      verifyCode: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateSiteResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSiteResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteCustomLogRequest extends $dara.Model {
  /**
   * @remarks
   * The cookie fields.
   */
  cookies?: string[];
  /**
   * @remarks
   * The request header fields.
   */
  requestHeaders?: string[];
  /**
   * @remarks
   * The response header fields.
   */
  responseHeaders?: string[];
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 11223
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      cookies: 'Cookies',
      requestHeaders: 'RequestHeaders',
      responseHeaders: 'ResponseHeaders',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cookies: { 'type': 'array', 'itemType': 'string' },
      requestHeaders: { 'type': 'array', 'itemType': 'string' },
      responseHeaders: { 'type': 'array', 'itemType': 'string' },
      siteId: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.cookies)) {
      $dara.Model.validateArray(this.cookies);
    }
    if(Array.isArray(this.requestHeaders)) {
      $dara.Model.validateArray(this.requestHeaders);
    }
    if(Array.isArray(this.responseHeaders)) {
      $dara.Model.validateArray(this.responseHeaders);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteCustomLogShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The cookie fields.
   */
  cookiesShrink?: string;
  /**
   * @remarks
   * The request header fields.
   */
  requestHeadersShrink?: string;
  /**
   * @remarks
   * The response header fields.
   */
  responseHeadersShrink?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 11223
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      cookiesShrink: 'Cookies',
      requestHeadersShrink: 'RequestHeaders',
      responseHeadersShrink: 'ResponseHeaders',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cookiesShrink: 'string',
      requestHeadersShrink: 'string',
      responseHeadersShrink: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteCustomLogResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 073bd613-6e72-4461-b6bc-19326dfc6a9c
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteCustomLogResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateSiteCustomLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSiteCustomLogResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteDeliveryTaskRequest extends $dara.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * *   **dcdn_log_access_l1** (default): access logs.
   * *   **dcdn_log_er**: Edge Routine logs.
   * *   **dcdn_log_waf**: firewall logs.
   * *   **dcdn_log_ipa**: TCP/UDP proxy logs.
   * 
   * This parameter is required.
   * 
   * @example
   * dcdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The data center. Valid values:
   * 
   * *   cn: the Chinese mainland.
   * *   oversea: outside the Chinese mainland.
   * 
   * This parameter is required.
   * 
   * @example
   * cn
   */
  dataCenter?: string;
  /**
   * @remarks
   * The destination of the delivery. Valid values:
   * 
   * *   sls: Alibaba Cloud Simple Log Service (SLS).
   * *   http: HTTP server.
   * *   aws3: Amazon Simple Storage Service (S3).
   * *   oss: Alibaba Cloud Object Storage Service (OSS).
   * *   kafka: Kafka.
   * *   aws3cmpt: S3-compatible storage service.
   * 
   * This parameter is required.
   * 
   * @example
   * sls
   */
  deliveryType?: string;
  /**
   * @remarks
   * The discard rate. Default value: 0.
   * 
   * @example
   * 0.0
   */
  discardRate?: number;
  /**
   * @remarks
   * The log fields, which are separated by commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * user_agent,ip_adress,ip_port
   */
  fieldName?: string;
  /**
   * @remarks
   * The configurations for delivery to an HTTP server.
   */
  httpDelivery?: CreateSiteDeliveryTaskRequestHttpDelivery;
  /**
   * @remarks
   * The configurations for delivery to Kafka.
   */
  kafkaDelivery?: CreateSiteDeliveryTaskRequestKafkaDelivery;
  /**
   * @remarks
   * The configurations for delivery to OSS.
   */
  ossDelivery?: CreateSiteDeliveryTaskRequestOssDelivery;
  /**
   * @remarks
   * The configurations for delivery to Amazon S3 or an S3-compatible service.
   */
  s3Delivery?: CreateSiteDeliveryTaskRequestS3Delivery;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 12312312112***
   */
  siteId?: number;
  /**
   * @remarks
   * The configurations for delivery to SLS.
   */
  slsDelivery?: CreateSiteDeliveryTaskRequestSlsDelivery;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * This parameter is required.
   * 
   * @example
   * dcdn-test-task
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      dataCenter: 'DataCenter',
      deliveryType: 'DeliveryType',
      discardRate: 'DiscardRate',
      fieldName: 'FieldName',
      httpDelivery: 'HttpDelivery',
      kafkaDelivery: 'KafkaDelivery',
      ossDelivery: 'OssDelivery',
      s3Delivery: 'S3Delivery',
      siteId: 'SiteId',
      slsDelivery: 'SlsDelivery',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      dataCenter: 'string',
      deliveryType: 'string',
      discardRate: 'number',
      fieldName: 'string',
      httpDelivery: CreateSiteDeliveryTaskRequestHttpDelivery,
      kafkaDelivery: CreateSiteDeliveryTaskRequestKafkaDelivery,
      ossDelivery: CreateSiteDeliveryTaskRequestOssDelivery,
      s3Delivery: CreateSiteDeliveryTaskRequestS3Delivery,
      siteId: 'number',
      slsDelivery: CreateSiteDeliveryTaskRequestSlsDelivery,
      taskName: 'string',
    };
  }

  validate() {
    if(this.httpDelivery && typeof (this.httpDelivery as any).validate === 'function') {
      (this.httpDelivery as any).validate();
    }
    if(this.kafkaDelivery && typeof (this.kafkaDelivery as any).validate === 'function') {
      (this.kafkaDelivery as any).validate();
    }
    if(this.ossDelivery && typeof (this.ossDelivery as any).validate === 'function') {
      (this.ossDelivery as any).validate();
    }
    if(this.s3Delivery && typeof (this.s3Delivery as any).validate === 'function') {
      (this.s3Delivery as any).validate();
    }
    if(this.slsDelivery && typeof (this.slsDelivery as any).validate === 'function') {
      (this.slsDelivery as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteDeliveryTaskShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * *   **dcdn_log_access_l1** (default): access logs.
   * *   **dcdn_log_er**: Edge Routine logs.
   * *   **dcdn_log_waf**: firewall logs.
   * *   **dcdn_log_ipa**: TCP/UDP proxy logs.
   * 
   * This parameter is required.
   * 
   * @example
   * dcdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The data center. Valid values:
   * 
   * *   cn: the Chinese mainland.
   * *   oversea: outside the Chinese mainland.
   * 
   * This parameter is required.
   * 
   * @example
   * cn
   */
  dataCenter?: string;
  /**
   * @remarks
   * The destination of the delivery. Valid values:
   * 
   * *   sls: Alibaba Cloud Simple Log Service (SLS).
   * *   http: HTTP server.
   * *   aws3: Amazon Simple Storage Service (S3).
   * *   oss: Alibaba Cloud Object Storage Service (OSS).
   * *   kafka: Kafka.
   * *   aws3cmpt: S3-compatible storage service.
   * 
   * This parameter is required.
   * 
   * @example
   * sls
   */
  deliveryType?: string;
  /**
   * @remarks
   * The discard rate. Default value: 0.
   * 
   * @example
   * 0.0
   */
  discardRate?: number;
  /**
   * @remarks
   * The log fields, which are separated by commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * user_agent,ip_adress,ip_port
   */
  fieldName?: string;
  /**
   * @remarks
   * The configurations for delivery to an HTTP server.
   */
  httpDeliveryShrink?: string;
  /**
   * @remarks
   * The configurations for delivery to Kafka.
   */
  kafkaDeliveryShrink?: string;
  /**
   * @remarks
   * The configurations for delivery to OSS.
   */
  ossDeliveryShrink?: string;
  /**
   * @remarks
   * The configurations for delivery to Amazon S3 or an S3-compatible service.
   */
  s3DeliveryShrink?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 12312312112***
   */
  siteId?: number;
  /**
   * @remarks
   * The configurations for delivery to SLS.
   */
  slsDeliveryShrink?: string;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * This parameter is required.
   * 
   * @example
   * dcdn-test-task
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      dataCenter: 'DataCenter',
      deliveryType: 'DeliveryType',
      discardRate: 'DiscardRate',
      fieldName: 'FieldName',
      httpDeliveryShrink: 'HttpDelivery',
      kafkaDeliveryShrink: 'KafkaDelivery',
      ossDeliveryShrink: 'OssDelivery',
      s3DeliveryShrink: 'S3Delivery',
      siteId: 'SiteId',
      slsDeliveryShrink: 'SlsDelivery',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      dataCenter: 'string',
      deliveryType: 'string',
      discardRate: 'number',
      fieldName: 'string',
      httpDeliveryShrink: 'string',
      kafkaDeliveryShrink: 'string',
      ossDeliveryShrink: 'string',
      s3DeliveryShrink: 'string',
      siteId: 'number',
      slsDeliveryShrink: 'string',
      taskName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteDeliveryTaskResponseBody extends $dara.Model {
  /**
   * @remarks
   * The data center. Valid values:
   * 
   * *   cn: the Chinese mainland.
   * *   oversea: outside the Chinese mainland.
   * 
   * @example
   * cn
   */
  dataCenter?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9358E852-992D-5BC7-8BD7-975CA02773A8
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.[](~~2850189~~)
   * 
   * @example
   * 123456****
   */
  siteId?: string;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * @example
   * er-oss
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      dataCenter: 'DataCenter',
      requestId: 'RequestId',
      siteId: 'SiteId',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataCenter: 'string',
      requestId: 'string',
      siteId: 'string',
      taskName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSiteDeliveryTaskResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateSiteDeliveryTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSiteDeliveryTaskResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSlrRoleForRealtimeLogResponseBody extends $dara.Model {
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 156A6B-677B1A-4297B7-9187B7-2B44792
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSlrRoleForRealtimeLogResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateSlrRoleForRealtimeLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSlrRoleForRealtimeLogResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserDeliveryTaskRequest extends $dara.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * *   dcdn_log_access_l1 (default): access logs.
   * *   dcdn_log_er: Edge Routine logs.
   * *   dcdn_log_waf: firewall logs.
   * *   dcdn_log_ipa: TCP/UDP proxy logs.
   * 
   * This parameter is required.
   * 
   * @example
   * dcdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The data center. Valid values:
   * 
   * *   cn: the Chinese mainland.
   * *   sg: outside the Chinese mainland.
   * 
   * This parameter is required.
   * 
   * @example
   * cn
   */
  dataCenter?: string;
  /**
   * @remarks
   * The destination of the delivery. Valid values:
   * 
   * 1.  sls: Alibaba Cloud SLS.
   * 2.  http: HTTP server.
   * 3.  aws3: Amazon S3.
   * 4.  oss: Alibaba Cloud OSS.
   * 5.  kafka: Kafka.
   * 6.  aws3cmpt: S3-compatible storage service.
   * 
   * This parameter is required.
   * 
   * @example
   * sls
   */
  deliveryType?: string;
  details?: string;
  /**
   * @remarks
   * The discard rate. Default value: 0.
   * 
   * @example
   * 0
   */
  discardRate?: number;
  /**
   * @remarks
   * The log field. If you specify multiple fields, separate them with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * user_agent,ip_address,ip_port
   */
  fieldName?: string;
  /**
   * @remarks
   * The configurations for delivery to an HTTP server.
   */
  httpDelivery?: CreateUserDeliveryTaskRequestHttpDelivery;
  /**
   * @remarks
   * The configurations for delivery to Kafka.
   */
  kafkaDelivery?: CreateUserDeliveryTaskRequestKafkaDelivery;
  /**
   * @remarks
   * The configurations for delivery to OSS.
   */
  ossDelivery?: CreateUserDeliveryTaskRequestOssDelivery;
  /**
   * @remarks
   * The configurations for delivery to Amazon S3 or an S3-compatible service.
   */
  s3Delivery?: CreateUserDeliveryTaskRequestS3Delivery;
  /**
   * @remarks
   * The configurations for delivery to SLS.
   */
  slsDelivery?: CreateUserDeliveryTaskRequestSlsDelivery;
  /**
   * @remarks
   * The task name.
   * 
   * This parameter is required.
   * 
   * @example
   * test_project
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      dataCenter: 'DataCenter',
      deliveryType: 'DeliveryType',
      details: 'Details',
      discardRate: 'DiscardRate',
      fieldName: 'FieldName',
      httpDelivery: 'HttpDelivery',
      kafkaDelivery: 'KafkaDelivery',
      ossDelivery: 'OssDelivery',
      s3Delivery: 'S3Delivery',
      slsDelivery: 'SlsDelivery',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      dataCenter: 'string',
      deliveryType: 'string',
      details: 'string',
      discardRate: 'number',
      fieldName: 'string',
      httpDelivery: CreateUserDeliveryTaskRequestHttpDelivery,
      kafkaDelivery: CreateUserDeliveryTaskRequestKafkaDelivery,
      ossDelivery: CreateUserDeliveryTaskRequestOssDelivery,
      s3Delivery: CreateUserDeliveryTaskRequestS3Delivery,
      slsDelivery: CreateUserDeliveryTaskRequestSlsDelivery,
      taskName: 'string',
    };
  }

  validate() {
    if(this.httpDelivery && typeof (this.httpDelivery as any).validate === 'function') {
      (this.httpDelivery as any).validate();
    }
    if(this.kafkaDelivery && typeof (this.kafkaDelivery as any).validate === 'function') {
      (this.kafkaDelivery as any).validate();
    }
    if(this.ossDelivery && typeof (this.ossDelivery as any).validate === 'function') {
      (this.ossDelivery as any).validate();
    }
    if(this.s3Delivery && typeof (this.s3Delivery as any).validate === 'function') {
      (this.s3Delivery as any).validate();
    }
    if(this.slsDelivery && typeof (this.slsDelivery as any).validate === 'function') {
      (this.slsDelivery as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserDeliveryTaskShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * *   dcdn_log_access_l1 (default): access logs.
   * *   dcdn_log_er: Edge Routine logs.
   * *   dcdn_log_waf: firewall logs.
   * *   dcdn_log_ipa: TCP/UDP proxy logs.
   * 
   * This parameter is required.
   * 
   * @example
   * dcdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The data center. Valid values:
   * 
   * *   cn: the Chinese mainland.
   * *   sg: outside the Chinese mainland.
   * 
   * This parameter is required.
   * 
   * @example
   * cn
   */
  dataCenter?: string;
  /**
   * @remarks
   * The destination of the delivery. Valid values:
   * 
   * 1.  sls: Alibaba Cloud SLS.
   * 2.  http: HTTP server.
   * 3.  aws3: Amazon S3.
   * 4.  oss: Alibaba Cloud OSS.
   * 5.  kafka: Kafka.
   * 6.  aws3cmpt: S3-compatible storage service.
   * 
   * This parameter is required.
   * 
   * @example
   * sls
   */
  deliveryType?: string;
  details?: string;
  /**
   * @remarks
   * The discard rate. Default value: 0.
   * 
   * @example
   * 0
   */
  discardRate?: number;
  /**
   * @remarks
   * The log field. If you specify multiple fields, separate them with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * user_agent,ip_address,ip_port
   */
  fieldName?: string;
  /**
   * @remarks
   * The configurations for delivery to an HTTP server.
   */
  httpDeliveryShrink?: string;
  /**
   * @remarks
   * The configurations for delivery to Kafka.
   */
  kafkaDeliveryShrink?: string;
  /**
   * @remarks
   * The configurations for delivery to OSS.
   */
  ossDeliveryShrink?: string;
  /**
   * @remarks
   * The configurations for delivery to Amazon S3 or an S3-compatible service.
   */
  s3DeliveryShrink?: string;
  /**
   * @remarks
   * The configurations for delivery to SLS.
   */
  slsDeliveryShrink?: string;
  /**
   * @remarks
   * The task name.
   * 
   * This parameter is required.
   * 
   * @example
   * test_project
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      dataCenter: 'DataCenter',
      deliveryType: 'DeliveryType',
      details: 'Details',
      discardRate: 'DiscardRate',
      fieldName: 'FieldName',
      httpDeliveryShrink: 'HttpDelivery',
      kafkaDeliveryShrink: 'KafkaDelivery',
      ossDeliveryShrink: 'OssDelivery',
      s3DeliveryShrink: 'S3Delivery',
      slsDeliveryShrink: 'SlsDelivery',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      dataCenter: 'string',
      deliveryType: 'string',
      details: 'string',
      discardRate: 'number',
      fieldName: 'string',
      httpDeliveryShrink: 'string',
      kafkaDeliveryShrink: 'string',
      ossDeliveryShrink: 'string',
      s3DeliveryShrink: 'string',
      slsDeliveryShrink: 'string',
      taskName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserDeliveryTaskResponseBody extends $dara.Model {
  /**
   * @remarks
   * The data center. Valid values:
   * 
   * *   cn: the Chinese mainland.
   * *   sg: outside the Chinese mainland.
   * 
   * @example
   * cn
   */
  dataCenter?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2CCD40B1-3F20-5FF0-8A67-E3F34B87744F
   */
  requestId?: string;
  /**
   * @remarks
   * The status of the delivery task.
   * 
   * @example
   * online
   */
  status?: string;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * @example
   * er-http
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      dataCenter: 'DataCenter',
      requestId: 'RequestId',
      status: 'Status',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataCenter: 'string',
      requestId: 'string',
      status: 'string',
      taskName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUserDeliveryTaskResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateUserDeliveryTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateUserDeliveryTaskResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingRoomRequest extends $dara.Model {
  /**
   * @remarks
   * The name of the custom cookie.
   * 
   * This parameter is required.
   * 
   * @example
   * __aliwaitingroom_example
   */
  cookieName?: string;
  /**
   * @remarks
   * The content of the custom waiting room page. You must specify this parameter if you set WaitingRoomType to custom. The content must be Base64-encoded.
   * 
   * @example
   * Hello%20world!
   */
  customPageHtml?: string;
  /**
   * @remarks
   * The description of the waiting room.
   */
  description?: string;
  /**
   * @remarks
   * Specifies whether to disable session renewal. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  disableSessionRenewalEnable?: string;
  /**
   * @remarks
   * Specifies whether to enable the waiting room. Valid values:
   * 
   * *   on
   * *   off
   * 
   * This parameter is required.
   * 
   * @example
   * on
   */
  enable?: string;
  /**
   * @remarks
   * The hostname and path.
   * 
   * This parameter is required.
   */
  hostNameAndPath?: CreateWaitingRoomRequestHostNameAndPath[];
  /**
   * @remarks
   * Specifies whether to enable JSON response. If you set this parameter to on, a JSON body is returned for requests to the waiting room with the header Accept: application/json. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  jsonResponseEnable?: string;
  /**
   * @remarks
   * The language of the waiting room page. You must specify this parameter if you set WaitingRoomType to default. Valid values:
   * 
   * *   enus: English.
   * *   zhcn: Simplified Chinese.
   * *   zhhk: Traditional Chinese.
   * 
   * @example
   * enus
   */
  language?: string;
  /**
   * @remarks
   * The name of the waiting room.
   * 
   * This parameter is required.
   * 
   * @example
   * waitingroom_example
   */
  name?: string;
  /**
   * @remarks
   * The maximum number of new users per minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 200
   */
  newUsersPerMinute?: string;
  /**
   * @remarks
   * Specifies whether to queue all requests. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  queueAllEnable?: string;
  /**
   * @remarks
   * The queuing method. Valid values:
   * 
   * *   random: Users gain access to the origin randomly, regardless of the arrival time.
   * *   fifo: Users gain access to the origin in order of arrival.
   * *   passthrough: Users pass through the waiting room and go straight to the origin.
   * *   reject-all: Users are blocked from reaching the origin.
   * 
   * This parameter is required.
   * 
   * @example
   * fifo
   */
  queuingMethod?: string;
  /**
   * @remarks
   * The HTTP status code to return while a user is in the queue. Valid values:
   * 
   * *   200
   * *   202
   * *   429
   * 
   * This parameter is required.
   * 
   * @example
   * 200
   */
  queuingStatusCode?: string;
  /**
   * @remarks
   * The maximum duration for which a session remains valid after a user leaves the origin. Unit: minutes.
   * 
   * This parameter is required.
   * 
   * @example
   * 5
   */
  sessionDuration?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The maximum number of active users.
   * 
   * This parameter is required.
   * 
   * @example
   * 300
   */
  totalActiveUsers?: string;
  /**
   * @remarks
   * The type of the waiting room. Valid values:
   * 
   * *   default
   * *   custom
   * 
   * This parameter is required.
   * 
   * @example
   * default
   */
  waitingRoomType?: string;
  static names(): { [key: string]: string } {
    return {
      cookieName: 'CookieName',
      customPageHtml: 'CustomPageHtml',
      description: 'Description',
      disableSessionRenewalEnable: 'DisableSessionRenewalEnable',
      enable: 'Enable',
      hostNameAndPath: 'HostNameAndPath',
      jsonResponseEnable: 'JsonResponseEnable',
      language: 'Language',
      name: 'Name',
      newUsersPerMinute: 'NewUsersPerMinute',
      queueAllEnable: 'QueueAllEnable',
      queuingMethod: 'QueuingMethod',
      queuingStatusCode: 'QueuingStatusCode',
      sessionDuration: 'SessionDuration',
      siteId: 'SiteId',
      totalActiveUsers: 'TotalActiveUsers',
      waitingRoomType: 'WaitingRoomType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cookieName: 'string',
      customPageHtml: 'string',
      description: 'string',
      disableSessionRenewalEnable: 'string',
      enable: 'string',
      hostNameAndPath: { 'type': 'array', 'itemType': CreateWaitingRoomRequestHostNameAndPath },
      jsonResponseEnable: 'string',
      language: 'string',
      name: 'string',
      newUsersPerMinute: 'string',
      queueAllEnable: 'string',
      queuingMethod: 'string',
      queuingStatusCode: 'string',
      sessionDuration: 'string',
      siteId: 'number',
      totalActiveUsers: 'string',
      waitingRoomType: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.hostNameAndPath)) {
      $dara.Model.validateArray(this.hostNameAndPath);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingRoomShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The name of the custom cookie.
   * 
   * This parameter is required.
   * 
   * @example
   * __aliwaitingroom_example
   */
  cookieName?: string;
  /**
   * @remarks
   * The content of the custom waiting room page. You must specify this parameter if you set WaitingRoomType to custom. The content must be Base64-encoded.
   * 
   * @example
   * Hello%20world!
   */
  customPageHtml?: string;
  /**
   * @remarks
   * The description of the waiting room.
   */
  description?: string;
  /**
   * @remarks
   * Specifies whether to disable session renewal. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  disableSessionRenewalEnable?: string;
  /**
   * @remarks
   * Specifies whether to enable the waiting room. Valid values:
   * 
   * *   on
   * *   off
   * 
   * This parameter is required.
   * 
   * @example
   * on
   */
  enable?: string;
  /**
   * @remarks
   * The hostname and path.
   * 
   * This parameter is required.
   */
  hostNameAndPathShrink?: string;
  /**
   * @remarks
   * Specifies whether to enable JSON response. If you set this parameter to on, a JSON body is returned for requests to the waiting room with the header Accept: application/json. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  jsonResponseEnable?: string;
  /**
   * @remarks
   * The language of the waiting room page. You must specify this parameter if you set WaitingRoomType to default. Valid values:
   * 
   * *   enus: English.
   * *   zhcn: Simplified Chinese.
   * *   zhhk: Traditional Chinese.
   * 
   * @example
   * enus
   */
  language?: string;
  /**
   * @remarks
   * The name of the waiting room.
   * 
   * This parameter is required.
   * 
   * @example
   * waitingroom_example
   */
  name?: string;
  /**
   * @remarks
   * The maximum number of new users per minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 200
   */
  newUsersPerMinute?: string;
  /**
   * @remarks
   * Specifies whether to queue all requests. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  queueAllEnable?: string;
  /**
   * @remarks
   * The queuing method. Valid values:
   * 
   * *   random: Users gain access to the origin randomly, regardless of the arrival time.
   * *   fifo: Users gain access to the origin in order of arrival.
   * *   passthrough: Users pass through the waiting room and go straight to the origin.
   * *   reject-all: Users are blocked from reaching the origin.
   * 
   * This parameter is required.
   * 
   * @example
   * fifo
   */
  queuingMethod?: string;
  /**
   * @remarks
   * The HTTP status code to return while a user is in the queue. Valid values:
   * 
   * *   200
   * *   202
   * *   429
   * 
   * This parameter is required.
   * 
   * @example
   * 200
   */
  queuingStatusCode?: string;
  /**
   * @remarks
   * The maximum duration for which a session remains valid after a user leaves the origin. Unit: minutes.
   * 
   * This parameter is required.
   * 
   * @example
   * 5
   */
  sessionDuration?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The maximum number of active users.
   * 
   * This parameter is required.
   * 
   * @example
   * 300
   */
  totalActiveUsers?: string;
  /**
   * @remarks
   * The type of the waiting room. Valid values:
   * 
   * *   default
   * *   custom
   * 
   * This parameter is required.
   * 
   * @example
   * default
   */
  waitingRoomType?: string;
  static names(): { [key: string]: string } {
    return {
      cookieName: 'CookieName',
      customPageHtml: 'CustomPageHtml',
      description: 'Description',
      disableSessionRenewalEnable: 'DisableSessionRenewalEnable',
      enable: 'Enable',
      hostNameAndPathShrink: 'HostNameAndPath',
      jsonResponseEnable: 'JsonResponseEnable',
      language: 'Language',
      name: 'Name',
      newUsersPerMinute: 'NewUsersPerMinute',
      queueAllEnable: 'QueueAllEnable',
      queuingMethod: 'QueuingMethod',
      queuingStatusCode: 'QueuingStatusCode',
      sessionDuration: 'SessionDuration',
      siteId: 'SiteId',
      totalActiveUsers: 'TotalActiveUsers',
      waitingRoomType: 'WaitingRoomType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cookieName: 'string',
      customPageHtml: 'string',
      description: 'string',
      disableSessionRenewalEnable: 'string',
      enable: 'string',
      hostNameAndPathShrink: 'string',
      jsonResponseEnable: 'string',
      language: 'string',
      name: 'string',
      newUsersPerMinute: 'string',
      queueAllEnable: 'string',
      queuingMethod: 'string',
      queuingStatusCode: 'string',
      sessionDuration: 'string',
      siteId: 'number',
      totalActiveUsers: 'string',
      waitingRoomType: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingRoomResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 85H66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  waitingRoomId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      waitingRoomId: 'WaitingRoomId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      waitingRoomId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingRoomResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateWaitingRoomResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateWaitingRoomResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingRoomEventRequest extends $dara.Model {
  /**
   * @remarks
   * The content of the custom waiting room page. You must specify this parameter if you set WaitingRoomType to custom. The content must be Base64-encoded.
   * 
   * @example
   * Hello%20world!
   */
  customPageHtml?: string;
  /**
   * @remarks
   * The description of the waiting room.
   */
  description?: string;
  /**
   * @remarks
   * Specifies whether to disable session renewal. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  disableSessionRenewalEnable?: string;
  /**
   * @remarks
   * Specifies whether to enable the waiting room. Valid values:
   * 
   * *   on
   * *   off
   * 
   * This parameter is required.
   * 
   * @example
   * on
   */
  enable?: string;
  /**
   * @remarks
   * The end time of the event. This value is a UNIX timestamp.
   * 
   * This parameter is required.
   * 
   * @example
   * 1719849600
   */
  endTime?: string;
  /**
   * @remarks
   * Specifies whether to enable JSON response. If you set this parameter to on, a JSON body is returned for requests to the waiting room with the header Accept: application/json. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  jsonResponseEnable?: string;
  /**
   * @remarks
   * The language of the waiting room page. You must specify this parameter if you set WaitingRoomType to default. Valid values:
   * 
   * *   enus: English.
   * *   zhcn: Simplified Chinese.
   * *   zhhk: Traditional Chinese.
   * 
   * @example
   * zhcn
   */
  language?: string;
  /**
   * @remarks
   * The name of the waiting room event.
   * 
   * This parameter is required.
   * 
   * @example
   * waitingroom_example
   */
  name?: string;
  /**
   * @remarks
   * The maximum number of new users per minute.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  newUsersPerMinute?: string;
  /**
   * @remarks
   * Specifies whether to enable pre-queuing.
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  preQueueEnable?: string;
  /**
   * @remarks
   * The start time for pre-queuing.
   * 
   * @example
   * 1719763200
   */
  preQueueStartTime?: string;
  /**
   * @remarks
   * The queuing method. Valid values:
   * 
   * *   random: Users gain access to the origin randomly, regardless of the arrival time.
   * *   fifo: Users gain access to the origin in order of arrival.
   * *   passthrough: Users pass through the waiting room and go straight to the origin.
   * *   reject-all: Users are blocked from reaching the origin.
   * 
   * This parameter is required.
   * 
   * @example
   * random
   */
  queuingMethod?: string;
  /**
   * @remarks
   * The HTTP status code to return while a user is in the queue. Valid values:
   * 
   * *   200
   * *   202
   * *   429
   * 
   * This parameter is required.
   * 
   * @example
   * 202
   */
  queuingStatusCode?: string;
  /**
   * @remarks
   * Specifies whether to enable random queuing.
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  randomPreQueueEnable?: string;
  /**
   * @remarks
   * The maximum duration for which a session remains valid after a user leaves the origin. Unit: minutes.
   * 
   * This parameter is required.
   * 
   * @example
   * 5
   */
  sessionDuration?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The start time of the event. This value is a UNIX timestamp.
   * 
   * This parameter is required.
   * 
   * @example
   * 1719763200
   */
  startTime?: string;
  /**
   * @remarks
   * The maximum number of active users.
   * 
   * This parameter is required.
   * 
   * @example
   * 100
   */
  totalActiveUsers?: string;
  /**
   * @remarks
   * The ID of the waiting room, which can be obtained by calling the [ListWaitingRooms](https://help.aliyun.com/document_detail/2850279.html) operation.
   * 
   * @example
   * 6a51d5bc6460887abd1291dc7d4db28b
   */
  waitingRoomId?: string;
  /**
   * @remarks
   * The type of the waiting room. Valid values:
   * 
   * *   default
   * *   custom
   * 
   * This parameter is required.
   * 
   * @example
   * default
   */
  waitingRoomType?: string;
  static names(): { [key: string]: string } {
    return {
      customPageHtml: 'CustomPageHtml',
      description: 'Description',
      disableSessionRenewalEnable: 'DisableSessionRenewalEnable',
      enable: 'Enable',
      endTime: 'EndTime',
      jsonResponseEnable: 'JsonResponseEnable',
      language: 'Language',
      name: 'Name',
      newUsersPerMinute: 'NewUsersPerMinute',
      preQueueEnable: 'PreQueueEnable',
      preQueueStartTime: 'PreQueueStartTime',
      queuingMethod: 'QueuingMethod',
      queuingStatusCode: 'QueuingStatusCode',
      randomPreQueueEnable: 'RandomPreQueueEnable',
      sessionDuration: 'SessionDuration',
      siteId: 'SiteId',
      startTime: 'StartTime',
      totalActiveUsers: 'TotalActiveUsers',
      waitingRoomId: 'WaitingRoomId',
      waitingRoomType: 'WaitingRoomType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customPageHtml: 'string',
      description: 'string',
      disableSessionRenewalEnable: 'string',
      enable: 'string',
      endTime: 'string',
      jsonResponseEnable: 'string',
      language: 'string',
      name: 'string',
      newUsersPerMinute: 'string',
      preQueueEnable: 'string',
      preQueueStartTime: 'string',
      queuingMethod: 'string',
      queuingStatusCode: 'string',
      randomPreQueueEnable: 'string',
      sessionDuration: 'string',
      siteId: 'number',
      startTime: 'string',
      totalActiveUsers: 'string',
      waitingRoomId: 'string',
      waitingRoomType: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingRoomEventResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A123425345
   */
  requestId?: string;
  waitingRoomEventId?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      waitingRoomEventId: 'WaitingRoomEventId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      waitingRoomEventId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingRoomEventResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateWaitingRoomEventResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateWaitingRoomEventResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingRoomRuleRequest extends $dara.Model {
  /**
   * @remarks
   * The rule content, which is a policy or conditional expression.
   * 
   * This parameter is required.
   * 
   * @example
   * (http.request.uri.path.file_name eq \\"jpg\\")
   */
  rule?: string;
  /**
   * @remarks
   * Specifies whether to enable the rule. Valid values:
   * 
   * *   on
   * *   off
   * 
   * This parameter is required.
   * 
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @remarks
   * The rule name.
   * 
   * This parameter is required.
   * 
   * @example
   * waitingroom_example
   */
  ruleName?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The ID of the waiting room to be bypassed.
   * 
   * This parameter is required.
   * 
   * @example
   * 25133f536f1b1f6b6091f6a92c614dd4
   */
  waitingRoomId?: string;
  static names(): { [key: string]: string } {
    return {
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      waitingRoomId: 'WaitingRoomId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
      waitingRoomId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingRoomRuleResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  waitingRoomRuleId?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      waitingRoomRuleId: 'WaitingRoomRuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      waitingRoomRuleId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateWaitingRoomRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateWaitingRoomRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateWaitingRoomRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeactivateVersionManagementRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeactivateVersionManagementResponseBody extends $dara.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeactivateVersionManagementResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeactivateVersionManagementResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeactivateVersionManagementResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCacheRuleRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 3528160*********
   */
  configId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 3500241*********
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCacheRuleResponseBody extends $dara.Model {
  /**
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCacheRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteCacheRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteCacheRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCertificateRequest extends $dara.Model {
  /**
   * @remarks
   * The certificate ID.
   * 
   * This parameter is required.
   * 
   * @example
   * babaded901474b9693acf530e0fb1d95
   */
  id?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](~~ListSites~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCertificateResponseBody extends $dara.Model {
  /**
   * @remarks
   * The certificate ID.
   * 
   * @example
   * babaded901474b9693acf530e0fb1d95
   */
  id?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F32C57AA-7BF8-49AE-A2CC-9F42390F5A19
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
      siteId: 'SiteId',
      siteName: 'SiteName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      requestId: 'string',
      siteId: 'number',
      siteName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCertificateResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteCertificateResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteClientCaCertificateRequest extends $dara.Model {
  /**
   * @remarks
   * The certificate ID.
   * 
   * This parameter is required.
   * 
   * @example
   * baba39055622c008b90285a8838ed09a
   */
  id?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteClientCaCertificateResponseBody extends $dara.Model {
  /**
   * @remarks
   * The certificate ID.
   * 
   * @example
   * baba39055622c008b90285a8838ed09a
   */
  id?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CB1A380B-09F0-41BB-280B-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
      siteId: 'SiteId',
      siteName: 'SiteName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      requestId: 'string',
      siteId: 'number',
      siteName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteClientCaCertificateResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteClientCaCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteClientCaCertificateResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteClientCertificateRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * baba39055622c008b90285a8838ed09a
   */
  id?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteClientCertificateResponseBody extends $dara.Model {
  /**
   * @example
   * baba39055622c008b90285a8838ed09a
   */
  id?: string;
  /**
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  /**
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @example
   * example.com
   */
  siteName?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
      siteId: 'SiteId',
      siteName: 'SiteName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      requestId: 'string',
      siteId: 'number',
      siteName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteClientCertificateResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteClientCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteClientCertificateResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCompressionRuleRequest extends $dara.Model {
  /**
   * @remarks
   * The configuration ID, which can be obtained by calling the [ListCompressionRules](~~ListCompressionRules~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCompressionRuleResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F61CDR30-E83C-4FDA-BF73-9A94CDD44229
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCompressionRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteCompressionRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteCompressionRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCustomScenePolicyRequest extends $dara.Model {
  /**
   * @remarks
   * The policy ID, which can be obtained by calling the [DescribeCustomScenePolicies](https://help.aliyun.com/document_detail/2850508.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  policyId?: number;
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCustomScenePolicyResponseBody extends $dara.Model {
  /**
   * @remarks
   * The policy ID.
   * 
   * @example
   * 1
   */
  policyId?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 5CC228B4-7A67-4016-9C9F-4A4133494A91
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'number',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCustomScenePolicyResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteCustomScenePolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteCustomScenePolicyResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeContainerAppRequest extends $dara.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * @example
   * app-1232321454***
   */
  appId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeContainerAppResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  /**
   * @remarks
   * Specifies whether the deletion is successful.
   * 
   * @example
   * ok
   */
  state?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      state: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeContainerAppResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteEdgeContainerAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteEdgeContainerAppResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeContainerAppRecordRequest extends $dara.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * This parameter is required.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The associated domain name.
   * 
   * This parameter is required.
   * 
   * @example
   * a.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 5407498413****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      recordName: 'RecordName',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      recordName: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeContainerAppRecordResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeContainerAppRecordResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteEdgeContainerAppRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteEdgeContainerAppRecordResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeContainerAppVersionRequest extends $dara.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * app-96253477062511****
   */
  appId?: string;
  /**
   * @remarks
   * The ID of the version that you want to delete. To obtain the version ID, call the [ListEdgeContainerAppVersions](~~ListEdgeContainerAppVersions~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * ver-89884764010378****
   */
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      versionId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeContainerAppVersionResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * b021e538-9dde-46ed-a1f2-9469da8f3e77
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteEdgeContainerAppVersionResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteEdgeContainerAppVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteEdgeContainerAppVersionResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHttpRequestHeaderModificationRuleRequest extends $dara.Model {
  /**
   * @remarks
   * The configuration ID, which can be obtained by calling the [ListHttpRequestHeaderModificationRules](~~ListHttpRequestHeaderModificationRules~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 3528160969****
   */
  configId?: number;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](~~ListSites~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHttpRequestHeaderModificationRuleResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 35C66C7B-671H-4297-9187-2C4477247A78
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHttpRequestHeaderModificationRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteHttpRequestHeaderModificationRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteHttpRequestHeaderModificationRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHttpResponseHeaderModificationRuleRequest extends $dara.Model {
  /**
   * @remarks
   * The configuration ID, which can be obtained by calling the [ListHttpResponseHeaderModificationRules](~~ListHttpResponseHeaderModificationRules~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456789****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHttpResponseHeaderModificationRuleResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F61CDR30-E83C-4FDA-BF73-9A94CDD44229
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHttpResponseHeaderModificationRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteHttpResponseHeaderModificationRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteHttpResponseHeaderModificationRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHttpsApplicationConfigurationRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHttpsApplicationConfigurationResponseBody extends $dara.Model {
  /**
   * @example
   * 35C66C7B-671H-4297-9187-2C4477247A78
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHttpsApplicationConfigurationResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteHttpsApplicationConfigurationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteHttpsApplicationConfigurationResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHttpsBasicConfigurationRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 3528160969****
   */
  configId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHttpsBasicConfigurationResponseBody extends $dara.Model {
  /**
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHttpsBasicConfigurationResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteHttpsBasicConfigurationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteHttpsBasicConfigurationResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteImageTransformRequest extends $dara.Model {
  /**
   * @remarks
   * The configuration ID, which can be obtained by calling the [ListImageTransforms](~~ListImageTransforms~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 352816096987136
   */
  configId?: number;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteImageTransformResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteImageTransformResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteImageTransformResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteImageTransformResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteKvRequest extends $dara.Model {
  /**
   * @remarks
   * The name of the key that you want to delete.
   * 
   * This parameter is required.
   * 
   * @example
   * test_key
   */
  key?: string;
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      namespace: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteKvResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteKvResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteKvResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteKvResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteKvNamespaceRequest extends $dara.Model {
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      namespace: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteKvNamespaceResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteKvNamespaceResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteKvNamespaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteKvNamespaceResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteListRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the custom list, which can be obtained by calling the [ListLists](https://help.aliyun.com/document_detail/2850217.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 40000001
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteListResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteListResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteListResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLoadBalancerRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * DeleteLoadBalancer
   */
  id?: number;
  /**
   * @remarks
   * This parameter is required.
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLoadBalancerResponseBody extends $dara.Model {
  /**
   * @remarks
   * Id of the request
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLoadBalancerResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteLoadBalancerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLoadBalancerResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNetworkOptimizationRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 352816**********
   */
  configId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNetworkOptimizationResponseBody extends $dara.Model {
  /**
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteNetworkOptimizationResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteNetworkOptimizationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteNetworkOptimizationResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOriginPoolRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * DeleteOriginPool
   */
  id?: number;
  /**
   * @remarks
   * This parameter is required.
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOriginPoolResponseBody extends $dara.Model {
  /**
   * @remarks
   * Id of the request
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOriginPoolResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteOriginPoolResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteOriginPoolResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOriginProtectionRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOriginProtectionResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CB1A380B-09F0-41BB-A198-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOriginProtectionResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteOriginProtectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteOriginProtectionResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOriginRuleRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 33793140540****
   */
  configId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 3400350********
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOriginRuleResponseBody extends $dara.Model {
  /**
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteOriginRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteOriginRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteOriginRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePageRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the custom error page, which can be obtained by calling the [ListPages](https://help.aliyun.com/document_detail/2850223.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 50000001
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePageResponseBody extends $dara.Model {
  /**
   * @remarks
   * The ID of the custom error page.[](~~2850223~~)
   * 
   * @example
   * 50000001
   */
  id?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePageResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeletePageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeletePageResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRecordRequest extends $dara.Model {
  /**
   * @remarks
   * The record ID, which can be obtained by calling [ListRecords](https://help.aliyun.com/document_detail/2850265.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  recordId?: number;
  static names(): { [key: string]: string } {
    return {
      recordId: 'RecordId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRecordResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F61CDR30-E83C-4FDA-BF73-9A94CDD44229
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRecordResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRecordResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRedirectRuleRequest extends $dara.Model {
  /**
   * @remarks
   * The configuration ID, which can be obtained by calling the [ListRedirectRules](~~ListRedirectRules~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRedirectRuleResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * BF9B849D-D847-5B16-9371-8ECB557A5921
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRedirectRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRedirectRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRedirectRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRewriteUrlRuleRequest extends $dara.Model {
  /**
   * @remarks
   * The configuration ID, which can be obtained by calling the [ListRewriteUrlRules](~~ListRewriteUrlRules~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRewriteUrlRuleResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 35C66C7B-671H-4297-9187-2C4477247A78
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRewriteUrlRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRewriteUrlRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRewriteUrlRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineRequest extends $dara.Model {
  /**
   * @remarks
   * The routine name.
   * 
   * This parameter is required.
   * 
   * @example
   * test-routine1
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the operation is successful.
   * 
   * @example
   * OK
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRoutineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRoutineResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineCodeVersionRequest extends $dara.Model {
  /**
   * @remarks
   * The code version.
   * 
   * This parameter is required.
   * 
   * @example
   * 1710120201067203242
   */
  codeVersion?: string;
  /**
   * @remarks
   * The routine name.
   * 
   * This parameter is required.
   * 
   * @example
   * test-routine1
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      codeVersion: 'CodeVersion',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeVersion: 'string',
      name: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineCodeVersionResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the operation is successful.
   * 
   * @example
   * OK
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineCodeVersionResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRoutineCodeVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRoutineCodeVersionResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineRelatedRecordRequest extends $dara.Model {
  /**
   * @remarks
   * The routine name.
   * 
   * This parameter is required.
   * 
   * @example
   * DeleteRoutineRelatedRecord
   */
  name?: string;
  /**
   * @remarks
   * The record ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  recordId?: number;
  /**
   * @remarks
   * The record name.
   * 
   * This parameter is required.
   * 
   * @example
   * test-xxx.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      recordId: 'RecordId',
      recordName: 'RecordName',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      recordId: 'number',
      recordName: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineRelatedRecordResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the operation is successful.
   * 
   * *   OK
   * *   Fail
   * 
   * @example
   * OK
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineRelatedRecordResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRoutineRelatedRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRoutineRelatedRecordResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineRelatedRouteRequest extends $dara.Model {
  /**
   * @remarks
   * The routine name.
   * 
   * This parameter is required.
   * 
   * @example
   * DeleteRoutineRelatedRoute
   */
  name?: string;
  /**
   * @remarks
   * The route URL.
   * 
   * This parameter is required.
   * 
   * @example
   * *.example.com/path1*
   */
  route?: string;
  /**
   * @remarks
   * The route ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 0c3b82a3d1524e9f750da11d0cc0be0a
   */
  routeId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 54362329990032
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      route: 'Route',
      routeId: 'RouteId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      route: 'string',
      routeId: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineRelatedRouteResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the operation is successful.
   * 
   * @example
   * OK
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRoutineRelatedRouteResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRoutineRelatedRouteResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRoutineRelatedRouteResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScheduledPreloadExecutionRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the prefetch plan.
   * 
   * This parameter is required.
   * 
   * @example
   * DeleteScheduledPreloadExecution
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScheduledPreloadExecutionResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScheduledPreloadExecutionResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteScheduledPreloadExecutionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteScheduledPreloadExecutionResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScheduledPreloadJobRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the scheduled prefetch task.
   * 
   * This parameter is required.
   * 
   * @example
   * DeleteScheduledPreloadJob
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScheduledPreloadJobResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * C370DAF1-C838-4288-A1A0-9A87633D248E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteScheduledPreloadJobResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteScheduledPreloadJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteScheduledPreloadJobResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSiteRequest extends $dara.Model {
  ownerId?: number;
  securityToken?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      ownerId: 'OwnerId',
      securityToken: 'SecurityToken',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ownerId: 'number',
      securityToken: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSiteResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247B78
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSiteResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteSiteResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSiteResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSiteDeliveryTaskRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456******
   */
  siteId?: number;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * This parameter is required.
   * 
   * @example
   * cdn-test-task
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      taskName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSiteDeliveryTaskResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F61CDR30-E83C-4FDA-BF73-9A94CDD44229
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSiteDeliveryTaskResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteSiteDeliveryTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSiteDeliveryTaskResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUserDeliveryTaskRequest extends $dara.Model {
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * This parameter is required.
   * 
   * @example
   * test-project
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUserDeliveryTaskResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 952ea16b-1f05-4a76-bb32-420282d8aeb9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUserDeliveryTaskResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteUserDeliveryTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteUserDeliveryTaskResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWaitingRoomRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The waiting room ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 25133f536f1b1f6b6091f6a92c614dd4
   */
  waitingRoomId?: string;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      waitingRoomId: 'WaitingRoomId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      waitingRoomId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWaitingRoomResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A123425345
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWaitingRoomResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteWaitingRoomResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteWaitingRoomResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWaitingRoomEventRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The ID of the waiting room event.
   * 
   * @example
   * 302909890***
   */
  waitingRoomEventId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      waitingRoomEventId: 'WaitingRoomEventId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      waitingRoomEventId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWaitingRoomEventResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWaitingRoomEventResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteWaitingRoomEventResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteWaitingRoomEventResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWaitingRoomRuleRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The ID of the waiting room bypass rule.
   * 
   * @example
   * 3672886****
   */
  waitingRoomRuleId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      waitingRoomRuleId: 'WaitingRoomRuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      waitingRoomRuleId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWaitingRoomRuleResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteWaitingRoomRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteWaitingRoomRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteWaitingRoomRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomScenePoliciesRequest extends $dara.Model {
  /**
   * @remarks
   * The page number. Valid values: 1 to 100000.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Valid values: 5, 10, and 20.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the policy, which can be obtained by calling the [ListWafRulesets](https://help.aliyun.com/document_detail/2850233.html) operation.
   * 
   * @example
   * 1234****
   */
  policyId?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      policyId: 'PolicyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      policyId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomScenePoliciesResponseBody extends $dara.Model {
  /**
   * @remarks
   * The scenario-specific policies.
   */
  dataModule?: DescribeCustomScenePoliciesResponseBodyDataModule[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The policy quota.
   * 
   * @example
   * 10
   */
  quota?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 85H66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      dataModule: 'DataModule',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      quota: 'Quota',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataModule: { 'type': 'array', 'itemType': DescribeCustomScenePoliciesResponseBodyDataModule },
      pageNumber: 'number',
      pageSize: 'number',
      quota: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.dataModule)) {
      $dara.Model.validateArray(this.dataModule);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomScenePoliciesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeCustomScenePoliciesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCustomScenePoliciesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDoSAllEventListRequest extends $dara.Model {
  /**
   * @remarks
   * The end of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. The maximum time range is 31 days.
   * 
   * If you do not configure this parameter, the current time is used as the end of the time range to query.
   * 
   * @example
   * 2023-02-22T15:59:59Z
   */
  endTime?: string;
  /**
   * @remarks
   * The type of DDoS attacks to query. Valid values:
   * 
   * *   **web-cc**: web resource exhaustion attacks.
   * *   **cc**: connection flood attacks.
   * *   **traffic**: volumetric attacks.
   * 
   * Default value: web-cc.
   * 
   * @example
   * web-cc
   */
  eventType?: string;
  /**
   * @remarks
   * The page number. Valid values: **1** to **100000**.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: **10**. Valid values: 5, 10, and 20.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 7096621098****
   */
  siteId?: number;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-02-12T15:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      eventType: 'EventType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      siteId: 'SiteId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      eventType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      siteId: 'number',
      startTime: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDoSAllEventListResponseBody extends $dara.Model {
  /**
   * @remarks
   * The DDoS attack events.
   */
  dataList?: DescribeDDoSAllEventListResponseBodyDataList[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * D73A4243-CFBD-5110-876F-09237E77ECBD
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 7096621098****
   */
  siteId?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      dataList: 'DataList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      siteId: 'SiteId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataList: { 'type': 'array', 'itemType': DescribeDDoSAllEventListResponseBodyDataList },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      siteId: 'number',
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.dataList)) {
      $dara.Model.validateArray(this.dataList);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDoSAllEventListResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDDoSAllEventListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDDoSAllEventListResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDoSBpsListRequest extends $dara.Model {
  coverage?: string;
  /**
   * @example
   * 2023-05-18T06:19:42Z
   */
  endTime?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 70966210986912
   */
  siteId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2023-05-14T17:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      coverage: 'Coverage',
      endTime: 'EndTime',
      siteId: 'SiteId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      coverage: 'string',
      endTime: 'string',
      siteId: 'number',
      startTime: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDoSBpsListResponseBody extends $dara.Model {
  /**
   * @example
   * 300
   */
  dataInterval?: number;
  dataModule?: DescribeDDoSBpsListResponseBodyDataModule[];
  /**
   * @example
   * 2023-05-18T06:19:42Z
   */
  endTime?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 156A6B-677B1A-4297B7-9187B7-2B44792
   */
  requestId?: string;
  /**
   * @example
   * 2023-05-14T17:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      dataModule: 'DataModule',
      endTime: 'EndTime',
      requestId: 'RequestId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'number',
      dataModule: { 'type': 'array', 'itemType': DescribeDDoSBpsListResponseBodyDataModule },
      endTime: 'string',
      requestId: 'string',
      startTime: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.dataModule)) {
      $dara.Model.validateArray(this.dataModule);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDoSBpsListResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDDoSBpsListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDDoSBpsListResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDoSL7QpsListRequest extends $dara.Model {
  /**
   * @example
   * 2023-04-19T19:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 300
   */
  interval?: number;
  /**
   * @example
   * 86510927836942****
   */
  recordId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * A short description of struct
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-19T16:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      interval: 'Interval',
      recordId: 'RecordId',
      siteId: 'SiteId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      interval: 'number',
      recordId: 'number',
      siteId: 'number',
      startTime: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDoSL7QpsListResponseBody extends $dara.Model {
  /**
   * @example
   * 300
   */
  dataInterval?: number;
  dataModule?: DescribeDDoSL7QpsListResponseBodyDataModule[];
  /**
   * @example
   * 2023-04-19T19:00:00Z
   */
  endTime?: string;
  /**
   * @example
   * 86510927836942****
   */
  recordId?: number;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 156A6B-677B1A-4297B7-9187B7-2B44792
   */
  requestId?: string;
  /**
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @example
   * 2023-04-19T16:00:00Z
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      dataInterval: 'DataInterval',
      dataModule: 'DataModule',
      endTime: 'EndTime',
      recordId: 'RecordId',
      requestId: 'RequestId',
      siteId: 'SiteId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataInterval: 'number',
      dataModule: { 'type': 'array', 'itemType': DescribeDDoSL7QpsListResponseBodyDataModule },
      endTime: 'string',
      recordId: 'number',
      requestId: 'string',
      siteId: 'number',
      startTime: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.dataModule)) {
      $dara.Model.validateArray(this.dataModule);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDDoSL7QpsListResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDDoSL7QpsListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDDoSL7QpsListResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHttpDDoSAttackIntelligentProtectionRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHttpDDoSAttackIntelligentProtectionResponseBody extends $dara.Model {
  /**
   * @remarks
   * The mode of smart HTTP DDoS protection. Valid values:
   * 
   * *   **observe**: alert.
   * *   **defense**: block.
   * 
   * @example
   * defense
   */
  aiMode?: string;
  /**
   * @remarks
   * The level of smart HTTP DDoS protection. Valid values:
   * 
   * *   **level0**: very loose.
   * *   **level30**: loose.
   * *   **level60**: normal.
   * *   **level90**: strict.
   * 
   * @example
   * level60
   */
  aiTemplate?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CB1A380B-09F0-41BB-3C82-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      aiMode: 'AiMode',
      aiTemplate: 'AiTemplate',
      requestId: 'RequestId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aiMode: 'string',
      aiTemplate: 'string',
      requestId: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHttpDDoSAttackIntelligentProtectionResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeHttpDDoSAttackIntelligentProtectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeHttpDDoSAttackIntelligentProtectionResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHttpDDoSAttackProtectionRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHttpDDoSAttackProtectionResponseBody extends $dara.Model {
  /**
   * @remarks
   * The level of HTTP DDoS attack protection. Valid values:
   * 
   * *   **very weak**: very loose.
   * *   **weak**: loose.
   * *   **default**: normal.
   * *   **hard**: strict.
   * 
   * @example
   * default
   */
  globalMode?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 35C66C7B-671H-4297-9187-2C4477247A78
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      globalMode: 'GlobalMode',
      requestId: 'RequestId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      globalMode: 'string',
      requestId: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHttpDDoSAttackProtectionResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeHttpDDoSAttackProtectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeHttpDDoSAttackProtectionResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeKvAccountStatusResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether Edge KV is activated for the Alibaba Cloud account.
   * 
   * *   **online**
   * *   **offline**
   * 
   * @example
   * online
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeKvAccountStatusResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeKvAccountStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeKvAccountStatusResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePreloadTasksRequest extends $dara.Model {
  /**
   * @remarks
   * The content to prefetch. Exact match is supported.
   * 
   * @example
   * http://a.com/1.jpg?b=2
   */
  content?: string;
  /**
   * @remarks
   * The end time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * >  The end time must be later than the start time.
   * 
   * @example
   * 2023-03-23T06:23:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The page number. Valid values: **1** to **100000**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 20. Valid values: 1 to 50.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * @example
   * 123456789****
   */
  siteId?: number;
  /**
   * @remarks
   * The start time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2023-03-22T17:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The task status. Valid values:
   * 
   * *   **Complete**: The task is complete.
   * *   **Refreshing**: The task is running.
   * *   **Failed**: The task failed.
   * 
   * @example
   * Complete
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      endTime: 'EndTime',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      siteId: 'SiteId',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      endTime: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      siteId: 'number',
      startTime: 'string',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePreloadTasksResponseBody extends $dara.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  /**
   * @remarks
   * The tasks.
   */
  tasks?: DescribePreloadTasksResponseBodyTasks[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 83
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      tasks: 'Tasks',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      tasks: { 'type': 'array', 'itemType': DescribePreloadTasksResponseBodyTasks },
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.tasks)) {
      $dara.Model.validateArray(this.tasks);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePreloadTasksResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePreloadTasksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePreloadTasksResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePurgeTasksRequest extends $dara.Model {
  /**
   * @remarks
   * The content to purge. Exact match is supported.
   * 
   * @example
   * http://a.com/1.jpg?b=1
   */
  content?: string;
  /**
   * @remarks
   * The end time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * >  The end time must be later than the start time.
   * 
   * @example
   * 2022-11-18T15:59:59Z
   */
  endTime?: string;
  /**
   * @remarks
   * The page number. Valid values: 1 to 100000.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 20. Valid values: 1 to 50.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * @example
   * 123456789****
   */
  siteId?: number;
  /**
   * @remarks
   * The start time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2022-11-16T05:33:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The task status. Valid values:
   * 
   * *   **Complete**: The task is complete.
   * *   **Refreshing**: The task is in progress.
   * *   **Failed**: The task failed.
   * 
   * @example
   * Complete
   */
  status?: string;
  /**
   * @remarks
   * The task type. Valid values:
   * 
   * *   **file** (default): purges the cache by file.
   * *   **cachetag**: purges the cache by cache tag.
   * *   **directory**: purges the cache by directory.
   * *   **ignoreParams**: purges the cache by URL with specified parameters ignored.
   * *   **hostname**: purges the cache by hostname.
   * *   **purgeall**: purges all cache.
   * 
   * @example
   * file
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      endTime: 'EndTime',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      siteId: 'SiteId',
      startTime: 'StartTime',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      endTime: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      siteId: 'number',
      startTime: 'string',
      status: 'string',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePurgeTasksResponseBody extends $dara.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A123425345
   */
  requestId?: string;
  /**
   * @remarks
   * The tasks.
   */
  tasks?: DescribePurgeTasksResponseBodyTasks[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 15
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      tasks: 'Tasks',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      tasks: { 'type': 'array', 'itemType': DescribePurgeTasksResponseBodyTasks },
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.tasks)) {
      $dara.Model.validateArray(this.tasks);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePurgeTasksResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePurgeTasksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePurgeTasksResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRatePlanInstanceStatusRequest extends $dara.Model {
  /**
   * @example
   * xcdn-91fknmb80f0g***
   */
  instanceId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRatePlanInstanceStatusResponseBody extends $dara.Model {
  /**
   * @example
   * xcdn-91fknmb80f0g***
   */
  instanceId?: string;
  /**
   * @example
   * running
   */
  instanceStatus?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 60423A7F-A83D-1E24-B80E-86DD25790759
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      instanceStatus: 'InstanceStatus',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      instanceStatus: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRatePlanInstanceStatusResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeRatePlanInstanceStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRatePlanInstanceStatusResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableCustomScenePolicyRequest extends $dara.Model {
  /**
   * @remarks
   * The policy ID, which can be obtained by calling the [DescribeCustomScenePolicies](https://help.aliyun.com/document_detail/2850508.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 100001
   */
  policyId?: number;
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableCustomScenePolicyResponseBody extends $dara.Model {
  /**
   * @remarks
   * The ID of the disabled policy.
   * 
   * @example
   * 100001
   */
  policyId?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9732E117-8A37-49FD-A36F-ABBB87556CA7
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'number',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableCustomScenePolicyResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DisableCustomScenePolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DisableCustomScenePolicyResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditSiteWafSettingsRequest extends $dara.Model {
  /**
   * @remarks
   * The WAF configuration of the website in the JSON format.
   */
  settings?: WafSiteSettings;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 1
   */
  siteId?: number;
  /**
   * @remarks
   * The version of the website.
   * 
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      settings: 'Settings',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      settings: WafSiteSettings,
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    if(this.settings && typeof (this.settings as any).validate === 'function') {
      (this.settings as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditSiteWafSettingsShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The WAF configuration of the website in the JSON format.
   */
  settingsShrink?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 1
   */
  siteId?: number;
  /**
   * @remarks
   * The version of the website.
   * 
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      settingsShrink: 'Settings',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      settingsShrink: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditSiteWafSettingsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditSiteWafSettingsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EditSiteWafSettingsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EditSiteWafSettingsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableCustomScenePolicyRequest extends $dara.Model {
  /**
   * @remarks
   * The policy ID, which can be obtained by calling the [DescribeCustomScenePolicies](https://help.aliyun.com/document_detail/2850508.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  policyId?: number;
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableCustomScenePolicyResponseBody extends $dara.Model {
  /**
   * @remarks
   * The policy ID.
   * 
   * @example
   * 1
   */
  policyId?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 65C66B7B-671A-8297-9187-2R5477247B76
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'number',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableCustomScenePolicyResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EnableCustomScenePolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EnableCustomScenePolicyResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportRecordsRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportRecordsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The exported DNS records.
   * 
   * @example
   * ;; site:example.com.\\n;; Exported:2024-01-24 15:54:35\\n\\n;; A Records\\na1.example.com. 30 IN A 1.1.1.1 direct\\na2.example.com. 30 IN A 1.1.1.1 direct\\na3.example.com. 30 IN A 1.1.1.1 direct\\n
   */
  content?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * C69B5894-D1BA-592C-95D0-DADBE7AEAC63
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportRecordsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExportRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExportRecordsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCacheReserveSpecificationResponseBody extends $dara.Model {
  /**
   * @remarks
   * The capacities of cache reserve instances that can be created.
   */
  cacheReserveCapacity?: string[];
  /**
   * @remarks
   * The regions in which cache reserve instances can be created.
   */
  cacheReserveRegion?: string[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      cacheReserveCapacity: 'CacheReserveCapacity',
      cacheReserveRegion: 'CacheReserveRegion',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cacheReserveCapacity: { 'type': 'array', 'itemType': 'string' },
      cacheReserveRegion: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.cacheReserveCapacity)) {
      $dara.Model.validateArray(this.cacheReserveCapacity);
    }
    if(Array.isArray(this.cacheReserveRegion)) {
      $dara.Model.validateArray(this.cacheReserveRegion);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCacheReserveSpecificationResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetCacheReserveSpecificationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCacheReserveSpecificationResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCacheRuleRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 352816096987136
   */
  configId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCacheRuleResponseBody extends $dara.Model {
  /**
   * @example
   * 2095
   */
  additionalCacheablePorts?: string;
  /**
   * @example
   * follow_origin
   */
  browserCacheMode?: string;
  /**
   * @example
   * 300
   */
  browserCacheTtl?: string;
  /**
   * @example
   * cache_all
   */
  bypassCache?: string;
  /**
   * @example
   * on
   */
  cacheDeceptionArmor?: string;
  /**
   * @example
   * bypass_cache_reserve
   */
  cacheReserveEligibility?: string;
  /**
   * @example
   * cookiename
   */
  checkPresenceCookie?: string;
  /**
   * @example
   * headername
   */
  checkPresenceHeader?: string;
  /**
   * @example
   * 352816096987136
   */
  configId?: number;
  /**
   * @example
   * global
   */
  configType?: string;
  /**
   * @example
   * follow_origin
   */
  edgeCacheMode?: string;
  /**
   * @example
   * 300
   */
  edgeCacheTtl?: string;
  /**
   * @example
   * 300
   */
  edgeStatusCodeCacheTtl?: string;
  /**
   * @example
   * cookie_exapmle
   */
  includeCookie?: string;
  /**
   * @example
   * example
   */
  includeHeader?: string;
  /**
   * @example
   * example
   */
  queryString?: string;
  /**
   * @example
   * reserve_all
   */
  queryStringMode?: string;
  /**
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  /**
   * @example
   * (http.host eq \\"video.example.com\\")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @example
   * 1
   */
  sequence?: number;
  /**
   * @example
   * on
   */
  serveStale?: string;
  /**
   * @example
   * 1
   */
  siteVersion?: number;
  /**
   * @example
   * on
   */
  sortQueryStringForCache?: string;
  /**
   * @example
   * on
   */
  userDeviceType?: string;
  /**
   * @example
   * on
   */
  userGeo?: string;
  /**
   * @example
   * on
   */
  userLanguage?: string;
  static names(): { [key: string]: string } {
    return {
      additionalCacheablePorts: 'AdditionalCacheablePorts',
      browserCacheMode: 'BrowserCacheMode',
      browserCacheTtl: 'BrowserCacheTtl',
      bypassCache: 'BypassCache',
      cacheDeceptionArmor: 'CacheDeceptionArmor',
      cacheReserveEligibility: 'CacheReserveEligibility',
      checkPresenceCookie: 'CheckPresenceCookie',
      checkPresenceHeader: 'CheckPresenceHeader',
      configId: 'ConfigId',
      configType: 'ConfigType',
      edgeCacheMode: 'EdgeCacheMode',
      edgeCacheTtl: 'EdgeCacheTtl',
      edgeStatusCodeCacheTtl: 'EdgeStatusCodeCacheTtl',
      includeCookie: 'IncludeCookie',
      includeHeader: 'IncludeHeader',
      queryString: 'QueryString',
      queryStringMode: 'QueryStringMode',
      requestId: 'RequestId',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      serveStale: 'ServeStale',
      siteVersion: 'SiteVersion',
      sortQueryStringForCache: 'SortQueryStringForCache',
      userDeviceType: 'UserDeviceType',
      userGeo: 'UserGeo',
      userLanguage: 'UserLanguage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      additionalCacheablePorts: 'string',
      browserCacheMode: 'string',
      browserCacheTtl: 'string',
      bypassCache: 'string',
      cacheDeceptionArmor: 'string',
      cacheReserveEligibility: 'string',
      checkPresenceCookie: 'string',
      checkPresenceHeader: 'string',
      configId: 'number',
      configType: 'string',
      edgeCacheMode: 'string',
      edgeCacheTtl: 'string',
      edgeStatusCodeCacheTtl: 'string',
      includeCookie: 'string',
      includeHeader: 'string',
      queryString: 'string',
      queryStringMode: 'string',
      requestId: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'number',
      serveStale: 'string',
      siteVersion: 'number',
      sortQueryStringForCache: 'string',
      userDeviceType: 'string',
      userGeo: 'string',
      userLanguage: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCacheRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetCacheRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCacheRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCacheTagRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The version number of the website.
   * 
   * @example
   * 1
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCacheTagResponseBody extends $dara.Model {
  /**
   * @remarks
   * Indicates whether the matching is not case-sensitive. Valid values:
   * 
   * *   on: The matching is not case-sensitive.
   * *   off: The matching is case-sensitive.
   * 
   * @example
   * on
   */
  caseInsensitive?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 156A6B-677B1A-4297B7-9187B7-2B44792
   */
  requestId?: string;
  /**
   * @remarks
   * The version number of the website.
   * 
   * @example
   * 1
   */
  siteVersion?: number;
  /**
   * @remarks
   * The name of the custom cache tag.
   * 
   * @example
   * example
   */
  tagName?: string;
  static names(): { [key: string]: string } {
    return {
      caseInsensitive: 'CaseInsensitive',
      requestId: 'RequestId',
      siteVersion: 'SiteVersion',
      tagName: 'TagName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      caseInsensitive: 'string',
      requestId: 'string',
      siteVersion: 'number',
      tagName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCacheTagResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetCacheTagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCacheTagResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCertificateRequest extends $dara.Model {
  /**
   * @remarks
   * The certificate ID.
   * 
   * This parameter is required.
   * 
   * @example
   * babaded901474b9693acf530e0fb1d95
   */
  id?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](~~ListSites~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCertificateResponseBody extends $dara.Model {
  /**
   * @remarks
   * The certificate content.
   * 
   * @example
   * -----BEGIN CERTIFICATE-----
   */
  certificate?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  /**
   * @remarks
   * The certificate information.
   */
  result?: GetCertificateResponseBodyResult;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  /**
   * @remarks
   * The certificate status.
   * 
   * @example
   * OK
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      certificate: 'Certificate',
      requestId: 'RequestId',
      result: 'Result',
      siteId: 'SiteId',
      siteName: 'SiteName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certificate: 'string',
      requestId: 'string',
      result: GetCertificateResponseBodyResult,
      siteId: 'number',
      siteName: 'string',
      status: 'string',
    };
  }

  validate() {
    if(this.result && typeof (this.result as any).validate === 'function') {
      (this.result as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCertificateResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCertificateResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCertificateQuotaRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * free
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCertificateQuotaResponseBody extends $dara.Model {
  /**
   * @example
   * 10
   */
  quota?: number;
  /**
   * @example
   * 5
   */
  quotaUsage?: number;
  /**
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  /**
   * @example
   * 2
   */
  siteCount?: number;
  siteUsage?: GetCertificateQuotaResponseBodySiteUsage[];
  /**
   * @example
   * free
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      quota: 'Quota',
      quotaUsage: 'QuotaUsage',
      requestId: 'RequestId',
      siteCount: 'SiteCount',
      siteUsage: 'SiteUsage',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      quota: 'number',
      quotaUsage: 'number',
      requestId: 'string',
      siteCount: 'number',
      siteUsage: { 'type': 'array', 'itemType': GetCertificateQuotaResponseBodySiteUsage },
      type: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.siteUsage)) {
      $dara.Model.validateArray(this.siteUsage);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCertificateQuotaResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetCertificateQuotaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCertificateQuotaResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientCaCertificateRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * babab9db65ee5efcca9f3d41d4b5****
   */
  id?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientCaCertificateResponseBody extends $dara.Model {
  /**
   * @example
   * -----BEGIN CERTIFICATE-----
   */
  certificate?: string;
  /**
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  result?: GetClientCaCertificateResponseBodyResult;
  /**
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @example
   * example.com
   */
  siteName?: string;
  /**
   * @example
   * OK
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      certificate: 'Certificate',
      requestId: 'RequestId',
      result: 'Result',
      siteId: 'SiteId',
      siteName: 'SiteName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certificate: 'string',
      requestId: 'string',
      result: GetClientCaCertificateResponseBodyResult,
      siteId: 'number',
      siteName: 'string',
      status: 'string',
    };
  }

  validate() {
    if(this.result && typeof (this.result as any).validate === 'function') {
      (this.result as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientCaCertificateResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetClientCaCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetClientCaCertificateResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientCertificateRequest extends $dara.Model {
  /**
   * @remarks
   * The certificate ID.
   * 
   * This parameter is required.
   * 
   * @example
   * baba39055622c008b90285a8838ed09a
   */
  id?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientCertificateResponseBody extends $dara.Model {
  /**
   * @remarks
   * The certificate content.
   * 
   * @example
   * -----BEGIN CERTIFICATE-----
   */
  certificate?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  /**
   * @remarks
   * The certificate information.
   */
  result?: GetClientCertificateResponseBodyResult;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  /**
   * @remarks
   * The certificate status.
   * 
   * @example
   * active
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      certificate: 'Certificate',
      requestId: 'RequestId',
      result: 'Result',
      siteId: 'SiteId',
      siteName: 'SiteName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certificate: 'string',
      requestId: 'string',
      result: GetClientCertificateResponseBodyResult,
      siteId: 'number',
      siteName: 'string',
      status: 'string',
    };
  }

  validate() {
    if(this.result && typeof (this.result as any).validate === 'function') {
      (this.result as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientCertificateResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetClientCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetClientCertificateResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientCertificateHostnamesRequest extends $dara.Model {
  /**
   * @remarks
   * The certificate ID.
   * 
   * @example
   * baba39055622c008b90285a8838ed09a
   */
  id?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientCertificateHostnamesResponseBody extends $dara.Model {
  /**
   * @remarks
   * The domain names with which the certificate is associated.
   */
  hostnames?: string[];
  /**
   * @remarks
   * The ID of the client CA certificate.
   * 
   * @example
   * baba39055622c008b90285a8838ed09a
   */
  id?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  static names(): { [key: string]: string } {
    return {
      hostnames: 'Hostnames',
      id: 'Id',
      requestId: 'RequestId',
      siteId: 'SiteId',
      siteName: 'SiteName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hostnames: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      requestId: 'string',
      siteId: 'number',
      siteName: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.hostnames)) {
      $dara.Model.validateArray(this.hostnames);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientCertificateHostnamesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetClientCertificateHostnamesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetClientCertificateHostnamesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCnameFlatteningRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCnameFlatteningResponseBody extends $dara.Model {
  /**
   * @remarks
   * The CNAME flattening mode. Valid values:
   * 
   * *   flatten_all: flattens all CNAMEs.
   * *   flatten_all (default): flattens only the root domain.
   * 
   * @example
   * flatten_all
   */
  flattenMode?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F61CDR30-E83C-4FDA-BF73-9A94CDD44229
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      flattenMode: 'FlattenMode',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flattenMode: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCnameFlatteningResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetCnameFlatteningResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCnameFlatteningResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCompressionRuleRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 34003500310****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCompressionRuleResponseBody extends $dara.Model {
  /**
   * @example
   * on
   */
  brotli?: string;
  /**
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @example
   * rule
   */
  configType?: string;
  /**
   * @example
   * on
   */
  gzip?: string;
  /**
   * @example
   * 186C6DF2-D96A-5102-B04E-FB92C16C9867
   */
  requestId?: string;
  /**
   * @example
   * (http.host eq "video.example.com")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @example
   * 1
   */
  sequence?: number;
  /**
   * @example
   * 0
   */
  siteVersion?: number;
  zstd?: string;
  static names(): { [key: string]: string } {
    return {
      brotli: 'Brotli',
      configId: 'ConfigId',
      configType: 'ConfigType',
      gzip: 'Gzip',
      requestId: 'RequestId',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      siteVersion: 'SiteVersion',
      zstd: 'Zstd',
    };
  }

  static types(): { [key: string]: any } {
    return {
      brotli: 'string',
      configId: 'number',
      configType: 'string',
      gzip: 'string',
      requestId: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'number',
      siteVersion: 'number',
      zstd: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCompressionRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetCompressionRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCompressionRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDevelopmentModeRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 5407498413****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDevelopmentModeResponseBody extends $dara.Model {
  /**
   * @remarks
   * Indicates whether the development mode is enabled. Valid values:
   * 
   * *   **on**
   * *   **off**
   * 
   * @example
   * on
   */
  enable?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 156A6B-677B1A-4297B7-9187B7-2B44792
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDevelopmentModeResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDevelopmentModeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDevelopmentModeResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppRequest extends $dara.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppResponseBody extends $dara.Model {
  /**
   * @remarks
   * The basic information about the application.
   */
  app?: GetEdgeContainerAppResponseBodyApp;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 156A6B-677B1A-4297B7-9187B7-2B44792
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      app: 'App',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      app: GetEdgeContainerAppResponseBodyApp,
      requestId: 'string',
    };
  }

  validate() {
    if(this.app && typeof (this.app as any).validate === 'function') {
      (this.app as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetEdgeContainerAppResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetEdgeContainerAppResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppStatusRequest extends $dara.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The release environment. Valid values: prod and staging.
   * 
   * @example
   * staging
   */
  publishEnv?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      publishEnv: 'PublishEnv',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      publishEnv: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppStatusResponseBody extends $dara.Model {
  /**
   * @remarks
   * The status of the application.
   */
  appStatus?: GetEdgeContainerAppStatusResponseBodyAppStatus;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247B78
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      appStatus: 'AppStatus',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appStatus: GetEdgeContainerAppStatusResponseBodyAppStatus,
      requestId: 'string',
    };
  }

  validate() {
    if(this.appStatus && typeof (this.appStatus as any).validate === 'function') {
      (this.appStatus as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppStatusResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetEdgeContainerAppStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetEdgeContainerAppStatusResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppVersionRequest extends $dara.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The version ID, which can be obtained by calling the [ListEdgeContainerAppVersions](~~ListEdgeContainerAppVersions~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * ver-87962637161651****
   */
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      versionId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppVersionResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the version.
   */
  version?: GetEdgeContainerAppVersionResponseBodyVersion;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      version: GetEdgeContainerAppVersionResponseBodyVersion,
    };
  }

  validate() {
    if(this.version && typeof (this.version as any).validate === 'function') {
      (this.version as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerAppVersionResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetEdgeContainerAppVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetEdgeContainerAppVersionResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerDeployRegionsRequest extends $dara.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * @example
   * GetEdgeContainerDeployRegions
   */
  appId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerDeployRegionsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The regions.
   */
  regions?: string[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      regions: 'Regions',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regions: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.regions)) {
      $dara.Model.validateArray(this.regions);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerDeployRegionsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetEdgeContainerDeployRegionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetEdgeContainerDeployRegionsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerLogsRequest extends $dara.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The number of log entries to output.
   * 
   * This parameter is required.
   * 
   * @example
   * 500
   */
  lines?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      lines: 'Lines',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      lines: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerLogsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The logs.
   */
  items?: string[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247B78
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.items)) {
      $dara.Model.validateArray(this.items);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerLogsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetEdgeContainerLogsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetEdgeContainerLogsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerStagingDeployStatusRequest extends $dara.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * @example
   * GetEdgeContainerStagingDeployStatus
   */
  appId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerStagingDeployStatusResponseBody extends $dara.Model {
  /**
   * @remarks
   * Indicates whether the container is ready.
   * 
   * *   ok
   * *   unready
   * 
   * @example
   * ok
   */
  containersReady?: string;
  /**
   * @remarks
   * The time when the container was created. The value is a timestamp.
   * 
   * @example
   * 2024-09-24T06:46:35Z
   */
  creationTimestamp?: string;
  /**
   * @remarks
   * The initialization status of the container.
   * 
   * *   ok
   * *   unready
   * 
   * @example
   * ok
   */
  initialized?: string;
  /**
   * @remarks
   * The status of the container in the staging environment.
   * 
   * *   NoContainer: created.
   * *   Running: running.
   * *   Failed: abnormal.
   * 
   * @example
   * Running
   */
  phase?: string;
  /**
   * @remarks
   * The details of container restart.
   */
  podRestartState?: GetEdgeContainerStagingDeployStatusResponseBodyPodRestartState;
  /**
   * @remarks
   * Indicates whether domain names are associated with the container.
   * 
   * *   ok
   * *   unready
   * 
   * @example
   * ok
   */
  ready?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2F2C992B-3FE2-5EBB-A61F-F9DD4EB257DA
   */
  requestId?: string;
  /**
   * @remarks
   * The scheduling status of the container.
   * 
   * *   ok
   * *   unready
   * 
   * @example
   * ok
   */
  scheduled?: string;
  /**
   * @remarks
   * The virtual IP addresses.
   */
  VIPs?: string[];
  static names(): { [key: string]: string } {
    return {
      containersReady: 'ContainersReady',
      creationTimestamp: 'CreationTimestamp',
      initialized: 'Initialized',
      phase: 'Phase',
      podRestartState: 'PodRestartState',
      ready: 'Ready',
      requestId: 'RequestId',
      scheduled: 'Scheduled',
      VIPs: 'VIPs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      containersReady: 'string',
      creationTimestamp: 'string',
      initialized: 'string',
      phase: 'string',
      podRestartState: GetEdgeContainerStagingDeployStatusResponseBodyPodRestartState,
      ready: 'string',
      requestId: 'string',
      scheduled: 'string',
      VIPs: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(this.podRestartState && typeof (this.podRestartState as any).validate === 'function') {
      (this.podRestartState as any).validate();
    }
    if(Array.isArray(this.VIPs)) {
      $dara.Model.validateArray(this.VIPs);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerStagingDeployStatusResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetEdgeContainerStagingDeployStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetEdgeContainerStagingDeployStatusResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerTerminalRequest extends $dara.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerTerminalResponseBody extends $dara.Model {
  /**
   * @remarks
   * The cluster name.
   * 
   * @example
   * c497b44c2a59f4ae0bd2826edc40a2c6e
   */
  cluster?: string;
  /**
   * @remarks
   * The container name.
   * 
   * @example
   * worker0
   */
  container?: string;
  /**
   * @remarks
   * The name of the namespace.
   * 
   * @example
   * ns1
   */
  namespace?: string;
  /**
   * @remarks
   * The name of the container group.
   * 
   * @example
   * 1775b9e0-8463-457e-89e8-fb7b6d125b2e
   */
  pod?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9732E117-8A37-49FD-A36F-ABBB87556CA7
   */
  requestId?: string;
  /**
   * @remarks
   * The session ID.
   * 
   * @example
   * af22f4xxxxxxxxxxxxxxxxxx
   */
  sessionId?: string;
  /**
   * @remarks
   * The information about the shared token.
   * 
   * @example
   * af22f4-xxxxx-xxxx-xxxx-xxxx
   */
  token?: string;
  static names(): { [key: string]: string } {
    return {
      cluster: 'Cluster',
      container: 'Container',
      namespace: 'Namespace',
      pod: 'Pod',
      requestId: 'RequestId',
      sessionId: 'SessionId',
      token: 'Token',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cluster: 'string',
      container: 'string',
      namespace: 'string',
      pod: 'string',
      requestId: 'string',
      sessionId: 'string',
      token: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetEdgeContainerTerminalResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetEdgeContainerTerminalResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetEdgeContainerTerminalResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHttpRequestHeaderModificationRuleRequest extends $dara.Model {
  /**
   * @remarks
   * The configuration ID, which can be obtained by calling the [ListHttpRequestHeaderModificationRules](~~ListHttpRequestHeaderModificationRules~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 3528160969****
   */
  configId?: number;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHttpRequestHeaderModificationRuleResponseBody extends $dara.Model {
  /**
   * @remarks
   * The configuration ID.
   * 
   * @example
   * 3528160969****
   */
  configId?: number;
  /**
   * @remarks
   * The configuration type. Valid values:
   * 
   * *   global: global configuration.
   * *   rule: rule configuration.
   * 
   * @example
   * global
   */
  configType?: string;
  /**
   * @remarks
   * The configurations of modifying request headers. You can add, delete, or modify a request header.
   */
  requestHeaderModification?: GetHttpRequestHeaderModificationRuleResponseBodyRequestHeaderModification[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  /**
   * @remarks
   * The rule content.
   * 
   * @example
   * (http.host eq "video.example.com")
   */
  rule?: string;
  /**
   * @remarks
   * Indicates whether the rule is enabled. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @remarks
   * The rule name.
   * 
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * The order in which the rule is executed.
   * 
   * @example
   * 1
   */
  sequence?: number;
  /**
   * @remarks
   * The version number of the website configurations.
   * 
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      configType: 'ConfigType',
      requestHeaderModification: 'RequestHeaderModification',
      requestId: 'RequestId',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      configType: 'string',
      requestHeaderModification: { 'type': 'array', 'itemType': GetHttpRequestHeaderModificationRuleResponseBodyRequestHeaderModification },
      requestId: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.requestHeaderModification)) {
      $dara.Model.validateArray(this.requestHeaderModification);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHttpRequestHeaderModificationRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetHttpRequestHeaderModificationRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetHttpRequestHeaderModificationRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHttpResponseHeaderModificationRuleRequest extends $dara.Model {
  /**
   * @remarks
   * The configuration ID, which can be obtained by calling the [ListHttpResponseHeaderModificationRules](~~ListHttpResponseHeaderModificationRules~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHttpResponseHeaderModificationRuleResponseBody extends $dara.Model {
  /**
   * @remarks
   * The configuration ID.
   * 
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @remarks
   * The configuration type. Valid values:
   * 
   * *   global: global configuration.
   * *   rule: rule configuration.
   * 
   * @example
   * rule
   */
  configType?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  /**
   * @remarks
   * The configurations of modifying response headers. You can add, delete, or modify a response header.
   */
  responseHeaderModification?: GetHttpResponseHeaderModificationRuleResponseBodyResponseHeaderModification[];
  /**
   * @remarks
   * The rule content.
   * 
   * @example
   * (http.host eq "video.example.com")
   */
  rule?: string;
  /**
   * @remarks
   * Indicates whether the rule is enabled. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @remarks
   * The rule name.
   * 
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * The order in which the rule is executed.
   * 
   * @example
   * 1
   */
  sequence?: number;
  /**
   * @remarks
   * The version number of the website configurations.
   * 
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      configType: 'ConfigType',
      requestId: 'RequestId',
      responseHeaderModification: 'ResponseHeaderModification',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      configType: 'string',
      requestId: 'string',
      responseHeaderModification: { 'type': 'array', 'itemType': GetHttpResponseHeaderModificationRuleResponseBodyResponseHeaderModification },
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.responseHeaderModification)) {
      $dara.Model.validateArray(this.responseHeaderModification);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHttpResponseHeaderModificationRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetHttpResponseHeaderModificationRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetHttpResponseHeaderModificationRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHttpsApplicationConfigurationRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 352816096987136
   */
  configId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHttpsApplicationConfigurationResponseBody extends $dara.Model {
  /**
   * @example
   * on
   */
  altSvc?: string;
  /**
   * @example
   * on
   */
  altSvcClear?: string;
  /**
   * @example
   * 86400
   */
  altSvcMa?: string;
  /**
   * @example
   * on
   */
  altSvcPersist?: string;
  /**
   * @example
   * 352816096987136
   */
  configId?: number;
  /**
   * @example
   * global
   */
  configType?: string;
  /**
   * @example
   * on
   */
  hsts?: string;
  /**
   * @example
   * on
   */
  hstsIncludeSubdomains?: string;
  /**
   * @example
   * 3600
   */
  hstsMaxAge?: string;
  /**
   * @example
   * on
   */
  hstsPreload?: string;
  /**
   * @example
   * on
   */
  httpsForce?: string;
  /**
   * @example
   * 301
   */
  httpsForceCode?: string;
  /**
   * @example
   * A3790430-3A06-535F-A424-0998BD9A6C9F
   */
  requestId?: string;
  /**
   * @example
   * (http.host eq \\"video.example.com\\")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @example
   * 1
   */
  sequence?: number;
  /**
   * @example
   * 1
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      altSvc: 'AltSvc',
      altSvcClear: 'AltSvcClear',
      altSvcMa: 'AltSvcMa',
      altSvcPersist: 'AltSvcPersist',
      configId: 'ConfigId',
      configType: 'ConfigType',
      hsts: 'Hsts',
      hstsIncludeSubdomains: 'HstsIncludeSubdomains',
      hstsMaxAge: 'HstsMaxAge',
      hstsPreload: 'HstsPreload',
      httpsForce: 'HttpsForce',
      httpsForceCode: 'HttpsForceCode',
      requestId: 'RequestId',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      altSvc: 'string',
      altSvcClear: 'string',
      altSvcMa: 'string',
      altSvcPersist: 'string',
      configId: 'number',
      configType: 'string',
      hsts: 'string',
      hstsIncludeSubdomains: 'string',
      hstsMaxAge: 'string',
      hstsPreload: 'string',
      httpsForce: 'string',
      httpsForceCode: 'string',
      requestId: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHttpsApplicationConfigurationResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetHttpsApplicationConfigurationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetHttpsApplicationConfigurationResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHttpsBasicConfigurationRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 352816096987136
   */
  configId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHttpsBasicConfigurationResponseBody extends $dara.Model {
  /**
   * @example
   * TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
   */
  ciphersuite?: string;
  /**
   * @example
   * all
   */
  ciphersuiteGroup?: string;
  /**
   * @example
   * 352816096987136
   */
  configId?: number;
  /**
   * @example
   * global
   */
  configType?: string;
  /**
   * @example
   * on
   */
  http2?: string;
  /**
   * @example
   * on
   */
  http3?: string;
  /**
   * @example
   * on
   */
  https?: string;
  /**
   * @example
   * on
   */
  ocspStapling?: string;
  /**
   * @example
   * C370DAF1-C838-4288-A1A0-9A87633D2***
   */
  requestId?: string;
  /**
   * @example
   * (http.host eq \\"video.example.com\\")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @example
   * 1
   */
  sequence?: number;
  /**
   * @example
   * on
   */
  tls10?: string;
  /**
   * @example
   * on
   */
  tls11?: string;
  /**
   * @example
   * on
   */
  tls12?: string;
  /**
   * @example
   * on
   */
  tls13?: string;
  static names(): { [key: string]: string } {
    return {
      ciphersuite: 'Ciphersuite',
      ciphersuiteGroup: 'CiphersuiteGroup',
      configId: 'ConfigId',
      configType: 'ConfigType',
      http2: 'Http2',
      http3: 'Http3',
      https: 'Https',
      ocspStapling: 'OcspStapling',
      requestId: 'RequestId',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      tls10: 'Tls10',
      tls11: 'Tls11',
      tls12: 'Tls12',
      tls13: 'Tls13',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ciphersuite: 'string',
      ciphersuiteGroup: 'string',
      configId: 'number',
      configType: 'string',
      http2: 'string',
      http3: 'string',
      https: 'string',
      ocspStapling: 'string',
      requestId: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'number',
      tls10: 'string',
      tls11: 'string',
      tls12: 'string',
      tls13: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHttpsBasicConfigurationResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetHttpsBasicConfigurationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetHttpsBasicConfigurationResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetIPv6Request extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456789****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetIPv6ResponseBody extends $dara.Model {
  /**
   * @example
   * on
   */
  enable?: string;
  /**
   * @example
   * 156A6B-677B1A-4297B7-9187B7-2B44792
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetIPv6Response extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetIPv6ResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetIPv6ResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetImageTransformRequest extends $dara.Model {
  /**
   * @remarks
   * The configuration ID, which can be obtained by calling the [ListImageTransforms](~~ListImageTransforms~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 352816096987136
   */
  configId?: number;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetImageTransformResponseBody extends $dara.Model {
  /**
   * @remarks
   * The configuration ID.
   * 
   * @example
   * 352816096987136
   */
  configId?: number;
  /**
   * @remarks
   * The configuration type. Valid values:
   * 
   * *   global: global configuration.
   * *   rule: rule configuration.
   * 
   * @example
   * global
   */
  configType?: string;
  /**
   * @remarks
   * Indicates whether the image transformations feature is enabled. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  enable?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CB1A380B-09F0-41BB-280B-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @remarks
   * The rule content, which is a policy or conditional expression.
   * 
   * @example
   * (http.request.uri.path.file_name eq \\"jpg\\")
   */
  rule?: string;
  /**
   * @remarks
   * Indicates whether the rule is enabled. Valid values:
   * 
   * *   **on**
   * *   **off**
   * 
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @remarks
   * The rule name.
   * 
   * @example
   * test
   */
  ruleName?: string;
  /**
   * @remarks
   * The order in which the rule is executed.
   * 
   * @example
   * 2
   */
  sequence?: number;
  /**
   * @remarks
   * The version number of the website.
   * 
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      configType: 'ConfigType',
      enable: 'Enable',
      requestId: 'RequestId',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      configType: 'string',
      enable: 'string',
      requestId: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetImageTransformResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetImageTransformResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetImageTransformResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetKvRequest extends $dara.Model {
  /**
   * @remarks
   * Specifies whether to decode the value by using Base 64. If you call the [PutKv](https://help.aliyun.com/document_detail/2850482.html) operation and set the Base64 parameter to true, set this parameter to true to read the original content.
   * 
   * @example
   * true
   */
  base64?: boolean;
  /**
   * @remarks
   * The key name for the query.
   * 
   * This parameter is required.
   * 
   * @example
   * test_key
   */
  key?: string;
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      base64: 'Base64',
      key: 'Key',
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      base64: 'boolean',
      key: 'string',
      namespace: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetKvResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * The value of the key.
   * 
   * @example
   * test_value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      value: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetKvResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetKvResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetKvResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetKvAccountResponseBody extends $dara.Model {
  /**
   * @remarks
   * The available capacity of all namespaces in the account. Unit: bytes.
   * 
   * @example
   * 1073741824
   */
  capacity?: number;
  /**
   * @remarks
   * The available capacity of all namespaces in the account.
   * 
   * @example
   * 1 GB
   */
  capacityString?: string;
  /**
   * @remarks
   * The used capacity of all namespaces in the account. Unit: bytes.
   * 
   * @example
   * 10048576
   */
  capacityUsed?: number;
  /**
   * @remarks
   * The used capacity of all namespaces in the account.
   * 
   * @example
   * 100 MB
   */
  capacityUsedString?: string;
  /**
   * @remarks
   * The namespaces in the account.
   */
  namespaceList?: GetKvAccountResponseBodyNamespaceList[];
  /**
   * @remarks
   * The maximum number of namespaces that can be created in the account.
   * 
   * @example
   * 10
   */
  namespaceQuota?: number;
  /**
   * @remarks
   * The number of created namespaces that store key-value data in the account.
   * 
   * @example
   * 1
   */
  namespaceUsed?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether Edge KV is activated for the Alibaba Cloud account.
   * 
   * *   **online**
   * *   **offline**
   * 
   * @example
   * online
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      capacity: 'Capacity',
      capacityString: 'CapacityString',
      capacityUsed: 'CapacityUsed',
      capacityUsedString: 'CapacityUsedString',
      namespaceList: 'NamespaceList',
      namespaceQuota: 'NamespaceQuota',
      namespaceUsed: 'NamespaceUsed',
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacity: 'number',
      capacityString: 'string',
      capacityUsed: 'number',
      capacityUsedString: 'string',
      namespaceList: { 'type': 'array', 'itemType': GetKvAccountResponseBodyNamespaceList },
      namespaceQuota: 'number',
      namespaceUsed: 'number',
      requestId: 'string',
      status: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.namespaceList)) {
      $dara.Model.validateArray(this.namespaceList);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetKvAccountResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetKvAccountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetKvAccountResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetKvNamespaceRequest extends $dara.Model {
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  static names(): { [key: string]: string } {
    return {
      namespace: 'Namespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      namespace: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetKvNamespaceResponseBody extends $dara.Model {
  /**
   * @remarks
   * The available capacity of the namespace. Unit: bytes.
   * 
   * @example
   * 1073741824
   */
  capacity?: number;
  /**
   * @remarks
   * The available capacity of the namespace.
   * 
   * @example
   * 1 GB
   */
  capacityString?: string;
  /**
   * @remarks
   * The used capacity of the namespace. Unit: bytes.
   * 
   * @example
   * 10048576
   */
  capacityUsed?: number;
  /**
   * @remarks
   * The used capacity of the namespace.
   * 
   * @example
   * 100 MB
   */
  capacityUsedString?: string;
  /**
   * @remarks
   * The description of the namespace.
   * 
   * @example
   * this is a test namespace.
   */
  description?: string;
  /**
   * @remarks
   * The name of the namespace.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  /**
   * @remarks
   * The ID of the namespace.
   * 
   * @example
   * 643355322374688768
   */
  namespaceId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * The status of the namespace. Valid values:
   * 
   * *   **online**: working as expected.
   * *   **delete**: pending deletion.
   * *   **deleting**: being deleted.
   * *   **deleted**: deleted.
   * 
   * @example
   * online
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      capacity: 'Capacity',
      capacityString: 'CapacityString',
      capacityUsed: 'CapacityUsed',
      capacityUsedString: 'CapacityUsedString',
      description: 'Description',
      namespace: 'Namespace',
      namespaceId: 'NamespaceId',
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      capacity: 'number',
      capacityString: 'string',
      capacityUsed: 'number',
      capacityUsedString: 'string',
      description: 'string',
      namespace: 'string',
      namespaceId: 'string',
      requestId: 'string',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetKvNamespaceResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetKvNamespaceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetKvNamespaceResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetListRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the custom list, which can be obtained by calling the [ListLists](https://help.aliyun.com/document_detail/2850217.html) operation.
   * 
   * @example
   * 40000001
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetListResponseBody extends $dara.Model {
  /**
   * @remarks
   * The description of the custom list.
   * 
   * @example
   * a custom list
   */
  description?: string;
  /**
   * @remarks
   * The ID of the custom list.[](~~2850217~~)
   * 
   * @example
   * 40000001
   */
  id?: number;
  /**
   * @remarks
   * The items in the custom list, which are displayed as an array.
   */
  items?: string[];
  /**
   * @remarks
   * The type of the custom list.
   * 
   * @example
   * ip
   */
  kind?: string;
  /**
   * @remarks
   * The name of the custom list.
   * 
   * This parameter is required.
   * 
   * @example
   * example
   */
  name?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  /**
   * @remarks
   * The time when the custom list was last modified.
   * 
   * @example
   * 2024-01-01T00:00:00Z
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      id: 'Id',
      items: 'Items',
      kind: 'Kind',
      name: 'Name',
      requestId: 'RequestId',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      id: 'number',
      items: { 'type': 'array', 'itemType': 'string' },
      kind: 'string',
      name: 'string',
      requestId: 'string',
      updateTime: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.items)) {
      $dara.Model.validateArray(this.items);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetListResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetListResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLoadBalancerRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * GetLoadBalancer
   */
  id?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1159101787****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLoadBalancerResponseBody extends $dara.Model {
  adaptiveRouting?: GetLoadBalancerResponseBodyAdaptiveRouting;
  defaultPools?: number[];
  /**
   * @example
   * test
   */
  description?: string;
  /**
   * @example
   * true
   */
  enabled?: boolean;
  /**
   * @example
   * 96228666776****
   */
  fallbackPool?: number;
  /**
   * @example
   * 99867648760****
   */
  id?: number;
  monitor?: GetLoadBalancerResponseBodyMonitor;
  /**
   * @example
   * lb.example.com
   */
  name?: string;
  randomSteering?: GetLoadBalancerResponseBodyRandomSteering;
  /**
   * @example
   * {
   *   "ENAM": [
   *     12345678****
   *   ],
   *   "WNAM": [
   *     23456789****,
   *     23456789****
   *   ]
   * }
   */
  regionPools?: any;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  rules?: GetLoadBalancerResponseBodyRules[];
  /**
   * @remarks
   * Session persistence. Valid values:
   * 
   * *   off: disables session persistence.
   * *   ip: enables session persistence by IP address.
   * *   cookie: disables session persistence.
   * 
   * @example
   * ip
   */
  sessionAffinity?: string;
  /**
   * @example
   * 11591017874****
   */
  siteId?: number;
  /**
   * @example
   * healthy
   */
  status?: string;
  /**
   * @example
   * order
   */
  steeringPolicy?: string;
  /**
   * @example
   * {"AL,MO": [92298024898****],"CN-SH,CN-SX,CN-SC":[92304347804****,92843536908****]}
   */
  subRegionPools?: any;
  /**
   * @example
   * 60
   */
  ttl?: number;
  static names(): { [key: string]: string } {
    return {
      adaptiveRouting: 'AdaptiveRouting',
      defaultPools: 'DefaultPools',
      description: 'Description',
      enabled: 'Enabled',
      fallbackPool: 'FallbackPool',
      id: 'Id',
      monitor: 'Monitor',
      name: 'Name',
      randomSteering: 'RandomSteering',
      regionPools: 'RegionPools',
      requestId: 'RequestId',
      rules: 'Rules',
      sessionAffinity: 'SessionAffinity',
      siteId: 'SiteId',
      status: 'Status',
      steeringPolicy: 'SteeringPolicy',
      subRegionPools: 'SubRegionPools',
      ttl: 'Ttl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adaptiveRouting: GetLoadBalancerResponseBodyAdaptiveRouting,
      defaultPools: { 'type': 'array', 'itemType': 'number' },
      description: 'string',
      enabled: 'boolean',
      fallbackPool: 'number',
      id: 'number',
      monitor: GetLoadBalancerResponseBodyMonitor,
      name: 'string',
      randomSteering: GetLoadBalancerResponseBodyRandomSteering,
      regionPools: 'any',
      requestId: 'string',
      rules: { 'type': 'array', 'itemType': GetLoadBalancerResponseBodyRules },
      sessionAffinity: 'string',
      siteId: 'number',
      status: 'string',
      steeringPolicy: 'string',
      subRegionPools: 'any',
      ttl: 'number',
    };
  }

  validate() {
    if(this.adaptiveRouting && typeof (this.adaptiveRouting as any).validate === 'function') {
      (this.adaptiveRouting as any).validate();
    }
    if(Array.isArray(this.defaultPools)) {
      $dara.Model.validateArray(this.defaultPools);
    }
    if(this.monitor && typeof (this.monitor as any).validate === 'function') {
      (this.monitor as any).validate();
    }
    if(this.randomSteering && typeof (this.randomSteering as any).validate === 'function') {
      (this.randomSteering as any).validate();
    }
    if(Array.isArray(this.rules)) {
      $dara.Model.validateArray(this.rules);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLoadBalancerResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetLoadBalancerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetLoadBalancerResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetManagedTransformRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The version number of the website. You can use this parameter to specify a version of your website to apply the feature settings. By default, version 0 is used.
   * 
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetManagedTransformResponseBody extends $dara.Model {
  /**
   * @remarks
   * Indicates whether to include the header that indicates the geographical location of a client in an origin request. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  addClientGeolocationHeader?: string;
  /**
   * @remarks
   * Indicates whether to include the "ali-real-client-ip" header that contains the client\\"s real IP address in an origin request. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  addRealClientIpHeader?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  /**
   * @remarks
   * The version number of the website.
   * 
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      addClientGeolocationHeader: 'AddClientGeolocationHeader',
      addRealClientIpHeader: 'AddRealClientIpHeader',
      requestId: 'RequestId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addClientGeolocationHeader: 'string',
      addRealClientIpHeader: 'string',
      requestId: 'string',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetManagedTransformResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetManagedTransformResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetManagedTransformResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNetworkOptimizationRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 12312312213212
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNetworkOptimizationResponseBody extends $dara.Model {
  /**
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @example
   * global
   */
  configType?: string;
  /**
   * @example
   * on
   */
  grpc?: string;
  /**
   * @example
   * on
   */
  http2Origin?: string;
  /**
   * @example
   * C370DAF1-C838-4288-A1A0-9A87633D248E
   */
  requestId?: string;
  /**
   * @example
   * (http.host eq \\"video.example.com\\")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @example
   * 2
   */
  sequence?: number;
  /**
   * @example
   * 1
   */
  siteVersion?: number;
  /**
   * @example
   * on
   */
  smartRouting?: string;
  /**
   * @example
   * 500
   */
  uploadMaxFilesize?: string;
  /**
   * @example
   * on
   */
  websocket?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      configType: 'ConfigType',
      grpc: 'Grpc',
      http2Origin: 'Http2Origin',
      requestId: 'RequestId',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      siteVersion: 'SiteVersion',
      smartRouting: 'SmartRouting',
      uploadMaxFilesize: 'UploadMaxFilesize',
      websocket: 'Websocket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      configType: 'string',
      grpc: 'string',
      http2Origin: 'string',
      requestId: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'number',
      siteVersion: 'number',
      smartRouting: 'string',
      uploadMaxFilesize: 'string',
      websocket: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNetworkOptimizationResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetNetworkOptimizationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetNetworkOptimizationResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginPoolRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * GetOriginPool
   */
  id?: number;
  /**
   * @remarks
   * This parameter is required.
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginPoolResponseBody extends $dara.Model {
  enabled?: boolean;
  id?: number;
  name?: string;
  origins?: GetOriginPoolResponseBodyOrigins[];
  recordName?: string;
  referenceLBCount?: number;
  references?: GetOriginPoolResponseBodyReferences;
  /**
   * @remarks
   * Id of the request
   */
  requestId?: string;
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      enabled: 'Enabled',
      id: 'Id',
      name: 'Name',
      origins: 'Origins',
      recordName: 'RecordName',
      referenceLBCount: 'ReferenceLBCount',
      references: 'References',
      requestId: 'RequestId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      id: 'number',
      name: 'string',
      origins: { 'type': 'array', 'itemType': GetOriginPoolResponseBodyOrigins },
      recordName: 'string',
      referenceLBCount: 'number',
      references: GetOriginPoolResponseBodyReferences,
      requestId: 'string',
      siteId: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.origins)) {
      $dara.Model.validateArray(this.origins);
    }
    if(this.references && typeof (this.references as any).validate === 'function') {
      (this.references as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginPoolResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetOriginPoolResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOriginPoolResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginProtectionRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456789****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginProtectionResponseBody extends $dara.Model {
  /**
   * @remarks
   * The IP whitelist for origin protection used by the website.
   */
  currentIPWhitelist?: GetOriginProtectionResponseBodyCurrentIPWhitelist;
  /**
   * @remarks
   * The IP whitelist for origin protection that has been updated.
   */
  diffIPWhitelist?: GetOriginProtectionResponseBodyDiffIPWhitelist;
  /**
   * @remarks
   * The latest IP whitelist for origin protection.
   */
  latestIPWhitelist?: GetOriginProtectionResponseBodyLatestIPWhitelist;
  /**
   * @remarks
   * Indicates whether the IP whitelist for origin protection needs to be updated. If the currently used IP whitelist is different from the latest IP whitelist, it needs to be updated, and the value is true.
   * 
   * *   true: The update is required.
   * *   false: No update is required.
   * 
   * @example
   * true
   */
  needUpdate?: boolean;
  /**
   * @remarks
   * Indicates whether IP convergence is enabled.
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  originConverge?: string;
  /**
   * @remarks
   * Indicates whether origin protection is enabled.
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  originProtection?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CB1A380B-09F0-41BB-A198-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      currentIPWhitelist: 'CurrentIPWhitelist',
      diffIPWhitelist: 'DiffIPWhitelist',
      latestIPWhitelist: 'LatestIPWhitelist',
      needUpdate: 'NeedUpdate',
      originConverge: 'OriginConverge',
      originProtection: 'OriginProtection',
      requestId: 'RequestId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentIPWhitelist: GetOriginProtectionResponseBodyCurrentIPWhitelist,
      diffIPWhitelist: GetOriginProtectionResponseBodyDiffIPWhitelist,
      latestIPWhitelist: GetOriginProtectionResponseBodyLatestIPWhitelist,
      needUpdate: 'boolean',
      originConverge: 'string',
      originProtection: 'string',
      requestId: 'string',
      siteId: 'number',
    };
  }

  validate() {
    if(this.currentIPWhitelist && typeof (this.currentIPWhitelist as any).validate === 'function') {
      (this.currentIPWhitelist as any).validate();
    }
    if(this.diffIPWhitelist && typeof (this.diffIPWhitelist as any).validate === 'function') {
      (this.diffIPWhitelist as any).validate();
    }
    if(this.latestIPWhitelist && typeof (this.latestIPWhitelist as any).validate === 'function') {
      (this.latestIPWhitelist as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginProtectionResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetOriginProtectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOriginProtectionResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginRuleRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 33793140540****
   */
  configId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 3400350********
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginRuleResponseBody extends $dara.Model {
  /**
   * @example
   * 352816096987136
   */
  configId?: number;
  /**
   * @example
   * rule
   */
  configType?: string;
  /**
   * @example
   * test.example.com
   */
  dnsRecord?: string;
  /**
   * @example
   * origin.example.com
   */
  originHost?: string;
  /**
   * @example
   * 8080
   */
  originHttpPort?: string;
  /**
   * @example
   * 4433
   */
  originHttpsPort?: string;
  /**
   * @example
   * http
   */
  originScheme?: string;
  /**
   * @example
   * origin.example.com
   */
  originSni?: string;
  /**
   * @example
   * on
   */
  range?: string;
  /**
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  /**
   * @example
   * (http.host eq \\"video.example.com\\")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @example
   * 1
   */
  sequence?: number;
  /**
   * @example
   * 1
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      configType: 'ConfigType',
      dnsRecord: 'DnsRecord',
      originHost: 'OriginHost',
      originHttpPort: 'OriginHttpPort',
      originHttpsPort: 'OriginHttpsPort',
      originScheme: 'OriginScheme',
      originSni: 'OriginSni',
      range: 'Range',
      requestId: 'RequestId',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      configType: 'string',
      dnsRecord: 'string',
      originHost: 'string',
      originHttpPort: 'string',
      originHttpsPort: 'string',
      originScheme: 'string',
      originSni: 'string',
      range: 'string',
      requestId: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOriginRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetOriginRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOriginRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPageRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the custom error page, which can be obtained by calling the [ListPages](https://help.aliyun.com/document_detail/2850223.html) operation.
   * 
   * @example
   * 50000001
   */
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPageResponseBody extends $dara.Model {
  /**
   * @remarks
   * The Base64-encoded content of the error page. The content type is specified by the Content-Type field.
   * 
   * This parameter is required.
   * 
   * @example
   * PGh0bWw+aGVsbG8gcGFnZTwvaHRtbD4=
   */
  content?: string;
  /**
   * @remarks
   * The Content-Type field in the HTTP header.
   * 
   * This parameter is required.
   * 
   * @example
   * text/html
   */
  contentType?: string;
  /**
   * @remarks
   * The description of the custom error page.
   * 
   * @example
   * a custom deny page
   */
  description?: string;
  /**
   * @remarks
   * The ID of the custom error page.[](~~2850223~~)
   * 
   * @example
   * 50000001
   */
  id?: number;
  /**
   * @remarks
   * The type of the custom response page.
   * 
   * @example
   * custom
   */
  kind?: string;
  /**
   * @remarks
   * The name of the custom response page.
   * 
   * This parameter is required.
   * 
   * @example
   * example
   */
  name?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  /**
   * @remarks
   * The time when the custom error page was last modified.
   * 
   * @example
   * 2024-01-01T00:00:00Z
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      contentType: 'ContentType',
      description: 'Description',
      id: 'Id',
      kind: 'Kind',
      name: 'Name',
      requestId: 'RequestId',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      contentType: 'string',
      description: 'string',
      id: 'number',
      kind: 'string',
      name: 'string',
      requestId: 'string',
      updateTime: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPageResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPageResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPurgeQuotaRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * @example
   * 123456789****
   */
  siteId?: number;
  /**
   * @remarks
   * The type of the purge task. Valid values:
   * 
   * *   **file** (default): purges the cache by file.
   * *   **cachetag**: purges the cache by cache tag.
   * *   **directory**: purges the cache by directory.
   * *   **ignoreParams**: purges the cache by URL with specific parameters ignored.
   * *   **hostname**: purges the cache by hostname.
   * *   **purgeall**: purges all cache.
   * 
   * @example
   * file
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPurgeQuotaResponseBody extends $dara.Model {
  /**
   * @remarks
   * The total quota.
   * 
   * @example
   * 100000
   */
  quota?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  /**
   * @remarks
   * The quota usage.
   * 
   * @example
   * 10
   */
  usage?: string;
  static names(): { [key: string]: string } {
    return {
      quota: 'Quota',
      requestId: 'RequestId',
      usage: 'Usage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      quota: 'string',
      requestId: 'string',
      usage: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPurgeQuotaResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPurgeQuotaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPurgeQuotaResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRealtimeDeliveryFieldRequest extends $dara.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * *   **dcdn_log_access_l1** (default): access logs.
   * *   **dcdn_log_er**: Edge Routine logs.
   * *   **dcdn_log_waf**: firewall logs.
   * *   **dcdn_log_ipa**: TCP/UDP proxy logs.
   * 
   * This parameter is required.
   * 
   * @example
   * dcdn_log_er
   */
  businessType?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRealtimeDeliveryFieldResponseBody extends $dara.Model {
  /**
   * @remarks
   * The fields returned.
   */
  fieldContent?: { [key: string]: FieldContentValue };
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247B78
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      fieldContent: 'FieldContent',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldContent: { 'type': 'map', 'keyType': 'string', 'valueType': FieldContentValue },
      requestId: 'string',
    };
  }

  validate() {
    if(this.fieldContent) {
      $dara.Model.validateMap(this.fieldContent);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRealtimeDeliveryFieldResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRealtimeDeliveryFieldResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRealtimeDeliveryFieldResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRecordRequest extends $dara.Model {
  /**
   * @remarks
   * The record ID, which can be obtained by calling [ListRecords](https://help.aliyun.com/document_detail/2850265.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  recordId?: number;
  static names(): { [key: string]: string } {
    return {
      recordId: 'RecordId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRecordResponseBody extends $dara.Model {
  /**
   * @remarks
   * The information about the queried record.
   */
  recordModel?: GetRecordResponseBodyRecordModel;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F32C57AA-7BF8-49AE-A2CC-9F42390F5A19
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      recordModel: 'RecordModel',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordModel: GetRecordResponseBodyRecordModel,
      requestId: 'string',
    };
  }

  validate() {
    if(this.recordModel && typeof (this.recordModel as any).validate === 'function') {
      (this.recordModel as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRecordResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRecordResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRedirectRuleRequest extends $dara.Model {
  /**
   * @remarks
   * The configuration ID, which can be obtained by calling the [ListRedirectRules](~~ListRedirectRules~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 34003500310****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRedirectRuleResponseBody extends $dara.Model {
  /**
   * @remarks
   * The configuration ID.
   * 
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @remarks
   * The type of the configuration. Valid values:
   * 
   * *   global: global configuration.
   * *   rule: rule configuration.
   * 
   * @example
   * rule
   */
  configType?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the feature of retaining the query string is enabled. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  reserveQueryString?: string;
  /**
   * @remarks
   * The rule content.
   * 
   * @example
   * (http.host eq "video.example.com")
   */
  rule?: string;
  /**
   * @remarks
   * Indicates whether the rule is enabled. Valid values:
   * 
   * *   **on**
   * *   **off**
   * 
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @remarks
   * The rule name.
   * 
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * The order in which the rule is executed.
   * 
   * @example
   * 1
   */
  sequence?: number;
  /**
   * @remarks
   * The version of the website configurations.
   * 
   * @example
   * 0
   */
  siteVersion?: number;
  /**
   * @remarks
   * The response code that you want to use to indicate URL redirection. Valid values:
   * 
   * *   301
   * *   302
   * *   303
   * *   307
   * *   308
   * 
   * @example
   * 301
   */
  statusCode?: string;
  /**
   * @remarks
   * The destination URL to which requests are redirected.
   * 
   * @example
   * http://www.exapmle.com/index.html
   */
  targetUrl?: string;
  /**
   * @remarks
   * The redirect type. Valid value:
   * 
   * *   static
   * 
   * @example
   * static
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      configType: 'ConfigType',
      requestId: 'RequestId',
      reserveQueryString: 'ReserveQueryString',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      siteVersion: 'SiteVersion',
      statusCode: 'StatusCode',
      targetUrl: 'TargetUrl',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      configType: 'string',
      requestId: 'string',
      reserveQueryString: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'number',
      siteVersion: 'number',
      statusCode: 'string',
      targetUrl: 'string',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRedirectRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRedirectRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRedirectRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRewriteUrlRuleRequest extends $dara.Model {
  /**
   * @remarks
   * The configuration ID, which can be obtained by calling the [ListRewriteUrlRules](~~ListRewriteUrlRules~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRewriteUrlRuleResponseBody extends $dara.Model {
  /**
   * @remarks
   * The configuration ID.
   * 
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @remarks
   * The configuration type. Valid values:
   * 
   * *   global: global configuration.
   * *   rule: rule configuration.
   * 
   * @example
   * global
   */
  configType?: string;
  /**
   * @remarks
   * The desired query string to which you want to rewrite the query string in the original request.
   * 
   * @example
   * example=123
   */
  queryString?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  /**
   * @remarks
   * The query string rewrite method. Valid value:
   * 
   * *   static
   * 
   * @example
   * static
   */
  rewriteQueryStringType?: string;
  /**
   * @remarks
   * The path rewrite method. Valid value:
   * 
   * *   static
   * 
   * @example
   * static
   */
  rewriteUriType?: string;
  /**
   * @remarks
   * The rule content.
   * 
   * @example
   * (http.host eq "video.example.com")
   */
  rule?: string;
  /**
   * @remarks
   * Indicates whether the rule is enabled. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @remarks
   * The rule name.
   * 
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * The order in which the rule is executed.
   * 
   * @example
   * 1
   */
  sequence?: number;
  /**
   * @remarks
   * The version number of the website configurations.
   * 
   * @example
   * 0
   */
  siteVersion?: number;
  /**
   * @remarks
   * The desired URI to which you want to rewrite the path in the original request.
   * 
   * @example
   * /image/example.jpg
   */
  uri?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      configType: 'ConfigType',
      queryString: 'QueryString',
      requestId: 'RequestId',
      rewriteQueryStringType: 'RewriteQueryStringType',
      rewriteUriType: 'RewriteUriType',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      sequence: 'Sequence',
      siteVersion: 'SiteVersion',
      uri: 'Uri',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      configType: 'string',
      queryString: 'string',
      requestId: 'string',
      rewriteQueryStringType: 'string',
      rewriteUriType: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      sequence: 'number',
      siteVersion: 'number',
      uri: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRewriteUrlRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRewriteUrlRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRewriteUrlRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineRequest extends $dara.Model {
  /**
   * @remarks
   * The routine name.
   * 
   * This parameter is required.
   * 
   * @example
   * GetRoutine
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineResponseBody extends $dara.Model {
  /**
   * @remarks
   * The code versions.
   */
  codeVersions?: GetRoutineResponseBodyCodeVersions[];
  /**
   * @remarks
   * The time when the routine was created.
   * 
   * @example
   * 2024-03-11T01:23:21Z
   */
  createTime?: string;
  /**
   * @remarks
   * The default record name to access.
   * 
   * @example
   * routine1.example.com
   */
  defaultRelatedRecord?: string;
  /**
   * @remarks
   * The description of the routine.
   * 
   * @example
   * ZWRpdCByb3V0aW5lIGNvbmZpZyBkZXNjcmlwdGlvbg
   */
  description?: string;
  /**
   * @remarks
   * The information about the environments.
   */
  envs?: GetRoutineResponseBodyEnvs[];
  /**
   * @remarks
   * The records associated with the routine.
   */
  relatedRecords?: GetRoutineResponseBodyRelatedRecords[];
  /**
   * @remarks
   * The routes associated with the routine.
   */
  relatedRoutes?: GetRoutineResponseBodyRelatedRoutes[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      codeVersions: 'CodeVersions',
      createTime: 'CreateTime',
      defaultRelatedRecord: 'DefaultRelatedRecord',
      description: 'Description',
      envs: 'Envs',
      relatedRecords: 'RelatedRecords',
      relatedRoutes: 'RelatedRoutes',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeVersions: { 'type': 'array', 'itemType': GetRoutineResponseBodyCodeVersions },
      createTime: 'string',
      defaultRelatedRecord: 'string',
      description: 'string',
      envs: { 'type': 'array', 'itemType': GetRoutineResponseBodyEnvs },
      relatedRecords: { 'type': 'array', 'itemType': GetRoutineResponseBodyRelatedRecords },
      relatedRoutes: { 'type': 'array', 'itemType': GetRoutineResponseBodyRelatedRoutes },
      requestId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.codeVersions)) {
      $dara.Model.validateArray(this.codeVersions);
    }
    if(Array.isArray(this.envs)) {
      $dara.Model.validateArray(this.envs);
    }
    if(Array.isArray(this.relatedRecords)) {
      $dara.Model.validateArray(this.relatedRecords);
    }
    if(Array.isArray(this.relatedRoutes)) {
      $dara.Model.validateArray(this.relatedRoutes);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRoutineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRoutineResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineStagingCodeUploadInfoRequest extends $dara.Model {
  /**
   * @remarks
   * The code description.
   * 
   * @example
   * the description of code
   */
  codeDescription?: string;
  /**
   * @remarks
   * The routine name.
   * 
   * This parameter is required.
   * 
   * @example
   * GetRoutineStagingCodeUploadInfo
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      codeDescription: 'CodeDescription',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeDescription: 'string',
      name: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineStagingCodeUploadInfoResponseBody extends $dara.Model {
  /**
   * @remarks
   * The code version.
   * 
   * @example
   * 1710120201067203242
   */
  codeVersion?: string;
  /**
   * @remarks
   * The configuration information that can be used to upload to OSS.
   * 
   * @example
   * {
   *             "Url": "http://oss_fake_bucket_url",
   *             "OSSAccessKeyId": "xxx",
   *             "key": "site_er_js/hello.1418586423220543.unstable.js",
   *             "callback": "xxx==",
   *             "x:codeDescription": "xxx=",
   *             "policy": "xxx",
   *             "Signature": "xxx="
   * }
   */
  ossPostConfig?: { [key: string]: any };
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      codeVersion: 'CodeVersion',
      ossPostConfig: 'OssPostConfig',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeVersion: 'string',
      ossPostConfig: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      requestId: 'string',
    };
  }

  validate() {
    if(this.ossPostConfig) {
      $dara.Model.validateMap(this.ossPostConfig);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineStagingCodeUploadInfoResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRoutineStagingCodeUploadInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRoutineStagingCodeUploadInfoResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineStagingEnvIpResponseBody extends $dara.Model {
  /**
   * @remarks
   * The IPv4 addresses.
   */
  IPV4?: string[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      IPV4: 'IPV4',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      IPV4: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.IPV4)) {
      $dara.Model.validateArray(this.IPV4);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineStagingEnvIpResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRoutineStagingEnvIpResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRoutineStagingEnvIpResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineUserInfoResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  /**
   * @remarks
   * The routines.
   */
  routines?: GetRoutineUserInfoResponseBodyRoutines[];
  /**
   * @remarks
   * The subdomains.
   */
  subdomains?: string[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      routines: 'Routines',
      subdomains: 'Subdomains',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      routines: { 'type': 'array', 'itemType': GetRoutineUserInfoResponseBodyRoutines },
      subdomains: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.routines)) {
      $dara.Model.validateArray(this.routines);
    }
    if(Array.isArray(this.subdomains)) {
      $dara.Model.validateArray(this.subdomains);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRoutineUserInfoResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRoutineUserInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRoutineUserInfoResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetScheduledPreloadJobRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the scheduled prefetch task.
   * 
   * This parameter is required.
   * 
   * @example
   * GetScheduledPreloadJob
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetScheduledPreloadJobResponseBody extends $dara.Model {
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 15685865xxx14622
   */
  aliUid?: string;
  /**
   * @remarks
   * The time when the task was created.
   * 
   * @example
   * 2024-06-02T02:23:26Z
   */
  createdAt?: string;
  /**
   * @remarks
   * The domain names to be prefetched.
   * 
   * @example
   * testurl.com
   */
  domains?: string;
  /**
   * @remarks
   * The error message that is returned.
   * 
   * @example
   * invalid domain:test.com
   */
  errorInfo?: string;
  /**
   * @remarks
   * The URL of the OSS object that stores a list of URLs that failed the conditional check for prefetching.
   * 
   * @example
   * https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7
   */
  failedFileOss?: string;
  /**
   * @remarks
   * The ID of the URL list file, which can be used during downloads.
   * 
   * @example
   * 665d3b48621bccf3fe29e1a7
   */
  fileId?: string;
  /**
   * @remarks
   * The ID of the prefetch task.
   * 
   * @example
   * 665d3af3621bccf3fe29e1a4
   */
  id?: string;
  /**
   * @remarks
   * The method to submit the URLs to be prefetched.
   * 
   * @example
   * oss
   */
  insertWay?: string;
  /**
   * @remarks
   * The task name.
   * 
   * @example
   * example
   */
  name?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 190007158391808
   */
  siteId?: number;
  /**
   * @remarks
   * The number of submitted prefetch tasks.
   * 
   * @example
   * 1
   */
  taskSubmitted?: number;
  /**
   * @remarks
   * The task type. Valid values: refresh and preload.
   * 
   * @example
   * preload
   */
  taskType?: string;
  /**
   * @remarks
   * The total number of URLs.
   * 
   * @example
   * 2
   */
  urlCount?: number;
  /**
   * @remarks
   * The number of submitted URLs.
   * 
   * @example
   * 1
   */
  urlSubmitted?: number;
  static names(): { [key: string]: string } {
    return {
      aliUid: 'AliUid',
      createdAt: 'CreatedAt',
      domains: 'Domains',
      errorInfo: 'ErrorInfo',
      failedFileOss: 'FailedFileOss',
      fileId: 'FileId',
      id: 'Id',
      insertWay: 'InsertWay',
      name: 'Name',
      requestId: 'RequestId',
      siteId: 'SiteId',
      taskSubmitted: 'TaskSubmitted',
      taskType: 'TaskType',
      urlCount: 'UrlCount',
      urlSubmitted: 'UrlSubmitted',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliUid: 'string',
      createdAt: 'string',
      domains: 'string',
      errorInfo: 'string',
      failedFileOss: 'string',
      fileId: 'string',
      id: 'string',
      insertWay: 'string',
      name: 'string',
      requestId: 'string',
      siteId: 'number',
      taskSubmitted: 'number',
      taskType: 'string',
      urlCount: 'number',
      urlSubmitted: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetScheduledPreloadJobResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetScheduledPreloadJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetScheduledPreloadJobResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSeoBypassRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSeoBypassResponseBody extends $dara.Model {
  /**
   * @remarks
   * The status of the feature. Valid values:
   * 
   * *   **on**
   * *   **off**
   * 
   * @example
   * on
   */
  enable?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247B78
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSeoBypassResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSeoBypassResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSeoBypassResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9732E117-8A37-49FD-A36F-ABBB87556CA7
   */
  requestId?: string;
  /**
   * @remarks
   * The queried website information.
   */
  siteModel?: GetSiteResponseBodySiteModel;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      siteModel: 'SiteModel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      siteModel: GetSiteResponseBodySiteModel,
    };
  }

  validate() {
    if(this.siteModel && typeof (this.siteModel as any).validate === 'function') {
      (this.siteModel as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSiteResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSiteResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteCurrentNSRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID. It can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteCurrentNSResponseBody extends $dara.Model {
  /**
   * @remarks
   * The nameservers of the website.
   */
  NSList?: string[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2430E05E-1340-5773-B5E1-B743929F46F2
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      NSList: 'NSList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      NSList: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.NSList)) {
      $dara.Model.validateArray(this.NSList);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteCurrentNSResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSiteCurrentNSResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSiteCurrentNSResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteCustomLogRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 11223***
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteCustomLogResponseBody extends $dara.Model {
  /**
   * @remarks
   * The ID of the custom log field configuration.
   * 
   * @example
   * 6befa4aa-2a94-4f51-a245-295787192d2c
   */
  configId?: number;
  /**
   * @remarks
   * Indicates whether the custom configuration exists.
   * 
   * @example
   * true
   */
  isExist?: boolean;
  /**
   * @remarks
   * The custom fields.
   */
  logCustomField?: GetSiteCustomLogResponseBodyLogCustomField;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6befa4aa-2a94-4f51-a245-295787192d2c
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 167026711***
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      isExist: 'IsExist',
      logCustomField: 'LogCustomField',
      requestId: 'RequestId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      isExist: 'boolean',
      logCustomField: GetSiteCustomLogResponseBodyLogCustomField,
      requestId: 'string',
      siteId: 'number',
    };
  }

  validate() {
    if(this.logCustomField && typeof (this.logCustomField as any).validate === 'function') {
      (this.logCustomField as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteCustomLogResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSiteCustomLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSiteCustomLogResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteDeliveryTaskRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 123456***
   */
  siteId?: number;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * This parameter is required.
   * 
   * @example
   * cdn-test-task
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      taskName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteDeliveryTaskResponseBody extends $dara.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * *   dcdn_log_access_l1 (default): access logs.
   * *   dcdn_log_er: Edge Routine logs.
   * *   dcdn_log_waf: firewall logs.
   * *   dcdn_log_ipa: TCP/UDP proxy logs.
   * 
   * @example
   * dcdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The data center. Valid values:
   * 
   * 1.  cn: the Chinese mainland.
   * 2.  sg: outside the Chinese mainland.
   * 
   * @example
   * cn
   */
  dataCenter?: string;
  /**
   * @remarks
   * The destination of the delivery. Valid values:
   * 
   * 1.  sls: Alibaba Cloud Simple Log Service (SLS).
   * 2.  http: HTTP server.
   * 3.  aws3: Amazon Simple Storage Service (S3).
   * 4.  oss: Alibaba Cloud Object Storage Service (OSS).
   * 5.  kafka: Kafka.
   * 6.  aws3cmpt: S3-compatible storage service.
   * 
   * @example
   * sls
   */
  deliveryType?: string;
  /**
   * @remarks
   * The discard rate.
   * 
   * @example
   * 0.0
   */
  discardRate?: number;
  /**
   * @remarks
   * The log fields.
   * 
   * @example
   * Client,UserAgent
   */
  fieldList?: string;
  /**
   * @remarks
   * The filtering rules.
   * 
   * @example
   * []
   */
  filterRules?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 34DCBC8A-****-****-****-6DAA11D7DDBD
   */
  requestId?: string;
  /**
   * @remarks
   * The delivery configuration.
   * 
   * @example
   * {\\"Region\\": \\"cn-hangzhou\\", \\"Endpoint\\": \\"https://***.oss-cn-hangzhou.aliyuncs.com\\", \\"BucketPath\\": \\"hjy-test002/online-logs\\"}
   */
  sinkConfig?: any;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * test.***.com
   */
  siteName?: string;
  /**
   * @remarks
   * The status of the delivery task.
   * 
   * *   **online**
   * *   **offline**
   * 
   * @example
   * online
   */
  status?: string;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * @example
   * cdn-test-task
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      dataCenter: 'DataCenter',
      deliveryType: 'DeliveryType',
      discardRate: 'DiscardRate',
      fieldList: 'FieldList',
      filterRules: 'FilterRules',
      requestId: 'RequestId',
      sinkConfig: 'SinkConfig',
      siteId: 'SiteId',
      siteName: 'SiteName',
      status: 'Status',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      dataCenter: 'string',
      deliveryType: 'string',
      discardRate: 'number',
      fieldList: 'string',
      filterRules: 'string',
      requestId: 'string',
      sinkConfig: 'any',
      siteId: 'number',
      siteName: 'string',
      status: 'string',
      taskName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteDeliveryTaskResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSiteDeliveryTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSiteDeliveryTaskResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteLogDeliveryQuotaRequest extends $dara.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * 1.  dcdn_log_access_l1 (default): access logs.
   * 2.  dcdn_log_er: Edge Routine logs.
   * 3.  dcdn_log_waf: firewall logs.
   * 4.  dcdn_log_ipa: TCP/UDP proxy logs.
   * 
   * This parameter is required.
   * 
   * @example
   * dcdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteLogDeliveryQuotaResponseBody extends $dara.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * 1.  dcdn_log_access_l1 (default): access logs.
   * 2.  dcdn_log_er: Edge Routine logs.
   * 3.  dcdn_log_waf: firewall logs.
   * 4.  dcdn_log_ipa: TCP/UDP proxy logs.
   * 
   * @example
   * dcdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The remaining quota.
   * 
   * @example
   * 3
   */
  freeQuota?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 4C14840EF0EAAB6D97CDE0C5F6554ACE
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      freeQuota: 'FreeQuota',
      requestId: 'RequestId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      freeQuota: 'number',
      requestId: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteLogDeliveryQuotaResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSiteLogDeliveryQuotaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSiteLogDeliveryQuotaResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteNameExclusiveRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteNameExclusiveResponseBody extends $dara.Model {
  /**
   * @example
   * on
   */
  enable?: string;
  /**
   * @example
   * 35C66C7B-671H-4297-9187-2C4477247A78
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteNameExclusiveResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSiteNameExclusiveResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSiteNameExclusiveResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSitePauseRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSitePauseResponseBody extends $dara.Model {
  /**
   * @example
   * true
   */
  paused?: boolean;
  /**
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      paused: 'Paused',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      paused: 'boolean',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSitePauseResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSitePauseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSitePauseResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteWafSettingsRequest extends $dara.Model {
  path?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 1
   */
  siteId?: number;
  /**
   * @remarks
   * The version of the website.
   * 
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      path: 'Path',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      path: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteWafSettingsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  /**
   * @remarks
   * The WAF configurations of the website.
   */
  settings?: WafSiteSettings;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      settings: 'Settings',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      settings: WafSiteSettings,
    };
  }

  validate() {
    if(this.settings && typeof (this.settings as any).validate === 'function') {
      (this.settings as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSiteWafSettingsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSiteWafSettingsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSiteWafSettingsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTieredCacheRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](~~ListSites~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTieredCacheResponseBody extends $dara.Model {
  /**
   * @remarks
   * The tiered cache architecture mode. Valid values:
   * 
   * *   edge: edge tiered cache.
   * *   edge_smart: edge tiered cache + smart tiered cache.
   * *   edge_regional: edge tiered cache + regional tiered cache.
   * *   edge_regional_smart: edge tiered cache + regional tiered cache + smart tiered cache.
   * 
   * @example
   * edge
   */
  cacheArchitectureMode?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      cacheArchitectureMode: 'CacheArchitectureMode',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cacheArchitectureMode: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTieredCacheResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTieredCacheResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTieredCacheResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUploadTaskRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The ID of the file upload task. This field is assigned after you call the [UploadFile](https://help.aliyun.com/document_detail/2850466.html) operation.
   * 
   * @example
   * 159253299357****
   */
  uploadId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      uploadId: 'UploadId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      uploadId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUploadTaskResponseBody extends $dara.Model {
  /**
   * @remarks
   * The error message returned when the file upload task failed.
   * 
   * @example
   * invalid url
   */
  description?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * ET5BF670-09D5-4D0B-BEBY-D96A2A52****
   */
  requestId?: string;
  /**
   * @remarks
   * The task status.
   * 
   * *   **INIT**: The task is being initialized.
   * *   **activacted**: The task is activated.
   * *   **running**: The task is running.
   * *   **success**: The task is successful.
   * *   **partial**: The task is partially successful.
   * *   **fail**: The task failed.
   * 
   * @example
   * running
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      requestId: 'string',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUploadTaskResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetUploadTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetUploadTaskResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserDeliveryTaskRequest extends $dara.Model {
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * This parameter is required.
   * 
   * @example
   * test_project
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserDeliveryTaskResponseBody extends $dara.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * *   **dcdn_log_access_l1** (default): access logs.
   * *   **dcdn_log_er**: Edge Routine logs.
   * *   **dcdn_log_waf**: firewall logs.
   * *   **dcdn_log_ipa**: TCP/UDP proxy logs.
   * 
   * @example
   * dcdn_log_er
   */
  businessType?: string;
  /**
   * @remarks
   * The data center. Valid values:
   * 
   * *   cn: the Chinese mainland.
   * *   sg: outside the Chinese mainland.
   * 
   * @example
   * cn
   */
  dataCenter?: string;
  /**
   * @remarks
   * The destination of the delivery. Valid values:
   * 
   * *   sls: Alibaba Cloud Simple Log Service (SLS).
   * *   http: HTTP server.
   * *   aws3: Amazon Simple Storage Service (S3).
   * *   oss: Alibaba Cloud Object Storage Service (OSS).
   * *   kafka: Kafka.
   * *   aws3cmpt: S3-compatible storage service.
   * 
   * @example
   * oss
   */
  deliveryType?: string;
  details?: string;
  /**
   * @remarks
   * The discard rate.
   * 
   * @example
   * 0
   */
  discardRate?: number;
  /**
   * @remarks
   * The fields.
   * 
   * @example
   * ClientRequestID,ClientRequestHost
   */
  fieldList?: string;
  /**
   * @remarks
   * The filtering rules.
   * 
   * @example
   * [{"ClientSSLProtocol": {"equals": ["TLSv1.3"]}}]
   */
  filterRules?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 7072132a-bd3c-46a6-9e81-aba3e0e3f861
   */
  requestId?: string;
  /**
   * @remarks
   * The delivery configuration.
   * 
   * @example
   * {\\"Project\\": \\"er-online-hjy-pro\\", \\"Logstore\\": \\"er-online-hjy-log\\", \\"Region\\": \\"cn-hangzhou\\", \\"Endpoint\\": \\"cn-hangzhou.log.aliyuncs.com\\", \\"Aliuid\\": \\"1077912128805410\\"}
   */
  sinkConfig?: any;
  /**
   * @remarks
   * The status of the delivery task.
   * 
   * @example
   * online
   */
  status?: string;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * @example
   * testoss11
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      dataCenter: 'DataCenter',
      deliveryType: 'DeliveryType',
      details: 'Details',
      discardRate: 'DiscardRate',
      fieldList: 'FieldList',
      filterRules: 'FilterRules',
      requestId: 'RequestId',
      sinkConfig: 'SinkConfig',
      status: 'Status',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      dataCenter: 'string',
      deliveryType: 'string',
      details: 'string',
      discardRate: 'number',
      fieldList: 'string',
      filterRules: 'string',
      requestId: 'string',
      sinkConfig: 'any',
      status: 'string',
      taskName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserDeliveryTaskResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetUserDeliveryTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetUserDeliveryTaskResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserLogDeliveryQuotaRequest extends $dara.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * *   dcdn_log_access_l1 (default): access logs.
   * *   dcdn_log_er: Edge Routine logs.
   * *   dcdn_log_waf: firewall logs.
   * *   dcdn_log_ipa: TCP/UDP proxy logs.
   * 
   * This parameter is required.
   * 
   * @example
   * dcdn_log_access_l1
   */
  businessType?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserLogDeliveryQuotaResponseBody extends $dara.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * *   dcdn_log_access_l1 (default): access logs.
   * *   dcdn_log_er: Edge Routine logs.
   * *   dcdn_log_waf: firewall logs.
   * *   dcdn_log_ipa: TCP/UDP proxy logs.
   * 
   * @example
   * dcdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The remaining quota.
   * 
   * @example
   * 3
   */
  freeQuota?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 34DCBC8A-****-****-****-6DAA11D7DDBD
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      freeQuota: 'FreeQuota',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      freeQuota: 'number',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserLogDeliveryQuotaResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetUserLogDeliveryQuotaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetUserLogDeliveryQuotaResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafBotAppKeyResponseBody extends $dara.Model {
  /**
   * @remarks
   * The application key.
   * 
   * @example
   * example_appkey
   */
  appKey?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      appKey: 'AppKey',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appKey: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafBotAppKeyResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWafBotAppKeyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWafBotAppKeyResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafFilterRequest extends $dara.Model {
  /**
   * @remarks
   * The WAF rule category to which the filter conditions to query belong.
   * 
   * @example
   * http_bot
   */
  phase?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 1
   */
  siteId?: number;
  /**
   * @remarks
   * The condition for matching incoming requests.
   * 
   * @example
   * characteristics
   */
  target?: string;
  /**
   * @remarks
   * The rule type.
   * 
   * @example
   * http_custom_cc
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      phase: 'Phase',
      siteId: 'SiteId',
      target: 'Target',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      phase: 'string',
      siteId: 'number',
      target: 'string',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafFilterResponseBody extends $dara.Model {
  /**
   * @remarks
   * The returned match conditions.
   */
  filter?: GetWafFilterResponseBodyFilter;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      filter: 'Filter',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      filter: GetWafFilterResponseBodyFilter,
      requestId: 'string',
    };
  }

  validate() {
    if(this.filter && typeof (this.filter as any).validate === 'function') {
      (this.filter as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafFilterResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWafFilterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWafFilterResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafQuotaRequest extends $dara.Model {
  /**
   * @remarks
   * The type of WAF resources. Valid values:
   * 
   * *   managed_rules_group: the managed rule group.
   * *   list: the custom list.
   * *   page: the custom error page.
   * *   scene_policy: the scenario-specific policy.
   * 
   * @example
   * page
   */
  paths?: string;
  static names(): { [key: string]: string } {
    return {
      paths: 'Paths',
    };
  }

  static types(): { [key: string]: any } {
    return {
      paths: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafQuotaResponseBody extends $dara.Model {
  /**
   * @remarks
   * The quota information returned.
   */
  quota?: GetWafQuotaResponseBodyQuota;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      quota: 'Quota',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      quota: GetWafQuotaResponseBodyQuota,
      requestId: 'string',
    };
  }

  validate() {
    if(this.quota && typeof (this.quota as any).validate === 'function') {
      (this.quota as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetWafQuotaResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetWafQuotaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetWafQuotaResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCacheReserveInstancesRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the cache reserve instance.
   * 
   * @example
   * sp-xcdn-96wblslz****
   */
  instanceId?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: **1 to 500**. Default value: **500**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The criterion by which you want to sort the queried instances. Valid values:
   * 
   * *   ExpireTime: sorts the instances by the time when the instances expire.
   * *   CreateTime: sorts the instances by the time when the instances were purchased.
   * 
   * @example
   * ExpireTime
   */
  sortBy?: string;
  /**
   * @remarks
   * The order by which you want to sort the queried instances. Valid values:
   * 
   * *   asc: in ascending order.
   * *   desc: in descending order.
   * 
   * @example
   * desc
   */
  sortOrder?: string;
  /**
   * @remarks
   * The status of the cache reserve instance. Valid values:
   * 
   * *   online: The instance is in service.
   * *   offline: The instance has expired within an allowable period. In this state, the plan is unavailable.
   * *   disable: The instance is released.
   * *   overdue: The instance is stopped due to overdue payments.
   * 
   * @example
   * ListCacheReserveInstances
   * 
   * **if can be null:**
   * false
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      sortBy: 'SortBy',
      sortOrder: 'SortOrder',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      sortBy: 'string',
      sortOrder: 'string',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCacheReserveInstancesResponseBody extends $dara.Model {
  /**
   * @remarks
   * The cache reserve instances.
   */
  instanceInfo?: ListCacheReserveInstancesResponseBodyInstanceInfo[];
  /**
   * @remarks
   * The page number. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: **500**. Valid values: **1 to 500**.
   * 
   * @example
   * 500
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 65C66B7B-671A-8297-9187-2R5477247B76
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 16
   */
  totalCount?: number;
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 1
   */
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      instanceInfo: 'InstanceInfo',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceInfo: { 'type': 'array', 'itemType': ListCacheReserveInstancesResponseBodyInstanceInfo },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      totalPage: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.instanceInfo)) {
      $dara.Model.validateArray(this.instanceInfo);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCacheReserveInstancesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListCacheReserveInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCacheReserveInstancesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCacheRulesRequest extends $dara.Model {
  /**
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @example
   * global
   */
  configType?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * test
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @example
   * 1
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      configType: 'ConfigType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      configType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      ruleName: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCacheRulesResponseBody extends $dara.Model {
  configs?: ListCacheRulesResponseBodyConfigs[];
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  /**
   * @example
   * 20
   */
  totalCount?: number;
  /**
   * @example
   * 2
   */
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      configs: 'Configs',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configs: { 'type': 'array', 'itemType': ListCacheRulesResponseBodyConfigs },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      totalPage: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.configs)) {
      $dara.Model.validateArray(this.configs);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCacheRulesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListCacheRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCacheRulesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCertificatesRequest extends $dara.Model {
  /**
   * @example
   * example
   */
  keyword?: string;
  /**
   * @example
   * 3
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @example
   * 1
   */
  validOnly?: boolean;
  static names(): { [key: string]: string } {
    return {
      keyword: 'Keyword',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      siteId: 'SiteId',
      validOnly: 'ValidOnly',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keyword: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      siteId: 'number',
      validOnly: 'boolean',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCertificatesResponseBody extends $dara.Model {
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  result?: ListCertificatesResponseBodyResult[];
  /**
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @example
   * example.com
   */
  siteName?: string;
  /**
   * @example
   * 10
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      result: 'Result',
      siteId: 'SiteId',
      siteName: 'SiteName',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListCertificatesResponseBodyResult },
      siteId: 'number',
      siteName: 'string',
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.result)) {
      $dara.Model.validateArray(this.result);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCertificatesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListCertificatesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCertificatesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCiphersRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * strict
   */
  ciphersGroup?: string;
  static names(): { [key: string]: string } {
    return {
      ciphersGroup: 'CiphersGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ciphersGroup: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCiphersResponseBody extends $dara.Model {
  /**
   * @example
   * all
   */
  ciphersGroup?: string;
  /**
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  result?: string[];
  /**
   * @example
   * 16
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      ciphersGroup: 'CiphersGroup',
      requestId: 'RequestId',
      result: 'Result',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ciphersGroup: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': 'string' },
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.result)) {
      $dara.Model.validateArray(this.result);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCiphersResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListCiphersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCiphersResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClientCaCertificatesRequest extends $dara.Model {
  /**
   * @remarks
   * The page number. Valid values: 1 to 500.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 20. Valid values: 1 to 100.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](~~ListSites~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClientCaCertificatesResponseBody extends $dara.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F61CDR30-E83C-4FDA-BF73-9A94CDD44229
   */
  requestId?: string;
  /**
   * @remarks
   * The queried client CA certificates.
   */
  result?: ListClientCaCertificatesResponseBodyResult[];
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  /**
   * @remarks
   * The total number of entries.
   * 
   * @example
   * 16
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      result: 'Result',
      siteId: 'SiteId',
      siteName: 'SiteName',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListClientCaCertificatesResponseBodyResult },
      siteId: 'number',
      siteName: 'string',
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.result)) {
      $dara.Model.validateArray(this.result);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClientCaCertificatesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListClientCaCertificatesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListClientCaCertificatesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClientCertificatesRequest extends $dara.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The website ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClientCertificatesResponseBody extends $dara.Model {
  /**
   * @remarks
   * The page number returned.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  /**
   * @remarks
   * The client certificates.
   */
  result?: ListClientCertificatesResponseBodyResult[];
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  /**
   * @remarks
   * The total number of entries.
   * 
   * @example
   * 5
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      result: 'Result',
      siteId: 'SiteId',
      siteName: 'SiteName',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': ListClientCertificatesResponseBodyResult },
      siteId: 'number',
      siteName: 'string',
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.result)) {
      $dara.Model.validateArray(this.result);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClientCertificatesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListClientCertificatesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListClientCertificatesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCompressionRulesRequest extends $dara.Model {
  /**
   * @remarks
   * The configuration ID, which can be obtained by calling the [ListRedirectRules](~~ListRedirectRules~~) operation.
   * 
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @remarks
   * The type of the configuration. Valid values:
   * 
   * *   global: global configuration.
   * *   rule: rule configuration.
   * 
   * @example
   * rule
   */
  configType?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The rule name.
   * 
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 34003500310****
   */
  siteId?: number;
  /**
   * @remarks
   * The version of the website configurations.
   * 
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      configType: 'ConfigType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      configType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      ruleName: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCompressionRulesResponseBody extends $dara.Model {
  /**
   * @remarks
   * The configured compression rules.
   */
  configs?: ListCompressionRulesResponseBodyConfigs[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries.
   * 
   * @example
   * 16
   */
  totalCount?: number;
  /**
   * @remarks
   * The total number of pages.
   * 
   * @example
   * 1
   */
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      configs: 'Configs',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configs: { 'type': 'array', 'itemType': ListCompressionRulesResponseBodyConfigs },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      totalPage: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.configs)) {
      $dara.Model.validateArray(this.configs);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCompressionRulesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListCompressionRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCompressionRulesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppRecordsRequest extends $dara.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The sorting field. Valid values:
   * 
   * *   CreateTime: the time when the domain name was associated.
   * *   CreateTime: the time when the domain name was last modified.
   * 
   * @example
   * CreateTime
   */
  orderKey?: string;
  /**
   * @remarks
   * The order in which you want to sort the query results. Valid values:
   * 
   * *   ASC: in ascending order.
   * *   DESC: in descending order.
   * 
   * @example
   * DESC
   */
  orderType?: string;
  /**
   * @remarks
   * The page number. Valid values: **1** to **100000**. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 20. Valid values: 1 to 500.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The keyword that is used for the search.
   * 
   * @example
   * ver-1006157458290860032
   */
  searchKey?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      orderKey: 'OrderKey',
      orderType: 'OrderType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchKey: 'SearchKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      orderKey: 'string',
      orderType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchKey: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppRecordsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The details about the associated domain names.
   */
  records?: ListEdgeContainerAppRecordsResponseBodyRecords[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CB1A380B-09F0-41BB-A198-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @remarks
   * The number of domain names that are associated with the specified application.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      records: 'Records',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      records: { 'type': 'array', 'itemType': ListEdgeContainerAppRecordsResponseBodyRecords },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.records)) {
      $dara.Model.validateArray(this.records);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppRecordsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEdgeContainerAppRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEdgeContainerAppRecordsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppVersionsRequest extends $dara.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The sorting field. Valid values:
   * 
   * *   Name: the version name.
   * *   CreateTime: the time when the version was created.
   * *   UpdateTime: the time when the version was last modified.
   * 
   * @example
   * Name
   */
  orderKey?: string;
  /**
   * @remarks
   * The order in which you want to sort the query results. Valid values:
   * 
   * *   ASC: in ascending order.
   * *   DESC: in descending order.
   * 
   * @example
   * DESC
   */
  orderType?: string;
  /**
   * @remarks
   * The page number. Valid values: 1 to 65535.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: 1 to 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The keyword used for the search.
   * 
   * @example
   * ver-100568263967926****
   */
  searchKey?: string;
  /**
   * @remarks
   * The parameter used for fuzzy search. Valid values: VersionId and Name.
   * 
   * @example
   * VersionId
   */
  searchType?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      orderKey: 'OrderKey',
      orderType: 'OrderType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchKey: 'SearchKey',
      searchType: 'SearchType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      orderKey: 'string',
      orderType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchKey: 'string',
      searchType: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppVersionsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F61CDR30-E83C-4FDA-BF73-9A94CDD44229
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  /**
   * @remarks
   * The versions.
   */
  versions?: ListEdgeContainerAppVersionsResponseBodyVersions[];
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      versions: 'Versions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      versions: { 'type': 'array', 'itemType': ListEdgeContainerAppVersionsResponseBodyVersions },
    };
  }

  validate() {
    if(Array.isArray(this.versions)) {
      $dara.Model.validateArray(this.versions);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppVersionsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEdgeContainerAppVersionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEdgeContainerAppVersionsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppsRequest extends $dara.Model {
  /**
   * @remarks
   * The sorting field. This parameter is left empty by default. Valid values:
   * 
   * *   Name: the version name.
   * *   CreateTime: the time when the version was created.
   * *   UpdateTime: the time when the version was last modified.
   * 
   * @example
   * CreateTime
   */
  orderKey?: string;
  /**
   * @remarks
   * The order in which you want to sort the query results. This parameter is left empty by default. Valid values:
   * 
   * *   ASC: in ascending order.
   * *   DESC: in descending order.
   * 
   * @example
   * Asc
   */
  orderType?: string;
  /**
   * @remarks
   * The page number. Default value: **1**. Valid values: 1 to 65535.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: **20**. Valid values: 1 to 500.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The search keyword.
   * 
   * @example
   * ver-1005682639679266816
   */
  searchKey?: string;
  /**
   * @remarks
   * The search criterion based on which you want to perform fuzzy search. Valid values:
   * 
   * *   Appid: the application ID.
   * *   Name: the application name.
   * 
   * @example
   * Appid
   */
  searchType?: string;
  static names(): { [key: string]: string } {
    return {
      orderKey: 'OrderKey',
      orderType: 'OrderType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      searchKey: 'SearchKey',
      searchType: 'SearchType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      orderKey: 'string',
      orderType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      searchKey: 'string',
      searchType: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The queried applications.
   */
  apps?: ListEdgeContainerAppsResponseBodyApps[];
  /**
   * @remarks
   * The page number. Default value: **1**. Valid values: 1 to 65535.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: 1 to 500.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 2430E05E-1340-5773-B5E1-B743929F46F2
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries.
   * 
   * @example
   * 10
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      apps: 'Apps',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apps: { 'type': 'array', 'itemType': ListEdgeContainerAppsResponseBodyApps },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.apps)) {
      $dara.Model.validateArray(this.apps);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerAppsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEdgeContainerAppsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEdgeContainerAppsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerRecordsRequest extends $dara.Model {
  /**
   * @remarks
   * The page number. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: **500**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The match mode to filter the record names:
   * 
   * *   **fuzzy**
   * *   **prefix**
   * *   **suffix**
   * *   **exact** (default)
   * 
   * @example
   * fuzzy
   */
  recordMatchType?: string;
  /**
   * @remarks
   * The record name.
   * 
   * @example
   * a.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      recordMatchType: 'RecordMatchType',
      recordName: 'RecordName',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      recordMatchType: 'string',
      recordName: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerRecordsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The records.
   */
  records?: ListEdgeContainerRecordsResponseBodyRecords[];
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of records returned.
   * 
   * @example
   * 50
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      records: 'Records',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      records: { 'type': 'array', 'itemType': ListEdgeContainerRecordsResponseBodyRecords },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.records)) {
      $dara.Model.validateArray(this.records);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeContainerRecordsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEdgeContainerRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEdgeContainerRecordsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeRoutinePlansResponseBody extends $dara.Model {
  /**
   * @remarks
   * The page number. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: 1 to 500.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The plans.
   */
  planInfo?: ListEdgeRoutinePlansResponseBodyPlanInfo[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 12
   */
  totalCount?: number;
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 1
   */
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      planInfo: 'PlanInfo',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      planInfo: { 'type': 'array', 'itemType': ListEdgeRoutinePlansResponseBodyPlanInfo },
      requestId: 'string',
      totalCount: 'number',
      totalPage: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.planInfo)) {
      $dara.Model.validateArray(this.planInfo);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeRoutinePlansResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEdgeRoutinePlansResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEdgeRoutinePlansResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeRoutineRecordsRequest extends $dara.Model {
  /**
   * @remarks
   * The page number. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: **500**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The match mode to filter the record names.
   * 
   * *   **fuzzy**: fuzzy match.
   * *   **prefix**: match by prefix.
   * *   **suffix**: match by suffix.
   * *   **exact** (default): exact match .
   * 
   * @example
   * fuzzy
   */
  recordMatchType?: string;
  /**
   * @remarks
   * The record name.
   * 
   * @example
   * a.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      recordMatchType: 'RecordMatchType',
      recordName: 'RecordName',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      recordMatchType: 'string',
      recordName: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeRoutineRecordsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The list of records.
   */
  records?: ListEdgeRoutineRecordsResponseBodyRecords[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of records returned.
   * 
   * @example
   * 121
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      records: 'Records',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      records: { 'type': 'array', 'itemType': ListEdgeRoutineRecordsResponseBodyRecords },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.records)) {
      $dara.Model.validateArray(this.records);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEdgeRoutineRecordsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEdgeRoutineRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEdgeRoutineRecordsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHttpRequestHeaderModificationRulesRequest extends $dara.Model {
  /**
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @example
   * rule
   */
  configType?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      configType: 'ConfigType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      configType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      ruleName: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHttpRequestHeaderModificationRulesResponseBody extends $dara.Model {
  configs?: ListHttpRequestHeaderModificationRulesResponseBodyConfigs[];
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * 35C66C7B-671H-4297-9187-2C4477247A78
   */
  requestId?: string;
  /**
   * @example
   * 10
   */
  totalCount?: number;
  /**
   * @example
   * 1
   */
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      configs: 'Configs',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configs: { 'type': 'array', 'itemType': ListHttpRequestHeaderModificationRulesResponseBodyConfigs },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      totalPage: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.configs)) {
      $dara.Model.validateArray(this.configs);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHttpRequestHeaderModificationRulesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListHttpRequestHeaderModificationRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListHttpRequestHeaderModificationRulesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHttpResponseHeaderModificationRulesRequest extends $dara.Model {
  /**
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @example
   * rule
   */
  configType?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      configType: 'ConfigType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      configType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      ruleName: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHttpResponseHeaderModificationRulesResponseBody extends $dara.Model {
  configs?: ListHttpResponseHeaderModificationRulesResponseBodyConfigs[];
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * CB1A380B-09F0-41BB-280B-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @example
   * 14
   */
  totalCount?: number;
  /**
   * @example
   * 1
   */
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      configs: 'Configs',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configs: { 'type': 'array', 'itemType': ListHttpResponseHeaderModificationRulesResponseBodyConfigs },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      totalPage: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.configs)) {
      $dara.Model.validateArray(this.configs);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHttpResponseHeaderModificationRulesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListHttpResponseHeaderModificationRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListHttpResponseHeaderModificationRulesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHttpsApplicationConfigurationsRequest extends $dara.Model {
  /**
   * @example
   * 3528160969****
   */
  configId?: number;
  /**
   * @example
   * global
   */
  configType?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @example
   * 1
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      configType: 'ConfigType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      configType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      ruleName: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHttpsApplicationConfigurationsResponseBody extends $dara.Model {
  configs?: ListHttpsApplicationConfigurationsResponseBodyConfigs[];
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  /**
   * @example
   * 16
   */
  totalCount?: number;
  /**
   * @example
   * 2
   */
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      configs: 'Configs',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configs: { 'type': 'array', 'itemType': ListHttpsApplicationConfigurationsResponseBodyConfigs },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      totalPage: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.configs)) {
      $dara.Model.validateArray(this.configs);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHttpsApplicationConfigurationsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListHttpsApplicationConfigurationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListHttpsApplicationConfigurationsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHttpsBasicConfigurationsRequest extends $dara.Model {
  /**
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @example
   * global
   */
  configType?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * test
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      configType: 'ConfigType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ruleName: 'RuleName',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      configType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      ruleName: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHttpsBasicConfigurationsResponseBody extends $dara.Model {
  configs?: ListHttpsBasicConfigurationsResponseBodyConfigs[];
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  /**
   * @example
   * 20
   */
  totalCount?: number;
  /**
   * @example
   * 2
   */
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      configs: 'Configs',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configs: { 'type': 'array', 'itemType': ListHttpsBasicConfigurationsResponseBodyConfigs },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      totalPage: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.configs)) {
      $dara.Model.validateArray(this.configs);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHttpsBasicConfigurationsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListHttpsBasicConfigurationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListHttpsBasicConfigurationsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListImageTransformsRequest extends $dara.Model {
  /**
   * @example
   * 352816096987136
   */
  configId?: number;
  /**
   * @example
   * global
   */
  configType?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * test1
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @example
   * 1
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      configType: 'ConfigType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      configType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      ruleName: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListImageTransformsResponseBody extends $dara.Model {
  configs?: ListImageTransformsResponseBodyConfigs[];
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * CB1A380B-09F0-41BB-A198-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @example
   * 16
   */
  totalCount?: number;
  /**
   * @example
   * 2
   */
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      configs: 'Configs',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configs: { 'type': 'array', 'itemType': ListImageTransformsResponseBodyConfigs },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      totalPage: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.configs)) {
      $dara.Model.validateArray(this.configs);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListImageTransformsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListImageTransformsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListImageTransformsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceQuotasRequest extends $dara.Model {
  /**
   * @remarks
   * The plan ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * sp-xcdn-96wblslz****
   */
  instanceId?: string;
  /**
   * @remarks
   * The quota names in the plan. Separate multiple names with commas (,). Valid values:
   * 
   * *   **waf:phase:http_anti_scan:actions**: the actions in WAF scan protection rules.
   * *   **waf:phase:http_bot:actions**: all actions in WAF bot management rules.
   * *   **waf:phase:http_bot:http_custom_cc_dev:characteristic:fields**: the statistical objects for the custom device-based throttling in WAF bot management rules.
   * *   **waf:phase:http_bot:http_custom_cc_ip:characteristic:fields**: the statistical objects for the custom IP address-based throttling in WAF bot management rules.
   * *   ****waf:phase:http_bot:match:symbols****: the match operators in WAF bot management rules.
   * *   **waf:phase:http_bot:http_custom_cc:characteristic:fields**: the statistical objects for the custom session-based throttling in WAF bot management rules.
   * *   **waf:phase:http_bot:match:fields**: the match fields in WAF bot management rules.
   * *   **waf:phase:http_whitelist:match:symbols**: the match operators in WAF whitelist rules.
   * *   **waf:phase:http_whitelist:match:fields**: the match fields in WAF whitelist rules.
   * *   **waf:phase:http_anti_scan:http_directory_traversal:characteristic:fields**: the statistical objects for directory traversal blocking in WAF scan protection rules.
   * *   **waf:phase:http_anti_scan:http_high_frequency:characteristic:fields**: the statistical objects for high-frequency scanning blocking in WAF scan protection rules.
   * *   **waf:phase:http_anti_scan:match:symbols**: the match operators in WAF scan protection rules.
   * *   **waf:phase:http_anti_scan:match:fields**: the match fields in WAF scan protection rules.
   * *   **waf:phase:http_managed:actions**: the actions in WAF managed rules.
   * *   **waf:phase:http_managed:group:reference:ids**: the referenced rule groups in WAF managed rules.
   * *   **waf:phase:http_ratelimit:actions**: the actions in WAF rate limiting rules.
   * *   **waf:phase:http_ratelimit:ttls**: the action durations in WAF rate limiting rules.
   * *   **waf:phase:http_ratelimit:intervals**: the statistical durations in WAF rate limiting rules.
   * *   **waf:phase:http_ratelimit:http_ratelimit:characteristic:fields**: the match characteristics in WAF rate limiting rules.
   * *   **waf:phase:http_ratelimit:match:symbols**: the match operators in WAF rate limiting rules.
   * *   **waf:phase:http_ratelimit:match:fields**: the match fields in WAF rate limiting rules.
   * *   **waf:phase:http_custom:actions**: the actions in custom WAF rules.
   * *   **waf:phase:http_custom:match:symbols**: the match operators in custom WAF rules.
   * *   **waf:phase:http_custom:match:fields**: the match fields in custom WAF rules.
   * *   **waiting_room|queuing_method**: the queuing method in Waiting Room.
   * *   **origin_rules|origin_scheme**: the origin protocol in origin rules.
   * *   **origin_rules|origin_sni**: the origin Server Name Indication (SNI) in origin rules.
   * *   **origin_rules|origin_host**: the origin host in origin rules.
   * *   **fourlayeracceleration**: TCP/UDP proxy.
   * *   **rtlog_service**: the availability to collect real-time logs.
   * *   **dashboard_traffic**: the value-added capability of traffic analytics.
   * *   **custom_name_server**: the availability to configure custom nameservers.
   * *   **waf:phase:http_bot:enable**: the availability to enable WAF bot management.
   * *   **waf:phase:http_whitelist:enable**: the availability to configure WAF whitelist rules.
   * *   **instantlog**: the availability to collect instant logs.
   * *   **waf:phase:http_anti_scan:enable**: the availability to enable WAF scan protection.
   * *   **waf:phase:http_managed:group:reference:enable**: the availability to configure reference rule groups in WAF managed rules.
   * *   **waf:phase:http_managed:enable**: the availability to configure WAF managed rules.
   * *   **waf:phase:http_ratelimit:on_hit:enable**: the availability to configure whether to apply rate limiting to all requests that hit the cache.
   * *   **ddos**: DDoS mitigation.
   * *   **waf:phase:http_ratelimit:enable**: the availability to configure WAF rate limiting.
   * *   **waf:phase:http_custom:enable**: the availability to configure custom WAF rules.
   * *   **waf:phase:all:page:reference:enable**: the availability to configure custom error pages.
   * *   **rules_support_regex**: the support for regular expressions in rules engine.
   * *   **waiting_room_event**: scheduled events in Waiting Room.
   * *   **waiting_room_rule**: the availability to allow requests to bypass the waiting room.
   * *   **waiting_room|json_response**: the availability to enable JSON response in Waiting Room.
   * *   **waiting_room|disable_session_renewal**: the availability to disable session renewal in Waiting Room.
   * *   **origin_rules|dns_record**: DNS records in origin rules.
   * *   **managed_transforms|add_client_geolocation_headers**: the availability to configure whether to add geolocation headers in transform rules.
   * *   **tiered_cache|regional_enable**: regional tiered cache.
   * *   **real_client_ip_header**: the availability to configure whether to add the real IP address of a client to the request header.
   * *   **data_timerange**: minute-level time range for data query.
   * *   **cache_rules|edge_cache_ttl**: POP cache TTL.
   * *   **cache_rules|browser_cache_ttl**: browser cache TTL.
   * *   **fourLayerRecordCount**: the maximum number of records of websites for which TCP/UDP acceleration is enabled.
   * *   **waitingroomRuleCount**: the maximum number of rules per waiting room.
   * *   **waitingroomEventCount**: the maximum number of events per waiting room.
   * *   **waitingroom_custom_pathhost**: the availability to configure the hostname and path in Waiting Room.
   * *   **er_routers**: Edge Routine routes.
   * *   **cache_rules|rule_quota**: the maximum number of cache rules.
   * *   **configuration_rules|rule_quota**: the maximum number of configuration rules.
   * *   **redirect_rules|rule_quota**: the redirect rules.
   * *   **compression_rules|rule_quota**: the maximum number of compression rules.
   * *   **origin_rules|rule_quota**: the maximum number of origin rules.
   * *   **waf:phase:http_bot:rulesets_per_instance:less_than_or_equal**: the maximum number of rulesets in WAF bot management per plan.
   * *   **waf:phase:http_whitelist:rules_per_instance:less_than_or_equal**: the maximum number of WAF whitelist rules per plan.
   * *   **rtlog_quota**: the maximum number of real-time log delivery tasks.
   * *   **waf:phase:http_anti_scan:rulesets_per_instance:less_than_or_equal**: the maximum number of rulesets in WAF scan protection per plan.
   * *   **ddos_instance**: the number of Anti-DDoS Proxy instances.
   * *   **waf:phase:http_ratelimit:rules_per_instance:less_than_or_equal**: the maximum number of WAF rate limiting rules.
   * *   **waf:phase:http_custom:rules_per_instance:less_than_or_equal**: the maximum number of custom WAF rules per plan.
   * *   **ruleNestedConditionalCount**: the number of nested layers in a rule.
   * *   **waiting_room_rule**: Waiting Room.
   * *   **transition_rule**: the maximum number of transform rules.
   * *   **customHttpCert**: the maximum number of custom certificates.
   * *   **free_cert**: the maximum number of free certificates.
   * *   **preload**: prefetch.
   * *   **refresh_cache_tag**: purge by cache tag.
   * *   **refresh_ignore_param**: purge by URL with specified parameters ignored.
   * *   **refresh_directory**: purge by directory.
   * *   **refresh_hostname**: purge by hostname.
   * *   **refresh_all**: purge all cache.
   * *   **refresh_file**: purge by URL.
   * *   **wildcard**: the maximum number of wildcard domains.
   * *   **recordCount**: the maximum number of Layer 7 records.
   * *   **siteCount**: the maximum number of websites that can be associated with the plan.
   * *   **https|rule_quota**: the maximum number of SSL/TLS rules.
   * 
   * This parameter is required.
   * 
   * @example
   * preload, free_cert
   */
  quotaNames?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 2882900****
   * 
   * **if can be null:**
   * false
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      quotaNames: 'QuotaNames',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      quotaNames: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceQuotasResponseBody extends $dara.Model {
  /**
   * @remarks
   * The plan ID.
   * 
   * @example
   * sp-xcdn-96wblslz****
   */
  instanceId?: string;
  /**
   * @remarks
   * The quotas in the plan.
   */
  quotas?: ListInstanceQuotasResponseBodyQuotas[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247B78
   */
  requestId?: string;
  /**
   * @remarks
   * The plan status. Valid values:
   * 
   * *   online: The plan is in service.
   * *   offline: The plan has expired within an allowable period. In this state, the plan is unavailable.
   * *   disable: The plan is released.
   * 
   * @example
   * online
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      quotas: 'Quotas',
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      quotas: { 'type': 'array', 'itemType': ListInstanceQuotasResponseBodyQuotas },
      requestId: 'string',
      status: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.quotas)) {
      $dara.Model.validateArray(this.quotas);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceQuotasResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListInstanceQuotasResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListInstanceQuotasResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceQuotasWithUsageRequest extends $dara.Model {
  /**
   * @remarks
   * The plan ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * sp-xcdn-96wblslz****
   */
  instanceId?: string;
  /**
   * @remarks
   * The quota names in the plan. Separate the quota names with commas (,). You can query up to 10 quota names at a time. Valid values:
   * 
   * *   **customHttpCert**: the custom certificates.
   * *   **transition_rule**: the transform rules.
   * *   **waiting_room**: the waiting rooms.
   * *   **https|rule_quota**: the SSL/TLS rules.
   * *   **cache_rules|rule_quota**: the cache rules.
   * *   **configuration_rules|rule_quota**: the configuration rules.
   * *   **redirect_rules|rule_quota**: the redirect rules.
   * *   **compression_rules|rule_quota**: the compression rules.
   * *   **origin_rules|rule_quota**: the origin rules.
   * 
   * This parameter is required.
   * 
   * @example
   * customHttpCert
   */
  quotaNames?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 1232223****
   * 
   * **if can be null:**
   * false
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      quotaNames: 'QuotaNames',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      quotaNames: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceQuotasWithUsageResponseBody extends $dara.Model {
  /**
   * @remarks
   * The plan ID.[](~~2850189~~)
   * 
   * @example
   * sp-xcdn-96wblslz****
   */
  instanceId?: string;
  /**
   * @remarks
   * The quotas and their actual usage in the plan.
   */
  quotas?: ListInstanceQuotasWithUsageResponseBodyQuotas[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 85H66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  /**
   * @remarks
   * The plan status. Valid values:
   * 
   * *   online: The plan is in service.
   * *   offline: The plan has expired within an allowable period. In this state, the plan is unavailable.
   * *   disable: The plan is released.
   * 
   * @example
   * online
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      quotas: 'Quotas',
      requestId: 'RequestId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      quotas: { 'type': 'array', 'itemType': ListInstanceQuotasWithUsageResponseBodyQuotas },
      requestId: 'string',
      status: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.quotas)) {
      $dara.Model.validateArray(this.quotas);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceQuotasWithUsageResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListInstanceQuotasWithUsageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListInstanceQuotasWithUsageResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListKvsRequest extends $dara.Model {
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreatevNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  /**
   * @remarks
   * The page number. The product of PageNumber and PageSize cannot exceed 50,000.
   * 
   * @example
   * 10
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 50. Maximum value: 100.
   * 
   * @example
   * 50
   */
  pageSize?: number;
  /**
   * @remarks
   * The prefix to query.
   * 
   * @example
   * prefix-
   */
  prefix?: string;
  static names(): { [key: string]: string } {
    return {
      namespace: 'Namespace',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      prefix: 'Prefix',
    };
  }

  static types(): { [key: string]: any } {
    return {
      namespace: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      prefix: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListKvsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The key-value pairs.
   */
  keys?: ListKvsResponseBodyKeys[];
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 100
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 50
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 1024
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      keys: 'Keys',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keys: { 'type': 'array', 'itemType': ListKvsResponseBodyKeys },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.keys)) {
      $dara.Model.validateArray(this.keys);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListKvsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListKvsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListKvsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListListsRequest extends $dara.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The query arguments in the JSON format, which contain filter conditions.
   * 
   * @example
   * ListLists
   */
  queryArgs?: ListListsRequestQueryArgs;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      queryArgs: 'QueryArgs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      queryArgs: ListListsRequestQueryArgs,
    };
  }

  validate() {
    if(this.queryArgs && typeof (this.queryArgs as any).validate === 'function') {
      (this.queryArgs as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListListsShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The query arguments in the JSON format, which contain filter conditions.
   * 
   * @example
   * ListLists
   */
  queryArgsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      queryArgsShrink: 'QueryArgs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      queryArgsShrink: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListListsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The array that contains list information, including list data after paging.
   */
  lists?: ListListsResponseBodyLists[];
  /**
   * @remarks
   * The page number returned.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of filtered lists.
   * 
   * @example
   * 5
   */
  totalCount?: number;
  /**
   * @remarks
   * The number of created lists.
   * 
   * @example
   * 10
   */
  usage?: number;
  static names(): { [key: string]: string } {
    return {
      lists: 'Lists',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      usage: 'Usage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lists: { 'type': 'array', 'itemType': ListListsResponseBodyLists },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      usage: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.lists)) {
      $dara.Model.validateArray(this.lists);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListListsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListListsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListListsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLoadBalancerOriginStatusRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  loadBalancerIds?: string;
  poolType?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * ListLoadBalancerOriginStatus
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      loadBalancerIds: 'LoadBalancerIds',
      poolType: 'PoolType',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      loadBalancerIds: 'string',
      poolType: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLoadBalancerOriginStatusResponseBody extends $dara.Model {
  originStatus?: ListLoadBalancerOriginStatusResponseBodyOriginStatus[];
  /**
   * @remarks
   * Id of the request
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      originStatus: 'OriginStatus',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      originStatus: { 'type': 'array', 'itemType': ListLoadBalancerOriginStatusResponseBodyOriginStatus },
      requestId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.originStatus)) {
      $dara.Model.validateArray(this.originStatus);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLoadBalancerOriginStatusResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListLoadBalancerOriginStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListLoadBalancerOriginStatusResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLoadBalancerRegionsRequest extends $dara.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 1024
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLoadBalancerRegionsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 1024
   */
  pageSize?: number;
  /**
   * @remarks
   * The regions.
   */
  regions?: ListLoadBalancerRegionsResponseBodyRegions[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 81A5E222-24BF-17EF-9E80-A68D9B8F363D
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 12
   */
  totalCount?: number;
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 1
   */
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      regions: 'Regions',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      regions: { 'type': 'array', 'itemType': ListLoadBalancerRegionsResponseBodyRegions },
      requestId: 'string',
      totalCount: 'number',
      totalPage: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.regions)) {
      $dara.Model.validateArray(this.regions);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLoadBalancerRegionsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListLoadBalancerRegionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListLoadBalancerRegionsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLoadBalancersRequest extends $dara.Model {
  /**
   * @example
   * fuzzy
   */
  matchType?: string;
  /**
   * @example
   * lb.example.com
   */
  name?: string;
  /**
   * @example
   * id
   */
  orderBy?: string;
  /**
   * @example
   * ListLoadBalancers
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 21655860979****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      matchType: 'MatchType',
      name: 'Name',
      orderBy: 'OrderBy',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      matchType: 'string',
      name: 'string',
      orderBy: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLoadBalancersResponseBody extends $dara.Model {
  /**
   * @remarks
   * The load balancers returned.
   */
  loadBalancers?: ListLoadBalancersResponseBodyLoadBalancers[];
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * CB1A380B-09F0-41BB-A198-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  /**
   * @example
   * 10
   */
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      loadBalancers: 'LoadBalancers',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      loadBalancers: { 'type': 'array', 'itemType': ListLoadBalancersResponseBodyLoadBalancers },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      totalPage: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.loadBalancers)) {
      $dara.Model.validateArray(this.loadBalancers);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLoadBalancersResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListLoadBalancersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListLoadBalancersResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListManagedRulesGroupsRequest extends $dara.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListManagedRulesGroupsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The information about the managed rule groups.
   */
  managedRulesGroups?: ListManagedRulesGroupsResponseBodyManagedRulesGroups[];
  /**
   * @remarks
   * The page number returned.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of managed rule groups returned.
   * 
   * @example
   * 5
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      managedRulesGroups: 'ManagedRulesGroups',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      managedRulesGroups: { 'type': 'array', 'itemType': ListManagedRulesGroupsResponseBodyManagedRulesGroups },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.managedRulesGroups)) {
      $dara.Model.validateArray(this.managedRulesGroups);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListManagedRulesGroupsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListManagedRulesGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListManagedRulesGroupsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNetworkOptimizationsRequest extends $dara.Model {
  /**
   * @example
   * 3528160969****
   */
  configId?: number;
  /**
   * @example
   * global
   */
  configType?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * test
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1231231221****
   */
  siteId?: number;
  /**
   * @example
   * 1
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      configType: 'ConfigType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      configType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      ruleName: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNetworkOptimizationsResponseBody extends $dara.Model {
  configs?: ListNetworkOptimizationsResponseBodyConfigs[];
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  /**
   * @example
   * 2
   */
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      configs: 'Configs',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configs: { 'type': 'array', 'itemType': ListNetworkOptimizationsResponseBodyConfigs },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      totalPage: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.configs)) {
      $dara.Model.validateArray(this.configs);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNetworkOptimizationsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListNetworkOptimizationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListNetworkOptimizationsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOriginPoolsRequest extends $dara.Model {
  matchType?: string;
  name?: string;
  orderBy?: string;
  /**
   * @example
   * ListOriginPools
   */
  pageNumber?: number;
  pageSize?: number;
  /**
   * @remarks
   * This parameter is required.
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      matchType: 'MatchType',
      name: 'Name',
      orderBy: 'OrderBy',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      matchType: 'string',
      name: 'string',
      orderBy: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOriginPoolsResponseBody extends $dara.Model {
  originPools?: ListOriginPoolsResponseBodyOriginPools[];
  pageNumber?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      originPools: 'OriginPools',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      originPools: { 'type': 'array', 'itemType': ListOriginPoolsResponseBodyOriginPools },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      totalPage: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.originPools)) {
      $dara.Model.validateArray(this.originPools);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOriginPoolsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListOriginPoolsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListOriginPoolsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOriginRulesRequest extends $dara.Model {
  /**
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @example
   * global
   */
  configType?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * test
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @example
   * 1
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      configType: 'ConfigType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      configType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      ruleName: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOriginRulesResponseBody extends $dara.Model {
  configs?: ListOriginRulesResponseBodyConfigs[];
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  /**
   * @example
   * 2
   */
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      configs: 'Configs',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configs: { 'type': 'array', 'itemType': ListOriginRulesResponseBodyConfigs },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      totalPage: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.configs)) {
      $dara.Model.validateArray(this.configs);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOriginRulesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListOriginRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListOriginRulesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPagesRequest extends $dara.Model {
  /**
   * @remarks
   * The page number. Valid values: **1 to 100000**. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 20.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  queryArgs?: ListPagesRequestQueryArgs;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      queryArgs: 'QueryArgs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      queryArgs: ListPagesRequestQueryArgs,
    };
  }

  validate() {
    if(this.queryArgs && typeof (this.queryArgs as any).validate === 'function') {
      (this.queryArgs as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPagesShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The page number. Valid values: **1 to 100000**. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 20.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  queryArgsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      queryArgsShrink: 'QueryArgs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      queryArgsShrink: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPagesResponseBody extends $dara.Model {
  /**
   * @remarks
   * The page number returned.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The custom error pages. Each element in the array contains error page-specific information.
   */
  pages?: ListPagesResponseBodyPages[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  /**
   * @remarks
   * The number of custom error pages after filtering.
   * 
   * @example
   * 10
   */
  totalCount?: number;
  /**
   * @remarks
   * The number of custom error pages that you created.
   * 
   * @example
   * 10
   */
  usage?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      pages: 'Pages',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      usage: 'Usage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      pages: { 'type': 'array', 'itemType': ListPagesResponseBodyPages },
      requestId: 'string',
      totalCount: 'number',
      usage: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.pages)) {
      $dara.Model.validateArray(this.pages);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPagesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListPagesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPagesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRecordsRequest extends $dara.Model {
  /**
   * @remarks
   * The business scenario of the record for acceleration. Valid values:
   * 
   * *   **image_video**: video and image.
   * *   **api**: API.
   * *   **web**: web page.
   * 
   * @example
   * web
   */
  bizName?: string;
  /**
   * @remarks
   * The page number. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: **500**.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * Filters by whether the record is proxied. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  proxied?: boolean;
  /**
   * @remarks
   * The match mode to search for the record name. Default value: exact. Valid values:
   * 
   * *   **prefix**: match by prefix.
   * *   **suffix**: match by suffix.
   * *   **exact**: exact match.
   * *   **fuzzy**: fuzzy match.
   * 
   * @example
   * fuzzy
   */
  recordMatchType?: string;
  /**
   * @remarks
   * The record name. This parameter specifies a filter condition for the query.
   * 
   * @example
   * www.example.com
   */
  recordName?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The origin type of the record. Only CNAME records can be filtered by using this field. Valid values:
   * 
   * *   **OSS**: OSS bucket.
   * *   **S3**: S3 bucket.
   * *   **LB**: load balancer.
   * *   **OP**: origin pool.
   * *   **Domain**: domain name.
   * 
   * @example
   * OSS
   */
  sourceType?: string;
  /**
   * @remarks
   * The DNS record type.
   * 
   * @example
   * CNAME
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      bizName: 'BizName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      proxied: 'Proxied',
      recordMatchType: 'RecordMatchType',
      recordName: 'RecordName',
      siteId: 'SiteId',
      sourceType: 'SourceType',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      proxied: 'boolean',
      recordMatchType: 'string',
      recordName: 'string',
      siteId: 'number',
      sourceType: 'string',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRecordsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The page number returned.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The DNS record information. The format of this field varies based on the record type. For more information, see Add DNS records.
   */
  records?: ListRecordsResponseBodyRecords[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of records returned.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      records: 'Records',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      records: { 'type': 'array', 'itemType': ListRecordsResponseBodyRecords },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.records)) {
      $dara.Model.validateArray(this.records);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRecordsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRecordsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRedirectRulesRequest extends $dara.Model {
  /**
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @example
   * rule
   */
  configType?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456******
   */
  siteId?: number;
  /**
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      configType: 'ConfigType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      configType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      ruleName: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRedirectRulesResponseBody extends $dara.Model {
  configs?: ListRedirectRulesResponseBodyConfigs[];
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  /**
   * @example
   * 10
   */
  totalCount?: number;
  /**
   * @example
   * 1
   */
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      configs: 'Configs',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configs: { 'type': 'array', 'itemType': ListRedirectRulesResponseBodyConfigs },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      totalPage: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.configs)) {
      $dara.Model.validateArray(this.configs);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRedirectRulesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRedirectRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRedirectRulesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRewriteUrlRulesRequest extends $dara.Model {
  /**
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @example
   * global
   */
  configType?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456789****
   */
  siteId?: number;
  /**
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      configType: 'ConfigType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      configType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      ruleName: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRewriteUrlRulesResponseBody extends $dara.Model {
  configs?: ListRewriteUrlRulesResponseBodyConfigs[];
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * CB1A380B-09F0-41BB-280B-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @example
   * 8
   */
  totalCount?: number;
  /**
   * @example
   * 1
   */
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      configs: 'Configs',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configs: { 'type': 'array', 'itemType': ListRewriteUrlRulesResponseBodyConfigs },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      totalPage: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.configs)) {
      $dara.Model.validateArray(this.configs);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRewriteUrlRulesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRewriteUrlRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRewriteUrlRulesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRoutineCanaryAreasResponseBody extends $dara.Model {
  /**
   * @remarks
   * The regions for canary release.
   */
  canaryAreas?: string[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      canaryAreas: 'CanaryAreas',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canaryAreas: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.canaryAreas)) {
      $dara.Model.validateArray(this.canaryAreas);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRoutineCanaryAreasResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRoutineCanaryAreasResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRoutineCanaryAreasResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRoutineOptionalSpecsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1234567890ABCDEF01234567890ABCDEF
   */
  requestId?: string;
  /**
   * @remarks
   * The available specifications.
   */
  specs?: ListRoutineOptionalSpecsResponseBodySpecs[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      specs: 'Specs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      specs: { 'type': 'array', 'itemType': ListRoutineOptionalSpecsResponseBodySpecs },
    };
  }

  validate() {
    if(Array.isArray(this.specs)) {
      $dara.Model.validateArray(this.specs);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRoutineOptionalSpecsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRoutineOptionalSpecsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRoutineOptionalSpecsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScheduledPreloadExecutionsRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the scheduled prefetch task.
   * 
   * This parameter is required.
   * 
   * @example
   * ListScheduledPreloadExecutions
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScheduledPreloadExecutionsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The information about prefetch plans returned.
   */
  executions?: ListScheduledPreloadExecutionsResponseBodyExecutions[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * ET5BF670-09D5-4D0B-BEBY-D96A2A528000
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      executions: 'Executions',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      executions: { 'type': 'array', 'itemType': ListScheduledPreloadExecutionsResponseBodyExecutions },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.executions)) {
      $dara.Model.validateArray(this.executions);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScheduledPreloadExecutionsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListScheduledPreloadExecutionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListScheduledPreloadExecutionsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScheduledPreloadJobsRequest extends $dara.Model {
  /**
   * @remarks
   * The end time for querying the task creation time range. Specify the timestamp in milliseconds.
   * 
   * @example
   * 1717225277000
   */
  endTime?: number;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The website ID.
   * 
   * This parameter is required.
   * 
   * @example
   * ListScheduledPreloadJobs
   */
  siteId?: number;
  /**
   * @remarks
   * The beginning of the task creation time range to query. Specify the timestamp in milliseconds.
   * 
   * @example
   * 1717225276000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      siteId: 'SiteId',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      siteId: 'number',
      startTime: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScheduledPreloadJobsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The list of the prefetch tasks.
   */
  jobs?: ListScheduledPreloadJobsResponseBodyJobs[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CB1A380B-09F0-41BB-A198-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of tasks returned.
   * 
   * @example
   * 5
   */
  totalCount?: string;
  static names(): { [key: string]: string } {
    return {
      jobs: 'Jobs',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobs: { 'type': 'array', 'itemType': ListScheduledPreloadJobsResponseBodyJobs },
      requestId: 'string',
      totalCount: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.jobs)) {
      $dara.Model.validateArray(this.jobs);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListScheduledPreloadJobsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListScheduledPreloadJobsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListScheduledPreloadJobsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteDeliveryTasksRequest extends $dara.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * *   dcdn_log_access_l1 (default): access logs.
   * *   dcdn_log_er: Edge Routine logs.
   * *   dcdn_log_waf: firewall logs.
   * *   dcdn_log_ipa: TCP/UDP proxy logs.
   * 
   * @example
   * dcdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The page number. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 20.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456***
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteDeliveryTasksResponseBody extends $dara.Model {
  /**
   * @remarks
   * The page number. Default value: 0.
   * 
   * @example
   * 0
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: **1 to 500**. Default value: **20**.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 34DCBC8A-****-****-****-6DAA11D7DDBD
   */
  requestId?: string;
  /**
   * @remarks
   * The delivery tasks.
   */
  tasks?: ListSiteDeliveryTasksResponseBodyTasks[];
  /**
   * @remarks
   * The total number of log delivery tasks.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      tasks: 'Tasks',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      tasks: { 'type': 'array', 'itemType': ListSiteDeliveryTasksResponseBodyTasks },
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.tasks)) {
      $dara.Model.validateArray(this.tasks);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSiteDeliveryTasksResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSiteDeliveryTasksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSiteDeliveryTasksResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSitesRequest extends $dara.Model {
  /**
   * @remarks
   * The DNS setup. Valid values:
   * 
   * *   **NS**
   * *   **CNAME**
   * 
   * @example
   * NS
   */
  accessType?: string;
  /**
   * @remarks
   * The service location. Valid values:
   * 
   * *   **domestic**: the Chinese Mainland
   * *   **global**: global (including the Chinese Mainland)
   * *   **overseas**: outside the Chinese Mainland
   * 
   * @example
   * global
   */
  coverage?: string;
  /**
   * @remarks
   * Specifies whether to query only websites on Enterprise plans. Valid values: **true and false**.
   * 
   * @example
   * false
   */
  onlyEnterprise?: boolean;
  /**
   * @remarks
   * null
   * 
   * *   null
   * *   null
   * 
   * @example
   * visitTime
   */
  orderBy?: string;
  /**
   * @remarks
   * The page number. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 500.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The plan type. Valid values:
   * 
   * *   **basicplan**: Entrance
   * *   **standardplan**: Pro
   * *   **advancedplan**: Premium
   * *   **enterpriseplan**: Enterprise
   * 
   * @example
   * basicplan
   */
  planSubscribeType?: string;
  /**
   * @remarks
   * The ID of the resource group. This parameter specifies a filter condition for the query.
   * 
   * @example
   * rg-aekzd3styujvyei
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The website name. This parameter specifies a filter condition for the query.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  /**
   * @remarks
   * The match mode to search for the website name. Default value: exact. Valid values:
   * 
   * *   **prefix**: match by prefix.
   * *   **suffix**: match by suffix.
   * *   **null**
   * *   **fuzzy**: fuzzy match.
   * 
   * @example
   * fuzzy
   */
  siteSearchType?: string;
  /**
   * @remarks
   * The website status. This parameter specifies a filter condition for the query.
   * 
   * @example
   * pending
   */
  status?: string;
  /**
   * @remarks
   * The tag filtering rule.
   */
  tagFilter?: ListSitesRequestTagFilter[];
  static names(): { [key: string]: string } {
    return {
      accessType: 'AccessType',
      coverage: 'Coverage',
      onlyEnterprise: 'OnlyEnterprise',
      orderBy: 'OrderBy',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      planSubscribeType: 'PlanSubscribeType',
      resourceGroupId: 'ResourceGroupId',
      siteName: 'SiteName',
      siteSearchType: 'SiteSearchType',
      status: 'Status',
      tagFilter: 'TagFilter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessType: 'string',
      coverage: 'string',
      onlyEnterprise: 'boolean',
      orderBy: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      planSubscribeType: 'string',
      resourceGroupId: 'string',
      siteName: 'string',
      siteSearchType: 'string',
      status: 'string',
      tagFilter: { 'type': 'array', 'itemType': ListSitesRequestTagFilter },
    };
  }

  validate() {
    if(Array.isArray(this.tagFilter)) {
      $dara.Model.validateArray(this.tagFilter);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSitesShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The DNS setup. Valid values:
   * 
   * *   **NS**
   * *   **CNAME**
   * 
   * @example
   * NS
   */
  accessType?: string;
  /**
   * @remarks
   * The service location. Valid values:
   * 
   * *   **domestic**: the Chinese Mainland
   * *   **global**: global (including the Chinese Mainland)
   * *   **overseas**: outside the Chinese Mainland
   * 
   * @example
   * global
   */
  coverage?: string;
  /**
   * @remarks
   * Specifies whether to query only websites on Enterprise plans. Valid values: **true and false**.
   * 
   * @example
   * false
   */
  onlyEnterprise?: boolean;
  /**
   * @remarks
   * null
   * 
   * *   null
   * *   null
   * 
   * @example
   * visitTime
   */
  orderBy?: string;
  /**
   * @remarks
   * The page number. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 500.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The plan type. Valid values:
   * 
   * *   **basicplan**: Entrance
   * *   **standardplan**: Pro
   * *   **advancedplan**: Premium
   * *   **enterpriseplan**: Enterprise
   * 
   * @example
   * basicplan
   */
  planSubscribeType?: string;
  /**
   * @remarks
   * The ID of the resource group. This parameter specifies a filter condition for the query.
   * 
   * @example
   * rg-aekzd3styujvyei
   */
  resourceGroupId?: string;
  /**
   * @remarks
   * The website name. This parameter specifies a filter condition for the query.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  /**
   * @remarks
   * The match mode to search for the website name. Default value: exact. Valid values:
   * 
   * *   **prefix**: match by prefix.
   * *   **suffix**: match by suffix.
   * *   **null**
   * *   **fuzzy**: fuzzy match.
   * 
   * @example
   * fuzzy
   */
  siteSearchType?: string;
  /**
   * @remarks
   * The website status. This parameter specifies a filter condition for the query.
   * 
   * @example
   * pending
   */
  status?: string;
  /**
   * @remarks
   * The tag filtering rule.
   */
  tagFilterShrink?: string;
  static names(): { [key: string]: string } {
    return {
      accessType: 'AccessType',
      coverage: 'Coverage',
      onlyEnterprise: 'OnlyEnterprise',
      orderBy: 'OrderBy',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      planSubscribeType: 'PlanSubscribeType',
      resourceGroupId: 'ResourceGroupId',
      siteName: 'SiteName',
      siteSearchType: 'SiteSearchType',
      status: 'Status',
      tagFilterShrink: 'TagFilter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessType: 'string',
      coverage: 'string',
      onlyEnterprise: 'boolean',
      orderBy: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      planSubscribeType: 'string',
      resourceGroupId: 'string',
      siteName: 'string',
      siteSearchType: 'string',
      status: 'string',
      tagFilterShrink: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSitesResponseBody extends $dara.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of websites per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  /**
   * @remarks
   * The queried websites.
   */
  sites?: ListSitesResponseBodySites[];
  /**
   * @remarks
   * The total number of websites.
   * 
   * @example
   * 40
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      sites: 'Sites',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      sites: { 'type': 'array', 'itemType': ListSitesResponseBodySites },
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.sites)) {
      $dara.Model.validateArray(this.sites);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSitesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSitesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSitesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesRequest extends $dara.Model {
  /**
   * @remarks
   * The maximum number of tags to return.
   * 
   * @example
   * 20
   */
  maxItem?: number;
  /**
   * @remarks
   * The pagination token that is used in the next request to retrieve a new page of results.
   * 
   * >  This parameter is not required for the first request. If not all results are returned in one query, you can specify the token that is obtained from the previous query as the value of **NextToken**.
   * 
   * @example
   * AAAAAZjtYxxxxxxxx
   */
  nextToken?: string;
  ownerId?: number;
  /**
   * @remarks
   * The ID of the region where the resources reside.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The website ID.
   */
  resourceId?: string[];
  /**
   * @remarks
   * The resource type.
   * 
   * This parameter is required.
   * 
   * @example
   * site
   */
  resourceType?: string;
  securityToken?: string;
  /**
   * @remarks
   * A list of tags. You can enter up to 20 tags.
   */
  tag?: ListTagResourcesRequestTag[];
  static names(): { [key: string]: string } {
    return {
      maxItem: 'MaxItem',
      nextToken: 'NextToken',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      securityToken: 'SecurityToken',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxItem: 'number',
      nextToken: 'string',
      ownerId: 'number',
      regionId: 'string',
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      securityToken: 'string',
      tag: { 'type': 'array', 'itemType': ListTagResourcesRequestTag },
    };
  }

  validate() {
    if(Array.isArray(this.resourceId)) {
      $dara.Model.validateArray(this.resourceId);
    }
    if(Array.isArray(this.tag)) {
      $dara.Model.validateArray(this.tag);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponseBody extends $dara.Model {
  /**
   * @remarks
   * The pagination token that is used in the next request to retrieve a new page of results. If NextToken is empty, no next page exists.
   * 
   * @example
   * AAAAAYwsxxxxxxx
   */
  nextToken?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CB1A380B-09F0-41BB-280B-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @remarks
   * The tags of the resource.
   */
  tagResources?: ListTagResourcesResponseBodyTagResources[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 16
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      nextToken: 'NextToken',
      requestId: 'RequestId',
      tagResources: 'TagResources',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextToken: 'string',
      requestId: 'string',
      tagResources: { 'type': 'array', 'itemType': ListTagResourcesResponseBodyTagResources },
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.tagResources)) {
      $dara.Model.validateArray(this.tagResources);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTagResourcesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUploadTasksRequest extends $dara.Model {
  /**
   * @remarks
   * The time when the task ends. Specify the time in the YYYY-MM-DDThh:mm:ssZ format.
   * 
   * @example
   * 2019-12-06T12:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The time when the task starts. Specify the time in the YYYY-MM-DDThh:mm:ssZ format.
   * 
   * @example
   * 2018-11-29T00:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The task type. Valid values:
   * 
   * *   **file**: purges the cache by file URL.
   * *   **preload**: prefetches files.
   * *   **directory**: purges the cache by directory.
   * *   **ignoreparams**: purges the cache by URL with specified parameters ignored.
   * 
   * @example
   * file
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      siteId: 'SiteId',
      startTime: 'StartTime',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      siteId: 'number',
      startTime: 'string',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUploadTasksResponseBody extends $dara.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * CB1A380B-09F0-41BB-A198-72F8FD6D****
   */
  requestId?: string;
  /**
   * @remarks
   * The file upload tasks.
   */
  tasks?: ListUploadTasksResponseBodyTasks[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tasks: 'Tasks',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tasks: { 'type': 'array', 'itemType': ListUploadTasksResponseBodyTasks },
    };
  }

  validate() {
    if(Array.isArray(this.tasks)) {
      $dara.Model.validateArray(this.tasks);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUploadTasksResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListUploadTasksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListUploadTasksResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserDeliveryTasksRequest extends $dara.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * 1.  dcdn_log_access_l1 (default): access logs.
   * 2.  dcdn_log_er: Edge Routine logs.
   * 3.  dcdn_log_waf: firewall logs.
   * 4.  dcdn_log_ipa: TCP/UDP proxy logs.
   * 
   * @example
   * dcdn_log_access_l1
   */
  businessType?: string;
  /**
   * @remarks
   * The page number. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 20.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserDeliveryTasksResponseBody extends $dara.Model {
  /**
   * @remarks
   * The page number returned.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1f94c47f-3a1a-4f69-8d6c-bfeee1b49aab
   */
  requestId?: string;
  /**
   * @remarks
   * The delivery tasks.
   */
  tasks?: ListUserDeliveryTasksResponseBodyTasks[];
  /**
   * @remarks
   * The total number of delivery tasks.
   * 
   * @example
   * 68
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      tasks: 'Tasks',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      tasks: { 'type': 'array', 'itemType': ListUserDeliveryTasksResponseBodyTasks },
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.tasks)) {
      $dara.Model.validateArray(this.tasks);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserDeliveryTasksResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListUserDeliveryTasksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListUserDeliveryTasksResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserRatePlanInstancesRequest extends $dara.Model {
  /**
   * @remarks
   * Specifies whether to query only the plans that have remaining quota for associating websites. Valid values:
   * 
   * *   true: queries only the plans that have remaining quota for associating websites.
   * *   false: queries all plans in your account.
   * 
   * @example
   * true
   */
  checkRemainingSiteQuota?: string;
  /**
   * @remarks
   * The plan ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * sp-xcdn-96wblslz****
   */
  instanceId?: string;
  /**
   * @remarks
   * The page number. Valid values: **1** to **100000**. Default value: **1**.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 500
   */
  pageSize?: number;
  remainingExpireDays?: number;
  /**
   * @remarks
   * The sorting field. By default, the queried plans are sorted by purchase time. Valid values:
   * 
   * *   CreateTime: the time when the plans were purchased.
   * *   ExpireTime: the time when the plans expire.
   * 
   * @example
   * CreateTime
   */
  sortBy?: string;
  /**
   * @remarks
   * The order in which you want to sort the query results. Default value: desc. Valid values:
   * 
   * *   asc: in ascending order.
   * *   desc: in descending order.
   * 
   * @example
   * asc
   */
  sortOrder?: string;
  /**
   * @remarks
   * The plan status. Valid values:
   * 
   * *   online: The plan is in service.
   * *   offline: The plan has expired within an allowable period. In this state, the plan is unavailable.
   * *   disable: The plan is released.
   * *   overdue: The plan is stopped due to overdue payments.
   * 
   * @example
   * online
   * 
   * **if can be null:**
   * false
   */
  status?: string;
  subscribeType?: string;
  static names(): { [key: string]: string } {
    return {
      checkRemainingSiteQuota: 'CheckRemainingSiteQuota',
      instanceId: 'InstanceId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      remainingExpireDays: 'RemainingExpireDays',
      sortBy: 'SortBy',
      sortOrder: 'SortOrder',
      status: 'Status',
      subscribeType: 'SubscribeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkRemainingSiteQuota: 'string',
      instanceId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      remainingExpireDays: 'number',
      sortBy: 'string',
      sortOrder: 'string',
      status: 'string',
      subscribeType: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserRatePlanInstancesResponseBody extends $dara.Model {
  /**
   * @remarks
   * The queried plans.
   */
  instanceInfo?: ListUserRatePlanInstancesResponseBodyInstanceInfo[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CB1A380B-09F0-41BB-3C82-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 68
   */
  totalCount?: number;
  /**
   * @remarks
   * The total number of pages returned.
   * 
   * @example
   * 1
   */
  totalPage?: number;
  static names(): { [key: string]: string } {
    return {
      instanceInfo: 'InstanceInfo',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      totalPage: 'TotalPage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceInfo: { 'type': 'array', 'itemType': ListUserRatePlanInstancesResponseBodyInstanceInfo },
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      totalPage: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.instanceInfo)) {
      $dara.Model.validateArray(this.instanceInfo);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUserRatePlanInstancesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListUserRatePlanInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListUserRatePlanInstancesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafManagedRulesRequest extends $dara.Model {
  /**
   * @remarks
   * The attack type. Valid values:
   * 
   * *   SQL injection
   * *   Cross-site scripting
   * *   Code execution
   * *   CRLF
   * *   Local file inclusion
   * *   Remote file inclusion
   * *   webshell
   * *   Cross-site request forgery
   * *   Others
   * *   SEMA
   * 
   * This parameter is required.
   * 
   * @example
   * 11
   */
  attackType?: number;
  /**
   * @remarks
   * The ID of the WAF rule.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000001
   */
  id?: number;
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   **en**: English.
   * *   **zh**: Chinese.
   * 
   * @example
   * zh
   */
  language?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  protectionLevel?: number;
  /**
   * @remarks
   * The query conditions.
   */
  queryArgs?: ListWafManagedRulesRequestQueryArgs;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      attackType: 'AttackType',
      id: 'Id',
      language: 'Language',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      protectionLevel: 'ProtectionLevel',
      queryArgs: 'QueryArgs',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attackType: 'number',
      id: 'number',
      language: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      protectionLevel: 'number',
      queryArgs: ListWafManagedRulesRequestQueryArgs,
      siteId: 'number',
    };
  }

  validate() {
    if(this.queryArgs && typeof (this.queryArgs as any).validate === 'function') {
      (this.queryArgs as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafManagedRulesShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The attack type. Valid values:
   * 
   * *   SQL injection
   * *   Cross-site scripting
   * *   Code execution
   * *   CRLF
   * *   Local file inclusion
   * *   Remote file inclusion
   * *   webshell
   * *   Cross-site request forgery
   * *   Others
   * *   SEMA
   * 
   * This parameter is required.
   * 
   * @example
   * 11
   */
  attackType?: number;
  /**
   * @remarks
   * The ID of the WAF rule.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000001
   */
  id?: number;
  /**
   * @remarks
   * The language of the response. Valid values:
   * 
   * *   **en**: English.
   * *   **zh**: Chinese.
   * 
   * @example
   * zh
   */
  language?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  protectionLevel?: number;
  /**
   * @remarks
   * The query conditions.
   */
  queryArgsShrink?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      attackType: 'AttackType',
      id: 'Id',
      language: 'Language',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      protectionLevel: 'ProtectionLevel',
      queryArgsShrink: 'QueryArgs',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attackType: 'number',
      id: 'number',
      language: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      protectionLevel: 'number',
      queryArgsShrink: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafManagedRulesResponseBody extends $dara.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  /**
   * @remarks
   * The managed rules.
   */
  rules?: ListWafManagedRulesResponseBodyRules[];
  /**
   * @remarks
   * The total number of filtered rules.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      rules: 'Rules',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      requestId: 'string',
      rules: { 'type': 'array', 'itemType': ListWafManagedRulesResponseBodyRules },
      totalCount: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.rules)) {
      $dara.Model.validateArray(this.rules);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafManagedRulesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWafManagedRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWafManagedRulesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafPhasesRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  siteId?: number;
  /**
   * @remarks
   * The version of the website.
   * 
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafPhasesResponseBody extends $dara.Model {
  /**
   * @remarks
   * The WAF rule categories.
   */
  phases?: ListWafPhasesResponseBodyPhases[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      phases: 'Phases',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      phases: { 'type': 'array', 'itemType': ListWafPhasesResponseBodyPhases },
      requestId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.phases)) {
      $dara.Model.validateArray(this.phases);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafPhasesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWafPhasesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWafPhasesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafTemplateRulesRequest extends $dara.Model {
  /**
   * @remarks
   * The WAF rule category, which is used to filter template rules of a specific category.
   * 
   * @example
   * http_anti_scan
   */
  phase?: string;
  /**
   * @remarks
   * The query parameter, which is used to filter template rules based on criteria such as the rule type.
   * 
   * @example
   * http_anti_scan
   */
  queryArgs?: ListWafTemplateRulesRequestQueryArgs;
  /**
   * @remarks
   * ID[ListSites](https://help.aliyun.com/document_detail/2850189.html)
   * 
   * @example
   * 1
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      phase: 'Phase',
      queryArgs: 'QueryArgs',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      phase: 'string',
      queryArgs: ListWafTemplateRulesRequestQueryArgs,
      siteId: 'number',
    };
  }

  validate() {
    if(this.queryArgs && typeof (this.queryArgs as any).validate === 'function') {
      (this.queryArgs as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafTemplateRulesShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The WAF rule category, which is used to filter template rules of a specific category.
   * 
   * @example
   * http_anti_scan
   */
  phase?: string;
  /**
   * @remarks
   * The query parameter, which is used to filter template rules based on criteria such as the rule type.
   * 
   * @example
   * http_anti_scan
   */
  queryArgsShrink?: string;
  /**
   * @remarks
   * ID[ListSites](https://help.aliyun.com/document_detail/2850189.html)
   * 
   * @example
   * 1
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      phase: 'Phase',
      queryArgsShrink: 'QueryArgs',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      phase: 'string',
      queryArgsShrink: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafTemplateRulesResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  /**
   * @remarks
   * The returned template rules.
   */
  rules?: ListWafTemplateRulesResponseBodyRules[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      rules: 'Rules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      rules: { 'type': 'array', 'itemType': ListWafTemplateRulesResponseBodyRules },
    };
  }

  validate() {
    if(Array.isArray(this.rules)) {
      $dara.Model.validateArray(this.rules);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafTemplateRulesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWafTemplateRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWafTemplateRulesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafUsageOfRulesRequest extends $dara.Model {
  /**
   * @remarks
   * The WAF rule category.
   * 
   * @example
   * http_anti_scan
   */
  phase?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * ListWafUsageOfRules
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      phase: 'Phase',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      phase: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafUsageOfRulesResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  /**
   * @remarks
   * The usage details of WAF rules of the website.
   */
  sites?: ListWafUsageOfRulesResponseBodySites[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      sites: 'Sites',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      sites: { 'type': 'array', 'itemType': ListWafUsageOfRulesResponseBodySites },
    };
  }

  validate() {
    if(Array.isArray(this.sites)) {
      $dara.Model.validateArray(this.sites);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWafUsageOfRulesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWafUsageOfRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWafUsageOfRulesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWaitingRoomEventsRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 7096621098****
   */
  siteId?: number;
  /**
   * @remarks
   * The ID of the waiting room event. This parameter is optional. You can specify this parameter to query a specific waiting room event.
   * 
   * @example
   * 89677721098****
   */
  waitingRoomEventId?: number;
  /**
   * @remarks
   * The unique ID of the waiting room, which can be obtained by calling the [ListWaitingRooms](https://help.aliyun.com/document_detail/2850279.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 6a51d5bc6460887abd129****
   */
  waitingRoomId?: string;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      waitingRoomEventId: 'WaitingRoomEventId',
      waitingRoomId: 'WaitingRoomId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      waitingRoomEventId: 'number',
      waitingRoomId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWaitingRoomEventsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID, which is used to trace a call.
   * 
   * @example
   * f3c3700a-4c0f-4a24-b576-fd7dbf9e7c55
   */
  requestId?: string;
  /**
   * @remarks
   * The details of the waiting room events.
   */
  waitingRoomEvents?: ListWaitingRoomEventsResponseBodyWaitingRoomEvents[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      waitingRoomEvents: 'WaitingRoomEvents',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      waitingRoomEvents: { 'type': 'array', 'itemType': ListWaitingRoomEventsResponseBodyWaitingRoomEvents },
    };
  }

  validate() {
    if(Array.isArray(this.waitingRoomEvents)) {
      $dara.Model.validateArray(this.waitingRoomEvents);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWaitingRoomEventsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWaitingRoomEventsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWaitingRoomEventsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWaitingRoomRulesRequest extends $dara.Model {
  /**
   * @remarks
   * Optional. The rule name, which can be used to query a specific bypass rule.
   * 
   * @example
   * test
   */
  ruleName?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The ID of the waiting room to be bypassed, which can be obtained by calling the [ListWatingRooms](https://help.aliyun.com/document_detail/2850279.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 6a51d5bc6460887abd129****
   */
  waitingRoomId?: string;
  /**
   * @remarks
   * Optional. The rule ID, which can be used to query a specific rule.
   * 
   * @example
   * 37286782688****
   */
  waitingRoomRuleId?: number;
  static names(): { [key: string]: string } {
    return {
      ruleName: 'RuleName',
      siteId: 'SiteId',
      waitingRoomId: 'WaitingRoomId',
      waitingRoomRuleId: 'WaitingRoomRuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleName: 'string',
      siteId: 'number',
      waitingRoomId: 'string',
      waitingRoomRuleId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWaitingRoomRulesResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID, which is used to trace a call.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A123425345
   */
  requestId?: string;
  /**
   * @remarks
   * The waiting room bypass rules.
   */
  waitingRoomRules?: ListWaitingRoomRulesResponseBodyWaitingRoomRules[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      waitingRoomRules: 'WaitingRoomRules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      waitingRoomRules: { 'type': 'array', 'itemType': ListWaitingRoomRulesResponseBodyWaitingRoomRules },
    };
  }

  validate() {
    if(Array.isArray(this.waitingRoomRules)) {
      $dara.Model.validateArray(this.waitingRoomRules);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWaitingRoomRulesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWaitingRoomRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWaitingRoomRulesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWaitingRoomsRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 120876698010528
   */
  siteId?: number;
  /**
   * @remarks
   * The ID of the waiting room. Specify this parameter to query the information about a specific waiting room.
   * 
   * @example
   * 6a51d5bc6460887abd1291dc7d4d****
   */
  waitingRoomId?: string;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      waitingRoomId: 'WaitingRoomId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      waitingRoomId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWaitingRoomsResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID, which is used to trace a call.
   * 
   * @example
   * CB1A380B-09F0-41BB-A198-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @remarks
   * The waiting rooms.
   */
  waitingRooms?: ListWaitingRoomsResponseBodyWaitingRooms[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      waitingRooms: 'WaitingRooms',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      waitingRooms: { 'type': 'array', 'itemType': ListWaitingRoomsResponseBodyWaitingRooms },
    };
  }

  validate() {
    if(Array.isArray(this.waitingRooms)) {
      $dara.Model.validateArray(this.waitingRooms);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListWaitingRoomsResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListWaitingRoomsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListWaitingRoomsResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreloadCachesRequest extends $dara.Model {
  /**
   * @remarks
   * The files to be prefetched.
   */
  content?: string[];
  /**
   * @remarks
   * By default, prefetch requests include the Accept-Encoding:gzip header. If you want a prefetch request to include other headers or implement multi-replica prefetch, you can specify a custom prefetch header by configuring the Headers parameter.
   */
  headers?: { [key: string]: string };
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * @example
   * 123456789****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      headers: 'Headers',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'array', 'itemType': 'string' },
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      siteId: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.content)) {
      $dara.Model.validateArray(this.content);
    }
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreloadCachesShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The files to be prefetched.
   */
  contentShrink?: string;
  /**
   * @remarks
   * By default, prefetch requests include the Accept-Encoding:gzip header. If you want a prefetch request to include other headers or implement multi-replica prefetch, you can specify a custom prefetch header by configuring the Headers parameter.
   */
  headersShrink?: string;
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * @example
   * 123456789****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      contentShrink: 'Content',
      headersShrink: 'Headers',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentShrink: 'string',
      headersShrink: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreloadCachesResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9732E117-8A37-49FD-A36F-ABBB87556CA7
   */
  requestId?: string;
  /**
   * @remarks
   * The prefetch task ID.
   * 
   * @example
   * 16401427840
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      taskId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PreloadCachesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PreloadCachesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PreloadCachesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishEdgeContainerAppVersionRequest extends $dara.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * This parameter is required.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * Specifies whether to fully release the version. This parameter takes effect only when PublishType is set to region.
   * 
   * @example
   * true
   */
  fullRelease?: boolean;
  /**
   * @remarks
   * The release percentage. Valid values: 1 to 100. Default value: 100.
   * 
   * @example
   * 100
   */
  percentage?: number;
  /**
   * @remarks
   * The environment to which you want to release the version. Valid values:
   * 
   * *   prod: the production environment.
   * *   staging: the staging environment.
   * 
   * This parameter is required.
   * 
   * @example
   * prod
   */
  publishEnv?: string;
  /**
   * @remarks
   * Specifies how the version is released. Valid values:
   * 
   * *   percentage: releases the version by percentage.
   * *   region: releases the version by region.
   * 
   * If you do not specify this parameter, the version is released by percentage by default.
   * 
   * @example
   * percentage
   */
  publishType?: string;
  /**
   * @remarks
   * The regions to which the version is released.
   */
  regions?: string[];
  /**
   * @remarks
   * The remarks. This parameter is empty by default.
   * 
   * @example
   * test publish app
   */
  remarks?: string;
  /**
   * @remarks
   * The time when the application version starts to be released. If you do not specify this parameter, the current time is used by default.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2023-06-05T16:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The version ID.
   * 
   * This parameter is required.
   * 
   * @example
   * ver-87962637161651****
   */
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      fullRelease: 'FullRelease',
      percentage: 'Percentage',
      publishEnv: 'PublishEnv',
      publishType: 'PublishType',
      regions: 'Regions',
      remarks: 'Remarks',
      startTime: 'StartTime',
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      fullRelease: 'boolean',
      percentage: 'number',
      publishEnv: 'string',
      publishType: 'string',
      regions: { 'type': 'array', 'itemType': 'string' },
      remarks: 'string',
      startTime: 'string',
      versionId: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.regions)) {
      $dara.Model.validateArray(this.regions);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishEdgeContainerAppVersionShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * This parameter is required.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * Specifies whether to fully release the version. This parameter takes effect only when PublishType is set to region.
   * 
   * @example
   * true
   */
  fullRelease?: boolean;
  /**
   * @remarks
   * The release percentage. Valid values: 1 to 100. Default value: 100.
   * 
   * @example
   * 100
   */
  percentage?: number;
  /**
   * @remarks
   * The environment to which you want to release the version. Valid values:
   * 
   * *   prod: the production environment.
   * *   staging: the staging environment.
   * 
   * This parameter is required.
   * 
   * @example
   * prod
   */
  publishEnv?: string;
  /**
   * @remarks
   * Specifies how the version is released. Valid values:
   * 
   * *   percentage: releases the version by percentage.
   * *   region: releases the version by region.
   * 
   * If you do not specify this parameter, the version is released by percentage by default.
   * 
   * @example
   * percentage
   */
  publishType?: string;
  /**
   * @remarks
   * The regions to which the version is released.
   */
  regionsShrink?: string;
  /**
   * @remarks
   * The remarks. This parameter is empty by default.
   * 
   * @example
   * test publish app
   */
  remarks?: string;
  /**
   * @remarks
   * The time when the application version starts to be released. If you do not specify this parameter, the current time is used by default.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * @example
   * 2023-06-05T16:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The version ID.
   * 
   * This parameter is required.
   * 
   * @example
   * ver-87962637161651****
   */
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      fullRelease: 'FullRelease',
      percentage: 'Percentage',
      publishEnv: 'PublishEnv',
      publishType: 'PublishType',
      regionsShrink: 'Regions',
      remarks: 'Remarks',
      startTime: 'StartTime',
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      fullRelease: 'boolean',
      percentage: 'number',
      publishEnv: 'string',
      publishType: 'string',
      regionsShrink: 'string',
      remarks: 'string',
      startTime: 'string',
      versionId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishEdgeContainerAppVersionResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishEdgeContainerAppVersionResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PublishEdgeContainerAppVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PublishEdgeContainerAppVersionResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishRoutineCodeVersionRequest extends $dara.Model {
  /**
   * @remarks
   * The regions for canary release.
   */
  canaryAreaList?: string[];
  /**
   * @remarks
   * The version number for canary release.
   * 
   * @example
   * 1710120201067203242
   */
  canaryCodeVersion?: string;
  /**
   * @remarks
   * The code version to be released.
   * 
   * @example
   * 1710120201067203242
   */
  codeVersion?: string;
  /**
   * @remarks
   * The environment name.
   * 
   * This parameter is required.
   * 
   * @example
   * production
   */
  env?: string;
  /**
   * @remarks
   * The routine name.
   * 
   * This parameter is required.
   * 
   * @example
   * PublishRoutineCodeVersion
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      canaryAreaList: 'CanaryAreaList',
      canaryCodeVersion: 'CanaryCodeVersion',
      codeVersion: 'CodeVersion',
      env: 'Env',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canaryAreaList: { 'type': 'array', 'itemType': 'string' },
      canaryCodeVersion: 'string',
      codeVersion: 'string',
      env: 'string',
      name: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.canaryAreaList)) {
      $dara.Model.validateArray(this.canaryAreaList);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishRoutineCodeVersionShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The regions for canary release.
   */
  canaryAreaListShrink?: string;
  /**
   * @remarks
   * The version number for canary release.
   * 
   * @example
   * 1710120201067203242
   */
  canaryCodeVersion?: string;
  /**
   * @remarks
   * The code version to be released.
   * 
   * @example
   * 1710120201067203242
   */
  codeVersion?: string;
  /**
   * @remarks
   * The environment name.
   * 
   * This parameter is required.
   * 
   * @example
   * production
   */
  env?: string;
  /**
   * @remarks
   * The routine name.
   * 
   * This parameter is required.
   * 
   * @example
   * PublishRoutineCodeVersion
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      canaryAreaListShrink: 'CanaryAreaList',
      canaryCodeVersion: 'CanaryCodeVersion',
      codeVersion: 'CodeVersion',
      env: 'Env',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canaryAreaListShrink: 'string',
      canaryCodeVersion: 'string',
      codeVersion: 'string',
      env: 'string',
      name: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishRoutineCodeVersionResponseBody extends $dara.Model {
  /**
   * @remarks
   * The code version.
   * 
   * @example
   * 1710120201067203242
   */
  codeVersion?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      codeVersion: 'CodeVersion',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeVersion: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishRoutineCodeVersionResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PublishRoutineCodeVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PublishRoutineCodeVersionResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurchaseRatePlanRequest extends $dara.Model {
  autoPay?: boolean;
  /**
   * @example
   * true
   */
  autoRenew?: boolean;
  /**
   * @example
   * PREPAY
   */
  chargeType?: string;
  /**
   * @example
   * domestic
   */
  coverage?: string;
  /**
   * @example
   * 1
   */
  period?: number;
  /**
   * @example
   * entranceplan
   */
  planCode?: string;
  /**
   * @example
   * basic
   */
  planName?: string;
  /**
   * @example
   * test.com
   */
  siteName?: string;
  /**
   * @example
   * CNAME
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      autoPay: 'AutoPay',
      autoRenew: 'AutoRenew',
      chargeType: 'ChargeType',
      coverage: 'Coverage',
      period: 'Period',
      planCode: 'PlanCode',
      planName: 'PlanName',
      siteName: 'SiteName',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoPay: 'boolean',
      autoRenew: 'boolean',
      chargeType: 'string',
      coverage: 'string',
      period: 'number',
      planCode: 'string',
      planName: 'string',
      siteName: 'string',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurchaseRatePlanResponseBody extends $dara.Model {
  /**
   * @example
   * xcdn-ads11w
   */
  instanceId?: string;
  /**
   * @example
   * 123123
   */
  orderId?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 30423A7F-A83D-1E24-B80E-86DD25790758
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      orderId: 'OrderId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      orderId: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurchaseRatePlanResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PurchaseRatePlanResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PurchaseRatePlanResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurgeCachesRequest extends $dara.Model {
  /**
   * @remarks
   * The content to purge.
   */
  content?: PurgeCachesRequestContent;
  /**
   * @remarks
   * Specifies whether to purge cached resources for edge computing. For example, purge the resources cached by the CacheAPI operation of Edge Routine.
   * 
   * @example
   * true
   */
  edgeComputePurge?: boolean;
  /**
   * @remarks
   * Specifies whether to purge resources in a directory if the resources requested are different from the resources on the origin server. Default value: false.
   * 
   * *   **true**: purges all resources in the directory.
   * *   **false**: purges only changed resources in the directory.
   * 
   * >  This configuration takes effect for the following purge task types: directory, cachetag, ignoreParams, hostname, and purgeall.
   * 
   * @example
   * true
   */
  force?: boolean;
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456789****
   */
  siteId?: number;
  /**
   * @remarks
   * The type of the purge task. Valid values:
   * 
   * *   **file** (default): purges the cache by file.
   * *   **cachetag**: purges the cache by cache tag.
   * *   **directory**: purges the cache by directory.
   * *   **ignoreParams**: purges the cache by URL with specific parameters ignored. This option ignores the question mark (?) and parameters after the question mark (?) in a request URL and purges the cache. After you call this operation with the request URL submitted, the system compares the submitted URL with the URL of the cached resource without specified parameters. If the URLs match, the POPs purge the cached resources.
   * *   **hostname**: purges the cache by hostname.
   * *   **purgeall**: purges all cache.
   * 
   * This parameter is required.
   * 
   * @example
   * file
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      edgeComputePurge: 'EdgeComputePurge',
      force: 'Force',
      siteId: 'SiteId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: PurgeCachesRequestContent,
      edgeComputePurge: 'boolean',
      force: 'boolean',
      siteId: 'number',
      type: 'string',
    };
  }

  validate() {
    if(this.content && typeof (this.content as any).validate === 'function') {
      (this.content as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurgeCachesShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The content to purge.
   */
  contentShrink?: string;
  /**
   * @remarks
   * Specifies whether to purge cached resources for edge computing. For example, purge the resources cached by the CacheAPI operation of Edge Routine.
   * 
   * @example
   * true
   */
  edgeComputePurge?: boolean;
  /**
   * @remarks
   * Specifies whether to purge resources in a directory if the resources requested are different from the resources on the origin server. Default value: false.
   * 
   * *   **true**: purges all resources in the directory.
   * *   **false**: purges only changed resources in the directory.
   * 
   * >  This configuration takes effect for the following purge task types: directory, cachetag, ignoreParams, hostname, and purgeall.
   * 
   * @example
   * true
   */
  force?: boolean;
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456789****
   */
  siteId?: number;
  /**
   * @remarks
   * The type of the purge task. Valid values:
   * 
   * *   **file** (default): purges the cache by file.
   * *   **cachetag**: purges the cache by cache tag.
   * *   **directory**: purges the cache by directory.
   * *   **ignoreParams**: purges the cache by URL with specific parameters ignored. This option ignores the question mark (?) and parameters after the question mark (?) in a request URL and purges the cache. After you call this operation with the request URL submitted, the system compares the submitted URL with the URL of the cached resource without specified parameters. If the URLs match, the POPs purge the cached resources.
   * *   **hostname**: purges the cache by hostname.
   * *   **purgeall**: purges all cache.
   * 
   * This parameter is required.
   * 
   * @example
   * file
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      contentShrink: 'Content',
      edgeComputePurge: 'EdgeComputePurge',
      force: 'Force',
      siteId: 'SiteId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentShrink: 'string',
      edgeComputePurge: 'boolean',
      force: 'boolean',
      siteId: 'number',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurgeCachesResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * ET5BF670-09D5-4D0B-BEBY-D96A2A528000
   */
  requestId?: string;
  /**
   * @remarks
   * The task ID, which is generated after you create a task.
   * 
   * @example
   * 15940956620
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      taskId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PurgeCachesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PurgeCachesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PurgeCachesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutKvRequest extends $dara.Model {
  /**
   * @remarks
   * Specifies whether the content of the key is Base64-encoded. Set this parameter to true if you want to store the key content in binary format. When this parameter is set to true, the Value parameter must be Base64-encoded.
   * 
   * @example
   * true
   */
  base64?: boolean;
  /**
   * @remarks
   * The time when the key-value pair expires, which cannot be earlier than the current time. The value is a timestamp in seconds. If you specify both Expiration and ExpirationTtl, only ExpirationTtl takes effect.
   * 
   * @example
   * 1690081381
   */
  expiration?: number;
  /**
   * @remarks
   * The relative expiration time. Unit: seconds. If you specify both Expiration and ExpirationTtl, only ExpirationTtl takes effect.
   * 
   * @example
   * 3600
   */
  expirationTtl?: number;
  /**
   * @remarks
   * The key name. The name can be up to 512 characters in length and cannot contain spaces or backslashes (\\\\).
   * 
   * This parameter is required.
   * 
   * @example
   * test_key
   */
  key?: string;
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namespace
   */
  namespace?: string;
  /**
   * @remarks
   * The content of the key, which can be up to 2 MB (2  1000  1000). If the content is larger than 2 MB, call [PutKvWithHighCapacity](https://help.aliyun.com/document_detail/2850486.html).
   * 
   * This parameter is required.
   * 
   * @example
   * test_value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      base64: 'Base64',
      expiration: 'Expiration',
      expirationTtl: 'ExpirationTtl',
      key: 'Key',
      namespace: 'Namespace',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      base64: 'boolean',
      expiration: 'number',
      expirationTtl: 'number',
      key: 'string',
      namespace: 'string',
      value: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutKvResponseBody extends $dara.Model {
  /**
   * @remarks
   * The length of the value in the key-value pair.
   * 
   * @example
   * 4
   */
  length?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * The content of the key. If the content has more than 256 characters in length, the system displays the first 100 and the last 100 characters, and omits the middle part.
   * 
   * @example
   * test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      length: 'Length',
      requestId: 'RequestId',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      length: 'string',
      requestId: 'string',
      value: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutKvResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PutKvResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PutKvResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutKvWithHighCapacityRequest extends $dara.Model {
  /**
   * @remarks
   * The key name. The name can be up to 512 characters in length and cannot contain spaces or backslashes (\\\\).
   * 
   * This parameter is required.
   * 
   * @example
   * test_key
   */
  key?: string;
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namesapce
   */
  namespace?: string;
  /**
   * @remarks
   * The download URL of the key-value pair that you want to upload. This parameter is automatically filled in when you use the SDK to call the operation.
   * 
   * This parameter is required.
   * 
   * @example
   * https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      namespace: 'Namespace',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      namespace: 'string',
      url: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutKvWithHighCapacityAdvanceRequest extends $dara.Model {
  /**
   * @remarks
   * The key name. The name can be up to 512 characters in length and cannot contain spaces or backslashes (\\\\).
   * 
   * This parameter is required.
   * 
   * @example
   * test_key
   */
  key?: string;
  /**
   * @remarks
   * The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * test_namesapce
   */
  namespace?: string;
  /**
   * @remarks
   * The download URL of the key-value pair that you want to upload. This parameter is automatically filled in when you use the SDK to call the operation.
   * 
   * This parameter is required.
   * 
   * @example
   * https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7
   */
  urlObject?: Readable;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      namespace: 'Namespace',
      urlObject: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      namespace: 'string',
      urlObject: 'Readable',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutKvWithHighCapacityResponseBody extends $dara.Model {
  /**
   * @remarks
   * The length of the value in the key-value pair.
   * 
   * @example
   * 4
   */
  length?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  /**
   * @remarks
   * The content of the key. If the content has more than 256 characters in length, the system displays the first 100 and the last 100 characters, and omits the middle part.
   * 
   * @example
   * test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      length: 'Length',
      requestId: 'RequestId',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      length: 'string',
      requestId: 'string',
      value: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PutKvWithHighCapacityResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PutKvWithHighCapacityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PutKvWithHighCapacityResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RebuildEdgeContainerAppStagingEnvRequest extends $dara.Model {
  /**
   * @remarks
   * The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RebuildEdgeContainerAppStagingEnvResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CB1A380B-09F0-41BB-3C82-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RebuildEdgeContainerAppStagingEnvResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RebuildEdgeContainerAppStagingEnvResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RebuildEdgeContainerAppStagingEnvResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetScheduledPreloadJobRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the scheduled prefetch task.
   * 
   * @example
   * ResetScheduledPreloadJob
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetScheduledPreloadJobResponseBody extends $dara.Model {
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 15685865xxx14622
   */
  aliUid?: string;
  /**
   * @remarks
   * The time when the SQL task was created.
   * 
   * @example
   * 2024-06-02T02:23:26Z
   */
  createdAt?: string;
  /**
   * @remarks
   * The domain names to be prefetched.
   * 
   * @example
   * testurl.com
   */
  domains?: string;
  /**
   * @remarks
   * The error message that is returned.
   * 
   * @example
   * invalid domain:test.com
   */
  errorInfo?: string;
  /**
   * @remarks
   * The URL of the OSS object that stores a list of URLs that failed the conditional check for prefetching.
   * 
   * @example
   * https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7
   */
  failedFileOss?: string;
  /**
   * @remarks
   * The ID of the URL list file, which can be used during downloads.
   * 
   * @example
   * 665d3b48621bccf3fe29e1a7
   */
  fileId?: string;
  /**
   * @remarks
   * The ID of the prefetch task.
   * 
   * @example
   * 665d3af3621bccf3fe29e1a4
   */
  id?: string;
  /**
   * @remarks
   * The method to submit the URLs to be prefetched.
   * 
   * @example
   * oss
   */
  insertWay?: string;
  /**
   * @remarks
   * The delivery project name.
   * 
   * @example
   * example
   */
  name?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 190007158391808
   */
  siteId?: number;
  /**
   * @remarks
   * The number of submitted prefetch tasks.
   * 
   * @example
   * 1
   */
  taskSubmitted?: number;
  /**
   * @remarks
   * The task type. Valid values: refresh and preload.
   * 
   * @example
   * preload
   */
  taskType?: string;
  /**
   * @remarks
   * The total number of URLs.
   * 
   * @example
   * 2
   */
  urlCount?: number;
  /**
   * @remarks
   * The number of submitted URLs.
   * 
   * @example
   * 1
   */
  urlSubmitted?: number;
  static names(): { [key: string]: string } {
    return {
      aliUid: 'AliUid',
      createdAt: 'CreatedAt',
      domains: 'Domains',
      errorInfo: 'ErrorInfo',
      failedFileOss: 'FailedFileOss',
      fileId: 'FileId',
      id: 'Id',
      insertWay: 'InsertWay',
      name: 'Name',
      requestId: 'RequestId',
      siteId: 'SiteId',
      taskSubmitted: 'TaskSubmitted',
      taskType: 'TaskType',
      urlCount: 'UrlCount',
      urlSubmitted: 'UrlSubmitted',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliUid: 'string',
      createdAt: 'string',
      domains: 'string',
      errorInfo: 'string',
      failedFileOss: 'string',
      fileId: 'string',
      id: 'string',
      insertWay: 'string',
      name: 'string',
      requestId: 'string',
      siteId: 'number',
      taskSubmitted: 'number',
      taskType: 'string',
      urlCount: 'number',
      urlSubmitted: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetScheduledPreloadJobResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ResetScheduledPreloadJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ResetScheduledPreloadJobResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RevokeClientCertificateRequest extends $dara.Model {
  /**
   * @remarks
   * The certificate ID.
   * 
   * This parameter is required.
   * 
   * @example
   * baba39055622c008b90285a8838ed09a
   */
  id?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RevokeClientCertificateResponseBody extends $dara.Model {
  /**
   * @remarks
   * The certificate ID.
   * 
   * @example
   * baba39055622c008b90285a8838ed09a
   */
  id?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A123425345
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
      siteId: 'SiteId',
      siteName: 'SiteName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      requestId: 'string',
      siteId: 'number',
      siteName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RevokeClientCertificateResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RevokeClientCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RevokeClientCertificateResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RollbackEdgeContainerAppVersionRequest extends $dara.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * This parameter is required.
   * 
   * @example
   * app-88068867578379****
   */
  appId?: string;
  /**
   * @remarks
   * The remarks.
   * 
   * @example
   * test rollback app
   */
  remarks?: string;
  /**
   * @remarks
   * The ID of version that you want to roll back.
   * 
   * This parameter is required.
   * 
   * @example
   * ver-87962637161651****
   */
  versionId?: string;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      remarks: 'Remarks',
      versionId: 'VersionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'string',
      remarks: 'string',
      versionId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RollbackEdgeContainerAppVersionResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * C370DAF1-C838-4288-A1A0-9A87633D248E
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RollbackEdgeContainerAppVersionResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RollbackEdgeContainerAppVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RollbackEdgeContainerAppVersionResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetCertificateRequest extends $dara.Model {
  /**
   * @remarks
   * The certificate ID on Certificate Management Service.
   * 
   * @example
   * 30000478
   */
  casId?: number;
  /**
   * @remarks
   * The certificate content.
   * 
   * @example
   * -----BEGIN CERTIFICATE-----
   */
  certificate?: string;
  /**
   * @remarks
   * The certificate ID on ESA.
   * 
   * @example
   * 30001303
   */
  id?: string;
  /**
   * @remarks
   * The certificate name.
   * 
   * @example
   * yourCertName
   */
  name?: string;
  ownerId?: number;
  /**
   * @remarks
   * The private key of the certificate.
   * 
   * @example
   * -----BEGIN PRIVATE KEY-----
   */
  privateKey?: string;
  /**
   * @remarks
   * The region.
   * 
   * @example
   * cn-hangzhou
   */
  region?: string;
  securityToken?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The certificate type. Valid values:
   * 
   * *   cas: a certificate purchased by using Certificate Management Service.
   * *   upload: a custom certificate that you upload.
   * 
   * This parameter is required.
   * 
   * @example
   * cas
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      casId: 'CasId',
      certificate: 'Certificate',
      id: 'Id',
      name: 'Name',
      ownerId: 'OwnerId',
      privateKey: 'PrivateKey',
      region: 'Region',
      securityToken: 'SecurityToken',
      siteId: 'SiteId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      casId: 'number',
      certificate: 'string',
      id: 'string',
      name: 'string',
      ownerId: 'number',
      privateKey: 'string',
      region: 'string',
      securityToken: 'string',
      siteId: 'number',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetCertificateResponseBody extends $dara.Model {
  id?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * A666D44F-19D6-490E-97CF-1A64AB962C57
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetCertificateResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetCertificateResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetClientCertificateHostnamesRequest extends $dara.Model {
  /**
   * @remarks
   * The domain names to associate.
   * 
   * This parameter is required.
   */
  hostnames?: string[];
  /**
   * @remarks
   * The ID of the client CA certificate.
   * 
   * @example
   * babab9db65ee5efcca9f3d41d4b50d66
   */
  id?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      hostnames: 'Hostnames',
      id: 'Id',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hostnames: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      siteId: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.hostnames)) {
      $dara.Model.validateArray(this.hostnames);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetClientCertificateHostnamesShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The domain names to associate.
   * 
   * This parameter is required.
   */
  hostnamesShrink?: string;
  /**
   * @remarks
   * The ID of the client CA certificate.
   * 
   * @example
   * babab9db65ee5efcca9f3d41d4b50d66
   */
  id?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      hostnamesShrink: 'Hostnames',
      id: 'Id',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hostnamesShrink: 'string',
      id: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetClientCertificateHostnamesResponseBody extends $dara.Model {
  /**
   * @remarks
   * The ID of the client CA certificate.
   * 
   * @example
   * babab9db65ee5efcca9f3d41d4b50d66
   */
  id?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * ET5BF670-09D5-4D0B-BEBY-D96A2A528000
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The website name.
   * 
   * @example
   * example.com
   */
  siteName?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
      siteId: 'SiteId',
      siteName: 'SiteName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      requestId: 'string',
      siteId: 'number',
      siteName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetClientCertificateHostnamesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetClientCertificateHostnamesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetClientCertificateHostnamesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetHttpDDoSAttackIntelligentProtectionRequest extends $dara.Model {
  /**
   * @remarks
   * The mode of smart HTTP DDoS protection. Valid values:
   * 
   * *   **observe**: alert.
   * *   **defense**: block.
   * 
   * This parameter is required.
   * 
   * @example
   * defense
   */
  aiMode?: string;
  /**
   * @remarks
   * The level of smart HTTP DDoS protection. Valid values:
   * 
   * *   **level0**: very loose.
   * *   **level30**: loose.
   * *   **level60**: normal.
   * *   **level90**: strict.
   * 
   * This parameter is required.
   * 
   * @example
   * level60
   */
  aiTemplate?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      aiMode: 'AiMode',
      aiTemplate: 'AiTemplate',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aiMode: 'string',
      aiTemplate: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetHttpDDoSAttackIntelligentProtectionResponseBody extends $dara.Model {
  /**
   * @remarks
   * The mode of smart HTTP DDoS protection. Valid values:
   * 
   * *   **observe**: alert.
   * *   **defense**: block.
   * 
   * @example
   * defense
   */
  aiMode?: string;
  /**
   * @remarks
   * The level of smart HTTP DDoS protection. Valid values:
   * 
   * *   **level0**: very loose.
   * *   **level30**: loose.
   * *   **level60**: normal.
   * *   **level90**: strict.
   * 
   * @example
   * level60
   */
  aiTemplate?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 156A6B-677B1A-4297B7-9187B7-2B44792
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      aiMode: 'AiMode',
      aiTemplate: 'AiTemplate',
      requestId: 'RequestId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aiMode: 'string',
      aiTemplate: 'string',
      requestId: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetHttpDDoSAttackIntelligentProtectionResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetHttpDDoSAttackIntelligentProtectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetHttpDDoSAttackIntelligentProtectionResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetHttpDDoSAttackProtectionRequest extends $dara.Model {
  /**
   * @remarks
   * The level of HTTP DDoS attack protection. Valid values:
   * 
   * *   **very weak**: very loose.
   * *   **weak**: loose.
   * *   **default**: normal.
   * *   **hard**: strict.
   * 
   * This parameter is required.
   * 
   * @example
   * default
   */
  globalMode?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      globalMode: 'GlobalMode',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      globalMode: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetHttpDDoSAttackProtectionResponseBody extends $dara.Model {
  /**
   * @remarks
   * The level of HTTP DDoS attack protection.
   * 
   * @example
   * default
   */
  globalMode?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * C370DAF1-C838-4288-A1A0-9A87633D248E
   */
  requestId?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      globalMode: 'GlobalMode',
      requestId: 'RequestId',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      globalMode: 'string',
      requestId: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetHttpDDoSAttackProtectionResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetHttpDDoSAttackProtectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetHttpDDoSAttackProtectionResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartScheduledPreloadExecutionRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the prefetch plan.
   * 
   * This parameter is required.
   * 
   * @example
   * StartScheduledPreloadExecution
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartScheduledPreloadExecutionResponseBody extends $dara.Model {
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 15685865xxx14622
   */
  aliUid?: string;
  /**
   * @remarks
   * The end time of the prefetch plan.
   * 
   * @example
   * 2024-05-31T18:10:48.849+08:00
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the prefetch plan.
   * 
   * @example
   * 665d3b48621bccf3fe29e1a7
   */
  id?: string;
  /**
   * @remarks
   * The time interval between each batch execution. Unit: seconds.
   * 
   * @example
   * 60
   */
  interval?: number;
  /**
   * @remarks
   * The ID of the prefetch task.
   * 
   * @example
   * 665d3af3621bccf3fe29e1a4
   */
  jobId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 65C66B7B-671A-8297-9187-2R5477247B76
   */
  requestId?: string;
  /**
   * @remarks
   * The number of URLs prefetched in each batch.
   * 
   * @example
   * 10
   */
  sliceLen?: number;
  /**
   * @remarks
   * The start time of the prefetch plan.
   * 
   * @example
   * 2024-05-31T17:10:48.849+08:00
   */
  startTime?: string;
  /**
   * @remarks
   * The status of the prefetch plan. Valid values:
   * 
   * *   **waiting**
   * *   **running**
   * *   **finished**
   * *   **failed**
   * *   **stopped**
   * 
   * @example
   * waiting
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      aliUid: 'AliUid',
      endTime: 'EndTime',
      id: 'Id',
      interval: 'Interval',
      jobId: 'JobId',
      requestId: 'RequestId',
      sliceLen: 'SliceLen',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliUid: 'string',
      endTime: 'string',
      id: 'string',
      interval: 'number',
      jobId: 'string',
      requestId: 'string',
      sliceLen: 'number',
      startTime: 'string',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartScheduledPreloadExecutionResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StartScheduledPreloadExecutionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartScheduledPreloadExecutionResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopScheduledPreloadExecutionRequest extends $dara.Model {
  /**
   * @remarks
   * The ID of the prefetch plan.
   * 
   * This parameter is required.
   * 
   * @example
   * StopScheduledPreloadExecution
   */
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopScheduledPreloadExecutionResponseBody extends $dara.Model {
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 15685865xxx14622
   */
  aliUid?: string;
  /**
   * @remarks
   * The end time of the prefetch plan.
   * 
   * @example
   * 2024-05-31T18:10:48.849+08:00
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the prefetch plan.
   * 
   * @example
   * 66599bd7397885b43804901c
   */
  id?: string;
  /**
   * @remarks
   * The time interval between each batch execution in the plan. Unit: seconds.
   * 
   * @example
   * 60
   */
  interval?: number;
  /**
   * @remarks
   * The ID of the prefetch task.
   * 
   * @example
   * 665d3af3621bccf3fe29e1a4
   */
  jobId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CB1A380B-09F0-41BB-A198-72F8FD6DA2FE
   */
  requestId?: string;
  /**
   * @remarks
   * The number of URLs prefetched in each batch.
   * 
   * @example
   * 10
   */
  sliceLen?: number;
  /**
   * @remarks
   * The start time of the prefetch plan.
   * 
   * @example
   * 2024-05-31T17:10:48.849+08:00
   */
  startTime?: string;
  /**
   * @remarks
   * The status of the prefetch plan. Valid values:
   * 
   * *   **waiting**
   * *   **running**
   * *   **finished**
   * *   **failed**
   * *   **stopped**
   * 
   * @example
   * stopped
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      aliUid: 'AliUid',
      endTime: 'EndTime',
      id: 'Id',
      interval: 'Interval',
      jobId: 'JobId',
      requestId: 'RequestId',
      sliceLen: 'SliceLen',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliUid: 'string',
      endTime: 'string',
      id: 'string',
      interval: 'number',
      jobId: 'string',
      requestId: 'string',
      sliceLen: 'number',
      startTime: 'string',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopScheduledPreloadExecutionResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StopScheduledPreloadExecutionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopScheduledPreloadExecutionResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesRequest extends $dara.Model {
  /**
   * @remarks
   * Specifies whether to remove all tags. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * Default value: **false**.
   * 
   * @example
   * false
   */
  all?: boolean;
  ownerId?: number;
  /**
   * @remarks
   * The ID of the region where the resources reside. Set the value to **cn-hangzhou**.
   * 
   * This parameter is required.
   * 
   * @example
   * cn-hangzhou
   */
  regionId?: string;
  /**
   * @remarks
   * The ID of resource N. Valid values of N: **1** to **50**.
   * 
   * This parameter is required.
   */
  resourceId?: string[];
  /**
   * @remarks
   * The resource type.
   * 
   * This parameter is required.
   * 
   * @example
   * site
   */
  resourceType?: string;
  securityToken?: string;
  /**
   * @remarks
   * The key of tag N to remove from the resource. Valid values of N: **1** to **20**.
   */
  tagKey?: string[];
  static names(): { [key: string]: string } {
    return {
      all: 'All',
      ownerId: 'OwnerId',
      regionId: 'RegionId',
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      securityToken: 'SecurityToken',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      all: 'boolean',
      ownerId: 'number',
      regionId: 'string',
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      securityToken: 'string',
      tagKey: { 'type': 'array', 'itemType': 'string' },
    };
  }

  validate() {
    if(Array.isArray(this.resourceId)) {
      $dara.Model.validateArray(this.resourceId);
    }
    if(Array.isArray(this.tagKey)) {
      $dara.Model.validateArray(this.tagKey);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 85H66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UntagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UntagResourcesResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCacheRuleRequest extends $dara.Model {
  /**
   * @example
   * 8880
   */
  additionalCacheablePorts?: string;
  /**
   * @example
   * no_cache
   */
  browserCacheMode?: string;
  /**
   * @example
   * 300
   */
  browserCacheTtl?: string;
  /**
   * @example
   * cache_all
   */
  bypassCache?: string;
  /**
   * @example
   * on
   */
  cacheDeceptionArmor?: string;
  /**
   * @example
   * bypass_cache_reserve
   */
  cacheReserveEligibility?: string;
  /**
   * @example
   * cookiename
   */
  checkPresenceCookie?: string;
  /**
   * @example
   * headername
   */
  checkPresenceHeader?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @example
   * follow_origin
   */
  edgeCacheMode?: string;
  /**
   * @example
   * 300
   */
  edgeCacheTtl?: string;
  /**
   * @example
   * 300
   */
  edgeStatusCodeCacheTtl?: string;
  /**
   * @example
   * cookiename
   */
  includeCookie?: string;
  /**
   * @example
   * headername
   */
  includeHeader?: string;
  /**
   * @example
   * example
   */
  queryString?: string;
  /**
   * @example
   * ignore_all
   */
  queryStringMode?: string;
  /**
   * @example
   * (http.host eq \\"video.example.com\\")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @example
   * on
   */
  serveStale?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @example
   * on
   */
  sortQueryStringForCache?: string;
  /**
   * @example
   * on
   */
  userDeviceType?: string;
  /**
   * @example
   * on
   */
  userGeo?: string;
  /**
   * @example
   * on
   */
  userLanguage?: string;
  static names(): { [key: string]: string } {
    return {
      additionalCacheablePorts: 'AdditionalCacheablePorts',
      browserCacheMode: 'BrowserCacheMode',
      browserCacheTtl: 'BrowserCacheTtl',
      bypassCache: 'BypassCache',
      cacheDeceptionArmor: 'CacheDeceptionArmor',
      cacheReserveEligibility: 'CacheReserveEligibility',
      checkPresenceCookie: 'CheckPresenceCookie',
      checkPresenceHeader: 'CheckPresenceHeader',
      configId: 'ConfigId',
      edgeCacheMode: 'EdgeCacheMode',
      edgeCacheTtl: 'EdgeCacheTtl',
      edgeStatusCodeCacheTtl: 'EdgeStatusCodeCacheTtl',
      includeCookie: 'IncludeCookie',
      includeHeader: 'IncludeHeader',
      queryString: 'QueryString',
      queryStringMode: 'QueryStringMode',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      serveStale: 'ServeStale',
      siteId: 'SiteId',
      sortQueryStringForCache: 'SortQueryStringForCache',
      userDeviceType: 'UserDeviceType',
      userGeo: 'UserGeo',
      userLanguage: 'UserLanguage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      additionalCacheablePorts: 'string',
      browserCacheMode: 'string',
      browserCacheTtl: 'string',
      bypassCache: 'string',
      cacheDeceptionArmor: 'string',
      cacheReserveEligibility: 'string',
      checkPresenceCookie: 'string',
      checkPresenceHeader: 'string',
      configId: 'number',
      edgeCacheMode: 'string',
      edgeCacheTtl: 'string',
      edgeStatusCodeCacheTtl: 'string',
      includeCookie: 'string',
      includeHeader: 'string',
      queryString: 'string',
      queryStringMode: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      serveStale: 'string',
      siteId: 'number',
      sortQueryStringForCache: 'string',
      userDeviceType: 'string',
      userGeo: 'string',
      userLanguage: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCacheRuleResponseBody extends $dara.Model {
  /**
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCacheRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateCacheRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCacheRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCacheTagRequest extends $dara.Model {
  /**
   * @example
   * on
   */
  caseInsensitive?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5407498413****
   */
  siteId?: number;
  /**
   * @example
   * 1
   */
  siteVersion?: number;
  /**
   * @example
   * example
   */
  tagName?: string;
  static names(): { [key: string]: string } {
    return {
      caseInsensitive: 'CaseInsensitive',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
      tagName: 'TagName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      caseInsensitive: 'string',
      siteId: 'number',
      siteVersion: 'number',
      tagName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCacheTagResponseBody extends $dara.Model {
  /**
   * @example
   * CB1A380B-09F0-41BB-280B-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCacheTagResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateCacheTagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCacheTagResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCnameFlatteningRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * flatten_all
   */
  flattenMode?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      flattenMode: 'FlattenMode',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flattenMode: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCnameFlatteningResponseBody extends $dara.Model {
  /**
   * @example
   * CB1A380B-09F0-41BB-280B-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCnameFlatteningResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateCnameFlatteningResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCnameFlatteningResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCompressionRuleRequest extends $dara.Model {
  /**
   * @example
   * on
   */
  brotli?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @example
   * on
   */
  gzip?: string;
  /**
   * @example
   * (http.host eq "video.example.com")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5407498413****
   */
  siteId?: number;
  zstd?: string;
  static names(): { [key: string]: string } {
    return {
      brotli: 'Brotli',
      configId: 'ConfigId',
      gzip: 'Gzip',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      zstd: 'Zstd',
    };
  }

  static types(): { [key: string]: any } {
    return {
      brotli: 'string',
      configId: 'number',
      gzip: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
      zstd: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCompressionRuleResponseBody extends $dara.Model {
  /**
   * @example
   * CE8EB0DE-3267-53D1-AB83-F36377D63FD0
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCompressionRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateCompressionRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCompressionRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCustomScenePolicyRequest extends $dara.Model {
  /**
   * @remarks
   * The time when the policy expires.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-03T19:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The policy name.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The IDs of the websites that you want to associate with the policy. Separate multiple IDs with commas (,).
   * 
   * @example
   * 123456****
   */
  objects?: string;
  /**
   * @remarks
   * The policy ID, which can be obtained by calling the [DescribeCustomScenePolicies](https://help.aliyun.com/document_detail/2850508.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  policyId?: number;
  /**
   * @remarks
   * The time when the policy takes effect.
   * 
   * Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2023-04-03T16:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The name of the policy template. Valid value:
   * 
   * *   **promotion**: major events.
   * 
   * This parameter is required.
   * 
   * @example
   * promotion
   */
  template?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      name: 'Name',
      objects: 'Objects',
      policyId: 'PolicyId',
      startTime: 'StartTime',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      name: 'string',
      objects: 'string',
      policyId: 'number',
      startTime: 'string',
      template: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCustomScenePolicyResponseBody extends $dara.Model {
  /**
   * @remarks
   * The time when the policy expires.
   * 
   * The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-04-03T19:00:00Z
   */
  endTime?: string;
  /**
   * @remarks
   * The policy name.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The IDs of websites associated.
   */
  objects?: string[];
  /**
   * @remarks
   * The policy ID.
   * 
   * @example
   * 1
   */
  policyId?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  /**
   * @remarks
   * The time when the policy takes effect.
   * 
   * The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
   * 
   * @example
   * 2023-04-03T16:00:00Z
   */
  startTime?: string;
  /**
   * @remarks
   * The name of the policy template. Valid value:
   * 
   * *   **promotion**: major events.
   * 
   * @example
   * promotion
   */
  template?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      name: 'Name',
      objects: 'Objects',
      policyId: 'PolicyId',
      requestId: 'RequestId',
      startTime: 'StartTime',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      name: 'string',
      objects: { 'type': 'array', 'itemType': 'string' },
      policyId: 'number',
      requestId: 'string',
      startTime: 'string',
      template: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.objects)) {
      $dara.Model.validateArray(this.objects);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCustomScenePolicyResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateCustomScenePolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCustomScenePolicyResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDevelopmentModeRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * on
   */
  enable?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDevelopmentModeResponseBody extends $dara.Model {
  /**
   * @example
   * 65C66B7B-671A-8297-9187-2R5477247B76
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDevelopmentModeResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateDevelopmentModeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDevelopmentModeResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHttpRequestHeaderModificationRuleRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 35281609698****
   */
  configId?: number;
  requestHeaderModification?: UpdateHttpRequestHeaderModificationRuleRequestRequestHeaderModification[];
  /**
   * @example
   * (http.host eq "video.example.com")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      requestHeaderModification: 'RequestHeaderModification',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      requestHeaderModification: { 'type': 'array', 'itemType': UpdateHttpRequestHeaderModificationRuleRequestRequestHeaderModification },
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.requestHeaderModification)) {
      $dara.Model.validateArray(this.requestHeaderModification);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHttpRequestHeaderModificationRuleShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 35281609698****
   */
  configId?: number;
  requestHeaderModificationShrink?: string;
  /**
   * @example
   * (http.host eq "video.example.com")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      requestHeaderModificationShrink: 'RequestHeaderModification',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      requestHeaderModificationShrink: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHttpRequestHeaderModificationRuleResponseBody extends $dara.Model {
  /**
   * @example
   * 2430E05E-1340-5773-B5E1-B743929F46F2
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHttpRequestHeaderModificationRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateHttpRequestHeaderModificationRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateHttpRequestHeaderModificationRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHttpResponseHeaderModificationRuleRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 35281609698****
   */
  configId?: number;
  responseHeaderModification?: UpdateHttpResponseHeaderModificationRuleRequestResponseHeaderModification[];
  /**
   * @example
   * (http.host eq "video.example.com")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456******
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      responseHeaderModification: 'ResponseHeaderModification',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      responseHeaderModification: { 'type': 'array', 'itemType': UpdateHttpResponseHeaderModificationRuleRequestResponseHeaderModification },
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.responseHeaderModification)) {
      $dara.Model.validateArray(this.responseHeaderModification);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHttpResponseHeaderModificationRuleShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 35281609698****
   */
  configId?: number;
  responseHeaderModificationShrink?: string;
  /**
   * @example
   * (http.host eq "video.example.com")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456******
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      responseHeaderModificationShrink: 'ResponseHeaderModification',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      responseHeaderModificationShrink: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHttpResponseHeaderModificationRuleResponseBody extends $dara.Model {
  /**
   * @example
   * CB1A380B-09F0-41BB-280B-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHttpResponseHeaderModificationRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateHttpResponseHeaderModificationRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateHttpResponseHeaderModificationRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHttpsApplicationConfigurationRequest extends $dara.Model {
  /**
   * @example
   * on
   */
  altSvc?: string;
  /**
   * @example
   * on
   */
  altSvcClear?: string;
  /**
   * @example
   * 86400
   */
  altSvcMa?: string;
  /**
   * @example
   * on
   */
  altSvcPersist?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @example
   * on
   */
  hsts?: string;
  /**
   * @example
   * on
   */
  hstsIncludeSubdomains?: string;
  /**
   * @example
   * 3600
   */
  hstsMaxAge?: string;
  /**
   * @example
   * on
   */
  hstsPreload?: string;
  /**
   * @example
   * on
   */
  httpsForce?: string;
  /**
   * @example
   * 301
   */
  httpsForceCode?: string;
  /**
   * @example
   * (http.host eq \\"video.example.com\\")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      altSvc: 'AltSvc',
      altSvcClear: 'AltSvcClear',
      altSvcMa: 'AltSvcMa',
      altSvcPersist: 'AltSvcPersist',
      configId: 'ConfigId',
      hsts: 'Hsts',
      hstsIncludeSubdomains: 'HstsIncludeSubdomains',
      hstsMaxAge: 'HstsMaxAge',
      hstsPreload: 'HstsPreload',
      httpsForce: 'HttpsForce',
      httpsForceCode: 'HttpsForceCode',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      altSvc: 'string',
      altSvcClear: 'string',
      altSvcMa: 'string',
      altSvcPersist: 'string',
      configId: 'number',
      hsts: 'string',
      hstsIncludeSubdomains: 'string',
      hstsMaxAge: 'string',
      hstsPreload: 'string',
      httpsForce: 'string',
      httpsForceCode: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHttpsApplicationConfigurationResponseBody extends $dara.Model {
  /**
   * @example
   * 35C66C7B-671H-4297-9187-2C4477247A78
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHttpsApplicationConfigurationResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateHttpsApplicationConfigurationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateHttpsApplicationConfigurationResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHttpsBasicConfigurationRequest extends $dara.Model {
  /**
   * @example
   * TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
   */
  ciphersuite?: string;
  /**
   * @example
   * all
   */
  ciphersuiteGroup?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 3528160969****
   */
  configId?: number;
  /**
   * @example
   * on
   */
  http2?: string;
  /**
   * @example
   * on
   */
  http3?: string;
  /**
   * @example
   * on
   */
  https?: string;
  /**
   * @example
   * on
   */
  ocspStapling?: string;
  /**
   * @example
   * (http.host eq \\"video.example.com\\")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1231231221****
   */
  siteId?: number;
  /**
   * @example
   * on
   */
  tls10?: string;
  /**
   * @example
   * on
   */
  tls11?: string;
  /**
   * @example
   * on
   */
  tls12?: string;
  /**
   * @example
   * on
   */
  tls13?: string;
  static names(): { [key: string]: string } {
    return {
      ciphersuite: 'Ciphersuite',
      ciphersuiteGroup: 'CiphersuiteGroup',
      configId: 'ConfigId',
      http2: 'Http2',
      http3: 'Http3',
      https: 'Https',
      ocspStapling: 'OcspStapling',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      tls10: 'Tls10',
      tls11: 'Tls11',
      tls12: 'Tls12',
      tls13: 'Tls13',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ciphersuite: 'string',
      ciphersuiteGroup: 'string',
      configId: 'number',
      http2: 'string',
      http3: 'string',
      https: 'string',
      ocspStapling: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
      tls10: 'string',
      tls11: 'string',
      tls12: 'string',
      tls13: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHttpsBasicConfigurationResponseBody extends $dara.Model {
  /**
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHttpsBasicConfigurationResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateHttpsBasicConfigurationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateHttpsBasicConfigurationResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateIPv6Request extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * on
   */
  enable?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5407498413****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateIPv6ResponseBody extends $dara.Model {
  /**
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateIPv6Response extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateIPv6ResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateIPv6ResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateImageTransformRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 352816096987136
   */
  configId?: number;
  /**
   * @example
   * on
   */
  enable?: string;
  /**
   * @example
   * (http.request.uri.path.file_name eq \\"jpg\\")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * test
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      enable: 'Enable',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      enable: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateImageTransformResponseBody extends $dara.Model {
  /**
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateImageTransformResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateImageTransformResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateImageTransformResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateListRequest extends $dara.Model {
  /**
   * @remarks
   * The new description of the list.
   * 
   * This parameter is required.
   * 
   * @example
   * a custom list
   */
  description?: string;
  /**
   * @remarks
   * The ID of the custom list, which can be obtained by calling the [ListLists](https://help.aliyun.com/document_detail/2850217.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 40000001
   */
  id?: number;
  /**
   * @remarks
   * The items in the updated list. The value is a JSON array.
   * 
   * This parameter is required.
   * 
   * @example
   * a custom list
   */
  items?: string[];
  /**
   * @remarks
   * The new name of the list.
   * 
   * This parameter is required.
   * 
   * @example
   * example
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      id: 'Id',
      items: 'Items',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      id: 'number',
      items: { 'type': 'array', 'itemType': 'string' },
      name: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.items)) {
      $dara.Model.validateArray(this.items);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateListShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The new description of the list.
   * 
   * This parameter is required.
   * 
   * @example
   * a custom list
   */
  description?: string;
  /**
   * @remarks
   * The ID of the custom list, which can be obtained by calling the [ListLists](https://help.aliyun.com/document_detail/2850217.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 40000001
   */
  id?: number;
  /**
   * @remarks
   * The items in the updated list. The value is a JSON array.
   * 
   * This parameter is required.
   * 
   * @example
   * a custom list
   */
  itemsShrink?: string;
  /**
   * @remarks
   * The new name of the list.
   * 
   * This parameter is required.
   * 
   * @example
   * example
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      id: 'Id',
      itemsShrink: 'Items',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      id: 'number',
      itemsShrink: 'string',
      name: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateListResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateListResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateListResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLoadBalancerRequest extends $dara.Model {
  adaptiveRouting?: UpdateLoadBalancerRequestAdaptiveRouting;
  defaultPools?: number[];
  description?: string;
  enabled?: boolean;
  /**
   * @example
   * 96228666776****
   */
  fallbackPool?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 95913670174****
   */
  id?: number;
  monitor?: UpdateLoadBalancerRequestMonitor;
  randomSteering?: UpdateLoadBalancerRequestRandomSteering;
  /**
   * @example
   * {
   *   "ENAM": [
   *     12345678****
   *   ],
   *   "WNAM": [
   *     23456789****,
   *     23456789****
   *   ]
   * }
   */
  regionPools?: any;
  /**
   * **if can be null:**
   * false
   */
  rules?: UpdateLoadBalancerRequestRules[];
  /**
   * @remarks
   * Session persistence. Valid values:
   * 
   * *   off:disables session persistence.
   * *   ip: enables session persistence by IP address.
   * *   cookie: disables session persistence.
   * 
   * @example
   * ip
   */
  sessionAffinity?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * UpdateLoadBalancer
   */
  siteId?: number;
  /**
   * @example
   * order
   */
  steeringPolicy?: string;
  /**
   * @example
   * {"AL,MO": [92298024898****],"CN-SH,CN-SX,CN-SC":[92304347804****,92843536908****]}
   */
  subRegionPools?: any;
  /**
   * @example
   * 300
   */
  ttl?: number;
  static names(): { [key: string]: string } {
    return {
      adaptiveRouting: 'AdaptiveRouting',
      defaultPools: 'DefaultPools',
      description: 'Description',
      enabled: 'Enabled',
      fallbackPool: 'FallbackPool',
      id: 'Id',
      monitor: 'Monitor',
      randomSteering: 'RandomSteering',
      regionPools: 'RegionPools',
      rules: 'Rules',
      sessionAffinity: 'SessionAffinity',
      siteId: 'SiteId',
      steeringPolicy: 'SteeringPolicy',
      subRegionPools: 'SubRegionPools',
      ttl: 'Ttl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adaptiveRouting: UpdateLoadBalancerRequestAdaptiveRouting,
      defaultPools: { 'type': 'array', 'itemType': 'number' },
      description: 'string',
      enabled: 'boolean',
      fallbackPool: 'number',
      id: 'number',
      monitor: UpdateLoadBalancerRequestMonitor,
      randomSteering: UpdateLoadBalancerRequestRandomSteering,
      regionPools: 'any',
      rules: { 'type': 'array', 'itemType': UpdateLoadBalancerRequestRules },
      sessionAffinity: 'string',
      siteId: 'number',
      steeringPolicy: 'string',
      subRegionPools: 'any',
      ttl: 'number',
    };
  }

  validate() {
    if(this.adaptiveRouting && typeof (this.adaptiveRouting as any).validate === 'function') {
      (this.adaptiveRouting as any).validate();
    }
    if(Array.isArray(this.defaultPools)) {
      $dara.Model.validateArray(this.defaultPools);
    }
    if(this.monitor && typeof (this.monitor as any).validate === 'function') {
      (this.monitor as any).validate();
    }
    if(this.randomSteering && typeof (this.randomSteering as any).validate === 'function') {
      (this.randomSteering as any).validate();
    }
    if(Array.isArray(this.rules)) {
      $dara.Model.validateArray(this.rules);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLoadBalancerShrinkRequest extends $dara.Model {
  adaptiveRoutingShrink?: string;
  defaultPoolsShrink?: string;
  description?: string;
  enabled?: boolean;
  /**
   * @example
   * 96228666776****
   */
  fallbackPool?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 95913670174****
   */
  id?: number;
  monitorShrink?: string;
  randomSteeringShrink?: string;
  /**
   * @example
   * {
   *   "ENAM": [
   *     12345678****
   *   ],
   *   "WNAM": [
   *     23456789****,
   *     23456789****
   *   ]
   * }
   */
  regionPools?: any;
  /**
   * **if can be null:**
   * false
   */
  rulesShrink?: string;
  /**
   * @remarks
   * Session persistence. Valid values:
   * 
   * *   off:disables session persistence.
   * *   ip: enables session persistence by IP address.
   * *   cookie: disables session persistence.
   * 
   * @example
   * ip
   */
  sessionAffinity?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * UpdateLoadBalancer
   */
  siteId?: number;
  /**
   * @example
   * order
   */
  steeringPolicy?: string;
  /**
   * @example
   * {"AL,MO": [92298024898****],"CN-SH,CN-SX,CN-SC":[92304347804****,92843536908****]}
   */
  subRegionPools?: any;
  /**
   * @example
   * 300
   */
  ttl?: number;
  static names(): { [key: string]: string } {
    return {
      adaptiveRoutingShrink: 'AdaptiveRouting',
      defaultPoolsShrink: 'DefaultPools',
      description: 'Description',
      enabled: 'Enabled',
      fallbackPool: 'FallbackPool',
      id: 'Id',
      monitorShrink: 'Monitor',
      randomSteeringShrink: 'RandomSteering',
      regionPools: 'RegionPools',
      rulesShrink: 'Rules',
      sessionAffinity: 'SessionAffinity',
      siteId: 'SiteId',
      steeringPolicy: 'SteeringPolicy',
      subRegionPools: 'SubRegionPools',
      ttl: 'Ttl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      adaptiveRoutingShrink: 'string',
      defaultPoolsShrink: 'string',
      description: 'string',
      enabled: 'boolean',
      fallbackPool: 'number',
      id: 'number',
      monitorShrink: 'string',
      randomSteeringShrink: 'string',
      regionPools: 'any',
      rulesShrink: 'string',
      sessionAffinity: 'string',
      siteId: 'number',
      steeringPolicy: 'string',
      subRegionPools: 'any',
      ttl: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLoadBalancerResponseBody extends $dara.Model {
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * EEEBE525-F576-1196-8DAF-2D70CA3F4D2F
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateLoadBalancerResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateLoadBalancerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateLoadBalancerResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateManagedTransformRequest extends $dara.Model {
  /**
   * @example
   * on
   */
  addClientGeolocationHeader?: string;
  /**
   * @example
   * on
   */
  addRealClientIpHeader?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @example
   * 0
   */
  siteVersion?: number;
  static names(): { [key: string]: string } {
    return {
      addClientGeolocationHeader: 'AddClientGeolocationHeader',
      addRealClientIpHeader: 'AddRealClientIpHeader',
      siteId: 'SiteId',
      siteVersion: 'SiteVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addClientGeolocationHeader: 'string',
      addRealClientIpHeader: 'string',
      siteId: 'number',
      siteVersion: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateManagedTransformResponseBody extends $dara.Model {
  /**
   * @example
   * CB1A380B-09F0-41BB-A198-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateManagedTransformResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateManagedTransformResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateManagedTransformResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateNetworkOptimizationRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 352816096987136
   */
  configId?: number;
  /**
   * @example
   * on
   */
  grpc?: string;
  /**
   * @example
   * on
   */
  http2Origin?: string;
  /**
   * @example
   * (http.host eq \\"video.example.com\\")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @example
   * on
   */
  smartRouting?: string;
  /**
   * @example
   * 100
   */
  uploadMaxFilesize?: string;
  /**
   * @example
   * on
   */
  websocket?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      grpc: 'Grpc',
      http2Origin: 'Http2Origin',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      smartRouting: 'SmartRouting',
      uploadMaxFilesize: 'UploadMaxFilesize',
      websocket: 'Websocket',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      grpc: 'string',
      http2Origin: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
      smartRouting: 'string',
      uploadMaxFilesize: 'string',
      websocket: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateNetworkOptimizationResponseBody extends $dara.Model {
  /**
   * @example
   * CB1A380B-09F0-41BB-A198-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateNetworkOptimizationResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateNetworkOptimizationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateNetworkOptimizationResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOriginPoolRequest extends $dara.Model {
  enabled?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * UpdateOriginPool
   */
  id?: number;
  origins?: UpdateOriginPoolRequestOrigins[];
  /**
   * @remarks
   * This parameter is required.
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      enabled: 'Enabled',
      id: 'Id',
      origins: 'Origins',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      id: 'number',
      origins: { 'type': 'array', 'itemType': UpdateOriginPoolRequestOrigins },
      siteId: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.origins)) {
      $dara.Model.validateArray(this.origins);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOriginPoolShrinkRequest extends $dara.Model {
  enabled?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * UpdateOriginPool
   */
  id?: number;
  originsShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      enabled: 'Enabled',
      id: 'Id',
      originsShrink: 'Origins',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enabled: 'boolean',
      id: 'number',
      originsShrink: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOriginPoolResponseBody extends $dara.Model {
  id?: number;
  /**
   * @remarks
   * Id of the request
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOriginPoolResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateOriginPoolResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateOriginPoolResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOriginProtectionRequest extends $dara.Model {
  /**
   * @remarks
   * The IP convergence status.
   * 
   * *   on
   * *   off
   * 
   * This parameter is required.
   * 
   * @example
   * on
   */
  originConverge?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      originConverge: 'OriginConverge',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      originConverge: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOriginProtectionResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 4C6B5E5A-42FC-5DF2-986C-4DAAE3C55086
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOriginProtectionResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateOriginProtectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateOriginProtectionResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOriginProtectionIpWhiteListRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOriginProtectionIpWhiteListResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CB1A380B-09F0-41BB-A198-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOriginProtectionIpWhiteListResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateOriginProtectionIpWhiteListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateOriginProtectionIpWhiteListResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOriginRuleRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 35281609698****
   */
  configId?: number;
  /**
   * @example
   * test.example.com
   */
  dnsRecord?: string;
  /**
   * @example
   * origin.example.com
   */
  originHost?: string;
  /**
   * @example
   * 8080
   */
  originHttpPort?: string;
  /**
   * @example
   * 4433
   */
  originHttpsPort?: string;
  /**
   * @example
   * http
   */
  originScheme?: string;
  /**
   * @example
   * origin.example.com
   */
  originSni?: string;
  /**
   * @example
   * on
   */
  range?: string;
  /**
   * @example
   * (http.host eq \\"video.example.com\\")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5407498413****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      dnsRecord: 'DnsRecord',
      originHost: 'OriginHost',
      originHttpPort: 'OriginHttpPort',
      originHttpsPort: 'OriginHttpsPort',
      originScheme: 'OriginScheme',
      originSni: 'OriginSni',
      range: 'Range',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      dnsRecord: 'string',
      originHost: 'string',
      originHttpPort: 'string',
      originHttpsPort: 'string',
      originScheme: 'string',
      originSni: 'string',
      range: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOriginRuleResponseBody extends $dara.Model {
  /**
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOriginRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateOriginRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateOriginRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePageRequest extends $dara.Model {
  /**
   * @remarks
   * The Base64-encoded content of the error page. The content type is specified by the Content-Type field.
   * 
   * This parameter is required.
   * 
   * @example
   * PGh0bWw+aGVsbG8gcGFnZTwvaHRtbD4=
   */
  content?: string;
  /**
   * @remarks
   * The Content-Type field in the HTTP header. Valid values:
   * 
   * *   text/html
   * *   application/json
   * 
   * This parameter is required.
   * 
   * @example
   * text/html
   */
  contentType?: string;
  /**
   * @remarks
   * The description of the custom error page.
   * 
   * This parameter is required.
   * 
   * @example
   * a custom deny page
   */
  description?: string;
  /**
   * @remarks
   * The ID of the custom error page, which can be obtained by calling the [ListPages](https://help.aliyun.com/document_detail/2850223.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 50000001
   */
  id?: number;
  /**
   * @remarks
   * The name of the custom error page.
   * 
   * This parameter is required.
   * 
   * @example
   * example
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      contentType: 'ContentType',
      description: 'Description',
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      contentType: 'string',
      description: 'string',
      id: 'number',
      name: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePageResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 36af3fcc-43d0-441c-86b1-428951dc8225
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdatePageResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdatePageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdatePageResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRatePlanSpecRequest extends $dara.Model {
  autoPay?: boolean;
  /**
   * @example
   * PREPAY
   */
  chargeType?: string;
  /**
   * @example
   * xcdn-91fknmb80f0g
   */
  instanceId?: string;
  /**
   * @example
   * UPGRADE
   */
  orderType?: string;
  /**
   * @example
   * entranceplan
   */
  targetPlanCode?: string;
  /**
   * @example
   * basic
   */
  targetPlanName?: string;
  static names(): { [key: string]: string } {
    return {
      autoPay: 'AutoPay',
      chargeType: 'ChargeType',
      instanceId: 'InstanceId',
      orderType: 'OrderType',
      targetPlanCode: 'TargetPlanCode',
      targetPlanName: 'TargetPlanName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoPay: 'boolean',
      chargeType: 'string',
      instanceId: 'string',
      orderType: 'string',
      targetPlanCode: 'string',
      targetPlanName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRatePlanSpecResponseBody extends $dara.Model {
  /**
   * @example
   * xcdn-as23ds***
   */
  instanceId?: string;
  /**
   * @example
   * 2223332122***
   */
  orderId?: string;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 30423A7F-A83D-1E24-B80E-86DD25790758
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      orderId: 'OrderId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      orderId: 'string',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRatePlanSpecResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateRatePlanSpecResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateRatePlanSpecResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRecordRequest extends $dara.Model {
  /**
   * @remarks
   * The origin authentication information of the CNAME record.
   */
  authConf?: UpdateRecordRequestAuthConf;
  /**
   * @remarks
   * The business scenario of the record for acceleration. Leave the parameter empty if your record is not proxied. Valid values:
   * 
   * *   **video_image**: video and image.
   * *   **api**: API.
   * *   **web**: web page.
   * 
   * @example
   * web
   */
  bizName?: string;
  /**
   * @remarks
   * The comments of the record.
   * 
   * @example
   * This is a remark.
   */
  comment?: string;
  /**
   * @remarks
   * The DNS record information. The format of this field varies based on the record type. For more information, see [Add DNS records](https://www.alibabacloud.com/help/doc-detail/2708761.html).
   * 
   * This parameter is required.
   * 
   * @example
   * {
   *     "value":"2.2.2.2"
   * }
   */
  data?: UpdateRecordRequestData;
  /**
   * @remarks
   * The origin host policy. This policy takes effect when the record type is CNAME. You can set the policy in two modes:
   * 
   * *   **follow_hostname**: match the requested domain name.
   * *   **follow_origin_domain**: match the origin\\"s domain name.
   * 
   * @example
   * follow_origin_domain
   */
  hostPolicy?: string;
  /**
   * @remarks
   * Specifies whether to proxy the record. Only CNAME and A/AAAA records can be proxied. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  proxied?: boolean;
  /**
   * @remarks
   * The record ID, which can be obtained by calling [ListRecords](https://help.aliyun.com/document_detail/2850265.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  recordId?: number;
  /**
   * @remarks
   * The type of the origin for the CNAME record. This parameter is required when you add a CNAME record. Valid values:
   * 
   * *   **OSS** : OSS origin.
   * *   **S3** : S3 origin.
   * *   **LB**: Load Balancer origin.
   * *   **OP**: origin in an origin pool.
   * *   **Domain**: common domain name.
   * 
   * If you leave the parameter empty or set its value as null, the default is Domain, which is common domain name.
   * 
   * @example
   * OSS
   */
  sourceType?: string;
  /**
   * @remarks
   * The TTL of the record. Unit: seconds. The range is 30 to 86,400, or 1. If the value is 1, the TTL of the record is determined by the system.
   * 
   * @example
   * 30
   */
  ttl?: number;
  static names(): { [key: string]: string } {
    return {
      authConf: 'AuthConf',
      bizName: 'BizName',
      comment: 'Comment',
      data: 'Data',
      hostPolicy: 'HostPolicy',
      proxied: 'Proxied',
      recordId: 'RecordId',
      sourceType: 'SourceType',
      ttl: 'Ttl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authConf: UpdateRecordRequestAuthConf,
      bizName: 'string',
      comment: 'string',
      data: UpdateRecordRequestData,
      hostPolicy: 'string',
      proxied: 'boolean',
      recordId: 'number',
      sourceType: 'string',
      ttl: 'number',
    };
  }

  validate() {
    if(this.authConf && typeof (this.authConf as any).validate === 'function') {
      (this.authConf as any).validate();
    }
    if(this.data && typeof (this.data as any).validate === 'function') {
      (this.data as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRecordShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The origin authentication information of the CNAME record.
   */
  authConfShrink?: string;
  /**
   * @remarks
   * The business scenario of the record for acceleration. Leave the parameter empty if your record is not proxied. Valid values:
   * 
   * *   **video_image**: video and image.
   * *   **api**: API.
   * *   **web**: web page.
   * 
   * @example
   * web
   */
  bizName?: string;
  /**
   * @remarks
   * The comments of the record.
   * 
   * @example
   * This is a remark.
   */
  comment?: string;
  /**
   * @remarks
   * The DNS record information. The format of this field varies based on the record type. For more information, see [Add DNS records](https://www.alibabacloud.com/help/doc-detail/2708761.html).
   * 
   * This parameter is required.
   * 
   * @example
   * {
   *     "value":"2.2.2.2"
   * }
   */
  dataShrink?: string;
  /**
   * @remarks
   * The origin host policy. This policy takes effect when the record type is CNAME. You can set the policy in two modes:
   * 
   * *   **follow_hostname**: match the requested domain name.
   * *   **follow_origin_domain**: match the origin\\"s domain name.
   * 
   * @example
   * follow_origin_domain
   */
  hostPolicy?: string;
  /**
   * @remarks
   * Specifies whether to proxy the record. Only CNAME and A/AAAA records can be proxied. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  proxied?: boolean;
  /**
   * @remarks
   * The record ID, which can be obtained by calling [ListRecords](https://help.aliyun.com/document_detail/2850265.html).
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  recordId?: number;
  /**
   * @remarks
   * The type of the origin for the CNAME record. This parameter is required when you add a CNAME record. Valid values:
   * 
   * *   **OSS** : OSS origin.
   * *   **S3** : S3 origin.
   * *   **LB**: Load Balancer origin.
   * *   **OP**: origin in an origin pool.
   * *   **Domain**: common domain name.
   * 
   * If you leave the parameter empty or set its value as null, the default is Domain, which is common domain name.
   * 
   * @example
   * OSS
   */
  sourceType?: string;
  /**
   * @remarks
   * The TTL of the record. Unit: seconds. The range is 30 to 86,400, or 1. If the value is 1, the TTL of the record is determined by the system.
   * 
   * @example
   * 30
   */
  ttl?: number;
  static names(): { [key: string]: string } {
    return {
      authConfShrink: 'AuthConf',
      bizName: 'BizName',
      comment: 'Comment',
      dataShrink: 'Data',
      hostPolicy: 'HostPolicy',
      proxied: 'Proxied',
      recordId: 'RecordId',
      sourceType: 'SourceType',
      ttl: 'Ttl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authConfShrink: 'string',
      bizName: 'string',
      comment: 'string',
      dataShrink: 'string',
      hostPolicy: 'string',
      proxied: 'boolean',
      recordId: 'number',
      sourceType: 'string',
      ttl: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRecordResponseBody extends $dara.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRecordResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateRecordResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRedirectRuleRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 3528160969****
   */
  configId?: number;
  /**
   * @example
   * on
   */
  reserveQueryString?: string;
  /**
   * @example
   * (http.host eq "video.example.com")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * rule_example
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @example
   * 301
   */
  statusCode?: string;
  /**
   * @example
   * http://www.exapmle.com/index.html
   */
  targetUrl?: string;
  /**
   * @example
   * static
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      reserveQueryString: 'ReserveQueryString',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      statusCode: 'StatusCode',
      targetUrl: 'TargetUrl',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      reserveQueryString: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
      statusCode: 'string',
      targetUrl: 'string',
      type: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRedirectRuleResponseBody extends $dara.Model {
  /**
   * @example
   * CB1A380B-09F0-41BB-A198-72F8FD6DA2FE
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRedirectRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateRedirectRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateRedirectRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRewriteUrlRuleRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 3528160969****
   */
  configId?: number;
  /**
   * @example
   * example=123
   */
  queryString?: string;
  /**
   * @example
   * static
   */
  rewriteQueryStringType?: string;
  /**
   * @example
   * static
   * 
   * **if can be null:**
   * false
   */
  rewriteUriType?: string;
  /**
   * @example
   * (http.host eq "video.example.com")
   */
  rule?: string;
  /**
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @example
   * example=123
   */
  ruleName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456789****
   */
  siteId?: number;
  /**
   * @example
   * /image/example.jpg
   */
  uri?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      queryString: 'QueryString',
      rewriteQueryStringType: 'RewriteQueryStringType',
      rewriteUriType: 'RewriteUriType',
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      uri: 'Uri',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'number',
      queryString: 'string',
      rewriteQueryStringType: 'string',
      rewriteUriType: 'string',
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
      uri: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRewriteUrlRuleResponseBody extends $dara.Model {
  /**
   * @example
   * 156A6B-677B1A-4297B7-9187B7-2B44792
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRewriteUrlRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateRewriteUrlRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateRewriteUrlRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScheduledPreloadExecutionRequest extends $dara.Model {
  /**
   * @remarks
   * The end time of the prefetch plan.
   * 
   * @example
   * 2024-05-31T18:10:48.849+08:00
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the prefetch plan.
   * 
   * This parameter is required.
   * 
   * @example
   * UpdateScheduledPreloadExecution
   */
  id?: string;
  /**
   * @remarks
   * The time interval between each batch execution. Unit: seconds.
   * 
   * @example
   * 60
   */
  interval?: number;
  /**
   * @remarks
   * The number of URLs prefetched in each batch.
   * 
   * @example
   * 10
   */
  sliceLen?: number;
  /**
   * @remarks
   * The start time of the prefetch plan.
   * 
   * @example
   * 2024-05-31T17:10:48.849+08:00
   */
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      id: 'Id',
      interval: 'Interval',
      sliceLen: 'SliceLen',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      id: 'string',
      interval: 'number',
      sliceLen: 'number',
      startTime: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScheduledPreloadExecutionResponseBody extends $dara.Model {
  /**
   * @remarks
   * The ID of the Alibaba Cloud account.
   * 
   * @example
   * 15685865xxx14622
   */
  aliUid?: string;
  /**
   * @remarks
   * The end time of the prefetch plan.
   * 
   * @example
   * 2024-05-31T18:10:48.849+08:00
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the prefetch plan.
   * 
   * @example
   * 66599bd7397885b43804901c
   */
  id?: string;
  /**
   * @remarks
   * The time interval between each batch execution. Unit: seconds.
   * 
   * @example
   * 60
   */
  interval?: number;
  /**
   * @remarks
   * The ID of the prefetch task.
   * 
   * @example
   * 665d3af3621bccf3fe29e1a4
   */
  jobId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A123425345
   */
  requestId?: string;
  /**
   * @remarks
   * The number of URLs prefetched in each batch.
   * 
   * @example
   * 10
   */
  sliceLen?: number;
  /**
   * @remarks
   * The start time of the prefetch plan.
   * 
   * @example
   * 2024-05-31T17:10:48.849+08:00
   */
  startTime?: string;
  /**
   * @remarks
   * The status of the prefetch plan. Valid values:
   * 
   * *   **waiting**
   * *   **running**
   * *   **finished**
   * *   **failed**
   * *   **stopped**
   * 
   * @example
   * running
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      aliUid: 'AliUid',
      endTime: 'EndTime',
      id: 'Id',
      interval: 'Interval',
      jobId: 'JobId',
      requestId: 'RequestId',
      sliceLen: 'SliceLen',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliUid: 'string',
      endTime: 'string',
      id: 'string',
      interval: 'number',
      jobId: 'string',
      requestId: 'string',
      sliceLen: 'number',
      startTime: 'string',
      status: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateScheduledPreloadExecutionResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateScheduledPreloadExecutionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateScheduledPreloadExecutionResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSeoBypassRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * on
   */
  enable?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSeoBypassResponseBody extends $dara.Model {
  /**
   * @example
   * 04F0F334-1335-436C-A1D7-6C044FE73368
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSeoBypassResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateSeoBypassResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSeoBypassResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteAccessTypeRequest extends $dara.Model {
  /**
   * @remarks
   * The new DNS setup of the website. Valid values:
   * 
   * *   **NS**
   * *   **CNAME**
   * 
   * This parameter is required.
   * 
   * @example
   * NS
   */
  accessType?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      accessType: 'AccessType',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessType: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteAccessTypeResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteAccessTypeResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateSiteAccessTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSiteAccessTypeResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteCoverageRequest extends $dara.Model {
  /**
   * @remarks
   * The desired service location. Valid values:
   * 
   * *   **domestic**: the Chinese mainland
   * *   **global**: global
   * *   **overseas**: outside the Chinese mainland
   * 
   * This parameter is required.
   * 
   * @example
   * global
   */
  coverage?: string;
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      coverage: 'Coverage',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      coverage: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteCoverageResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 65C66B7B-671A-8297-9187-2R5477247B76
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteCoverageResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateSiteCoverageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSiteCoverageResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteCustomLogRequest extends $dara.Model {
  /**
   * @remarks
   * The cookie fields.
   */
  cookies?: string[];
  /**
   * @remarks
   * The request header fields.
   */
  requestHeaders?: string[];
  /**
   * @remarks
   * The response header fields.
   */
  responseHeaders?: string[];
  /**
   * @remarks
   * site id
   * 
   * @example
   * 11223****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      cookies: 'Cookies',
      requestHeaders: 'RequestHeaders',
      responseHeaders: 'ResponseHeaders',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cookies: { 'type': 'array', 'itemType': 'string' },
      requestHeaders: { 'type': 'array', 'itemType': 'string' },
      responseHeaders: { 'type': 'array', 'itemType': 'string' },
      siteId: 'number',
    };
  }

  validate() {
    if(Array.isArray(this.cookies)) {
      $dara.Model.validateArray(this.cookies);
    }
    if(Array.isArray(this.requestHeaders)) {
      $dara.Model.validateArray(this.requestHeaders);
    }
    if(Array.isArray(this.responseHeaders)) {
      $dara.Model.validateArray(this.responseHeaders);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteCustomLogShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The cookie fields.
   */
  cookiesShrink?: string;
  /**
   * @remarks
   * The request header fields.
   */
  requestHeadersShrink?: string;
  /**
   * @remarks
   * The response header fields.
   */
  responseHeadersShrink?: string;
  /**
   * @remarks
   * site id
   * 
   * @example
   * 11223****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      cookiesShrink: 'Cookies',
      requestHeadersShrink: 'RequestHeaders',
      responseHeadersShrink: 'ResponseHeaders',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cookiesShrink: 'string',
      requestHeadersShrink: 'string',
      responseHeadersShrink: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteCustomLogResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * ET5BF670-09D5-4D0B-BEBY-D96A2A528000
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteCustomLogResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateSiteCustomLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSiteCustomLogResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteDeliveryTaskRequest extends $dara.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * *   dcdn_log_access_l1 (default): access logs.
   * *   dcdn_log_er: Edge Routine logs.
   * *   dcdn_log_waf: firewall logs.
   * *   dcdn_log_ipa: TCP/UDP proxy logs.
   * 
   * @example
   * dcdn_log_er
   */
  businessType?: string;
  /**
   * @remarks
   * The discard rate.
   * 
   * @example
   * 0.0
   */
  discardRate?: number;
  /**
   * @remarks
   * The log fields that you want to include in real-time logs to be delivered. Separate the log fields with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * ClientIP,UserAgent
   */
  fieldName?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * This parameter is required.
   * 
   * @example
   * cdn-test-task
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      discardRate: 'DiscardRate',
      fieldName: 'FieldName',
      siteId: 'SiteId',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      discardRate: 'number',
      fieldName: 'string',
      siteId: 'number',
      taskName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteDeliveryTaskResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 34DCBC8A-****-****-****-6DAA11D7DDBD
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteDeliveryTaskResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateSiteDeliveryTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSiteDeliveryTaskResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteDeliveryTaskStatusRequest extends $dara.Model {
  /**
   * @remarks
   * Specifies whether to enable the delivery task.
   * 
   * This parameter is required.
   * 
   * @example
   * online
   */
  method?: string;
  /**
   * @remarks
   * The website ID.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * This parameter is required.
   * 
   * @example
   * cdn-test-task
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      method: 'Method',
      siteId: 'SiteId',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      method: 'string',
      siteId: 'number',
      taskName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteDeliveryTaskStatusResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 34DCBC8A-****-****-****-6DAA11D7DDBD
   */
  requestId?: string;
  /**
   * @remarks
   * The status of the delivery task. Valid values:
   * 
   * *   **online**
   * *   **offline**
   * 
   * @example
   * online
   */
  status?: string;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * @example
   * cdn-test-task
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      status: 'Status',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      status: 'string',
      taskName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteDeliveryTaskStatusResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateSiteDeliveryTaskStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSiteDeliveryTaskStatusResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteNameExclusiveRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * on
   */
  enable?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteNameExclusiveResponseBody extends $dara.Model {
  /**
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteNameExclusiveResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateSiteNameExclusiveResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSiteNameExclusiveResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSitePauseRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * true
   */
  paused?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      paused: 'Paused',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      paused: 'boolean',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSitePauseResponseBody extends $dara.Model {
  /**
   * @example
   * 6abd807e-ed2a-44de-ac54-ac38a62472e6
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSitePauseResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateSitePauseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSitePauseResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteVanityNSRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  /**
   * @remarks
   * The custom nameserver names. You can specify two to five custom nameserver names. Separate multiple names with commas (,).
   * 
   * @example
   * ns1.example.com,ns2.example.com
   */
  vanityNSList?: string;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      vanityNSList: 'VanityNSList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      vanityNSList: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteVanityNSResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSiteVanityNSResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateSiteVanityNSResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSiteVanityNSResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTieredCacheRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * edge_smart
   */
  cacheArchitectureMode?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      cacheArchitectureMode: 'CacheArchitectureMode',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cacheArchitectureMode: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTieredCacheResponseBody extends $dara.Model {
  /**
   * @example
   * 15C66C7B-671A-4297-9187-2C4477247A74
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTieredCacheResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTieredCacheResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTieredCacheResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserDeliveryTaskRequest extends $dara.Model {
  /**
   * @remarks
   * The log category. Valid values:
   * 
   * *   dcdn_log_access_l1 (default): access logs.
   * *   dcdn_log_er: Edge Routine logs.
   * *   dcdn_log_waf: firewall logs.
   * *   dcdn_log_ipa: TCP/UDP proxy logs.
   * 
   * @example
   * dcdn_log_er
   */
  businessType?: string;
  details?: string;
  /**
   * @remarks
   * The discard rate. Default value: 0.
   * 
   * @example
   * 0
   */
  discardRate?: number;
  /**
   * @remarks
   * The log fields that you want to include in logs to be delivered. Separate the log fields with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * ClientRequestID,ClientRequestHost
   */
  fieldName?: string;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * This parameter is required.
   * 
   * @example
   * test_project
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      details: 'Details',
      discardRate: 'DiscardRate',
      fieldName: 'FieldName',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      details: 'string',
      discardRate: 'number',
      fieldName: 'string',
      taskName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserDeliveryTaskResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 34DCBC8A-****-****-****-6DAA11D7DDBD
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserDeliveryTaskResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateUserDeliveryTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateUserDeliveryTaskResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserDeliveryTaskStatusRequest extends $dara.Model {
  /**
   * @remarks
   * Enables or disables the delivery task. Valid values: online and offline.
   * 
   * This parameter is required.
   * 
   * @example
   * online
   */
  method?: string;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * This parameter is required.
   * 
   * @example
   * test_project
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      method: 'Method',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      method: 'string',
      taskName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserDeliveryTaskStatusResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 34DCBC8A-****-****-****-6DAA11D7DDBD
   */
  requestId?: string;
  /**
   * @remarks
   * The status of the delivery task.
   * 
   * @example
   * online
   */
  status?: string;
  /**
   * @remarks
   * The name of the delivery task.
   * 
   * @example
   * test_project
   */
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      status: 'Status',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      status: 'string',
      taskName: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUserDeliveryTaskStatusResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateUserDeliveryTaskStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateUserDeliveryTaskStatusResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaitingRoomRequest extends $dara.Model {
  /**
   * @remarks
   * The name of the custom cookie.
   * 
   * @example
   * __aliwaitingroom_example
   */
  cookieName?: string;
  /**
   * @remarks
   * The content of the custom waiting room page. You must specify this parameter if you set WaitingRoomType to custom. The content must be Base64-encoded.
   * 
   * @example
   * Hello%20world!
   */
  customPageHtml?: string;
  /**
   * @remarks
   * The description of the waiting room.
   */
  description?: string;
  /**
   * @remarks
   * Specifies whether to disable session renewal. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  disableSessionRenewalEnable?: string;
  /**
   * @remarks
   * Specifies whether to enable the waiting room. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  enable?: string;
  /**
   * @remarks
   * The hostname and path.
   */
  hostNameAndPath?: UpdateWaitingRoomRequestHostNameAndPath[];
  /**
   * @remarks
   * Specifies whether to enable JSON response. If JSON response is enabled, a JSON body is returned for requests to the waiting room with the header Accept: application/json. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  jsonResponseEnable?: string;
  /**
   * @remarks
   * The language of the waiting room page. You must specify this parameter if you set WaitingRoomType to default. Valid values:
   * 
   * *   enus: English.
   * *   zhcn: Simplified Chinese.
   * *   zhhk: Traditional Chinese.
   * 
   * @example
   * zhcn
   */
  language?: string;
  /**
   * @remarks
   * The name of the waiting room.
   */
  name?: string;
  /**
   * @remarks
   * The maximum number of new users per minute.
   * 
   * @example
   * 200
   */
  newUsersPerMinute?: string;
  /**
   * @remarks
   * Specifies whether to queue all requests. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  queueAllEnable?: string;
  /**
   * @remarks
   * The queuing method. Valid values:
   * 
   * *   random: Users gain access to the origin randomly, regardless of the arrival time.
   * *   fifo: Users gain access to the origin in order of arrival.
   * *   passthrough: Users pass through the waiting room and go straight to the origin.
   * *   reject-all: Users are blocked from reaching the origin.
   * 
   * @example
   * random
   */
  queuingMethod?: string;
  /**
   * @remarks
   * The HTTP status code to return while a user is in the queue. Valid values:
   * 
   * *   200
   * *   202
   * *   429
   * 
   * @example
   * 200
   */
  queuingStatusCode?: string;
  /**
   * @remarks
   * The maximum duration for which a session remains valid after a user leaves the origin. Unit: minutes.
   * 
   * @example
   * 5
   */
  sessionDuration?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 7096621098****
   */
  siteId?: number;
  /**
   * @remarks
   * The maximum number of active users.
   * 
   * @example
   * 300
   */
  totalActiveUsers?: string;
  /**
   * @remarks
   * The ID of the waiting room, which can be obtained by calling the [ListWaitingRooms](https://help.aliyun.com/document_detail/2850279.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 6a51d5bc6460887abd129****
   */
  waitingRoomId?: string;
  /**
   * @remarks
   * The type of the waiting room. Valid values:
   * 
   * *   default
   * *   custom
   * 
   * @example
   * default
   */
  waitingRoomType?: string;
  static names(): { [key: string]: string } {
    return {
      cookieName: 'CookieName',
      customPageHtml: 'CustomPageHtml',
      description: 'Description',
      disableSessionRenewalEnable: 'DisableSessionRenewalEnable',
      enable: 'Enable',
      hostNameAndPath: 'HostNameAndPath',
      jsonResponseEnable: 'JsonResponseEnable',
      language: 'Language',
      name: 'Name',
      newUsersPerMinute: 'NewUsersPerMinute',
      queueAllEnable: 'QueueAllEnable',
      queuingMethod: 'QueuingMethod',
      queuingStatusCode: 'QueuingStatusCode',
      sessionDuration: 'SessionDuration',
      siteId: 'SiteId',
      totalActiveUsers: 'TotalActiveUsers',
      waitingRoomId: 'WaitingRoomId',
      waitingRoomType: 'WaitingRoomType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cookieName: 'string',
      customPageHtml: 'string',
      description: 'string',
      disableSessionRenewalEnable: 'string',
      enable: 'string',
      hostNameAndPath: { 'type': 'array', 'itemType': UpdateWaitingRoomRequestHostNameAndPath },
      jsonResponseEnable: 'string',
      language: 'string',
      name: 'string',
      newUsersPerMinute: 'string',
      queueAllEnable: 'string',
      queuingMethod: 'string',
      queuingStatusCode: 'string',
      sessionDuration: 'string',
      siteId: 'number',
      totalActiveUsers: 'string',
      waitingRoomId: 'string',
      waitingRoomType: 'string',
    };
  }

  validate() {
    if(Array.isArray(this.hostNameAndPath)) {
      $dara.Model.validateArray(this.hostNameAndPath);
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaitingRoomShrinkRequest extends $dara.Model {
  /**
   * @remarks
   * The name of the custom cookie.
   * 
   * @example
   * __aliwaitingroom_example
   */
  cookieName?: string;
  /**
   * @remarks
   * The content of the custom waiting room page. You must specify this parameter if you set WaitingRoomType to custom. The content must be Base64-encoded.
   * 
   * @example
   * Hello%20world!
   */
  customPageHtml?: string;
  /**
   * @remarks
   * The description of the waiting room.
   */
  description?: string;
  /**
   * @remarks
   * Specifies whether to disable session renewal. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  disableSessionRenewalEnable?: string;
  /**
   * @remarks
   * Specifies whether to enable the waiting room. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  enable?: string;
  /**
   * @remarks
   * The hostname and path.
   */
  hostNameAndPathShrink?: string;
  /**
   * @remarks
   * Specifies whether to enable JSON response. If JSON response is enabled, a JSON body is returned for requests to the waiting room with the header Accept: application/json. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  jsonResponseEnable?: string;
  /**
   * @remarks
   * The language of the waiting room page. You must specify this parameter if you set WaitingRoomType to default. Valid values:
   * 
   * *   enus: English.
   * *   zhcn: Simplified Chinese.
   * *   zhhk: Traditional Chinese.
   * 
   * @example
   * zhcn
   */
  language?: string;
  /**
   * @remarks
   * The name of the waiting room.
   */
  name?: string;
  /**
   * @remarks
   * The maximum number of new users per minute.
   * 
   * @example
   * 200
   */
  newUsersPerMinute?: string;
  /**
   * @remarks
   * Specifies whether to queue all requests. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  queueAllEnable?: string;
  /**
   * @remarks
   * The queuing method. Valid values:
   * 
   * *   random: Users gain access to the origin randomly, regardless of the arrival time.
   * *   fifo: Users gain access to the origin in order of arrival.
   * *   passthrough: Users pass through the waiting room and go straight to the origin.
   * *   reject-all: Users are blocked from reaching the origin.
   * 
   * @example
   * random
   */
  queuingMethod?: string;
  /**
   * @remarks
   * The HTTP status code to return while a user is in the queue. Valid values:
   * 
   * *   200
   * *   202
   * *   429
   * 
   * @example
   * 200
   */
  queuingStatusCode?: string;
  /**
   * @remarks
   * The maximum duration for which a session remains valid after a user leaves the origin. Unit: minutes.
   * 
   * @example
   * 5
   */
  sessionDuration?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 7096621098****
   */
  siteId?: number;
  /**
   * @remarks
   * The maximum number of active users.
   * 
   * @example
   * 300
   */
  totalActiveUsers?: string;
  /**
   * @remarks
   * The ID of the waiting room, which can be obtained by calling the [ListWaitingRooms](https://help.aliyun.com/document_detail/2850279.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 6a51d5bc6460887abd129****
   */
  waitingRoomId?: string;
  /**
   * @remarks
   * The type of the waiting room. Valid values:
   * 
   * *   default
   * *   custom
   * 
   * @example
   * default
   */
  waitingRoomType?: string;
  static names(): { [key: string]: string } {
    return {
      cookieName: 'CookieName',
      customPageHtml: 'CustomPageHtml',
      description: 'Description',
      disableSessionRenewalEnable: 'DisableSessionRenewalEnable',
      enable: 'Enable',
      hostNameAndPathShrink: 'HostNameAndPath',
      jsonResponseEnable: 'JsonResponseEnable',
      language: 'Language',
      name: 'Name',
      newUsersPerMinute: 'NewUsersPerMinute',
      queueAllEnable: 'QueueAllEnable',
      queuingMethod: 'QueuingMethod',
      queuingStatusCode: 'QueuingStatusCode',
      sessionDuration: 'SessionDuration',
      siteId: 'SiteId',
      totalActiveUsers: 'TotalActiveUsers',
      waitingRoomId: 'WaitingRoomId',
      waitingRoomType: 'WaitingRoomType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cookieName: 'string',
      customPageHtml: 'string',
      description: 'string',
      disableSessionRenewalEnable: 'string',
      enable: 'string',
      hostNameAndPathShrink: 'string',
      jsonResponseEnable: 'string',
      language: 'string',
      name: 'string',
      newUsersPerMinute: 'string',
      queueAllEnable: 'string',
      queuingMethod: 'string',
      queuingStatusCode: 'string',
      sessionDuration: 'string',
      siteId: 'number',
      totalActiveUsers: 'string',
      waitingRoomId: 'string',
      waitingRoomType: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaitingRoomResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0195619f-eab3-4a66-ac00-ed53d913e72e
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaitingRoomResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateWaitingRoomResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateWaitingRoomResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaitingRoomEventRequest extends $dara.Model {
  /**
   * @remarks
   * The content of the custom waiting room page. You must specify this parameter if you set WaitingRoomType to custom. The content must be Base64-encoded.
   * 
   * @example
   * html-yets-maqi1111
   */
  customPageHtml?: string;
  /**
   * @remarks
   * The description of the waiting room.
   * 
   * @example
   * http://yywyyw.com
   */
  description?: string;
  /**
   * @remarks
   * Specifies whether to disable session renewal. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * off
   */
  disableSessionRenewalEnable?: string;
  /**
   * @remarks
   * Specifies whether to enable the waiting room event. Valid values:
   * 
   * *   `on`
   * *   `off`
   * 
   * @example
   * on
   */
  enable?: string;
  /**
   * @remarks
   * The end time of the event. This value is a UNIX timestamp.
   * 
   * @example
   * 1719849600
   */
  endTime?: string;
  /**
   * @remarks
   * Specifies whether to enable JSON response. Valid values:
   * 
   * *   on
   * *   off
   * 
   * @example
   * off
   */
  jsonResponseEnable?: string;
  /**
   * @remarks
   * The default language. Valid values:
   * 
   * *   `enus`: English.
   * *   `zhcn`: Simplified Chinese.
   * *   `zhhk`: Traditional Chinese.
   * 
   * @example
   * enus
   */
  language?: string;
  /**
   * @remarks
   * The name of the waiting room event.
   */
  name?: string;
  /**
   * @remarks
   * The maximum number of new users per minute.
   * 
   * @example
   * 300
   */
  newUsersPerMinute?: string;
  /**
   * @remarks
   * Specifies whether to enable pre-queuing.
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  preQueueEnable?: string;
  /**
   * @remarks
   * The start time for pre-queuing.
   * 
   * @example
   * 1719763200
   */
  preQueueStartTime?: string;
  /**
   * @remarks
   * The queuing method. Valid values:
   * 
   * *   random: Users gain access to the origin randomly, regardless of the arrival time.
   * *   fifo: Users gain access to the origin in order of arrival.
   * *   passthrough: Users pass through the waiting room and go straight to the origin.
   * *   reject-all: All requests are blocked from accessing the origin.
   * 
   * @example
   * fifo
   */
  queuingMethod?: string;
  /**
   * @remarks
   * The HTTP status code to return while a user is in the queue. Valid values:
   * 
   * *   200
   * *   202
   * *   429
   * 
   * @example
   * 200
   */
  queuingStatusCode?: string;
  /**
   * @remarks
   * Specifies whether to enable random queuing.
   * 
   * *   on
   * *   off
   * 
   * @example
   * on
   */
  randomPreQueueEnable?: string;
  /**
   * @remarks
   * The maximum duration for which a session remains valid after a user leaves the origin. Unit: minutes.
   * 
   * @example
   * 5
   */
  sessionDuration?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The start time of the event. This value is a UNIX timestamp.
   * 
   * @example
   * 1719763200
   */
  startTime?: string;
  /**
   * @remarks
   * The maximum number of active users.
   * 
   * @example
   * 200
   */
  totalActiveUsers?: string;
  /**
   * @remarks
   * The ID of the waiting room event, which can be obtained by calling the [ListWaitingRoomEvents](https://help.aliyun.com/document_detail/2850279.html) operation.
   * 
   * @example
   * 89677721098****
   */
  waitingRoomEventId?: number;
  /**
   * @remarks
   * The type of the waiting room. Valid values:
   * 
   * *   default
   * *   custom
   * 
   * @example
   * custom
   */
  waitingRoomType?: string;
  static names(): { [key: string]: string } {
    return {
      customPageHtml: 'CustomPageHtml',
      description: 'Description',
      disableSessionRenewalEnable: 'DisableSessionRenewalEnable',
      enable: 'Enable',
      endTime: 'EndTime',
      jsonResponseEnable: 'JsonResponseEnable',
      language: 'Language',
      name: 'Name',
      newUsersPerMinute: 'NewUsersPerMinute',
      preQueueEnable: 'PreQueueEnable',
      preQueueStartTime: 'PreQueueStartTime',
      queuingMethod: 'QueuingMethod',
      queuingStatusCode: 'QueuingStatusCode',
      randomPreQueueEnable: 'RandomPreQueueEnable',
      sessionDuration: 'SessionDuration',
      siteId: 'SiteId',
      startTime: 'StartTime',
      totalActiveUsers: 'TotalActiveUsers',
      waitingRoomEventId: 'WaitingRoomEventId',
      waitingRoomType: 'WaitingRoomType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customPageHtml: 'string',
      description: 'string',
      disableSessionRenewalEnable: 'string',
      enable: 'string',
      endTime: 'string',
      jsonResponseEnable: 'string',
      language: 'string',
      name: 'string',
      newUsersPerMinute: 'string',
      preQueueEnable: 'string',
      preQueueStartTime: 'string',
      queuingMethod: 'string',
      queuingStatusCode: 'string',
      randomPreQueueEnable: 'string',
      sessionDuration: 'string',
      siteId: 'number',
      startTime: 'string',
      totalActiveUsers: 'string',
      waitingRoomEventId: 'number',
      waitingRoomType: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaitingRoomEventResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0195619f-eab3-4a66-ac00-ed53d913e72e
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaitingRoomEventResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateWaitingRoomEventResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateWaitingRoomEventResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaitingRoomRuleRequest extends $dara.Model {
  /**
   * @remarks
   * The rule content, which is a policy or conditional expression.
   * 
   * This parameter is required.
   * 
   * @example
   * (http.request.uri.path.file_name eq \\"jpg\\")
   */
  rule?: string;
  /**
   * @remarks
   * Specifies whether to enable the rule. Valid values:
   * 
   * *   on
   * *   off
   * 
   * This parameter is required.
   * 
   * @example
   * on
   */
  ruleEnable?: string;
  /**
   * @remarks
   * The rule name.
   * 
   * This parameter is required.
   * 
   * @example
   * test1
   */
  ruleName?: string;
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456****
   */
  siteId?: number;
  /**
   * @remarks
   * The ID of the waiting room bypass rule that you want to update. You can call [ListWaitingRoomRules](https://help.aliyun.com/document_detail/2850279.html) to obtain the ID.
   * 
   * @example
   * 8987739839****
   */
  waitingRoomRuleId?: number;
  static names(): { [key: string]: string } {
    return {
      rule: 'Rule',
      ruleEnable: 'RuleEnable',
      ruleName: 'RuleName',
      siteId: 'SiteId',
      waitingRoomRuleId: 'WaitingRoomRuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      rule: 'string',
      ruleEnable: 'string',
      ruleName: 'string',
      siteId: 'number',
      waitingRoomRuleId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaitingRoomRuleResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID, which is used to trace a call.
   * 
   * @example
   * 9bfe9d95-7bf6-469d-a628-ed7bc9f25073
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWaitingRoomRuleResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateWaitingRoomRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateWaitingRoomRuleResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadClientCaCertificateRequest extends $dara.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * -----BEGIN CERTIFICATE-----
   */
  certificate?: string;
  /**
   * @example
   * yourCertName
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      certificate: 'Certificate',
      name: 'Name',
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certificate: 'string',
      name: 'string',
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadClientCaCertificateResponseBody extends $dara.Model {
  /**
   * @example
   * www.example.com
   */
  commonName?: string;
  /**
   * @example
   * 1dc5fc9af4eead2570c70d94b416130baeb6d4429b51fd3557379588456aca66
   */
  fingerprintSha256?: string;
  /**
   * @example
   * baba39055622c008b90285a8838ed09a
   */
  id?: string;
  /**
   * @example
   * GlobalSign nv-sa
   */
  issuer?: string;
  /**
   * @example
   * 2024-12-01T02:13:07Z
   */
  notAfter?: string;
  /**
   * @example
   * 2023-12-01T02:13:07Z
   */
  notBefore?: string;
  /**
   * @example
   * 0AEDAF20-4DDF-4165-8750-47FF9C1929C9
   */
  requestId?: string;
  /**
   * @example
   * babab9db65ee5efcca9f3d41d4b50d66
   */
  serialNumber?: string;
  /**
   * @example
   * SHA256-RSA
   */
  signatureAlgorithm?: string;
  /**
   * @example
   * OK
   */
  status?: string;
  /**
   * @example
   * 300
   */
  validityDays?: string;
  static names(): { [key: string]: string } {
    return {
      commonName: 'CommonName',
      fingerprintSha256: 'FingerprintSha256',
      id: 'Id',
      issuer: 'Issuer',
      notAfter: 'NotAfter',
      notBefore: 'NotBefore',
      requestId: 'RequestId',
      serialNumber: 'SerialNumber',
      signatureAlgorithm: 'SignatureAlgorithm',
      status: 'Status',
      validityDays: 'ValidityDays',
    };
  }

  static types(): { [key: string]: any } {
    return {
      commonName: 'string',
      fingerprintSha256: 'string',
      id: 'string',
      issuer: 'string',
      notAfter: 'string',
      notBefore: 'string',
      requestId: 'string',
      serialNumber: 'string',
      signatureAlgorithm: 'string',
      status: 'string',
      validityDays: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadClientCaCertificateResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UploadClientCaCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UploadClientCaCertificateResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadFileRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456789****
   */
  siteId?: number;
  /**
   * @remarks
   * The type of the purge or prefetch task. Valid values:
   * 
   * *   **file** (default): purges the cache by file.
   * *   **preload**: prefetches the file.
   * *   **directory**: purges the cache by directory.
   * *   **ignoreParams**: purges the cache by URL with specified parameters ignored.
   * 
   * This parameter is required.
   * 
   * @example
   * file
   */
  type?: string;
  /**
   * @remarks
   * The name of the upload task.
   * 
   * This parameter is required.
   * 
   * @example
   * purge_task_2024_11_11
   */
  uploadTaskName?: string;
  /**
   * @remarks
   * The OSS URL of the file that contains resources to be purged or prefetched.
   * 
   * This parameter is required.
   * 
   * @example
   * https://xxxxx.oss-cn-shenzhen.aliyuncs.com/test_oss_file?Expires=1708659191&OSSAccessKeyId=**********&Signature=**********
   */
  url?: string;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      type: 'Type',
      uploadTaskName: 'UploadTaskName',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      type: 'string',
      uploadTaskName: 'string',
      url: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadFileAdvanceRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456789****
   */
  siteId?: number;
  /**
   * @remarks
   * The type of the purge or prefetch task. Valid values:
   * 
   * *   **file** (default): purges the cache by file.
   * *   **preload**: prefetches the file.
   * *   **directory**: purges the cache by directory.
   * *   **ignoreParams**: purges the cache by URL with specified parameters ignored.
   * 
   * This parameter is required.
   * 
   * @example
   * file
   */
  type?: string;
  /**
   * @remarks
   * The name of the upload task.
   * 
   * This parameter is required.
   * 
   * @example
   * purge_task_2024_11_11
   */
  uploadTaskName?: string;
  /**
   * @remarks
   * The OSS URL of the file that contains resources to be purged or prefetched.
   * 
   * This parameter is required.
   * 
   * @example
   * https://xxxxx.oss-cn-shenzhen.aliyuncs.com/test_oss_file?Expires=1708659191&OSSAccessKeyId=**********&Signature=**********
   */
  urlObject?: Readable;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
      type: 'Type',
      uploadTaskName: 'UploadTaskName',
      urlObject: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
      type: 'string',
      uploadTaskName: 'string',
      urlObject: 'Readable',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadFileResponseBody extends $dara.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 3C6CCEC4-6B88-4D4A-93E4-D47B3D92CF8F
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the file upload task. You can use this ID for task submission or query subsequently.
   * 
   * @example
   * 159253299357****
   */
  uploadId?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      uploadId: 'UploadId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      uploadId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UploadFileResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UploadFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UploadFileResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class VerifySiteRequest extends $dara.Model {
  /**
   * @remarks
   * The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234567890123
   */
  siteId?: number;
  static names(): { [key: string]: string } {
    return {
      siteId: 'SiteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      siteId: 'number',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class VerifySiteResponseBody extends $dara.Model {
  /**
   * @remarks
   * Indicates whether the verification passed. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  passed?: boolean;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 65C66B7B-671A-8297-9187-2R5477247B76
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      passed: 'Passed',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      passed: 'boolean',
      requestId: 'string',
    };
  }

  validate() {
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class VerifySiteResponse extends $dara.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: VerifySiteResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: VerifySiteResponseBody,
    };
  }

  validate() {
    if(this.headers) {
      $dara.Model.validateMap(this.headers);
    }
    if(this.body && typeof (this.body as any).validate === 'function') {
      (this.body as any).validate();
    }
    super.validate();
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends OpenApi {

  constructor(config: $OpenApiUtil.Config) {
    super(config);
    this._endpointRule = "";
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("esa", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!$dara.isNull(endpoint)) {
      return endpoint;
    }

    if (!$dara.isNull(endpointMap) && !$dara.isNull(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return OpenApiUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  /**
   * Activates a client certificate.
   * 
   * @param request - ActivateClientCertificateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ActivateClientCertificateResponse
   */
  async activateClientCertificateWithOptions(request: ActivateClientCertificateRequest, runtime: $dara.RuntimeOptions): Promise<ActivateClientCertificateResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ActivateClientCertificate",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ActivateClientCertificateResponse>(await this.callApi(params, req, runtime), new ActivateClientCertificateResponse({}));
    } else {
      return $dara.cast<ActivateClientCertificateResponse>(await this.execute(params, req, runtime), new ActivateClientCertificateResponse({}));
    }

  }

  /**
   * Activates a client certificate.
   * 
   * @param request - ActivateClientCertificateRequest
   * @returns ActivateClientCertificateResponse
   */
  async activateClientCertificate(request: ActivateClientCertificateRequest): Promise<ActivateClientCertificateResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.activateClientCertificateWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - ActivateVersionManagementRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ActivateVersionManagementResponse
   */
  async activateVersionManagementWithOptions(request: ActivateVersionManagementRequest, runtime: $dara.RuntimeOptions): Promise<ActivateVersionManagementResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ActivateVersionManagement",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ActivateVersionManagementResponse>(await this.callApi(params, req, runtime), new ActivateVersionManagementResponse({}));
    } else {
      return $dara.cast<ActivateVersionManagementResponse>(await this.execute(params, req, runtime), new ActivateVersionManagementResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - ActivateVersionManagementRequest
   * @returns ActivateVersionManagementResponse
   */
  async activateVersionManagement(request: ActivateVersionManagementRequest): Promise<ActivateVersionManagementResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.activateVersionManagementWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - ApplyCertificateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ApplyCertificateResponse
   */
  async applyCertificateWithOptions(request: ApplyCertificateRequest, runtime: $dara.RuntimeOptions): Promise<ApplyCertificateResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ApplyCertificate",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ApplyCertificateResponse>(await this.callApi(params, req, runtime), new ApplyCertificateResponse({}));
    } else {
      return $dara.cast<ApplyCertificateResponse>(await this.execute(params, req, runtime), new ApplyCertificateResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - ApplyCertificateRequest
   * @returns ApplyCertificateResponse
   */
  async applyCertificate(request: ApplyCertificateRequest): Promise<ApplyCertificateResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.applyCertificateWithOptions(request, runtime);
  }

  /**
   * Adds DNS records of different record types at a time..
   * 
   * @remarks
   * This operation allows you to create or update multiple DNS records at a time. It is suitable for managing a large number of DNS configurations. Supported record types include but are not limited to A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, and URI. The operation allows you to configure the priority, flag, tag, and weight for DNS records. In addition, for specific types of records, such as CERT, SSHFP, SMIMEA, and TLSA, advanced settings such as certificate information and encryption algorithms are also supported.
   * Successful and failed records along with error messages are listed in the response.
   * 
   * @param tmpReq - BatchCreateRecordsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchCreateRecordsResponse
   */
  async batchCreateRecordsWithOptions(tmpReq: BatchCreateRecordsRequest, runtime: $dara.RuntimeOptions): Promise<BatchCreateRecordsResponse> {
    tmpReq.validate();
    let request = new BatchCreateRecordsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.recordList)) {
      request.recordListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.recordList, "RecordList", "json");
    }

    let query = { };
    if (!$dara.isNull(request.recordListShrink)) {
      query["RecordList"] = request.recordListShrink;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "BatchCreateRecords",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<BatchCreateRecordsResponse>(await this.callApi(params, req, runtime), new BatchCreateRecordsResponse({}));
    } else {
      return $dara.cast<BatchCreateRecordsResponse>(await this.execute(params, req, runtime), new BatchCreateRecordsResponse({}));
    }

  }

  /**
   * Adds DNS records of different record types at a time..
   * 
   * @remarks
   * This operation allows you to create or update multiple DNS records at a time. It is suitable for managing a large number of DNS configurations. Supported record types include but are not limited to A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, and URI. The operation allows you to configure the priority, flag, tag, and weight for DNS records. In addition, for specific types of records, such as CERT, SSHFP, SMIMEA, and TLSA, advanced settings such as certificate information and encryption algorithms are also supported.
   * Successful and failed records along with error messages are listed in the response.
   * 
   * @param request - BatchCreateRecordsRequest
   * @returns BatchCreateRecordsResponse
   */
  async batchCreateRecords(request: BatchCreateRecordsRequest): Promise<BatchCreateRecordsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.batchCreateRecordsWithOptions(request, runtime);
  }

  /**
   * Deletes key-value pairs from a namespace at a time based on keys.
   * 
   * @param tmpReq - BatchDeleteKvRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchDeleteKvResponse
   */
  async batchDeleteKvWithOptions(tmpReq: BatchDeleteKvRequest, runtime: $dara.RuntimeOptions): Promise<BatchDeleteKvResponse> {
    tmpReq.validate();
    let request = new BatchDeleteKvShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.keys)) {
      request.keysShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.keys, "Keys", "json");
    }

    let query = { };
    if (!$dara.isNull(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.keysShrink)) {
      body["Keys"] = request.keysShrink;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "BatchDeleteKv",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<BatchDeleteKvResponse>(await this.callApi(params, req, runtime), new BatchDeleteKvResponse({}));
    } else {
      return $dara.cast<BatchDeleteKvResponse>(await this.execute(params, req, runtime), new BatchDeleteKvResponse({}));
    }

  }

  /**
   * Deletes key-value pairs from a namespace at a time based on keys.
   * 
   * @param request - BatchDeleteKvRequest
   * @returns BatchDeleteKvResponse
   */
  async batchDeleteKv(request: BatchDeleteKvRequest): Promise<BatchDeleteKvResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.batchDeleteKvWithOptions(request, runtime);
  }

  /**
   * Deletes multiple key-value pairs from a namespace at a time based on specified keys. The request body can be up to 100 MB.
   * 
   * @remarks
   * This operation allows you to upload a larger request body than by using [BatchDeleteKv](https://help.aliyun.com/document_detail/2850204.html). For small request bodies, we recommend that you use [BatchDeleteKv](https://help.aliyun.com/document_detail/2850204.html) to minimize the server processing time. This operation must be called by using SDKs. The following sample code uses the Golang SDK and BatchDeleteKvWithHighCapacityAdvance to call the operation.
   *     func TestBatchDeleteWithHighCapacity() error {
   *     	// Initialize the configurations.
   *     	cfg := new(openapi.Config)
   *     	cfg.SetAccessKeyId("xxxxxxxxx")
   *     	cfg.SetAccessKeySecret("xxxxxxxxxx")
   *     	cli, err := NewClient(cfg)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	runtime := &util.RuntimeOptions{}
   *     	// Construct a request for deleting key-value pairs at a time.
   *     	namespace := "test_batch_put"
   *     	rawReq := BatchDeleteKvRequest{
   *     		Namespace: &namespace,
   *     	}
   *     	for i := 0; i < 10000; i++ {
   *     		key := fmt.Sprintf("test_key_%d", i)
   *     		rawReq.Keys = append(rawReq.Keys, &key)
   *     	}
   *     	payload, err := json.Marshal(rawReq)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	// If the payload is greater than 2 MB, call the BatchDeleteKvWithHighCapacity operation for deletion.
   *     	reqHighCapacity := BatchDeleteKvWithHighCapacityAdvanceRequest{
   *     		Namespace: &namespace,
   *     		UrlObject: bytes.NewReader(payload),
   *     	}
   *     	resp, err := cli.BatchDeleteKvWithHighCapacityAdvance(&reqHighCapacity, runtime)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	return nil
   *     }
   * 
   * @param request - BatchDeleteKvWithHighCapacityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchDeleteKvWithHighCapacityResponse
   */
  async batchDeleteKvWithHighCapacityWithOptions(request: BatchDeleteKvWithHighCapacityRequest, runtime: $dara.RuntimeOptions): Promise<BatchDeleteKvWithHighCapacityResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!$dara.isNull(request.url)) {
      query["Url"] = request.url;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "BatchDeleteKvWithHighCapacity",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<BatchDeleteKvWithHighCapacityResponse>(await this.callApi(params, req, runtime), new BatchDeleteKvWithHighCapacityResponse({}));
    } else {
      return $dara.cast<BatchDeleteKvWithHighCapacityResponse>(await this.execute(params, req, runtime), new BatchDeleteKvWithHighCapacityResponse({}));
    }

  }

  /**
   * Deletes multiple key-value pairs from a namespace at a time based on specified keys. The request body can be up to 100 MB.
   * 
   * @remarks
   * This operation allows you to upload a larger request body than by using [BatchDeleteKv](https://help.aliyun.com/document_detail/2850204.html). For small request bodies, we recommend that you use [BatchDeleteKv](https://help.aliyun.com/document_detail/2850204.html) to minimize the server processing time. This operation must be called by using SDKs. The following sample code uses the Golang SDK and BatchDeleteKvWithHighCapacityAdvance to call the operation.
   *     func TestBatchDeleteWithHighCapacity() error {
   *     	// Initialize the configurations.
   *     	cfg := new(openapi.Config)
   *     	cfg.SetAccessKeyId("xxxxxxxxx")
   *     	cfg.SetAccessKeySecret("xxxxxxxxxx")
   *     	cli, err := NewClient(cfg)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	runtime := &util.RuntimeOptions{}
   *     	// Construct a request for deleting key-value pairs at a time.
   *     	namespace := "test_batch_put"
   *     	rawReq := BatchDeleteKvRequest{
   *     		Namespace: &namespace,
   *     	}
   *     	for i := 0; i < 10000; i++ {
   *     		key := fmt.Sprintf("test_key_%d", i)
   *     		rawReq.Keys = append(rawReq.Keys, &key)
   *     	}
   *     	payload, err := json.Marshal(rawReq)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	// If the payload is greater than 2 MB, call the BatchDeleteKvWithHighCapacity operation for deletion.
   *     	reqHighCapacity := BatchDeleteKvWithHighCapacityAdvanceRequest{
   *     		Namespace: &namespace,
   *     		UrlObject: bytes.NewReader(payload),
   *     	}
   *     	resp, err := cli.BatchDeleteKvWithHighCapacityAdvance(&reqHighCapacity, runtime)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	return nil
   *     }
   * 
   * @param request - BatchDeleteKvWithHighCapacityRequest
   * @returns BatchDeleteKvWithHighCapacityResponse
   */
  async batchDeleteKvWithHighCapacity(request: BatchDeleteKvWithHighCapacityRequest): Promise<BatchDeleteKvWithHighCapacityResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.batchDeleteKvWithHighCapacityWithOptions(request, runtime);
  }

  async batchDeleteKvWithHighCapacityAdvance(request: BatchDeleteKvWithHighCapacityAdvanceRequest, runtime: $dara.RuntimeOptions): Promise<BatchDeleteKvWithHighCapacityResponse> {
    // Step 0: init client
    let accessKeyId = await this._credential.getAccessKeyId();
    let accessKeySecret = await this._credential.getAccessKeySecret();
    let securityToken = await this._credential.getSecurityToken();
    let credentialType = this._credential.getType();
    let openPlatformEndpoint = this._openPlatformEndpoint;
    if ($dara.isNull(openPlatformEndpoint)) {
      openPlatformEndpoint = "openplatform.aliyuncs.com";
    }

    if ($dara.isNull(credentialType)) {
      credentialType = "access_key";
    }

    let authConfig = new $OpenApiUtil.Config({
      accessKeyId: accessKeyId,
      accessKeySecret: accessKeySecret,
      securityToken: securityToken,
      type: credentialType,
      endpoint: openPlatformEndpoint,
      protocol: this._protocol,
      regionId: this._regionId,
    });
    let authClient = new OpenPlatform(authConfig);
    let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
      product: "ESA",
      regionId: this._regionId,
    });
    let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({ });
    let ossConfig = new $OSS.Config({
      accessKeyId: accessKeyId,
      accessKeySecret: accessKeySecret,
      type: "access_key",
      protocol: this._protocol,
      regionId: this._regionId,
    });
    let ossClient : OSS = new OSS(ossConfig);
    let fileObj = new $FileForm.FileField({ });
    let ossHeader = new $OSS.PostObjectRequestHeader({ });
    let uploadRequest = new $OSS.PostObjectRequest({ });
    let ossRuntime = new $OSSUtil.RuntimeOptions({ });
    OpenApiUtil.convert(runtime, ossRuntime);
    let batchDeleteKvWithHighCapacityReq = new BatchDeleteKvWithHighCapacityRequest({ });
    OpenApiUtil.convert(request, batchDeleteKvWithHighCapacityReq);
    if (!$dara.isNull(request.urlObject)) {
      authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
      ossConfig.accessKeyId = authResponse.body.accessKeyId;
      ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
      ossClient = new OSS(ossConfig);
      fileObj = new $FileForm.FileField({
        filename: authResponse.body.objectKey,
        content: request.urlObject,
        contentType: "",
      });
      ossHeader = new $OSS.PostObjectRequestHeader({
        accessKeyId: authResponse.body.accessKeyId,
        policy: authResponse.body.encodedPolicy,
        signature: authResponse.body.signature,
        key: authResponse.body.objectKey,
        file: fileObj,
        successActionStatus: "201",
      });
      uploadRequest = new $OSS.PostObjectRequest({
        bucketName: authResponse.body.bucket,
        header: ossHeader,
      });
      await ossClient.postObject(uploadRequest, ossRuntime);
      batchDeleteKvWithHighCapacityReq.url = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
    }

    let batchDeleteKvWithHighCapacityResp = await this.batchDeleteKvWithHighCapacityWithOptions(batchDeleteKvWithHighCapacityReq, runtime);
    return batchDeleteKvWithHighCapacityResp;
  }

  /**
   * Batch queries the objects that match specific expressions.
   * 
   * @param tmpReq - BatchGetExpressionFieldsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchGetExpressionFieldsResponse
   */
  async batchGetExpressionFieldsWithOptions(tmpReq: BatchGetExpressionFieldsRequest, runtime: $dara.RuntimeOptions): Promise<BatchGetExpressionFieldsResponse> {
    tmpReq.validate();
    let request = new BatchGetExpressionFieldsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.expressions)) {
      request.expressionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.expressions, "Expressions", "json");
    }

    let query = { };
    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.expressionsShrink)) {
      body["Expressions"] = request.expressionsShrink;
    }

    if (!$dara.isNull(request.phase)) {
      body["Phase"] = request.phase;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "BatchGetExpressionFields",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<BatchGetExpressionFieldsResponse>(await this.callApi(params, req, runtime), new BatchGetExpressionFieldsResponse({}));
    } else {
      return $dara.cast<BatchGetExpressionFieldsResponse>(await this.execute(params, req, runtime), new BatchGetExpressionFieldsResponse({}));
    }

  }

  /**
   * Batch queries the objects that match specific expressions.
   * 
   * @param request - BatchGetExpressionFieldsRequest
   * @returns BatchGetExpressionFieldsResponse
   */
  async batchGetExpressionFields(request: BatchGetExpressionFieldsRequest): Promise<BatchGetExpressionFieldsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.batchGetExpressionFieldsWithOptions(request, runtime);
  }

  /**
   * Configures key-value pairs for a namespace at a time based on specified keys.
   * 
   * @param tmpReq - BatchPutKvRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchPutKvResponse
   */
  async batchPutKvWithOptions(tmpReq: BatchPutKvRequest, runtime: $dara.RuntimeOptions): Promise<BatchPutKvResponse> {
    tmpReq.validate();
    let request = new BatchPutKvShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.kvList)) {
      request.kvListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.kvList, "KvList", "json");
    }

    let query = { };
    if (!$dara.isNull(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.kvListShrink)) {
      body["KvList"] = request.kvListShrink;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "BatchPutKv",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<BatchPutKvResponse>(await this.callApi(params, req, runtime), new BatchPutKvResponse({}));
    } else {
      return $dara.cast<BatchPutKvResponse>(await this.execute(params, req, runtime), new BatchPutKvResponse({}));
    }

  }

  /**
   * Configures key-value pairs for a namespace at a time based on specified keys.
   * 
   * @param request - BatchPutKvRequest
   * @returns BatchPutKvResponse
   */
  async batchPutKv(request: BatchPutKvRequest): Promise<BatchPutKvResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.batchPutKvWithOptions(request, runtime);
  }

  /**
   * Configures key-value pairs for a namespace at a time based on specified keys. The request body can be up to 100 MB.
   * 
   * @remarks
   * This operation allows you to upload a larger request body than by using [BatchPutKv](https://help.aliyun.com/document_detail/2850203.html). For small request bodies, we recommend that you use [BatchPutKv](https://help.aliyun.com/document_detail/2850203.html) to minimize the server processing time. This operation must be called by using SDKs. The following sample code uses the Golang SDK and BatchPutKvWithHighCapacityAdvance to call the operation.
   *     func TestBatchPutKvWithHighCapacity() error {
   *     	// Initialize the configurations.
   *     	cfg := new(openapi.Config)
   *     	cfg.SetAccessKeyId("xxxxxxxxx")
   *     	cfg.SetAccessKeySecret("xxxxxxxxxx")
   *     	cli, err := NewClient(cfg)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	runtime := &util.RuntimeOptions{}
   *     	// Construct a request for uploading key-value pairs at a time.
   *     	namespace := "test_batch_put"
   *     	numKv := 10000
   *     	kvList := make([]*BatchPutKvRequestKvList, numKv)
   *     	test_value := strings.Repeat("a", 10*1024)
   *     	for i := 0; i < numKv; i++ {
   *     		key := fmt.Sprintf("test_key_%d", i)
   *     		value := test_value
   *     		kvList[i] = &BatchPutKvRequestKvList{
   *     			Key:   &key,
   *     			Value: &value,
   *     		}
   *     	}
   *     	rawReq := BatchPutKvRequest{
   *     		Namespace: &namespace,
   *     		KvList:    kvList,
   *     	}
   *     	payload, err := json.Marshal(rawReq)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	// If the payload is greater than 2 MB, call the BatchPutKvWithHighCapacity operation for upload.
   *     	reqHighCapacity := BatchPutKvWithHighCapacityAdvanceRequest{
   *     		Namespace: &namespace,
   *     		UrlObject: bytes.NewReader(payload),
   *     	}
   *     	resp, err := cli.BatchPutKvWithHighCapacityAdvance(&reqHighCapacity, runtime)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	return nil
   *     }
   * 
   * @param request - BatchPutKvWithHighCapacityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BatchPutKvWithHighCapacityResponse
   */
  async batchPutKvWithHighCapacityWithOptions(request: BatchPutKvWithHighCapacityRequest, runtime: $dara.RuntimeOptions): Promise<BatchPutKvWithHighCapacityResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!$dara.isNull(request.url)) {
      query["Url"] = request.url;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "BatchPutKvWithHighCapacity",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<BatchPutKvWithHighCapacityResponse>(await this.callApi(params, req, runtime), new BatchPutKvWithHighCapacityResponse({}));
    } else {
      return $dara.cast<BatchPutKvWithHighCapacityResponse>(await this.execute(params, req, runtime), new BatchPutKvWithHighCapacityResponse({}));
    }

  }

  /**
   * Configures key-value pairs for a namespace at a time based on specified keys. The request body can be up to 100 MB.
   * 
   * @remarks
   * This operation allows you to upload a larger request body than by using [BatchPutKv](https://help.aliyun.com/document_detail/2850203.html). For small request bodies, we recommend that you use [BatchPutKv](https://help.aliyun.com/document_detail/2850203.html) to minimize the server processing time. This operation must be called by using SDKs. The following sample code uses the Golang SDK and BatchPutKvWithHighCapacityAdvance to call the operation.
   *     func TestBatchPutKvWithHighCapacity() error {
   *     	// Initialize the configurations.
   *     	cfg := new(openapi.Config)
   *     	cfg.SetAccessKeyId("xxxxxxxxx")
   *     	cfg.SetAccessKeySecret("xxxxxxxxxx")
   *     	cli, err := NewClient(cfg)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	runtime := &util.RuntimeOptions{}
   *     	// Construct a request for uploading key-value pairs at a time.
   *     	namespace := "test_batch_put"
   *     	numKv := 10000
   *     	kvList := make([]*BatchPutKvRequestKvList, numKv)
   *     	test_value := strings.Repeat("a", 10*1024)
   *     	for i := 0; i < numKv; i++ {
   *     		key := fmt.Sprintf("test_key_%d", i)
   *     		value := test_value
   *     		kvList[i] = &BatchPutKvRequestKvList{
   *     			Key:   &key,
   *     			Value: &value,
   *     		}
   *     	}
   *     	rawReq := BatchPutKvRequest{
   *     		Namespace: &namespace,
   *     		KvList:    kvList,
   *     	}
   *     	payload, err := json.Marshal(rawReq)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	// If the payload is greater than 2 MB, call the BatchPutKvWithHighCapacity operation for upload.
   *     	reqHighCapacity := BatchPutKvWithHighCapacityAdvanceRequest{
   *     		Namespace: &namespace,
   *     		UrlObject: bytes.NewReader(payload),
   *     	}
   *     	resp, err := cli.BatchPutKvWithHighCapacityAdvance(&reqHighCapacity, runtime)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	return nil
   *     }
   * 
   * @param request - BatchPutKvWithHighCapacityRequest
   * @returns BatchPutKvWithHighCapacityResponse
   */
  async batchPutKvWithHighCapacity(request: BatchPutKvWithHighCapacityRequest): Promise<BatchPutKvWithHighCapacityResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.batchPutKvWithHighCapacityWithOptions(request, runtime);
  }

  async batchPutKvWithHighCapacityAdvance(request: BatchPutKvWithHighCapacityAdvanceRequest, runtime: $dara.RuntimeOptions): Promise<BatchPutKvWithHighCapacityResponse> {
    // Step 0: init client
    let accessKeyId = await this._credential.getAccessKeyId();
    let accessKeySecret = await this._credential.getAccessKeySecret();
    let securityToken = await this._credential.getSecurityToken();
    let credentialType = this._credential.getType();
    let openPlatformEndpoint = this._openPlatformEndpoint;
    if ($dara.isNull(openPlatformEndpoint)) {
      openPlatformEndpoint = "openplatform.aliyuncs.com";
    }

    if ($dara.isNull(credentialType)) {
      credentialType = "access_key";
    }

    let authConfig = new $OpenApiUtil.Config({
      accessKeyId: accessKeyId,
      accessKeySecret: accessKeySecret,
      securityToken: securityToken,
      type: credentialType,
      endpoint: openPlatformEndpoint,
      protocol: this._protocol,
      regionId: this._regionId,
    });
    let authClient = new OpenPlatform(authConfig);
    let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
      product: "ESA",
      regionId: this._regionId,
    });
    let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({ });
    let ossConfig = new $OSS.Config({
      accessKeyId: accessKeyId,
      accessKeySecret: accessKeySecret,
      type: "access_key",
      protocol: this._protocol,
      regionId: this._regionId,
    });
    let ossClient : OSS = new OSS(ossConfig);
    let fileObj = new $FileForm.FileField({ });
    let ossHeader = new $OSS.PostObjectRequestHeader({ });
    let uploadRequest = new $OSS.PostObjectRequest({ });
    let ossRuntime = new $OSSUtil.RuntimeOptions({ });
    OpenApiUtil.convert(runtime, ossRuntime);
    let batchPutKvWithHighCapacityReq = new BatchPutKvWithHighCapacityRequest({ });
    OpenApiUtil.convert(request, batchPutKvWithHighCapacityReq);
    if (!$dara.isNull(request.urlObject)) {
      authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
      ossConfig.accessKeyId = authResponse.body.accessKeyId;
      ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
      ossClient = new OSS(ossConfig);
      fileObj = new $FileForm.FileField({
        filename: authResponse.body.objectKey,
        content: request.urlObject,
        contentType: "",
      });
      ossHeader = new $OSS.PostObjectRequestHeader({
        accessKeyId: authResponse.body.accessKeyId,
        policy: authResponse.body.encodedPolicy,
        signature: authResponse.body.signature,
        key: authResponse.body.objectKey,
        file: fileObj,
        successActionStatus: "201",
      });
      uploadRequest = new $OSS.PostObjectRequest({
        bucketName: authResponse.body.bucket,
        header: ossHeader,
      });
      await ossClient.postObject(uploadRequest, ossRuntime);
      batchPutKvWithHighCapacityReq.url = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
    }

    let batchPutKvWithHighCapacityResp = await this.batchPutKvWithHighCapacityWithOptions(batchPutKvWithHighCapacityReq, runtime);
    return batchPutKvWithHighCapacityResp;
  }

  /**
   * Blocks URLs.
   * 
   * @param tmpReq - BlockObjectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns BlockObjectResponse
   */
  async blockObjectWithOptions(tmpReq: BlockObjectRequest, runtime: $dara.RuntimeOptions): Promise<BlockObjectResponse> {
    tmpReq.validate();
    let request = new BlockObjectShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.content)) {
      request.contentShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.content, "Content", "json");
    }

    let query = { };
    if (!$dara.isNull(request.contentShrink)) {
      query["Content"] = request.contentShrink;
    }

    if (!$dara.isNull(request.extension)) {
      query["Extension"] = request.extension;
    }

    if (!$dara.isNull(request.maxage)) {
      query["Maxage"] = request.maxage;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "BlockObject",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<BlockObjectResponse>(await this.callApi(params, req, runtime), new BlockObjectResponse({}));
    } else {
      return $dara.cast<BlockObjectResponse>(await this.execute(params, req, runtime), new BlockObjectResponse({}));
    }

  }

  /**
   * Blocks URLs.
   * 
   * @param request - BlockObjectRequest
   * @returns BlockObjectResponse
   */
  async blockObject(request: BlockObjectRequest): Promise<BlockObjectResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.blockObjectWithOptions(request, runtime);
  }

  /**
   * slr
   * 
   * @param request - CheckAssumeSlrRoleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CheckAssumeSlrRoleResponse
   */
  async checkAssumeSlrRoleWithOptions(runtime: $dara.RuntimeOptions): Promise<CheckAssumeSlrRoleResponse> {
    let req = new $OpenApiUtil.OpenApiRequest({ });
    let params = new $OpenApiUtil.Params({
      action: "CheckAssumeSlrRole",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CheckAssumeSlrRoleResponse>(await this.callApi(params, req, runtime), new CheckAssumeSlrRoleResponse({}));
    } else {
      return $dara.cast<CheckAssumeSlrRoleResponse>(await this.execute(params, req, runtime), new CheckAssumeSlrRoleResponse({}));
    }

  }

  /**
   * slr
   * @returns CheckAssumeSlrRoleResponse
   */
  async checkAssumeSlrRole(): Promise<CheckAssumeSlrRoleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.checkAssumeSlrRoleWithOptions(runtime);
  }

  /**
   * Checks whether a specified website name is available.
   * 
   * @param request - CheckSiteNameRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CheckSiteNameResponse
   */
  async checkSiteNameWithOptions(request: CheckSiteNameRequest, runtime: $dara.RuntimeOptions): Promise<CheckSiteNameResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.siteName)) {
      query["SiteName"] = request.siteName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CheckSiteName",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CheckSiteNameResponse>(await this.callApi(params, req, runtime), new CheckSiteNameResponse({}));
    } else {
      return $dara.cast<CheckSiteNameResponse>(await this.execute(params, req, runtime), new CheckSiteNameResponse({}));
    }

  }

  /**
   * Checks whether a specified website name is available.
   * 
   * @param request - CheckSiteNameRequest
   * @returns CheckSiteNameResponse
   */
  async checkSiteName(request: CheckSiteNameRequest): Promise<CheckSiteNameResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.checkSiteNameWithOptions(request, runtime);
  }

  /**
   * Checks the name of a real-time log delivery task.
   * 
   * @param request - CheckSiteProjectNameRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CheckSiteProjectNameResponse
   */
  async checkSiteProjectNameWithOptions(request: CheckSiteProjectNameRequest, runtime: $dara.RuntimeOptions): Promise<CheckSiteProjectNameResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CheckSiteProjectName",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CheckSiteProjectNameResponse>(await this.callApi(params, req, runtime), new CheckSiteProjectNameResponse({}));
    } else {
      return $dara.cast<CheckSiteProjectNameResponse>(await this.execute(params, req, runtime), new CheckSiteProjectNameResponse({}));
    }

  }

  /**
   * Checks the name of a real-time log delivery task.
   * 
   * @param request - CheckSiteProjectNameRequest
   * @returns CheckSiteProjectNameResponse
   */
  async checkSiteProjectName(request: CheckSiteProjectNameRequest): Promise<CheckSiteProjectNameResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.checkSiteProjectNameWithOptions(request, runtime);
  }

  /**
   * Checks the name of a real-time log delivery task by account.
   * 
   * @param request - CheckUserProjectNameRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CheckUserProjectNameResponse
   */
  async checkUserProjectNameWithOptions(request: CheckUserProjectNameRequest, runtime: $dara.RuntimeOptions): Promise<CheckUserProjectNameResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CheckUserProjectName",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CheckUserProjectNameResponse>(await this.callApi(params, req, runtime), new CheckUserProjectNameResponse({}));
    } else {
      return $dara.cast<CheckUserProjectNameResponse>(await this.execute(params, req, runtime), new CheckUserProjectNameResponse({}));
    }

  }

  /**
   * Checks the name of a real-time log delivery task by account.
   * 
   * @param request - CheckUserProjectNameRequest
   * @returns CheckUserProjectNameResponse
   */
  async checkUserProjectName(request: CheckUserProjectNameRequest): Promise<CheckUserProjectNameResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.checkUserProjectNameWithOptions(request, runtime);
  }

  /**
   * Commits the unstable code in the staging environment to generate an official code version.
   * 
   * @param request - CommitRoutineStagingCodeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CommitRoutineStagingCodeResponse
   */
  async commitRoutineStagingCodeWithOptions(request: CommitRoutineStagingCodeRequest, runtime: $dara.RuntimeOptions): Promise<CommitRoutineStagingCodeResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.codeDescription)) {
      body["CodeDescription"] = request.codeDescription;
    }

    if (!$dara.isNull(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CommitRoutineStagingCode",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CommitRoutineStagingCodeResponse>(await this.callApi(params, req, runtime), new CommitRoutineStagingCodeResponse({}));
    } else {
      return $dara.cast<CommitRoutineStagingCodeResponse>(await this.execute(params, req, runtime), new CommitRoutineStagingCodeResponse({}));
    }

  }

  /**
   * Commits the unstable code in the staging environment to generate an official code version.
   * 
   * @param request - CommitRoutineStagingCodeRequest
   * @returns CommitRoutineStagingCodeResponse
   */
  async commitRoutineStagingCode(request: CommitRoutineStagingCodeRequest): Promise<CommitRoutineStagingCodeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.commitRoutineStagingCodeWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - CreateCacheRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateCacheRuleResponse
   */
  async createCacheRuleWithOptions(request: CreateCacheRuleRequest, runtime: $dara.RuntimeOptions): Promise<CreateCacheRuleResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.additionalCacheablePorts)) {
      query["AdditionalCacheablePorts"] = request.additionalCacheablePorts;
    }

    if (!$dara.isNull(request.browserCacheMode)) {
      query["BrowserCacheMode"] = request.browserCacheMode;
    }

    if (!$dara.isNull(request.browserCacheTtl)) {
      query["BrowserCacheTtl"] = request.browserCacheTtl;
    }

    if (!$dara.isNull(request.bypassCache)) {
      query["BypassCache"] = request.bypassCache;
    }

    if (!$dara.isNull(request.cacheDeceptionArmor)) {
      query["CacheDeceptionArmor"] = request.cacheDeceptionArmor;
    }

    if (!$dara.isNull(request.cacheReserveEligibility)) {
      query["CacheReserveEligibility"] = request.cacheReserveEligibility;
    }

    if (!$dara.isNull(request.checkPresenceCookie)) {
      query["CheckPresenceCookie"] = request.checkPresenceCookie;
    }

    if (!$dara.isNull(request.checkPresenceHeader)) {
      query["CheckPresenceHeader"] = request.checkPresenceHeader;
    }

    if (!$dara.isNull(request.edgeCacheMode)) {
      query["EdgeCacheMode"] = request.edgeCacheMode;
    }

    if (!$dara.isNull(request.edgeCacheTtl)) {
      query["EdgeCacheTtl"] = request.edgeCacheTtl;
    }

    if (!$dara.isNull(request.edgeStatusCodeCacheTtl)) {
      query["EdgeStatusCodeCacheTtl"] = request.edgeStatusCodeCacheTtl;
    }

    if (!$dara.isNull(request.includeCookie)) {
      query["IncludeCookie"] = request.includeCookie;
    }

    if (!$dara.isNull(request.includeHeader)) {
      query["IncludeHeader"] = request.includeHeader;
    }

    if (!$dara.isNull(request.queryString)) {
      query["QueryString"] = request.queryString;
    }

    if (!$dara.isNull(request.queryStringMode)) {
      query["QueryStringMode"] = request.queryStringMode;
    }

    if (!$dara.isNull(request.rule)) {
      query["Rule"] = request.rule;
    }

    if (!$dara.isNull(request.ruleEnable)) {
      query["RuleEnable"] = request.ruleEnable;
    }

    if (!$dara.isNull(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!$dara.isNull(request.serveStale)) {
      query["ServeStale"] = request.serveStale;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    if (!$dara.isNull(request.sortQueryStringForCache)) {
      query["SortQueryStringForCache"] = request.sortQueryStringForCache;
    }

    if (!$dara.isNull(request.userDeviceType)) {
      query["UserDeviceType"] = request.userDeviceType;
    }

    if (!$dara.isNull(request.userGeo)) {
      query["UserGeo"] = request.userGeo;
    }

    if (!$dara.isNull(request.userLanguage)) {
      query["UserLanguage"] = request.userLanguage;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateCacheRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateCacheRuleResponse>(await this.callApi(params, req, runtime), new CreateCacheRuleResponse({}));
    } else {
      return $dara.cast<CreateCacheRuleResponse>(await this.execute(params, req, runtime), new CreateCacheRuleResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - CreateCacheRuleRequest
   * @returns CreateCacheRuleResponse
   */
  async createCacheRule(request: CreateCacheRuleRequest): Promise<CreateCacheRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createCacheRuleWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - CreateClientCertificateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateClientCertificateResponse
   */
  async createClientCertificateWithOptions(request: CreateClientCertificateRequest, runtime: $dara.RuntimeOptions): Promise<CreateClientCertificateResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.CSR)) {
      body["CSR"] = request.CSR;
    }

    if (!$dara.isNull(request.pkeyType)) {
      body["PkeyType"] = request.pkeyType;
    }

    if (!$dara.isNull(request.validityDays)) {
      body["ValidityDays"] = request.validityDays;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateClientCertificate",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateClientCertificateResponse>(await this.callApi(params, req, runtime), new CreateClientCertificateResponse({}));
    } else {
      return $dara.cast<CreateClientCertificateResponse>(await this.execute(params, req, runtime), new CreateClientCertificateResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - CreateClientCertificateRequest
   * @returns CreateClientCertificateResponse
   */
  async createClientCertificate(request: CreateClientCertificateRequest): Promise<CreateClientCertificateResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createClientCertificateWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - CreateCompressionRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateCompressionRuleResponse
   */
  async createCompressionRuleWithOptions(request: CreateCompressionRuleRequest, runtime: $dara.RuntimeOptions): Promise<CreateCompressionRuleResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.brotli)) {
      query["Brotli"] = request.brotli;
    }

    if (!$dara.isNull(request.gzip)) {
      query["Gzip"] = request.gzip;
    }

    if (!$dara.isNull(request.rule)) {
      query["Rule"] = request.rule;
    }

    if (!$dara.isNull(request.ruleEnable)) {
      query["RuleEnable"] = request.ruleEnable;
    }

    if (!$dara.isNull(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    if (!$dara.isNull(request.zstd)) {
      query["Zstd"] = request.zstd;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateCompressionRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateCompressionRuleResponse>(await this.callApi(params, req, runtime), new CreateCompressionRuleResponse({}));
    } else {
      return $dara.cast<CreateCompressionRuleResponse>(await this.execute(params, req, runtime), new CreateCompressionRuleResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - CreateCompressionRuleRequest
   * @returns CreateCompressionRuleResponse
   */
  async createCompressionRule(request: CreateCompressionRuleRequest): Promise<CreateCompressionRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createCompressionRuleWithOptions(request, runtime);
  }

  /**
   * Creates an account-level custom scenario policy. You can execute a policy after you associate the policy with a website.
   * 
   * @param request - CreateCustomScenePolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateCustomScenePolicyResponse
   */
  async createCustomScenePolicyWithOptions(request: CreateCustomScenePolicyRequest, runtime: $dara.RuntimeOptions): Promise<CreateCustomScenePolicyResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.objects)) {
      query["Objects"] = request.objects;
    }

    if (!$dara.isNull(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!$dara.isNull(request.template)) {
      query["Template"] = request.template;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateCustomScenePolicy",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateCustomScenePolicyResponse>(await this.callApi(params, req, runtime), new CreateCustomScenePolicyResponse({}));
    } else {
      return $dara.cast<CreateCustomScenePolicyResponse>(await this.execute(params, req, runtime), new CreateCustomScenePolicyResponse({}));
    }

  }

  /**
   * Creates an account-level custom scenario policy. You can execute a policy after you associate the policy with a website.
   * 
   * @param request - CreateCustomScenePolicyRequest
   * @returns CreateCustomScenePolicyResponse
   */
  async createCustomScenePolicy(request: CreateCustomScenePolicyRequest): Promise<CreateCustomScenePolicyResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createCustomScenePolicyWithOptions(request, runtime);
  }

  /**
   * Creates a containerized application. You can deploy and release a version of the application across points of presence (POPs).
   * 
   * @param request - CreateEdgeContainerAppRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateEdgeContainerAppResponse
   */
  async createEdgeContainerAppWithOptions(request: CreateEdgeContainerAppRequest, runtime: $dara.RuntimeOptions): Promise<CreateEdgeContainerAppResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.healthCheckFailTimes)) {
      body["HealthCheckFailTimes"] = request.healthCheckFailTimes;
    }

    if (!$dara.isNull(request.healthCheckHost)) {
      body["HealthCheckHost"] = request.healthCheckHost;
    }

    if (!$dara.isNull(request.healthCheckHttpCode)) {
      body["HealthCheckHttpCode"] = request.healthCheckHttpCode;
    }

    if (!$dara.isNull(request.healthCheckInterval)) {
      body["HealthCheckInterval"] = request.healthCheckInterval;
    }

    if (!$dara.isNull(request.healthCheckMethod)) {
      body["HealthCheckMethod"] = request.healthCheckMethod;
    }

    if (!$dara.isNull(request.healthCheckPort)) {
      body["HealthCheckPort"] = request.healthCheckPort;
    }

    if (!$dara.isNull(request.healthCheckSuccTimes)) {
      body["HealthCheckSuccTimes"] = request.healthCheckSuccTimes;
    }

    if (!$dara.isNull(request.healthCheckTimeout)) {
      body["HealthCheckTimeout"] = request.healthCheckTimeout;
    }

    if (!$dara.isNull(request.healthCheckType)) {
      body["HealthCheckType"] = request.healthCheckType;
    }

    if (!$dara.isNull(request.healthCheckURI)) {
      body["HealthCheckURI"] = request.healthCheckURI;
    }

    if (!$dara.isNull(request.name)) {
      body["Name"] = request.name;
    }

    if (!$dara.isNull(request.remarks)) {
      body["Remarks"] = request.remarks;
    }

    if (!$dara.isNull(request.servicePort)) {
      body["ServicePort"] = request.servicePort;
    }

    if (!$dara.isNull(request.targetPort)) {
      body["TargetPort"] = request.targetPort;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateEdgeContainerApp",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateEdgeContainerAppResponse>(await this.callApi(params, req, runtime), new CreateEdgeContainerAppResponse({}));
    } else {
      return $dara.cast<CreateEdgeContainerAppResponse>(await this.execute(params, req, runtime), new CreateEdgeContainerAppResponse({}));
    }

  }

  /**
   * Creates a containerized application. You can deploy and release a version of the application across points of presence (POPs).
   * 
   * @param request - CreateEdgeContainerAppRequest
   * @returns CreateEdgeContainerAppResponse
   */
  async createEdgeContainerApp(request: CreateEdgeContainerAppRequest): Promise<CreateEdgeContainerAppResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createEdgeContainerAppWithOptions(request, runtime);
  }

  /**
   * Associates a domain name with a containerized application. This way, requests destined for the associated domain name are forwarded to the application.
   * 
   * @param request - CreateEdgeContainerAppRecordRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateEdgeContainerAppRecordResponse
   */
  async createEdgeContainerAppRecordWithOptions(request: CreateEdgeContainerAppRecordRequest, runtime: $dara.RuntimeOptions): Promise<CreateEdgeContainerAppRecordResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!$dara.isNull(request.recordName)) {
      body["RecordName"] = request.recordName;
    }

    if (!$dara.isNull(request.siteId)) {
      body["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateEdgeContainerAppRecord",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateEdgeContainerAppRecordResponse>(await this.callApi(params, req, runtime), new CreateEdgeContainerAppRecordResponse({}));
    } else {
      return $dara.cast<CreateEdgeContainerAppRecordResponse>(await this.execute(params, req, runtime), new CreateEdgeContainerAppRecordResponse({}));
    }

  }

  /**
   * Associates a domain name with a containerized application. This way, requests destined for the associated domain name are forwarded to the application.
   * 
   * @param request - CreateEdgeContainerAppRecordRequest
   * @returns CreateEdgeContainerAppRecordResponse
   */
  async createEdgeContainerAppRecord(request: CreateEdgeContainerAppRecordRequest): Promise<CreateEdgeContainerAppRecordResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createEdgeContainerAppRecordWithOptions(request, runtime);
  }

  /**
   * Creates a version for a containerized application. You can iterate the application based on the version.
   * 
   * @param tmpReq - CreateEdgeContainerAppVersionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateEdgeContainerAppVersionResponse
   */
  async createEdgeContainerAppVersionWithOptions(tmpReq: CreateEdgeContainerAppVersionRequest, runtime: $dara.RuntimeOptions): Promise<CreateEdgeContainerAppVersionResponse> {
    tmpReq.validate();
    let request = new CreateEdgeContainerAppVersionShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.containers)) {
      request.containersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.containers, "Containers", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!$dara.isNull(request.containersShrink)) {
      body["Containers"] = request.containersShrink;
    }

    if (!$dara.isNull(request.name)) {
      body["Name"] = request.name;
    }

    if (!$dara.isNull(request.remarks)) {
      body["Remarks"] = request.remarks;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateEdgeContainerAppVersion",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateEdgeContainerAppVersionResponse>(await this.callApi(params, req, runtime), new CreateEdgeContainerAppVersionResponse({}));
    } else {
      return $dara.cast<CreateEdgeContainerAppVersionResponse>(await this.execute(params, req, runtime), new CreateEdgeContainerAppVersionResponse({}));
    }

  }

  /**
   * Creates a version for a containerized application. You can iterate the application based on the version.
   * 
   * @param request - CreateEdgeContainerAppVersionRequest
   * @returns CreateEdgeContainerAppVersionResponse
   */
  async createEdgeContainerAppVersion(request: CreateEdgeContainerAppVersionRequest): Promise<CreateEdgeContainerAppVersionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createEdgeContainerAppVersionWithOptions(request, runtime);
  }

  /**
   * HTTP
   * 
   * @param tmpReq - CreateHttpRequestHeaderModificationRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateHttpRequestHeaderModificationRuleResponse
   */
  async createHttpRequestHeaderModificationRuleWithOptions(tmpReq: CreateHttpRequestHeaderModificationRuleRequest, runtime: $dara.RuntimeOptions): Promise<CreateHttpRequestHeaderModificationRuleResponse> {
    tmpReq.validate();
    let request = new CreateHttpRequestHeaderModificationRuleShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.requestHeaderModification)) {
      request.requestHeaderModificationShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.requestHeaderModification, "RequestHeaderModification", "json");
    }

    let query = { };
    if (!$dara.isNull(request.requestHeaderModificationShrink)) {
      query["RequestHeaderModification"] = request.requestHeaderModificationShrink;
    }

    if (!$dara.isNull(request.rule)) {
      query["Rule"] = request.rule;
    }

    if (!$dara.isNull(request.ruleEnable)) {
      query["RuleEnable"] = request.ruleEnable;
    }

    if (!$dara.isNull(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateHttpRequestHeaderModificationRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateHttpRequestHeaderModificationRuleResponse>(await this.callApi(params, req, runtime), new CreateHttpRequestHeaderModificationRuleResponse({}));
    } else {
      return $dara.cast<CreateHttpRequestHeaderModificationRuleResponse>(await this.execute(params, req, runtime), new CreateHttpRequestHeaderModificationRuleResponse({}));
    }

  }

  /**
   * HTTP
   * 
   * @param request - CreateHttpRequestHeaderModificationRuleRequest
   * @returns CreateHttpRequestHeaderModificationRuleResponse
   */
  async createHttpRequestHeaderModificationRule(request: CreateHttpRequestHeaderModificationRuleRequest): Promise<CreateHttpRequestHeaderModificationRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createHttpRequestHeaderModificationRuleWithOptions(request, runtime);
  }

  /**
   * HTTP
   * 
   * @param tmpReq - CreateHttpResponseHeaderModificationRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateHttpResponseHeaderModificationRuleResponse
   */
  async createHttpResponseHeaderModificationRuleWithOptions(tmpReq: CreateHttpResponseHeaderModificationRuleRequest, runtime: $dara.RuntimeOptions): Promise<CreateHttpResponseHeaderModificationRuleResponse> {
    tmpReq.validate();
    let request = new CreateHttpResponseHeaderModificationRuleShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.responseHeaderModification)) {
      request.responseHeaderModificationShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.responseHeaderModification, "ResponseHeaderModification", "json");
    }

    let query = { };
    if (!$dara.isNull(request.responseHeaderModificationShrink)) {
      query["ResponseHeaderModification"] = request.responseHeaderModificationShrink;
    }

    if (!$dara.isNull(request.rule)) {
      query["Rule"] = request.rule;
    }

    if (!$dara.isNull(request.ruleEnable)) {
      query["RuleEnable"] = request.ruleEnable;
    }

    if (!$dara.isNull(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateHttpResponseHeaderModificationRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateHttpResponseHeaderModificationRuleResponse>(await this.callApi(params, req, runtime), new CreateHttpResponseHeaderModificationRuleResponse({}));
    } else {
      return $dara.cast<CreateHttpResponseHeaderModificationRuleResponse>(await this.execute(params, req, runtime), new CreateHttpResponseHeaderModificationRuleResponse({}));
    }

  }

  /**
   * HTTP
   * 
   * @param request - CreateHttpResponseHeaderModificationRuleRequest
   * @returns CreateHttpResponseHeaderModificationRuleResponse
   */
  async createHttpResponseHeaderModificationRule(request: CreateHttpResponseHeaderModificationRuleRequest): Promise<CreateHttpResponseHeaderModificationRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createHttpResponseHeaderModificationRuleWithOptions(request, runtime);
  }

  /**
   * HTTPS
   * 
   * @param request - CreateHttpsApplicationConfigurationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateHttpsApplicationConfigurationResponse
   */
  async createHttpsApplicationConfigurationWithOptions(request: CreateHttpsApplicationConfigurationRequest, runtime: $dara.RuntimeOptions): Promise<CreateHttpsApplicationConfigurationResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.altSvc)) {
      query["AltSvc"] = request.altSvc;
    }

    if (!$dara.isNull(request.altSvcClear)) {
      query["AltSvcClear"] = request.altSvcClear;
    }

    if (!$dara.isNull(request.altSvcMa)) {
      query["AltSvcMa"] = request.altSvcMa;
    }

    if (!$dara.isNull(request.altSvcPersist)) {
      query["AltSvcPersist"] = request.altSvcPersist;
    }

    if (!$dara.isNull(request.hsts)) {
      query["Hsts"] = request.hsts;
    }

    if (!$dara.isNull(request.hstsIncludeSubdomains)) {
      query["HstsIncludeSubdomains"] = request.hstsIncludeSubdomains;
    }

    if (!$dara.isNull(request.hstsMaxAge)) {
      query["HstsMaxAge"] = request.hstsMaxAge;
    }

    if (!$dara.isNull(request.hstsPreload)) {
      query["HstsPreload"] = request.hstsPreload;
    }

    if (!$dara.isNull(request.httpsForce)) {
      query["HttpsForce"] = request.httpsForce;
    }

    if (!$dara.isNull(request.httpsForceCode)) {
      query["HttpsForceCode"] = request.httpsForceCode;
    }

    if (!$dara.isNull(request.rule)) {
      query["Rule"] = request.rule;
    }

    if (!$dara.isNull(request.ruleEnable)) {
      query["RuleEnable"] = request.ruleEnable;
    }

    if (!$dara.isNull(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateHttpsApplicationConfiguration",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateHttpsApplicationConfigurationResponse>(await this.callApi(params, req, runtime), new CreateHttpsApplicationConfigurationResponse({}));
    } else {
      return $dara.cast<CreateHttpsApplicationConfigurationResponse>(await this.execute(params, req, runtime), new CreateHttpsApplicationConfigurationResponse({}));
    }

  }

  /**
   * HTTPS
   * 
   * @param request - CreateHttpsApplicationConfigurationRequest
   * @returns CreateHttpsApplicationConfigurationResponse
   */
  async createHttpsApplicationConfiguration(request: CreateHttpsApplicationConfigurationRequest): Promise<CreateHttpsApplicationConfigurationResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createHttpsApplicationConfigurationWithOptions(request, runtime);
  }

  /**
   * HTTPS
   * 
   * @param request - CreateHttpsBasicConfigurationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateHttpsBasicConfigurationResponse
   */
  async createHttpsBasicConfigurationWithOptions(request: CreateHttpsBasicConfigurationRequest, runtime: $dara.RuntimeOptions): Promise<CreateHttpsBasicConfigurationResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ciphersuite)) {
      query["Ciphersuite"] = request.ciphersuite;
    }

    if (!$dara.isNull(request.ciphersuiteGroup)) {
      query["CiphersuiteGroup"] = request.ciphersuiteGroup;
    }

    if (!$dara.isNull(request.http2)) {
      query["Http2"] = request.http2;
    }

    if (!$dara.isNull(request.http3)) {
      query["Http3"] = request.http3;
    }

    if (!$dara.isNull(request.https)) {
      query["Https"] = request.https;
    }

    if (!$dara.isNull(request.ocspStapling)) {
      query["OcspStapling"] = request.ocspStapling;
    }

    if (!$dara.isNull(request.rule)) {
      query["Rule"] = request.rule;
    }

    if (!$dara.isNull(request.ruleEnable)) {
      query["RuleEnable"] = request.ruleEnable;
    }

    if (!$dara.isNull(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.tls10)) {
      query["Tls10"] = request.tls10;
    }

    if (!$dara.isNull(request.tls11)) {
      query["Tls11"] = request.tls11;
    }

    if (!$dara.isNull(request.tls12)) {
      query["Tls12"] = request.tls12;
    }

    if (!$dara.isNull(request.tls13)) {
      query["Tls13"] = request.tls13;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateHttpsBasicConfiguration",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateHttpsBasicConfigurationResponse>(await this.callApi(params, req, runtime), new CreateHttpsBasicConfigurationResponse({}));
    } else {
      return $dara.cast<CreateHttpsBasicConfigurationResponse>(await this.execute(params, req, runtime), new CreateHttpsBasicConfigurationResponse({}));
    }

  }

  /**
   * HTTPS
   * 
   * @param request - CreateHttpsBasicConfigurationRequest
   * @returns CreateHttpsBasicConfigurationResponse
   */
  async createHttpsBasicConfiguration(request: CreateHttpsBasicConfigurationRequest): Promise<CreateHttpsBasicConfigurationResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createHttpsBasicConfigurationWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - CreateImageTransformRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateImageTransformResponse
   */
  async createImageTransformWithOptions(request: CreateImageTransformRequest, runtime: $dara.RuntimeOptions): Promise<CreateImageTransformResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!$dara.isNull(request.rule)) {
      query["Rule"] = request.rule;
    }

    if (!$dara.isNull(request.ruleEnable)) {
      query["RuleEnable"] = request.ruleEnable;
    }

    if (!$dara.isNull(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateImageTransform",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateImageTransformResponse>(await this.callApi(params, req, runtime), new CreateImageTransformResponse({}));
    } else {
      return $dara.cast<CreateImageTransformResponse>(await this.execute(params, req, runtime), new CreateImageTransformResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - CreateImageTransformRequest
   * @returns CreateImageTransformResponse
   */
  async createImageTransform(request: CreateImageTransformRequest): Promise<CreateImageTransformResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createImageTransformWithOptions(request, runtime);
  }

  /**
   * Create a namespace in your Alibaba Cloud account.
   * 
   * @param request - CreateKvNamespaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateKvNamespaceResponse
   */
  async createKvNamespaceWithOptions(request: CreateKvNamespaceRequest, runtime: $dara.RuntimeOptions): Promise<CreateKvNamespaceResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.description)) {
      body["Description"] = request.description;
    }

    if (!$dara.isNull(request.namespace)) {
      body["Namespace"] = request.namespace;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateKvNamespace",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateKvNamespaceResponse>(await this.callApi(params, req, runtime), new CreateKvNamespaceResponse({}));
    } else {
      return $dara.cast<CreateKvNamespaceResponse>(await this.execute(params, req, runtime), new CreateKvNamespaceResponse({}));
    }

  }

  /**
   * Create a namespace in your Alibaba Cloud account.
   * 
   * @param request - CreateKvNamespaceRequest
   * @returns CreateKvNamespaceResponse
   */
  async createKvNamespace(request: CreateKvNamespaceRequest): Promise<CreateKvNamespaceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createKvNamespaceWithOptions(request, runtime);
  }

  /**
   * Creates a list. Lists are used for the referencing of values in the rules engine to implement complex logic and control in security policies.
   * 
   * @param tmpReq - CreateListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateListResponse
   */
  async createListWithOptions(tmpReq: CreateListRequest, runtime: $dara.RuntimeOptions): Promise<CreateListResponse> {
    tmpReq.validate();
    let request = new CreateListShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.items)) {
      request.itemsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.items, "Items", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.description)) {
      body["Description"] = request.description;
    }

    if (!$dara.isNull(request.itemsShrink)) {
      body["Items"] = request.itemsShrink;
    }

    if (!$dara.isNull(request.kind)) {
      body["Kind"] = request.kind;
    }

    if (!$dara.isNull(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateList",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateListResponse>(await this.callApi(params, req, runtime), new CreateListResponse({}));
    } else {
      return $dara.cast<CreateListResponse>(await this.execute(params, req, runtime), new CreateListResponse({}));
    }

  }

  /**
   * Creates a list. Lists are used for the referencing of values in the rules engine to implement complex logic and control in security policies.
   * 
   * @param request - CreateListRequest
   * @returns CreateListResponse
   */
  async createList(request: CreateListRequest): Promise<CreateListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createListWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param tmpReq - CreateLoadBalancerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateLoadBalancerResponse
   */
  async createLoadBalancerWithOptions(tmpReq: CreateLoadBalancerRequest, runtime: $dara.RuntimeOptions): Promise<CreateLoadBalancerResponse> {
    tmpReq.validate();
    let request = new CreateLoadBalancerShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.adaptiveRouting)) {
      request.adaptiveRoutingShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.adaptiveRouting, "AdaptiveRouting", "json");
    }

    if (!$dara.isNull(tmpReq.defaultPools)) {
      request.defaultPoolsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.defaultPools, "DefaultPools", "json");
    }

    if (!$dara.isNull(tmpReq.monitor)) {
      request.monitorShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.monitor, "Monitor", "json");
    }

    if (!$dara.isNull(tmpReq.randomSteering)) {
      request.randomSteeringShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.randomSteering, "RandomSteering", "json");
    }

    if (!$dara.isNull(tmpReq.rules)) {
      request.rulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.rules, "Rules", "json");
    }

    let query = { };
    if (!$dara.isNull(request.adaptiveRoutingShrink)) {
      query["AdaptiveRouting"] = request.adaptiveRoutingShrink;
    }

    if (!$dara.isNull(request.defaultPoolsShrink)) {
      query["DefaultPools"] = request.defaultPoolsShrink;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.enabled)) {
      query["Enabled"] = request.enabled;
    }

    if (!$dara.isNull(request.fallbackPool)) {
      query["FallbackPool"] = request.fallbackPool;
    }

    if (!$dara.isNull(request.monitorShrink)) {
      query["Monitor"] = request.monitorShrink;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.randomSteeringShrink)) {
      query["RandomSteering"] = request.randomSteeringShrink;
    }

    if (!$dara.isNull(request.regionPools)) {
      query["RegionPools"] = request.regionPools;
    }

    if (!$dara.isNull(request.rulesShrink)) {
      query["Rules"] = request.rulesShrink;
    }

    if (!$dara.isNull(request.sessionAffinity)) {
      query["SessionAffinity"] = request.sessionAffinity;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.steeringPolicy)) {
      query["SteeringPolicy"] = request.steeringPolicy;
    }

    if (!$dara.isNull(request.subRegionPools)) {
      query["SubRegionPools"] = request.subRegionPools;
    }

    if (!$dara.isNull(request.ttl)) {
      query["Ttl"] = request.ttl;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateLoadBalancer",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateLoadBalancerResponse>(await this.callApi(params, req, runtime), new CreateLoadBalancerResponse({}));
    } else {
      return $dara.cast<CreateLoadBalancerResponse>(await this.execute(params, req, runtime), new CreateLoadBalancerResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - CreateLoadBalancerRequest
   * @returns CreateLoadBalancerResponse
   */
  async createLoadBalancer(request: CreateLoadBalancerRequest): Promise<CreateLoadBalancerResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createLoadBalancerWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - CreateNetworkOptimizationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateNetworkOptimizationResponse
   */
  async createNetworkOptimizationWithOptions(request: CreateNetworkOptimizationRequest, runtime: $dara.RuntimeOptions): Promise<CreateNetworkOptimizationResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.grpc)) {
      query["Grpc"] = request.grpc;
    }

    if (!$dara.isNull(request.http2Origin)) {
      query["Http2Origin"] = request.http2Origin;
    }

    if (!$dara.isNull(request.rule)) {
      query["Rule"] = request.rule;
    }

    if (!$dara.isNull(request.ruleEnable)) {
      query["RuleEnable"] = request.ruleEnable;
    }

    if (!$dara.isNull(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    if (!$dara.isNull(request.smartRouting)) {
      query["SmartRouting"] = request.smartRouting;
    }

    if (!$dara.isNull(request.uploadMaxFilesize)) {
      query["UploadMaxFilesize"] = request.uploadMaxFilesize;
    }

    if (!$dara.isNull(request.websocket)) {
      query["Websocket"] = request.websocket;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateNetworkOptimization",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateNetworkOptimizationResponse>(await this.callApi(params, req, runtime), new CreateNetworkOptimizationResponse({}));
    } else {
      return $dara.cast<CreateNetworkOptimizationResponse>(await this.execute(params, req, runtime), new CreateNetworkOptimizationResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - CreateNetworkOptimizationRequest
   * @returns CreateNetworkOptimizationResponse
   */
  async createNetworkOptimization(request: CreateNetworkOptimizationRequest): Promise<CreateNetworkOptimizationResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createNetworkOptimizationWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param tmpReq - CreateOriginPoolRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateOriginPoolResponse
   */
  async createOriginPoolWithOptions(tmpReq: CreateOriginPoolRequest, runtime: $dara.RuntimeOptions): Promise<CreateOriginPoolResponse> {
    tmpReq.validate();
    let request = new CreateOriginPoolShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.origins)) {
      request.originsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.origins, "Origins", "json");
    }

    let query = { };
    if (!$dara.isNull(request.enabled)) {
      query["Enabled"] = request.enabled;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.originsShrink)) {
      query["Origins"] = request.originsShrink;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateOriginPool",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateOriginPoolResponse>(await this.callApi(params, req, runtime), new CreateOriginPoolResponse({}));
    } else {
      return $dara.cast<CreateOriginPoolResponse>(await this.execute(params, req, runtime), new CreateOriginPoolResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - CreateOriginPoolRequest
   * @returns CreateOriginPoolResponse
   */
  async createOriginPool(request: CreateOriginPoolRequest): Promise<CreateOriginPoolResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createOriginPoolWithOptions(request, runtime);
  }

  /**
   * Enables origin protection.
   * 
   * @param request - CreateOriginProtectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateOriginProtectionResponse
   */
  async createOriginProtectionWithOptions(request: CreateOriginProtectionRequest, runtime: $dara.RuntimeOptions): Promise<CreateOriginProtectionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateOriginProtection",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateOriginProtectionResponse>(await this.callApi(params, req, runtime), new CreateOriginProtectionResponse({}));
    } else {
      return $dara.cast<CreateOriginProtectionResponse>(await this.execute(params, req, runtime), new CreateOriginProtectionResponse({}));
    }

  }

  /**
   * Enables origin protection.
   * 
   * @param request - CreateOriginProtectionRequest
   * @returns CreateOriginProtectionResponse
   */
  async createOriginProtection(request: CreateOriginProtectionRequest): Promise<CreateOriginProtectionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createOriginProtectionWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - CreateOriginRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateOriginRuleResponse
   */
  async createOriginRuleWithOptions(request: CreateOriginRuleRequest, runtime: $dara.RuntimeOptions): Promise<CreateOriginRuleResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.dnsRecord)) {
      query["DnsRecord"] = request.dnsRecord;
    }

    if (!$dara.isNull(request.originHost)) {
      query["OriginHost"] = request.originHost;
    }

    if (!$dara.isNull(request.originHttpPort)) {
      query["OriginHttpPort"] = request.originHttpPort;
    }

    if (!$dara.isNull(request.originHttpsPort)) {
      query["OriginHttpsPort"] = request.originHttpsPort;
    }

    if (!$dara.isNull(request.originScheme)) {
      query["OriginScheme"] = request.originScheme;
    }

    if (!$dara.isNull(request.originSni)) {
      query["OriginSni"] = request.originSni;
    }

    if (!$dara.isNull(request.range)) {
      query["Range"] = request.range;
    }

    if (!$dara.isNull(request.rule)) {
      query["Rule"] = request.rule;
    }

    if (!$dara.isNull(request.ruleEnable)) {
      query["RuleEnable"] = request.ruleEnable;
    }

    if (!$dara.isNull(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateOriginRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateOriginRuleResponse>(await this.callApi(params, req, runtime), new CreateOriginRuleResponse({}));
    } else {
      return $dara.cast<CreateOriginRuleResponse>(await this.execute(params, req, runtime), new CreateOriginRuleResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - CreateOriginRuleRequest
   * @returns CreateOriginRuleResponse
   */
  async createOriginRule(request: CreateOriginRuleRequest): Promise<CreateOriginRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createOriginRuleWithOptions(request, runtime);
  }

  /**
   * Creates a custom error page, which is displayed when a request is blocked by Web Application Firewall (WAF). You can configure the HTML content, page type, and description, and submit the Base64-encoded page content.
   * 
   * @param request - CreatePageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreatePageResponse
   */
  async createPageWithOptions(request: CreatePageRequest, runtime: $dara.RuntimeOptions): Promise<CreatePageResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.content)) {
      body["Content"] = request.content;
    }

    if (!$dara.isNull(request.contentType)) {
      body["ContentType"] = request.contentType;
    }

    if (!$dara.isNull(request.description)) {
      body["Description"] = request.description;
    }

    if (!$dara.isNull(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreatePage",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreatePageResponse>(await this.callApi(params, req, runtime), new CreatePageResponse({}));
    } else {
      return $dara.cast<CreatePageResponse>(await this.execute(params, req, runtime), new CreatePageResponse({}));
    }

  }

  /**
   * Creates a custom error page, which is displayed when a request is blocked by Web Application Firewall (WAF). You can configure the HTML content, page type, and description, and submit the Base64-encoded page content.
   * 
   * @param request - CreatePageRequest
   * @returns CreatePageResponse
   */
  async createPage(request: CreatePageRequest): Promise<CreatePageResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createPageWithOptions(request, runtime);
  }

  /**
   * Creates a DNS record for a specific website.
   * 
   * @param tmpReq - CreateRecordRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateRecordResponse
   */
  async createRecordWithOptions(tmpReq: CreateRecordRequest, runtime: $dara.RuntimeOptions): Promise<CreateRecordResponse> {
    tmpReq.validate();
    let request = new CreateRecordShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.authConf)) {
      request.authConfShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.authConf, "AuthConf", "json");
    }

    if (!$dara.isNull(tmpReq.data)) {
      request.dataShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.data, "Data", "json");
    }

    let query = { };
    if (!$dara.isNull(request.authConfShrink)) {
      query["AuthConf"] = request.authConfShrink;
    }

    if (!$dara.isNull(request.bizName)) {
      query["BizName"] = request.bizName;
    }

    if (!$dara.isNull(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!$dara.isNull(request.dataShrink)) {
      query["Data"] = request.dataShrink;
    }

    if (!$dara.isNull(request.hostPolicy)) {
      query["HostPolicy"] = request.hostPolicy;
    }

    if (!$dara.isNull(request.proxied)) {
      query["Proxied"] = request.proxied;
    }

    if (!$dara.isNull(request.recordName)) {
      query["RecordName"] = request.recordName;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.sourceType)) {
      query["SourceType"] = request.sourceType;
    }

    if (!$dara.isNull(request.ttl)) {
      query["Ttl"] = request.ttl;
    }

    if (!$dara.isNull(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateRecord",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateRecordResponse>(await this.callApi(params, req, runtime), new CreateRecordResponse({}));
    } else {
      return $dara.cast<CreateRecordResponse>(await this.execute(params, req, runtime), new CreateRecordResponse({}));
    }

  }

  /**
   * Creates a DNS record for a specific website.
   * 
   * @param request - CreateRecordRequest
   * @returns CreateRecordResponse
   */
  async createRecord(request: CreateRecordRequest): Promise<CreateRecordResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createRecordWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - CreateRedirectRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateRedirectRuleResponse
   */
  async createRedirectRuleWithOptions(request: CreateRedirectRuleRequest, runtime: $dara.RuntimeOptions): Promise<CreateRedirectRuleResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.reserveQueryString)) {
      query["ReserveQueryString"] = request.reserveQueryString;
    }

    if (!$dara.isNull(request.rule)) {
      query["Rule"] = request.rule;
    }

    if (!$dara.isNull(request.ruleEnable)) {
      query["RuleEnable"] = request.ruleEnable;
    }

    if (!$dara.isNull(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    if (!$dara.isNull(request.statusCode)) {
      query["StatusCode"] = request.statusCode;
    }

    if (!$dara.isNull(request.targetUrl)) {
      query["TargetUrl"] = request.targetUrl;
    }

    if (!$dara.isNull(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateRedirectRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateRedirectRuleResponse>(await this.callApi(params, req, runtime), new CreateRedirectRuleResponse({}));
    } else {
      return $dara.cast<CreateRedirectRuleResponse>(await this.execute(params, req, runtime), new CreateRedirectRuleResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - CreateRedirectRuleRequest
   * @returns CreateRedirectRuleResponse
   */
  async createRedirectRule(request: CreateRedirectRuleRequest): Promise<CreateRedirectRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createRedirectRuleWithOptions(request, runtime);
  }

  /**
   * Url
   * 
   * @param request - CreateRewriteUrlRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateRewriteUrlRuleResponse
   */
  async createRewriteUrlRuleWithOptions(request: CreateRewriteUrlRuleRequest, runtime: $dara.RuntimeOptions): Promise<CreateRewriteUrlRuleResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.queryString)) {
      query["QueryString"] = request.queryString;
    }

    if (!$dara.isNull(request.rewriteQueryStringType)) {
      query["RewriteQueryStringType"] = request.rewriteQueryStringType;
    }

    if (!$dara.isNull(request.rewriteUriType)) {
      query["RewriteUriType"] = request.rewriteUriType;
    }

    if (!$dara.isNull(request.rule)) {
      query["Rule"] = request.rule;
    }

    if (!$dara.isNull(request.ruleEnable)) {
      query["RuleEnable"] = request.ruleEnable;
    }

    if (!$dara.isNull(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    if (!$dara.isNull(request.uri)) {
      query["Uri"] = request.uri;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateRewriteUrlRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateRewriteUrlRuleResponse>(await this.callApi(params, req, runtime), new CreateRewriteUrlRuleResponse({}));
    } else {
      return $dara.cast<CreateRewriteUrlRuleResponse>(await this.execute(params, req, runtime), new CreateRewriteUrlRuleResponse({}));
    }

  }

  /**
   * Url
   * 
   * @param request - CreateRewriteUrlRuleRequest
   * @returns CreateRewriteUrlRuleResponse
   */
  async createRewriteUrlRule(request: CreateRewriteUrlRuleRequest): Promise<CreateRewriteUrlRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createRewriteUrlRuleWithOptions(request, runtime);
  }

  /**
   * Creates a routine.
   * 
   * @param request - CreateRoutineRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateRoutineResponse
   */
  async createRoutineWithOptions(request: CreateRoutineRequest, runtime: $dara.RuntimeOptions): Promise<CreateRoutineResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.description)) {
      body["Description"] = request.description;
    }

    if (!$dara.isNull(request.name)) {
      body["Name"] = request.name;
    }

    if (!$dara.isNull(request.specName)) {
      body["SpecName"] = request.specName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateRoutine",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateRoutineResponse>(await this.callApi(params, req, runtime), new CreateRoutineResponse({}));
    } else {
      return $dara.cast<CreateRoutineResponse>(await this.execute(params, req, runtime), new CreateRoutineResponse({}));
    }

  }

  /**
   * Creates a routine.
   * 
   * @param request - CreateRoutineRequest
   * @returns CreateRoutineResponse
   */
  async createRoutine(request: CreateRoutineRequest): Promise<CreateRoutineResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createRoutineWithOptions(request, runtime);
  }

  /**
   * Adds a record to map a domain that is associated with a routine. This record is used to trigger the associated routine code.
   * 
   * @param request - CreateRoutineRelatedRecordRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateRoutineRelatedRecordResponse
   */
  async createRoutineRelatedRecordWithOptions(request: CreateRoutineRelatedRecordRequest, runtime: $dara.RuntimeOptions): Promise<CreateRoutineRelatedRecordResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.name)) {
      body["Name"] = request.name;
    }

    if (!$dara.isNull(request.recordName)) {
      body["RecordName"] = request.recordName;
    }

    if (!$dara.isNull(request.siteId)) {
      body["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateRoutineRelatedRecord",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateRoutineRelatedRecordResponse>(await this.callApi(params, req, runtime), new CreateRoutineRelatedRecordResponse({}));
    } else {
      return $dara.cast<CreateRoutineRelatedRecordResponse>(await this.execute(params, req, runtime), new CreateRoutineRelatedRecordResponse({}));
    }

  }

  /**
   * Adds a record to map a domain that is associated with a routine. This record is used to trigger the associated routine code.
   * 
   * @param request - CreateRoutineRelatedRecordRequest
   * @returns CreateRoutineRelatedRecordResponse
   */
  async createRoutineRelatedRecord(request: CreateRoutineRelatedRecordRequest): Promise<CreateRoutineRelatedRecordResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createRoutineRelatedRecordWithOptions(request, runtime);
  }

  /**
   * Adds a route to map a URL to a routine so that the routine can be triggered to respond to requests destined for the URL.
   * 
   * @param request - CreateRoutineRelatedRouteRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateRoutineRelatedRouteResponse
   */
  async createRoutineRelatedRouteWithOptions(request: CreateRoutineRelatedRouteRequest, runtime: $dara.RuntimeOptions): Promise<CreateRoutineRelatedRouteResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.byPass)) {
      body["ByPass"] = request.byPass;
    }

    if (!$dara.isNull(request.name)) {
      body["Name"] = request.name;
    }

    if (!$dara.isNull(request.route)) {
      body["Route"] = request.route;
    }

    if (!$dara.isNull(request.siteId)) {
      body["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateRoutineRelatedRoute",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateRoutineRelatedRouteResponse>(await this.callApi(params, req, runtime), new CreateRoutineRelatedRouteResponse({}));
    } else {
      return $dara.cast<CreateRoutineRelatedRouteResponse>(await this.execute(params, req, runtime), new CreateRoutineRelatedRouteResponse({}));
    }

  }

  /**
   * Adds a route to map a URL to a routine so that the routine can be triggered to respond to requests destined for the URL.
   * 
   * @param request - CreateRoutineRelatedRouteRequest
   * @returns CreateRoutineRelatedRouteResponse
   */
  async createRoutineRelatedRoute(request: CreateRoutineRelatedRouteRequest): Promise<CreateRoutineRelatedRouteResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createRoutineRelatedRouteWithOptions(request, runtime);
  }

  /**
   * Creates scheduled prefetch plans.
   * 
   * @param tmpReq - CreateScheduledPreloadExecutionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateScheduledPreloadExecutionsResponse
   */
  async createScheduledPreloadExecutionsWithOptions(tmpReq: CreateScheduledPreloadExecutionsRequest, runtime: $dara.RuntimeOptions): Promise<CreateScheduledPreloadExecutionsResponse> {
    tmpReq.validate();
    let request = new CreateScheduledPreloadExecutionsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.executions)) {
      request.executionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.executions, "Executions", "json");
    }

    let query = { };
    if (!$dara.isNull(request.id)) {
      query["Id"] = request.id;
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.executionsShrink)) {
      body["Executions"] = request.executionsShrink;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateScheduledPreloadExecutions",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateScheduledPreloadExecutionsResponse>(await this.callApi(params, req, runtime), new CreateScheduledPreloadExecutionsResponse({}));
    } else {
      return $dara.cast<CreateScheduledPreloadExecutionsResponse>(await this.execute(params, req, runtime), new CreateScheduledPreloadExecutionsResponse({}));
    }

  }

  /**
   * Creates scheduled prefetch plans.
   * 
   * @param request - CreateScheduledPreloadExecutionsRequest
   * @returns CreateScheduledPreloadExecutionsResponse
   */
  async createScheduledPreloadExecutions(request: CreateScheduledPreloadExecutionsRequest): Promise<CreateScheduledPreloadExecutionsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createScheduledPreloadExecutionsWithOptions(request, runtime);
  }

  /**
   * Adds a scheduled prefetch task.
   * 
   * @param request - CreateScheduledPreloadJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateScheduledPreloadJobResponse
   */
  async createScheduledPreloadJobWithOptions(request: CreateScheduledPreloadJobRequest, runtime: $dara.RuntimeOptions): Promise<CreateScheduledPreloadJobResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.insertWay)) {
      body["InsertWay"] = request.insertWay;
    }

    if (!$dara.isNull(request.name)) {
      body["Name"] = request.name;
    }

    if (!$dara.isNull(request.ossUrl)) {
      body["OssUrl"] = request.ossUrl;
    }

    if (!$dara.isNull(request.siteId)) {
      body["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.urlList)) {
      body["UrlList"] = request.urlList;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateScheduledPreloadJob",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateScheduledPreloadJobResponse>(await this.callApi(params, req, runtime), new CreateScheduledPreloadJobResponse({}));
    } else {
      return $dara.cast<CreateScheduledPreloadJobResponse>(await this.execute(params, req, runtime), new CreateScheduledPreloadJobResponse({}));
    }

  }

  /**
   * Adds a scheduled prefetch task.
   * 
   * @param request - CreateScheduledPreloadJobRequest
   * @returns CreateScheduledPreloadJobResponse
   */
  async createScheduledPreloadJob(request: CreateScheduledPreloadJobRequest): Promise<CreateScheduledPreloadJobResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createScheduledPreloadJobWithOptions(request, runtime);
  }

  /**
   * Adds a website.
   * 
   * @remarks
   *   Make sure that you have an available plan before you add a website.
   * *   Make sure that your website domain name has an ICP filing if the location you want to specify covers the Chinese mainland.
   * 
   * @param request - CreateSiteRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateSiteResponse
   */
  async createSiteWithOptions(request: CreateSiteRequest, runtime: $dara.RuntimeOptions): Promise<CreateSiteResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.accessType)) {
      query["AccessType"] = request.accessType;
    }

    if (!$dara.isNull(request.coverage)) {
      query["Coverage"] = request.coverage;
    }

    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.resourceGroupId)) {
      query["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!$dara.isNull(request.siteName)) {
      query["SiteName"] = request.siteName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateSite",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateSiteResponse>(await this.callApi(params, req, runtime), new CreateSiteResponse({}));
    } else {
      return $dara.cast<CreateSiteResponse>(await this.execute(params, req, runtime), new CreateSiteResponse({}));
    }

  }

  /**
   * Adds a website.
   * 
   * @remarks
   *   Make sure that you have an available plan before you add a website.
   * *   Make sure that your website domain name has an ICP filing if the location you want to specify covers the Chinese mainland.
   * 
   * @param request - CreateSiteRequest
   * @returns CreateSiteResponse
   */
  async createSite(request: CreateSiteRequest): Promise<CreateSiteResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createSiteWithOptions(request, runtime);
  }

  /**
   * Adds the configuration of custom request header, response header, and cookie fields that are used to capture logs of a website.
   * 
   * @remarks
   *   **Custom field limits**: The key name of a custom field can contain only letters, digits, underscores (_), and spaces. The key name cannot contain other characters. Otherwise, errors may occur.
   * *   **Parameter passing**: Submit `SiteId`, `RequestHeaders`, `ResponseHeaders`, and `Cookies` by using `formData`. Each array element matches a custom field name.
   * *   **(Required) SiteId**: Although `SiteId` is not marked as required in the Required column, you must specify a website ID by using this parameter when you can call this API operation.
   * 
   * @param tmpReq - CreateSiteCustomLogRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateSiteCustomLogResponse
   */
  async createSiteCustomLogWithOptions(tmpReq: CreateSiteCustomLogRequest, runtime: $dara.RuntimeOptions): Promise<CreateSiteCustomLogResponse> {
    tmpReq.validate();
    let request = new CreateSiteCustomLogShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.cookies)) {
      request.cookiesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.cookies, "Cookies", "json");
    }

    if (!$dara.isNull(tmpReq.requestHeaders)) {
      request.requestHeadersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.requestHeaders, "RequestHeaders", "json");
    }

    if (!$dara.isNull(tmpReq.responseHeaders)) {
      request.responseHeadersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.responseHeaders, "ResponseHeaders", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.cookiesShrink)) {
      body["Cookies"] = request.cookiesShrink;
    }

    if (!$dara.isNull(request.requestHeadersShrink)) {
      body["RequestHeaders"] = request.requestHeadersShrink;
    }

    if (!$dara.isNull(request.responseHeadersShrink)) {
      body["ResponseHeaders"] = request.responseHeadersShrink;
    }

    if (!$dara.isNull(request.siteId)) {
      body["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateSiteCustomLog",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateSiteCustomLogResponse>(await this.callApi(params, req, runtime), new CreateSiteCustomLogResponse({}));
    } else {
      return $dara.cast<CreateSiteCustomLogResponse>(await this.execute(params, req, runtime), new CreateSiteCustomLogResponse({}));
    }

  }

  /**
   * Adds the configuration of custom request header, response header, and cookie fields that are used to capture logs of a website.
   * 
   * @remarks
   *   **Custom field limits**: The key name of a custom field can contain only letters, digits, underscores (_), and spaces. The key name cannot contain other characters. Otherwise, errors may occur.
   * *   **Parameter passing**: Submit `SiteId`, `RequestHeaders`, `ResponseHeaders`, and `Cookies` by using `formData`. Each array element matches a custom field name.
   * *   **(Required) SiteId**: Although `SiteId` is not marked as required in the Required column, you must specify a website ID by using this parameter when you can call this API operation.
   * 
   * @param request - CreateSiteCustomLogRequest
   * @returns CreateSiteCustomLogResponse
   */
  async createSiteCustomLog(request: CreateSiteCustomLogRequest): Promise<CreateSiteCustomLogResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createSiteCustomLogWithOptions(request, runtime);
  }

  /**
   * Creates a real-time log delivery task.
   * 
   * @param tmpReq - CreateSiteDeliveryTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateSiteDeliveryTaskResponse
   */
  async createSiteDeliveryTaskWithOptions(tmpReq: CreateSiteDeliveryTaskRequest, runtime: $dara.RuntimeOptions): Promise<CreateSiteDeliveryTaskResponse> {
    tmpReq.validate();
    let request = new CreateSiteDeliveryTaskShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.httpDelivery)) {
      request.httpDeliveryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.httpDelivery, "HttpDelivery", "json");
    }

    if (!$dara.isNull(tmpReq.kafkaDelivery)) {
      request.kafkaDeliveryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.kafkaDelivery, "KafkaDelivery", "json");
    }

    if (!$dara.isNull(tmpReq.ossDelivery)) {
      request.ossDeliveryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ossDelivery, "OssDelivery", "json");
    }

    if (!$dara.isNull(tmpReq.s3Delivery)) {
      request.s3DeliveryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.s3Delivery, "S3Delivery", "json");
    }

    if (!$dara.isNull(tmpReq.slsDelivery)) {
      request.slsDeliveryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.slsDelivery, "SlsDelivery", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.businessType)) {
      body["BusinessType"] = request.businessType;
    }

    if (!$dara.isNull(request.dataCenter)) {
      body["DataCenter"] = request.dataCenter;
    }

    if (!$dara.isNull(request.deliveryType)) {
      body["DeliveryType"] = request.deliveryType;
    }

    if (!$dara.isNull(request.discardRate)) {
      body["DiscardRate"] = request.discardRate;
    }

    if (!$dara.isNull(request.fieldName)) {
      body["FieldName"] = request.fieldName;
    }

    if (!$dara.isNull(request.httpDeliveryShrink)) {
      body["HttpDelivery"] = request.httpDeliveryShrink;
    }

    if (!$dara.isNull(request.kafkaDeliveryShrink)) {
      body["KafkaDelivery"] = request.kafkaDeliveryShrink;
    }

    if (!$dara.isNull(request.ossDeliveryShrink)) {
      body["OssDelivery"] = request.ossDeliveryShrink;
    }

    if (!$dara.isNull(request.s3DeliveryShrink)) {
      body["S3Delivery"] = request.s3DeliveryShrink;
    }

    if (!$dara.isNull(request.siteId)) {
      body["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.slsDeliveryShrink)) {
      body["SlsDelivery"] = request.slsDeliveryShrink;
    }

    if (!$dara.isNull(request.taskName)) {
      body["TaskName"] = request.taskName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateSiteDeliveryTask",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateSiteDeliveryTaskResponse>(await this.callApi(params, req, runtime), new CreateSiteDeliveryTaskResponse({}));
    } else {
      return $dara.cast<CreateSiteDeliveryTaskResponse>(await this.execute(params, req, runtime), new CreateSiteDeliveryTaskResponse({}));
    }

  }

  /**
   * Creates a real-time log delivery task.
   * 
   * @param request - CreateSiteDeliveryTaskRequest
   * @returns CreateSiteDeliveryTaskResponse
   */
  async createSiteDeliveryTask(request: CreateSiteDeliveryTaskRequest): Promise<CreateSiteDeliveryTaskResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createSiteDeliveryTaskWithOptions(request, runtime);
  }

  /**
   * slr
   * 
   * @param request - CreateSlrRoleForRealtimeLogRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateSlrRoleForRealtimeLogResponse
   */
  async createSlrRoleForRealtimeLogWithOptions(runtime: $dara.RuntimeOptions): Promise<CreateSlrRoleForRealtimeLogResponse> {
    let req = new $OpenApiUtil.OpenApiRequest({ });
    let params = new $OpenApiUtil.Params({
      action: "CreateSlrRoleForRealtimeLog",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateSlrRoleForRealtimeLogResponse>(await this.callApi(params, req, runtime), new CreateSlrRoleForRealtimeLogResponse({}));
    } else {
      return $dara.cast<CreateSlrRoleForRealtimeLogResponse>(await this.execute(params, req, runtime), new CreateSlrRoleForRealtimeLogResponse({}));
    }

  }

  /**
   * slr
   * @returns CreateSlrRoleForRealtimeLogResponse
   */
  async createSlrRoleForRealtimeLog(): Promise<CreateSlrRoleForRealtimeLogResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createSlrRoleForRealtimeLogWithOptions(runtime);
  }

  /**
   * Creates a log delivery task to ship logs to the specified destination.
   * 
   * @remarks
   * This API operation allows you to deliver logs to destinations such as Simple Log Service (SLS), HTTP servers, Object Storage Service (OSS), Amazon Simple Storage Service (S3), and Kafka. You can specify the task name, log fields to deliver, data center, discard rate, delivery type, and delivery details.
   * *   **Field filtering**: Use the `FieldName` parameter to specify log fields to deliver.
   * *   **Filtering rules**: Use the `FilterRules` parameter to pre-process and filter log data.
   * *   **Diverse delivery destinations**: Logs can be delivered to different destinations. Configuration parameters vary with delivery destinations.
   * ## [](#)Precautions
   * *   Make sure that you have sufficient permissions to perform delivery tasks.
   * *   If you enable encryption or authentication, properly configure corresponding parameters.
   * *   Verify the syntax of `FilterRules` to make sure that filtering logic works as expected.
   * *   Specify advanced settings such as the number of retries and timeout period based on your needs to have optimal delivery efficiency and stability.
   * 
   * @param tmpReq - CreateUserDeliveryTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateUserDeliveryTaskResponse
   */
  async createUserDeliveryTaskWithOptions(tmpReq: CreateUserDeliveryTaskRequest, runtime: $dara.RuntimeOptions): Promise<CreateUserDeliveryTaskResponse> {
    tmpReq.validate();
    let request = new CreateUserDeliveryTaskShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.httpDelivery)) {
      request.httpDeliveryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.httpDelivery, "HttpDelivery", "json");
    }

    if (!$dara.isNull(tmpReq.kafkaDelivery)) {
      request.kafkaDeliveryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.kafkaDelivery, "KafkaDelivery", "json");
    }

    if (!$dara.isNull(tmpReq.ossDelivery)) {
      request.ossDeliveryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ossDelivery, "OssDelivery", "json");
    }

    if (!$dara.isNull(tmpReq.s3Delivery)) {
      request.s3DeliveryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.s3Delivery, "S3Delivery", "json");
    }

    if (!$dara.isNull(tmpReq.slsDelivery)) {
      request.slsDeliveryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.slsDelivery, "SlsDelivery", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.businessType)) {
      body["BusinessType"] = request.businessType;
    }

    if (!$dara.isNull(request.dataCenter)) {
      body["DataCenter"] = request.dataCenter;
    }

    if (!$dara.isNull(request.deliveryType)) {
      body["DeliveryType"] = request.deliveryType;
    }

    if (!$dara.isNull(request.details)) {
      body["Details"] = request.details;
    }

    if (!$dara.isNull(request.discardRate)) {
      body["DiscardRate"] = request.discardRate;
    }

    if (!$dara.isNull(request.fieldName)) {
      body["FieldName"] = request.fieldName;
    }

    if (!$dara.isNull(request.httpDeliveryShrink)) {
      body["HttpDelivery"] = request.httpDeliveryShrink;
    }

    if (!$dara.isNull(request.kafkaDeliveryShrink)) {
      body["KafkaDelivery"] = request.kafkaDeliveryShrink;
    }

    if (!$dara.isNull(request.ossDeliveryShrink)) {
      body["OssDelivery"] = request.ossDeliveryShrink;
    }

    if (!$dara.isNull(request.s3DeliveryShrink)) {
      body["S3Delivery"] = request.s3DeliveryShrink;
    }

    if (!$dara.isNull(request.slsDeliveryShrink)) {
      body["SlsDelivery"] = request.slsDeliveryShrink;
    }

    if (!$dara.isNull(request.taskName)) {
      body["TaskName"] = request.taskName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateUserDeliveryTask",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateUserDeliveryTaskResponse>(await this.callApi(params, req, runtime), new CreateUserDeliveryTaskResponse({}));
    } else {
      return $dara.cast<CreateUserDeliveryTaskResponse>(await this.execute(params, req, runtime), new CreateUserDeliveryTaskResponse({}));
    }

  }

  /**
   * Creates a log delivery task to ship logs to the specified destination.
   * 
   * @remarks
   * This API operation allows you to deliver logs to destinations such as Simple Log Service (SLS), HTTP servers, Object Storage Service (OSS), Amazon Simple Storage Service (S3), and Kafka. You can specify the task name, log fields to deliver, data center, discard rate, delivery type, and delivery details.
   * *   **Field filtering**: Use the `FieldName` parameter to specify log fields to deliver.
   * *   **Filtering rules**: Use the `FilterRules` parameter to pre-process and filter log data.
   * *   **Diverse delivery destinations**: Logs can be delivered to different destinations. Configuration parameters vary with delivery destinations.
   * ## [](#)Precautions
   * *   Make sure that you have sufficient permissions to perform delivery tasks.
   * *   If you enable encryption or authentication, properly configure corresponding parameters.
   * *   Verify the syntax of `FilterRules` to make sure that filtering logic works as expected.
   * *   Specify advanced settings such as the number of retries and timeout period based on your needs to have optimal delivery efficiency and stability.
   * 
   * @param request - CreateUserDeliveryTaskRequest
   * @returns CreateUserDeliveryTaskResponse
   */
  async createUserDeliveryTask(request: CreateUserDeliveryTaskRequest): Promise<CreateUserDeliveryTaskResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createUserDeliveryTaskWithOptions(request, runtime);
  }

  /**
   * Creates a waiting room for a website.
   * 
   * @param tmpReq - CreateWaitingRoomRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateWaitingRoomResponse
   */
  async createWaitingRoomWithOptions(tmpReq: CreateWaitingRoomRequest, runtime: $dara.RuntimeOptions): Promise<CreateWaitingRoomResponse> {
    tmpReq.validate();
    let request = new CreateWaitingRoomShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.hostNameAndPath)) {
      request.hostNameAndPathShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.hostNameAndPath, "HostNameAndPath", "json");
    }

    let query = { };
    if (!$dara.isNull(request.cookieName)) {
      query["CookieName"] = request.cookieName;
    }

    if (!$dara.isNull(request.customPageHtml)) {
      query["CustomPageHtml"] = request.customPageHtml;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.disableSessionRenewalEnable)) {
      query["DisableSessionRenewalEnable"] = request.disableSessionRenewalEnable;
    }

    if (!$dara.isNull(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!$dara.isNull(request.hostNameAndPathShrink)) {
      query["HostNameAndPath"] = request.hostNameAndPathShrink;
    }

    if (!$dara.isNull(request.jsonResponseEnable)) {
      query["JsonResponseEnable"] = request.jsonResponseEnable;
    }

    if (!$dara.isNull(request.language)) {
      query["Language"] = request.language;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.newUsersPerMinute)) {
      query["NewUsersPerMinute"] = request.newUsersPerMinute;
    }

    if (!$dara.isNull(request.queueAllEnable)) {
      query["QueueAllEnable"] = request.queueAllEnable;
    }

    if (!$dara.isNull(request.queuingMethod)) {
      query["QueuingMethod"] = request.queuingMethod;
    }

    if (!$dara.isNull(request.queuingStatusCode)) {
      query["QueuingStatusCode"] = request.queuingStatusCode;
    }

    if (!$dara.isNull(request.sessionDuration)) {
      query["SessionDuration"] = request.sessionDuration;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.totalActiveUsers)) {
      query["TotalActiveUsers"] = request.totalActiveUsers;
    }

    if (!$dara.isNull(request.waitingRoomType)) {
      query["WaitingRoomType"] = request.waitingRoomType;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateWaitingRoom",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateWaitingRoomResponse>(await this.callApi(params, req, runtime), new CreateWaitingRoomResponse({}));
    } else {
      return $dara.cast<CreateWaitingRoomResponse>(await this.execute(params, req, runtime), new CreateWaitingRoomResponse({}));
    }

  }

  /**
   * Creates a waiting room for a website.
   * 
   * @param request - CreateWaitingRoomRequest
   * @returns CreateWaitingRoomResponse
   */
  async createWaitingRoom(request: CreateWaitingRoomRequest): Promise<CreateWaitingRoomResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createWaitingRoomWithOptions(request, runtime);
  }

  /**
   * Creates a waiting room event.
   * 
   * @param request - CreateWaitingRoomEventRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateWaitingRoomEventResponse
   */
  async createWaitingRoomEventWithOptions(request: CreateWaitingRoomEventRequest, runtime: $dara.RuntimeOptions): Promise<CreateWaitingRoomEventResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.customPageHtml)) {
      query["CustomPageHtml"] = request.customPageHtml;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.disableSessionRenewalEnable)) {
      query["DisableSessionRenewalEnable"] = request.disableSessionRenewalEnable;
    }

    if (!$dara.isNull(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!$dara.isNull(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.jsonResponseEnable)) {
      query["JsonResponseEnable"] = request.jsonResponseEnable;
    }

    if (!$dara.isNull(request.language)) {
      query["Language"] = request.language;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.newUsersPerMinute)) {
      query["NewUsersPerMinute"] = request.newUsersPerMinute;
    }

    if (!$dara.isNull(request.preQueueEnable)) {
      query["PreQueueEnable"] = request.preQueueEnable;
    }

    if (!$dara.isNull(request.preQueueStartTime)) {
      query["PreQueueStartTime"] = request.preQueueStartTime;
    }

    if (!$dara.isNull(request.queuingMethod)) {
      query["QueuingMethod"] = request.queuingMethod;
    }

    if (!$dara.isNull(request.queuingStatusCode)) {
      query["QueuingStatusCode"] = request.queuingStatusCode;
    }

    if (!$dara.isNull(request.randomPreQueueEnable)) {
      query["RandomPreQueueEnable"] = request.randomPreQueueEnable;
    }

    if (!$dara.isNull(request.sessionDuration)) {
      query["SessionDuration"] = request.sessionDuration;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!$dara.isNull(request.totalActiveUsers)) {
      query["TotalActiveUsers"] = request.totalActiveUsers;
    }

    if (!$dara.isNull(request.waitingRoomId)) {
      query["WaitingRoomId"] = request.waitingRoomId;
    }

    if (!$dara.isNull(request.waitingRoomType)) {
      query["WaitingRoomType"] = request.waitingRoomType;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateWaitingRoomEvent",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateWaitingRoomEventResponse>(await this.callApi(params, req, runtime), new CreateWaitingRoomEventResponse({}));
    } else {
      return $dara.cast<CreateWaitingRoomEventResponse>(await this.execute(params, req, runtime), new CreateWaitingRoomEventResponse({}));
    }

  }

  /**
   * Creates a waiting room event.
   * 
   * @param request - CreateWaitingRoomEventRequest
   * @returns CreateWaitingRoomEventResponse
   */
  async createWaitingRoomEvent(request: CreateWaitingRoomEventRequest): Promise<CreateWaitingRoomEventResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createWaitingRoomEventWithOptions(request, runtime);
  }

  /**
   * Creates a waiting room bypass rule.
   * 
   * @param request - CreateWaitingRoomRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateWaitingRoomRuleResponse
   */
  async createWaitingRoomRuleWithOptions(request: CreateWaitingRoomRuleRequest, runtime: $dara.RuntimeOptions): Promise<CreateWaitingRoomRuleResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.rule)) {
      query["Rule"] = request.rule;
    }

    if (!$dara.isNull(request.ruleEnable)) {
      query["RuleEnable"] = request.ruleEnable;
    }

    if (!$dara.isNull(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.waitingRoomId)) {
      query["WaitingRoomId"] = request.waitingRoomId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "CreateWaitingRoomRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<CreateWaitingRoomRuleResponse>(await this.callApi(params, req, runtime), new CreateWaitingRoomRuleResponse({}));
    } else {
      return $dara.cast<CreateWaitingRoomRuleResponse>(await this.execute(params, req, runtime), new CreateWaitingRoomRuleResponse({}));
    }

  }

  /**
   * Creates a waiting room bypass rule.
   * 
   * @param request - CreateWaitingRoomRuleRequest
   * @returns CreateWaitingRoomRuleResponse
   */
  async createWaitingRoomRule(request: CreateWaitingRoomRuleRequest): Promise<CreateWaitingRoomRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.createWaitingRoomRuleWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - DeactivateVersionManagementRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeactivateVersionManagementResponse
   */
  async deactivateVersionManagementWithOptions(request: DeactivateVersionManagementRequest, runtime: $dara.RuntimeOptions): Promise<DeactivateVersionManagementResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeactivateVersionManagement",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeactivateVersionManagementResponse>(await this.callApi(params, req, runtime), new DeactivateVersionManagementResponse({}));
    } else {
      return $dara.cast<DeactivateVersionManagementResponse>(await this.execute(params, req, runtime), new DeactivateVersionManagementResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - DeactivateVersionManagementRequest
   * @returns DeactivateVersionManagementResponse
   */
  async deactivateVersionManagement(request: DeactivateVersionManagementRequest): Promise<DeactivateVersionManagementResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deactivateVersionManagementWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - DeleteCacheRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteCacheRuleResponse
   */
  async deleteCacheRuleWithOptions(request: DeleteCacheRuleRequest, runtime: $dara.RuntimeOptions): Promise<DeleteCacheRuleResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteCacheRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteCacheRuleResponse>(await this.callApi(params, req, runtime), new DeleteCacheRuleResponse({}));
    } else {
      return $dara.cast<DeleteCacheRuleResponse>(await this.execute(params, req, runtime), new DeleteCacheRuleResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - DeleteCacheRuleRequest
   * @returns DeleteCacheRuleResponse
   */
  async deleteCacheRule(request: DeleteCacheRuleRequest): Promise<DeleteCacheRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteCacheRuleWithOptions(request, runtime);
  }

  /**
   * Deletes a certificate for a website.
   * 
   * @param request - DeleteCertificateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteCertificateResponse
   */
  async deleteCertificateWithOptions(request: DeleteCertificateRequest, runtime: $dara.RuntimeOptions): Promise<DeleteCertificateResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteCertificate",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteCertificateResponse>(await this.callApi(params, req, runtime), new DeleteCertificateResponse({}));
    } else {
      return $dara.cast<DeleteCertificateResponse>(await this.execute(params, req, runtime), new DeleteCertificateResponse({}));
    }

  }

  /**
   * Deletes a certificate for a website.
   * 
   * @param request - DeleteCertificateRequest
   * @returns DeleteCertificateResponse
   */
  async deleteCertificate(request: DeleteCertificateRequest): Promise<DeleteCertificateResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteCertificateWithOptions(request, runtime);
  }

  /**
   * Deletes a client CA certificate.
   * 
   * @param request - DeleteClientCaCertificateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteClientCaCertificateResponse
   */
  async deleteClientCaCertificateWithOptions(request: DeleteClientCaCertificateRequest, runtime: $dara.RuntimeOptions): Promise<DeleteClientCaCertificateResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteClientCaCertificate",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteClientCaCertificateResponse>(await this.callApi(params, req, runtime), new DeleteClientCaCertificateResponse({}));
    } else {
      return $dara.cast<DeleteClientCaCertificateResponse>(await this.execute(params, req, runtime), new DeleteClientCaCertificateResponse({}));
    }

  }

  /**
   * Deletes a client CA certificate.
   * 
   * @param request - DeleteClientCaCertificateRequest
   * @returns DeleteClientCaCertificateResponse
   */
  async deleteClientCaCertificate(request: DeleteClientCaCertificateRequest): Promise<DeleteClientCaCertificateResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteClientCaCertificateWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - DeleteClientCertificateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteClientCertificateResponse
   */
  async deleteClientCertificateWithOptions(request: DeleteClientCertificateRequest, runtime: $dara.RuntimeOptions): Promise<DeleteClientCertificateResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteClientCertificate",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteClientCertificateResponse>(await this.callApi(params, req, runtime), new DeleteClientCertificateResponse({}));
    } else {
      return $dara.cast<DeleteClientCertificateResponse>(await this.execute(params, req, runtime), new DeleteClientCertificateResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - DeleteClientCertificateRequest
   * @returns DeleteClientCertificateResponse
   */
  async deleteClientCertificate(request: DeleteClientCertificateRequest): Promise<DeleteClientCertificateResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteClientCertificateWithOptions(request, runtime);
  }

  /**
   * Deletes the compression rule configuration for a website.
   * 
   * @param request - DeleteCompressionRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteCompressionRuleResponse
   */
  async deleteCompressionRuleWithOptions(request: DeleteCompressionRuleRequest, runtime: $dara.RuntimeOptions): Promise<DeleteCompressionRuleResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteCompressionRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteCompressionRuleResponse>(await this.callApi(params, req, runtime), new DeleteCompressionRuleResponse({}));
    } else {
      return $dara.cast<DeleteCompressionRuleResponse>(await this.execute(params, req, runtime), new DeleteCompressionRuleResponse({}));
    }

  }

  /**
   * Deletes the compression rule configuration for a website.
   * 
   * @param request - DeleteCompressionRuleRequest
   * @returns DeleteCompressionRuleResponse
   */
  async deleteCompressionRule(request: DeleteCompressionRuleRequest): Promise<DeleteCompressionRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteCompressionRuleWithOptions(request, runtime);
  }

  /**
   * Deletes a scenario-specific custom policy.
   * 
   * @param request - DeleteCustomScenePolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteCustomScenePolicyResponse
   */
  async deleteCustomScenePolicyWithOptions(request: DeleteCustomScenePolicyRequest, runtime: $dara.RuntimeOptions): Promise<DeleteCustomScenePolicyResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteCustomScenePolicy",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteCustomScenePolicyResponse>(await this.callApi(params, req, runtime), new DeleteCustomScenePolicyResponse({}));
    } else {
      return $dara.cast<DeleteCustomScenePolicyResponse>(await this.execute(params, req, runtime), new DeleteCustomScenePolicyResponse({}));
    }

  }

  /**
   * Deletes a scenario-specific custom policy.
   * 
   * @param request - DeleteCustomScenePolicyRequest
   * @returns DeleteCustomScenePolicyResponse
   */
  async deleteCustomScenePolicy(request: DeleteCustomScenePolicyRequest): Promise<DeleteCustomScenePolicyResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteCustomScenePolicyWithOptions(request, runtime);
  }

  /**
   * Deletes a containerized application.
   * 
   * @param request - DeleteEdgeContainerAppRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteEdgeContainerAppResponse
   */
  async deleteEdgeContainerAppWithOptions(request: DeleteEdgeContainerAppRequest, runtime: $dara.RuntimeOptions): Promise<DeleteEdgeContainerAppResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.appId)) {
      query["AppId"] = request.appId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteEdgeContainerApp",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteEdgeContainerAppResponse>(await this.callApi(params, req, runtime), new DeleteEdgeContainerAppResponse({}));
    } else {
      return $dara.cast<DeleteEdgeContainerAppResponse>(await this.execute(params, req, runtime), new DeleteEdgeContainerAppResponse({}));
    }

  }

  /**
   * Deletes a containerized application.
   * 
   * @param request - DeleteEdgeContainerAppRequest
   * @returns DeleteEdgeContainerAppResponse
   */
  async deleteEdgeContainerApp(request: DeleteEdgeContainerAppRequest): Promise<DeleteEdgeContainerAppResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteEdgeContainerAppWithOptions(request, runtime);
  }

  /**
   * Disassociates a domain name from a containerized application. After the dissociation, you can no longer use the domain name to access the containerized application.
   * 
   * @param request - DeleteEdgeContainerAppRecordRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteEdgeContainerAppRecordResponse
   */
  async deleteEdgeContainerAppRecordWithOptions(request: DeleteEdgeContainerAppRecordRequest, runtime: $dara.RuntimeOptions): Promise<DeleteEdgeContainerAppRecordResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!$dara.isNull(request.recordName)) {
      body["RecordName"] = request.recordName;
    }

    if (!$dara.isNull(request.siteId)) {
      body["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteEdgeContainerAppRecord",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteEdgeContainerAppRecordResponse>(await this.callApi(params, req, runtime), new DeleteEdgeContainerAppRecordResponse({}));
    } else {
      return $dara.cast<DeleteEdgeContainerAppRecordResponse>(await this.execute(params, req, runtime), new DeleteEdgeContainerAppRecordResponse({}));
    }

  }

  /**
   * Disassociates a domain name from a containerized application. After the dissociation, you can no longer use the domain name to access the containerized application.
   * 
   * @param request - DeleteEdgeContainerAppRecordRequest
   * @returns DeleteEdgeContainerAppRecordResponse
   */
  async deleteEdgeContainerAppRecord(request: DeleteEdgeContainerAppRecordRequest): Promise<DeleteEdgeContainerAppRecordResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteEdgeContainerAppRecordWithOptions(request, runtime);
  }

  /**
   * Deletes a version of a containerized application.
   * 
   * @param request - DeleteEdgeContainerAppVersionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteEdgeContainerAppVersionResponse
   */
  async deleteEdgeContainerAppVersionWithOptions(request: DeleteEdgeContainerAppVersionRequest, runtime: $dara.RuntimeOptions): Promise<DeleteEdgeContainerAppVersionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!$dara.isNull(request.versionId)) {
      query["VersionId"] = request.versionId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteEdgeContainerAppVersion",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteEdgeContainerAppVersionResponse>(await this.callApi(params, req, runtime), new DeleteEdgeContainerAppVersionResponse({}));
    } else {
      return $dara.cast<DeleteEdgeContainerAppVersionResponse>(await this.execute(params, req, runtime), new DeleteEdgeContainerAppVersionResponse({}));
    }

  }

  /**
   * Deletes a version of a containerized application.
   * 
   * @param request - DeleteEdgeContainerAppVersionRequest
   * @returns DeleteEdgeContainerAppVersionResponse
   */
  async deleteEdgeContainerAppVersion(request: DeleteEdgeContainerAppVersionRequest): Promise<DeleteEdgeContainerAppVersionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteEdgeContainerAppVersionWithOptions(request, runtime);
  }

  /**
   * Deletes the configuration of modifying HTTP request headers for a website.
   * 
   * @param request - DeleteHttpRequestHeaderModificationRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteHttpRequestHeaderModificationRuleResponse
   */
  async deleteHttpRequestHeaderModificationRuleWithOptions(request: DeleteHttpRequestHeaderModificationRuleRequest, runtime: $dara.RuntimeOptions): Promise<DeleteHttpRequestHeaderModificationRuleResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteHttpRequestHeaderModificationRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteHttpRequestHeaderModificationRuleResponse>(await this.callApi(params, req, runtime), new DeleteHttpRequestHeaderModificationRuleResponse({}));
    } else {
      return $dara.cast<DeleteHttpRequestHeaderModificationRuleResponse>(await this.execute(params, req, runtime), new DeleteHttpRequestHeaderModificationRuleResponse({}));
    }

  }

  /**
   * Deletes the configuration of modifying HTTP request headers for a website.
   * 
   * @param request - DeleteHttpRequestHeaderModificationRuleRequest
   * @returns DeleteHttpRequestHeaderModificationRuleResponse
   */
  async deleteHttpRequestHeaderModificationRule(request: DeleteHttpRequestHeaderModificationRuleRequest): Promise<DeleteHttpRequestHeaderModificationRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteHttpRequestHeaderModificationRuleWithOptions(request, runtime);
  }

  /**
   * Deletes the configuration of modifying HTTP response headers for a website.
   * 
   * @param request - DeleteHttpResponseHeaderModificationRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteHttpResponseHeaderModificationRuleResponse
   */
  async deleteHttpResponseHeaderModificationRuleWithOptions(request: DeleteHttpResponseHeaderModificationRuleRequest, runtime: $dara.RuntimeOptions): Promise<DeleteHttpResponseHeaderModificationRuleResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteHttpResponseHeaderModificationRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteHttpResponseHeaderModificationRuleResponse>(await this.callApi(params, req, runtime), new DeleteHttpResponseHeaderModificationRuleResponse({}));
    } else {
      return $dara.cast<DeleteHttpResponseHeaderModificationRuleResponse>(await this.execute(params, req, runtime), new DeleteHttpResponseHeaderModificationRuleResponse({}));
    }

  }

  /**
   * Deletes the configuration of modifying HTTP response headers for a website.
   * 
   * @param request - DeleteHttpResponseHeaderModificationRuleRequest
   * @returns DeleteHttpResponseHeaderModificationRuleResponse
   */
  async deleteHttpResponseHeaderModificationRule(request: DeleteHttpResponseHeaderModificationRuleRequest): Promise<DeleteHttpResponseHeaderModificationRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteHttpResponseHeaderModificationRuleWithOptions(request, runtime);
  }

  /**
   * HTTPS
   * 
   * @param request - DeleteHttpsApplicationConfigurationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteHttpsApplicationConfigurationResponse
   */
  async deleteHttpsApplicationConfigurationWithOptions(request: DeleteHttpsApplicationConfigurationRequest, runtime: $dara.RuntimeOptions): Promise<DeleteHttpsApplicationConfigurationResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteHttpsApplicationConfiguration",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteHttpsApplicationConfigurationResponse>(await this.callApi(params, req, runtime), new DeleteHttpsApplicationConfigurationResponse({}));
    } else {
      return $dara.cast<DeleteHttpsApplicationConfigurationResponse>(await this.execute(params, req, runtime), new DeleteHttpsApplicationConfigurationResponse({}));
    }

  }

  /**
   * HTTPS
   * 
   * @param request - DeleteHttpsApplicationConfigurationRequest
   * @returns DeleteHttpsApplicationConfigurationResponse
   */
  async deleteHttpsApplicationConfiguration(request: DeleteHttpsApplicationConfigurationRequest): Promise<DeleteHttpsApplicationConfigurationResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteHttpsApplicationConfigurationWithOptions(request, runtime);
  }

  /**
   * HTTPS
   * 
   * @param request - DeleteHttpsBasicConfigurationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteHttpsBasicConfigurationResponse
   */
  async deleteHttpsBasicConfigurationWithOptions(request: DeleteHttpsBasicConfigurationRequest, runtime: $dara.RuntimeOptions): Promise<DeleteHttpsBasicConfigurationResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteHttpsBasicConfiguration",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteHttpsBasicConfigurationResponse>(await this.callApi(params, req, runtime), new DeleteHttpsBasicConfigurationResponse({}));
    } else {
      return $dara.cast<DeleteHttpsBasicConfigurationResponse>(await this.execute(params, req, runtime), new DeleteHttpsBasicConfigurationResponse({}));
    }

  }

  /**
   * HTTPS
   * 
   * @param request - DeleteHttpsBasicConfigurationRequest
   * @returns DeleteHttpsBasicConfigurationResponse
   */
  async deleteHttpsBasicConfiguration(request: DeleteHttpsBasicConfigurationRequest): Promise<DeleteHttpsBasicConfigurationResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteHttpsBasicConfigurationWithOptions(request, runtime);
  }

  /**
   * Deletes the configuration of image transformations for a website.
   * 
   * @param request - DeleteImageTransformRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteImageTransformResponse
   */
  async deleteImageTransformWithOptions(request: DeleteImageTransformRequest, runtime: $dara.RuntimeOptions): Promise<DeleteImageTransformResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteImageTransform",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteImageTransformResponse>(await this.callApi(params, req, runtime), new DeleteImageTransformResponse({}));
    } else {
      return $dara.cast<DeleteImageTransformResponse>(await this.execute(params, req, runtime), new DeleteImageTransformResponse({}));
    }

  }

  /**
   * Deletes the configuration of image transformations for a website.
   * 
   * @param request - DeleteImageTransformRequest
   * @returns DeleteImageTransformResponse
   */
  async deleteImageTransform(request: DeleteImageTransformRequest): Promise<DeleteImageTransformResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteImageTransformWithOptions(request, runtime);
  }

  /**
   * Deletes a key-value pair from a namespace.
   * 
   * @param request - DeleteKvRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteKvResponse
   */
  async deleteKvWithOptions(request: DeleteKvRequest, runtime: $dara.RuntimeOptions): Promise<DeleteKvResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteKv",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteKvResponse>(await this.callApi(params, req, runtime), new DeleteKvResponse({}));
    } else {
      return $dara.cast<DeleteKvResponse>(await this.execute(params, req, runtime), new DeleteKvResponse({}));
    }

  }

  /**
   * Deletes a key-value pair from a namespace.
   * 
   * @param request - DeleteKvRequest
   * @returns DeleteKvResponse
   */
  async deleteKv(request: DeleteKvRequest): Promise<DeleteKvResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteKvWithOptions(request, runtime);
  }

  /**
   * Deletes a namespace from an Alibaba Cloud account.
   * 
   * @param request - DeleteKvNamespaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteKvNamespaceResponse
   */
  async deleteKvNamespaceWithOptions(request: DeleteKvNamespaceRequest, runtime: $dara.RuntimeOptions): Promise<DeleteKvNamespaceResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteKvNamespace",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteKvNamespaceResponse>(await this.callApi(params, req, runtime), new DeleteKvNamespaceResponse({}));
    } else {
      return $dara.cast<DeleteKvNamespaceResponse>(await this.execute(params, req, runtime), new DeleteKvNamespaceResponse({}));
    }

  }

  /**
   * Deletes a namespace from an Alibaba Cloud account.
   * 
   * @param request - DeleteKvNamespaceRequest
   * @returns DeleteKvNamespaceResponse
   */
  async deleteKvNamespace(request: DeleteKvNamespaceRequest): Promise<DeleteKvNamespaceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteKvNamespaceWithOptions(request, runtime);
  }

  /**
   * Deletes a custom list that is no longer needed.
   * 
   * @param request - DeleteListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteListResponse
   */
  async deleteListWithOptions(request: DeleteListRequest, runtime: $dara.RuntimeOptions): Promise<DeleteListResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteList",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteListResponse>(await this.callApi(params, req, runtime), new DeleteListResponse({}));
    } else {
      return $dara.cast<DeleteListResponse>(await this.execute(params, req, runtime), new DeleteListResponse({}));
    }

  }

  /**
   * Deletes a custom list that is no longer needed.
   * 
   * @param request - DeleteListRequest
   * @returns DeleteListResponse
   */
  async deleteList(request: DeleteListRequest): Promise<DeleteListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteListWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - DeleteLoadBalancerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteLoadBalancerResponse
   */
  async deleteLoadBalancerWithOptions(request: DeleteLoadBalancerRequest, runtime: $dara.RuntimeOptions): Promise<DeleteLoadBalancerResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.id)) {
      query["Id"] = request.id;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteLoadBalancer",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteLoadBalancerResponse>(await this.callApi(params, req, runtime), new DeleteLoadBalancerResponse({}));
    } else {
      return $dara.cast<DeleteLoadBalancerResponse>(await this.execute(params, req, runtime), new DeleteLoadBalancerResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - DeleteLoadBalancerRequest
   * @returns DeleteLoadBalancerResponse
   */
  async deleteLoadBalancer(request: DeleteLoadBalancerRequest): Promise<DeleteLoadBalancerResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteLoadBalancerWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - DeleteNetworkOptimizationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteNetworkOptimizationResponse
   */
  async deleteNetworkOptimizationWithOptions(request: DeleteNetworkOptimizationRequest, runtime: $dara.RuntimeOptions): Promise<DeleteNetworkOptimizationResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteNetworkOptimization",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteNetworkOptimizationResponse>(await this.callApi(params, req, runtime), new DeleteNetworkOptimizationResponse({}));
    } else {
      return $dara.cast<DeleteNetworkOptimizationResponse>(await this.execute(params, req, runtime), new DeleteNetworkOptimizationResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - DeleteNetworkOptimizationRequest
   * @returns DeleteNetworkOptimizationResponse
   */
  async deleteNetworkOptimization(request: DeleteNetworkOptimizationRequest): Promise<DeleteNetworkOptimizationResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteNetworkOptimizationWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - DeleteOriginPoolRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteOriginPoolResponse
   */
  async deleteOriginPoolWithOptions(request: DeleteOriginPoolRequest, runtime: $dara.RuntimeOptions): Promise<DeleteOriginPoolResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.id)) {
      query["Id"] = request.id;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteOriginPool",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteOriginPoolResponse>(await this.callApi(params, req, runtime), new DeleteOriginPoolResponse({}));
    } else {
      return $dara.cast<DeleteOriginPoolResponse>(await this.execute(params, req, runtime), new DeleteOriginPoolResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - DeleteOriginPoolRequest
   * @returns DeleteOriginPoolResponse
   */
  async deleteOriginPool(request: DeleteOriginPoolRequest): Promise<DeleteOriginPoolResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteOriginPoolWithOptions(request, runtime);
  }

  /**
   * Disables origin protection.
   * 
   * @param request - DeleteOriginProtectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteOriginProtectionResponse
   */
  async deleteOriginProtectionWithOptions(request: DeleteOriginProtectionRequest, runtime: $dara.RuntimeOptions): Promise<DeleteOriginProtectionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteOriginProtection",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteOriginProtectionResponse>(await this.callApi(params, req, runtime), new DeleteOriginProtectionResponse({}));
    } else {
      return $dara.cast<DeleteOriginProtectionResponse>(await this.execute(params, req, runtime), new DeleteOriginProtectionResponse({}));
    }

  }

  /**
   * Disables origin protection.
   * 
   * @param request - DeleteOriginProtectionRequest
   * @returns DeleteOriginProtectionResponse
   */
  async deleteOriginProtection(request: DeleteOriginProtectionRequest): Promise<DeleteOriginProtectionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteOriginProtectionWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - DeleteOriginRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteOriginRuleResponse
   */
  async deleteOriginRuleWithOptions(request: DeleteOriginRuleRequest, runtime: $dara.RuntimeOptions): Promise<DeleteOriginRuleResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteOriginRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteOriginRuleResponse>(await this.callApi(params, req, runtime), new DeleteOriginRuleResponse({}));
    } else {
      return $dara.cast<DeleteOriginRuleResponse>(await this.execute(params, req, runtime), new DeleteOriginRuleResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - DeleteOriginRuleRequest
   * @returns DeleteOriginRuleResponse
   */
  async deleteOriginRule(request: DeleteOriginRuleRequest): Promise<DeleteOriginRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteOriginRuleWithOptions(request, runtime);
  }

  /**
   * Deletes a custom error page that is no longer needed.
   * 
   * @param request - DeletePageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeletePageResponse
   */
  async deletePageWithOptions(request: DeletePageRequest, runtime: $dara.RuntimeOptions): Promise<DeletePageResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeletePage",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeletePageResponse>(await this.callApi(params, req, runtime), new DeletePageResponse({}));
    } else {
      return $dara.cast<DeletePageResponse>(await this.execute(params, req, runtime), new DeletePageResponse({}));
    }

  }

  /**
   * Deletes a custom error page that is no longer needed.
   * 
   * @param request - DeletePageRequest
   * @returns DeletePageResponse
   */
  async deletePage(request: DeletePageRequest): Promise<DeletePageResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deletePageWithOptions(request, runtime);
  }

  /**
   * Deletes a DNS record of a website based on the specified RecordId.
   * 
   * @param request - DeleteRecordRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRecordResponse
   */
  async deleteRecordWithOptions(request: DeleteRecordRequest, runtime: $dara.RuntimeOptions): Promise<DeleteRecordResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.recordId)) {
      query["RecordId"] = request.recordId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteRecord",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteRecordResponse>(await this.callApi(params, req, runtime), new DeleteRecordResponse({}));
    } else {
      return $dara.cast<DeleteRecordResponse>(await this.execute(params, req, runtime), new DeleteRecordResponse({}));
    }

  }

  /**
   * Deletes a DNS record of a website based on the specified RecordId.
   * 
   * @param request - DeleteRecordRequest
   * @returns DeleteRecordResponse
   */
  async deleteRecord(request: DeleteRecordRequest): Promise<DeleteRecordResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteRecordWithOptions(request, runtime);
  }

  /**
   * Deletes a URL redirect rule for a website.
   * 
   * @param request - DeleteRedirectRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRedirectRuleResponse
   */
  async deleteRedirectRuleWithOptions(request: DeleteRedirectRuleRequest, runtime: $dara.RuntimeOptions): Promise<DeleteRedirectRuleResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteRedirectRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteRedirectRuleResponse>(await this.callApi(params, req, runtime), new DeleteRedirectRuleResponse({}));
    } else {
      return $dara.cast<DeleteRedirectRuleResponse>(await this.execute(params, req, runtime), new DeleteRedirectRuleResponse({}));
    }

  }

  /**
   * Deletes a URL redirect rule for a website.
   * 
   * @param request - DeleteRedirectRuleRequest
   * @returns DeleteRedirectRuleResponse
   */
  async deleteRedirectRule(request: DeleteRedirectRuleRequest): Promise<DeleteRedirectRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteRedirectRuleWithOptions(request, runtime);
  }

  /**
   * Deletes a URL rewrite rule for a website.
   * 
   * @param request - DeleteRewriteUrlRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRewriteUrlRuleResponse
   */
  async deleteRewriteUrlRuleWithOptions(request: DeleteRewriteUrlRuleRequest, runtime: $dara.RuntimeOptions): Promise<DeleteRewriteUrlRuleResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteRewriteUrlRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteRewriteUrlRuleResponse>(await this.callApi(params, req, runtime), new DeleteRewriteUrlRuleResponse({}));
    } else {
      return $dara.cast<DeleteRewriteUrlRuleResponse>(await this.execute(params, req, runtime), new DeleteRewriteUrlRuleResponse({}));
    }

  }

  /**
   * Deletes a URL rewrite rule for a website.
   * 
   * @param request - DeleteRewriteUrlRuleRequest
   * @returns DeleteRewriteUrlRuleResponse
   */
  async deleteRewriteUrlRule(request: DeleteRewriteUrlRuleRequest): Promise<DeleteRewriteUrlRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteRewriteUrlRuleWithOptions(request, runtime);
  }

  /**
   * Deletes a routine in Edge Routine.
   * 
   * @param request - DeleteRoutineRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRoutineResponse
   */
  async deleteRoutineWithOptions(request: DeleteRoutineRequest, runtime: $dara.RuntimeOptions): Promise<DeleteRoutineResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteRoutine",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteRoutineResponse>(await this.callApi(params, req, runtime), new DeleteRoutineResponse({}));
    } else {
      return $dara.cast<DeleteRoutineResponse>(await this.execute(params, req, runtime), new DeleteRoutineResponse({}));
    }

  }

  /**
   * Deletes a routine in Edge Routine.
   * 
   * @param request - DeleteRoutineRequest
   * @returns DeleteRoutineResponse
   */
  async deleteRoutine(request: DeleteRoutineRequest): Promise<DeleteRoutineResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteRoutineWithOptions(request, runtime);
  }

  /**
   * Deletes a code version of a routine.
   * 
   * @param request - DeleteRoutineCodeVersionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRoutineCodeVersionResponse
   */
  async deleteRoutineCodeVersionWithOptions(request: DeleteRoutineCodeVersionRequest, runtime: $dara.RuntimeOptions): Promise<DeleteRoutineCodeVersionResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.codeVersion)) {
      body["CodeVersion"] = request.codeVersion;
    }

    if (!$dara.isNull(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteRoutineCodeVersion",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteRoutineCodeVersionResponse>(await this.callApi(params, req, runtime), new DeleteRoutineCodeVersionResponse({}));
    } else {
      return $dara.cast<DeleteRoutineCodeVersionResponse>(await this.execute(params, req, runtime), new DeleteRoutineCodeVersionResponse({}));
    }

  }

  /**
   * Deletes a code version of a routine.
   * 
   * @param request - DeleteRoutineCodeVersionRequest
   * @returns DeleteRoutineCodeVersionResponse
   */
  async deleteRoutineCodeVersion(request: DeleteRoutineCodeVersionRequest): Promise<DeleteRoutineCodeVersionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteRoutineCodeVersionWithOptions(request, runtime);
  }

  /**
   * Deletes a record that is associated with a routine.
   * 
   * @param request - DeleteRoutineRelatedRecordRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRoutineRelatedRecordResponse
   */
  async deleteRoutineRelatedRecordWithOptions(request: DeleteRoutineRelatedRecordRequest, runtime: $dara.RuntimeOptions): Promise<DeleteRoutineRelatedRecordResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.name)) {
      body["Name"] = request.name;
    }

    if (!$dara.isNull(request.recordId)) {
      body["RecordId"] = request.recordId;
    }

    if (!$dara.isNull(request.recordName)) {
      body["RecordName"] = request.recordName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteRoutineRelatedRecord",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteRoutineRelatedRecordResponse>(await this.callApi(params, req, runtime), new DeleteRoutineRelatedRecordResponse({}));
    } else {
      return $dara.cast<DeleteRoutineRelatedRecordResponse>(await this.execute(params, req, runtime), new DeleteRoutineRelatedRecordResponse({}));
    }

  }

  /**
   * Deletes a record that is associated with a routine.
   * 
   * @param request - DeleteRoutineRelatedRecordRequest
   * @returns DeleteRoutineRelatedRecordResponse
   */
  async deleteRoutineRelatedRecord(request: DeleteRoutineRelatedRecordRequest): Promise<DeleteRoutineRelatedRecordResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteRoutineRelatedRecordWithOptions(request, runtime);
  }

  /**
   * Deletes a route that is associated with a routine.
   * 
   * @param request - DeleteRoutineRelatedRouteRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRoutineRelatedRouteResponse
   */
  async deleteRoutineRelatedRouteWithOptions(request: DeleteRoutineRelatedRouteRequest, runtime: $dara.RuntimeOptions): Promise<DeleteRoutineRelatedRouteResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.name)) {
      body["Name"] = request.name;
    }

    if (!$dara.isNull(request.route)) {
      body["Route"] = request.route;
    }

    if (!$dara.isNull(request.routeId)) {
      body["RouteId"] = request.routeId;
    }

    if (!$dara.isNull(request.siteId)) {
      body["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteRoutineRelatedRoute",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteRoutineRelatedRouteResponse>(await this.callApi(params, req, runtime), new DeleteRoutineRelatedRouteResponse({}));
    } else {
      return $dara.cast<DeleteRoutineRelatedRouteResponse>(await this.execute(params, req, runtime), new DeleteRoutineRelatedRouteResponse({}));
    }

  }

  /**
   * Deletes a route that is associated with a routine.
   * 
   * @param request - DeleteRoutineRelatedRouteRequest
   * @returns DeleteRoutineRelatedRouteResponse
   */
  async deleteRoutineRelatedRoute(request: DeleteRoutineRelatedRouteRequest): Promise<DeleteRoutineRelatedRouteResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteRoutineRelatedRouteWithOptions(request, runtime);
  }

  /**
   * Deletes a scheduled prefetch plan based on the plan ID.
   * 
   * @param request - DeleteScheduledPreloadExecutionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteScheduledPreloadExecutionResponse
   */
  async deleteScheduledPreloadExecutionWithOptions(request: DeleteScheduledPreloadExecutionRequest, runtime: $dara.RuntimeOptions): Promise<DeleteScheduledPreloadExecutionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteScheduledPreloadExecution",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteScheduledPreloadExecutionResponse>(await this.callApi(params, req, runtime), new DeleteScheduledPreloadExecutionResponse({}));
    } else {
      return $dara.cast<DeleteScheduledPreloadExecutionResponse>(await this.execute(params, req, runtime), new DeleteScheduledPreloadExecutionResponse({}));
    }

  }

  /**
   * Deletes a scheduled prefetch plan based on the plan ID.
   * 
   * @param request - DeleteScheduledPreloadExecutionRequest
   * @returns DeleteScheduledPreloadExecutionResponse
   */
  async deleteScheduledPreloadExecution(request: DeleteScheduledPreloadExecutionRequest): Promise<DeleteScheduledPreloadExecutionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteScheduledPreloadExecutionWithOptions(request, runtime);
  }

  /**
   * Deletes a specified scheduled prefetch task based on the task ID.
   * 
   * @param request - DeleteScheduledPreloadJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteScheduledPreloadJobResponse
   */
  async deleteScheduledPreloadJobWithOptions(request: DeleteScheduledPreloadJobRequest, runtime: $dara.RuntimeOptions): Promise<DeleteScheduledPreloadJobResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteScheduledPreloadJob",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteScheduledPreloadJobResponse>(await this.callApi(params, req, runtime), new DeleteScheduledPreloadJobResponse({}));
    } else {
      return $dara.cast<DeleteScheduledPreloadJobResponse>(await this.execute(params, req, runtime), new DeleteScheduledPreloadJobResponse({}));
    }

  }

  /**
   * Deletes a specified scheduled prefetch task based on the task ID.
   * 
   * @param request - DeleteScheduledPreloadJobRequest
   * @returns DeleteScheduledPreloadJobResponse
   */
  async deleteScheduledPreloadJob(request: DeleteScheduledPreloadJobRequest): Promise<DeleteScheduledPreloadJobResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteScheduledPreloadJobWithOptions(request, runtime);
  }

  /**
   * Deletes a website based on the specified website ID.
   * 
   * @param request - DeleteSiteRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteSiteResponse
   */
  async deleteSiteWithOptions(request: DeleteSiteRequest, runtime: $dara.RuntimeOptions): Promise<DeleteSiteResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteSite",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteSiteResponse>(await this.callApi(params, req, runtime), new DeleteSiteResponse({}));
    } else {
      return $dara.cast<DeleteSiteResponse>(await this.execute(params, req, runtime), new DeleteSiteResponse({}));
    }

  }

  /**
   * Deletes a website based on the specified website ID.
   * 
   * @param request - DeleteSiteRequest
   * @returns DeleteSiteResponse
   */
  async deleteSite(request: DeleteSiteRequest): Promise<DeleteSiteResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteSiteWithOptions(request, runtime);
  }

  /**
   * Deletes a real-time log delivery task.
   * 
   * @param request - DeleteSiteDeliveryTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteSiteDeliveryTaskResponse
   */
  async deleteSiteDeliveryTaskWithOptions(request: DeleteSiteDeliveryTaskRequest, runtime: $dara.RuntimeOptions): Promise<DeleteSiteDeliveryTaskResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.siteId)) {
      body["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.taskName)) {
      body["TaskName"] = request.taskName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteSiteDeliveryTask",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteSiteDeliveryTaskResponse>(await this.callApi(params, req, runtime), new DeleteSiteDeliveryTaskResponse({}));
    } else {
      return $dara.cast<DeleteSiteDeliveryTaskResponse>(await this.execute(params, req, runtime), new DeleteSiteDeliveryTaskResponse({}));
    }

  }

  /**
   * Deletes a real-time log delivery task.
   * 
   * @param request - DeleteSiteDeliveryTaskRequest
   * @returns DeleteSiteDeliveryTaskResponse
   */
  async deleteSiteDeliveryTask(request: DeleteSiteDeliveryTaskRequest): Promise<DeleteSiteDeliveryTaskResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteSiteDeliveryTaskWithOptions(request, runtime);
  }

  /**
   * Deletes a log delivery task from your Alibaba Cloud account.
   * 
   * @remarks
   * *****> 
   * *   Deleted tasks cannot be restored. Proceed with caution.
   * *   To call this operation, you must have an account that has the required permissions.
   * *   The returned `RequestId` value can be used to track the request processing progress and troubleshoot issues.
   * 
   * @param request - DeleteUserDeliveryTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteUserDeliveryTaskResponse
   */
  async deleteUserDeliveryTaskWithOptions(request: DeleteUserDeliveryTaskRequest, runtime: $dara.RuntimeOptions): Promise<DeleteUserDeliveryTaskResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.taskName)) {
      body["TaskName"] = request.taskName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteUserDeliveryTask",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteUserDeliveryTaskResponse>(await this.callApi(params, req, runtime), new DeleteUserDeliveryTaskResponse({}));
    } else {
      return $dara.cast<DeleteUserDeliveryTaskResponse>(await this.execute(params, req, runtime), new DeleteUserDeliveryTaskResponse({}));
    }

  }

  /**
   * Deletes a log delivery task from your Alibaba Cloud account.
   * 
   * @remarks
   * *****> 
   * *   Deleted tasks cannot be restored. Proceed with caution.
   * *   To call this operation, you must have an account that has the required permissions.
   * *   The returned `RequestId` value can be used to track the request processing progress and troubleshoot issues.
   * 
   * @param request - DeleteUserDeliveryTaskRequest
   * @returns DeleteUserDeliveryTaskResponse
   */
  async deleteUserDeliveryTask(request: DeleteUserDeliveryTaskRequest): Promise<DeleteUserDeliveryTaskResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteUserDeliveryTaskWithOptions(request, runtime);
  }

  /**
   * Deletes a waiting room.
   * 
   * @param request - DeleteWaitingRoomRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteWaitingRoomResponse
   */
  async deleteWaitingRoomWithOptions(request: DeleteWaitingRoomRequest, runtime: $dara.RuntimeOptions): Promise<DeleteWaitingRoomResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.waitingRoomId)) {
      query["WaitingRoomId"] = request.waitingRoomId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteWaitingRoom",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteWaitingRoomResponse>(await this.callApi(params, req, runtime), new DeleteWaitingRoomResponse({}));
    } else {
      return $dara.cast<DeleteWaitingRoomResponse>(await this.execute(params, req, runtime), new DeleteWaitingRoomResponse({}));
    }

  }

  /**
   * Deletes a waiting room.
   * 
   * @param request - DeleteWaitingRoomRequest
   * @returns DeleteWaitingRoomResponse
   */
  async deleteWaitingRoom(request: DeleteWaitingRoomRequest): Promise<DeleteWaitingRoomResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteWaitingRoomWithOptions(request, runtime);
  }

  /**
   * Deletes a waiting room event.
   * 
   * @param request - DeleteWaitingRoomEventRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteWaitingRoomEventResponse
   */
  async deleteWaitingRoomEventWithOptions(request: DeleteWaitingRoomEventRequest, runtime: $dara.RuntimeOptions): Promise<DeleteWaitingRoomEventResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.waitingRoomEventId)) {
      query["WaitingRoomEventId"] = request.waitingRoomEventId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteWaitingRoomEvent",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteWaitingRoomEventResponse>(await this.callApi(params, req, runtime), new DeleteWaitingRoomEventResponse({}));
    } else {
      return $dara.cast<DeleteWaitingRoomEventResponse>(await this.execute(params, req, runtime), new DeleteWaitingRoomEventResponse({}));
    }

  }

  /**
   * Deletes a waiting room event.
   * 
   * @param request - DeleteWaitingRoomEventRequest
   * @returns DeleteWaitingRoomEventResponse
   */
  async deleteWaitingRoomEvent(request: DeleteWaitingRoomEventRequest): Promise<DeleteWaitingRoomEventResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteWaitingRoomEventWithOptions(request, runtime);
  }

  /**
   * Deletes a waiting room bypass rule.
   * 
   * @param request - DeleteWaitingRoomRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteWaitingRoomRuleResponse
   */
  async deleteWaitingRoomRuleWithOptions(request: DeleteWaitingRoomRuleRequest, runtime: $dara.RuntimeOptions): Promise<DeleteWaitingRoomRuleResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.waitingRoomRuleId)) {
      query["WaitingRoomRuleId"] = request.waitingRoomRuleId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DeleteWaitingRoomRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DeleteWaitingRoomRuleResponse>(await this.callApi(params, req, runtime), new DeleteWaitingRoomRuleResponse({}));
    } else {
      return $dara.cast<DeleteWaitingRoomRuleResponse>(await this.execute(params, req, runtime), new DeleteWaitingRoomRuleResponse({}));
    }

  }

  /**
   * Deletes a waiting room bypass rule.
   * 
   * @param request - DeleteWaitingRoomRuleRequest
   * @returns DeleteWaitingRoomRuleResponse
   */
  async deleteWaitingRoomRule(request: DeleteWaitingRoomRuleRequest): Promise<DeleteWaitingRoomRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.deleteWaitingRoomRuleWithOptions(request, runtime);
  }

  /**
   * Queries the configurations of a scenario-specific policy.
   * 
   * @param request - DescribeCustomScenePoliciesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeCustomScenePoliciesResponse
   */
  async describeCustomScenePoliciesWithOptions(request: DescribeCustomScenePoliciesRequest, runtime: $dara.RuntimeOptions): Promise<DescribeCustomScenePoliciesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeCustomScenePolicies",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeCustomScenePoliciesResponse>(await this.callApi(params, req, runtime), new DescribeCustomScenePoliciesResponse({}));
    } else {
      return $dara.cast<DescribeCustomScenePoliciesResponse>(await this.execute(params, req, runtime), new DescribeCustomScenePoliciesResponse({}));
    }

  }

  /**
   * Queries the configurations of a scenario-specific policy.
   * 
   * @param request - DescribeCustomScenePoliciesRequest
   * @returns DescribeCustomScenePoliciesResponse
   */
  async describeCustomScenePolicies(request: DescribeCustomScenePoliciesRequest): Promise<DescribeCustomScenePoliciesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeCustomScenePoliciesWithOptions(request, runtime);
  }

  /**
   * Queries DDoS attack events.
   * 
   * @param request - DescribeDDoSAllEventListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDDoSAllEventListResponse
   */
  async describeDDoSAllEventListWithOptions(request: DescribeDDoSAllEventListRequest, runtime: $dara.RuntimeOptions): Promise<DescribeDDoSAllEventListResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.eventType)) {
      query["EventType"] = request.eventType;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeDDoSAllEventList",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeDDoSAllEventListResponse>(await this.callApi(params, req, runtime), new DescribeDDoSAllEventListResponse({}));
    } else {
      return $dara.cast<DescribeDDoSAllEventListResponse>(await this.execute(params, req, runtime), new DescribeDDoSAllEventListResponse({}));
    }

  }

  /**
   * Queries DDoS attack events.
   * 
   * @param request - DescribeDDoSAllEventListRequest
   * @returns DescribeDDoSAllEventListResponse
   */
  async describeDDoSAllEventList(request: DescribeDDoSAllEventListRequest): Promise<DescribeDDoSAllEventListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeDDoSAllEventListWithOptions(request, runtime);
  }

  /**
   * DCDN DDoSbpspps
   * 
   * @param request - DescribeDDoSBpsListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDDoSBpsListResponse
   */
  async describeDDoSBpsListWithOptions(request: DescribeDDoSBpsListRequest, runtime: $dara.RuntimeOptions): Promise<DescribeDDoSBpsListResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeDDoSBpsList",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeDDoSBpsListResponse>(await this.callApi(params, req, runtime), new DescribeDDoSBpsListResponse({}));
    } else {
      return $dara.cast<DescribeDDoSBpsListResponse>(await this.execute(params, req, runtime), new DescribeDDoSBpsListResponse({}));
    }

  }

  /**
   * DCDN DDoSbpspps
   * 
   * @param request - DescribeDDoSBpsListRequest
   * @returns DescribeDDoSBpsListResponse
   */
  async describeDDoSBpsList(request: DescribeDDoSBpsListRequest): Promise<DescribeDDoSBpsListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeDDoSBpsListWithOptions(request, runtime);
  }

  /**
   * ddosqps
   * 
   * @param request - DescribeDDoSL7QpsListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeDDoSL7QpsListResponse
   */
  async describeDDoSL7QpsListWithOptions(request: DescribeDDoSL7QpsListRequest, runtime: $dara.RuntimeOptions): Promise<DescribeDDoSL7QpsListResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.interval)) {
      query["Interval"] = request.interval;
    }

    if (!$dara.isNull(request.recordId)) {
      query["RecordId"] = request.recordId;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeDDoSL7QpsList",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeDDoSL7QpsListResponse>(await this.callApi(params, req, runtime), new DescribeDDoSL7QpsListResponse({}));
    } else {
      return $dara.cast<DescribeDDoSL7QpsListResponse>(await this.execute(params, req, runtime), new DescribeDDoSL7QpsListResponse({}));
    }

  }

  /**
   * ddosqps
   * 
   * @param request - DescribeDDoSL7QpsListRequest
   * @returns DescribeDDoSL7QpsListResponse
   */
  async describeDDoSL7QpsList(request: DescribeDDoSL7QpsListRequest): Promise<DescribeDDoSL7QpsListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeDDoSL7QpsListWithOptions(request, runtime);
  }

  /**
   * Queries the configuration of smart HTTP DDoS protection for a website.
   * 
   * @param request - DescribeHttpDDoSAttackIntelligentProtectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeHttpDDoSAttackIntelligentProtectionResponse
   */
  async describeHttpDDoSAttackIntelligentProtectionWithOptions(request: DescribeHttpDDoSAttackIntelligentProtectionRequest, runtime: $dara.RuntimeOptions): Promise<DescribeHttpDDoSAttackIntelligentProtectionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeHttpDDoSAttackIntelligentProtection",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeHttpDDoSAttackIntelligentProtectionResponse>(await this.callApi(params, req, runtime), new DescribeHttpDDoSAttackIntelligentProtectionResponse({}));
    } else {
      return $dara.cast<DescribeHttpDDoSAttackIntelligentProtectionResponse>(await this.execute(params, req, runtime), new DescribeHttpDDoSAttackIntelligentProtectionResponse({}));
    }

  }

  /**
   * Queries the configuration of smart HTTP DDoS protection for a website.
   * 
   * @param request - DescribeHttpDDoSAttackIntelligentProtectionRequest
   * @returns DescribeHttpDDoSAttackIntelligentProtectionResponse
   */
  async describeHttpDDoSAttackIntelligentProtection(request: DescribeHttpDDoSAttackIntelligentProtectionRequest): Promise<DescribeHttpDDoSAttackIntelligentProtectionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeHttpDDoSAttackIntelligentProtectionWithOptions(request, runtime);
  }

  /**
   * Queries the configurations of HTTP DDoS attack protection.
   * 
   * @param request - DescribeHttpDDoSAttackProtectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeHttpDDoSAttackProtectionResponse
   */
  async describeHttpDDoSAttackProtectionWithOptions(request: DescribeHttpDDoSAttackProtectionRequest, runtime: $dara.RuntimeOptions): Promise<DescribeHttpDDoSAttackProtectionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeHttpDDoSAttackProtection",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeHttpDDoSAttackProtectionResponse>(await this.callApi(params, req, runtime), new DescribeHttpDDoSAttackProtectionResponse({}));
    } else {
      return $dara.cast<DescribeHttpDDoSAttackProtectionResponse>(await this.execute(params, req, runtime), new DescribeHttpDDoSAttackProtectionResponse({}));
    }

  }

  /**
   * Queries the configurations of HTTP DDoS attack protection.
   * 
   * @param request - DescribeHttpDDoSAttackProtectionRequest
   * @returns DescribeHttpDDoSAttackProtectionResponse
   */
  async describeHttpDDoSAttackProtection(request: DescribeHttpDDoSAttackProtectionRequest): Promise<DescribeHttpDDoSAttackProtectionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeHttpDDoSAttackProtectionWithOptions(request, runtime);
  }

  /**
   * Queries whether Edge KV is activated in your Alibaba Cloud account.
   * 
   * @param request - DescribeKvAccountStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeKvAccountStatusResponse
   */
  async describeKvAccountStatusWithOptions(runtime: $dara.RuntimeOptions): Promise<DescribeKvAccountStatusResponse> {
    let req = new $OpenApiUtil.OpenApiRequest({ });
    let params = new $OpenApiUtil.Params({
      action: "DescribeKvAccountStatus",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeKvAccountStatusResponse>(await this.callApi(params, req, runtime), new DescribeKvAccountStatusResponse({}));
    } else {
      return $dara.cast<DescribeKvAccountStatusResponse>(await this.execute(params, req, runtime), new DescribeKvAccountStatusResponse({}));
    }

  }

  /**
   * Queries whether Edge KV is activated in your Alibaba Cloud account.
   * @returns DescribeKvAccountStatusResponse
   */
  async describeKvAccountStatus(): Promise<DescribeKvAccountStatusResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeKvAccountStatusWithOptions(runtime);
  }

  /**
   * Queries the details of prefetch tasks by time, task status, or prefetch URL.
   * 
   * @param request - DescribePreloadTasksRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePreloadTasksResponse
   */
  async describePreloadTasksWithOptions(request: DescribePreloadTasksRequest, runtime: $dara.RuntimeOptions): Promise<DescribePreloadTasksResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribePreloadTasks",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribePreloadTasksResponse>(await this.callApi(params, req, runtime), new DescribePreloadTasksResponse({}));
    } else {
      return $dara.cast<DescribePreloadTasksResponse>(await this.execute(params, req, runtime), new DescribePreloadTasksResponse({}));
    }

  }

  /**
   * Queries the details of prefetch tasks by time, task status, or prefetch URL.
   * 
   * @param request - DescribePreloadTasksRequest
   * @returns DescribePreloadTasksResponse
   */
  async describePreloadTasks(request: DescribePreloadTasksRequest): Promise<DescribePreloadTasksResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describePreloadTasksWithOptions(request, runtime);
  }

  /**
   * Queries the details of purge tasks.
   * 
   * @param request - DescribePurgeTasksRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribePurgeTasksResponse
   */
  async describePurgeTasksWithOptions(request: DescribePurgeTasksRequest, runtime: $dara.RuntimeOptions): Promise<DescribePurgeTasksResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribePurgeTasks",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribePurgeTasksResponse>(await this.callApi(params, req, runtime), new DescribePurgeTasksResponse({}));
    } else {
      return $dara.cast<DescribePurgeTasksResponse>(await this.execute(params, req, runtime), new DescribePurgeTasksResponse({}));
    }

  }

  /**
   * Queries the details of purge tasks.
   * 
   * @param request - DescribePurgeTasksRequest
   * @returns DescribePurgeTasksResponse
   */
  async describePurgeTasks(request: DescribePurgeTasksRequest): Promise<DescribePurgeTasksResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describePurgeTasksWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - DescribeRatePlanInstanceStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DescribeRatePlanInstanceStatusResponse
   */
  async describeRatePlanInstanceStatusWithOptions(request: DescribeRatePlanInstanceStatusRequest, runtime: $dara.RuntimeOptions): Promise<DescribeRatePlanInstanceStatusResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DescribeRatePlanInstanceStatus",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DescribeRatePlanInstanceStatusResponse>(await this.callApi(params, req, runtime), new DescribeRatePlanInstanceStatusResponse({}));
    } else {
      return $dara.cast<DescribeRatePlanInstanceStatusResponse>(await this.execute(params, req, runtime), new DescribeRatePlanInstanceStatusResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - DescribeRatePlanInstanceStatusRequest
   * @returns DescribeRatePlanInstanceStatusResponse
   */
  async describeRatePlanInstanceStatus(request: DescribeRatePlanInstanceStatusRequest): Promise<DescribeRatePlanInstanceStatusResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.describeRatePlanInstanceStatusWithOptions(request, runtime);
  }

  /**
   * Disables a scenario-specific policy.
   * 
   * @param request - DisableCustomScenePolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DisableCustomScenePolicyResponse
   */
  async disableCustomScenePolicyWithOptions(request: DisableCustomScenePolicyRequest, runtime: $dara.RuntimeOptions): Promise<DisableCustomScenePolicyResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "DisableCustomScenePolicy",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<DisableCustomScenePolicyResponse>(await this.callApi(params, req, runtime), new DisableCustomScenePolicyResponse({}));
    } else {
      return $dara.cast<DisableCustomScenePolicyResponse>(await this.execute(params, req, runtime), new DisableCustomScenePolicyResponse({}));
    }

  }

  /**
   * Disables a scenario-specific policy.
   * 
   * @param request - DisableCustomScenePolicyRequest
   * @returns DisableCustomScenePolicyResponse
   */
  async disableCustomScenePolicy(request: DisableCustomScenePolicyRequest): Promise<DisableCustomScenePolicyResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.disableCustomScenePolicyWithOptions(request, runtime);
  }

  /**
   * Modifies the Web Application Firewall (WAF) configuration of a website, such as the client IP address that is identified by WAF.
   * 
   * @param tmpReq - EditSiteWafSettingsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EditSiteWafSettingsResponse
   */
  async editSiteWafSettingsWithOptions(tmpReq: EditSiteWafSettingsRequest, runtime: $dara.RuntimeOptions): Promise<EditSiteWafSettingsResponse> {
    tmpReq.validate();
    let request = new EditSiteWafSettingsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.settings)) {
      request.settingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.settings, "Settings", "json");
    }

    let query = { };
    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.settingsShrink)) {
      body["Settings"] = request.settingsShrink;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "EditSiteWafSettings",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<EditSiteWafSettingsResponse>(await this.callApi(params, req, runtime), new EditSiteWafSettingsResponse({}));
    } else {
      return $dara.cast<EditSiteWafSettingsResponse>(await this.execute(params, req, runtime), new EditSiteWafSettingsResponse({}));
    }

  }

  /**
   * Modifies the Web Application Firewall (WAF) configuration of a website, such as the client IP address that is identified by WAF.
   * 
   * @param request - EditSiteWafSettingsRequest
   * @returns EditSiteWafSettingsResponse
   */
  async editSiteWafSettings(request: EditSiteWafSettingsRequest): Promise<EditSiteWafSettingsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.editSiteWafSettingsWithOptions(request, runtime);
  }

  /**
   * Enables a scenario-specific policy.
   * 
   * @param request - EnableCustomScenePolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EnableCustomScenePolicyResponse
   */
  async enableCustomScenePolicyWithOptions(request: EnableCustomScenePolicyRequest, runtime: $dara.RuntimeOptions): Promise<EnableCustomScenePolicyResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "EnableCustomScenePolicy",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<EnableCustomScenePolicyResponse>(await this.callApi(params, req, runtime), new EnableCustomScenePolicyResponse({}));
    } else {
      return $dara.cast<EnableCustomScenePolicyResponse>(await this.execute(params, req, runtime), new EnableCustomScenePolicyResponse({}));
    }

  }

  /**
   * Enables a scenario-specific policy.
   * 
   * @param request - EnableCustomScenePolicyRequest
   * @returns EnableCustomScenePolicyResponse
   */
  async enableCustomScenePolicy(request: EnableCustomScenePolicyRequest): Promise<EnableCustomScenePolicyResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.enableCustomScenePolicyWithOptions(request, runtime);
  }

  /**
   * Exports all DNS records of a website domain as a TXT file.
   * 
   * @param request - ExportRecordsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ExportRecordsResponse
   */
  async exportRecordsWithOptions(request: ExportRecordsRequest, runtime: $dara.RuntimeOptions): Promise<ExportRecordsResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ExportRecords",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ExportRecordsResponse>(await this.callApi(params, req, runtime), new ExportRecordsResponse({}));
    } else {
      return $dara.cast<ExportRecordsResponse>(await this.execute(params, req, runtime), new ExportRecordsResponse({}));
    }

  }

  /**
   * Exports all DNS records of a website domain as a TXT file.
   * 
   * @param request - ExportRecordsRequest
   * @returns ExportRecordsResponse
   */
  async exportRecords(request: ExportRecordsRequest): Promise<ExportRecordsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.exportRecordsWithOptions(request, runtime);
  }

  /**
   * Queries the available specifications of cache reserve instances.
   * 
   * @param request - GetCacheReserveSpecificationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetCacheReserveSpecificationResponse
   */
  async getCacheReserveSpecificationWithOptions(runtime: $dara.RuntimeOptions): Promise<GetCacheReserveSpecificationResponse> {
    let req = new $OpenApiUtil.OpenApiRequest({ });
    let params = new $OpenApiUtil.Params({
      action: "GetCacheReserveSpecification",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetCacheReserveSpecificationResponse>(await this.callApi(params, req, runtime), new GetCacheReserveSpecificationResponse({}));
    } else {
      return $dara.cast<GetCacheReserveSpecificationResponse>(await this.execute(params, req, runtime), new GetCacheReserveSpecificationResponse({}));
    }

  }

  /**
   * Queries the available specifications of cache reserve instances.
   * @returns GetCacheReserveSpecificationResponse
   */
  async getCacheReserveSpecification(): Promise<GetCacheReserveSpecificationResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getCacheReserveSpecificationWithOptions(runtime);
  }

  /**
   * 
   * 
   * @param request - GetCacheRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetCacheRuleResponse
   */
  async getCacheRuleWithOptions(request: GetCacheRuleRequest, runtime: $dara.RuntimeOptions): Promise<GetCacheRuleResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetCacheRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetCacheRuleResponse>(await this.callApi(params, req, runtime), new GetCacheRuleResponse({}));
    } else {
      return $dara.cast<GetCacheRuleResponse>(await this.execute(params, req, runtime), new GetCacheRuleResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - GetCacheRuleRequest
   * @returns GetCacheRuleResponse
   */
  async getCacheRule(request: GetCacheRuleRequest): Promise<GetCacheRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getCacheRuleWithOptions(request, runtime);
  }

  /**
   * Queries the cache tag configuration of your website. You can call this operation when you need to specify tags in the Cache-Tag response header to use the purge by cache tag feature.
   * 
   * @param request - GetCacheTagRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetCacheTagResponse
   */
  async getCacheTagWithOptions(request: GetCacheTagRequest, runtime: $dara.RuntimeOptions): Promise<GetCacheTagResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetCacheTag",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetCacheTagResponse>(await this.callApi(params, req, runtime), new GetCacheTagResponse({}));
    } else {
      return $dara.cast<GetCacheTagResponse>(await this.execute(params, req, runtime), new GetCacheTagResponse({}));
    }

  }

  /**
   * Queries the cache tag configuration of your website. You can call this operation when you need to specify tags in the Cache-Tag response header to use the purge by cache tag feature.
   * 
   * @param request - GetCacheTagRequest
   * @returns GetCacheTagResponse
   */
  async getCacheTag(request: GetCacheTagRequest): Promise<GetCacheTagResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getCacheTagWithOptions(request, runtime);
  }

  /**
   * Queries certificate information about a website.
   * 
   * @param request - GetCertificateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetCertificateResponse
   */
  async getCertificateWithOptions(request: GetCertificateRequest, runtime: $dara.RuntimeOptions): Promise<GetCertificateResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetCertificate",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetCertificateResponse>(await this.callApi(params, req, runtime), new GetCertificateResponse({}));
    } else {
      return $dara.cast<GetCertificateResponse>(await this.execute(params, req, runtime), new GetCertificateResponse({}));
    }

  }

  /**
   * Queries certificate information about a website.
   * 
   * @param request - GetCertificateRequest
   * @returns GetCertificateResponse
   */
  async getCertificate(request: GetCertificateRequest): Promise<GetCertificateResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getCertificateWithOptions(request, runtime);
  }

  /**
   * quota
   * 
   * @param request - GetCertificateQuotaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetCertificateQuotaResponse
   */
  async getCertificateQuotaWithOptions(request: GetCertificateQuotaRequest, runtime: $dara.RuntimeOptions): Promise<GetCertificateQuotaResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetCertificateQuota",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetCertificateQuotaResponse>(await this.callApi(params, req, runtime), new GetCertificateQuotaResponse({}));
    } else {
      return $dara.cast<GetCertificateQuotaResponse>(await this.execute(params, req, runtime), new GetCertificateQuotaResponse({}));
    }

  }

  /**
   * quota
   * 
   * @param request - GetCertificateQuotaRequest
   * @returns GetCertificateQuotaResponse
   */
  async getCertificateQuota(request: GetCertificateQuotaRequest): Promise<GetCertificateQuotaResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getCertificateQuotaWithOptions(request, runtime);
  }

  /**
   * CA
   * 
   * @param request - GetClientCaCertificateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetClientCaCertificateResponse
   */
  async getClientCaCertificateWithOptions(request: GetClientCaCertificateRequest, runtime: $dara.RuntimeOptions): Promise<GetClientCaCertificateResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetClientCaCertificate",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetClientCaCertificateResponse>(await this.callApi(params, req, runtime), new GetClientCaCertificateResponse({}));
    } else {
      return $dara.cast<GetClientCaCertificateResponse>(await this.execute(params, req, runtime), new GetClientCaCertificateResponse({}));
    }

  }

  /**
   * CA
   * 
   * @param request - GetClientCaCertificateRequest
   * @returns GetClientCaCertificateResponse
   */
  async getClientCaCertificate(request: GetClientCaCertificateRequest): Promise<GetClientCaCertificateResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getClientCaCertificateWithOptions(request, runtime);
  }

  /**
   * Queries information about a client certificate.
   * 
   * @param request - GetClientCertificateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetClientCertificateResponse
   */
  async getClientCertificateWithOptions(request: GetClientCertificateRequest, runtime: $dara.RuntimeOptions): Promise<GetClientCertificateResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetClientCertificate",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetClientCertificateResponse>(await this.callApi(params, req, runtime), new GetClientCertificateResponse({}));
    } else {
      return $dara.cast<GetClientCertificateResponse>(await this.execute(params, req, runtime), new GetClientCertificateResponse({}));
    }

  }

  /**
   * Queries information about a client certificate.
   * 
   * @param request - GetClientCertificateRequest
   * @returns GetClientCertificateResponse
   */
  async getClientCertificate(request: GetClientCertificateRequest): Promise<GetClientCertificateResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getClientCertificateWithOptions(request, runtime);
  }

  /**
   * Queries domain names associated with a client CA certificate. If no certificate is specified, domain names associated with an Edge Security Acceleration(ESA)-managed CA certificate are returned.
   * 
   * @param request - GetClientCertificateHostnamesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetClientCertificateHostnamesResponse
   */
  async getClientCertificateHostnamesWithOptions(request: GetClientCertificateHostnamesRequest, runtime: $dara.RuntimeOptions): Promise<GetClientCertificateHostnamesResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetClientCertificateHostnames",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetClientCertificateHostnamesResponse>(await this.callApi(params, req, runtime), new GetClientCertificateHostnamesResponse({}));
    } else {
      return $dara.cast<GetClientCertificateHostnamesResponse>(await this.execute(params, req, runtime), new GetClientCertificateHostnamesResponse({}));
    }

  }

  /**
   * Queries domain names associated with a client CA certificate. If no certificate is specified, domain names associated with an Edge Security Acceleration(ESA)-managed CA certificate are returned.
   * 
   * @param request - GetClientCertificateHostnamesRequest
   * @returns GetClientCertificateHostnamesResponse
   */
  async getClientCertificateHostnames(request: GetClientCertificateHostnamesRequest): Promise<GetClientCertificateHostnamesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getClientCertificateHostnamesWithOptions(request, runtime);
  }

  /**
   * Queries the CNAME flattening configuration of a website
   * 
   * @param request - GetCnameFlatteningRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetCnameFlatteningResponse
   */
  async getCnameFlatteningWithOptions(request: GetCnameFlatteningRequest, runtime: $dara.RuntimeOptions): Promise<GetCnameFlatteningResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetCnameFlattening",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetCnameFlatteningResponse>(await this.callApi(params, req, runtime), new GetCnameFlatteningResponse({}));
    } else {
      return $dara.cast<GetCnameFlatteningResponse>(await this.execute(params, req, runtime), new GetCnameFlatteningResponse({}));
    }

  }

  /**
   * Queries the CNAME flattening configuration of a website
   * 
   * @param request - GetCnameFlatteningRequest
   * @returns GetCnameFlatteningResponse
   */
  async getCnameFlattening(request: GetCnameFlatteningRequest): Promise<GetCnameFlatteningResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getCnameFlatteningWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - GetCompressionRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetCompressionRuleResponse
   */
  async getCompressionRuleWithOptions(request: GetCompressionRuleRequest, runtime: $dara.RuntimeOptions): Promise<GetCompressionRuleResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetCompressionRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetCompressionRuleResponse>(await this.callApi(params, req, runtime), new GetCompressionRuleResponse({}));
    } else {
      return $dara.cast<GetCompressionRuleResponse>(await this.execute(params, req, runtime), new GetCompressionRuleResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - GetCompressionRuleRequest
   * @returns GetCompressionRuleResponse
   */
  async getCompressionRule(request: GetCompressionRuleRequest): Promise<GetCompressionRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getCompressionRuleWithOptions(request, runtime);
  }

  /**
   * Queries the development mode configuration of your website.
   * 
   * @param request - GetDevelopmentModeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDevelopmentModeResponse
   */
  async getDevelopmentModeWithOptions(request: GetDevelopmentModeRequest, runtime: $dara.RuntimeOptions): Promise<GetDevelopmentModeResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetDevelopmentMode",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetDevelopmentModeResponse>(await this.callApi(params, req, runtime), new GetDevelopmentModeResponse({}));
    } else {
      return $dara.cast<GetDevelopmentModeResponse>(await this.execute(params, req, runtime), new GetDevelopmentModeResponse({}));
    }

  }

  /**
   * Queries the development mode configuration of your website.
   * 
   * @param request - GetDevelopmentModeRequest
   * @returns GetDevelopmentModeResponse
   */
  async getDevelopmentMode(request: GetDevelopmentModeRequest): Promise<GetDevelopmentModeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getDevelopmentModeWithOptions(request, runtime);
  }

  /**
   * Queries the information about a containerized application, including basic application configurations and health check configurations.
   * 
   * @param request - GetEdgeContainerAppRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetEdgeContainerAppResponse
   */
  async getEdgeContainerAppWithOptions(request: GetEdgeContainerAppRequest, runtime: $dara.RuntimeOptions): Promise<GetEdgeContainerAppResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.appId)) {
      query["AppId"] = request.appId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetEdgeContainerApp",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetEdgeContainerAppResponse>(await this.callApi(params, req, runtime), new GetEdgeContainerAppResponse({}));
    } else {
      return $dara.cast<GetEdgeContainerAppResponse>(await this.execute(params, req, runtime), new GetEdgeContainerAppResponse({}));
    }

  }

  /**
   * Queries the information about a containerized application, including basic application configurations and health check configurations.
   * 
   * @param request - GetEdgeContainerAppRequest
   * @returns GetEdgeContainerAppResponse
   */
  async getEdgeContainerApp(request: GetEdgeContainerAppRequest): Promise<GetEdgeContainerAppResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getEdgeContainerAppWithOptions(request, runtime);
  }

  /**
   * Queries the status information about a containerized application, including the deployment, release, and rollback of the application.
   * 
   * @param request - GetEdgeContainerAppStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetEdgeContainerAppStatusResponse
   */
  async getEdgeContainerAppStatusWithOptions(request: GetEdgeContainerAppStatusRequest, runtime: $dara.RuntimeOptions): Promise<GetEdgeContainerAppStatusResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.appId)) {
      query["AppId"] = request.appId;
    }

    if (!$dara.isNull(request.publishEnv)) {
      query["PublishEnv"] = request.publishEnv;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetEdgeContainerAppStatus",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetEdgeContainerAppStatusResponse>(await this.callApi(params, req, runtime), new GetEdgeContainerAppStatusResponse({}));
    } else {
      return $dara.cast<GetEdgeContainerAppStatusResponse>(await this.execute(params, req, runtime), new GetEdgeContainerAppStatusResponse({}));
    }

  }

  /**
   * Queries the status information about a containerized application, including the deployment, release, and rollback of the application.
   * 
   * @param request - GetEdgeContainerAppStatusRequest
   * @returns GetEdgeContainerAppStatusResponse
   */
  async getEdgeContainerAppStatus(request: GetEdgeContainerAppStatusRequest): Promise<GetEdgeContainerAppStatusResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getEdgeContainerAppStatusWithOptions(request, runtime);
  }

  /**
   * Queries the information about a version of a containerized application. You can select an application version to release based on the version information.
   * 
   * @param request - GetEdgeContainerAppVersionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetEdgeContainerAppVersionResponse
   */
  async getEdgeContainerAppVersionWithOptions(request: GetEdgeContainerAppVersionRequest, runtime: $dara.RuntimeOptions): Promise<GetEdgeContainerAppVersionResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetEdgeContainerAppVersion",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetEdgeContainerAppVersionResponse>(await this.callApi(params, req, runtime), new GetEdgeContainerAppVersionResponse({}));
    } else {
      return $dara.cast<GetEdgeContainerAppVersionResponse>(await this.execute(params, req, runtime), new GetEdgeContainerAppVersionResponse({}));
    }

  }

  /**
   * Queries the information about a version of a containerized application. You can select an application version to release based on the version information.
   * 
   * @param request - GetEdgeContainerAppVersionRequest
   * @returns GetEdgeContainerAppVersionResponse
   */
  async getEdgeContainerAppVersion(request: GetEdgeContainerAppVersionRequest): Promise<GetEdgeContainerAppVersionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getEdgeContainerAppVersionWithOptions(request, runtime);
  }

  /**
   * Queries regions where a containerized application is deployed based on the application ID.
   * 
   * @param request - GetEdgeContainerDeployRegionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetEdgeContainerDeployRegionsResponse
   */
  async getEdgeContainerDeployRegionsWithOptions(request: GetEdgeContainerDeployRegionsRequest, runtime: $dara.RuntimeOptions): Promise<GetEdgeContainerDeployRegionsResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetEdgeContainerDeployRegions",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetEdgeContainerDeployRegionsResponse>(await this.callApi(params, req, runtime), new GetEdgeContainerDeployRegionsResponse({}));
    } else {
      return $dara.cast<GetEdgeContainerDeployRegionsResponse>(await this.execute(params, req, runtime), new GetEdgeContainerDeployRegionsResponse({}));
    }

  }

  /**
   * Queries regions where a containerized application is deployed based on the application ID.
   * 
   * @param request - GetEdgeContainerDeployRegionsRequest
   * @returns GetEdgeContainerDeployRegionsResponse
   */
  async getEdgeContainerDeployRegions(request: GetEdgeContainerDeployRegionsRequest): Promise<GetEdgeContainerDeployRegionsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getEdgeContainerDeployRegionsWithOptions(request, runtime);
  }

  /**
   * Queries Edge Container logs.
   * 
   * @param request - GetEdgeContainerLogsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetEdgeContainerLogsResponse
   */
  async getEdgeContainerLogsWithOptions(request: GetEdgeContainerLogsRequest, runtime: $dara.RuntimeOptions): Promise<GetEdgeContainerLogsResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetEdgeContainerLogs",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetEdgeContainerLogsResponse>(await this.callApi(params, req, runtime), new GetEdgeContainerLogsResponse({}));
    } else {
      return $dara.cast<GetEdgeContainerLogsResponse>(await this.execute(params, req, runtime), new GetEdgeContainerLogsResponse({}));
    }

  }

  /**
   * Queries Edge Container logs.
   * 
   * @param request - GetEdgeContainerLogsRequest
   * @returns GetEdgeContainerLogsResponse
   */
  async getEdgeContainerLogs(request: GetEdgeContainerLogsRequest): Promise<GetEdgeContainerLogsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getEdgeContainerLogsWithOptions(request, runtime);
  }

  /**
   * Queries the deployment status of an application in the staging environment by using the application ID.
   * 
   * @param request - GetEdgeContainerStagingDeployStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetEdgeContainerStagingDeployStatusResponse
   */
  async getEdgeContainerStagingDeployStatusWithOptions(request: GetEdgeContainerStagingDeployStatusRequest, runtime: $dara.RuntimeOptions): Promise<GetEdgeContainerStagingDeployStatusResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetEdgeContainerStagingDeployStatus",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetEdgeContainerStagingDeployStatusResponse>(await this.callApi(params, req, runtime), new GetEdgeContainerStagingDeployStatusResponse({}));
    } else {
      return $dara.cast<GetEdgeContainerStagingDeployStatusResponse>(await this.execute(params, req, runtime), new GetEdgeContainerStagingDeployStatusResponse({}));
    }

  }

  /**
   * Queries the deployment status of an application in the staging environment by using the application ID.
   * 
   * @param request - GetEdgeContainerStagingDeployStatusRequest
   * @returns GetEdgeContainerStagingDeployStatusResponse
   */
  async getEdgeContainerStagingDeployStatus(request: GetEdgeContainerStagingDeployStatusRequest): Promise<GetEdgeContainerStagingDeployStatusResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getEdgeContainerStagingDeployStatusWithOptions(request, runtime);
  }

  /**
   * Queries the terminal information of a containerized application.
   * 
   * @param request - GetEdgeContainerTerminalRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetEdgeContainerTerminalResponse
   */
  async getEdgeContainerTerminalWithOptions(request: GetEdgeContainerTerminalRequest, runtime: $dara.RuntimeOptions): Promise<GetEdgeContainerTerminalResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.appId)) {
      query["AppId"] = request.appId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetEdgeContainerTerminal",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetEdgeContainerTerminalResponse>(await this.callApi(params, req, runtime), new GetEdgeContainerTerminalResponse({}));
    } else {
      return $dara.cast<GetEdgeContainerTerminalResponse>(await this.execute(params, req, runtime), new GetEdgeContainerTerminalResponse({}));
    }

  }

  /**
   * Queries the terminal information of a containerized application.
   * 
   * @param request - GetEdgeContainerTerminalRequest
   * @returns GetEdgeContainerTerminalResponse
   */
  async getEdgeContainerTerminal(request: GetEdgeContainerTerminalRequest): Promise<GetEdgeContainerTerminalResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getEdgeContainerTerminalWithOptions(request, runtime);
  }

  /**
   * Queries the configuration details of an HTTP request header modification rule for a website.
   * 
   * @param request - GetHttpRequestHeaderModificationRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetHttpRequestHeaderModificationRuleResponse
   */
  async getHttpRequestHeaderModificationRuleWithOptions(request: GetHttpRequestHeaderModificationRuleRequest, runtime: $dara.RuntimeOptions): Promise<GetHttpRequestHeaderModificationRuleResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetHttpRequestHeaderModificationRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetHttpRequestHeaderModificationRuleResponse>(await this.callApi(params, req, runtime), new GetHttpRequestHeaderModificationRuleResponse({}));
    } else {
      return $dara.cast<GetHttpRequestHeaderModificationRuleResponse>(await this.execute(params, req, runtime), new GetHttpRequestHeaderModificationRuleResponse({}));
    }

  }

  /**
   * Queries the configuration details of an HTTP request header modification rule for a website.
   * 
   * @param request - GetHttpRequestHeaderModificationRuleRequest
   * @returns GetHttpRequestHeaderModificationRuleResponse
   */
  async getHttpRequestHeaderModificationRule(request: GetHttpRequestHeaderModificationRuleRequest): Promise<GetHttpRequestHeaderModificationRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getHttpRequestHeaderModificationRuleWithOptions(request, runtime);
  }

  /**
   * Queries the configuration details of an HTTP response header modification rule for a website.
   * 
   * @param request - GetHttpResponseHeaderModificationRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetHttpResponseHeaderModificationRuleResponse
   */
  async getHttpResponseHeaderModificationRuleWithOptions(request: GetHttpResponseHeaderModificationRuleRequest, runtime: $dara.RuntimeOptions): Promise<GetHttpResponseHeaderModificationRuleResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetHttpResponseHeaderModificationRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetHttpResponseHeaderModificationRuleResponse>(await this.callApi(params, req, runtime), new GetHttpResponseHeaderModificationRuleResponse({}));
    } else {
      return $dara.cast<GetHttpResponseHeaderModificationRuleResponse>(await this.execute(params, req, runtime), new GetHttpResponseHeaderModificationRuleResponse({}));
    }

  }

  /**
   * Queries the configuration details of an HTTP response header modification rule for a website.
   * 
   * @param request - GetHttpResponseHeaderModificationRuleRequest
   * @returns GetHttpResponseHeaderModificationRuleResponse
   */
  async getHttpResponseHeaderModificationRule(request: GetHttpResponseHeaderModificationRuleRequest): Promise<GetHttpResponseHeaderModificationRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getHttpResponseHeaderModificationRuleWithOptions(request, runtime);
  }

  /**
   * HTTPS
   * 
   * @param request - GetHttpsApplicationConfigurationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetHttpsApplicationConfigurationResponse
   */
  async getHttpsApplicationConfigurationWithOptions(request: GetHttpsApplicationConfigurationRequest, runtime: $dara.RuntimeOptions): Promise<GetHttpsApplicationConfigurationResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetHttpsApplicationConfiguration",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetHttpsApplicationConfigurationResponse>(await this.callApi(params, req, runtime), new GetHttpsApplicationConfigurationResponse({}));
    } else {
      return $dara.cast<GetHttpsApplicationConfigurationResponse>(await this.execute(params, req, runtime), new GetHttpsApplicationConfigurationResponse({}));
    }

  }

  /**
   * HTTPS
   * 
   * @param request - GetHttpsApplicationConfigurationRequest
   * @returns GetHttpsApplicationConfigurationResponse
   */
  async getHttpsApplicationConfiguration(request: GetHttpsApplicationConfigurationRequest): Promise<GetHttpsApplicationConfigurationResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getHttpsApplicationConfigurationWithOptions(request, runtime);
  }

  /**
   * HTTPS
   * 
   * @param request - GetHttpsBasicConfigurationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetHttpsBasicConfigurationResponse
   */
  async getHttpsBasicConfigurationWithOptions(request: GetHttpsBasicConfigurationRequest, runtime: $dara.RuntimeOptions): Promise<GetHttpsBasicConfigurationResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetHttpsBasicConfiguration",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetHttpsBasicConfigurationResponse>(await this.callApi(params, req, runtime), new GetHttpsBasicConfigurationResponse({}));
    } else {
      return $dara.cast<GetHttpsBasicConfigurationResponse>(await this.execute(params, req, runtime), new GetHttpsBasicConfigurationResponse({}));
    }

  }

  /**
   * HTTPS
   * 
   * @param request - GetHttpsBasicConfigurationRequest
   * @returns GetHttpsBasicConfigurationResponse
   */
  async getHttpsBasicConfiguration(request: GetHttpsBasicConfigurationRequest): Promise<GetHttpsBasicConfigurationResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getHttpsBasicConfigurationWithOptions(request, runtime);
  }

  /**
   * IPv6
   * 
   * @param request - GetIPv6Request
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetIPv6Response
   */
  async getIPv6WithOptions(request: GetIPv6Request, runtime: $dara.RuntimeOptions): Promise<GetIPv6Response> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetIPv6",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetIPv6Response>(await this.callApi(params, req, runtime), new GetIPv6Response({}));
    } else {
      return $dara.cast<GetIPv6Response>(await this.execute(params, req, runtime), new GetIPv6Response({}));
    }

  }

  /**
   * IPv6
   * 
   * @param request - GetIPv6Request
   * @returns GetIPv6Response
   */
  async getIPv6(request: GetIPv6Request): Promise<GetIPv6Response> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getIPv6WithOptions(request, runtime);
  }

  /**
   * Queries the configuration of image transformations for a website.
   * 
   * @param request - GetImageTransformRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetImageTransformResponse
   */
  async getImageTransformWithOptions(request: GetImageTransformRequest, runtime: $dara.RuntimeOptions): Promise<GetImageTransformResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetImageTransform",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetImageTransformResponse>(await this.callApi(params, req, runtime), new GetImageTransformResponse({}));
    } else {
      return $dara.cast<GetImageTransformResponse>(await this.execute(params, req, runtime), new GetImageTransformResponse({}));
    }

  }

  /**
   * Queries the configuration of image transformations for a website.
   * 
   * @param request - GetImageTransformRequest
   * @returns GetImageTransformResponse
   */
  async getImageTransform(request: GetImageTransformRequest): Promise<GetImageTransformResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getImageTransformWithOptions(request, runtime);
  }

  /**
   * Queries the value of a key in a key-value pair.
   * 
   * @param request - GetKvRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetKvResponse
   */
  async getKvWithOptions(request: GetKvRequest, runtime: $dara.RuntimeOptions): Promise<GetKvResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetKv",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetKvResponse>(await this.callApi(params, req, runtime), new GetKvResponse({}));
    } else {
      return $dara.cast<GetKvResponse>(await this.execute(params, req, runtime), new GetKvResponse({}));
    }

  }

  /**
   * Queries the value of a key in a key-value pair.
   * 
   * @param request - GetKvRequest
   * @returns GetKvResponse
   */
  async getKv(request: GetKvRequest): Promise<GetKvResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getKvWithOptions(request, runtime);
  }

  /**
   * Queries the Edge KV usage in your Alibaba Cloud account, including the information about all namespaces.
   * 
   * @param request - GetKvAccountRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetKvAccountResponse
   */
  async getKvAccountWithOptions(runtime: $dara.RuntimeOptions): Promise<GetKvAccountResponse> {
    let req = new $OpenApiUtil.OpenApiRequest({ });
    let params = new $OpenApiUtil.Params({
      action: "GetKvAccount",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetKvAccountResponse>(await this.callApi(params, req, runtime), new GetKvAccountResponse({}));
    } else {
      return $dara.cast<GetKvAccountResponse>(await this.execute(params, req, runtime), new GetKvAccountResponse({}));
    }

  }

  /**
   * Queries the Edge KV usage in your Alibaba Cloud account, including the information about all namespaces.
   * @returns GetKvAccountResponse
   */
  async getKvAccount(): Promise<GetKvAccountResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getKvAccountWithOptions(runtime);
  }

  /**
   * Queries the information about a namespace in your Alibaba Cloud account.
   * 
   * @param request - GetKvNamespaceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetKvNamespaceResponse
   */
  async getKvNamespaceWithOptions(request: GetKvNamespaceRequest, runtime: $dara.RuntimeOptions): Promise<GetKvNamespaceResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetKvNamespace",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetKvNamespaceResponse>(await this.callApi(params, req, runtime), new GetKvNamespaceResponse({}));
    } else {
      return $dara.cast<GetKvNamespaceResponse>(await this.execute(params, req, runtime), new GetKvNamespaceResponse({}));
    }

  }

  /**
   * Queries the information about a namespace in your Alibaba Cloud account.
   * 
   * @param request - GetKvNamespaceRequest
   * @returns GetKvNamespaceResponse
   */
  async getKvNamespace(request: GetKvNamespaceRequest): Promise<GetKvNamespaceResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getKvNamespaceWithOptions(request, runtime);
  }

  /**
   * Queries the details of a custom list, such as the name, description, type, and content.
   * 
   * @param request - GetListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetListResponse
   */
  async getListWithOptions(request: GetListRequest, runtime: $dara.RuntimeOptions): Promise<GetListResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetList",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetListResponse>(await this.callApi(params, req, runtime), new GetListResponse({}));
    } else {
      return $dara.cast<GetListResponse>(await this.execute(params, req, runtime), new GetListResponse({}));
    }

  }

  /**
   * Queries the details of a custom list, such as the name, description, type, and content.
   * 
   * @param request - GetListRequest
   * @returns GetListResponse
   */
  async getList(request: GetListRequest): Promise<GetListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getListWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - GetLoadBalancerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetLoadBalancerResponse
   */
  async getLoadBalancerWithOptions(request: GetLoadBalancerRequest, runtime: $dara.RuntimeOptions): Promise<GetLoadBalancerResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetLoadBalancer",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetLoadBalancerResponse>(await this.callApi(params, req, runtime), new GetLoadBalancerResponse({}));
    } else {
      return $dara.cast<GetLoadBalancerResponse>(await this.execute(params, req, runtime), new GetLoadBalancerResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - GetLoadBalancerRequest
   * @returns GetLoadBalancerResponse
   */
  async getLoadBalancer(request: GetLoadBalancerRequest): Promise<GetLoadBalancerResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getLoadBalancerWithOptions(request, runtime);
  }

  /**
   * Query the configuration of managed transforms for your website.
   * 
   * @param request - GetManagedTransformRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetManagedTransformResponse
   */
  async getManagedTransformWithOptions(request: GetManagedTransformRequest, runtime: $dara.RuntimeOptions): Promise<GetManagedTransformResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetManagedTransform",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetManagedTransformResponse>(await this.callApi(params, req, runtime), new GetManagedTransformResponse({}));
    } else {
      return $dara.cast<GetManagedTransformResponse>(await this.execute(params, req, runtime), new GetManagedTransformResponse({}));
    }

  }

  /**
   * Query the configuration of managed transforms for your website.
   * 
   * @param request - GetManagedTransformRequest
   * @returns GetManagedTransformResponse
   */
  async getManagedTransform(request: GetManagedTransformRequest): Promise<GetManagedTransformResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getManagedTransformWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - GetNetworkOptimizationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetNetworkOptimizationResponse
   */
  async getNetworkOptimizationWithOptions(request: GetNetworkOptimizationRequest, runtime: $dara.RuntimeOptions): Promise<GetNetworkOptimizationResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetNetworkOptimization",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetNetworkOptimizationResponse>(await this.callApi(params, req, runtime), new GetNetworkOptimizationResponse({}));
    } else {
      return $dara.cast<GetNetworkOptimizationResponse>(await this.execute(params, req, runtime), new GetNetworkOptimizationResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - GetNetworkOptimizationRequest
   * @returns GetNetworkOptimizationResponse
   */
  async getNetworkOptimization(request: GetNetworkOptimizationRequest): Promise<GetNetworkOptimizationResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getNetworkOptimizationWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - GetOriginPoolRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetOriginPoolResponse
   */
  async getOriginPoolWithOptions(request: GetOriginPoolRequest, runtime: $dara.RuntimeOptions): Promise<GetOriginPoolResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetOriginPool",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetOriginPoolResponse>(await this.callApi(params, req, runtime), new GetOriginPoolResponse({}));
    } else {
      return $dara.cast<GetOriginPoolResponse>(await this.execute(params, req, runtime), new GetOriginPoolResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - GetOriginPoolRequest
   * @returns GetOriginPoolResponse
   */
  async getOriginPool(request: GetOriginPoolRequest): Promise<GetOriginPoolResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getOriginPoolWithOptions(request, runtime);
  }

  /**
   * Queries the origin protection configurations of a website, including the origin protection, IP convergence, and the status and details of the IP whitelist for origin protection. The details includes the IP whitelist used by the website, the latest IP whitelist, and the differences between them.
   * 
   * @param request - GetOriginProtectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetOriginProtectionResponse
   */
  async getOriginProtectionWithOptions(request: GetOriginProtectionRequest, runtime: $dara.RuntimeOptions): Promise<GetOriginProtectionResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetOriginProtection",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetOriginProtectionResponse>(await this.callApi(params, req, runtime), new GetOriginProtectionResponse({}));
    } else {
      return $dara.cast<GetOriginProtectionResponse>(await this.execute(params, req, runtime), new GetOriginProtectionResponse({}));
    }

  }

  /**
   * Queries the origin protection configurations of a website, including the origin protection, IP convergence, and the status and details of the IP whitelist for origin protection. The details includes the IP whitelist used by the website, the latest IP whitelist, and the differences between them.
   * 
   * @param request - GetOriginProtectionRequest
   * @returns GetOriginProtectionResponse
   */
  async getOriginProtection(request: GetOriginProtectionRequest): Promise<GetOriginProtectionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getOriginProtectionWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - GetOriginRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetOriginRuleResponse
   */
  async getOriginRuleWithOptions(request: GetOriginRuleRequest, runtime: $dara.RuntimeOptions): Promise<GetOriginRuleResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetOriginRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetOriginRuleResponse>(await this.callApi(params, req, runtime), new GetOriginRuleResponse({}));
    } else {
      return $dara.cast<GetOriginRuleResponse>(await this.execute(params, req, runtime), new GetOriginRuleResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - GetOriginRuleRequest
   * @returns GetOriginRuleResponse
   */
  async getOriginRule(request: GetOriginRuleRequest): Promise<GetOriginRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getOriginRuleWithOptions(request, runtime);
  }

  /**
   * Queries the details of a custom error page based on the error page ID.
   * 
   * @param request - GetPageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetPageResponse
   */
  async getPageWithOptions(request: GetPageRequest, runtime: $dara.RuntimeOptions): Promise<GetPageResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetPage",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetPageResponse>(await this.callApi(params, req, runtime), new GetPageResponse({}));
    } else {
      return $dara.cast<GetPageResponse>(await this.execute(params, req, runtime), new GetPageResponse({}));
    }

  }

  /**
   * Queries the details of a custom error page based on the error page ID.
   * 
   * @param request - GetPageRequest
   * @returns GetPageResponse
   */
  async getPage(request: GetPageRequest): Promise<GetPageResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getPageWithOptions(request, runtime);
  }

  /**
   * Queries the quotas and quota usage for different cache purge options.
   * 
   * @param request - GetPurgeQuotaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetPurgeQuotaResponse
   */
  async getPurgeQuotaWithOptions(request: GetPurgeQuotaRequest, runtime: $dara.RuntimeOptions): Promise<GetPurgeQuotaResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetPurgeQuota",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetPurgeQuotaResponse>(await this.callApi(params, req, runtime), new GetPurgeQuotaResponse({}));
    } else {
      return $dara.cast<GetPurgeQuotaResponse>(await this.execute(params, req, runtime), new GetPurgeQuotaResponse({}));
    }

  }

  /**
   * Queries the quotas and quota usage for different cache purge options.
   * 
   * @param request - GetPurgeQuotaRequest
   * @returns GetPurgeQuotaResponse
   */
  async getPurgeQuota(request: GetPurgeQuotaRequest): Promise<GetPurgeQuotaResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getPurgeQuotaWithOptions(request, runtime);
  }

  /**
   * Queries the fields in real-time logs based on the log category.
   * 
   * @param request - GetRealtimeDeliveryFieldRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRealtimeDeliveryFieldResponse
   */
  async getRealtimeDeliveryFieldWithOptions(request: GetRealtimeDeliveryFieldRequest, runtime: $dara.RuntimeOptions): Promise<GetRealtimeDeliveryFieldResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetRealtimeDeliveryField",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetRealtimeDeliveryFieldResponse>(await this.callApi(params, req, runtime), new GetRealtimeDeliveryFieldResponse({}));
    } else {
      return $dara.cast<GetRealtimeDeliveryFieldResponse>(await this.execute(params, req, runtime), new GetRealtimeDeliveryFieldResponse({}));
    }

  }

  /**
   * Queries the fields in real-time logs based on the log category.
   * 
   * @param request - GetRealtimeDeliveryFieldRequest
   * @returns GetRealtimeDeliveryFieldResponse
   */
  async getRealtimeDeliveryField(request: GetRealtimeDeliveryFieldRequest): Promise<GetRealtimeDeliveryFieldResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getRealtimeDeliveryFieldWithOptions(request, runtime);
  }

  /**
   * Queries the configuration of a single DNS record, such as the record value, priority, and origin authentication setting (exclusive to CNAME records).
   * 
   * @param request - GetRecordRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRecordResponse
   */
  async getRecordWithOptions(request: GetRecordRequest, runtime: $dara.RuntimeOptions): Promise<GetRecordResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetRecord",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetRecordResponse>(await this.callApi(params, req, runtime), new GetRecordResponse({}));
    } else {
      return $dara.cast<GetRecordResponse>(await this.execute(params, req, runtime), new GetRecordResponse({}));
    }

  }

  /**
   * Queries the configuration of a single DNS record, such as the record value, priority, and origin authentication setting (exclusive to CNAME records).
   * 
   * @param request - GetRecordRequest
   * @returns GetRecordResponse
   */
  async getRecord(request: GetRecordRequest): Promise<GetRecordResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getRecordWithOptions(request, runtime);
  }

  /**
   * Queries the configuration details of a URL redirect rule for a website.
   * 
   * @param request - GetRedirectRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRedirectRuleResponse
   */
  async getRedirectRuleWithOptions(request: GetRedirectRuleRequest, runtime: $dara.RuntimeOptions): Promise<GetRedirectRuleResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetRedirectRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetRedirectRuleResponse>(await this.callApi(params, req, runtime), new GetRedirectRuleResponse({}));
    } else {
      return $dara.cast<GetRedirectRuleResponse>(await this.execute(params, req, runtime), new GetRedirectRuleResponse({}));
    }

  }

  /**
   * Queries the configuration details of a URL redirect rule for a website.
   * 
   * @param request - GetRedirectRuleRequest
   * @returns GetRedirectRuleResponse
   */
  async getRedirectRule(request: GetRedirectRuleRequest): Promise<GetRedirectRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getRedirectRuleWithOptions(request, runtime);
  }

  /**
   * Queries the configuration details of a URL rewrite rule.
   * 
   * @param request - GetRewriteUrlRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRewriteUrlRuleResponse
   */
  async getRewriteUrlRuleWithOptions(request: GetRewriteUrlRuleRequest, runtime: $dara.RuntimeOptions): Promise<GetRewriteUrlRuleResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetRewriteUrlRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetRewriteUrlRuleResponse>(await this.callApi(params, req, runtime), new GetRewriteUrlRuleResponse({}));
    } else {
      return $dara.cast<GetRewriteUrlRuleResponse>(await this.execute(params, req, runtime), new GetRewriteUrlRuleResponse({}));
    }

  }

  /**
   * Queries the configuration details of a URL rewrite rule.
   * 
   * @param request - GetRewriteUrlRuleRequest
   * @returns GetRewriteUrlRuleResponse
   */
  async getRewriteUrlRule(request: GetRewriteUrlRuleRequest): Promise<GetRewriteUrlRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getRewriteUrlRuleWithOptions(request, runtime);
  }

  /**
   * Queries the configurations of a routine, including the code versions and the configurations of the environments, associated domain names, and associated routes.
   * 
   * @param request - GetRoutineRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRoutineResponse
   */
  async getRoutineWithOptions(request: GetRoutineRequest, runtime: $dara.RuntimeOptions): Promise<GetRoutineResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetRoutine",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetRoutineResponse>(await this.callApi(params, req, runtime), new GetRoutineResponse({}));
    } else {
      return $dara.cast<GetRoutineResponse>(await this.execute(params, req, runtime), new GetRoutineResponse({}));
    }

  }

  /**
   * Queries the configurations of a routine, including the code versions and the configurations of the environments, associated domain names, and associated routes.
   * 
   * @param request - GetRoutineRequest
   * @returns GetRoutineResponse
   */
  async getRoutine(request: GetRoutineRequest): Promise<GetRoutineResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getRoutineWithOptions(request, runtime);
  }

  /**
   * Obtains the release information about the routine code that is released to the staging environment. This information can be used to upload the test code to Object Storage Service (OSS).
   * 
   * @remarks
   *   Every time the code of a routine is released to the staging environment, a version number is generated. Such code is for tests only.
   * *   A routine can retain a maximum of 10 code versions. If the number of versions reaches the limit, you must call the DeleteRoutineCodeRevision operation to delete unwanted versions.
   * 
   * @param request - GetRoutineStagingCodeUploadInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRoutineStagingCodeUploadInfoResponse
   */
  async getRoutineStagingCodeUploadInfoWithOptions(request: GetRoutineStagingCodeUploadInfoRequest, runtime: $dara.RuntimeOptions): Promise<GetRoutineStagingCodeUploadInfoResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.codeDescription)) {
      body["CodeDescription"] = request.codeDescription;
    }

    if (!$dara.isNull(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetRoutineStagingCodeUploadInfo",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetRoutineStagingCodeUploadInfoResponse>(await this.callApi(params, req, runtime), new GetRoutineStagingCodeUploadInfoResponse({}));
    } else {
      return $dara.cast<GetRoutineStagingCodeUploadInfoResponse>(await this.execute(params, req, runtime), new GetRoutineStagingCodeUploadInfoResponse({}));
    }

  }

  /**
   * Obtains the release information about the routine code that is released to the staging environment. This information can be used to upload the test code to Object Storage Service (OSS).
   * 
   * @remarks
   *   Every time the code of a routine is released to the staging environment, a version number is generated. Such code is for tests only.
   * *   A routine can retain a maximum of 10 code versions. If the number of versions reaches the limit, you must call the DeleteRoutineCodeRevision operation to delete unwanted versions.
   * 
   * @param request - GetRoutineStagingCodeUploadInfoRequest
   * @returns GetRoutineStagingCodeUploadInfoResponse
   */
  async getRoutineStagingCodeUploadInfo(request: GetRoutineStagingCodeUploadInfoRequest): Promise<GetRoutineStagingCodeUploadInfoResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getRoutineStagingCodeUploadInfoWithOptions(request, runtime);
  }

  /**
   * Queries the IP addresses of staging environments for Edge Routine.
   * 
   * @param request - GetRoutineStagingEnvIpRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRoutineStagingEnvIpResponse
   */
  async getRoutineStagingEnvIpWithOptions(runtime: $dara.RuntimeOptions): Promise<GetRoutineStagingEnvIpResponse> {
    let req = new $OpenApiUtil.OpenApiRequest({ });
    let params = new $OpenApiUtil.Params({
      action: "GetRoutineStagingEnvIp",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetRoutineStagingEnvIpResponse>(await this.callApi(params, req, runtime), new GetRoutineStagingEnvIpResponse({}));
    } else {
      return $dara.cast<GetRoutineStagingEnvIpResponse>(await this.execute(params, req, runtime), new GetRoutineStagingEnvIpResponse({}));
    }

  }

  /**
   * Queries the IP addresses of staging environments for Edge Routine.
   * @returns GetRoutineStagingEnvIpResponse
   */
  async getRoutineStagingEnvIp(): Promise<GetRoutineStagingEnvIpResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getRoutineStagingEnvIpWithOptions(runtime);
  }

  /**
   * Queries the Edge Routine information in your Alibaba Cloud account, including the associated subdomain and created routines.
   * 
   * @param request - GetRoutineUserInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRoutineUserInfoResponse
   */
  async getRoutineUserInfoWithOptions(runtime: $dara.RuntimeOptions): Promise<GetRoutineUserInfoResponse> {
    let req = new $OpenApiUtil.OpenApiRequest({ });
    let params = new $OpenApiUtil.Params({
      action: "GetRoutineUserInfo",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetRoutineUserInfoResponse>(await this.callApi(params, req, runtime), new GetRoutineUserInfoResponse({}));
    } else {
      return $dara.cast<GetRoutineUserInfoResponse>(await this.execute(params, req, runtime), new GetRoutineUserInfoResponse({}));
    }

  }

  /**
   * Queries the Edge Routine information in your Alibaba Cloud account, including the associated subdomain and created routines.
   * @returns GetRoutineUserInfoResponse
   */
  async getRoutineUserInfo(): Promise<GetRoutineUserInfoResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getRoutineUserInfoWithOptions(runtime);
  }

  /**
   * Queries a specified scheduled prefetch task based on the task ID.
   * 
   * @param request - GetScheduledPreloadJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetScheduledPreloadJobResponse
   */
  async getScheduledPreloadJobWithOptions(request: GetScheduledPreloadJobRequest, runtime: $dara.RuntimeOptions): Promise<GetScheduledPreloadJobResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetScheduledPreloadJob",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetScheduledPreloadJobResponse>(await this.callApi(params, req, runtime), new GetScheduledPreloadJobResponse({}));
    } else {
      return $dara.cast<GetScheduledPreloadJobResponse>(await this.execute(params, req, runtime), new GetScheduledPreloadJobResponse({}));
    }

  }

  /**
   * Queries a specified scheduled prefetch task based on the task ID.
   * 
   * @param request - GetScheduledPreloadJobRequest
   * @returns GetScheduledPreloadJobResponse
   */
  async getScheduledPreloadJob(request: GetScheduledPreloadJobRequest): Promise<GetScheduledPreloadJobResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getScheduledPreloadJobWithOptions(request, runtime);
  }

  /**
   * Queries the configuration for search engine crawler of a website.
   * 
   * @param request - GetSeoBypassRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetSeoBypassResponse
   */
  async getSeoBypassWithOptions(request: GetSeoBypassRequest, runtime: $dara.RuntimeOptions): Promise<GetSeoBypassResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetSeoBypass",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetSeoBypassResponse>(await this.callApi(params, req, runtime), new GetSeoBypassResponse({}));
    } else {
      return $dara.cast<GetSeoBypassResponse>(await this.execute(params, req, runtime), new GetSeoBypassResponse({}));
    }

  }

  /**
   * Queries the configuration for search engine crawler of a website.
   * 
   * @param request - GetSeoBypassRequest
   * @returns GetSeoBypassResponse
   */
  async getSeoBypass(request: GetSeoBypassRequest): Promise<GetSeoBypassResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getSeoBypassWithOptions(request, runtime);
  }

  /**
   * Queries information about a website based on the website ID.
   * 
   * @param request - GetSiteRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetSiteResponse
   */
  async getSiteWithOptions(request: GetSiteRequest, runtime: $dara.RuntimeOptions): Promise<GetSiteResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetSite",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetSiteResponse>(await this.callApi(params, req, runtime), new GetSiteResponse({}));
    } else {
      return $dara.cast<GetSiteResponse>(await this.execute(params, req, runtime), new GetSiteResponse({}));
    }

  }

  /**
   * Queries information about a website based on the website ID.
   * 
   * @param request - GetSiteRequest
   * @returns GetSiteResponse
   */
  async getSite(request: GetSiteRequest): Promise<GetSiteResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getSiteWithOptions(request, runtime);
  }

  /**
   * Queries the nameservers configured for a website.
   * 
   * @param request - GetSiteCurrentNSRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetSiteCurrentNSResponse
   */
  async getSiteCurrentNSWithOptions(request: GetSiteCurrentNSRequest, runtime: $dara.RuntimeOptions): Promise<GetSiteCurrentNSResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetSiteCurrentNS",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetSiteCurrentNSResponse>(await this.callApi(params, req, runtime), new GetSiteCurrentNSResponse({}));
    } else {
      return $dara.cast<GetSiteCurrentNSResponse>(await this.execute(params, req, runtime), new GetSiteCurrentNSResponse({}));
    }

  }

  /**
   * Queries the nameservers configured for a website.
   * 
   * @param request - GetSiteCurrentNSRequest
   * @returns GetSiteCurrentNSResponse
   */
  async getSiteCurrentNS(request: GetSiteCurrentNSRequest): Promise<GetSiteCurrentNSResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getSiteCurrentNSWithOptions(request, runtime);
  }

  /**
   * Queries the configuration of custom log fields for a website.
   * 
   * @remarks
   *   **Description**: You can call this operation to query the configuration of custom log fields for a website, including custom fields in request headers, response headers, and cookies.
   * *   **Scenarios**: You can call this operation in scenarios where you need to obtain specific HTTP headers or cookie information for log analysis.
   * *   ****
   * 
   * @param request - GetSiteCustomLogRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetSiteCustomLogResponse
   */
  async getSiteCustomLogWithOptions(request: GetSiteCustomLogRequest, runtime: $dara.RuntimeOptions): Promise<GetSiteCustomLogResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetSiteCustomLog",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetSiteCustomLogResponse>(await this.callApi(params, req, runtime), new GetSiteCustomLogResponse({}));
    } else {
      return $dara.cast<GetSiteCustomLogResponse>(await this.execute(params, req, runtime), new GetSiteCustomLogResponse({}));
    }

  }

  /**
   * Queries the configuration of custom log fields for a website.
   * 
   * @remarks
   *   **Description**: You can call this operation to query the configuration of custom log fields for a website, including custom fields in request headers, response headers, and cookies.
   * *   **Scenarios**: You can call this operation in scenarios where you need to obtain specific HTTP headers or cookie information for log analysis.
   * *   ****
   * 
   * @param request - GetSiteCustomLogRequest
   * @returns GetSiteCustomLogResponse
   */
  async getSiteCustomLog(request: GetSiteCustomLogRequest): Promise<GetSiteCustomLogResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getSiteCustomLogWithOptions(request, runtime);
  }

  /**
   * Queries a real-time log delivery task.
   * 
   * @param request - GetSiteDeliveryTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetSiteDeliveryTaskResponse
   */
  async getSiteDeliveryTaskWithOptions(request: GetSiteDeliveryTaskRequest, runtime: $dara.RuntimeOptions): Promise<GetSiteDeliveryTaskResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetSiteDeliveryTask",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetSiteDeliveryTaskResponse>(await this.callApi(params, req, runtime), new GetSiteDeliveryTaskResponse({}));
    } else {
      return $dara.cast<GetSiteDeliveryTaskResponse>(await this.execute(params, req, runtime), new GetSiteDeliveryTaskResponse({}));
    }

  }

  /**
   * Queries a real-time log delivery task.
   * 
   * @param request - GetSiteDeliveryTaskRequest
   * @returns GetSiteDeliveryTaskResponse
   */
  async getSiteDeliveryTask(request: GetSiteDeliveryTaskRequest): Promise<GetSiteDeliveryTaskResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getSiteDeliveryTaskWithOptions(request, runtime);
  }

  /**
   * Queries the remaining quota for delivering a specific category of real-time logs in a website.
   * 
   * @remarks
   * You can call this operation to query the remaining quota for delivering a specific category of real-time logs in a website within an Alibaba Cloud account. This is essential for monitoring and managing your log delivery capacity to ensure that logs can be delivered to the destination and prevent data loss or latency caused by insufficient quota.
   * **Take note of the following parameters:**
   * *   ``
   * *   `BusinessType` is required. You must specify a log category to obtain the corresponding quota information.
   * *   `SiteId` specifies the ID of a website, which must be a valid integer that corresponds to a website that you configured on Alibaba Cloud.
   * **Response:**
   * *   If a request is successful, the system returns the remaining log delivery quota (`FreeQuota`), request ID (`RequestId`), website ID (`SiteId`), and log category (`BusinessType`). You can confirm and record the returned data.
   * 
   * @param request - GetSiteLogDeliveryQuotaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetSiteLogDeliveryQuotaResponse
   */
  async getSiteLogDeliveryQuotaWithOptions(request: GetSiteLogDeliveryQuotaRequest, runtime: $dara.RuntimeOptions): Promise<GetSiteLogDeliveryQuotaResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetSiteLogDeliveryQuota",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetSiteLogDeliveryQuotaResponse>(await this.callApi(params, req, runtime), new GetSiteLogDeliveryQuotaResponse({}));
    } else {
      return $dara.cast<GetSiteLogDeliveryQuotaResponse>(await this.execute(params, req, runtime), new GetSiteLogDeliveryQuotaResponse({}));
    }

  }

  /**
   * Queries the remaining quota for delivering a specific category of real-time logs in a website.
   * 
   * @remarks
   * You can call this operation to query the remaining quota for delivering a specific category of real-time logs in a website within an Alibaba Cloud account. This is essential for monitoring and managing your log delivery capacity to ensure that logs can be delivered to the destination and prevent data loss or latency caused by insufficient quota.
   * **Take note of the following parameters:**
   * *   ``
   * *   `BusinessType` is required. You must specify a log category to obtain the corresponding quota information.
   * *   `SiteId` specifies the ID of a website, which must be a valid integer that corresponds to a website that you configured on Alibaba Cloud.
   * **Response:**
   * *   If a request is successful, the system returns the remaining log delivery quota (`FreeQuota`), request ID (`RequestId`), website ID (`SiteId`), and log category (`BusinessType`). You can confirm and record the returned data.
   * 
   * @param request - GetSiteLogDeliveryQuotaRequest
   * @returns GetSiteLogDeliveryQuotaResponse
   */
  async getSiteLogDeliveryQuota(request: GetSiteLogDeliveryQuotaRequest): Promise<GetSiteLogDeliveryQuotaResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getSiteLogDeliveryQuotaWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - GetSiteNameExclusiveRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetSiteNameExclusiveResponse
   */
  async getSiteNameExclusiveWithOptions(request: GetSiteNameExclusiveRequest, runtime: $dara.RuntimeOptions): Promise<GetSiteNameExclusiveResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetSiteNameExclusive",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetSiteNameExclusiveResponse>(await this.callApi(params, req, runtime), new GetSiteNameExclusiveResponse({}));
    } else {
      return $dara.cast<GetSiteNameExclusiveResponse>(await this.execute(params, req, runtime), new GetSiteNameExclusiveResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - GetSiteNameExclusiveRequest
   * @returns GetSiteNameExclusiveResponse
   */
  async getSiteNameExclusive(request: GetSiteNameExclusiveRequest): Promise<GetSiteNameExclusiveResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getSiteNameExclusiveWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - GetSitePauseRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetSitePauseResponse
   */
  async getSitePauseWithOptions(request: GetSitePauseRequest, runtime: $dara.RuntimeOptions): Promise<GetSitePauseResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetSitePause",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetSitePauseResponse>(await this.callApi(params, req, runtime), new GetSitePauseResponse({}));
    } else {
      return $dara.cast<GetSitePauseResponse>(await this.execute(params, req, runtime), new GetSitePauseResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - GetSitePauseRequest
   * @returns GetSitePauseResponse
   */
  async getSitePause(request: GetSitePauseRequest): Promise<GetSitePauseResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getSitePauseWithOptions(request, runtime);
  }

  /**
   * Queries the Web Application Firewall (WAF) configurations of a website.
   * 
   * @param request - GetSiteWafSettingsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetSiteWafSettingsResponse
   */
  async getSiteWafSettingsWithOptions(request: GetSiteWafSettingsRequest, runtime: $dara.RuntimeOptions): Promise<GetSiteWafSettingsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.path)) {
      query["Path"] = request.path;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetSiteWafSettings",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetSiteWafSettingsResponse>(await this.callApi(params, req, runtime), new GetSiteWafSettingsResponse({}));
    } else {
      return $dara.cast<GetSiteWafSettingsResponse>(await this.execute(params, req, runtime), new GetSiteWafSettingsResponse({}));
    }

  }

  /**
   * Queries the Web Application Firewall (WAF) configurations of a website.
   * 
   * @param request - GetSiteWafSettingsRequest
   * @returns GetSiteWafSettingsResponse
   */
  async getSiteWafSettings(request: GetSiteWafSettingsRequest): Promise<GetSiteWafSettingsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getSiteWafSettingsWithOptions(request, runtime);
  }

  /**
   * Queries the tiered cache configuration of your website.
   * 
   * @param request - GetTieredCacheRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetTieredCacheResponse
   */
  async getTieredCacheWithOptions(request: GetTieredCacheRequest, runtime: $dara.RuntimeOptions): Promise<GetTieredCacheResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetTieredCache",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetTieredCacheResponse>(await this.callApi(params, req, runtime), new GetTieredCacheResponse({}));
    } else {
      return $dara.cast<GetTieredCacheResponse>(await this.execute(params, req, runtime), new GetTieredCacheResponse({}));
    }

  }

  /**
   * Queries the tiered cache configuration of your website.
   * 
   * @param request - GetTieredCacheRequest
   * @returns GetTieredCacheResponse
   */
  async getTieredCache(request: GetTieredCacheRequest): Promise<GetTieredCacheResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getTieredCacheWithOptions(request, runtime);
  }

  /**
   * Queries the execution status and running information of a file upload task based on the task ID.
   * 
   * @param request - GetUploadTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetUploadTaskResponse
   */
  async getUploadTaskWithOptions(request: GetUploadTaskRequest, runtime: $dara.RuntimeOptions): Promise<GetUploadTaskResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetUploadTask",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetUploadTaskResponse>(await this.callApi(params, req, runtime), new GetUploadTaskResponse({}));
    } else {
      return $dara.cast<GetUploadTaskResponse>(await this.execute(params, req, runtime), new GetUploadTaskResponse({}));
    }

  }

  /**
   * Queries the execution status and running information of a file upload task based on the task ID.
   * 
   * @param request - GetUploadTaskRequest
   * @returns GetUploadTaskResponse
   */
  async getUploadTask(request: GetUploadTaskRequest): Promise<GetUploadTaskResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getUploadTaskWithOptions(request, runtime);
  }

  /**
   * Queries the information about a log delivery task by account.
   * 
   * @remarks
   *   This API operation queries the details of a delivery task, including the task name, discard rate, region, log category, status, delivery destination, configuration, and filtering rules.****
   * *   You can call this operation to query detailed information about a log delivery task to analyze log processing efficiency or troubleshoot delivery problems.****
   * *   ****````
   * 
   * @param request - GetUserDeliveryTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetUserDeliveryTaskResponse
   */
  async getUserDeliveryTaskWithOptions(request: GetUserDeliveryTaskRequest, runtime: $dara.RuntimeOptions): Promise<GetUserDeliveryTaskResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetUserDeliveryTask",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetUserDeliveryTaskResponse>(await this.callApi(params, req, runtime), new GetUserDeliveryTaskResponse({}));
    } else {
      return $dara.cast<GetUserDeliveryTaskResponse>(await this.execute(params, req, runtime), new GetUserDeliveryTaskResponse({}));
    }

  }

  /**
   * Queries the information about a log delivery task by account.
   * 
   * @remarks
   *   This API operation queries the details of a delivery task, including the task name, discard rate, region, log category, status, delivery destination, configuration, and filtering rules.****
   * *   You can call this operation to query detailed information about a log delivery task to analyze log processing efficiency or troubleshoot delivery problems.****
   * *   ****````
   * 
   * @param request - GetUserDeliveryTaskRequest
   * @returns GetUserDeliveryTaskResponse
   */
  async getUserDeliveryTask(request: GetUserDeliveryTaskRequest): Promise<GetUserDeliveryTaskResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getUserDeliveryTaskWithOptions(request, runtime);
  }

  /**
   * Queries the remaining log delivery quota of each log category in your account.
   * 
   * @remarks
   * This operation allows you to query the remaining real-time log delivery quota of each log category in your Alibaba Cloud account. You must provide your Alibaba Cloud account ID (aliUid) and log category (BusinessType). The system then returns the remaining quota of the log category to help you track the usage.
   * 
   * @param request - GetUserLogDeliveryQuotaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetUserLogDeliveryQuotaResponse
   */
  async getUserLogDeliveryQuotaWithOptions(request: GetUserLogDeliveryQuotaRequest, runtime: $dara.RuntimeOptions): Promise<GetUserLogDeliveryQuotaResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetUserLogDeliveryQuota",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetUserLogDeliveryQuotaResponse>(await this.callApi(params, req, runtime), new GetUserLogDeliveryQuotaResponse({}));
    } else {
      return $dara.cast<GetUserLogDeliveryQuotaResponse>(await this.execute(params, req, runtime), new GetUserLogDeliveryQuotaResponse({}));
    }

  }

  /**
   * Queries the remaining log delivery quota of each log category in your account.
   * 
   * @remarks
   * This operation allows you to query the remaining real-time log delivery quota of each log category in your Alibaba Cloud account. You must provide your Alibaba Cloud account ID (aliUid) and log category (BusinessType). The system then returns the remaining quota of the log category to help you track the usage.
   * 
   * @param request - GetUserLogDeliveryQuotaRequest
   * @returns GetUserLogDeliveryQuotaResponse
   */
  async getUserLogDeliveryQuota(request: GetUserLogDeliveryQuotaRequest): Promise<GetUserLogDeliveryQuotaResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getUserLogDeliveryQuotaWithOptions(request, runtime);
  }

  /**
   * Queries the application key (AppKey) that is used for authentication and data exchange in bot behavior detection in Web Application Firewall (WAF).
   * 
   * @param request - GetWafBotAppKeyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetWafBotAppKeyResponse
   */
  async getWafBotAppKeyWithOptions(runtime: $dara.RuntimeOptions): Promise<GetWafBotAppKeyResponse> {
    let req = new $OpenApiUtil.OpenApiRequest({ });
    let params = new $OpenApiUtil.Params({
      action: "GetWafBotAppKey",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetWafBotAppKeyResponse>(await this.callApi(params, req, runtime), new GetWafBotAppKeyResponse({}));
    } else {
      return $dara.cast<GetWafBotAppKeyResponse>(await this.execute(params, req, runtime), new GetWafBotAppKeyResponse({}));
    }

  }

  /**
   * Queries the application key (AppKey) that is used for authentication and data exchange in bot behavior detection in Web Application Firewall (WAF).
   * @returns GetWafBotAppKeyResponse
   */
  async getWafBotAppKey(): Promise<GetWafBotAppKeyResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getWafBotAppKeyWithOptions(runtime);
  }

  /**
   * Queries the conditions for matching incoming requests that are configured in a WAF rule category for a website. These conditions define how WAF detects and processes different types of requests.
   * 
   * @param request - GetWafFilterRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetWafFilterResponse
   */
  async getWafFilterWithOptions(request: GetWafFilterRequest, runtime: $dara.RuntimeOptions): Promise<GetWafFilterResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.phase)) {
      query["Phase"] = request.phase;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.target)) {
      query["Target"] = request.target;
    }

    if (!$dara.isNull(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetWafFilter",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetWafFilterResponse>(await this.callApi(params, req, runtime), new GetWafFilterResponse({}));
    } else {
      return $dara.cast<GetWafFilterResponse>(await this.execute(params, req, runtime), new GetWafFilterResponse({}));
    }

  }

  /**
   * Queries the conditions for matching incoming requests that are configured in a WAF rule category for a website. These conditions define how WAF detects and processes different types of requests.
   * 
   * @param request - GetWafFilterRequest
   * @returns GetWafFilterResponse
   */
  async getWafFilter(request: GetWafFilterRequest): Promise<GetWafFilterResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getWafFilterWithOptions(request, runtime);
  }

  /**
   * Queries the quotas of Web Application Firewall (WAF) resources, such as managed rule groups, custom lists, custom error pages, and scenario-specific policies.
   * 
   * @param request - GetWafQuotaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetWafQuotaResponse
   */
  async getWafQuotaWithOptions(request: GetWafQuotaRequest, runtime: $dara.RuntimeOptions): Promise<GetWafQuotaResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.paths)) {
      query["Paths"] = request.paths;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "GetWafQuota",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<GetWafQuotaResponse>(await this.callApi(params, req, runtime), new GetWafQuotaResponse({}));
    } else {
      return $dara.cast<GetWafQuotaResponse>(await this.execute(params, req, runtime), new GetWafQuotaResponse({}));
    }

  }

  /**
   * Queries the quotas of Web Application Firewall (WAF) resources, such as managed rule groups, custom lists, custom error pages, and scenario-specific policies.
   * 
   * @param request - GetWafQuotaRequest
   * @returns GetWafQuotaResponse
   */
  async getWafQuota(request: GetWafQuotaRequest): Promise<GetWafQuotaResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.getWafQuotaWithOptions(request, runtime);
  }

  /**
   * Queries the cache reserve instances in your Alibaba Cloud account.
   * 
   * @param request - ListCacheReserveInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListCacheReserveInstancesResponse
   */
  async listCacheReserveInstancesWithOptions(request: ListCacheReserveInstancesRequest, runtime: $dara.RuntimeOptions): Promise<ListCacheReserveInstancesResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListCacheReserveInstances",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListCacheReserveInstancesResponse>(await this.callApi(params, req, runtime), new ListCacheReserveInstancesResponse({}));
    } else {
      return $dara.cast<ListCacheReserveInstancesResponse>(await this.execute(params, req, runtime), new ListCacheReserveInstancesResponse({}));
    }

  }

  /**
   * Queries the cache reserve instances in your Alibaba Cloud account.
   * 
   * @param request - ListCacheReserveInstancesRequest
   * @returns ListCacheReserveInstancesResponse
   */
  async listCacheReserveInstances(request: ListCacheReserveInstancesRequest): Promise<ListCacheReserveInstancesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listCacheReserveInstancesWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - ListCacheRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListCacheRulesResponse
   */
  async listCacheRulesWithOptions(request: ListCacheRulesRequest, runtime: $dara.RuntimeOptions): Promise<ListCacheRulesResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListCacheRules",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListCacheRulesResponse>(await this.callApi(params, req, runtime), new ListCacheRulesResponse({}));
    } else {
      return $dara.cast<ListCacheRulesResponse>(await this.execute(params, req, runtime), new ListCacheRulesResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - ListCacheRulesRequest
   * @returns ListCacheRulesResponse
   */
  async listCacheRules(request: ListCacheRulesRequest): Promise<ListCacheRulesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listCacheRulesWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - ListCertificatesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListCertificatesResponse
   */
  async listCertificatesWithOptions(request: ListCertificatesRequest, runtime: $dara.RuntimeOptions): Promise<ListCertificatesResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListCertificates",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListCertificatesResponse>(await this.callApi(params, req, runtime), new ListCertificatesResponse({}));
    } else {
      return $dara.cast<ListCertificatesResponse>(await this.execute(params, req, runtime), new ListCertificatesResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - ListCertificatesRequest
   * @returns ListCertificatesResponse
   */
  async listCertificates(request: ListCertificatesRequest): Promise<ListCertificatesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listCertificatesWithOptions(request, runtime);
  }

  /**
   * TLS
   * 
   * @param request - ListCiphersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListCiphersResponse
   */
  async listCiphersWithOptions(request: ListCiphersRequest, runtime: $dara.RuntimeOptions): Promise<ListCiphersResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListCiphers",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListCiphersResponse>(await this.callApi(params, req, runtime), new ListCiphersResponse({}));
    } else {
      return $dara.cast<ListCiphersResponse>(await this.execute(params, req, runtime), new ListCiphersResponse({}));
    }

  }

  /**
   * TLS
   * 
   * @param request - ListCiphersRequest
   * @returns ListCiphersResponse
   */
  async listCiphers(request: ListCiphersRequest): Promise<ListCiphersResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listCiphersWithOptions(request, runtime);
  }

  /**
   * Queries a list of client certificate authority (CA) certificates for a website.
   * 
   * @param request - ListClientCaCertificatesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListClientCaCertificatesResponse
   */
  async listClientCaCertificatesWithOptions(request: ListClientCaCertificatesRequest, runtime: $dara.RuntimeOptions): Promise<ListClientCaCertificatesResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListClientCaCertificates",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListClientCaCertificatesResponse>(await this.callApi(params, req, runtime), new ListClientCaCertificatesResponse({}));
    } else {
      return $dara.cast<ListClientCaCertificatesResponse>(await this.execute(params, req, runtime), new ListClientCaCertificatesResponse({}));
    }

  }

  /**
   * Queries a list of client certificate authority (CA) certificates for a website.
   * 
   * @param request - ListClientCaCertificatesRequest
   * @returns ListClientCaCertificatesResponse
   */
  async listClientCaCertificates(request: ListClientCaCertificatesRequest): Promise<ListClientCaCertificatesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listClientCaCertificatesWithOptions(request, runtime);
  }

  /**
   * Queries client certificates configured for a website.
   * 
   * @param request - ListClientCertificatesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListClientCertificatesResponse
   */
  async listClientCertificatesWithOptions(request: ListClientCertificatesRequest, runtime: $dara.RuntimeOptions): Promise<ListClientCertificatesResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListClientCertificates",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListClientCertificatesResponse>(await this.callApi(params, req, runtime), new ListClientCertificatesResponse({}));
    } else {
      return $dara.cast<ListClientCertificatesResponse>(await this.execute(params, req, runtime), new ListClientCertificatesResponse({}));
    }

  }

  /**
   * Queries client certificates configured for a website.
   * 
   * @param request - ListClientCertificatesRequest
   * @returns ListClientCertificatesResponse
   */
  async listClientCertificates(request: ListClientCertificatesRequest): Promise<ListClientCertificatesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listClientCertificatesWithOptions(request, runtime);
  }

  /**
   * Queries compression rules that are configured for a website.
   * 
   * @param request - ListCompressionRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListCompressionRulesResponse
   */
  async listCompressionRulesWithOptions(request: ListCompressionRulesRequest, runtime: $dara.RuntimeOptions): Promise<ListCompressionRulesResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListCompressionRules",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListCompressionRulesResponse>(await this.callApi(params, req, runtime), new ListCompressionRulesResponse({}));
    } else {
      return $dara.cast<ListCompressionRulesResponse>(await this.execute(params, req, runtime), new ListCompressionRulesResponse({}));
    }

  }

  /**
   * Queries compression rules that are configured for a website.
   * 
   * @param request - ListCompressionRulesRequest
   * @returns ListCompressionRulesResponse
   */
  async listCompressionRules(request: ListCompressionRulesRequest): Promise<ListCompressionRulesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listCompressionRulesWithOptions(request, runtime);
  }

  /**
   * Lists domain names that are associated with a containerized application.
   * 
   * @param request - ListEdgeContainerAppRecordsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEdgeContainerAppRecordsResponse
   */
  async listEdgeContainerAppRecordsWithOptions(request: ListEdgeContainerAppRecordsRequest, runtime: $dara.RuntimeOptions): Promise<ListEdgeContainerAppRecordsResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListEdgeContainerAppRecords",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListEdgeContainerAppRecordsResponse>(await this.callApi(params, req, runtime), new ListEdgeContainerAppRecordsResponse({}));
    } else {
      return $dara.cast<ListEdgeContainerAppRecordsResponse>(await this.execute(params, req, runtime), new ListEdgeContainerAppRecordsResponse({}));
    }

  }

  /**
   * Lists domain names that are associated with a containerized application.
   * 
   * @param request - ListEdgeContainerAppRecordsRequest
   * @returns ListEdgeContainerAppRecordsResponse
   */
  async listEdgeContainerAppRecords(request: ListEdgeContainerAppRecordsRequest): Promise<ListEdgeContainerAppRecordsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listEdgeContainerAppRecordsWithOptions(request, runtime);
  }

  /**
   * Lists versions of all containerized applications.
   * 
   * @param request - ListEdgeContainerAppVersionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEdgeContainerAppVersionsResponse
   */
  async listEdgeContainerAppVersionsWithOptions(request: ListEdgeContainerAppVersionsRequest, runtime: $dara.RuntimeOptions): Promise<ListEdgeContainerAppVersionsResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListEdgeContainerAppVersions",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListEdgeContainerAppVersionsResponse>(await this.callApi(params, req, runtime), new ListEdgeContainerAppVersionsResponse({}));
    } else {
      return $dara.cast<ListEdgeContainerAppVersionsResponse>(await this.execute(params, req, runtime), new ListEdgeContainerAppVersionsResponse({}));
    }

  }

  /**
   * Lists versions of all containerized applications.
   * 
   * @param request - ListEdgeContainerAppVersionsRequest
   * @returns ListEdgeContainerAppVersionsResponse
   */
  async listEdgeContainerAppVersions(request: ListEdgeContainerAppVersionsRequest): Promise<ListEdgeContainerAppVersionsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listEdgeContainerAppVersionsWithOptions(request, runtime);
  }

  /**
   * Queries all containerized applications in your Alibaba Cloud account.
   * 
   * @param request - ListEdgeContainerAppsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEdgeContainerAppsResponse
   */
  async listEdgeContainerAppsWithOptions(request: ListEdgeContainerAppsRequest, runtime: $dara.RuntimeOptions): Promise<ListEdgeContainerAppsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.orderKey)) {
      query["OrderKey"] = request.orderKey;
    }

    if (!$dara.isNull(request.orderType)) {
      query["OrderType"] = request.orderType;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.searchKey)) {
      query["SearchKey"] = request.searchKey;
    }

    if (!$dara.isNull(request.searchType)) {
      query["SearchType"] = request.searchType;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListEdgeContainerApps",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListEdgeContainerAppsResponse>(await this.callApi(params, req, runtime), new ListEdgeContainerAppsResponse({}));
    } else {
      return $dara.cast<ListEdgeContainerAppsResponse>(await this.execute(params, req, runtime), new ListEdgeContainerAppsResponse({}));
    }

  }

  /**
   * Queries all containerized applications in your Alibaba Cloud account.
   * 
   * @param request - ListEdgeContainerAppsRequest
   * @returns ListEdgeContainerAppsResponse
   */
  async listEdgeContainerApps(request: ListEdgeContainerAppsRequest): Promise<ListEdgeContainerAppsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listEdgeContainerAppsWithOptions(request, runtime);
  }

  /**
   * Queries the records that are associated with Edge Container for a website.
   * 
   * @param request - ListEdgeContainerRecordsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEdgeContainerRecordsResponse
   */
  async listEdgeContainerRecordsWithOptions(request: ListEdgeContainerRecordsRequest, runtime: $dara.RuntimeOptions): Promise<ListEdgeContainerRecordsResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListEdgeContainerRecords",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListEdgeContainerRecordsResponse>(await this.callApi(params, req, runtime), new ListEdgeContainerRecordsResponse({}));
    } else {
      return $dara.cast<ListEdgeContainerRecordsResponse>(await this.execute(params, req, runtime), new ListEdgeContainerRecordsResponse({}));
    }

  }

  /**
   * Queries the records that are associated with Edge Container for a website.
   * 
   * @param request - ListEdgeContainerRecordsRequest
   * @returns ListEdgeContainerRecordsResponse
   */
  async listEdgeContainerRecords(request: ListEdgeContainerRecordsRequest): Promise<ListEdgeContainerRecordsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listEdgeContainerRecordsWithOptions(request, runtime);
  }

  /**
   * Queries Edge Routine plans.
   * 
   * @param request - ListEdgeRoutinePlansRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEdgeRoutinePlansResponse
   */
  async listEdgeRoutinePlansWithOptions(runtime: $dara.RuntimeOptions): Promise<ListEdgeRoutinePlansResponse> {
    let req = new $OpenApiUtil.OpenApiRequest({ });
    let params = new $OpenApiUtil.Params({
      action: "ListEdgeRoutinePlans",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListEdgeRoutinePlansResponse>(await this.callApi(params, req, runtime), new ListEdgeRoutinePlansResponse({}));
    } else {
      return $dara.cast<ListEdgeRoutinePlansResponse>(await this.execute(params, req, runtime), new ListEdgeRoutinePlansResponse({}));
    }

  }

  /**
   * Queries Edge Routine plans.
   * @returns ListEdgeRoutinePlansResponse
   */
  async listEdgeRoutinePlans(): Promise<ListEdgeRoutinePlansResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listEdgeRoutinePlansWithOptions(runtime);
  }

  /**
   * Queries the records that are associated with Edge Routine routes for a website.
   * 
   * @remarks
   * >  You can call this operation 100 times per second.
   * 
   * @param request - ListEdgeRoutineRecordsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEdgeRoutineRecordsResponse
   */
  async listEdgeRoutineRecordsWithOptions(request: ListEdgeRoutineRecordsRequest, runtime: $dara.RuntimeOptions): Promise<ListEdgeRoutineRecordsResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListEdgeRoutineRecords",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListEdgeRoutineRecordsResponse>(await this.callApi(params, req, runtime), new ListEdgeRoutineRecordsResponse({}));
    } else {
      return $dara.cast<ListEdgeRoutineRecordsResponse>(await this.execute(params, req, runtime), new ListEdgeRoutineRecordsResponse({}));
    }

  }

  /**
   * Queries the records that are associated with Edge Routine routes for a website.
   * 
   * @remarks
   * >  You can call this operation 100 times per second.
   * 
   * @param request - ListEdgeRoutineRecordsRequest
   * @returns ListEdgeRoutineRecordsResponse
   */
  async listEdgeRoutineRecords(request: ListEdgeRoutineRecordsRequest): Promise<ListEdgeRoutineRecordsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listEdgeRoutineRecordsWithOptions(request, runtime);
  }

  /**
   * HTTP
   * 
   * @param request - ListHttpRequestHeaderModificationRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListHttpRequestHeaderModificationRulesResponse
   */
  async listHttpRequestHeaderModificationRulesWithOptions(request: ListHttpRequestHeaderModificationRulesRequest, runtime: $dara.RuntimeOptions): Promise<ListHttpRequestHeaderModificationRulesResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListHttpRequestHeaderModificationRules",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListHttpRequestHeaderModificationRulesResponse>(await this.callApi(params, req, runtime), new ListHttpRequestHeaderModificationRulesResponse({}));
    } else {
      return $dara.cast<ListHttpRequestHeaderModificationRulesResponse>(await this.execute(params, req, runtime), new ListHttpRequestHeaderModificationRulesResponse({}));
    }

  }

  /**
   * HTTP
   * 
   * @param request - ListHttpRequestHeaderModificationRulesRequest
   * @returns ListHttpRequestHeaderModificationRulesResponse
   */
  async listHttpRequestHeaderModificationRules(request: ListHttpRequestHeaderModificationRulesRequest): Promise<ListHttpRequestHeaderModificationRulesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listHttpRequestHeaderModificationRulesWithOptions(request, runtime);
  }

  /**
   * HTTP
   * 
   * @param request - ListHttpResponseHeaderModificationRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListHttpResponseHeaderModificationRulesResponse
   */
  async listHttpResponseHeaderModificationRulesWithOptions(request: ListHttpResponseHeaderModificationRulesRequest, runtime: $dara.RuntimeOptions): Promise<ListHttpResponseHeaderModificationRulesResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListHttpResponseHeaderModificationRules",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListHttpResponseHeaderModificationRulesResponse>(await this.callApi(params, req, runtime), new ListHttpResponseHeaderModificationRulesResponse({}));
    } else {
      return $dara.cast<ListHttpResponseHeaderModificationRulesResponse>(await this.execute(params, req, runtime), new ListHttpResponseHeaderModificationRulesResponse({}));
    }

  }

  /**
   * HTTP
   * 
   * @param request - ListHttpResponseHeaderModificationRulesRequest
   * @returns ListHttpResponseHeaderModificationRulesResponse
   */
  async listHttpResponseHeaderModificationRules(request: ListHttpResponseHeaderModificationRulesRequest): Promise<ListHttpResponseHeaderModificationRulesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listHttpResponseHeaderModificationRulesWithOptions(request, runtime);
  }

  /**
   * HTTPS
   * 
   * @param request - ListHttpsApplicationConfigurationsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListHttpsApplicationConfigurationsResponse
   */
  async listHttpsApplicationConfigurationsWithOptions(request: ListHttpsApplicationConfigurationsRequest, runtime: $dara.RuntimeOptions): Promise<ListHttpsApplicationConfigurationsResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListHttpsApplicationConfigurations",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListHttpsApplicationConfigurationsResponse>(await this.callApi(params, req, runtime), new ListHttpsApplicationConfigurationsResponse({}));
    } else {
      return $dara.cast<ListHttpsApplicationConfigurationsResponse>(await this.execute(params, req, runtime), new ListHttpsApplicationConfigurationsResponse({}));
    }

  }

  /**
   * HTTPS
   * 
   * @param request - ListHttpsApplicationConfigurationsRequest
   * @returns ListHttpsApplicationConfigurationsResponse
   */
  async listHttpsApplicationConfigurations(request: ListHttpsApplicationConfigurationsRequest): Promise<ListHttpsApplicationConfigurationsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listHttpsApplicationConfigurationsWithOptions(request, runtime);
  }

  /**
   * HTTPS
   * 
   * @param request - ListHttpsBasicConfigurationsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListHttpsBasicConfigurationsResponse
   */
  async listHttpsBasicConfigurationsWithOptions(request: ListHttpsBasicConfigurationsRequest, runtime: $dara.RuntimeOptions): Promise<ListHttpsBasicConfigurationsResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListHttpsBasicConfigurations",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListHttpsBasicConfigurationsResponse>(await this.callApi(params, req, runtime), new ListHttpsBasicConfigurationsResponse({}));
    } else {
      return $dara.cast<ListHttpsBasicConfigurationsResponse>(await this.execute(params, req, runtime), new ListHttpsBasicConfigurationsResponse({}));
    }

  }

  /**
   * HTTPS
   * 
   * @param request - ListHttpsBasicConfigurationsRequest
   * @returns ListHttpsBasicConfigurationsResponse
   */
  async listHttpsBasicConfigurations(request: ListHttpsBasicConfigurationsRequest): Promise<ListHttpsBasicConfigurationsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listHttpsBasicConfigurationsWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - ListImageTransformsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListImageTransformsResponse
   */
  async listImageTransformsWithOptions(request: ListImageTransformsRequest, runtime: $dara.RuntimeOptions): Promise<ListImageTransformsResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListImageTransforms",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListImageTransformsResponse>(await this.callApi(params, req, runtime), new ListImageTransformsResponse({}));
    } else {
      return $dara.cast<ListImageTransformsResponse>(await this.execute(params, req, runtime), new ListImageTransformsResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - ListImageTransformsRequest
   * @returns ListImageTransformsResponse
   */
  async listImageTransforms(request: ListImageTransformsRequest): Promise<ListImageTransformsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listImageTransformsWithOptions(request, runtime);
  }

  /**
   * Queries the quota details in a subscription plan.
   * 
   * @param request - ListInstanceQuotasRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListInstanceQuotasResponse
   */
  async listInstanceQuotasWithOptions(request: ListInstanceQuotasRequest, runtime: $dara.RuntimeOptions): Promise<ListInstanceQuotasResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListInstanceQuotas",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListInstanceQuotasResponse>(await this.callApi(params, req, runtime), new ListInstanceQuotasResponse({}));
    } else {
      return $dara.cast<ListInstanceQuotasResponse>(await this.execute(params, req, runtime), new ListInstanceQuotasResponse({}));
    }

  }

  /**
   * Queries the quota details in a subscription plan.
   * 
   * @param request - ListInstanceQuotasRequest
   * @returns ListInstanceQuotasResponse
   */
  async listInstanceQuotas(request: ListInstanceQuotasRequest): Promise<ListInstanceQuotasResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listInstanceQuotasWithOptions(request, runtime);
  }

  /**
   * Queries quotas and the actual usage in a plan based on the website or plan ID.
   * 
   * @param request - ListInstanceQuotasWithUsageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListInstanceQuotasWithUsageResponse
   */
  async listInstanceQuotasWithUsageWithOptions(request: ListInstanceQuotasWithUsageRequest, runtime: $dara.RuntimeOptions): Promise<ListInstanceQuotasWithUsageResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListInstanceQuotasWithUsage",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListInstanceQuotasWithUsageResponse>(await this.callApi(params, req, runtime), new ListInstanceQuotasWithUsageResponse({}));
    } else {
      return $dara.cast<ListInstanceQuotasWithUsageResponse>(await this.execute(params, req, runtime), new ListInstanceQuotasWithUsageResponse({}));
    }

  }

  /**
   * Queries quotas and the actual usage in a plan based on the website or plan ID.
   * 
   * @param request - ListInstanceQuotasWithUsageRequest
   * @returns ListInstanceQuotasWithUsageResponse
   */
  async listInstanceQuotasWithUsage(request: ListInstanceQuotasWithUsageRequest): Promise<ListInstanceQuotasWithUsageResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listInstanceQuotasWithUsageWithOptions(request, runtime);
  }

  /**
   * Lists all key-value pairs in a namespace in your Alibaba Cloud account.
   * 
   * @param request - ListKvsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListKvsResponse
   */
  async listKvsWithOptions(request: ListKvsRequest, runtime: $dara.RuntimeOptions): Promise<ListKvsResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListKvs",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListKvsResponse>(await this.callApi(params, req, runtime), new ListKvsResponse({}));
    } else {
      return $dara.cast<ListKvsResponse>(await this.execute(params, req, runtime), new ListKvsResponse({}));
    }

  }

  /**
   * Lists all key-value pairs in a namespace in your Alibaba Cloud account.
   * 
   * @param request - ListKvsRequest
   * @returns ListKvsResponse
   */
  async listKvs(request: ListKvsRequest): Promise<ListKvsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listKvsWithOptions(request, runtime);
  }

  /**
   * Queries all custom lists and their details in an Alibaba Cloud account. You can specify query arguments to filter the results and display the returned lists by page.
   * 
   * @param tmpReq - ListListsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListListsResponse
   */
  async listListsWithOptions(tmpReq: ListListsRequest, runtime: $dara.RuntimeOptions): Promise<ListListsResponse> {
    tmpReq.validate();
    let request = new ListListsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.queryArgs)) {
      request.queryArgsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.queryArgs, "QueryArgs", "json");
    }

    let query = { };
    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.queryArgsShrink)) {
      query["QueryArgs"] = request.queryArgsShrink;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListLists",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListListsResponse>(await this.callApi(params, req, runtime), new ListListsResponse({}));
    } else {
      return $dara.cast<ListListsResponse>(await this.execute(params, req, runtime), new ListListsResponse({}));
    }

  }

  /**
   * Queries all custom lists and their details in an Alibaba Cloud account. You can specify query arguments to filter the results and display the returned lists by page.
   * 
   * @param request - ListListsRequest
   * @returns ListListsResponse
   */
  async listLists(request: ListListsRequest): Promise<ListListsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listListsWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - ListLoadBalancerOriginStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListLoadBalancerOriginStatusResponse
   */
  async listLoadBalancerOriginStatusWithOptions(request: ListLoadBalancerOriginStatusRequest, runtime: $dara.RuntimeOptions): Promise<ListLoadBalancerOriginStatusResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListLoadBalancerOriginStatus",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListLoadBalancerOriginStatusResponse>(await this.callApi(params, req, runtime), new ListLoadBalancerOriginStatusResponse({}));
    } else {
      return $dara.cast<ListLoadBalancerOriginStatusResponse>(await this.execute(params, req, runtime), new ListLoadBalancerOriginStatusResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - ListLoadBalancerOriginStatusRequest
   * @returns ListLoadBalancerOriginStatusResponse
   */
  async listLoadBalancerOriginStatus(request: ListLoadBalancerOriginStatusRequest): Promise<ListLoadBalancerOriginStatusResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listLoadBalancerOriginStatusWithOptions(request, runtime);
  }

  /**
   * Queries the information that can be used to configure a traffic steering policy based on the originating country or region for a load balancer, such as the code and code descriptions of the regions and subregions of the load balancer.
   * 
   * @remarks
   * When you call an operation to create a traffic steering policy based on the originating country or region for a load balancer, you can use the code of a region or subregion to specify traffic that is sent from the region or subregion.
   * 
   * @param request - ListLoadBalancerRegionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListLoadBalancerRegionsResponse
   */
  async listLoadBalancerRegionsWithOptions(request: ListLoadBalancerRegionsRequest, runtime: $dara.RuntimeOptions): Promise<ListLoadBalancerRegionsResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListLoadBalancerRegions",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListLoadBalancerRegionsResponse>(await this.callApi(params, req, runtime), new ListLoadBalancerRegionsResponse({}));
    } else {
      return $dara.cast<ListLoadBalancerRegionsResponse>(await this.execute(params, req, runtime), new ListLoadBalancerRegionsResponse({}));
    }

  }

  /**
   * Queries the information that can be used to configure a traffic steering policy based on the originating country or region for a load balancer, such as the code and code descriptions of the regions and subregions of the load balancer.
   * 
   * @remarks
   * When you call an operation to create a traffic steering policy based on the originating country or region for a load balancer, you can use the code of a region or subregion to specify traffic that is sent from the region or subregion.
   * 
   * @param request - ListLoadBalancerRegionsRequest
   * @returns ListLoadBalancerRegionsResponse
   */
  async listLoadBalancerRegions(request: ListLoadBalancerRegionsRequest): Promise<ListLoadBalancerRegionsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listLoadBalancerRegionsWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - ListLoadBalancersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListLoadBalancersResponse
   */
  async listLoadBalancersWithOptions(request: ListLoadBalancersRequest, runtime: $dara.RuntimeOptions): Promise<ListLoadBalancersResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListLoadBalancers",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListLoadBalancersResponse>(await this.callApi(params, req, runtime), new ListLoadBalancersResponse({}));
    } else {
      return $dara.cast<ListLoadBalancersResponse>(await this.execute(params, req, runtime), new ListLoadBalancersResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - ListLoadBalancersRequest
   * @returns ListLoadBalancersResponse
   */
  async listLoadBalancers(request: ListLoadBalancersRequest): Promise<ListLoadBalancersResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listLoadBalancersWithOptions(request, runtime);
  }

  /**
   * Queries all WAF managed rule groups in your Alibaba Cloud account.
   * 
   * @param request - ListManagedRulesGroupsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListManagedRulesGroupsResponse
   */
  async listManagedRulesGroupsWithOptions(request: ListManagedRulesGroupsRequest, runtime: $dara.RuntimeOptions): Promise<ListManagedRulesGroupsResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListManagedRulesGroups",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListManagedRulesGroupsResponse>(await this.callApi(params, req, runtime), new ListManagedRulesGroupsResponse({}));
    } else {
      return $dara.cast<ListManagedRulesGroupsResponse>(await this.execute(params, req, runtime), new ListManagedRulesGroupsResponse({}));
    }

  }

  /**
   * Queries all WAF managed rule groups in your Alibaba Cloud account.
   * 
   * @param request - ListManagedRulesGroupsRequest
   * @returns ListManagedRulesGroupsResponse
   */
  async listManagedRulesGroups(request: ListManagedRulesGroupsRequest): Promise<ListManagedRulesGroupsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listManagedRulesGroupsWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - ListNetworkOptimizationsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListNetworkOptimizationsResponse
   */
  async listNetworkOptimizationsWithOptions(request: ListNetworkOptimizationsRequest, runtime: $dara.RuntimeOptions): Promise<ListNetworkOptimizationsResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListNetworkOptimizations",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListNetworkOptimizationsResponse>(await this.callApi(params, req, runtime), new ListNetworkOptimizationsResponse({}));
    } else {
      return $dara.cast<ListNetworkOptimizationsResponse>(await this.execute(params, req, runtime), new ListNetworkOptimizationsResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - ListNetworkOptimizationsRequest
   * @returns ListNetworkOptimizationsResponse
   */
  async listNetworkOptimizations(request: ListNetworkOptimizationsRequest): Promise<ListNetworkOptimizationsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listNetworkOptimizationsWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - ListOriginPoolsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListOriginPoolsResponse
   */
  async listOriginPoolsWithOptions(request: ListOriginPoolsRequest, runtime: $dara.RuntimeOptions): Promise<ListOriginPoolsResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListOriginPools",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListOriginPoolsResponse>(await this.callApi(params, req, runtime), new ListOriginPoolsResponse({}));
    } else {
      return $dara.cast<ListOriginPoolsResponse>(await this.execute(params, req, runtime), new ListOriginPoolsResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - ListOriginPoolsRequest
   * @returns ListOriginPoolsResponse
   */
  async listOriginPools(request: ListOriginPoolsRequest): Promise<ListOriginPoolsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listOriginPoolsWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - ListOriginRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListOriginRulesResponse
   */
  async listOriginRulesWithOptions(request: ListOriginRulesRequest, runtime: $dara.RuntimeOptions): Promise<ListOriginRulesResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListOriginRules",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListOriginRulesResponse>(await this.callApi(params, req, runtime), new ListOriginRulesResponse({}));
    } else {
      return $dara.cast<ListOriginRulesResponse>(await this.execute(params, req, runtime), new ListOriginRulesResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - ListOriginRulesRequest
   * @returns ListOriginRulesResponse
   */
  async listOriginRules(request: ListOriginRulesRequest): Promise<ListOriginRulesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listOriginRulesWithOptions(request, runtime);
  }

  /**
   * Lists all custom error pages that you created. You can define the page number and the number of entries per page to display the response.
   * 
   * @param tmpReq - ListPagesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListPagesResponse
   */
  async listPagesWithOptions(tmpReq: ListPagesRequest, runtime: $dara.RuntimeOptions): Promise<ListPagesResponse> {
    tmpReq.validate();
    let request = new ListPagesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.queryArgs)) {
      request.queryArgsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.queryArgs, "QueryArgs", "json");
    }

    let query = { };
    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.queryArgsShrink)) {
      query["QueryArgs"] = request.queryArgsShrink;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListPages",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListPagesResponse>(await this.callApi(params, req, runtime), new ListPagesResponse({}));
    } else {
      return $dara.cast<ListPagesResponse>(await this.execute(params, req, runtime), new ListPagesResponse({}));
    }

  }

  /**
   * Lists all custom error pages that you created. You can define the page number and the number of entries per page to display the response.
   * 
   * @param request - ListPagesRequest
   * @returns ListPagesResponse
   */
  async listPages(request: ListPagesRequest): Promise<ListPagesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listPagesWithOptions(request, runtime);
  }

  /**
   * Queries a list of Domain Name System (DNS) records of a website, including the record value, priority, and authentication configurations. Supports filtering by specifying parameters such as RecordName and RecordMatchType.
   * 
   * @remarks
   * The DNS records related to Edge Container, Edge Routine, and TCP/UDP proxy are not returned in this operation.
   * 
   * @param request - ListRecordsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListRecordsResponse
   */
  async listRecordsWithOptions(request: ListRecordsRequest, runtime: $dara.RuntimeOptions): Promise<ListRecordsResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListRecords",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListRecordsResponse>(await this.callApi(params, req, runtime), new ListRecordsResponse({}));
    } else {
      return $dara.cast<ListRecordsResponse>(await this.execute(params, req, runtime), new ListRecordsResponse({}));
    }

  }

  /**
   * Queries a list of Domain Name System (DNS) records of a website, including the record value, priority, and authentication configurations. Supports filtering by specifying parameters such as RecordName and RecordMatchType.
   * 
   * @remarks
   * The DNS records related to Edge Container, Edge Routine, and TCP/UDP proxy are not returned in this operation.
   * 
   * @param request - ListRecordsRequest
   * @returns ListRecordsResponse
   */
  async listRecords(request: ListRecordsRequest): Promise<ListRecordsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listRecordsWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - ListRedirectRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListRedirectRulesResponse
   */
  async listRedirectRulesWithOptions(request: ListRedirectRulesRequest, runtime: $dara.RuntimeOptions): Promise<ListRedirectRulesResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListRedirectRules",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListRedirectRulesResponse>(await this.callApi(params, req, runtime), new ListRedirectRulesResponse({}));
    } else {
      return $dara.cast<ListRedirectRulesResponse>(await this.execute(params, req, runtime), new ListRedirectRulesResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - ListRedirectRulesRequest
   * @returns ListRedirectRulesResponse
   */
  async listRedirectRules(request: ListRedirectRulesRequest): Promise<ListRedirectRulesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listRedirectRulesWithOptions(request, runtime);
  }

  /**
   * Url
   * 
   * @param request - ListRewriteUrlRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListRewriteUrlRulesResponse
   */
  async listRewriteUrlRulesWithOptions(request: ListRewriteUrlRulesRequest, runtime: $dara.RuntimeOptions): Promise<ListRewriteUrlRulesResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListRewriteUrlRules",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListRewriteUrlRulesResponse>(await this.callApi(params, req, runtime), new ListRewriteUrlRulesResponse({}));
    } else {
      return $dara.cast<ListRewriteUrlRulesResponse>(await this.execute(params, req, runtime), new ListRewriteUrlRulesResponse({}));
    }

  }

  /**
   * Url
   * 
   * @param request - ListRewriteUrlRulesRequest
   * @returns ListRewriteUrlRulesResponse
   */
  async listRewriteUrlRules(request: ListRewriteUrlRulesRequest): Promise<ListRewriteUrlRulesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listRewriteUrlRulesWithOptions(request, runtime);
  }

  /**
   * Lists the regions to which Edge Routine code can be released for canary deployment.
   * 
   * @param request - ListRoutineCanaryAreasRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListRoutineCanaryAreasResponse
   */
  async listRoutineCanaryAreasWithOptions(runtime: $dara.RuntimeOptions): Promise<ListRoutineCanaryAreasResponse> {
    let req = new $OpenApiUtil.OpenApiRequest({ });
    let params = new $OpenApiUtil.Params({
      action: "ListRoutineCanaryAreas",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListRoutineCanaryAreasResponse>(await this.callApi(params, req, runtime), new ListRoutineCanaryAreasResponse({}));
    } else {
      return $dara.cast<ListRoutineCanaryAreasResponse>(await this.execute(params, req, runtime), new ListRoutineCanaryAreasResponse({}));
    }

  }

  /**
   * Lists the regions to which Edge Routine code can be released for canary deployment.
   * @returns ListRoutineCanaryAreasResponse
   */
  async listRoutineCanaryAreas(): Promise<ListRoutineCanaryAreasResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listRoutineCanaryAreasWithOptions(runtime);
  }

  /**
   * Queries the specifications that you can select for a routine based on the plan type. The response contains all specifications that you can select for a routine. The IsAvailable parameter indicates whether a specification is available.
   * 
   * @remarks
   * You can call this operation to query the specifications that you can select for a routine.
   * 
   * @param request - ListRoutineOptionalSpecsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListRoutineOptionalSpecsResponse
   */
  async listRoutineOptionalSpecsWithOptions(runtime: $dara.RuntimeOptions): Promise<ListRoutineOptionalSpecsResponse> {
    let req = new $OpenApiUtil.OpenApiRequest({ });
    let params = new $OpenApiUtil.Params({
      action: "ListRoutineOptionalSpecs",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListRoutineOptionalSpecsResponse>(await this.callApi(params, req, runtime), new ListRoutineOptionalSpecsResponse({}));
    } else {
      return $dara.cast<ListRoutineOptionalSpecsResponse>(await this.execute(params, req, runtime), new ListRoutineOptionalSpecsResponse({}));
    }

  }

  /**
   * Queries the specifications that you can select for a routine based on the plan type. The response contains all specifications that you can select for a routine. The IsAvailable parameter indicates whether a specification is available.
   * 
   * @remarks
   * You can call this operation to query the specifications that you can select for a routine.
   * @returns ListRoutineOptionalSpecsResponse
   */
  async listRoutineOptionalSpecs(): Promise<ListRoutineOptionalSpecsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listRoutineOptionalSpecsWithOptions(runtime);
  }

  /**
   * Lists the plans in a scheduled prefetch task by task ID.
   * 
   * @param request - ListScheduledPreloadExecutionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListScheduledPreloadExecutionsResponse
   */
  async listScheduledPreloadExecutionsWithOptions(request: ListScheduledPreloadExecutionsRequest, runtime: $dara.RuntimeOptions): Promise<ListScheduledPreloadExecutionsResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListScheduledPreloadExecutions",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListScheduledPreloadExecutionsResponse>(await this.callApi(params, req, runtime), new ListScheduledPreloadExecutionsResponse({}));
    } else {
      return $dara.cast<ListScheduledPreloadExecutionsResponse>(await this.execute(params, req, runtime), new ListScheduledPreloadExecutionsResponse({}));
    }

  }

  /**
   * Lists the plans in a scheduled prefetch task by task ID.
   * 
   * @param request - ListScheduledPreloadExecutionsRequest
   * @returns ListScheduledPreloadExecutionsResponse
   */
  async listScheduledPreloadExecutions(request: ListScheduledPreloadExecutionsRequest): Promise<ListScheduledPreloadExecutionsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listScheduledPreloadExecutionsWithOptions(request, runtime);
  }

  /**
   * Queries the scheduled prefetch tasks for a website.
   * 
   * @param request - ListScheduledPreloadJobsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListScheduledPreloadJobsResponse
   */
  async listScheduledPreloadJobsWithOptions(request: ListScheduledPreloadJobsRequest, runtime: $dara.RuntimeOptions): Promise<ListScheduledPreloadJobsResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListScheduledPreloadJobs",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListScheduledPreloadJobsResponse>(await this.callApi(params, req, runtime), new ListScheduledPreloadJobsResponse({}));
    } else {
      return $dara.cast<ListScheduledPreloadJobsResponse>(await this.execute(params, req, runtime), new ListScheduledPreloadJobsResponse({}));
    }

  }

  /**
   * Queries the scheduled prefetch tasks for a website.
   * 
   * @param request - ListScheduledPreloadJobsRequest
   * @returns ListScheduledPreloadJobsResponse
   */
  async listScheduledPreloadJobs(request: ListScheduledPreloadJobsRequest): Promise<ListScheduledPreloadJobsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listScheduledPreloadJobsWithOptions(request, runtime);
  }

  /**
   * Lists all log delivery tasks that are in progress.
   * 
   * @param request - ListSiteDeliveryTasksRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListSiteDeliveryTasksResponse
   */
  async listSiteDeliveryTasksWithOptions(request: ListSiteDeliveryTasksRequest, runtime: $dara.RuntimeOptions): Promise<ListSiteDeliveryTasksResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListSiteDeliveryTasks",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListSiteDeliveryTasksResponse>(await this.callApi(params, req, runtime), new ListSiteDeliveryTasksResponse({}));
    } else {
      return $dara.cast<ListSiteDeliveryTasksResponse>(await this.execute(params, req, runtime), new ListSiteDeliveryTasksResponse({}));
    }

  }

  /**
   * Lists all log delivery tasks that are in progress.
   * 
   * @param request - ListSiteDeliveryTasksRequest
   * @returns ListSiteDeliveryTasksResponse
   */
  async listSiteDeliveryTasks(request: ListSiteDeliveryTasksRequest): Promise<ListSiteDeliveryTasksResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listSiteDeliveryTasksWithOptions(request, runtime);
  }

  /**
   * Queries the information about websites in your account, such as the name, status, and configuration of each website.
   * 
   * @param tmpReq - ListSitesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListSitesResponse
   */
  async listSitesWithOptions(tmpReq: ListSitesRequest, runtime: $dara.RuntimeOptions): Promise<ListSitesResponse> {
    tmpReq.validate();
    let request = new ListSitesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.tagFilter)) {
      request.tagFilterShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tagFilter, "TagFilter", "json");
    }

    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListSites",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListSitesResponse>(await this.callApi(params, req, runtime), new ListSitesResponse({}));
    } else {
      return $dara.cast<ListSitesResponse>(await this.execute(params, req, runtime), new ListSitesResponse({}));
    }

  }

  /**
   * Queries the information about websites in your account, such as the name, status, and configuration of each website.
   * 
   * @param request - ListSitesRequest
   * @returns ListSitesResponse
   */
  async listSites(request: ListSitesRequest): Promise<ListSitesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listSitesWithOptions(request, runtime);
  }

  /**
   * Queries tags based on the region ID and resource type.
   * 
   * @param request - ListTagResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListTagResourcesResponse
   */
  async listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: $dara.RuntimeOptions): Promise<ListTagResourcesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.maxItem)) {
      query["MaxItem"] = request.maxItem;
    }

    if (!$dara.isNull(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!$dara.isNull(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!$dara.isNull(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!$dara.isNull(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListTagResources",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListTagResourcesResponse>(await this.callApi(params, req, runtime), new ListTagResourcesResponse({}));
    } else {
      return $dara.cast<ListTagResourcesResponse>(await this.execute(params, req, runtime), new ListTagResourcesResponse({}));
    }

  }

  /**
   * Queries tags based on the region ID and resource type.
   * 
   * @param request - ListTagResourcesRequest
   * @returns ListTagResourcesResponse
   */
  async listTagResources(request: ListTagResourcesRequest): Promise<ListTagResourcesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listTagResourcesWithOptions(request, runtime);
  }

  /**
   * Queries the execution status and running information of file upload tasks based on the task time and type.
   * 
   * @param request - ListUploadTasksRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListUploadTasksResponse
   */
  async listUploadTasksWithOptions(request: ListUploadTasksRequest, runtime: $dara.RuntimeOptions): Promise<ListUploadTasksResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListUploadTasks",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListUploadTasksResponse>(await this.callApi(params, req, runtime), new ListUploadTasksResponse({}));
    } else {
      return $dara.cast<ListUploadTasksResponse>(await this.execute(params, req, runtime), new ListUploadTasksResponse({}));
    }

  }

  /**
   * Queries the execution status and running information of file upload tasks based on the task time and type.
   * 
   * @param request - ListUploadTasksRequest
   * @returns ListUploadTasksResponse
   */
  async listUploadTasks(request: ListUploadTasksRequest): Promise<ListUploadTasksResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listUploadTasksWithOptions(request, runtime);
  }

  /**
   * Queries all delivery tasks in your Alibaba Cloud account by page. You can filter the delivery tasks by the category of the delivered real-time logs.
   * 
   * @param request - ListUserDeliveryTasksRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListUserDeliveryTasksResponse
   */
  async listUserDeliveryTasksWithOptions(request: ListUserDeliveryTasksRequest, runtime: $dara.RuntimeOptions): Promise<ListUserDeliveryTasksResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListUserDeliveryTasks",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListUserDeliveryTasksResponse>(await this.callApi(params, req, runtime), new ListUserDeliveryTasksResponse({}));
    } else {
      return $dara.cast<ListUserDeliveryTasksResponse>(await this.execute(params, req, runtime), new ListUserDeliveryTasksResponse({}));
    }

  }

  /**
   * Queries all delivery tasks in your Alibaba Cloud account by page. You can filter the delivery tasks by the category of the delivered real-time logs.
   * 
   * @param request - ListUserDeliveryTasksRequest
   * @returns ListUserDeliveryTasksResponse
   */
  async listUserDeliveryTasks(request: ListUserDeliveryTasksRequest): Promise<ListUserDeliveryTasksResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listUserDeliveryTasksWithOptions(request, runtime);
  }

  /**
   * Queries the plans that you purchased and the details of the plans.
   * 
   * @param request - ListUserRatePlanInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListUserRatePlanInstancesResponse
   */
  async listUserRatePlanInstancesWithOptions(request: ListUserRatePlanInstancesRequest, runtime: $dara.RuntimeOptions): Promise<ListUserRatePlanInstancesResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListUserRatePlanInstances",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListUserRatePlanInstancesResponse>(await this.callApi(params, req, runtime), new ListUserRatePlanInstancesResponse({}));
    } else {
      return $dara.cast<ListUserRatePlanInstancesResponse>(await this.execute(params, req, runtime), new ListUserRatePlanInstancesResponse({}));
    }

  }

  /**
   * Queries the plans that you purchased and the details of the plans.
   * 
   * @param request - ListUserRatePlanInstancesRequest
   * @returns ListUserRatePlanInstancesResponse
   */
  async listUserRatePlanInstances(request: ListUserRatePlanInstancesRequest): Promise<ListUserRatePlanInstancesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listUserRatePlanInstancesWithOptions(request, runtime);
  }

  /**
   * Lists all Web Application Firewall (WAF) managed rules or some of them based on specific conditions. You can call this operation to query the details of WAF rules by page.
   * 
   * @param tmpReq - ListWafManagedRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListWafManagedRulesResponse
   */
  async listWafManagedRulesWithOptions(tmpReq: ListWafManagedRulesRequest, runtime: $dara.RuntimeOptions): Promise<ListWafManagedRulesResponse> {
    tmpReq.validate();
    let request = new ListWafManagedRulesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.queryArgs)) {
      request.queryArgsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.queryArgs, "QueryArgs", "json");
    }

    let query = { };
    if (!$dara.isNull(request.attackType)) {
      query["AttackType"] = request.attackType;
    }

    if (!$dara.isNull(request.id)) {
      query["Id"] = request.id;
    }

    if (!$dara.isNull(request.language)) {
      query["Language"] = request.language;
    }

    if (!$dara.isNull(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!$dara.isNull(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!$dara.isNull(request.protectionLevel)) {
      query["ProtectionLevel"] = request.protectionLevel;
    }

    if (!$dara.isNull(request.queryArgsShrink)) {
      query["QueryArgs"] = request.queryArgsShrink;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListWafManagedRules",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListWafManagedRulesResponse>(await this.callApi(params, req, runtime), new ListWafManagedRulesResponse({}));
    } else {
      return $dara.cast<ListWafManagedRulesResponse>(await this.execute(params, req, runtime), new ListWafManagedRulesResponse({}));
    }

  }

  /**
   * Lists all Web Application Firewall (WAF) managed rules or some of them based on specific conditions. You can call this operation to query the details of WAF rules by page.
   * 
   * @param request - ListWafManagedRulesRequest
   * @returns ListWafManagedRulesResponse
   */
  async listWafManagedRules(request: ListWafManagedRulesRequest): Promise<ListWafManagedRulesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listWafManagedRulesWithOptions(request, runtime);
  }

  /**
   * Queries the WAF rule categories that are applied to a website and related rulesets.
   * 
   * @param request - ListWafPhasesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListWafPhasesResponse
   */
  async listWafPhasesWithOptions(request: ListWafPhasesRequest, runtime: $dara.RuntimeOptions): Promise<ListWafPhasesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListWafPhases",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListWafPhasesResponse>(await this.callApi(params, req, runtime), new ListWafPhasesResponse({}));
    } else {
      return $dara.cast<ListWafPhasesResponse>(await this.execute(params, req, runtime), new ListWafPhasesResponse({}));
    }

  }

  /**
   * Queries the WAF rule categories that are applied to a website and related rulesets.
   * 
   * @param request - ListWafPhasesRequest
   * @returns ListWafPhasesResponse
   */
  async listWafPhases(request: ListWafPhasesRequest): Promise<ListWafPhasesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listWafPhasesWithOptions(request, runtime);
  }

  /**
   * Queries template rules in Web Application Firewall (WAF). In most cases, these rules are pre-defined rulesets that are used to quickly enable protection against common types of attacks.
   * 
   * @param tmpReq - ListWafTemplateRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListWafTemplateRulesResponse
   */
  async listWafTemplateRulesWithOptions(tmpReq: ListWafTemplateRulesRequest, runtime: $dara.RuntimeOptions): Promise<ListWafTemplateRulesResponse> {
    tmpReq.validate();
    let request = new ListWafTemplateRulesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.queryArgs)) {
      request.queryArgsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.queryArgs, "QueryArgs", "json");
    }

    let query = { };
    if (!$dara.isNull(request.phase)) {
      query["Phase"] = request.phase;
    }

    if (!$dara.isNull(request.queryArgsShrink)) {
      query["QueryArgs"] = request.queryArgsShrink;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListWafTemplateRules",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListWafTemplateRulesResponse>(await this.callApi(params, req, runtime), new ListWafTemplateRulesResponse({}));
    } else {
      return $dara.cast<ListWafTemplateRulesResponse>(await this.execute(params, req, runtime), new ListWafTemplateRulesResponse({}));
    }

  }

  /**
   * Queries template rules in Web Application Firewall (WAF). In most cases, these rules are pre-defined rulesets that are used to quickly enable protection against common types of attacks.
   * 
   * @param request - ListWafTemplateRulesRequest
   * @returns ListWafTemplateRulesResponse
   */
  async listWafTemplateRules(request: ListWafTemplateRulesRequest): Promise<ListWafTemplateRulesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listWafTemplateRulesWithOptions(request, runtime);
  }

  /**
   * Queries the usage details of WAF rules.
   * 
   * @param request - ListWafUsageOfRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListWafUsageOfRulesResponse
   */
  async listWafUsageOfRulesWithOptions(request: ListWafUsageOfRulesRequest, runtime: $dara.RuntimeOptions): Promise<ListWafUsageOfRulesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.phase)) {
      query["Phase"] = request.phase;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListWafUsageOfRules",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListWafUsageOfRulesResponse>(await this.callApi(params, req, runtime), new ListWafUsageOfRulesResponse({}));
    } else {
      return $dara.cast<ListWafUsageOfRulesResponse>(await this.execute(params, req, runtime), new ListWafUsageOfRulesResponse({}));
    }

  }

  /**
   * Queries the usage details of WAF rules.
   * 
   * @param request - ListWafUsageOfRulesRequest
   * @returns ListWafUsageOfRulesResponse
   */
  async listWafUsageOfRules(request: ListWafUsageOfRulesRequest): Promise<ListWafUsageOfRulesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listWafUsageOfRulesWithOptions(request, runtime);
  }

  /**
   * Queries the information about waiting room events for a waiting room.
   * 
   * @remarks
   * You can call this operation to query details of all waiting room events related to a waiting room in a website.
   * 
   * @param request - ListWaitingRoomEventsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListWaitingRoomEventsResponse
   */
  async listWaitingRoomEventsWithOptions(request: ListWaitingRoomEventsRequest, runtime: $dara.RuntimeOptions): Promise<ListWaitingRoomEventsResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListWaitingRoomEvents",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListWaitingRoomEventsResponse>(await this.callApi(params, req, runtime), new ListWaitingRoomEventsResponse({}));
    } else {
      return $dara.cast<ListWaitingRoomEventsResponse>(await this.execute(params, req, runtime), new ListWaitingRoomEventsResponse({}));
    }

  }

  /**
   * Queries the information about waiting room events for a waiting room.
   * 
   * @remarks
   * You can call this operation to query details of all waiting room events related to a waiting room in a website.
   * 
   * @param request - ListWaitingRoomEventsRequest
   * @returns ListWaitingRoomEventsResponse
   */
  async listWaitingRoomEvents(request: ListWaitingRoomEventsRequest): Promise<ListWaitingRoomEventsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listWaitingRoomEventsWithOptions(request, runtime);
  }

  /**
   * Queries the waiting room bypass rules configured for a waiting room.
   * 
   * @remarks
   * You can call this operation to query the waiting room bypass rules that are associated with a website.
   * 
   * @param request - ListWaitingRoomRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListWaitingRoomRulesResponse
   */
  async listWaitingRoomRulesWithOptions(request: ListWaitingRoomRulesRequest, runtime: $dara.RuntimeOptions): Promise<ListWaitingRoomRulesResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListWaitingRoomRules",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListWaitingRoomRulesResponse>(await this.callApi(params, req, runtime), new ListWaitingRoomRulesResponse({}));
    } else {
      return $dara.cast<ListWaitingRoomRulesResponse>(await this.execute(params, req, runtime), new ListWaitingRoomRulesResponse({}));
    }

  }

  /**
   * Queries the waiting room bypass rules configured for a waiting room.
   * 
   * @remarks
   * You can call this operation to query the waiting room bypass rules that are associated with a website.
   * 
   * @param request - ListWaitingRoomRulesRequest
   * @returns ListWaitingRoomRulesResponse
   */
  async listWaitingRoomRules(request: ListWaitingRoomRulesRequest): Promise<ListWaitingRoomRulesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listWaitingRoomRulesWithOptions(request, runtime);
  }

  /**
   * Queries the information about all waiting rooms in a website.
   * 
   * @remarks
   * You can call this operation to query detailed configurations about all waiting rooms in a website, including the status, name, and queuing rules of each waiting room.
   * 
   * @param request - ListWaitingRoomsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListWaitingRoomsResponse
   */
  async listWaitingRoomsWithOptions(request: ListWaitingRoomsRequest, runtime: $dara.RuntimeOptions): Promise<ListWaitingRoomsResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ListWaitingRooms",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ListWaitingRoomsResponse>(await this.callApi(params, req, runtime), new ListWaitingRoomsResponse({}));
    } else {
      return $dara.cast<ListWaitingRoomsResponse>(await this.execute(params, req, runtime), new ListWaitingRoomsResponse({}));
    }

  }

  /**
   * Queries the information about all waiting rooms in a website.
   * 
   * @remarks
   * You can call this operation to query detailed configurations about all waiting rooms in a website, including the status, name, and queuing rules of each waiting room.
   * 
   * @param request - ListWaitingRoomsRequest
   * @returns ListWaitingRoomsResponse
   */
  async listWaitingRooms(request: ListWaitingRoomsRequest): Promise<ListWaitingRoomsResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.listWaitingRoomsWithOptions(request, runtime);
  }

  /**
   * Prefetches cache.
   * 
   * @param tmpReq - PreloadCachesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PreloadCachesResponse
   */
  async preloadCachesWithOptions(tmpReq: PreloadCachesRequest, runtime: $dara.RuntimeOptions): Promise<PreloadCachesResponse> {
    tmpReq.validate();
    let request = new PreloadCachesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.content)) {
      request.contentShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.content, "Content", "json");
    }

    if (!$dara.isNull(tmpReq.headers)) {
      request.headersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.headers, "Headers", "json");
    }

    let query = { };
    if (!$dara.isNull(request.contentShrink)) {
      query["Content"] = request.contentShrink;
    }

    if (!$dara.isNull(request.headersShrink)) {
      query["Headers"] = request.headersShrink;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "PreloadCaches",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<PreloadCachesResponse>(await this.callApi(params, req, runtime), new PreloadCachesResponse({}));
    } else {
      return $dara.cast<PreloadCachesResponse>(await this.execute(params, req, runtime), new PreloadCachesResponse({}));
    }

  }

  /**
   * Prefetches cache.
   * 
   * @param request - PreloadCachesRequest
   * @returns PreloadCachesResponse
   */
  async preloadCaches(request: PreloadCachesRequest): Promise<PreloadCachesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.preloadCachesWithOptions(request, runtime);
  }

  /**
   * Releases a specific version of a containerized application. You can call this operation to iterate an application.
   * 
   * @param tmpReq - PublishEdgeContainerAppVersionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PublishEdgeContainerAppVersionResponse
   */
  async publishEdgeContainerAppVersionWithOptions(tmpReq: PublishEdgeContainerAppVersionRequest, runtime: $dara.RuntimeOptions): Promise<PublishEdgeContainerAppVersionResponse> {
    tmpReq.validate();
    let request = new PublishEdgeContainerAppVersionShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.regions)) {
      request.regionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.regions, "Regions", "json");
    }

    let query = { };
    if (!$dara.isNull(request.fullRelease)) {
      query["FullRelease"] = request.fullRelease;
    }

    if (!$dara.isNull(request.publishType)) {
      query["PublishType"] = request.publishType;
    }

    if (!$dara.isNull(request.regionsShrink)) {
      query["Regions"] = request.regionsShrink;
    }

    if (!$dara.isNull(request.versionId)) {
      query["VersionId"] = request.versionId;
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!$dara.isNull(request.percentage)) {
      body["Percentage"] = request.percentage;
    }

    if (!$dara.isNull(request.publishEnv)) {
      body["PublishEnv"] = request.publishEnv;
    }

    if (!$dara.isNull(request.remarks)) {
      body["Remarks"] = request.remarks;
    }

    if (!$dara.isNull(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "PublishEdgeContainerAppVersion",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<PublishEdgeContainerAppVersionResponse>(await this.callApi(params, req, runtime), new PublishEdgeContainerAppVersionResponse({}));
    } else {
      return $dara.cast<PublishEdgeContainerAppVersionResponse>(await this.execute(params, req, runtime), new PublishEdgeContainerAppVersionResponse({}));
    }

  }

  /**
   * Releases a specific version of a containerized application. You can call this operation to iterate an application.
   * 
   * @param request - PublishEdgeContainerAppVersionRequest
   * @returns PublishEdgeContainerAppVersionResponse
   */
  async publishEdgeContainerAppVersion(request: PublishEdgeContainerAppVersionRequest): Promise<PublishEdgeContainerAppVersionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.publishEdgeContainerAppVersionWithOptions(request, runtime);
  }

  /**
   * Releases a code version of a routine to the staging, canary, or production environment. You can specify the regions where the canary environment is deployed to release your code.
   * 
   * @param tmpReq - PublishRoutineCodeVersionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PublishRoutineCodeVersionResponse
   */
  async publishRoutineCodeVersionWithOptions(tmpReq: PublishRoutineCodeVersionRequest, runtime: $dara.RuntimeOptions): Promise<PublishRoutineCodeVersionResponse> {
    tmpReq.validate();
    let request = new PublishRoutineCodeVersionShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.canaryAreaList)) {
      request.canaryAreaListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.canaryAreaList, "CanaryAreaList", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.canaryAreaListShrink)) {
      body["CanaryAreaList"] = request.canaryAreaListShrink;
    }

    if (!$dara.isNull(request.canaryCodeVersion)) {
      body["CanaryCodeVersion"] = request.canaryCodeVersion;
    }

    if (!$dara.isNull(request.codeVersion)) {
      body["CodeVersion"] = request.codeVersion;
    }

    if (!$dara.isNull(request.env)) {
      body["Env"] = request.env;
    }

    if (!$dara.isNull(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "PublishRoutineCodeVersion",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<PublishRoutineCodeVersionResponse>(await this.callApi(params, req, runtime), new PublishRoutineCodeVersionResponse({}));
    } else {
      return $dara.cast<PublishRoutineCodeVersionResponse>(await this.execute(params, req, runtime), new PublishRoutineCodeVersionResponse({}));
    }

  }

  /**
   * Releases a code version of a routine to the staging, canary, or production environment. You can specify the regions where the canary environment is deployed to release your code.
   * 
   * @param request - PublishRoutineCodeVersionRequest
   * @returns PublishRoutineCodeVersionResponse
   */
  async publishRoutineCodeVersion(request: PublishRoutineCodeVersionRequest): Promise<PublishRoutineCodeVersionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.publishRoutineCodeVersionWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - PurchaseRatePlanRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PurchaseRatePlanResponse
   */
  async purchaseRatePlanWithOptions(request: PurchaseRatePlanRequest, runtime: $dara.RuntimeOptions): Promise<PurchaseRatePlanResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.autoPay)) {
      query["AutoPay"] = request.autoPay;
    }

    if (!$dara.isNull(request.autoRenew)) {
      query["AutoRenew"] = request.autoRenew;
    }

    if (!$dara.isNull(request.chargeType)) {
      query["ChargeType"] = request.chargeType;
    }

    if (!$dara.isNull(request.coverage)) {
      query["Coverage"] = request.coverage;
    }

    if (!$dara.isNull(request.period)) {
      query["Period"] = request.period;
    }

    if (!$dara.isNull(request.planCode)) {
      query["PlanCode"] = request.planCode;
    }

    if (!$dara.isNull(request.planName)) {
      query["PlanName"] = request.planName;
    }

    if (!$dara.isNull(request.siteName)) {
      query["SiteName"] = request.siteName;
    }

    if (!$dara.isNull(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "PurchaseRatePlan",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<PurchaseRatePlanResponse>(await this.callApi(params, req, runtime), new PurchaseRatePlanResponse({}));
    } else {
      return $dara.cast<PurchaseRatePlanResponse>(await this.execute(params, req, runtime), new PurchaseRatePlanResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - PurchaseRatePlanRequest
   * @returns PurchaseRatePlanResponse
   */
  async purchaseRatePlan(request: PurchaseRatePlanRequest): Promise<PurchaseRatePlanResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.purchaseRatePlanWithOptions(request, runtime);
  }

  /**
   * Purges resources cached on points of presence (POPs). You can purge the cache by file URL, directory, cache tag, hostname, or URL with specified parameters ignored, or purge all the cache.
   * 
   * @param tmpReq - PurgeCachesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PurgeCachesResponse
   */
  async purgeCachesWithOptions(tmpReq: PurgeCachesRequest, runtime: $dara.RuntimeOptions): Promise<PurgeCachesResponse> {
    tmpReq.validate();
    let request = new PurgeCachesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.content)) {
      request.contentShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.content, "Content", "json");
    }

    let query = { };
    if (!$dara.isNull(request.contentShrink)) {
      query["Content"] = request.contentShrink;
    }

    if (!$dara.isNull(request.edgeComputePurge)) {
      query["EdgeComputePurge"] = request.edgeComputePurge;
    }

    if (!$dara.isNull(request.force)) {
      query["Force"] = request.force;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "PurgeCaches",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<PurgeCachesResponse>(await this.callApi(params, req, runtime), new PurgeCachesResponse({}));
    } else {
      return $dara.cast<PurgeCachesResponse>(await this.execute(params, req, runtime), new PurgeCachesResponse({}));
    }

  }

  /**
   * Purges resources cached on points of presence (POPs). You can purge the cache by file URL, directory, cache tag, hostname, or URL with specified parameters ignored, or purge all the cache.
   * 
   * @param request - PurgeCachesRequest
   * @returns PurgeCachesResponse
   */
  async purgeCaches(request: PurgeCachesRequest): Promise<PurgeCachesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.purgeCachesWithOptions(request, runtime);
  }

  /**
   * Configures a key-value pair for a namespace. The request body can be up to 2 MB.
   * 
   * @param request - PutKvRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PutKvResponse
   */
  async putKvWithOptions(request: PutKvRequest, runtime: $dara.RuntimeOptions): Promise<PutKvResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.base64)) {
      query["Base64"] = request.base64;
    }

    if (!$dara.isNull(request.expiration)) {
      query["Expiration"] = request.expiration;
    }

    if (!$dara.isNull(request.expirationTtl)) {
      query["ExpirationTtl"] = request.expirationTtl;
    }

    if (!$dara.isNull(request.key)) {
      query["Key"] = request.key;
    }

    if (!$dara.isNull(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.value)) {
      body["Value"] = request.value;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "PutKv",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<PutKvResponse>(await this.callApi(params, req, runtime), new PutKvResponse({}));
    } else {
      return $dara.cast<PutKvResponse>(await this.execute(params, req, runtime), new PutKvResponse({}));
    }

  }

  /**
   * Configures a key-value pair for a namespace. The request body can be up to 2 MB.
   * 
   * @param request - PutKvRequest
   * @returns PutKvResponse
   */
  async putKv(request: PutKvRequest): Promise<PutKvResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.putKvWithOptions(request, runtime);
  }

  /**
   * Configures a large key-value pair for a namespace. The request body can be up to 25 MB.
   * 
   * @remarks
   * This operation allows you to upload a larger request body than by using [PutKv](~~PutKv~~). For small request bodies, we recommend that you use [PutKv](~~PutKv~~) to minimize the server processing time. This operation must be called by using SDKs. The following sample code uses the Golang SDK and PutKvWithHighCapacityAdvance to call the operation.
   *     func TestPutKvWithHighCapacity() {
   *     	// Initialize the configurations.
   *     	cfg := new(openapi.Config)
   *     	cfg.SetAccessKeyId("xxxxxxxxx")
   *     	cfg.SetAccessKeySecret("xxxxxxxxxx")
   *     	cli, err := NewClient(cfg)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	runtime := &util.RuntimeOptions{}
   *     	// Construct a request for uploading key-value pairs.
   *     	namespace := "test-put-kv"
   *     	key := "test_PutKvWithHighCapacity_0"
   *     	value := strings.Repeat("t", 10*1024*1024)
   *     	rawReq := &PutKvRequest{
   *     		Namespace: &namespace,
   *     		Key:       &key,
   *     		Value:     &value,
   *     	}
   *     	payload, err := json.Marshal(rawReq)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	// If the payload is greater than 2 MB, call the PutKvWithHighCapacity operation for upload.
   *     	reqHighCapacity := &PutKvWithHighCapacityAdvanceRequest{
   *     		Namespace: &namespace,
   *     		Key:       &key,
   *     		UrlObject: bytes.NewReader([]byte(payload)),
   *     	}
   *     	resp, err := cli.PutKvWithHighCapacityAdvance(reqHighCapacity, runtime)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	return nil
   *     }
   * 
   * @param request - PutKvWithHighCapacityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PutKvWithHighCapacityResponse
   */
  async putKvWithHighCapacityWithOptions(request: PutKvWithHighCapacityRequest, runtime: $dara.RuntimeOptions): Promise<PutKvWithHighCapacityResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.key)) {
      query["Key"] = request.key;
    }

    if (!$dara.isNull(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!$dara.isNull(request.url)) {
      query["Url"] = request.url;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "PutKvWithHighCapacity",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<PutKvWithHighCapacityResponse>(await this.callApi(params, req, runtime), new PutKvWithHighCapacityResponse({}));
    } else {
      return $dara.cast<PutKvWithHighCapacityResponse>(await this.execute(params, req, runtime), new PutKvWithHighCapacityResponse({}));
    }

  }

  /**
   * Configures a large key-value pair for a namespace. The request body can be up to 25 MB.
   * 
   * @remarks
   * This operation allows you to upload a larger request body than by using [PutKv](~~PutKv~~). For small request bodies, we recommend that you use [PutKv](~~PutKv~~) to minimize the server processing time. This operation must be called by using SDKs. The following sample code uses the Golang SDK and PutKvWithHighCapacityAdvance to call the operation.
   *     func TestPutKvWithHighCapacity() {
   *     	// Initialize the configurations.
   *     	cfg := new(openapi.Config)
   *     	cfg.SetAccessKeyId("xxxxxxxxx")
   *     	cfg.SetAccessKeySecret("xxxxxxxxxx")
   *     	cli, err := NewClient(cfg)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	runtime := &util.RuntimeOptions{}
   *     	// Construct a request for uploading key-value pairs.
   *     	namespace := "test-put-kv"
   *     	key := "test_PutKvWithHighCapacity_0"
   *     	value := strings.Repeat("t", 10*1024*1024)
   *     	rawReq := &PutKvRequest{
   *     		Namespace: &namespace,
   *     		Key:       &key,
   *     		Value:     &value,
   *     	}
   *     	payload, err := json.Marshal(rawReq)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	// If the payload is greater than 2 MB, call the PutKvWithHighCapacity operation for upload.
   *     	reqHighCapacity := &PutKvWithHighCapacityAdvanceRequest{
   *     		Namespace: &namespace,
   *     		Key:       &key,
   *     		UrlObject: bytes.NewReader([]byte(payload)),
   *     	}
   *     	resp, err := cli.PutKvWithHighCapacityAdvance(reqHighCapacity, runtime)
   *     	if err != nil {
   *     		return err
   *     	}
   *     	return nil
   *     }
   * 
   * @param request - PutKvWithHighCapacityRequest
   * @returns PutKvWithHighCapacityResponse
   */
  async putKvWithHighCapacity(request: PutKvWithHighCapacityRequest): Promise<PutKvWithHighCapacityResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.putKvWithHighCapacityWithOptions(request, runtime);
  }

  async putKvWithHighCapacityAdvance(request: PutKvWithHighCapacityAdvanceRequest, runtime: $dara.RuntimeOptions): Promise<PutKvWithHighCapacityResponse> {
    // Step 0: init client
    let accessKeyId = await this._credential.getAccessKeyId();
    let accessKeySecret = await this._credential.getAccessKeySecret();
    let securityToken = await this._credential.getSecurityToken();
    let credentialType = this._credential.getType();
    let openPlatformEndpoint = this._openPlatformEndpoint;
    if ($dara.isNull(openPlatformEndpoint)) {
      openPlatformEndpoint = "openplatform.aliyuncs.com";
    }

    if ($dara.isNull(credentialType)) {
      credentialType = "access_key";
    }

    let authConfig = new $OpenApiUtil.Config({
      accessKeyId: accessKeyId,
      accessKeySecret: accessKeySecret,
      securityToken: securityToken,
      type: credentialType,
      endpoint: openPlatformEndpoint,
      protocol: this._protocol,
      regionId: this._regionId,
    });
    let authClient = new OpenPlatform(authConfig);
    let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
      product: "ESA",
      regionId: this._regionId,
    });
    let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({ });
    let ossConfig = new $OSS.Config({
      accessKeyId: accessKeyId,
      accessKeySecret: accessKeySecret,
      type: "access_key",
      protocol: this._protocol,
      regionId: this._regionId,
    });
    let ossClient : OSS = new OSS(ossConfig);
    let fileObj = new $FileForm.FileField({ });
    let ossHeader = new $OSS.PostObjectRequestHeader({ });
    let uploadRequest = new $OSS.PostObjectRequest({ });
    let ossRuntime = new $OSSUtil.RuntimeOptions({ });
    OpenApiUtil.convert(runtime, ossRuntime);
    let putKvWithHighCapacityReq = new PutKvWithHighCapacityRequest({ });
    OpenApiUtil.convert(request, putKvWithHighCapacityReq);
    if (!$dara.isNull(request.urlObject)) {
      authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
      ossConfig.accessKeyId = authResponse.body.accessKeyId;
      ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
      ossClient = new OSS(ossConfig);
      fileObj = new $FileForm.FileField({
        filename: authResponse.body.objectKey,
        content: request.urlObject,
        contentType: "",
      });
      ossHeader = new $OSS.PostObjectRequestHeader({
        accessKeyId: authResponse.body.accessKeyId,
        policy: authResponse.body.encodedPolicy,
        signature: authResponse.body.signature,
        key: authResponse.body.objectKey,
        file: fileObj,
        successActionStatus: "201",
      });
      uploadRequest = new $OSS.PostObjectRequest({
        bucketName: authResponse.body.bucket,
        header: ossHeader,
      });
      await ossClient.postObject(uploadRequest, ossRuntime);
      putKvWithHighCapacityReq.url = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
    }

    let putKvWithHighCapacityResp = await this.putKvWithHighCapacityWithOptions(putKvWithHighCapacityReq, runtime);
    return putKvWithHighCapacityResp;
  }

  /**
   * Rebuilds the staging environment for containerized applications.
   * 
   * @param request - RebuildEdgeContainerAppStagingEnvRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RebuildEdgeContainerAppStagingEnvResponse
   */
  async rebuildEdgeContainerAppStagingEnvWithOptions(request: RebuildEdgeContainerAppStagingEnvRequest, runtime: $dara.RuntimeOptions): Promise<RebuildEdgeContainerAppStagingEnvResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.appId)) {
      query["AppId"] = request.appId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "RebuildEdgeContainerAppStagingEnv",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<RebuildEdgeContainerAppStagingEnvResponse>(await this.callApi(params, req, runtime), new RebuildEdgeContainerAppStagingEnvResponse({}));
    } else {
      return $dara.cast<RebuildEdgeContainerAppStagingEnvResponse>(await this.execute(params, req, runtime), new RebuildEdgeContainerAppStagingEnvResponse({}));
    }

  }

  /**
   * Rebuilds the staging environment for containerized applications.
   * 
   * @param request - RebuildEdgeContainerAppStagingEnvRequest
   * @returns RebuildEdgeContainerAppStagingEnvResponse
   */
  async rebuildEdgeContainerAppStagingEnv(request: RebuildEdgeContainerAppStagingEnvRequest): Promise<RebuildEdgeContainerAppStagingEnvResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.rebuildEdgeContainerAppStagingEnvWithOptions(request, runtime);
  }

  /**
   * Resets the progress of a scheduled prefetch task and starts the prefetch from the beginning.
   * 
   * @param request - ResetScheduledPreloadJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ResetScheduledPreloadJobResponse
   */
  async resetScheduledPreloadJobWithOptions(request: ResetScheduledPreloadJobRequest, runtime: $dara.RuntimeOptions): Promise<ResetScheduledPreloadJobResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "ResetScheduledPreloadJob",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<ResetScheduledPreloadJobResponse>(await this.callApi(params, req, runtime), new ResetScheduledPreloadJobResponse({}));
    } else {
      return $dara.cast<ResetScheduledPreloadJobResponse>(await this.execute(params, req, runtime), new ResetScheduledPreloadJobResponse({}));
    }

  }

  /**
   * Resets the progress of a scheduled prefetch task and starts the prefetch from the beginning.
   * 
   * @param request - ResetScheduledPreloadJobRequest
   * @returns ResetScheduledPreloadJobResponse
   */
  async resetScheduledPreloadJob(request: ResetScheduledPreloadJobRequest): Promise<ResetScheduledPreloadJobResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.resetScheduledPreloadJobWithOptions(request, runtime);
  }

  /**
   * Revokes an activated client certificate.
   * 
   * @param request - RevokeClientCertificateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RevokeClientCertificateResponse
   */
  async revokeClientCertificateWithOptions(request: RevokeClientCertificateRequest, runtime: $dara.RuntimeOptions): Promise<RevokeClientCertificateResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "RevokeClientCertificate",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<RevokeClientCertificateResponse>(await this.callApi(params, req, runtime), new RevokeClientCertificateResponse({}));
    } else {
      return $dara.cast<RevokeClientCertificateResponse>(await this.execute(params, req, runtime), new RevokeClientCertificateResponse({}));
    }

  }

  /**
   * Revokes an activated client certificate.
   * 
   * @param request - RevokeClientCertificateRequest
   * @returns RevokeClientCertificateResponse
   */
  async revokeClientCertificate(request: RevokeClientCertificateRequest): Promise<RevokeClientCertificateResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.revokeClientCertificateWithOptions(request, runtime);
  }

  /**
   * Rolls back a version of a containerized application.
   * 
   * @param request - RollbackEdgeContainerAppVersionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RollbackEdgeContainerAppVersionResponse
   */
  async rollbackEdgeContainerAppVersionWithOptions(request: RollbackEdgeContainerAppVersionRequest, runtime: $dara.RuntimeOptions): Promise<RollbackEdgeContainerAppVersionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.versionId)) {
      query["VersionId"] = request.versionId;
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!$dara.isNull(request.remarks)) {
      body["Remarks"] = request.remarks;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "RollbackEdgeContainerAppVersion",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<RollbackEdgeContainerAppVersionResponse>(await this.callApi(params, req, runtime), new RollbackEdgeContainerAppVersionResponse({}));
    } else {
      return $dara.cast<RollbackEdgeContainerAppVersionResponse>(await this.execute(params, req, runtime), new RollbackEdgeContainerAppVersionResponse({}));
    }

  }

  /**
   * Rolls back a version of a containerized application.
   * 
   * @param request - RollbackEdgeContainerAppVersionRequest
   * @returns RollbackEdgeContainerAppVersionResponse
   */
  async rollbackEdgeContainerAppVersion(request: RollbackEdgeContainerAppVersionRequest): Promise<RollbackEdgeContainerAppVersionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.rollbackEdgeContainerAppVersionWithOptions(request, runtime);
  }

  /**
   * Configures whether to enable certificates and update certificate information for a website.
   * 
   * @param request - SetCertificateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetCertificateResponse
   */
  async setCertificateWithOptions(request: SetCertificateRequest, runtime: $dara.RuntimeOptions): Promise<SetCertificateResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.casId)) {
      body["CasId"] = request.casId;
    }

    if (!$dara.isNull(request.certificate)) {
      body["Certificate"] = request.certificate;
    }

    if (!$dara.isNull(request.id)) {
      body["Id"] = request.id;
    }

    if (!$dara.isNull(request.name)) {
      body["Name"] = request.name;
    }

    if (!$dara.isNull(request.privateKey)) {
      body["PrivateKey"] = request.privateKey;
    }

    if (!$dara.isNull(request.region)) {
      body["Region"] = request.region;
    }

    if (!$dara.isNull(request.siteId)) {
      body["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.type)) {
      body["Type"] = request.type;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "SetCertificate",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<SetCertificateResponse>(await this.callApi(params, req, runtime), new SetCertificateResponse({}));
    } else {
      return $dara.cast<SetCertificateResponse>(await this.execute(params, req, runtime), new SetCertificateResponse({}));
    }

  }

  /**
   * Configures whether to enable certificates and update certificate information for a website.
   * 
   * @param request - SetCertificateRequest
   * @returns SetCertificateResponse
   */
  async setCertificate(request: SetCertificateRequest): Promise<SetCertificateResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.setCertificateWithOptions(request, runtime);
  }

  /**
   * Associates domain names with a client CA certificate. If no certificate is specified, domain names are associated with an Edge Security Acceleration (ESA)-managed CA certificate.
   * 
   * @param tmpReq - SetClientCertificateHostnamesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetClientCertificateHostnamesResponse
   */
  async setClientCertificateHostnamesWithOptions(tmpReq: SetClientCertificateHostnamesRequest, runtime: $dara.RuntimeOptions): Promise<SetClientCertificateHostnamesResponse> {
    tmpReq.validate();
    let request = new SetClientCertificateHostnamesShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.hostnames)) {
      request.hostnamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.hostnames, "Hostnames", "json");
    }

    let query = { };
    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.hostnamesShrink)) {
      body["Hostnames"] = request.hostnamesShrink;
    }

    if (!$dara.isNull(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "SetClientCertificateHostnames",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<SetClientCertificateHostnamesResponse>(await this.callApi(params, req, runtime), new SetClientCertificateHostnamesResponse({}));
    } else {
      return $dara.cast<SetClientCertificateHostnamesResponse>(await this.execute(params, req, runtime), new SetClientCertificateHostnamesResponse({}));
    }

  }

  /**
   * Associates domain names with a client CA certificate. If no certificate is specified, domain names are associated with an Edge Security Acceleration (ESA)-managed CA certificate.
   * 
   * @param request - SetClientCertificateHostnamesRequest
   * @returns SetClientCertificateHostnamesResponse
   */
  async setClientCertificateHostnames(request: SetClientCertificateHostnamesRequest): Promise<SetClientCertificateHostnamesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.setClientCertificateHostnamesWithOptions(request, runtime);
  }

  /**
   * Configures smart HTTP DDoS protection.
   * 
   * @param request - SetHttpDDoSAttackIntelligentProtectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetHttpDDoSAttackIntelligentProtectionResponse
   */
  async setHttpDDoSAttackIntelligentProtectionWithOptions(request: SetHttpDDoSAttackIntelligentProtectionRequest, runtime: $dara.RuntimeOptions): Promise<SetHttpDDoSAttackIntelligentProtectionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.aiMode)) {
      query["AiMode"] = request.aiMode;
    }

    if (!$dara.isNull(request.aiTemplate)) {
      query["AiTemplate"] = request.aiTemplate;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "SetHttpDDoSAttackIntelligentProtection",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<SetHttpDDoSAttackIntelligentProtectionResponse>(await this.callApi(params, req, runtime), new SetHttpDDoSAttackIntelligentProtectionResponse({}));
    } else {
      return $dara.cast<SetHttpDDoSAttackIntelligentProtectionResponse>(await this.execute(params, req, runtime), new SetHttpDDoSAttackIntelligentProtectionResponse({}));
    }

  }

  /**
   * Configures smart HTTP DDoS protection.
   * 
   * @param request - SetHttpDDoSAttackIntelligentProtectionRequest
   * @returns SetHttpDDoSAttackIntelligentProtectionResponse
   */
  async setHttpDDoSAttackIntelligentProtection(request: SetHttpDDoSAttackIntelligentProtectionRequest): Promise<SetHttpDDoSAttackIntelligentProtectionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.setHttpDDoSAttackIntelligentProtectionWithOptions(request, runtime);
  }

  /**
   * Configures HTTP DDoS attack protection for a website.
   * 
   * @param request - SetHttpDDoSAttackProtectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetHttpDDoSAttackProtectionResponse
   */
  async setHttpDDoSAttackProtectionWithOptions(request: SetHttpDDoSAttackProtectionRequest, runtime: $dara.RuntimeOptions): Promise<SetHttpDDoSAttackProtectionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.globalMode)) {
      query["GlobalMode"] = request.globalMode;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "SetHttpDDoSAttackProtection",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<SetHttpDDoSAttackProtectionResponse>(await this.callApi(params, req, runtime), new SetHttpDDoSAttackProtectionResponse({}));
    } else {
      return $dara.cast<SetHttpDDoSAttackProtectionResponse>(await this.execute(params, req, runtime), new SetHttpDDoSAttackProtectionResponse({}));
    }

  }

  /**
   * Configures HTTP DDoS attack protection for a website.
   * 
   * @param request - SetHttpDDoSAttackProtectionRequest
   * @returns SetHttpDDoSAttackProtectionResponse
   */
  async setHttpDDoSAttackProtection(request: SetHttpDDoSAttackProtectionRequest): Promise<SetHttpDDoSAttackProtectionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.setHttpDDoSAttackProtectionWithOptions(request, runtime);
  }

  /**
   * Starts a scheduled prefetch plan based on the plan ID.
   * 
   * @param request - StartScheduledPreloadExecutionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StartScheduledPreloadExecutionResponse
   */
  async startScheduledPreloadExecutionWithOptions(request: StartScheduledPreloadExecutionRequest, runtime: $dara.RuntimeOptions): Promise<StartScheduledPreloadExecutionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "StartScheduledPreloadExecution",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<StartScheduledPreloadExecutionResponse>(await this.callApi(params, req, runtime), new StartScheduledPreloadExecutionResponse({}));
    } else {
      return $dara.cast<StartScheduledPreloadExecutionResponse>(await this.execute(params, req, runtime), new StartScheduledPreloadExecutionResponse({}));
    }

  }

  /**
   * Starts a scheduled prefetch plan based on the plan ID.
   * 
   * @param request - StartScheduledPreloadExecutionRequest
   * @returns StartScheduledPreloadExecutionResponse
   */
  async startScheduledPreloadExecution(request: StartScheduledPreloadExecutionRequest): Promise<StartScheduledPreloadExecutionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.startScheduledPreloadExecutionWithOptions(request, runtime);
  }

  /**
   * Stops a scheduled prefetch plan based on the plan ID.
   * 
   * @param request - StopScheduledPreloadExecutionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StopScheduledPreloadExecutionResponse
   */
  async stopScheduledPreloadExecutionWithOptions(request: StopScheduledPreloadExecutionRequest, runtime: $dara.RuntimeOptions): Promise<StopScheduledPreloadExecutionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "StopScheduledPreloadExecution",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<StopScheduledPreloadExecutionResponse>(await this.callApi(params, req, runtime), new StopScheduledPreloadExecutionResponse({}));
    } else {
      return $dara.cast<StopScheduledPreloadExecutionResponse>(await this.execute(params, req, runtime), new StopScheduledPreloadExecutionResponse({}));
    }

  }

  /**
   * Stops a scheduled prefetch plan based on the plan ID.
   * 
   * @param request - StopScheduledPreloadExecutionRequest
   * @returns StopScheduledPreloadExecutionResponse
   */
  async stopScheduledPreloadExecution(request: StopScheduledPreloadExecutionRequest): Promise<StopScheduledPreloadExecutionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.stopScheduledPreloadExecutionWithOptions(request, runtime);
  }

  /**
   * Deletes a resource tag based on a specified resource ID.
   * 
   * @param request - UntagResourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UntagResourcesResponse
   */
  async untagResourcesWithOptions(request: UntagResourcesRequest, runtime: $dara.RuntimeOptions): Promise<UntagResourcesResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.all)) {
      query["All"] = request.all;
    }

    if (!$dara.isNull(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!$dara.isNull(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!$dara.isNull(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!$dara.isNull(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!$dara.isNull(request.securityToken)) {
      query["SecurityToken"] = request.securityToken;
    }

    if (!$dara.isNull(request.tagKey)) {
      query["TagKey"] = request.tagKey;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UntagResources",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UntagResourcesResponse>(await this.callApi(params, req, runtime), new UntagResourcesResponse({}));
    } else {
      return $dara.cast<UntagResourcesResponse>(await this.execute(params, req, runtime), new UntagResourcesResponse({}));
    }

  }

  /**
   * Deletes a resource tag based on a specified resource ID.
   * 
   * @param request - UntagResourcesRequest
   * @returns UntagResourcesResponse
   */
  async untagResources(request: UntagResourcesRequest): Promise<UntagResourcesResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.untagResourcesWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - UpdateCacheRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateCacheRuleResponse
   */
  async updateCacheRuleWithOptions(request: UpdateCacheRuleRequest, runtime: $dara.RuntimeOptions): Promise<UpdateCacheRuleResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.additionalCacheablePorts)) {
      query["AdditionalCacheablePorts"] = request.additionalCacheablePorts;
    }

    if (!$dara.isNull(request.browserCacheMode)) {
      query["BrowserCacheMode"] = request.browserCacheMode;
    }

    if (!$dara.isNull(request.browserCacheTtl)) {
      query["BrowserCacheTtl"] = request.browserCacheTtl;
    }

    if (!$dara.isNull(request.bypassCache)) {
      query["BypassCache"] = request.bypassCache;
    }

    if (!$dara.isNull(request.cacheDeceptionArmor)) {
      query["CacheDeceptionArmor"] = request.cacheDeceptionArmor;
    }

    if (!$dara.isNull(request.cacheReserveEligibility)) {
      query["CacheReserveEligibility"] = request.cacheReserveEligibility;
    }

    if (!$dara.isNull(request.checkPresenceCookie)) {
      query["CheckPresenceCookie"] = request.checkPresenceCookie;
    }

    if (!$dara.isNull(request.checkPresenceHeader)) {
      query["CheckPresenceHeader"] = request.checkPresenceHeader;
    }

    if (!$dara.isNull(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!$dara.isNull(request.edgeCacheMode)) {
      query["EdgeCacheMode"] = request.edgeCacheMode;
    }

    if (!$dara.isNull(request.edgeCacheTtl)) {
      query["EdgeCacheTtl"] = request.edgeCacheTtl;
    }

    if (!$dara.isNull(request.edgeStatusCodeCacheTtl)) {
      query["EdgeStatusCodeCacheTtl"] = request.edgeStatusCodeCacheTtl;
    }

    if (!$dara.isNull(request.includeCookie)) {
      query["IncludeCookie"] = request.includeCookie;
    }

    if (!$dara.isNull(request.includeHeader)) {
      query["IncludeHeader"] = request.includeHeader;
    }

    if (!$dara.isNull(request.queryString)) {
      query["QueryString"] = request.queryString;
    }

    if (!$dara.isNull(request.queryStringMode)) {
      query["QueryStringMode"] = request.queryStringMode;
    }

    if (!$dara.isNull(request.rule)) {
      query["Rule"] = request.rule;
    }

    if (!$dara.isNull(request.ruleEnable)) {
      query["RuleEnable"] = request.ruleEnable;
    }

    if (!$dara.isNull(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!$dara.isNull(request.serveStale)) {
      query["ServeStale"] = request.serveStale;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.sortQueryStringForCache)) {
      query["SortQueryStringForCache"] = request.sortQueryStringForCache;
    }

    if (!$dara.isNull(request.userDeviceType)) {
      query["UserDeviceType"] = request.userDeviceType;
    }

    if (!$dara.isNull(request.userGeo)) {
      query["UserGeo"] = request.userGeo;
    }

    if (!$dara.isNull(request.userLanguage)) {
      query["UserLanguage"] = request.userLanguage;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateCacheRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateCacheRuleResponse>(await this.callApi(params, req, runtime), new UpdateCacheRuleResponse({}));
    } else {
      return $dara.cast<UpdateCacheRuleResponse>(await this.execute(params, req, runtime), new UpdateCacheRuleResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - UpdateCacheRuleRequest
   * @returns UpdateCacheRuleResponse
   */
  async updateCacheRule(request: UpdateCacheRuleRequest): Promise<UpdateCacheRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateCacheRuleWithOptions(request, runtime);
  }

  /**
   * Tag
   * 
   * @param request - UpdateCacheTagRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateCacheTagResponse
   */
  async updateCacheTagWithOptions(request: UpdateCacheTagRequest, runtime: $dara.RuntimeOptions): Promise<UpdateCacheTagResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.caseInsensitive)) {
      query["CaseInsensitive"] = request.caseInsensitive;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    if (!$dara.isNull(request.tagName)) {
      query["TagName"] = request.tagName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateCacheTag",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateCacheTagResponse>(await this.callApi(params, req, runtime), new UpdateCacheTagResponse({}));
    } else {
      return $dara.cast<UpdateCacheTagResponse>(await this.execute(params, req, runtime), new UpdateCacheTagResponse({}));
    }

  }

  /**
   * Tag
   * 
   * @param request - UpdateCacheTagRequest
   * @returns UpdateCacheTagResponse
   */
  async updateCacheTag(request: UpdateCacheTagRequest): Promise<UpdateCacheTagResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateCacheTagWithOptions(request, runtime);
  }

  /**
   * cname
   * 
   * @param request - UpdateCnameFlatteningRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateCnameFlatteningResponse
   */
  async updateCnameFlatteningWithOptions(request: UpdateCnameFlatteningRequest, runtime: $dara.RuntimeOptions): Promise<UpdateCnameFlatteningResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.flattenMode)) {
      query["FlattenMode"] = request.flattenMode;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateCnameFlattening",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateCnameFlatteningResponse>(await this.callApi(params, req, runtime), new UpdateCnameFlatteningResponse({}));
    } else {
      return $dara.cast<UpdateCnameFlatteningResponse>(await this.execute(params, req, runtime), new UpdateCnameFlatteningResponse({}));
    }

  }

  /**
   * cname
   * 
   * @param request - UpdateCnameFlatteningRequest
   * @returns UpdateCnameFlatteningResponse
   */
  async updateCnameFlattening(request: UpdateCnameFlatteningRequest): Promise<UpdateCnameFlatteningResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateCnameFlatteningWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - UpdateCompressionRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateCompressionRuleResponse
   */
  async updateCompressionRuleWithOptions(request: UpdateCompressionRuleRequest, runtime: $dara.RuntimeOptions): Promise<UpdateCompressionRuleResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.brotli)) {
      query["Brotli"] = request.brotli;
    }

    if (!$dara.isNull(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!$dara.isNull(request.gzip)) {
      query["Gzip"] = request.gzip;
    }

    if (!$dara.isNull(request.rule)) {
      query["Rule"] = request.rule;
    }

    if (!$dara.isNull(request.ruleEnable)) {
      query["RuleEnable"] = request.ruleEnable;
    }

    if (!$dara.isNull(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.zstd)) {
      query["Zstd"] = request.zstd;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateCompressionRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateCompressionRuleResponse>(await this.callApi(params, req, runtime), new UpdateCompressionRuleResponse({}));
    } else {
      return $dara.cast<UpdateCompressionRuleResponse>(await this.execute(params, req, runtime), new UpdateCompressionRuleResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - UpdateCompressionRuleRequest
   * @returns UpdateCompressionRuleResponse
   */
  async updateCompressionRule(request: UpdateCompressionRuleRequest): Promise<UpdateCompressionRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateCompressionRuleWithOptions(request, runtime);
  }

  /**
   * Modifies the configurations of a custom scenario-specific policy.
   * 
   * @param request - UpdateCustomScenePolicyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateCustomScenePolicyResponse
   */
  async updateCustomScenePolicyWithOptions(request: UpdateCustomScenePolicyRequest, runtime: $dara.RuntimeOptions): Promise<UpdateCustomScenePolicyResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.objects)) {
      query["Objects"] = request.objects;
    }

    if (!$dara.isNull(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    if (!$dara.isNull(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!$dara.isNull(request.template)) {
      query["Template"] = request.template;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateCustomScenePolicy",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateCustomScenePolicyResponse>(await this.callApi(params, req, runtime), new UpdateCustomScenePolicyResponse({}));
    } else {
      return $dara.cast<UpdateCustomScenePolicyResponse>(await this.execute(params, req, runtime), new UpdateCustomScenePolicyResponse({}));
    }

  }

  /**
   * Modifies the configurations of a custom scenario-specific policy.
   * 
   * @param request - UpdateCustomScenePolicyRequest
   * @returns UpdateCustomScenePolicyResponse
   */
  async updateCustomScenePolicy(request: UpdateCustomScenePolicyRequest): Promise<UpdateCustomScenePolicyResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateCustomScenePolicyWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - UpdateDevelopmentModeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateDevelopmentModeResponse
   */
  async updateDevelopmentModeWithOptions(request: UpdateDevelopmentModeRequest, runtime: $dara.RuntimeOptions): Promise<UpdateDevelopmentModeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateDevelopmentMode",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateDevelopmentModeResponse>(await this.callApi(params, req, runtime), new UpdateDevelopmentModeResponse({}));
    } else {
      return $dara.cast<UpdateDevelopmentModeResponse>(await this.execute(params, req, runtime), new UpdateDevelopmentModeResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - UpdateDevelopmentModeRequest
   * @returns UpdateDevelopmentModeResponse
   */
  async updateDevelopmentMode(request: UpdateDevelopmentModeRequest): Promise<UpdateDevelopmentModeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateDevelopmentModeWithOptions(request, runtime);
  }

  /**
   * HTTP
   * 
   * @param tmpReq - UpdateHttpRequestHeaderModificationRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateHttpRequestHeaderModificationRuleResponse
   */
  async updateHttpRequestHeaderModificationRuleWithOptions(tmpReq: UpdateHttpRequestHeaderModificationRuleRequest, runtime: $dara.RuntimeOptions): Promise<UpdateHttpRequestHeaderModificationRuleResponse> {
    tmpReq.validate();
    let request = new UpdateHttpRequestHeaderModificationRuleShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.requestHeaderModification)) {
      request.requestHeaderModificationShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.requestHeaderModification, "RequestHeaderModification", "json");
    }

    let query = { };
    if (!$dara.isNull(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!$dara.isNull(request.requestHeaderModificationShrink)) {
      query["RequestHeaderModification"] = request.requestHeaderModificationShrink;
    }

    if (!$dara.isNull(request.rule)) {
      query["Rule"] = request.rule;
    }

    if (!$dara.isNull(request.ruleEnable)) {
      query["RuleEnable"] = request.ruleEnable;
    }

    if (!$dara.isNull(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateHttpRequestHeaderModificationRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateHttpRequestHeaderModificationRuleResponse>(await this.callApi(params, req, runtime), new UpdateHttpRequestHeaderModificationRuleResponse({}));
    } else {
      return $dara.cast<UpdateHttpRequestHeaderModificationRuleResponse>(await this.execute(params, req, runtime), new UpdateHttpRequestHeaderModificationRuleResponse({}));
    }

  }

  /**
   * HTTP
   * 
   * @param request - UpdateHttpRequestHeaderModificationRuleRequest
   * @returns UpdateHttpRequestHeaderModificationRuleResponse
   */
  async updateHttpRequestHeaderModificationRule(request: UpdateHttpRequestHeaderModificationRuleRequest): Promise<UpdateHttpRequestHeaderModificationRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateHttpRequestHeaderModificationRuleWithOptions(request, runtime);
  }

  /**
   * HTTP
   * 
   * @param tmpReq - UpdateHttpResponseHeaderModificationRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateHttpResponseHeaderModificationRuleResponse
   */
  async updateHttpResponseHeaderModificationRuleWithOptions(tmpReq: UpdateHttpResponseHeaderModificationRuleRequest, runtime: $dara.RuntimeOptions): Promise<UpdateHttpResponseHeaderModificationRuleResponse> {
    tmpReq.validate();
    let request = new UpdateHttpResponseHeaderModificationRuleShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.responseHeaderModification)) {
      request.responseHeaderModificationShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.responseHeaderModification, "ResponseHeaderModification", "json");
    }

    let query = { };
    if (!$dara.isNull(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!$dara.isNull(request.responseHeaderModificationShrink)) {
      query["ResponseHeaderModification"] = request.responseHeaderModificationShrink;
    }

    if (!$dara.isNull(request.rule)) {
      query["Rule"] = request.rule;
    }

    if (!$dara.isNull(request.ruleEnable)) {
      query["RuleEnable"] = request.ruleEnable;
    }

    if (!$dara.isNull(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateHttpResponseHeaderModificationRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateHttpResponseHeaderModificationRuleResponse>(await this.callApi(params, req, runtime), new UpdateHttpResponseHeaderModificationRuleResponse({}));
    } else {
      return $dara.cast<UpdateHttpResponseHeaderModificationRuleResponse>(await this.execute(params, req, runtime), new UpdateHttpResponseHeaderModificationRuleResponse({}));
    }

  }

  /**
   * HTTP
   * 
   * @param request - UpdateHttpResponseHeaderModificationRuleRequest
   * @returns UpdateHttpResponseHeaderModificationRuleResponse
   */
  async updateHttpResponseHeaderModificationRule(request: UpdateHttpResponseHeaderModificationRuleRequest): Promise<UpdateHttpResponseHeaderModificationRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateHttpResponseHeaderModificationRuleWithOptions(request, runtime);
  }

  /**
   * HTTPS
   * 
   * @param request - UpdateHttpsApplicationConfigurationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateHttpsApplicationConfigurationResponse
   */
  async updateHttpsApplicationConfigurationWithOptions(request: UpdateHttpsApplicationConfigurationRequest, runtime: $dara.RuntimeOptions): Promise<UpdateHttpsApplicationConfigurationResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.altSvc)) {
      query["AltSvc"] = request.altSvc;
    }

    if (!$dara.isNull(request.altSvcClear)) {
      query["AltSvcClear"] = request.altSvcClear;
    }

    if (!$dara.isNull(request.altSvcMa)) {
      query["AltSvcMa"] = request.altSvcMa;
    }

    if (!$dara.isNull(request.altSvcPersist)) {
      query["AltSvcPersist"] = request.altSvcPersist;
    }

    if (!$dara.isNull(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!$dara.isNull(request.hsts)) {
      query["Hsts"] = request.hsts;
    }

    if (!$dara.isNull(request.hstsIncludeSubdomains)) {
      query["HstsIncludeSubdomains"] = request.hstsIncludeSubdomains;
    }

    if (!$dara.isNull(request.hstsMaxAge)) {
      query["HstsMaxAge"] = request.hstsMaxAge;
    }

    if (!$dara.isNull(request.hstsPreload)) {
      query["HstsPreload"] = request.hstsPreload;
    }

    if (!$dara.isNull(request.httpsForce)) {
      query["HttpsForce"] = request.httpsForce;
    }

    if (!$dara.isNull(request.httpsForceCode)) {
      query["HttpsForceCode"] = request.httpsForceCode;
    }

    if (!$dara.isNull(request.rule)) {
      query["Rule"] = request.rule;
    }

    if (!$dara.isNull(request.ruleEnable)) {
      query["RuleEnable"] = request.ruleEnable;
    }

    if (!$dara.isNull(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateHttpsApplicationConfiguration",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateHttpsApplicationConfigurationResponse>(await this.callApi(params, req, runtime), new UpdateHttpsApplicationConfigurationResponse({}));
    } else {
      return $dara.cast<UpdateHttpsApplicationConfigurationResponse>(await this.execute(params, req, runtime), new UpdateHttpsApplicationConfigurationResponse({}));
    }

  }

  /**
   * HTTPS
   * 
   * @param request - UpdateHttpsApplicationConfigurationRequest
   * @returns UpdateHttpsApplicationConfigurationResponse
   */
  async updateHttpsApplicationConfiguration(request: UpdateHttpsApplicationConfigurationRequest): Promise<UpdateHttpsApplicationConfigurationResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateHttpsApplicationConfigurationWithOptions(request, runtime);
  }

  /**
   * HTTPS
   * 
   * @param request - UpdateHttpsBasicConfigurationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateHttpsBasicConfigurationResponse
   */
  async updateHttpsBasicConfigurationWithOptions(request: UpdateHttpsBasicConfigurationRequest, runtime: $dara.RuntimeOptions): Promise<UpdateHttpsBasicConfigurationResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.ciphersuite)) {
      query["Ciphersuite"] = request.ciphersuite;
    }

    if (!$dara.isNull(request.ciphersuiteGroup)) {
      query["CiphersuiteGroup"] = request.ciphersuiteGroup;
    }

    if (!$dara.isNull(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!$dara.isNull(request.http2)) {
      query["Http2"] = request.http2;
    }

    if (!$dara.isNull(request.http3)) {
      query["Http3"] = request.http3;
    }

    if (!$dara.isNull(request.https)) {
      query["Https"] = request.https;
    }

    if (!$dara.isNull(request.ocspStapling)) {
      query["OcspStapling"] = request.ocspStapling;
    }

    if (!$dara.isNull(request.rule)) {
      query["Rule"] = request.rule;
    }

    if (!$dara.isNull(request.ruleEnable)) {
      query["RuleEnable"] = request.ruleEnable;
    }

    if (!$dara.isNull(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.tls10)) {
      query["Tls10"] = request.tls10;
    }

    if (!$dara.isNull(request.tls11)) {
      query["Tls11"] = request.tls11;
    }

    if (!$dara.isNull(request.tls12)) {
      query["Tls12"] = request.tls12;
    }

    if (!$dara.isNull(request.tls13)) {
      query["Tls13"] = request.tls13;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateHttpsBasicConfiguration",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateHttpsBasicConfigurationResponse>(await this.callApi(params, req, runtime), new UpdateHttpsBasicConfigurationResponse({}));
    } else {
      return $dara.cast<UpdateHttpsBasicConfigurationResponse>(await this.execute(params, req, runtime), new UpdateHttpsBasicConfigurationResponse({}));
    }

  }

  /**
   * HTTPS
   * 
   * @param request - UpdateHttpsBasicConfigurationRequest
   * @returns UpdateHttpsBasicConfigurationResponse
   */
  async updateHttpsBasicConfiguration(request: UpdateHttpsBasicConfigurationRequest): Promise<UpdateHttpsBasicConfigurationResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateHttpsBasicConfigurationWithOptions(request, runtime);
  }

  /**
   * IPv6
   * 
   * @param request - UpdateIPv6Request
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateIPv6Response
   */
  async updateIPv6WithOptions(request: UpdateIPv6Request, runtime: $dara.RuntimeOptions): Promise<UpdateIPv6Response> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateIPv6",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateIPv6Response>(await this.callApi(params, req, runtime), new UpdateIPv6Response({}));
    } else {
      return $dara.cast<UpdateIPv6Response>(await this.execute(params, req, runtime), new UpdateIPv6Response({}));
    }

  }

  /**
   * IPv6
   * 
   * @param request - UpdateIPv6Request
   * @returns UpdateIPv6Response
   */
  async updateIPv6(request: UpdateIPv6Request): Promise<UpdateIPv6Response> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateIPv6WithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - UpdateImageTransformRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateImageTransformResponse
   */
  async updateImageTransformWithOptions(request: UpdateImageTransformRequest, runtime: $dara.RuntimeOptions): Promise<UpdateImageTransformResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!$dara.isNull(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!$dara.isNull(request.rule)) {
      query["Rule"] = request.rule;
    }

    if (!$dara.isNull(request.ruleEnable)) {
      query["RuleEnable"] = request.ruleEnable;
    }

    if (!$dara.isNull(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateImageTransform",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateImageTransformResponse>(await this.callApi(params, req, runtime), new UpdateImageTransformResponse({}));
    } else {
      return $dara.cast<UpdateImageTransformResponse>(await this.execute(params, req, runtime), new UpdateImageTransformResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - UpdateImageTransformRequest
   * @returns UpdateImageTransformResponse
   */
  async updateImageTransform(request: UpdateImageTransformRequest): Promise<UpdateImageTransformResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateImageTransformWithOptions(request, runtime);
  }

  /**
   * Updates a custom list.
   * 
   * @param tmpReq - UpdateListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateListResponse
   */
  async updateListWithOptions(tmpReq: UpdateListRequest, runtime: $dara.RuntimeOptions): Promise<UpdateListResponse> {
    tmpReq.validate();
    let request = new UpdateListShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.items)) {
      request.itemsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.items, "Items", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.description)) {
      body["Description"] = request.description;
    }

    if (!$dara.isNull(request.id)) {
      body["Id"] = request.id;
    }

    if (!$dara.isNull(request.itemsShrink)) {
      body["Items"] = request.itemsShrink;
    }

    if (!$dara.isNull(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateList",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateListResponse>(await this.callApi(params, req, runtime), new UpdateListResponse({}));
    } else {
      return $dara.cast<UpdateListResponse>(await this.execute(params, req, runtime), new UpdateListResponse({}));
    }

  }

  /**
   * Updates a custom list.
   * 
   * @param request - UpdateListRequest
   * @returns UpdateListResponse
   */
  async updateList(request: UpdateListRequest): Promise<UpdateListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateListWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param tmpReq - UpdateLoadBalancerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateLoadBalancerResponse
   */
  async updateLoadBalancerWithOptions(tmpReq: UpdateLoadBalancerRequest, runtime: $dara.RuntimeOptions): Promise<UpdateLoadBalancerResponse> {
    tmpReq.validate();
    let request = new UpdateLoadBalancerShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.adaptiveRouting)) {
      request.adaptiveRoutingShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.adaptiveRouting, "AdaptiveRouting", "json");
    }

    if (!$dara.isNull(tmpReq.defaultPools)) {
      request.defaultPoolsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.defaultPools, "DefaultPools", "json");
    }

    if (!$dara.isNull(tmpReq.monitor)) {
      request.monitorShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.monitor, "Monitor", "json");
    }

    if (!$dara.isNull(tmpReq.randomSteering)) {
      request.randomSteeringShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.randomSteering, "RandomSteering", "json");
    }

    if (!$dara.isNull(tmpReq.rules)) {
      request.rulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.rules, "Rules", "json");
    }

    let query = { };
    if (!$dara.isNull(request.adaptiveRoutingShrink)) {
      query["AdaptiveRouting"] = request.adaptiveRoutingShrink;
    }

    if (!$dara.isNull(request.defaultPoolsShrink)) {
      query["DefaultPools"] = request.defaultPoolsShrink;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.enabled)) {
      query["Enabled"] = request.enabled;
    }

    if (!$dara.isNull(request.fallbackPool)) {
      query["FallbackPool"] = request.fallbackPool;
    }

    if (!$dara.isNull(request.id)) {
      query["Id"] = request.id;
    }

    if (!$dara.isNull(request.monitorShrink)) {
      query["Monitor"] = request.monitorShrink;
    }

    if (!$dara.isNull(request.randomSteeringShrink)) {
      query["RandomSteering"] = request.randomSteeringShrink;
    }

    if (!$dara.isNull(request.regionPools)) {
      query["RegionPools"] = request.regionPools;
    }

    if (!$dara.isNull(request.rulesShrink)) {
      query["Rules"] = request.rulesShrink;
    }

    if (!$dara.isNull(request.sessionAffinity)) {
      query["SessionAffinity"] = request.sessionAffinity;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.steeringPolicy)) {
      query["SteeringPolicy"] = request.steeringPolicy;
    }

    if (!$dara.isNull(request.subRegionPools)) {
      query["SubRegionPools"] = request.subRegionPools;
    }

    if (!$dara.isNull(request.ttl)) {
      query["Ttl"] = request.ttl;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateLoadBalancer",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateLoadBalancerResponse>(await this.callApi(params, req, runtime), new UpdateLoadBalancerResponse({}));
    } else {
      return $dara.cast<UpdateLoadBalancerResponse>(await this.execute(params, req, runtime), new UpdateLoadBalancerResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - UpdateLoadBalancerRequest
   * @returns UpdateLoadBalancerResponse
   */
  async updateLoadBalancer(request: UpdateLoadBalancerRequest): Promise<UpdateLoadBalancerResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateLoadBalancerWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - UpdateManagedTransformRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateManagedTransformResponse
   */
  async updateManagedTransformWithOptions(request: UpdateManagedTransformRequest, runtime: $dara.RuntimeOptions): Promise<UpdateManagedTransformResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.addClientGeolocationHeader)) {
      query["AddClientGeolocationHeader"] = request.addClientGeolocationHeader;
    }

    if (!$dara.isNull(request.addRealClientIpHeader)) {
      query["AddRealClientIpHeader"] = request.addRealClientIpHeader;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.siteVersion)) {
      query["SiteVersion"] = request.siteVersion;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateManagedTransform",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateManagedTransformResponse>(await this.callApi(params, req, runtime), new UpdateManagedTransformResponse({}));
    } else {
      return $dara.cast<UpdateManagedTransformResponse>(await this.execute(params, req, runtime), new UpdateManagedTransformResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - UpdateManagedTransformRequest
   * @returns UpdateManagedTransformResponse
   */
  async updateManagedTransform(request: UpdateManagedTransformRequest): Promise<UpdateManagedTransformResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateManagedTransformWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - UpdateNetworkOptimizationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateNetworkOptimizationResponse
   */
  async updateNetworkOptimizationWithOptions(request: UpdateNetworkOptimizationRequest, runtime: $dara.RuntimeOptions): Promise<UpdateNetworkOptimizationResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!$dara.isNull(request.grpc)) {
      query["Grpc"] = request.grpc;
    }

    if (!$dara.isNull(request.http2Origin)) {
      query["Http2Origin"] = request.http2Origin;
    }

    if (!$dara.isNull(request.rule)) {
      query["Rule"] = request.rule;
    }

    if (!$dara.isNull(request.ruleEnable)) {
      query["RuleEnable"] = request.ruleEnable;
    }

    if (!$dara.isNull(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.smartRouting)) {
      query["SmartRouting"] = request.smartRouting;
    }

    if (!$dara.isNull(request.uploadMaxFilesize)) {
      query["UploadMaxFilesize"] = request.uploadMaxFilesize;
    }

    if (!$dara.isNull(request.websocket)) {
      query["Websocket"] = request.websocket;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateNetworkOptimization",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateNetworkOptimizationResponse>(await this.callApi(params, req, runtime), new UpdateNetworkOptimizationResponse({}));
    } else {
      return $dara.cast<UpdateNetworkOptimizationResponse>(await this.execute(params, req, runtime), new UpdateNetworkOptimizationResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - UpdateNetworkOptimizationRequest
   * @returns UpdateNetworkOptimizationResponse
   */
  async updateNetworkOptimization(request: UpdateNetworkOptimizationRequest): Promise<UpdateNetworkOptimizationResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateNetworkOptimizationWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param tmpReq - UpdateOriginPoolRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateOriginPoolResponse
   */
  async updateOriginPoolWithOptions(tmpReq: UpdateOriginPoolRequest, runtime: $dara.RuntimeOptions): Promise<UpdateOriginPoolResponse> {
    tmpReq.validate();
    let request = new UpdateOriginPoolShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.origins)) {
      request.originsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.origins, "Origins", "json");
    }

    let query = { };
    if (!$dara.isNull(request.enabled)) {
      query["Enabled"] = request.enabled;
    }

    if (!$dara.isNull(request.id)) {
      query["Id"] = request.id;
    }

    if (!$dara.isNull(request.originsShrink)) {
      query["Origins"] = request.originsShrink;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateOriginPool",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateOriginPoolResponse>(await this.callApi(params, req, runtime), new UpdateOriginPoolResponse({}));
    } else {
      return $dara.cast<UpdateOriginPoolResponse>(await this.execute(params, req, runtime), new UpdateOriginPoolResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - UpdateOriginPoolRequest
   * @returns UpdateOriginPoolResponse
   */
  async updateOriginPool(request: UpdateOriginPoolRequest): Promise<UpdateOriginPoolResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateOriginPoolWithOptions(request, runtime);
  }

  /**
   * Enables or disables IP convergence.
   * 
   * @param request - UpdateOriginProtectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateOriginProtectionResponse
   */
  async updateOriginProtectionWithOptions(request: UpdateOriginProtectionRequest, runtime: $dara.RuntimeOptions): Promise<UpdateOriginProtectionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.originConverge)) {
      query["OriginConverge"] = request.originConverge;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateOriginProtection",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateOriginProtectionResponse>(await this.callApi(params, req, runtime), new UpdateOriginProtectionResponse({}));
    } else {
      return $dara.cast<UpdateOriginProtectionResponse>(await this.execute(params, req, runtime), new UpdateOriginProtectionResponse({}));
    }

  }

  /**
   * Enables or disables IP convergence.
   * 
   * @param request - UpdateOriginProtectionRequest
   * @returns UpdateOriginProtectionResponse
   */
  async updateOriginProtection(request: UpdateOriginProtectionRequest): Promise<UpdateOriginProtectionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateOriginProtectionWithOptions(request, runtime);
  }

  /**
   * Updates the IP whitelist for origin protection used by a website to the latest version.
   * 
   * @param request - UpdateOriginProtectionIpWhiteListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateOriginProtectionIpWhiteListResponse
   */
  async updateOriginProtectionIpWhiteListWithOptions(request: UpdateOriginProtectionIpWhiteListRequest, runtime: $dara.RuntimeOptions): Promise<UpdateOriginProtectionIpWhiteListResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateOriginProtectionIpWhiteList",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateOriginProtectionIpWhiteListResponse>(await this.callApi(params, req, runtime), new UpdateOriginProtectionIpWhiteListResponse({}));
    } else {
      return $dara.cast<UpdateOriginProtectionIpWhiteListResponse>(await this.execute(params, req, runtime), new UpdateOriginProtectionIpWhiteListResponse({}));
    }

  }

  /**
   * Updates the IP whitelist for origin protection used by a website to the latest version.
   * 
   * @param request - UpdateOriginProtectionIpWhiteListRequest
   * @returns UpdateOriginProtectionIpWhiteListResponse
   */
  async updateOriginProtectionIpWhiteList(request: UpdateOriginProtectionIpWhiteListRequest): Promise<UpdateOriginProtectionIpWhiteListResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateOriginProtectionIpWhiteListWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - UpdateOriginRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateOriginRuleResponse
   */
  async updateOriginRuleWithOptions(request: UpdateOriginRuleRequest, runtime: $dara.RuntimeOptions): Promise<UpdateOriginRuleResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!$dara.isNull(request.dnsRecord)) {
      query["DnsRecord"] = request.dnsRecord;
    }

    if (!$dara.isNull(request.originHost)) {
      query["OriginHost"] = request.originHost;
    }

    if (!$dara.isNull(request.originHttpPort)) {
      query["OriginHttpPort"] = request.originHttpPort;
    }

    if (!$dara.isNull(request.originHttpsPort)) {
      query["OriginHttpsPort"] = request.originHttpsPort;
    }

    if (!$dara.isNull(request.originScheme)) {
      query["OriginScheme"] = request.originScheme;
    }

    if (!$dara.isNull(request.originSni)) {
      query["OriginSni"] = request.originSni;
    }

    if (!$dara.isNull(request.range)) {
      query["Range"] = request.range;
    }

    if (!$dara.isNull(request.rule)) {
      query["Rule"] = request.rule;
    }

    if (!$dara.isNull(request.ruleEnable)) {
      query["RuleEnable"] = request.ruleEnable;
    }

    if (!$dara.isNull(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateOriginRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateOriginRuleResponse>(await this.callApi(params, req, runtime), new UpdateOriginRuleResponse({}));
    } else {
      return $dara.cast<UpdateOriginRuleResponse>(await this.execute(params, req, runtime), new UpdateOriginRuleResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - UpdateOriginRuleRequest
   * @returns UpdateOriginRuleResponse
   */
  async updateOriginRule(request: UpdateOriginRuleRequest): Promise<UpdateOriginRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateOriginRuleWithOptions(request, runtime);
  }

  /**
   * Modifies the configurations of a custom error page, such as the name, description, content type, and content of the page.
   * 
   * @param request - UpdatePageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdatePageResponse
   */
  async updatePageWithOptions(request: UpdatePageRequest, runtime: $dara.RuntimeOptions): Promise<UpdatePageResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.content)) {
      body["Content"] = request.content;
    }

    if (!$dara.isNull(request.contentType)) {
      body["ContentType"] = request.contentType;
    }

    if (!$dara.isNull(request.description)) {
      body["Description"] = request.description;
    }

    if (!$dara.isNull(request.id)) {
      body["Id"] = request.id;
    }

    if (!$dara.isNull(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdatePage",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdatePageResponse>(await this.callApi(params, req, runtime), new UpdatePageResponse({}));
    } else {
      return $dara.cast<UpdatePageResponse>(await this.execute(params, req, runtime), new UpdatePageResponse({}));
    }

  }

  /**
   * Modifies the configurations of a custom error page, such as the name, description, content type, and content of the page.
   * 
   * @param request - UpdatePageRequest
   * @returns UpdatePageResponse
   */
  async updatePage(request: UpdatePageRequest): Promise<UpdatePageResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updatePageWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - UpdateRatePlanSpecRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateRatePlanSpecResponse
   */
  async updateRatePlanSpecWithOptions(request: UpdateRatePlanSpecRequest, runtime: $dara.RuntimeOptions): Promise<UpdateRatePlanSpecResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.autoPay)) {
      query["AutoPay"] = request.autoPay;
    }

    if (!$dara.isNull(request.chargeType)) {
      query["ChargeType"] = request.chargeType;
    }

    if (!$dara.isNull(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!$dara.isNull(request.orderType)) {
      query["OrderType"] = request.orderType;
    }

    if (!$dara.isNull(request.targetPlanCode)) {
      query["TargetPlanCode"] = request.targetPlanCode;
    }

    if (!$dara.isNull(request.targetPlanName)) {
      query["TargetPlanName"] = request.targetPlanName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateRatePlanSpec",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateRatePlanSpecResponse>(await this.callApi(params, req, runtime), new UpdateRatePlanSpecResponse({}));
    } else {
      return $dara.cast<UpdateRatePlanSpecResponse>(await this.execute(params, req, runtime), new UpdateRatePlanSpecResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - UpdateRatePlanSpecRequest
   * @returns UpdateRatePlanSpecResponse
   */
  async updateRatePlanSpec(request: UpdateRatePlanSpecRequest): Promise<UpdateRatePlanSpecResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateRatePlanSpecWithOptions(request, runtime);
  }

  /**
   * Updates multiple types of DNS records and origin authentication configurations.
   * 
   * @remarks
   * This operation allows you to update multiple types of DNS records, including but not limited to A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, and URI. You can modify the record content by providing the necessary fields such as Value, Priority, and Flag. For origins added in CNAME records such as OSS and S3, the API enables you to configure authentication details to ensure secure access.
   * ### [](#)Usage notes
   * *   The record value (Value) must match the record type. For example, the CNAME record should correspond to the target domain name.
   * *   You must specify a priority (Priority) for some record types, such as MX and SRV.
   * *   You must specify specific fields such as Flag and Tag for CAA records.
   * *   When you update security records such as CERT and SSHFP, you must accurately set fields such as Type and Algorithm.
   * *   If your origin type is OSS or S3, configure the authentication details in AuthConf based on the permissions.
   * 
   * @param tmpReq - UpdateRecordRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateRecordResponse
   */
  async updateRecordWithOptions(tmpReq: UpdateRecordRequest, runtime: $dara.RuntimeOptions): Promise<UpdateRecordResponse> {
    tmpReq.validate();
    let request = new UpdateRecordShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.authConf)) {
      request.authConfShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.authConf, "AuthConf", "json");
    }

    if (!$dara.isNull(tmpReq.data)) {
      request.dataShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.data, "Data", "json");
    }

    let query = { };
    if (!$dara.isNull(request.authConfShrink)) {
      query["AuthConf"] = request.authConfShrink;
    }

    if (!$dara.isNull(request.bizName)) {
      query["BizName"] = request.bizName;
    }

    if (!$dara.isNull(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!$dara.isNull(request.dataShrink)) {
      query["Data"] = request.dataShrink;
    }

    if (!$dara.isNull(request.hostPolicy)) {
      query["HostPolicy"] = request.hostPolicy;
    }

    if (!$dara.isNull(request.proxied)) {
      query["Proxied"] = request.proxied;
    }

    if (!$dara.isNull(request.recordId)) {
      query["RecordId"] = request.recordId;
    }

    if (!$dara.isNull(request.sourceType)) {
      query["SourceType"] = request.sourceType;
    }

    if (!$dara.isNull(request.ttl)) {
      query["Ttl"] = request.ttl;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateRecord",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateRecordResponse>(await this.callApi(params, req, runtime), new UpdateRecordResponse({}));
    } else {
      return $dara.cast<UpdateRecordResponse>(await this.execute(params, req, runtime), new UpdateRecordResponse({}));
    }

  }

  /**
   * Updates multiple types of DNS records and origin authentication configurations.
   * 
   * @remarks
   * This operation allows you to update multiple types of DNS records, including but not limited to A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, and URI. You can modify the record content by providing the necessary fields such as Value, Priority, and Flag. For origins added in CNAME records such as OSS and S3, the API enables you to configure authentication details to ensure secure access.
   * ### [](#)Usage notes
   * *   The record value (Value) must match the record type. For example, the CNAME record should correspond to the target domain name.
   * *   You must specify a priority (Priority) for some record types, such as MX and SRV.
   * *   You must specify specific fields such as Flag and Tag for CAA records.
   * *   When you update security records such as CERT and SSHFP, you must accurately set fields such as Type and Algorithm.
   * *   If your origin type is OSS or S3, configure the authentication details in AuthConf based on the permissions.
   * 
   * @param request - UpdateRecordRequest
   * @returns UpdateRecordResponse
   */
  async updateRecord(request: UpdateRecordRequest): Promise<UpdateRecordResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateRecordWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - UpdateRedirectRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateRedirectRuleResponse
   */
  async updateRedirectRuleWithOptions(request: UpdateRedirectRuleRequest, runtime: $dara.RuntimeOptions): Promise<UpdateRedirectRuleResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!$dara.isNull(request.reserveQueryString)) {
      query["ReserveQueryString"] = request.reserveQueryString;
    }

    if (!$dara.isNull(request.rule)) {
      query["Rule"] = request.rule;
    }

    if (!$dara.isNull(request.ruleEnable)) {
      query["RuleEnable"] = request.ruleEnable;
    }

    if (!$dara.isNull(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.statusCode)) {
      query["StatusCode"] = request.statusCode;
    }

    if (!$dara.isNull(request.targetUrl)) {
      query["TargetUrl"] = request.targetUrl;
    }

    if (!$dara.isNull(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateRedirectRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateRedirectRuleResponse>(await this.callApi(params, req, runtime), new UpdateRedirectRuleResponse({}));
    } else {
      return $dara.cast<UpdateRedirectRuleResponse>(await this.execute(params, req, runtime), new UpdateRedirectRuleResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - UpdateRedirectRuleRequest
   * @returns UpdateRedirectRuleResponse
   */
  async updateRedirectRule(request: UpdateRedirectRuleRequest): Promise<UpdateRedirectRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateRedirectRuleWithOptions(request, runtime);
  }

  /**
   * Url
   * 
   * @param request - UpdateRewriteUrlRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateRewriteUrlRuleResponse
   */
  async updateRewriteUrlRuleWithOptions(request: UpdateRewriteUrlRuleRequest, runtime: $dara.RuntimeOptions): Promise<UpdateRewriteUrlRuleResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!$dara.isNull(request.queryString)) {
      query["QueryString"] = request.queryString;
    }

    if (!$dara.isNull(request.rewriteQueryStringType)) {
      query["RewriteQueryStringType"] = request.rewriteQueryStringType;
    }

    if (!$dara.isNull(request.rewriteUriType)) {
      query["RewriteUriType"] = request.rewriteUriType;
    }

    if (!$dara.isNull(request.rule)) {
      query["Rule"] = request.rule;
    }

    if (!$dara.isNull(request.ruleEnable)) {
      query["RuleEnable"] = request.ruleEnable;
    }

    if (!$dara.isNull(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.uri)) {
      query["Uri"] = request.uri;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateRewriteUrlRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateRewriteUrlRuleResponse>(await this.callApi(params, req, runtime), new UpdateRewriteUrlRuleResponse({}));
    } else {
      return $dara.cast<UpdateRewriteUrlRuleResponse>(await this.execute(params, req, runtime), new UpdateRewriteUrlRuleResponse({}));
    }

  }

  /**
   * Url
   * 
   * @param request - UpdateRewriteUrlRuleRequest
   * @returns UpdateRewriteUrlRuleResponse
   */
  async updateRewriteUrlRule(request: UpdateRewriteUrlRuleRequest): Promise<UpdateRewriteUrlRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateRewriteUrlRuleWithOptions(request, runtime);
  }

  /**
   * Updates a scheduled prefetch plan based on the plan ID.
   * 
   * @param request - UpdateScheduledPreloadExecutionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateScheduledPreloadExecutionResponse
   */
  async updateScheduledPreloadExecutionWithOptions(request: UpdateScheduledPreloadExecutionRequest, runtime: $dara.RuntimeOptions): Promise<UpdateScheduledPreloadExecutionResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.id)) {
      query["Id"] = request.id;
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.interval)) {
      body["Interval"] = request.interval;
    }

    if (!$dara.isNull(request.sliceLen)) {
      body["SliceLen"] = request.sliceLen;
    }

    if (!$dara.isNull(request.startTime)) {
      body["StartTime"] = request.startTime;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateScheduledPreloadExecution",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateScheduledPreloadExecutionResponse>(await this.callApi(params, req, runtime), new UpdateScheduledPreloadExecutionResponse({}));
    } else {
      return $dara.cast<UpdateScheduledPreloadExecutionResponse>(await this.execute(params, req, runtime), new UpdateScheduledPreloadExecutionResponse({}));
    }

  }

  /**
   * Updates a scheduled prefetch plan based on the plan ID.
   * 
   * @param request - UpdateScheduledPreloadExecutionRequest
   * @returns UpdateScheduledPreloadExecutionResponse
   */
  async updateScheduledPreloadExecution(request: UpdateScheduledPreloadExecutionRequest): Promise<UpdateScheduledPreloadExecutionResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateScheduledPreloadExecutionWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - UpdateSeoBypassRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateSeoBypassResponse
   */
  async updateSeoBypassWithOptions(request: UpdateSeoBypassRequest, runtime: $dara.RuntimeOptions): Promise<UpdateSeoBypassResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateSeoBypass",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateSeoBypassResponse>(await this.callApi(params, req, runtime), new UpdateSeoBypassResponse({}));
    } else {
      return $dara.cast<UpdateSeoBypassResponse>(await this.execute(params, req, runtime), new UpdateSeoBypassResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - UpdateSeoBypassRequest
   * @returns UpdateSeoBypassResponse
   */
  async updateSeoBypass(request: UpdateSeoBypassRequest): Promise<UpdateSeoBypassResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateSeoBypassWithOptions(request, runtime);
  }

  /**
   * Converts the DNS setup option of a website.
   * 
   * @remarks
   * When you change the DNS setup of a website from NS to CNAME, note the following prerequisites:
   * *   The website only has proxied A/AAAA and CNAME records.
   * *   The DNS passthrough mode and custom nameserver features are not enabled for the website.
   * 
   * @param request - UpdateSiteAccessTypeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateSiteAccessTypeResponse
   */
  async updateSiteAccessTypeWithOptions(request: UpdateSiteAccessTypeRequest, runtime: $dara.RuntimeOptions): Promise<UpdateSiteAccessTypeResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.accessType)) {
      query["AccessType"] = request.accessType;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateSiteAccessType",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateSiteAccessTypeResponse>(await this.callApi(params, req, runtime), new UpdateSiteAccessTypeResponse({}));
    } else {
      return $dara.cast<UpdateSiteAccessTypeResponse>(await this.execute(params, req, runtime), new UpdateSiteAccessTypeResponse({}));
    }

  }

  /**
   * Converts the DNS setup option of a website.
   * 
   * @remarks
   * When you change the DNS setup of a website from NS to CNAME, note the following prerequisites:
   * *   The website only has proxied A/AAAA and CNAME records.
   * *   The DNS passthrough mode and custom nameserver features are not enabled for the website.
   * 
   * @param request - UpdateSiteAccessTypeRequest
   * @returns UpdateSiteAccessTypeResponse
   */
  async updateSiteAccessType(request: UpdateSiteAccessTypeRequest): Promise<UpdateSiteAccessTypeResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateSiteAccessTypeWithOptions(request, runtime);
  }

  /**
   * Modifies the service location for a single website. This updates the acceleration configuration of the website to adapt to changes in traffic distribution, and improve user experience in specific regions.
   * 
   * @param request - UpdateSiteCoverageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateSiteCoverageResponse
   */
  async updateSiteCoverageWithOptions(request: UpdateSiteCoverageRequest, runtime: $dara.RuntimeOptions): Promise<UpdateSiteCoverageResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.coverage)) {
      query["Coverage"] = request.coverage;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateSiteCoverage",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateSiteCoverageResponse>(await this.callApi(params, req, runtime), new UpdateSiteCoverageResponse({}));
    } else {
      return $dara.cast<UpdateSiteCoverageResponse>(await this.execute(params, req, runtime), new UpdateSiteCoverageResponse({}));
    }

  }

  /**
   * Modifies the service location for a single website. This updates the acceleration configuration of the website to adapt to changes in traffic distribution, and improve user experience in specific regions.
   * 
   * @param request - UpdateSiteCoverageRequest
   * @returns UpdateSiteCoverageResponse
   */
  async updateSiteCoverage(request: UpdateSiteCoverageRequest): Promise<UpdateSiteCoverageResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateSiteCoverageWithOptions(request, runtime);
  }

  /**
   * Modifies the configuration of custom request header, response header, and cookie fields that are used to capture logs of a website.
   * 
   * @param tmpReq - UpdateSiteCustomLogRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateSiteCustomLogResponse
   */
  async updateSiteCustomLogWithOptions(tmpReq: UpdateSiteCustomLogRequest, runtime: $dara.RuntimeOptions): Promise<UpdateSiteCustomLogResponse> {
    tmpReq.validate();
    let request = new UpdateSiteCustomLogShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.cookies)) {
      request.cookiesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.cookies, "Cookies", "json");
    }

    if (!$dara.isNull(tmpReq.requestHeaders)) {
      request.requestHeadersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.requestHeaders, "RequestHeaders", "json");
    }

    if (!$dara.isNull(tmpReq.responseHeaders)) {
      request.responseHeadersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.responseHeaders, "ResponseHeaders", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.cookiesShrink)) {
      body["Cookies"] = request.cookiesShrink;
    }

    if (!$dara.isNull(request.requestHeadersShrink)) {
      body["RequestHeaders"] = request.requestHeadersShrink;
    }

    if (!$dara.isNull(request.responseHeadersShrink)) {
      body["ResponseHeaders"] = request.responseHeadersShrink;
    }

    if (!$dara.isNull(request.siteId)) {
      body["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateSiteCustomLog",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateSiteCustomLogResponse>(await this.callApi(params, req, runtime), new UpdateSiteCustomLogResponse({}));
    } else {
      return $dara.cast<UpdateSiteCustomLogResponse>(await this.execute(params, req, runtime), new UpdateSiteCustomLogResponse({}));
    }

  }

  /**
   * Modifies the configuration of custom request header, response header, and cookie fields that are used to capture logs of a website.
   * 
   * @param request - UpdateSiteCustomLogRequest
   * @returns UpdateSiteCustomLogResponse
   */
  async updateSiteCustomLog(request: UpdateSiteCustomLogRequest): Promise<UpdateSiteCustomLogResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateSiteCustomLogWithOptions(request, runtime);
  }

  /**
   * Modifies a real-time log delivery task.
   * 
   * @param request - UpdateSiteDeliveryTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateSiteDeliveryTaskResponse
   */
  async updateSiteDeliveryTaskWithOptions(request: UpdateSiteDeliveryTaskRequest, runtime: $dara.RuntimeOptions): Promise<UpdateSiteDeliveryTaskResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.businessType)) {
      body["BusinessType"] = request.businessType;
    }

    if (!$dara.isNull(request.discardRate)) {
      body["DiscardRate"] = request.discardRate;
    }

    if (!$dara.isNull(request.fieldName)) {
      body["FieldName"] = request.fieldName;
    }

    if (!$dara.isNull(request.siteId)) {
      body["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.taskName)) {
      body["TaskName"] = request.taskName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateSiteDeliveryTask",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateSiteDeliveryTaskResponse>(await this.callApi(params, req, runtime), new UpdateSiteDeliveryTaskResponse({}));
    } else {
      return $dara.cast<UpdateSiteDeliveryTaskResponse>(await this.execute(params, req, runtime), new UpdateSiteDeliveryTaskResponse({}));
    }

  }

  /**
   * Modifies a real-time log delivery task.
   * 
   * @param request - UpdateSiteDeliveryTaskRequest
   * @returns UpdateSiteDeliveryTaskResponse
   */
  async updateSiteDeliveryTask(request: UpdateSiteDeliveryTaskRequest): Promise<UpdateSiteDeliveryTaskResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateSiteDeliveryTaskWithOptions(request, runtime);
  }

  /**
   * Changes the status of a real-time log delivery task.
   * 
   * @param request - UpdateSiteDeliveryTaskStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateSiteDeliveryTaskStatusResponse
   */
  async updateSiteDeliveryTaskStatusWithOptions(request: UpdateSiteDeliveryTaskStatusRequest, runtime: $dara.RuntimeOptions): Promise<UpdateSiteDeliveryTaskStatusResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateSiteDeliveryTaskStatus",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateSiteDeliveryTaskStatusResponse>(await this.callApi(params, req, runtime), new UpdateSiteDeliveryTaskStatusResponse({}));
    } else {
      return $dara.cast<UpdateSiteDeliveryTaskStatusResponse>(await this.execute(params, req, runtime), new UpdateSiteDeliveryTaskStatusResponse({}));
    }

  }

  /**
   * Changes the status of a real-time log delivery task.
   * 
   * @param request - UpdateSiteDeliveryTaskStatusRequest
   * @returns UpdateSiteDeliveryTaskStatusResponse
   */
  async updateSiteDeliveryTaskStatus(request: UpdateSiteDeliveryTaskStatusRequest): Promise<UpdateSiteDeliveryTaskStatusResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateSiteDeliveryTaskStatusWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - UpdateSiteNameExclusiveRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateSiteNameExclusiveResponse
   */
  async updateSiteNameExclusiveWithOptions(request: UpdateSiteNameExclusiveRequest, runtime: $dara.RuntimeOptions): Promise<UpdateSiteNameExclusiveResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateSiteNameExclusive",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateSiteNameExclusiveResponse>(await this.callApi(params, req, runtime), new UpdateSiteNameExclusiveResponse({}));
    } else {
      return $dara.cast<UpdateSiteNameExclusiveResponse>(await this.execute(params, req, runtime), new UpdateSiteNameExclusiveResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - UpdateSiteNameExclusiveRequest
   * @returns UpdateSiteNameExclusiveResponse
   */
  async updateSiteNameExclusive(request: UpdateSiteNameExclusiveRequest): Promise<UpdateSiteNameExclusiveResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateSiteNameExclusiveWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - UpdateSitePauseRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateSitePauseResponse
   */
  async updateSitePauseWithOptions(request: UpdateSitePauseRequest, runtime: $dara.RuntimeOptions): Promise<UpdateSitePauseResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.paused)) {
      query["Paused"] = request.paused;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateSitePause",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateSitePauseResponse>(await this.callApi(params, req, runtime), new UpdateSitePauseResponse({}));
    } else {
      return $dara.cast<UpdateSitePauseResponse>(await this.execute(params, req, runtime), new UpdateSitePauseResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - UpdateSitePauseRequest
   * @returns UpdateSitePauseResponse
   */
  async updateSitePause(request: UpdateSitePauseRequest): Promise<UpdateSitePauseResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateSitePauseWithOptions(request, runtime);
  }

  /**
   * Updates the custom nameserver names for a single website.
   * 
   * @param request - UpdateSiteVanityNSRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateSiteVanityNSResponse
   */
  async updateSiteVanityNSWithOptions(request: UpdateSiteVanityNSRequest, runtime: $dara.RuntimeOptions): Promise<UpdateSiteVanityNSResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.vanityNSList)) {
      query["VanityNSList"] = request.vanityNSList;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateSiteVanityNS",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateSiteVanityNSResponse>(await this.callApi(params, req, runtime), new UpdateSiteVanityNSResponse({}));
    } else {
      return $dara.cast<UpdateSiteVanityNSResponse>(await this.execute(params, req, runtime), new UpdateSiteVanityNSResponse({}));
    }

  }

  /**
   * Updates the custom nameserver names for a single website.
   * 
   * @param request - UpdateSiteVanityNSRequest
   * @returns UpdateSiteVanityNSResponse
   */
  async updateSiteVanityNS(request: UpdateSiteVanityNSRequest): Promise<UpdateSiteVanityNSResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateSiteVanityNSWithOptions(request, runtime);
  }

  /**
   * 
   * 
   * @param request - UpdateTieredCacheRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateTieredCacheResponse
   */
  async updateTieredCacheWithOptions(request: UpdateTieredCacheRequest, runtime: $dara.RuntimeOptions): Promise<UpdateTieredCacheResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.cacheArchitectureMode)) {
      query["CacheArchitectureMode"] = request.cacheArchitectureMode;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateTieredCache",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateTieredCacheResponse>(await this.callApi(params, req, runtime), new UpdateTieredCacheResponse({}));
    } else {
      return $dara.cast<UpdateTieredCacheResponse>(await this.execute(params, req, runtime), new UpdateTieredCacheResponse({}));
    }

  }

  /**
   * 
   * 
   * @param request - UpdateTieredCacheRequest
   * @returns UpdateTieredCacheResponse
   */
  async updateTieredCache(request: UpdateTieredCacheRequest): Promise<UpdateTieredCacheResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateTieredCacheWithOptions(request, runtime);
  }

  /**
   * Modifies the configurations of a delivery task, including the task name, log field, log category, and discard rate.
   * 
   * @param request - UpdateUserDeliveryTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateUserDeliveryTaskResponse
   */
  async updateUserDeliveryTaskWithOptions(request: UpdateUserDeliveryTaskRequest, runtime: $dara.RuntimeOptions): Promise<UpdateUserDeliveryTaskResponse> {
    request.validate();
    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.businessType)) {
      body["BusinessType"] = request.businessType;
    }

    if (!$dara.isNull(request.details)) {
      body["Details"] = request.details;
    }

    if (!$dara.isNull(request.discardRate)) {
      body["DiscardRate"] = request.discardRate;
    }

    if (!$dara.isNull(request.fieldName)) {
      body["FieldName"] = request.fieldName;
    }

    if (!$dara.isNull(request.taskName)) {
      body["TaskName"] = request.taskName;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateUserDeliveryTask",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateUserDeliveryTaskResponse>(await this.callApi(params, req, runtime), new UpdateUserDeliveryTaskResponse({}));
    } else {
      return $dara.cast<UpdateUserDeliveryTaskResponse>(await this.execute(params, req, runtime), new UpdateUserDeliveryTaskResponse({}));
    }

  }

  /**
   * Modifies the configurations of a delivery task, including the task name, log field, log category, and discard rate.
   * 
   * @param request - UpdateUserDeliveryTaskRequest
   * @returns UpdateUserDeliveryTaskResponse
   */
  async updateUserDeliveryTask(request: UpdateUserDeliveryTaskRequest): Promise<UpdateUserDeliveryTaskResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateUserDeliveryTaskWithOptions(request, runtime);
  }

  /**
   * Changes the status of a delivery task in your Alibaba Cloud account.
   * 
   * @remarks
   * ## [](#)
   * You can call this operation to enable or disable a delivery task by using TaskName and Method. The response includes the most recent status and operation result details of the task.
   * 
   * @param request - UpdateUserDeliveryTaskStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateUserDeliveryTaskStatusResponse
   */
  async updateUserDeliveryTaskStatusWithOptions(request: UpdateUserDeliveryTaskStatusRequest, runtime: $dara.RuntimeOptions): Promise<UpdateUserDeliveryTaskStatusResponse> {
    request.validate();
    let query = OpenApiUtil.query(request.toMap());
    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateUserDeliveryTaskStatus",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateUserDeliveryTaskStatusResponse>(await this.callApi(params, req, runtime), new UpdateUserDeliveryTaskStatusResponse({}));
    } else {
      return $dara.cast<UpdateUserDeliveryTaskStatusResponse>(await this.execute(params, req, runtime), new UpdateUserDeliveryTaskStatusResponse({}));
    }

  }

  /**
   * Changes the status of a delivery task in your Alibaba Cloud account.
   * 
   * @remarks
   * ## [](#)
   * You can call this operation to enable or disable a delivery task by using TaskName and Method. The response includes the most recent status and operation result details of the task.
   * 
   * @param request - UpdateUserDeliveryTaskStatusRequest
   * @returns UpdateUserDeliveryTaskStatusResponse
   */
  async updateUserDeliveryTaskStatus(request: UpdateUserDeliveryTaskStatusRequest): Promise<UpdateUserDeliveryTaskStatusResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateUserDeliveryTaskStatusWithOptions(request, runtime);
  }

  /**
   * Modifies the configurations of a waiting room.
   * 
   * @param tmpReq - UpdateWaitingRoomRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateWaitingRoomResponse
   */
  async updateWaitingRoomWithOptions(tmpReq: UpdateWaitingRoomRequest, runtime: $dara.RuntimeOptions): Promise<UpdateWaitingRoomResponse> {
    tmpReq.validate();
    let request = new UpdateWaitingRoomShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!$dara.isNull(tmpReq.hostNameAndPath)) {
      request.hostNameAndPathShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.hostNameAndPath, "HostNameAndPath", "json");
    }

    let query = { };
    if (!$dara.isNull(request.cookieName)) {
      query["CookieName"] = request.cookieName;
    }

    if (!$dara.isNull(request.customPageHtml)) {
      query["CustomPageHtml"] = request.customPageHtml;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.disableSessionRenewalEnable)) {
      query["DisableSessionRenewalEnable"] = request.disableSessionRenewalEnable;
    }

    if (!$dara.isNull(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!$dara.isNull(request.hostNameAndPathShrink)) {
      query["HostNameAndPath"] = request.hostNameAndPathShrink;
    }

    if (!$dara.isNull(request.jsonResponseEnable)) {
      query["JsonResponseEnable"] = request.jsonResponseEnable;
    }

    if (!$dara.isNull(request.language)) {
      query["Language"] = request.language;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.newUsersPerMinute)) {
      query["NewUsersPerMinute"] = request.newUsersPerMinute;
    }

    if (!$dara.isNull(request.queueAllEnable)) {
      query["QueueAllEnable"] = request.queueAllEnable;
    }

    if (!$dara.isNull(request.queuingMethod)) {
      query["QueuingMethod"] = request.queuingMethod;
    }

    if (!$dara.isNull(request.queuingStatusCode)) {
      query["QueuingStatusCode"] = request.queuingStatusCode;
    }

    if (!$dara.isNull(request.sessionDuration)) {
      query["SessionDuration"] = request.sessionDuration;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.totalActiveUsers)) {
      query["TotalActiveUsers"] = request.totalActiveUsers;
    }

    if (!$dara.isNull(request.waitingRoomId)) {
      query["WaitingRoomId"] = request.waitingRoomId;
    }

    if (!$dara.isNull(request.waitingRoomType)) {
      query["WaitingRoomType"] = request.waitingRoomType;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateWaitingRoom",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateWaitingRoomResponse>(await this.callApi(params, req, runtime), new UpdateWaitingRoomResponse({}));
    } else {
      return $dara.cast<UpdateWaitingRoomResponse>(await this.execute(params, req, runtime), new UpdateWaitingRoomResponse({}));
    }

  }

  /**
   * Modifies the configurations of a waiting room.
   * 
   * @param request - UpdateWaitingRoomRequest
   * @returns UpdateWaitingRoomResponse
   */
  async updateWaitingRoom(request: UpdateWaitingRoomRequest): Promise<UpdateWaitingRoomResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateWaitingRoomWithOptions(request, runtime);
  }

  /**
   * Modifies the configurations of a waiting room event.
   * 
   * @param request - UpdateWaitingRoomEventRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateWaitingRoomEventResponse
   */
  async updateWaitingRoomEventWithOptions(request: UpdateWaitingRoomEventRequest, runtime: $dara.RuntimeOptions): Promise<UpdateWaitingRoomEventResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.customPageHtml)) {
      query["CustomPageHtml"] = request.customPageHtml;
    }

    if (!$dara.isNull(request.description)) {
      query["Description"] = request.description;
    }

    if (!$dara.isNull(request.disableSessionRenewalEnable)) {
      query["DisableSessionRenewalEnable"] = request.disableSessionRenewalEnable;
    }

    if (!$dara.isNull(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!$dara.isNull(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!$dara.isNull(request.jsonResponseEnable)) {
      query["JsonResponseEnable"] = request.jsonResponseEnable;
    }

    if (!$dara.isNull(request.language)) {
      query["Language"] = request.language;
    }

    if (!$dara.isNull(request.name)) {
      query["Name"] = request.name;
    }

    if (!$dara.isNull(request.newUsersPerMinute)) {
      query["NewUsersPerMinute"] = request.newUsersPerMinute;
    }

    if (!$dara.isNull(request.preQueueEnable)) {
      query["PreQueueEnable"] = request.preQueueEnable;
    }

    if (!$dara.isNull(request.preQueueStartTime)) {
      query["PreQueueStartTime"] = request.preQueueStartTime;
    }

    if (!$dara.isNull(request.queuingMethod)) {
      query["QueuingMethod"] = request.queuingMethod;
    }

    if (!$dara.isNull(request.queuingStatusCode)) {
      query["QueuingStatusCode"] = request.queuingStatusCode;
    }

    if (!$dara.isNull(request.randomPreQueueEnable)) {
      query["RandomPreQueueEnable"] = request.randomPreQueueEnable;
    }

    if (!$dara.isNull(request.sessionDuration)) {
      query["SessionDuration"] = request.sessionDuration;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!$dara.isNull(request.totalActiveUsers)) {
      query["TotalActiveUsers"] = request.totalActiveUsers;
    }

    if (!$dara.isNull(request.waitingRoomEventId)) {
      query["WaitingRoomEventId"] = request.waitingRoomEventId;
    }

    if (!$dara.isNull(request.waitingRoomType)) {
      query["WaitingRoomType"] = request.waitingRoomType;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateWaitingRoomEvent",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateWaitingRoomEventResponse>(await this.callApi(params, req, runtime), new UpdateWaitingRoomEventResponse({}));
    } else {
      return $dara.cast<UpdateWaitingRoomEventResponse>(await this.execute(params, req, runtime), new UpdateWaitingRoomEventResponse({}));
    }

  }

  /**
   * Modifies the configurations of a waiting room event.
   * 
   * @param request - UpdateWaitingRoomEventRequest
   * @returns UpdateWaitingRoomEventResponse
   */
  async updateWaitingRoomEvent(request: UpdateWaitingRoomEventRequest): Promise<UpdateWaitingRoomEventResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateWaitingRoomEventWithOptions(request, runtime);
  }

  /**
   * Updates the configurations of a waiting room bypass rule for a website.
   * 
   * @remarks
   * You can call this API operation to modify the configurations of a waiting room bypass rule for your website, including the rule name, status, and rule content.
   * 
   * @param request - UpdateWaitingRoomRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateWaitingRoomRuleResponse
   */
  async updateWaitingRoomRuleWithOptions(request: UpdateWaitingRoomRuleRequest, runtime: $dara.RuntimeOptions): Promise<UpdateWaitingRoomRuleResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.rule)) {
      query["Rule"] = request.rule;
    }

    if (!$dara.isNull(request.ruleEnable)) {
      query["RuleEnable"] = request.ruleEnable;
    }

    if (!$dara.isNull(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.waitingRoomRuleId)) {
      query["WaitingRoomRuleId"] = request.waitingRoomRuleId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UpdateWaitingRoomRule",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UpdateWaitingRoomRuleResponse>(await this.callApi(params, req, runtime), new UpdateWaitingRoomRuleResponse({}));
    } else {
      return $dara.cast<UpdateWaitingRoomRuleResponse>(await this.execute(params, req, runtime), new UpdateWaitingRoomRuleResponse({}));
    }

  }

  /**
   * Updates the configurations of a waiting room bypass rule for a website.
   * 
   * @remarks
   * You can call this API operation to modify the configurations of a waiting room bypass rule for your website, including the rule name, status, and rule content.
   * 
   * @param request - UpdateWaitingRoomRuleRequest
   * @returns UpdateWaitingRoomRuleResponse
   */
  async updateWaitingRoomRule(request: UpdateWaitingRoomRuleRequest): Promise<UpdateWaitingRoomRuleResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.updateWaitingRoomRuleWithOptions(request, runtime);
  }

  /**
   * CA
   * 
   * @param request - UploadClientCaCertificateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UploadClientCaCertificateResponse
   */
  async uploadClientCaCertificateWithOptions(request: UploadClientCaCertificateRequest, runtime: $dara.RuntimeOptions): Promise<UploadClientCaCertificateResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let body : {[key: string ]: any} = { };
    if (!$dara.isNull(request.certificate)) {
      body["Certificate"] = request.certificate;
    }

    if (!$dara.isNull(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApiUtil.Params({
      action: "UploadClientCaCertificate",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UploadClientCaCertificateResponse>(await this.callApi(params, req, runtime), new UploadClientCaCertificateResponse({}));
    } else {
      return $dara.cast<UploadClientCaCertificateResponse>(await this.execute(params, req, runtime), new UploadClientCaCertificateResponse({}));
    }

  }

  /**
   * CA
   * 
   * @param request - UploadClientCaCertificateRequest
   * @returns UploadClientCaCertificateResponse
   */
  async uploadClientCaCertificate(request: UploadClientCaCertificateRequest): Promise<UploadClientCaCertificateResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.uploadClientCaCertificateWithOptions(request, runtime);
  }

  /**
   * Uploads the file that contains resources to be purged or prefetched.
   * 
   * @remarks
   * > 
   * *   The file can be up to 10 MB in size.
   * 
   * @param request - UploadFileRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UploadFileResponse
   */
  async uploadFileWithOptions(request: UploadFileRequest, runtime: $dara.RuntimeOptions): Promise<UploadFileResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    if (!$dara.isNull(request.type)) {
      query["Type"] = request.type;
    }

    if (!$dara.isNull(request.uploadTaskName)) {
      query["UploadTaskName"] = request.uploadTaskName;
    }

    if (!$dara.isNull(request.url)) {
      query["Url"] = request.url;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "UploadFile",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<UploadFileResponse>(await this.callApi(params, req, runtime), new UploadFileResponse({}));
    } else {
      return $dara.cast<UploadFileResponse>(await this.execute(params, req, runtime), new UploadFileResponse({}));
    }

  }

  /**
   * Uploads the file that contains resources to be purged or prefetched.
   * 
   * @remarks
   * > 
   * *   The file can be up to 10 MB in size.
   * 
   * @param request - UploadFileRequest
   * @returns UploadFileResponse
   */
  async uploadFile(request: UploadFileRequest): Promise<UploadFileResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.uploadFileWithOptions(request, runtime);
  }

  async uploadFileAdvance(request: UploadFileAdvanceRequest, runtime: $dara.RuntimeOptions): Promise<UploadFileResponse> {
    // Step 0: init client
    let accessKeyId = await this._credential.getAccessKeyId();
    let accessKeySecret = await this._credential.getAccessKeySecret();
    let securityToken = await this._credential.getSecurityToken();
    let credentialType = this._credential.getType();
    let openPlatformEndpoint = this._openPlatformEndpoint;
    if ($dara.isNull(openPlatformEndpoint)) {
      openPlatformEndpoint = "openplatform.aliyuncs.com";
    }

    if ($dara.isNull(credentialType)) {
      credentialType = "access_key";
    }

    let authConfig = new $OpenApiUtil.Config({
      accessKeyId: accessKeyId,
      accessKeySecret: accessKeySecret,
      securityToken: securityToken,
      type: credentialType,
      endpoint: openPlatformEndpoint,
      protocol: this._protocol,
      regionId: this._regionId,
    });
    let authClient = new OpenPlatform(authConfig);
    let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
      product: "ESA",
      regionId: this._regionId,
    });
    let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({ });
    let ossConfig = new $OSS.Config({
      accessKeyId: accessKeyId,
      accessKeySecret: accessKeySecret,
      type: "access_key",
      protocol: this._protocol,
      regionId: this._regionId,
    });
    let ossClient : OSS = new OSS(ossConfig);
    let fileObj = new $FileForm.FileField({ });
    let ossHeader = new $OSS.PostObjectRequestHeader({ });
    let uploadRequest = new $OSS.PostObjectRequest({ });
    let ossRuntime = new $OSSUtil.RuntimeOptions({ });
    OpenApiUtil.convert(runtime, ossRuntime);
    let uploadFileReq = new UploadFileRequest({ });
    OpenApiUtil.convert(request, uploadFileReq);
    if (!$dara.isNull(request.urlObject)) {
      authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
      ossConfig.accessKeyId = authResponse.body.accessKeyId;
      ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
      ossClient = new OSS(ossConfig);
      fileObj = new $FileForm.FileField({
        filename: authResponse.body.objectKey,
        content: request.urlObject,
        contentType: "",
      });
      ossHeader = new $OSS.PostObjectRequestHeader({
        accessKeyId: authResponse.body.accessKeyId,
        policy: authResponse.body.encodedPolicy,
        signature: authResponse.body.signature,
        key: authResponse.body.objectKey,
        file: fileObj,
        successActionStatus: "201",
      });
      uploadRequest = new $OSS.PostObjectRequest({
        bucketName: authResponse.body.bucket,
        header: ossHeader,
      });
      await ossClient.postObject(uploadRequest, ossRuntime);
      uploadFileReq.url = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
    }

    let uploadFileResp = await this.uploadFileWithOptions(uploadFileReq, runtime);
    return uploadFileResp;
  }

  /**
   * Verifies the ownership of a website domain. Websites that pass the verification are automatically activated.
   * 
   * @remarks
   * 1.  For a website connected by using NS setup, this operation verifies whether the nameservers of the website are the nameservers assigned by Alibaba Cloud.
   * 2.  For a website connected by using CNAME setup, this operation verifies whether the website has a TXT record whose hostname is  _esaauth.[websiteDomainName] and record value is the value of VerifyCode to the DNS records of your domain. You can see the VerifyCode field in the site information.
   * 
   * @param request - VerifySiteRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns VerifySiteResponse
   */
  async verifySiteWithOptions(request: VerifySiteRequest, runtime: $dara.RuntimeOptions): Promise<VerifySiteResponse> {
    request.validate();
    let query = { };
    if (!$dara.isNull(request.siteId)) {
      query["SiteId"] = request.siteId;
    }

    let req = new $OpenApiUtil.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApiUtil.Params({
      action: "VerifySite",
      version: "2024-09-10",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    if ($dara.isNull(this._signatureVersion) || this._signatureVersion != "v4") {
      return $dara.cast<VerifySiteResponse>(await this.callApi(params, req, runtime), new VerifySiteResponse({}));
    } else {
      return $dara.cast<VerifySiteResponse>(await this.execute(params, req, runtime), new VerifySiteResponse({}));
    }

  }

  /**
   * Verifies the ownership of a website domain. Websites that pass the verification are automatically activated.
   * 
   * @remarks
   * 1.  For a website connected by using NS setup, this operation verifies whether the nameservers of the website are the nameservers assigned by Alibaba Cloud.
   * 2.  For a website connected by using CNAME setup, this operation verifies whether the website has a TXT record whose hostname is  _esaauth.[websiteDomainName] and record value is the value of VerifyCode to the DNS records of your domain. You can see the VerifyCode field in the site information.
   * 
   * @param request - VerifySiteRequest
   * @returns VerifySiteResponse
   */
  async verifySite(request: VerifySiteRequest): Promise<VerifySiteResponse> {
    let runtime = new $dara.RuntimeOptions({ });
    return await this.verifySiteWithOptions(request, runtime);
  }

}
